

\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/level-1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; Level-1.lisp

(in-package "CCL")

(macrolet ((l1-load (name)
	     (let* ((namestring
		     (concatenate 'simple-base-string
                                  "./l1-fasls/"
				  (string name)
                                  (namestring (backend-target-fasl-pathname
                                               *target-backend*)))))
	       `(%fasload ,namestring)))
	   (bin-load (name)
	     (let* ((namestring
		     (concatenate 'simple-base-string
                                  "./bin/"
				  (string name)
                                  (namestring (backend-target-fasl-pathname
                                               *target-backend*)))))
	       `(%fasload ,namestring))))

  (l1-load "l1-cl-package")
  (l1-load "l1-utils")
  (l1-load "l1-init")
  (l1-load "l1-symhash")
  (l1-load "l1-numbers")
  (l1-load "l1-aprims")
  #+ppc-target
  (l1-load "ppc-callback-support")
  #+x86-target
  (l1-load "x86-callback-support")
  #+arm-target
  (l1-load "arm-callback-support")
  (l1-load "l1-callbacks")
  (l1-load "l1-sort")
  (bin-load "lists")
  (bin-load "sequences")
  (l1-load "l1-dcode")
  (l1-load "l1-clos-boot")
  (bin-load "hash")
  (l1-load "l1-clos")
  (bin-load "defstruct")
  (bin-load "dll-node")
  (l1-load "l1-unicode")
  (l1-load "l1-streams")
  (l1-load "linux-files")
  (bin-load "chars")
  (l1-load "l1-files")
  (provide "SEQUENCES")
  (provide "DEFSTRUCT")
  (provide "CHARS")
  (provide "LISTS")
  (provide "DLL-NODE")
  (l1-load "l1-typesys")
  (l1-load "sysutils")
  #+ppc-target
  (l1-load "ppc-threads-utils")
  #+x86-target
  (l1-load "x86-threads-utils")
  #+arm-target
  (l1-load "arm-threads-utils")
  (l1-load "l1-lisp-threads")
  (l1-load "l1-application")
  (l1-load "l1-processes")
  (l1-load "l1-io")
  (l1-load "l1-reader")
  (l1-load "l1-readloop")
  (l1-load "l1-readloop-lds")
  (l1-load "l1-error-system")

  (l1-load "l1-events")
  #+ppc-target
  (l1-load "ppc-trap-support")
  #+x86-target
  (l1-load "x86-trap-support")
  #+arm-target
  (l1-load "arm-trap-support")
  (l1-load "l1-format")
  (l1-load "l1-sysio")
  (l1-load "l1-pathnames")
  (l1-load "l1-boot-lds")

  (l1-load "l1-boot-1")
  (l1-load "l1-boot-2")
  (l1-load "l1-boot-3")

  )

(require "PREPARE-MCL-ENVIRONMENT")
(progn
  (%set-toplevel #'(lambda ()
                     (setq *loading-file-source-file* nil
                           *loading-toplevel-location* nil)
                     (toplevel-loop)))
  (set-user-environment t)
  (toplevel))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/level-1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/arm-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2010 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

#+androidarm-target
(eval-when (:compile-toplevel :execute)
  (def-foreign-type :__sigset_t
      (:struct nil
        (:__val (:array :unsigned-long 32)))) 
  (def-foreign-type nil
      (:struct :sigcontext
        (:trap_no :unsigned-long)
        (:error_code :unsigned-long)
        (:oldmask :unsigned-long)
        (:arm_r0 :unsigned-long)
        (:arm_r1 :unsigned-long)
        (:arm_r2 :unsigned-long)
        (:arm_r3 :unsigned-long)
        (:arm_r4 :unsigned-long)
        (:arm_r5 :unsigned-long)
        (:arm_r6 :unsigned-long)
        (:arm_r7 :unsigned-long)
        (:arm_r8 :unsigned-long)
        (:arm_r9 :unsigned-long)
        (:arm_r10 :unsigned-long)
        (:arm_fp :unsigned-long)
        (:arm_ip :unsigned-long)
        (:arm_sp :unsigned-long)
        (:arm_lr :unsigned-long)
        (:arm_pc :unsigned-long)
        (:arm_cpsr :unsigned-long)
        (:fault_address :unsigned-long)))
  (def-foreign-type :mcontext_t (:struct :sigcontext))
  (def-foreign-type nil
      (:struct :sigaltstack
        (:ss_sp :address)
        (:ss_flags :int)
        (:ss_size :size_t)))
  (def-foreign-type :stack_t (:struct :sigaltstack))
  (def-foreign-type nil
      (:struct :ucontext
        (:uc_flags :unsigned-long)
        (:uc_link (:* (:struct :ucontext)))
        (:uc_stack :stack_t)
        (:uc_mcontext :mcontext_t)
        (:uc_sigmask :__sigset_t)
        (:uc_regspace (:array :unsigned-long 128))))
  (def-foreign-type :ucontext_t (:struct :ucontext)))
  
    
  
  
        
        
#+linuxarm-target
(progn
(defmacro with-xp-registers-and-gpr-offset ((xp register-number)
                                            (registers offset) &body body)
  (let* ((regform `(pref ,xp :ucontext.uc_mcontext)))
    `(with-macptrs ((,registers ,regform))
      (let ((,offset (xp-gpr-offset ,register-number)))
        ,@body))))
(defun xp-gpr-offset (register-number)
  (unless (and (fixnump register-number)
               (<= -3 (the fixnum register-number))
               (< (the fixnum register-number) 18))
    (setq register-number (require-type register-number '(integer -3 (18)))))
  (the fixnum (* (the fixnum (+ register-number 3)) arm::node-size)))
(defconstant xp-cpsr-regno 16)
)

#+darwinarm-target
(progn
(defmacro with-xp-registers-and-gpr-offset ((xp register-number)
                                            (registers offset) &body body)
  (let* ((regform `(pref ,xp :ucontext_t.uc_mcontext.__ss)))
    `(with-macptrs ((,registers ,regform))
      (let ((,offset (xp-gpr-offset ,register-number)))
        ,@body))))
(defun xp-gpr-offset (register-number)
  (unless (and (fixnump register-number)
               (<= 0 (the fixnum register-number))
               (< (the fixnum register-number) 17))
    (setq register-number (require-type register-number '(integer 0 (17)))))
  (the fixnum (* (the fixnum register-number) arm::node-size)))
(defconstant xp-cpsr-regno 16)
)

(defun xp-gpr-lisp (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-object registers offset))))

(defun (setf xp-gpr-lisp) (value xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (%set-object registers offset value)))

(defun xp-gpr-signed-long (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-signed-long registers offset))))

(defun xp-gpr-unsigned-long (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-signed-long registers offset))))

(defun xp-gpr-signed-doubleword (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%%get-signed-longlong registers offset))))
  

(defun xp-gpr-macptr (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-ptr registers offset))))

(defun return-address-offset (xp fn machine-state-offset)
  (with-macptrs ((regs (pref xp #+linuxarm-target :ucontext.uc_mcontext
                                #+darwinarm-target :ucontext_t.uc_mcontext.__ss)))
    (if (functionp fn)
      (or (%code-vector-pc (uvref fn 1) (%inc-ptr regs machine-state-offset))
           (%get-ptr regs machine-state-offset))
      (%get-ptr regs machine-state-offset))))

(defconstant lr-offset-in-register-context
  #+linuxarm-target (get-field-offset :sigcontext.arm_lr)
  #+darwinarm-target (get-field-offset :__darwin_arm_thread_state.__lr))

(defconstant pc-offset-in-register-context
  #+linuxarm-target (get-field-offset :sigcontext.arm_pc)
  #+darwinarm-target (get-field-offset :__darwin_arm_thread_state.__pc))

(defun funcall-with-xp-stack-frames (xp trap-function thunk)
  (cond ((null trap-function)
         ; Maybe inside a subprim from a lisp function
         (let* ((fn (xp-gpr-lisp xp arm::fn))
                (lr (return-address-offset
                     xp fn lr-offset-in-register-context)))
           (if (fixnump lr)
             (let* ((sp (xp-gpr-lisp xp arm::sp))
                    (vsp (xp-gpr-lisp xp arm::vsp))
                    (frame (make-fake-stack-frame sp sp fn lr vsp xp)))
               (declare (dynamic-extent frame))
               (funcall thunk (%dnode-address-of frame)))
             (funcall thunk (xp-gpr-lisp xp arm::sp)))))
        ((eq trap-function (xp-gpr-lisp xp arm::fn))
         (let* ((sp (xp-gpr-lisp xp arm::sp))
                (fn trap-function)
                (lr (return-address-offset
                     xp fn pc-offset-in-register-context))
                (vsp (xp-gpr-lisp xp arm::vsp))
                (frame (make-fake-stack-frame sp sp fn lr vsp xp)))
           (declare (dynamic-extent frame))
           (funcall thunk (%dnode-address-of frame))))
        ((eq trap-function (xp-gpr-lisp xp arm::nfn))
         (let* ((sp (xp-gpr-lisp xp arm::sp))
                (fn (xp-gpr-lisp xp arm::fn))
                (lr (return-address-offset
                     xp fn lr-offset-in-register-context))
                (vsp (xp-gpr-lisp xp arm::vsp))
                (lr-frame (make-fake-stack-frame sp sp fn lr vsp xp))
                (pc-fn trap-function)
                (pc-lr (return-address-offset
                        xp pc-fn pc-offset-in-register-context))
                (pc-frame (make-fake-stack-frame sp (%dnode-address-of lr-frame) pc-fn pc-lr vsp xp)))
           (declare (dynamic-extent lr-frame pc-frame))
           (funcall thunk (%dnode-address-of pc-frame))))
        (t (funcall thunk (xp-gpr-lisp xp arm::sp)))))

(defparameter *pending-gc-notification-hook* nil)

(defcallback xcmain (:address xp
                              :signed-fullword signal
                              :signed-fullword arg
                              :signed-fullword fnreg
                              :signed-fullword offset)
  (with-xp-stack-frames (xp (unless (eql 0 fnreg) (xp-gpr-lisp xp fnreg)) frame-ptr)
    (cond ((eql signal 0) (cmain))
          ((or (eql signal #$SIGBUS)
               (eql signal #$SIGSEGV))
           (%error (make-condition 'invalid-memory-access
                                   :address arg
                                   :write-p (eql signal #$SIGBUS))
                   ()
                   frame-ptr))
          ((eql signal #$SIGTRAP)
           (let* ((hook *pending-gc-notification-hook*))
               (declare (special *pending-gc-notification-hook*))
               (when hook (funcall hook))))
          (t
           (error "cmain callback: signal = ~d, arg = #x~x, fnreg = ~d, offset = ~d"
                  signal arg fnreg offset)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/arm-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-dcode.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


(in-package "CCL")






(defun %make-gf-instance (class &key
                                name
                                (method-combination *standard-method-combination* mcomb-p)
                                (method-class *standard-method-class* mclass-p)
                                declarations
                                (lambda-list nil ll-p)
                                (argument-precedence-order nil apo-p)
                                &allow-other-keys)
  (when mcomb-p
    (unless (typep method-combination 'method-combination)
      (report-bad-arg method-combination 'method-combination)))
  (when mclass-p
    (if (symbolp method-class)
      (setq method-class (find-class method-class)))
    (unless (subtypep method-class *method-class*)
      (error "~s is not a subtype of ~s." method-class *method-class*)))
  (when declarations
    (unless (list-length declarations)
      (error "~s is not a proper list" declarations)))
  ;; Fix APO, lambda-list
  (if apo-p
    (if (not ll-p)
      (error "Cannot specify ~s without specifying ~s" :argument-precedence-order
	     :lambda-list)))
  (let* ((gf (%allocate-gf-instance class)))
    (setf (sgf.name gf) name
          (sgf.method-combination gf) method-combination
          (sgf.methods gf) nil
          (sgf.method-class gf) method-class
          (sgf.decls gf) declarations
          (sgf.%lambda-list gf) :unspecified
	  (sgf.dependents gf) nil)
    (when ll-p
      (if apo-p
        (set-gf-arg-info gf :lambda-list lambda-list
                         :argument-precedence-order argument-precedence-order)
        (set-gf-arg-info gf :lambda-list lambda-list)))
    gf))

(defun gf-arg-info-valid-p (gf)
  (let* ((bits (lfun-bits gf)))
    (declare (fixnum bits))
    (not (and (logbitp $lfbits-aok-bit bits)
	      (not (logbitp $lfbits-keys-bit bits))))))

;;; Derive a GF lambda list from the method's lambda list.
(defun flatten-method-lambda-list (lambda-list)
  (collect ((ll))
    (dolist (x lambda-list (ll))
      (if (atom x)
        (if (eq x '&aux)
          (return (ll))
          (ll x))
        (ll (car x))))))
          
(defun %maybe-compute-gf-lambda-list (gf method)
  (let* ((gf-ll (sgf.%lambda-list gf)))
    (if (eq gf-ll :unspecified)
      (and method
           (let* ((method-lambda-list (%method-lambda-list method))
                  (method-has-&key (member '&key method-lambda-list))
                  (method-has-&allow-other-keys
                   (member '&allow-other-keys method-lambda-list)))
             (if method-has-&key
               (nconc (ldiff method-lambda-list (cdr method-has-&key))
                      (if method-has-&allow-other-keys
                        '(&allow-other-keys)))
               (flatten-method-lambda-list method-lambda-list))))
      gf-ll)))
             
             
;;; Borrowed from PCL, sort of.  We can encode required/optional/restp/keyp
;;; information in the gf's lfun-bits
(defun set-gf-arg-info (gf &key new-method (lambda-list nil lambda-list-p)
                           (argument-precedence-order nil apo-p))
  (let* ((methods (%gf-methods gf))
         (dt (%gf-dispatch-table gf))
         (gf-lfun-bits (lfun-bits gf))
         (first-method-p (and new-method (null methods))))
    (declare (fixnum gf-lfun-bits))
    (unless lambda-list-p
      (setq lambda-list
            (%maybe-compute-gf-lambda-list gf (or (car (last methods))
                                                  new-method))))
    (when (or lambda-list-p
              (and first-method-p
                   (eq (%gf-%lambda-list gf) :unspecified)))
      (multiple-value-bind (newbits keyvect)
          (encode-lambda-list lambda-list t)
        (declare (fixnum newbits))
        (when (and methods (not first-method-p))
          (unless (and (= (ldb $lfbits-numreq gf-lfun-bits)
                          (ldb $lfbits-numreq newbits))
                       (= (ldb $lfbits-numopt gf-lfun-bits)
                          (ldb $lfbits-numopt newbits))
                       (eq (or (logbitp $lfbits-keys-bit gf-lfun-bits)
                               (logbitp $lfbits-rest-bit gf-lfun-bits)
                               (logbitp $lfbits-restv-bit gf-lfun-bits))
                           (or (logbitp $lfbits-keys-bit newbits)
                               (logbitp $lfbits-rest-bit newbits)
                               (logbitp $lfbits-restv-bit newbits))))
            (cerror (format nil
                            "Remove ~d method~:p from the generic-function and ~
                             change its lambda list."
                            (length (%gf-methods gf)))
                    "New lambda list of generic function ~s is not congruent ~
                     with lambda lists of existing methods.~%~
                     Generic-function's   : ~s~%~
                     Method's lambda-list : ~s~%"
                    gf lambda-list (%method-lambda-list (car methods)))
            (loop
               (let ((methods (%gf-methods gf)))
                 (if methods
                     (remove-method gf (car methods))
                     (return))))
            (%set-defgeneric-keys gf nil)))
        (when lambda-list-p
          (setf (%gf-%lambda-list gf) lambda-list
                (%gf-dispatch-table-keyvect dt) keyvect))
        (when (and apo-p lambda-list-p)
          (let* ((old-precedence-list (%gf-dispatch-table-precedence-list dt)))
            (setf (%gf-dispatch-table-precedence-list dt)
                  (canonicalize-argument-precedence-order
                   argument-precedence-order
                   (required-lambda-list-args lambda-list)))
            (unless (equal old-precedence-list
                           (%gf-dispatch-table-precedence-list dt))
              (clear-gf-dispatch-table dt))))
        (lfun-bits gf (logior (ash 1 $lfbits-gfn-bit)
                              (logand $lfbits-args-mask newbits)))))
    (when new-method
      (check-defmethod-congruency gf new-method))))
        
(defun %gf-name (gf &optional (new-name nil new-name-p))
  (let* ((old-name (%standard-generic-function-instance-location-access
                    gf sgf.name)))
    (if new-name-p
      (setf (sgf.name gf) new-name))
    (unless (eq old-name (%slot-unbound-marker))
      old-name)))



	     
(defun make-n+1th-arg-combined-method (methods gf argnum)
  (let ((table (make-gf-dispatch-table)))
    (setf (%gf-dispatch-table-methods table) methods
          (%gf-dispatch-table-argnum table) (%i+ 1 argnum))
    (let ((self (%cons-combined-method gf table #'%%nth-arg-dcode))) ; <<
      (setf (%gf-dispatch-table-gf table) self)
      self)))

;;; Bring the generic function to the smallest possible size by removing
;;; any cached recomputable info.  Currently this means clearing out the
;;; combined methods from the dispatch table.

(defun clear-gf-cache (gf)
  #-bccl (unless t (typep gf 'standard-generic-function) 
                 (report-bad-arg gf 'standard-generic-function))
  (let ((dt (%gf-dispatch-table gf)))
    (unless (< (%gf-dispatch-table-argnum dt) 0) ;reader-method optimization
      (if (eq (%gf-dispatch-table-size dt) *min-gf-dispatch-table-size*)
        (clear-gf-dispatch-table dt)
        (let ((new (make-gf-dispatch-table)))
          (setf (%gf-dispatch-table-methods new) (%gf-dispatch-table-methods dt))
          (setf (%gf-dispatch-table-precedence-list new)
                (%gf-dispatch-table-precedence-list dt))
          (setf (%gf-dispatch-table-gf new) gf)
          (setf (%gf-dispatch-table-keyvect new)
                (%gf-dispatch-table-keyvect dt))
          (setf (%gf-dispatch-table-argnum new) (%gf-dispatch-table-argnum dt))
          (setf (%gf-dispatch-table gf) new))))))

(defun %gf-dispatch-table-store-conditional (dt index new)
  "Returns T if the new value can be stored in DT at INDEX, replacing a NIL.
   Returns NIL - without storing anything - if the value already in DT
   at INDEX is non-NIL at the time of the store."
  (let ((offset (+ (ash (%i+ index %gf-dispatch-table-first-data)
                        target::word-shift)
                   target::misc-data-offset)))
    (or (%store-node-conditional offset dt nil new)
        (%store-node-conditional offset dt *gf-dispatch-bug* new))))

(defun grow-gf-dispatch-table (gf-or-cm wrapper table-entry &optional obsolete-wrappers-p)
  ;; Grow the table associated with gf and insert table-entry as the value for
  ;; wrapper.  Wrapper is a class-wrapper.  Assumes that it is not obsolete.
  (let* ((dt (if (generic-function-p gf-or-cm)
               (%gf-dispatch-table gf-or-cm)
               (%combined-method-methods gf-or-cm)))
         (size (%gf-dispatch-table-size dt))
         (new-size (if obsolete-wrappers-p
                     size
                     (%i+ size size)))
         new-dt)
    (if (> new-size *max-gf-dispatch-table-size*)
      (progn 
        (setq new-dt (clear-gf-dispatch-table dt)
                   *gf-dt-ovf-cnt* (%i+ *gf-dt-ovf-cnt* 1)))
      (progn
        (setq new-dt (make-gf-dispatch-table new-size))
        (setf (%gf-dispatch-table-methods new-dt) (%gf-dispatch-table-methods dt)
              (%gf-dispatch-table-precedence-list new-dt) (%gf-dispatch-table-precedence-list dt)
              (%gf-dispatch-table-keyvect new-dt) (%gf-dispatch-table-keyvect dt)
              (%gf-dispatch-table-gf new-dt) gf-or-cm
              (%gf-dispatch-table-argnum new-dt) (%gf-dispatch-table-argnum dt))
        (let ((i 0) index w cm)
          (dotimes (j (%ilsr 1 (%gf-dispatch-table-size dt)))
	    (declare (fixnum j))
            (unless (or (null (setq w (%gf-dispatch-table-ref dt i)))
                        (eql 0 (%wrapper-hash-index w))
                        (no-applicable-method-cm-p
                         (setq cm (%gf-dispatch-table-ref dt (%i+ i 1)))))
              (setq index (find-gf-dispatch-table-index new-dt w t))
              (setf (%gf-dispatch-table-ref new-dt index) w)
              (setf (%gf-dispatch-table-ref new-dt (%i+ index 1)) cm))
            (setq i (%i+ i 2))))))
    (let ((index (find-gf-dispatch-table-index new-dt wrapper t)))
      (setf (%gf-dispatch-table-ref new-dt index) wrapper)
      (setf (%gf-dispatch-table-ref new-dt (%i+ index 1)) table-entry))
    (if (generic-function-p gf-or-cm)
      (setf (%gf-dispatch-table gf-or-cm) new-dt)
      (setf (%combined-method-methods gf-or-cm) new-dt))))


(defun inner-lfun-bits (function &optional value)
  (lfun-bits (closure-function function) value))



;;; probably want to use alists vs. hash-tables initially


;;; only used if error - well not really
(defun collect-lexpr-args (args first &optional last) 
  (if (listp args)
    (subseq args first (or last (length args)))
    (let ((res nil))
      (when (not last)(setq last (%lexpr-count args)))
      (dotimes (i (- last first))
        (setq res (push (%lexpr-ref args last (+ first i)) res)))
      (nreverse res))))




(defmacro with-list-from-lexpr ((list lexpr) &body body)
  (let ((len (gensym)))
    `(let* ((,len (%lexpr-count ,lexpr))
            (,list  (make-list ,len)))
       (declare (dynamic-extent ,list) (fixnum ,len))       
       (do* ((i 0 (1+ i))
             (ls ,list (cdr ls)))
            ((= i ,len) ,list)
         (declare (fixnum i) (list ls))
         (declare (optimize (speed 3)(safety 0)))
         (%rplaca ls (%lexpr-ref ,lexpr ,len i)))
       ,@body)))



(defmacro %standard-instance-p (i)
  `(eq (typecode ,i) ,(type-keyword-code :instance)))



(declaim (inline %find-1st-arg-combined-method))
(declaim (inline %find-nth-arg-combined-method))




(defun %find-1st-arg-combined-method (dt arg)
  (let ((wrapper (instance-class-wrapper arg)))
    (when (eql 0 (%wrapper-hash-index wrapper))
      (update-obsolete-instance arg)
      (setq wrapper (instance-class-wrapper arg)))
    (let* ((mask (%gf-dispatch-table-mask dt))
           (index (%ilsl 1 (%ilogand mask (%wrapper-hash-index wrapper))))
           table-wrapper flag)
      (declare (fixnum index mask))
      (loop 
        (if (eq (setq table-wrapper (%gf-dispatch-table-ref dt index)) wrapper)
          (return (%gf-dispatch-table-ref dt  (the fixnum (1+ index))))
          (progn
            (when (null (%gf-dispatch-table-ref dt (the fixnum (1+ index))))
              (if (or (neq table-wrapper (%unbound-marker))
                      (eql 0 flag))
                (without-interrupts     ; why?
                 (return (1st-arg-combined-method-trap (%gf-dispatch-table-gf dt) wrapper arg))) ; the only difference?
                (setq flag 0 index -2)))
            (setq index (+ 2 index))))))))

;;; for calls from outside - e.g. stream-reader
(defun find-1st-arg-combined-method (gf arg)
  (declare (optimize (speed 3)(safety 0)))
  (%find-1st-arg-combined-method (%gf-dispatch-table gf) arg))


;;; more PC - it it possible one needs to go round more than once? -
;;; seems unlikely
(defun %find-nth-arg-combined-method (dt arg args)  
  (declare (optimize (speed 3)(safety 0)))
  (let ((wrapper (instance-class-wrapper arg)))
    (when (eql 0 (%wrapper-hash-index wrapper))
      (update-obsolete-instance arg)
      (setq wrapper (instance-class-wrapper arg)))
    (let* ((mask (%gf-dispatch-table-mask dt))
           (index (%ilsl 1 (%ilogand mask (%wrapper-hash-index wrapper))))
           table-wrapper flag)
      (declare (fixnum index mask))
      (loop 
        (if (eq (setq table-wrapper (%gf-dispatch-table-ref dt index)) wrapper)
          (return (%gf-dispatch-table-ref dt (the fixnum (1+ index))))
          (progn
            (when (null (%gf-dispatch-table-ref dt (the fixnum (1+ index))))
              (if (or (neq table-wrapper (%unbound-marker))
                      (eql 0 flag))
                (without-interrupts     ; why?
                 (let ((gf (%gf-dispatch-table-gf dt)))
                   (if (listp args)
                     (return (nth-arg-combined-method-trap-0 gf dt wrapper args))
                     (with-list-from-lexpr (args-list args)
                       (return (nth-arg-combined-method-trap-0 gf dt wrapper args-list))))))
                (setq flag 0 index -2)))
            (setq index (+ 2 index))))))))




;;;;;;;;;;;;;;;;;;;;;;;;;;; Generic functions and methods ;;;;;;;;;;;;;;;;;;;;
(defun %class-cpl (class)
  (if (%standard-instance-p class)
    (%class.cpl class)
    (or
     (and (typep class 'macptr)
	  (let* ((slots (foreign-slots-vector class)))
	    (and slots (%slot-ref slots %class.cpl))))
     (error "Can't determine CPL of class ~s" class))))


(defun standard-method-p (thing)
  (when (%standard-instance-p thing)
    (let* ((cpl (%class-cpl (%wrapper-class (instance.class-wrapper thing))))
           (smc *standard-method-class*))
      (dolist (c cpl)
        (if (eq c smc)(return t))))))



(defun %method-function-p (thing)
  (when (functionp thing)
    (let ((bits (lfun-bits thing)))
      (declare (fixnum bits))
      (logbitp $lfbits-method-bit bits))))




(setf (type-predicate 'standard-generic-function) 'standard-generic-function-p)
(setf (type-predicate 'combined-method) 'combined-method-p)

(setf (type-predicate 'standard-method) 'standard-method-p)

;; Maybe we shouldn't make this a real type...
(setf (type-predicate 'method-function) '%method-function-p)


(defvar %all-gfs% (%cons-population nil))


(eval-when (:compile-toplevel :execute)
(defconstant $lfbits-numinh-mask (logior (dpb -1 $lfbits-numinh 0)
                                         (%ilsl $lfbits-nonnullenv-bit 1)))
)


#+ppc-target
(defvar *fi-trampoline-code* (uvref #'funcallable-trampoline 0))
#+arm-target
(defvar *fi-trampoline-code* (uvref #'funcallable-trampoline 1))


#+ppc-target
(defvar *unset-fin-code* (uvref #'unset-fin-trampoline 0))
#+arm-target
(defvar *unset-fin-code* (uvref #'unset-fin-trampoline 1))


#+ppc-target
(defvar *gf-proto-code* (uvref *gf-proto* 0))
#+arm-target
(defvar *gf-proto-code* (uvref *gf-proto* 1))

;;; The "early" version of %ALLOCATE-GF-INSTANCE.
(setf (fdefinition '%allocate-gf-instance)
      #'(lambda (class)
	  (declare (ignorable class))
	  (setq class *standard-generic-function-class*)
	  (let* ((wrapper (%class.own-wrapper class))
		 (len (length #.(%wrapper-instance-slots (class-own-wrapper
							  *standard-generic-function-class*))))
		 (dt (make-gf-dispatch-table))
		 (slots (allocate-typed-vector :slot-vector (1+ len) (%slot-unbound-marker)))
		 (fn #+(or ppc-target arm-target)
                     (#+arm-target
                      %fix-fn-entrypoint
                      #-arm-target
                      progn
                      (gvector :function
                            #+arm-target 0
			      *gf-proto-code*
			      wrapper
			      slots
			      dt
			      #'%%0-arg-dcode
			      0
			      (%ilogior (%ilsl $lfbits-gfn-bit 1)
					(%ilogand $lfbits-args-mask 0))))
                   #+x86-target
                   (%clone-x86-function *gf-proto*
                                        wrapper
                                        slots
                                        dt
                                        #'%%0-arg-dcode
                                        0
                                        (%ilogior (%ilsl $lfbits-gfn-bit 1)
                                                  (%ilogand $lfbits-args-mask 0)))))
	    (setf ;(gf.hash fn) (strip-tag-to-fixnum fn)
		  (slot-vector.instance slots) fn
		  (%gf-dispatch-table-gf dt) fn)
	    (push fn (population.data %all-gfs%))
	    fn)))






  


(defparameter *gf-proto-one-arg*  #'gag-one-arg)
(defparameter *gf-proto-two-arg*  #'gag-two-arg)




#+ppc-target
(defvar *cm-proto-code* (uvref *cm-proto* 0))

#+arm-target
(defvar *cm-proto-code* (uvref *cm-proto* 1))

(defun %cons-combined-method (gf thing dcode)
  ;; set bits and name = gf
  #+(or ppc-target arm-target)
  (#+arm-target
   %fix-fn-entrypoint
   #-arm-target
   progn
   (gvector :function          
           #+arm-target 0
           *cm-proto-code*
           thing
           dcode
           gf
           (%ilogior (%ilsl $lfbits-cm-bit 1)
                            (%ilogand $lfbits-args-mask (lfun-bits gf)))))
  #+x86-target
  (%clone-x86-function *cm-proto*
                       thing
                       dcode
                       gf
                       (%ilogior (%ilsl $lfbits-cm-bit 1)
                                 (%ilogand $lfbits-args-mask (lfun-bits gf)))))

(defun %gf-dispatch-table (gf)
  ;(require-type gf 'standard-generic-function)
  (gf.dispatch-table gf))

(defun %gf-dcode (gf)
  ;(require-type gf 'standard-generic-function)
  (gf.dcode gf))

(defun %set-gf-dcode (gf dcode)
  (let ((gf (require-type gf 'funcallable-standard-object))
        (dcode (require-type dcode 'function)))
    (replace-function-code gf (or (cdr (assq dcode dcode-proto-alist))
                                  #'funcallable-trampoline))
    (setf (gf.dcode gf) dcode)))

(defun %set-gf-dispatch-table (gf val)
  (setf (gf.dispatch-table gf) val))

(defun %combined-method-methods  (cm)
  ;(require-type cm 'combined-method)
  (combined-method.thing cm))

(defun %combined-method-dcode (cm)
  ;(require-type cm 'combined-method)
  (combined-method.dcode cm))

(defun %set-combined-method-methods (cm val)
  (setf (combined-method.thing cm) val))

(defun %set-combined-method-dcode (cm val)
  (setf (combined-method.dcode cm) val))

(declaim (inline funcallable-instance-p))
(defun funcallable-instance-p (thing)
  (when (typep thing 'function)
    (let ((bits (lfun-bits-known-function thing)))
      (declare (fixnum bits))
      (eq (ash 1 $lfbits-gfn-bit)
	  (logand bits (logior (ash 1 $lfbits-gfn-bit)
			       (ash 1 $lfbits-method-bit)))))))

(setf (type-predicate 'funcallable-standard-object) 'funcallable-instance-p)

(defstatic *generic-function-class-wrapper* nil)
(defstatic *standard-generic-function-class-wrapper* nil)

(defun generic-function-p (thing)
  (and (typep thing 'funcallable-standard-object)
       (let* ((wrapper (gf.instance.class-wrapper thing)))
         ;; In practice, many generic-functions are standard-generic-functions.
         (or (eq *standard-generic-function-class-wrapper* wrapper)
             (eq *generic-function-class-wrapper* wrapper)
             (let* ((bits (or (%wrapper-cpl-bits wrapper)
                              (make-cpl-bits (%inited-class-cpl (%wrapper-class wrapper)))))
                    (ordinal (%wrapper-class-ordinal *generic-function-class-wrapper*)))
               (and bits ordinal
                    (locally (declare (simple-bit-vector bits)
                                      (fixnum ordinal)
                                      (optimize (speed 3) (safety 0)))
                      (and (< ordinal (length bits))
                           (eql 1 (sbit bits ordinal))))))))))


(defun standard-generic-function-p (thing)
  (and (typep thing 'function)
       (let ((bits (lfun-bits-known-function thing)))
	 (declare (fixnum bits))
	 (eq (ash 1 $lfbits-gfn-bit)
	     (logand bits (logior (ash 1 $lfbits-gfn-bit)
				  (ash 1 $lfbits-method-bit)))))
       (or (eq (%class.own-wrapper *standard-generic-function-class*)
	       (gf.instance.class-wrapper thing))
	   (memq  *standard-generic-function-class*
		  (%inited-class-cpl (class-of thing))))))


(defun combined-method-p (thing)
  (when (functionp thing)
    (let ((bits (lfun-bits-known-function thing)))
      (declare (fixnum bits))
      (eq (ash 1 $lfbits-cm-bit)
	  (logand bits
		  (logior (ash 1 $lfbits-cm-bit)
			  (ash 1 $lfbits-method-bit)))))))

(setf (type-predicate 'generic-function) 'generic-function-p)

(setf (type-predicate 'standard-generic-function) 'standard-generic-function-p)
(setf (type-predicate 'funcallable-standard-object) 'funcallable-instance-p)
(setf (type-predicate 'combined-method) 'combined-method-p)



;;; A generic-function looks like:
;;; 
;;; header | trampoline |  dispatch-table | dcode | name | bits
;;; %svref :    0              1              2       3      4
;;;
;;; The trampoline is *gf-proto*'s code vector.
;;; The dispatch-table and dcode are sort of settable closed-over variables.

(defsetf %gf-dispatch-table %set-gf-dispatch-table)

(defun %gf-methods (gf)
  (sgf.methods gf))

(defun %gf-precedence-list (gf)
  (%gf-dispatch-table-precedence-list (%gf-dispatch-table gf)))

(defun %gf-%lambda-list (gf)
  (sgf.%lambda-list gf))

(defun (setf %gf-%lambda-list) (new gf)
  (setf (sgf.%lambda-list gf) new))

;;; Returns INSTANCE if it is either a standard instance of a
;;; standard gf, else nil.
(defun %maybe-gf-instance (instance)
  (if (or (standard-generic-function-p instance)
	  (%standard-instance-p instance))
    instance))

(defsetf %gf-dcode %set-gf-dcode)

(defun %gf-method-class (gf)
  (sgf.method-class gf))


(defun %gf-method-combination (gf)
  (sgf.method-combination gf))

; need setters too

(defsetf %combined-method-methods %set-combined-method-methods)

(defparameter *min-gf-dispatch-table-size* 2
  "The minimum size of a generic-function dispatch table")

(defun make-gf-dispatch-table (&optional (size *min-gf-dispatch-table-size*))
  (when (<= size 0) (report-bad-arg size '(integer 1)))
  (setq size (%imax (%ilsl (%i- (integer-length (%i+ size size -1))
                                1)
                           1)           ; next power of 2
                    *min-gf-dispatch-table-size*))
  (let ((res (%cons-gf-dispatch-table size)))
    (declare (optimize (speed 3) (safety 0)))
    (setf (%gf-dispatch-table-mask res) (%i- (%ilsr 1 size) 1)
          (%gf-dispatch-table-argnum res) 0
          (%gf-dispatch-table-ref res size) (%unbound-marker))
    res))

;;; I wanted this to be faster - I didn't
(defun clear-gf-dispatch-table (dt)
  (let ((i %gf-dispatch-table-first-data))
    (dotimes (j (%gf-dispatch-table-size dt))
      (declare (fixnum j))
      (setf (%svref dt i) nil 
            i (%i+ i 1)))
    (setf (%svref dt i) (%unbound-marker)) ; paranoia...
    (setf (svref dt (%i+ 1 i)) nil))
  dt)


; Remove all combined-methods from the world
(defun clear-all-gf-caches ()
  (dolist (f (population-data %all-gfs%))
    (clear-gf-cache f))
  (clrhash *combined-methods*)
  nil)


;;; Searches for an empty slot in dt at the hash-index for wrapper.
;;; Returns nil if the table was full.
(defun find-gf-dispatch-table-index (dt wrapper &optional skip-full-check?)
  (let ((contains-obsolete-wrappers-p nil)
        (mask (%gf-dispatch-table-mask dt)))
    (declare (fixnum mask))
    (unless skip-full-check?
      (let* ((size (1+ mask))
             (max-count (- size (the fixnum (ash (the fixnum (+ size 3)) -2))))
             (index 0)
             (count 0))
        (declare (fixnum size max-count index count))
        (dotimes (i size)
          (declare (fixnum i))
          (let ((wrapper (%gf-dispatch-table-ref dt index)))
            (if wrapper
              (if (eql 0 (%wrapper-hash-index wrapper))
                (setf contains-obsolete-wrappers-p t
                      (%gf-dispatch-table-ref dt index) *obsolete-wrapper*
                      (%gf-dispatch-table-ref dt (1+ index)) *gf-dispatch-bug*)
                (setq count (%i+ count 1)))))
          (setq index (%i+ index 2)))
        (when (> count max-count)
          (return-from find-gf-dispatch-table-index (values nil contains-obsolete-wrappers-p)))))
    (let* ((index (ash (logand mask (%wrapper-hash-index wrapper)) 1))
           (flag nil)
           table-wrapper)      
      (values
       (loop
         (while (and (neq wrapper
                          (setq table-wrapper (%gf-dispatch-table-ref dt index)))
                     (%gf-dispatch-table-ref dt (1+ index))
                     (neq 0 (%wrapper-hash-index table-wrapper)))
           (setq index (%i+ index 2)))
         (if (eq (%unbound-marker) table-wrapper)
           (if flag
             (return nil)         ; table full
             (setq flag 1
                   index 0))
           (return index)))
       contains-obsolete-wrappers-p))))


(defvar *obsolete-wrapper* #(obsolete-wrapper 0))
(defvar *gf-dispatch-bug*
  #'(lambda (&rest rest)
      (declare (ignore rest))
      (error "Generic-function dispatch bug!")))

  
;;; This maximum is necessary because of the 32 bit arithmetic in
;;; find-gf-dispatch-table-index.
(defparameter *max-gf-dispatch-table-size* (expt 2 16))
(defvar *gf-dt-ovf-cnt* 0)              ; overflow count

(defvar *no-applicable-method-hash* nil)


(let* ((eql-specializers-lock (make-lock))
       (eql-specializers-hash (make-hash-table :test #'eql  :weak :value)))
  (defun intern-eql-specializer (object)
    (with-lock-grabbed (eql-specializers-lock)
      (or (gethash object eql-specializers-hash)
	  (setf (gethash object eql-specializers-hash)
		(make-instance 'eql-specializer :object object))))))


(setq *no-applicable-method-hash* (make-hash-table :test 'eq :size 0 :weak :key))


(defun make-no-applicable-method-function (gf)
  (if *no-applicable-method-hash*
    (progn
      (or (gethash gf *no-applicable-method-hash*))
      (setf (gethash gf *no-applicable-method-hash*)
            (%cons-no-applicable-method gf)))
    (%cons-no-applicable-method gf)))

(defun %cons-no-applicable-method (gf)
  (%cons-combined-method gf gf #'%%no-applicable-method))

; Returns true if F is a combined-method that calls no-applicable-method
(defun no-applicable-method-cm-p (f)
  (and (typep f 'combined-method)
       (eq '%%no-applicable-method
           (function-name (%combined-method-dcode f)))))


(defun %%no-applicable-method (gf args)
  (if (listp args)
    (apply #'no-applicable-method gf args)
    (%apply-lexpr #'no-applicable-method gf args )))

;;; if obsolete-wrappers-p is true, will rehash instead of grow.
;;; It would be better to do the rehash in place, but I'm lazy today.


(defun arg-wrapper (arg)
  (or (standard-object-p arg)
      (%class.own-wrapper (class-of arg))
      (error "~a has no wrapper" arg)))

;;;;;;;;;;;;;;;;;;;;;;;;; generic-function dcode ;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; dcode functions using other than *gf-proto*
(defparameter dcode-proto-alist ())

(defun register-dcode-proto (dcode proto)
  (let ((a (assoc dcode dcode-proto-alist)))
    (if a
      (setf (cdr a) proto)
      (push (cons dcode proto) dcode-proto-alist))))


;;; Simple case for generic-functions with no specializers
;;; Why anyone would want to do this I can't imagine.

(defun %%0-arg-dcode (dispatch-table args) ; need to get gf from table
  (let ((method (or (%gf-dispatch-table-ref dispatch-table 1)
                    (0-arg-combined-method-trap
                     (%gf-dispatch-table-gf dispatch-table)))))
    (if (not (listp args))
      (progn
        (%apply-lexpr-tail-wise method args))
      (apply method args))))

(register-dcode-proto #'%%0-arg-dcode *gf-proto*)

(defun dcode-too-few-args (arg-count cm-or-gf)
  (error (make-condition 'too-few-arguments
                         :nargs arg-count
                         :fn (combined-method-gf cm-or-gf))))



(defun %%1st-arg-dcode (dt  args)
  ;(declare (dynamic-extent args))
  (if (not (listp args))
    (let* ((args-len (%lexpr-count args)))
      (if (neq 0 args-len) 
        (let ((method (%find-1st-arg-combined-method dt (%lexpr-ref args args-len 0))))
	  (%apply-lexpr-tail-wise method args))
        (dcode-too-few-args 0 (%gf-dispatch-table-gf dt))))
    (let* ()  ; happens if traced
      (when (null args) (dcode-too-few-args 0 (%gf-dispatch-table-gf dt)))
      (let ((method (%find-1st-arg-combined-method dt (%car args))))
        (apply method args)))))
(register-dcode-proto #'%%1st-arg-dcode *gf-proto*)

(defun %%one-arg-dcode (dt  arg)
  (let ((method (%find-1st-arg-combined-method dt arg)))
    (funcall method arg)))
(register-dcode-proto #'%%one-arg-dcode *gf-proto-one-arg*)

;;; two args - specialized on first
(defun %%1st-two-arg-dcode (dt arg1 arg2)
  (let ((method (%find-1st-arg-combined-method dt arg1)))
    (funcall method arg1 arg2)))
(register-dcode-proto #'%%1st-two-arg-dcode *gf-proto-two-arg*)


;;;  arg is dispatch-table and argnum is in the dispatch table
(defun %%nth-arg-dcode (dt args)
  (if (listp args)
    (let* ((args-len (list-length args))
           (argnum (%gf-dispatch-table-argnum dt)))
      (declare (fixnum args-len argnum))
      (when (>= argnum args-len) (dcode-too-few-args args-len (%gf-dispatch-table-gf dt)))
      (let ((method (%find-nth-arg-combined-method dt (nth argnum args) args)))
        (apply method args)))
    (let* ((args-len (%lexpr-count args))
           (argnum (%gf-dispatch-table-argnum dt)))
      (declare (fixnum args-len argnum))
      (when (>= argnum args-len) (dcode-too-few-args args-len (%gf-dispatch-table-gf dt)))
      (let ((method (%find-nth-arg-combined-method dt (%lexpr-ref args args-len argnum) args)))
	(%apply-lexpr-tail-wise method args)))))
(register-dcode-proto #'%%nth-arg-dcode *gf-proto*)

(defun 0-arg-combined-method-trap (gf)
  (let* ((methods (%gf-methods gf))
         (mc (%gf-method-combination gf))
         (cm (if (eq mc *standard-method-combination*)
               (make-standard-combined-method methods nil gf)
               (compute-effective-method-function 
                gf 
                mc
                (sort-methods (copy-list methods) nil)))))
    (setf (%gf-dispatch-table-ref (%gf-dispatch-table gf) 1) cm)
    cm))

(defun compute-effective-method-function (gf mc methods)  
  (if methods
    (compute-effective-method gf mc methods)
    (make-no-applicable-method-function gf)))

(defun 1st-arg-combined-method-trap (gf wrapper arg)
  ;; Here when we can't find the method in the dispatch table.
  ;; Compute it and add it to the table.  This code will remain in Lisp.
  (let ((table (%gf-dispatch-table gf))
        (combined-method (compute-1st-arg-combined-method gf arg wrapper)))
    (multiple-value-bind (index obsolete-wrappers-p)
        (find-gf-dispatch-table-index table wrapper)
      (if index
          (if (%gf-dispatch-table-store-conditional table (%i+ index 1) combined-method)
            (setf (%gf-dispatch-table-ref table index) wrapper))
          (grow-gf-dispatch-table gf wrapper combined-method obsolete-wrappers-p)))
    combined-method))

(defvar *cpl-classes* nil)

(defun %inited-class-cpl (class &optional initialize-can-fail)
  (or (%class-cpl class)
      (if (memq class *cpl-classes*)
        (compute-cpl class)
        (let ((*cpl-classes* (cons class *cpl-classes*)))
          (declare (dynamic-extent *cpl-classes*))
          (update-class class initialize-can-fail)
          (%class-cpl class)))))


(defun compute-1st-arg-combined-method (gf arg &optional 
                                           (wrapper (arg-wrapper arg)))
  (let* ((methods (%gf-dispatch-table-methods (%gf-dispatch-table gf)))
         (cpl (%inited-class-cpl (%wrapper-class wrapper)))
         (method-combination (%gf-method-combination gf))
         applicable-methods eql-methods specializer)
    (dolist (method methods)
      (setq specializer (%car (%method.specializers method)))
      (if (typep specializer 'eql-specializer)
        (when (cpl-memq (%wrapper-class (arg-wrapper (eql-specializer-object specializer))) cpl)
          (push method eql-methods))
        (when (cpl-memq specializer cpl)
          (push method applicable-methods))))
    (if (null eql-methods)
      (if (eq method-combination *standard-method-combination*)
        (make-standard-combined-method applicable-methods (list cpl) gf)
        (compute-effective-method-function 
         gf 
         method-combination
         (sort-methods applicable-methods
                       (list cpl)
                       (%gf-precedence-list gf))))
      (make-eql-combined-method  
       eql-methods applicable-methods (list cpl) gf 0 nil method-combination))))
      


(defvar *combined-methods* (make-hash-table  :test 'equal :weak :value))                          

(defun gethash-combined-method (key)
  (gethash key *combined-methods*))

(defun puthash-combined-method (key value)
  (setf (gethash key *combined-methods*) value))

;;; Some statistics on the hash table above
(defvar *returned-combined-methods* 0)
(defvar *consed-combined-methods* 0)

;;; Assumes methods are already sorted if cpls is nil
(defun make-standard-combined-method (methods cpls gf &optional
                                              (ok-if-no-primaries (null methods)))
  (unless (null cpls)
    (setq methods (sort-methods 
                   methods cpls (%gf-precedence-list (combined-method-gf gf)))))
  (let* ((keywords (compute-allowable-keywords-vector gf methods))
         (combined-method (make-standard-combined-method-internal
                           methods gf keywords ok-if-no-primaries)))
    (if (and keywords methods)
      (make-keyword-checking-combined-method gf combined-method keywords)
      combined-method)))


;;; Initialized below after the functions exist.
(defvar *clos-initialization-functions* nil)

;;; Returns NIL if all keywords allowed, or a vector of the allowable ones.
(defun compute-allowable-keywords-vector (gf methods)
  (setq gf (combined-method-gf gf))
  (unless (memq gf *clos-initialization-functions*)
    (let* ((gbits (inner-lfun-bits gf))
           (&key-mentioned-p (logbitp $lfbits-keys-bit gbits)))
      (unless (or (logbitp $lfbits-aok-bit gbits)
                  (dolist (method methods)
                    (let ((mbits (lfun-bits (%method.function method))))
                      (when (logbitp $lfbits-keys-bit mbits)
                        (setq &key-mentioned-p t)
                        (if (logbitp $lfbits-aok-bit mbits)
                          (return t)))))
                  (not &key-mentioned-p))
        (let (keys)
          (flet ((adjoin-keys (keyvect keys)
                              (when keyvect
                                (dovector (key keyvect) (pushnew key keys)))
                              keys))
            (when (logbitp $lfbits-keys-bit gbits)
              (setq keys (adjoin-keys (%defgeneric-keys gf) keys)))
            (dolist (method methods)
              (let ((f (%inner-method-function method)))
                (when (logbitp $lfbits-keys-bit (lfun-bits f))
                  (setq keys (adjoin-keys (lfun-keyvect f) keys))))))
          (apply #'vector keys))))))


(defun make-keyword-checking-combined-method (gf combined-method keyvect)
  (let* ((bits (inner-lfun-bits gf))
         (numreq (ldb $lfbits-numreq bits))
         (key-index (+ numreq (ldb $lfbits-numopt bits))))
    (%cons-combined-method 
     gf       
     (vector key-index keyvect combined-method)
     #'%%check-keywords)))



(defun odd-keys-error (varg l) 
  (let ((gf (combined-method-gf (%svref varg 2))))
    (signal-program-error "Odd number of keyword args to ~s~%keyargs: ~s" gf l)))


(defun bad-key-error (key varg l)
  (let* ((keys (%svref varg 1))
         (gf (combined-method-gf (%svref varg 2)))
         (*print-array* t)
         (*print-readably* t)
         (readable-keys (format nil "~s" keys)))
    (signal-program-error "Bad keyword ~s to ~s.~%keyargs: ~s~%allowable keys are ~a." key gf l readable-keys)))

; vector arg is (vector key-index keyvect combined-method) ; the next combined method

(defun %%check-keywords (vector-arg args)
  (flet ((do-it (vector-arg args)
           (let* ((args-len (length args))
                  (keyvect (%svref vector-arg 1))
                  (keyvect-len (length keyvect))
                  (key-index (%svref vector-arg 0)))
					; vector arg is (vector key-index keyvect combined-method) ; the next combined method
             (declare (fixnum args-len key-index keyvect-len))
             (when (>= args-len key-index)
               (let* ((keys-in (- args-len key-index)))	; actually * 2
                 (declare (fixnum  key-index keys-in keyvect-len))
                 (when (logbitp 0 keys-in) (odd-keys-error vector-arg (collect-lexpr-args args key-index args-len)))
		 (unless (%cadr (%pl-search (nthcdr key-index args) :allow-other-keys))
		   (do ((i key-index (+ i 2))
			(kargs (nthcdr key-index args) (cddr kargs)))
		       ((eq i args-len))
		     (declare (fixnum i))
		     (let ((key (car kargs)))
		       (when (not (or (eq key :allow-other-keys)
				      (dotimes (i keyvect-len nil)
					(if (eq key (%svref keyvect i))
					  (return t)))))
			 (bad-key-error key vector-arg (collect-lexpr-args args key-index args-len))
			 ))))))
             (let ((method (%svref vector-arg 2)))
					; magic here ?? not needed
               (apply method args)))))
    (if (listp args)
      (do-it vector-arg args)
      (with-list-from-lexpr (args-list args)
        (do-it vector-arg args-list)))))



  


;;; called from %%call-next-method-with-args - its the key-or-init-fn 
;;; called from call-next-method-with-args - just check the blooming keys
;;; dont invoke any methods - maybe use x%%check-keywords with last vector elt nil
; means dont call any methods - but need the gf or method for error message
(defun x-%%check-keywords (vector-arg ARGS)
  ;(declare (dynamic-extent args))
    ; vector arg is (vector key-index keyvect unused)
  (let* ((ARGS-LEN (length args))
         (keyvect (%svref vector-arg 1))
         (keyvect-len (length keyvect))
         (key-index (%svref vector-arg 0))
         (keys-in (- args-len key-index))
         aok)  ; actually * 2
    (declare (fixnum args-len key-index keys-in keyvect-len))
    
    (when (logbitp 0 keys-in) (odd-keys-error vector-arg (collect-lexpr-args args key-index args-len)))
    (do ((i key-index (+ i 2))
         (kargs (nthcdr key-index args) (cddr kargs)))
        ((eq i args-len))
      (declare (fixnum i))
      (when aok (return))
      (let ((key (car kargs)))
        (when (and (eq key :allow-other-keys)
                   (cadr kargs))
          (return))
        (when (not (dotimes (i keyvect-len nil)
                     (if (eq key (%svref keyvect i))
                       (return t))))
          ; not found - is :allow-other-keys t in rest of user args
          (when (not (do ((remargs kargs (cddr remargs)))
                         ((null remargs) nil)
                       (when (and (eq (car remargs) :allow-other-keys)
                                  (cadr remargs))
                         (setq aok t)
                         (return t))))              
            (bad-key-error key vector-arg 
                           (collect-lexpr-args args key-index args-len))))))))
#| ; testing
(setq keyvect  #(:a :b ))
(setq foo (make-array 3))
(setf (aref foo 0) keyvect (aref foo 1) 2)
(setf (aref foo 2)(method window-close (window)))
( %%check-keywords 1 2 :a 3 :c 4 foo)
( %%check-keywords 1 2 :a 3 :b 4 :d foo)
|#
 
    



;;; Map an effective-method to it's generic-function.
;;; This is only used for effective-method's which are not combined-method's
;;; (e.g. those created by non-STANDARD method-combination)
(defvar *effective-method-gfs* (make-hash-table :test 'eq :weak :key))


(defun get-combined-method (method-list gf)
  (let ((cm (gethash-combined-method method-list)))
    (when cm
      (setq gf (combined-method-gf gf))
      (if (combined-method-p cm)
        (and (eq (combined-method-gf cm) gf) cm)
        (and (eq (gethash cm *effective-method-gfs*) gf) cm)))))

(defun put-combined-method (method-list cm gf)
  (unless (%method-function-p cm)       ; don't bother with non-combined methods
    (puthash-combined-method method-list cm)
    (unless (combined-method-p cm)
      (setf (gethash cm *effective-method-gfs*) (combined-method-gf gf))))
  cm)

(defun make-standard-combined-method-internal (methods gf &optional 
                                                       keywords
                                                       (ok-if-no-primaries
                                                        (null methods)))
  (let ((method-list (and methods (compute-method-list methods nil))))
    (if method-list                 ; no applicable primary methods
      (if (atom method-list)
        (%method.function method-list)    ; can jump right to the method-function
        (progn
          (incf *returned-combined-methods*)  ; dont need this
          (if (contains-call-next-method-with-args-p method-list)
            (make-cnm-combined-method gf methods method-list keywords)
            (or (get-combined-method method-list gf)
                (progn
                  (incf *consed-combined-methods*)  ; dont need this
                  (puthash-combined-method
                   method-list
                   (%cons-combined-method
                    gf method-list #'%%standard-combined-method-dcode)))))))
      (if ok-if-no-primaries
        (make-no-applicable-method-function (combined-method-gf gf))
        (no-applicable-primary-method gf methods)))))

; Initialized after the initialization (generic) functions exist.
(defvar *initialization-functions-alist* nil)

;;; This could be in-line above, but I was getting confused.

;;; ok
(defun make-cnm-combined-method (gf methods method-list keywords)
  (setq gf (combined-method-gf gf))
  (let ((key (cons methods method-list)))
    (or (get-combined-method key gf)
        (let* (key-or-init-arg
               key-or-init-fn)
          (if keywords
            (let* ((bits (inner-lfun-bits gf))
                   (numreq (ldb $lfbits-numreq bits))
                   (key-index (+ numreq (ldb $lfbits-numopt bits))))
              (setq key-or-init-arg (vector key-index keywords gf))
              (setq key-or-init-fn #'x-%%check-keywords))
            (let ((init-cell (assq gf *initialization-functions-alist*)))
              (when init-cell                
                (setq key-or-init-arg init-cell)
                (setq key-or-init-fn #'%%cnm-with-args-check-initargs))))
          (incf *consed-combined-methods*)
          (let* ((vect (vector gf methods key-or-init-arg key-or-init-fn method-list))
                 (self (%cons-combined-method
                        gf vect #'%%cnm-with-args-combined-method-dcode)))
            ;(setf (svref vect 4) self)
            (puthash-combined-method ; if  testing 1 2 3 dont put in our real table
             key
             self))))))


(defparameter *check-call-next-method-with-args* t)

(defun contains-call-next-method-with-args-p (method-list)
  (when *check-call-next-method-with-args*
    (let ((methods method-list)
          method)
      (loop
        (setq method (pop methods))
        (unless methods (return nil))
        (unless (listp method)
          (if (logbitp $lfbits-nextmeth-with-args-bit
                       (lfun-bits (%method.function method)))
            (return t)))))))

;;; The METHODS arg is a sorted list of applicable methods.  Returns
;;; the method-list expected by
;;; %%before-and-after-combined-method-dcode or a single method, or
;;; NIL if there are no applicable primaries
(defun compute-method-list (methods &optional (sub-dispatch? t))
  (let (arounds befores primaries afters qs)
    (dolist (m methods)
      (setq qs (%method.qualifiers m))
      (if qs
        (if (cdr qs)
          (%invalid-method-error
           m "Multiple method qualifiers not allowed in ~s method combination"
           'standard)
          (case (car qs)
            (:before (push m befores))
            (:after (push m afters))
            (:around (push m arounds))
            (t (%invalid-method-error m "~s is not one of ~s, ~s, and ~s."
                                      (car qs) :before :after :around))))
        (push m primaries)))
    (setq primaries (nreverse primaries)
          arounds (nreverse arounds)
          befores (nreverse befores))
    (unless sub-dispatch?
      (setq primaries (nremove-uncallable-next-methods primaries)
            arounds (nremove-uncallable-next-methods arounds)))
    (flet ((next-method-bit-p (method)
                              (logbitp $lfbits-nextmeth-bit 
                                       (lfun-bits (%method.function method)))))
      (unless (null primaries)            ; return NIL if no applicable primary methods
        (when (and arounds
                   (not sub-dispatch?)
                   (not (next-method-bit-p (car (last arounds)))))
          ;; Arounds don't call-next-method, can't get to befores,
          ;; afters, or primaries
          (setq primaries arounds
                arounds nil
                befores nil
                afters nil))
        (if (and (null befores) (null afters)
                 (progn
                   (when arounds
                     (setq primaries (nconc arounds primaries)
                           arounds nil)
                     (unless sub-dispatch?
                       (setq primaries (nremove-uncallable-next-methods primaries))))
                   t)
                 (null (cdr primaries))
                 (not (next-method-bit-p (car primaries))))
          (car primaries)                 ; single method, no call-next-method
          (let ((method-list primaries))
            (if (or befores afters)
              (setq method-list (cons befores (cons afters method-list))))
            (nconc arounds method-list)))))))



(defun %invalid-method-error (method format-string &rest format-args)
  (error "~s is an invalid method.~%~?" method format-string format-args))

(defun %method-combination-error (format-string &rest args)
  (apply #'error format-string args))



(defun combined-method-gf (gf-or-cm)
  (let ((gf gf-or-cm))
    (while (combined-method-p gf)
      (setq gf (lfun-name gf)))
    gf))


(defun nth-arg-combined-method-trap-0 (gf-or-cm table wrapper args)
  (let* ((argnum (%gf-dispatch-table-argnum table))
         (arg (nth argnum args)))
    (nth-arg-combined-method-trap gf-or-cm table argnum args arg wrapper)))


(defun nth-arg-combined-method-trap (gf-or-cm table argnum args &optional
                                              (arg (nth-or-gf-error 
                                                    argnum args gf-or-cm))
                                              (wrapper (arg-wrapper arg)))
  ;; Here when we can't find the method in the dispatch table.
  ;; Compute it and add it to the table.  This code will remain in Lisp.
  (multiple-value-bind (combined-method sub-dispatch?)
      (compute-nth-arg-combined-method
       gf-or-cm (%gf-dispatch-table-methods table) argnum args
       wrapper)
    (multiple-value-bind (index obsolete-wrappers-p)
        (find-gf-dispatch-table-index table wrapper)
      (if index
        (if (%gf-dispatch-table-store-conditional table (%i+ index 1) combined-method)
          (setf (%gf-dispatch-table-ref table index) wrapper))
        (grow-gf-dispatch-table gf-or-cm wrapper combined-method obsolete-wrappers-p)))
    (if sub-dispatch?
      (let ((table (%combined-method-methods combined-method)))
        (nth-arg-combined-method-trap
         combined-method
         table
         (%gf-dispatch-table-argnum table)
         args))
      combined-method)))

;;; Returns (values combined-method sub-dispatch?)
;;; If sub-dispatch? is true, need to compute a combined-method on the
;;; next arg.
(defun compute-nth-arg-combined-method (gf methods argnum args &optional 
                                           (wrapper (arg-wrapper
                                                     (nth-or-gf-error
                                                      argnum args gf))))
  (let* ((cpl (%inited-class-cpl (%wrapper-class wrapper)))
         (real-gf (combined-method-gf gf))
         (mc (%gf-method-combination real-gf))
         (standard-mc? (eq mc *standard-method-combination*))
         applicable-methods eql-methods specializers specializer sub-dispatch?)
    (dolist (method methods)
      ;;(require-type method 'standard-method)   ; for debugging.
      (setq specializers (nthcdr argnum (%method.specializers method))
            specializer (%car specializers))
      (when (if (typep specializer 'eql-specializer)
              (when (cpl-memq (%wrapper-class
                                (arg-wrapper (eql-specializer-object specializer))) cpl)
                (push method eql-methods))
              (when (cpl-memq specializer cpl)
                (push method applicable-methods)))
        (if (contains-non-t-specializer? (%cdr specializers))
          (setq sub-dispatch? t))))
    (if (or eql-methods applicable-methods)
      (if (or (not standard-mc?)
            (contains-primary-method? applicable-methods)
            (contains-primary-method? eql-methods))
        (let ((cpls (args-cpls args)))
          (if eql-methods
            (make-eql-combined-method
             eql-methods applicable-methods cpls gf argnum sub-dispatch? mc)
            (if sub-dispatch?
              (values (make-n+1th-arg-combined-method applicable-methods gf argnum)
                      t)
              (if standard-mc?
                (make-standard-combined-method applicable-methods cpls gf)
                (compute-effective-method-function
                 real-gf mc (sort-methods applicable-methods
                                          (args-cpls args)
                                          (%gf-precedence-list real-gf)))))))
        (no-applicable-primary-method
         real-gf
         (sort-methods (append eql-methods applicable-methods)
                       (args-cpls args)
                       (%gf-precedence-list real-gf))))
       (make-no-applicable-method-function real-gf))))

(defun nth-or-gf-error (n l gf)
  (declare (fixnum n))
  (do* ((i 0 (1+ i))
        (l l (cdr l)))
       ((null l) (dcode-too-few-args i gf))
    (declare (fixnum i))
    (if (= i n)
      (return (car l)))))

(defun contains-non-t-specializer? (specializer-list)
  (dolist (s specializer-list nil)
    (unless (eq *t-class* s)
      (return t))))

(defun contains-primary-method? (method-list)
  (dolist (m method-list nil)
    (if (null (%method.qualifiers m))
      (return t))))

(defun args-cpls (args &aux res)
  (dolist (arg args)
    (push (%inited-class-cpl (%wrapper-class (arg-wrapper arg))) res))
  (nreverse res))


(defun compute-eql-combined-method-hash-table-threshold (&optional (iters 1000000) (max 200))
  (flet ((time-assq (cnt iters)
           (let ((alist (loop for i from 1 to cnt collect (cons i i)))
                 (start-time (get-internal-run-time))
                 (j 0)
                 res)
             (declare (fixnum j))
             (dotimes (i iters)
               (declare (fixnum i))
               (setq res (cdr (assq j alist)))
               (when (>= (incf j) cnt) (setq j 0)))
             (values (- (get-internal-run-time) start-time) res)))
         (time-hash (cnt iters)
           (let ((hash (make-hash-table :test 'eq))
                 start-time
                 (j 0)
                 res)
             (declare (fixnum j))
             (dotimes (i cnt)
               (setf (gethash i hash) i))
             (assert-hash-table-readonly hash)
             (setq start-time (get-internal-run-time))
             (dotimes (i iters)
               (declare (fixnum i))
               (setq res (gethash i hash))
               (when (>= (incf j) cnt) (setq j 0)))
             (values (- (get-internal-run-time) start-time) res))))
    (dotimes (i max)
      (let ((time-assq (time-assq i iters))
            (time-hash (time-hash i iters)))
        (format t "i: ~d, assq: ~d, hash: ~d~%" i time-assq time-hash)
        (when (> time-assq time-hash) (return i))))))

;; Value computed on a dual-core 2.4 GHz AMD Opteron running FC3
;; This isn't the result of compute-eql-combined-method-hash-table-threshold,
;; it's the value at which assq takes 3/4 the time of hash, which weights
;; towards the worst case of the eql method, not the average for uniform inputs.
(defparameter *eql-combined-method-hash-table-threshold* 45)

;;; A vector might be a little faster than an alist, but the hash table case
;;; will speed up large numbers of methods.
(defun make-eql-combined-method (eql-methods methods cpls gf argnum sub-dispatch? &optional
                                             (method-combination *standard-method-combination*))
  (let ((eql-ms (copy-list eql-methods))
        (precedence-list (%gf-precedence-list (combined-method-gf gf)))
        (standard-mc? (eq method-combination *standard-method-combination*))
        (real-gf (combined-method-gf gf))
        eql-method-alist
        (can-use-eq? t))
    (unless sub-dispatch?
      (setq methods (sort-methods methods cpls precedence-list)))
    (while eql-ms
      (let ((eql-element (eql-specializer-object (nth argnum (%method.specializers (car eql-ms)))))
            (this-element-methods eql-ms)
            cell last-cell)
        (if (or (and (numberp eql-element) (not (fixnump eql-element)))
                (macptrp eql-element))
          (setq can-use-eq? nil))
        (setf eql-ms (%cdr eql-ms)
              (%cdr this-element-methods) nil
              cell eql-ms)
        (while cell
          (if (eql eql-element
                     (eql-specializer-object (nth argnum (%method.specializers (car cell)))))
            (let ((cell-save cell))
              (if last-cell
                (setf (%cdr last-cell) (cdr cell))
                (setq eql-ms (cdr eql-ms)))
              (setf cell (cdr cell)
                    (%cdr cell-save) this-element-methods
                    this-element-methods cell-save))
            (setq last-cell cell
                  cell (cdr cell))))
        (let* ((sorted-methods
                (sort-methods (nreconc (copy-list this-element-methods)
                                       (copy-list methods))
                              cpls
                              precedence-list))
               (method-list (and standard-mc? (compute-method-list sorted-methods sub-dispatch?))))
          (when (or (not standard-mc?)
                    (memq method-list this-element-methods)
                    (and (consp method-list)
                         (labels ((member-anywhere (tem mlist)
                                    (member tem mlist
                                            :test #'(lambda (tem el)
                                                      (if (listp el)
                                                        (member-anywhere tem el)
                                                        (member el tem))))))
                           (member-anywhere this-element-methods method-list))))
            ; Do EQL comparison only if the EQL methods can run
            ; (e.g. does not come after a primary method that does not call-next-method)
            (push (cons eql-element
                        (if sub-dispatch?
                          (make-n+1th-arg-combined-method
                           sorted-methods gf argnum)
                          (if standard-mc?
                            (make-standard-combined-method sorted-methods nil gf)
                            (compute-effective-method-function
                             real-gf method-combination sorted-methods))))
                  eql-method-alist)))))
    ;;eql-method-alist has (element . combined-method) pairs.
    ;;for now, we're going to use assq or assoc
    (let ((default-method (if sub-dispatch?
                            (make-n+1th-arg-combined-method
                             methods gf argnum)
                            (if standard-mc?
                              (make-standard-combined-method methods nil gf t)
                              (compute-effective-method-function
                               real-gf method-combination methods)))))
      (if eql-method-alist
        (if (> (length eql-method-alist) *eql-combined-method-hash-table-threshold*)
          (let ((hash (make-hash-table :test (if can-use-eq? 'eq 'eql))))
            (dolist (pair eql-method-alist)
              (setf (gethash (car pair) hash) (cdr pair)))
            (assert-hash-table-readonly hash)
            (%cons-combined-method 
             gf (cons argnum (cons hash default-method))
             #'%%hash-table-combined-method-dcode))
          (%cons-combined-method
           gf (cons argnum (cons eql-method-alist default-method))
           (if can-use-eq? 
               #'%%assq-combined-method-dcode
               #'%%assoc-combined-method-dcode)))
        default-method))))


(defun %%assq-combined-method-dcode (stuff args)
  ;; stuff is (argnum eql-method-list . default-method)
  ;(declare (dynamic-extent args))
  (if (listp args)
    (let* ((args-len (list-length args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error  "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (nth argnum args))
             (thing (assq arg (cadr stuff)))) ; are these things methods or method-functions? - fns    
        (if thing 
          (apply (cdr thing) args)
          (apply (cddr stuff) args))))
    (let* ((args-len (%lexpr-count args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (%lexpr-ref args args-len argnum))
             (thing (assq arg (cadr stuff))))
        (if thing 
          (%apply-lexpr (cdr thing) args)
          (%apply-lexpr (cddr stuff) args))))))
  

(DEFun %%assoc-combined-method-dcode (stuff args)
  ;; stuff is (argnum eql-method-list . default-method)
  ;(declare (dynamic-extent args))
  (if (listp args)
    (let* ((args-len (list-length args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (nth argnum args))
             (thing (assoc arg (cadr stuff)))) ; are these things methods or method-functions?    
        (if thing 
          (apply (cdr thing) args)
          (apply (cddr stuff) args))))
    (let* ((args-len (%lexpr-count args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (%lexpr-ref args args-len argnum))
             (thing (assoc arg (cadr stuff)))) ; are these things methods or method-functions?    
        (if thing 
          (%apply-lexpr (cdr thing) args)
          (%apply-lexpr (cddr stuff) args))))))



(defun %%hash-table-combined-method-dcode (stuff args)
  ;; stuff is (argnum eql-hash-table . default-method)
  ;(declare (dynamic-extent args))
  (if (listp args)
    (let* ((args-len (list-length args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (nth argnum args)))
        (apply (gethash arg (cadr stuff) (cddr stuff)) args)))
    (let* ((args-len (%lexpr-count args))
           (argnum (car stuff)))
      (when (>= argnum args-len)(signal-program-error "Too few args to ~s." (%method-gf (cddr stuff))))
      (let* ((arg (%lexpr-ref args args-len argnum)))
        (%apply-lexpr (gethash arg (cadr stuff) (cddr stuff)) args)))))


;;; Assumes the two methods have the same number of specializers and
;;; that each specializer of each method is in the corresponding
;;; element of cpls (e.g. cpls is a list of the cpl's for the classes
;;; of args for which both method1 & method2 are applicable.
(defun %method< (method1 method2 cpls)
  (let ((s1s (%method.specializers method1))
        (s2s (%method.specializers method2))
        s1 s2 cpl)
    (loop
      (if (null s1s)
        (return (method-qualifiers< method1 method2)))
      (setq s1 (%pop s1s)
            s2 (%pop s2s)
            cpl (%pop cpls))
      (cond ((typep s1 'eql-specializer) 
             (unless (eq s1 s2)
               (return t)))
            ((typep s2 'eql-specializer) (return nil))
            ((eq s1 s2))
            (t (return (%i< (cpl-index s1 cpl) (cpl-index s2 cpl))))))))

(defun %simple-method< (method1 method2 cpl)
  (let ((s1 (%car (%method.specializers method1)))
        (s2 (%car (%method.specializers method2))))
    (cond ((typep s1 'eql-specializer) 
           (if (eq s1 s2)
             (method-qualifiers< method1 method2)
             t))
          ((typep s2 'eql-specializer) nil)
          ((eq s1 s2) (method-qualifiers< method1 method2))
          (t (%i< (cpl-index s1 cpl) (cpl-index s2 cpl))))))

; Sort methods with argument-precedence-order
(defun %hairy-method< (method1 method2 cpls apo)
  (let ((s1s (%method.specializers method1))
        (s2s (%method.specializers method2))
        s1 s2 cpl index)
    (loop
      (if (null apo)
        (return (method-qualifiers< method1 method2)))
      (setq index (pop apo))
      (setq s1 (nth index s1s)
            s2 (nth index s2s)
            cpl (nth index cpls))
      (cond ((typep s1 'eql-specializer) 
             (unless (eq s1 s2)
               (return t)))
            ((typep s2 'eql-specializer) (return nil))
            ((eq s1 s2))
            (t (return (%i< (cpl-index s1 cpl) (cpl-index s2 cpl))))))))

; This can matter if the user removes & reinstalls methods between
; invoking a generic-function and doing call-next-method with args.
; Hence, we need a truly canonical sort order for the methods
; (or a smarter comparison than EQUAL in %%cnm-with-args-check-methods).
(defun method-qualifiers< (method1 method2)
  (labels ((qualifier-list< (ql1 ql2 &aux q1 q2)
              (cond ((null ql1) (not (null ql2)))
                    ((null ql2) nil)
                    ((eq (setq q1 (car ql1)) (setq q2 (car ql2)))
                     (qualifier-list< (cdr ql1) (cdr ql2)))
                    ((string-lessp q1 q2) t)
                    ; This isn't entirely correct.
                    ; two qualifiers with the same pname in different packages
                    ; are not comparable here.
                    ; Unfortunately, users can change package names, hence,
                    ; comparing the package names doesn't work either.
                    (t nil))))
    (qualifier-list< (%method.qualifiers method1) (%method.qualifiers method2))))
       
(defun sort-methods (methods cpls &optional apo)
  (cond ((null cpls) methods)
        ((null (%cdr cpls))
         (setq cpls (%car cpls))
         (flet ((simple-sort-fn (m1 m2)
                  (%simple-method< m1 m2 cpls)))
           (declare (dynamic-extent #'simple-sort-fn))
           (%sort-list-no-key methods #'simple-sort-fn)))
        ((null apo)                     ; no unusual argument-precedence-order
         (flet ((sort-fn (m1 m2) 
                  (%method< m1 m2 cpls)))
           (declare (dynamic-extent #'sort-fn))
           (%sort-list-no-key methods #'sort-fn)))
        (t                              ; I guess some people are just plain rude
         (flet ((hairy-sort-fn (m1 m2)
                  (%hairy-method< m1 m2 cpls apo)))
           (declare (dynamic-extent #'hairy-sort-fn))
           (%sort-list-no-key methods #'hairy-sort-fn)))))

(defun nremove-uncallable-next-methods (methods)
  (do ((m methods (%cdr m))
       mbits)
      ((null m))
    (setq mbits (lfun-bits (%method.function (%car m))))
    (unless (logbitp $lfbits-nextmeth-bit mbits)
      (setf (%cdr m) nil)
      (return)))
  methods)


(defun cpl-index (superclass cpl)
  ;; This will be table lookup later.  Also we'll prelookup the tables
  ;; in compute-1st-arg-combined-methods above.
  (locally (declare (optimize (speed 3)(safety 0)))
    (do ((i 0 (%i+ i 1))
         (cpl cpl (%cdr cpl)))
        ((null cpl) nil)
      (if (eq superclass (%car cpl))
        (return i)))))

(defun cpl-memq (superclass cpl)
  (locally (declare (optimize (speed 3)(safety 0)))
    (do ((cpl cpl (%cdr cpl)))
        ((null cpl) nil)
      (if (eq superclass (%car cpl))
        (return cpl)))))

;;; Combined method interpretation


;;; magic is a list of (cnm-cm (methods) . args) cnm-cm is the
;;; argument checker for call-next-method-with-args or nil could make
;;; it be a cons as a flag that magic has been heap consed - done
;;; could also switch car and cadr if we do &lexpr business then if
;;; cddr is lexpr-p (aka (not listp)) thats the clue also would need
;;; to do lexpr-apply or apply depending on the state.


(defun %%standard-combined-method-dcode (methods args)
  ;; combined-methods as made by make-combined-method are in methods
  ;; args are as put there by the caller of the gf.
  (let* ((car-meths (car methods))
         (cell-2 (cons methods args))
         (magic (cons nil cell-2)))
    ;; i.e. magic is nil methods . args
    (declare (dynamic-extent magic)
             (dynamic-extent cell-2))    
    (if (listp car-meths)
      (%%before-and-after-combined-method-dcode magic)
      (progn       
        (if (not (cdr methods))
          (%rplaca (cdr magic) car-meths)
          (%rplaca (cdr magic) (cdr methods)))
        ; so maybe its a combined-method ?? - no
        (apply-with-method-context magic (%method.function car-meths) args)))))

;;; args is list, old-args may be lexpr
(defun cmp-args-old-args (args old-args numreq)
  (declare (optimize (speed 3)(safety 0)))
  (if (listp old-args)
    (do ((newl args (cdr newl))
         (oldl old-args (cdr oldl))
         (i 0 (1+ i)))
        ((eql i numreq) t)
      (when (neq (car newl)(car oldl))(return nil)))
    (let ((len (%lexpr-count old-args)))
      (do ((newl args (cdr newl))
           (i 0 (1+ i)))
          ((eql i numreq) t)
        (when (neq (car newl)(%lexpr-ref old-args len i))(return nil))))))        


; called from call-next-method-with-args with magic supplied and 1st time around with not
(defun %%cnm-with-args-combined-method-dcode (thing args &optional magic) ; was &rest args
  ;(declare (dynamic-extent args))
  ; now thing is vector of gf orig methods, arg for key or initarg check, key or initarg fnction
  ; and our job is to do all the arg checking
  (let ()
    ;; THING is nil in next-method calls for non-standard method combination.  To enable
    ;; checking in that case, would need to change %%call-method* to store a vector in (car magic).
    (when (and magic thing)
      (flet ((do-it (thing args)
               (let* ((args-len (length args))
                      (gf (svref thing 0))  ; could get this from a method
                      (numreq (ldb $lfbits-numreq (inner-lfun-bits gf)))
                      (next-methods (cadr magic)))
                 ;(when (null self)(error "Next method with args context error"))
                 (when (neq 0 numreq)
                   ; oh screw it - old-args may be lexpr too
                   (let ((old-args (cddr magic)))
                     (when (< args-len numreq) (signal-program-error "Too few args to ~S" gf))
                     (when (null (cmp-args-old-args args old-args numreq))
                       ; required args not eq - usually true, we expect
                       (let ((new-methods (%compute-applicable-methods* gf args))
                             (old-methods (svref thing 1)))
                         (when (not (equal new-methods old-methods))
                           (error '"Applicable-methods changed in call-next-method.~%~
                                    Should be: ~s~%Was: ~s~%Next-methods: ~s"
                                  old-methods new-methods next-methods))))))
                 (let ((key-or-init-fn (svref thing 3)))
                   (when key-or-init-fn 
                     ; was apply
                     (funcall key-or-init-fn (svref thing 2) args))))))
        (if (listp args)
          (do-it thing args)
          (with-list-from-lexpr (args-list args)
            (do-it thing args-list)))))
    ; ok done checking - lets do it 
    (let* ((methods (if magic (cadr magic)(svref thing 4)))  ;<< was 5 this is nil unless cnm with args
           ; was if magic
           (car-meths (car methods))
           (cell-2 (cons methods args))
           (magic (cons thing cell-2)))
      (declare (dynamic-extent magic cell-2))
      ; i.e. magic is thing methods . args
      ;(%rplaca magic thing)
      ;(setf (cadr magic) methods)
      ;(%rplaca (cdr magic) methods)
      ;(setf (cddr magic) args)
      ;(%rplacd (cdr magic) args)
      (if (listp car-meths)
        (progn
          (%%before-and-after-combined-method-dcode magic))
        (progn       
          (if (not (cdr methods))
            (%rplaca (cdr magic) car-meths)
            (%rplaca (cdr magic) (cdr methods)))
          ; so maybe its a combined-method ?? - no
          (apply-with-method-context magic (%method.function car-meths) args))))))



;;; here if car of methods is listp. methods = (befores afters . primaries)
(defun %%before-and-after-combined-method-dcode (magic) 
  (declare (list magic))
  (let* ((methods (cadr magic))         
         (befores (car methods))         
         (cdr-meths (cdr methods))
         (primaries (cdr cdr-meths))
         (afters (car cdr-meths))
         (args (cddr magic)))
    (declare (list befores afters primaries))
    (when befores 
      (dolist (method befores)
        (rplaca (cdr magic) method)
        (apply-with-method-context magic (%method.function method) args)))
    (let* ((cdr (cdr primaries))
           (method-function (%method.function (car primaries))))   ; guaranteed non nil?
      (rplaca (cdr magic) (if (null cdr)(car primaries) cdr))      
      (if (null afters)
        (apply-with-method-context magic method-function args)  ; tail call if possible
        (multiple-value-prog1
          (apply-with-method-context magic method-function args)        
          (dolist (method afters)
            (rplaca (cdr magic) method)
            (apply-with-method-context magic (%method.function method) args)))))))


; This is called by the compiler expansion of next-method-p
; I think there's a bug going around... LAP fever! I'm immune
(defun %next-method-p (magic)
  (let ((methods (%cadr magic)))
    (consp methods)))


(defun %call-next-method (magic &rest args) ; if args supplied they are new ones
  (declare (dynamic-extent args)) 
  (if args
    (apply #'%call-next-method-with-args magic args)
    (let* ((next-methods (%cadr magic))) ; don't get this closed magic stuff      
      (if (not (consp next-methods))
        ( %no-next-method  magic)            
        (let ((args (%cddr magic)))  ; get original args
          ;The unwind-protect is needed in case some hacker in his/her wisdom decides to:
          ; (defmethod foo (x) (catch 'foo (call-next-method)) (call-next-method))
          ; where the next-method throws to 'foo.
          ; The alternative is to make a new magic var with args
          ; actually not that fancy (call-next-method)(call-next-method) is same problem
          (let ()
            (unwind-protect
              (if (listp (car next-methods))
                ( %%before-and-after-combined-method-dcode magic)
                (let ((cdr (cdr next-methods)))
                  (rplaca (cdr magic)(if (not cdr)(car next-methods) cdr))
                  (let ((method-function (%method.function (car next-methods))))
                    (apply-with-method-context magic method-function args))))
              (rplaca (cdr magic) next-methods))))))))

;; Note: we need to change the compiler to call this when it can prove that
;; call-next-method cannot be called a second time. I believe thats done.


(defun %tail-call-next-method (magic)
  (let* ((next-methods (%cadr magic))  ; or make it car
         (args (%cddr magic))) ; get original args        
    (if (not (consp next-methods)) ; or consp?
      ( %no-next-method magic)
      (if (listp (car next-methods))
        ( %%before-and-after-combined-method-dcode magic)
        (let ((cdr (cdr next-methods)))
          (rplaca (cdr magic) (if (not cdr)(car next-methods) cdr))
          (apply-with-method-context magic (%method.function (car next-methods)) args))))))

;;; may be simpler to blow another cell so magic looks like
;;; (cnm-cm/nil next-methods . args) - done
;;; and also use first cell to mean heap-consed if itsa cons

(defun %call-next-method-with-args (magic &rest args)
  (declare (dynamic-extent args))
  (if (null args)
    (%call-next-method magic)
    (let* ((methods (%cadr magic)))
      (if (not (consp methods))
        (%no-next-method  magic)
        (let* ((cnm-cm (car magic)))
          ; a combined method
          (when (consp cnm-cm)(setq cnm-cm (car cnm-cm)))
          ; could just put the vector in car magic & no self needed in vector?
          (let ((the-vect cnm-cm)) ;  <<
            (funcall #'%%cnm-with-args-combined-method-dcode ;(%combined-method-dcode cnm-cm)
                     the-vect
                     args
                     magic)))))))



; called from x%%call-next-method-with-args - its the key-or-init-fn 
(defun %%cnm-with-args-check-initargs (init-cell args)
  ; here we forget the lexpr idea because it wants to cdr
  ;(declare (dynamic-extent args))
  (let* ((rest (cdr args))
         (first-arg (car args)))
    (declare (list rest))
    (let* ((initargs rest)
           (init-function (car init-cell))
           (instance (cond ((eq init-function #'update-instance-for-different-class)
                            (setq initargs (cdr rest))
                            (car rest))
                           ((eq init-function #'shared-initialize)
                            (setq initargs (cdr rest))
                            first-arg)
                           ((eq init-function #'update-instance-for-redefined-class)
                            (setq initargs (%cdddr rest))
                            first-arg)
                           (t first-arg)))
           (class (class-of instance))
           bad-initarg)
      (dolist (functions (cdr init-cell)
                         (error "Bad initarg: ~s to call-next-method for ~s~%on ~s"
                                bad-initarg instance (car init-cell)))
        (multiple-value-bind 
          (errorp bad-key)
          (if (eq (car functions) #'initialize-instance)
            (apply #'check-initargs instance class initargs nil
                   #'initialize-instance #'allocate-instance #'shared-initialize
                   nil)
            (apply #'check-initargs instance class initargs nil functions))
          (if errorp
            (unless bad-initarg (setq bad-initarg bad-key))
            (return t)))))))



(defun %no-next-method (magic)
  (let* ((method (%cadr magic)))
    (if (consp method) (setq method (car method)))
    (unless (typep method 'standard-method)
      (error "call-next-method called outside of generic-function dispatch context.~@
              Usually indicates an error in a define-method-combination form."))
    (let ((args (cddr magic))
          (gf (%method.gf method)))
      (if (listp args)
        (apply #'no-next-method gf method args)
        (%apply-lexpr #'no-next-method gf method args)))))




;;; This makes a consed version of the magic first arg to a method.
;;; Called when someone closes over the magic arg. (i.e. does (george
;;; #'call-next-method))

(defun %cons-magic-next-method-arg (magic)
  ; car is a cons as a flag that its already heap-consed! - else cnm-cm or nil
  (if (consp (car magic))
    magic
    (list* (list (car magic))
           (if (consp (%cadr magic))
             (copy-list (%cadr magic)) ; is this copy needed - probably not
             (cadr magic))
           (let ((args (%cddr magic)))
             (if (listp args)
               (copy-list args)
               (let* ((len (%lexpr-count args))
                      (l (make-list len)))
                 (do ((i 0 (1+ i))
                      (list l (cdr list)))
                     ((null list))
                   (%rplaca list (%lexpr-ref args len i)))
                 l))))))


; Support CALL-METHOD in DEFINE-METHOD-COMBINATION
(defun %%call-method* (method next-methods args)
  (let* ((method-function (%method.function method))
         (bits (lfun-bits method-function)))
    (declare (fixnum bits))
    (if (not (and (logbitp $lfbits-nextmeth-bit  bits)
                  (logbitp  $lfbits-method-bit bits)))
      (if (listp args)
        (apply method-function args)
        (%apply-lexpr method-function args))
      (let* ((cell-2 (cons next-methods args))
             (magic (cons nil cell-2)))
        (declare (dynamic-extent magic)
                 (dynamic-extent cell-2))  
        (if (null next-methods)
          (%rplaca (cdr magic) method))
        (apply-with-method-context magic method-function args)))))

; Error checking version for user's to call
(defun %call-method* (method next-methods args)
  (let* ((method-function (%method.function method))
         (bits (lfun-bits method-function)))
    (declare (fixnum bits))
    (if (not (and (logbitp $lfbits-nextmeth-bit  bits)
                  (logbitp  $lfbits-method-bit bits)))
      (progn
        (require-type method 'standard-method)
        (if (listp args)
          (apply method-function args)
          (%apply-lexpr method-function args)))
      (progn
        (do* ((list next-methods (cdr list)))
             ((null list))
          (when (not (listp list))
            (%err-disp $XIMPROPERLIST next-methods))
          (when (not (standard-method-p (car list)))
            (report-bad-arg (car list) 'standard-method))) 
        (let* ((cell-2 (cons next-methods args))
               (magic (cons nil cell-2)))
          (declare (dynamic-extent magic)
                   (dynamic-extent cell-2))  
          (if (null next-methods)
            (%rplaca (cdr magic) method))
          (apply-with-method-context magic method-function args))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-dcode.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-numbers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
  (require "NUMBER-MACROS")
)

(defun %parse-number-token (string &optional start end radix)
  (if end (require-type end 'fixnum)(setq end (length string)))
  (if start (require-type start 'fixnum)(setq start 0))
  (multiple-value-bind (string offset)(array-data-and-offset string)
    (new-numtoken string (+ start offset)(- end start) (%validate-radix (or radix 10)))))

(defun new-numtoken (string start len radix &optional no-rat no-sign)
  (declare (fixnum start len radix))
  (if (eq 0 len)
    nil
    (let ((c (%scharcode string start))
          (nstart start)
          (end (+ start len))
          (hic (if (<= radix 10)
                 (+ (char-code #\0) (1- radix))
                 (+ (char-code #\A) (- radix 11))))
          dot dec dgt)
      (declare (fixnum nstart end hic))
      (when (or (eq c (char-code #\+))(eq c (char-code #\-)))
        (if no-sign
          (return-from new-numtoken nil)
          (setq nstart (1+ nstart))))
      (when (eq nstart end)(return-from new-numtoken nil)) ; just a sign
      (do ((i nstart (1+ i)))
          ((eq i end))
        (let ()
          (setq c (%scharcode string i))
          (cond
           ((eq c (char-code #\.))
            (when dot (return-from new-numtoken nil))
            (setq dot t)
            (when dec (return-from new-numtoken nil))
            (setq hic (char-code #\9)))
           ((< c (char-code #\0)) 
            (when (and (eq c (char-code #\/))(not dot)(not no-rat))
              (let ((top (new-numtoken string start (- i start) radix)))
                (when top 
                  (let ((bottom (new-numtoken string (+ start i 1) (- len i 1) radix t t)))
                    (when bottom 
                      (return-from new-numtoken (/ top bottom)))))))
            (return-from new-numtoken nil))
           ((<= c (char-code #\9))
            (when (> c hic)
              ; seen a decimal digit above base.
              (setq dgt t)))
           (t (when (>= c (char-code #\a))(setq c (- c 32)))
              ;; don't care about *read-base* if float
              (cond ((or (< c (char-code #\A))(> c hic))
                     (when (and (neq i nstart) ; need some digits first
                                (memq c '#.(list (char-code #\E)(char-code #\F)
                                                 (char-code #\D)(char-code #\L)
                                                 (char-code #\S))))
                       (return-from new-numtoken (parse-float string len start)))
                     (return-from new-numtoken nil))
                    (t     ; seen a "digit" in base that ain't decimal
                     (setq dec t)))))))
      (when (and dot (or (and (neq nstart start)(eq len 2))
                         (eq len 1)))  ;. +. or -.
        (return-from new-numtoken nil))
      (when dot 
        (if (eq c (char-code #\.))
          (progn (setq len (1- len) end (1- end))
                 (when dec (return-from new-numtoken nil))
                 ; make #o9. work (should it)
                 (setq radix 10 dgt nil))
          (return-from new-numtoken (parse-float string len start))))
      (when dgt (return-from new-numtoken nil)) ; so why didnt we quit at first sight of it?
      ; and we ought to accumulate as we go until she gets too big - maybe
      (cond (nil ;(or (and (eq radix 10)(< (- end nstart) 9))(and (eq radix 8)(< (- end nstart) 10)))
             (let ((num 0))
               (declare (fixnum num))
               (do ((i nstart (1+ i)))
                   ((eq i end))
                 (setq num (%i+ (%i* num radix)(%i- (%scharcode string i) (char-code #\0)))))
               (if (eq (%scharcode string start) (char-code #\-)) (setq num (- num)))
               num))                         
            (t (token2int string start len radix))))))


;; Will Clingers number 1.448997445238699
;; Doug Curries numbers 214748.3646, 1073741823/5000
;; My number: 12.
;; Your number:





(defun logand (&lexpr numbers)
  "Return the bit-wise and of its arguments. Args must be integers."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      -1
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'integer)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (declare (optimize (speed 3) (safety 0)))
            (setq n0 (logand (%lexpr-ref numbers count i) n0))))))))


(defun logior (&lexpr numbers)
  "Return the bit-wise or of its arguments. Args must be integers."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      0
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'integer)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (declare (optimize (speed 3) (safety 0)))
            (setq n0 (logior (%lexpr-ref numbers count i) n0))))))))

(defun logxor (&lexpr numbers)
  "Return the bit-wise exclusive or of its arguments. Args must be integers."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      0
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'integer)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (declare (optimize (speed 3) (safety 0)))
            (setq n0 (logxor (%lexpr-ref numbers count i) n0))))))))

(defun logeqv (&lexpr numbers)
  "Return the bit-wise equivalence of its arguments. Args must be integers."
  (let* ((count (%lexpr-count numbers))
         (result (if (zerop count)
                   0
                   (let* ((n0 (%lisp-word-ref numbers count)))
                     (if (= count 1)
                       (require-type n0 'integer)
                       (do* ((i 1 (1+ i)))
                            ((= i count) n0)
                         (declare (fixnum i))
                         (declare (optimize (speed 3) (safety 0)))
                         (setq n0 (logxor (%lexpr-ref numbers count i) n0))))))))
    (declare (fixnum count))
    (if (evenp count)
      (lognot result)
      result)))




(defun = (num &lexpr more)
  "Return T if all of its arguments are numerically equal, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'number)
        t)
      (dotimes (i count t)
        (unless (=-2 (%lexpr-ref more count i) num) (return))))))

(defun /= (num &lexpr more)
  "Return T if no two of its arguments are numerically equal, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'number)
        t)
      (dotimes (i count t)
        (declare (fixnum i))
        (do ((j i (1+ j)))
            ((= j count))
          (declare (fixnum j))
          (when (=-2 num (%lexpr-ref more count j))
            (return-from /= nil)))
        (setq num (%lexpr-ref more count i))))))

(defun - (num &lexpr more)
  "Subtract the second and all subsequent arguments from the first; 
  or with one argument, negate the first argument."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (- num)
      (dotimes (i count num)
        (setq num (--2 num (%lexpr-ref more count i)))))))

(defun / (num &lexpr more)
  "Divide the first argument by each of the following arguments, in turn.
  With one argument, return reciprocal."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (%quo-1 num)
      (dotimes (i count num)
        (setq num (/-2 num (%lexpr-ref more count i)))))))

(defun + (&lexpr numbers)
  "Return the sum of its arguments. With no args, returns 0."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      0
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'number)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (setq n0 (+-2 (%lexpr-ref numbers count i) n0))))))))



(defun * (&lexpr numbers)
  "Return the product of its arguments. With no args, returns 1."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      1
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'number)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (declare (optimize (speed 3) (safety 0)))
            (setq n0 (*-2 (%lexpr-ref numbers count i) n0))))))))


(defun < (num &lexpr more)
  "Return T if its arguments are in strictly increasing order, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'real)
        t)
      (dotimes (i count t)
        (declare (optimize (speed 3) (safety 0)))
        (unless (< num (setq num (%lexpr-ref more count i)))
          (return))))))

(defun <= (num &lexpr more)
  "Return T if arguments are in strictly non-decreasing order, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'real)
        t)
      (dotimes (i count t)
        (declare (optimize (speed 3) (safety 0)))
        (unless (<= num (setq num (%lexpr-ref more count i)))
          (return))))))


(defun > (num &lexpr more)
  "Return T if its arguments are in strictly decreasing order, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'real)
        t)
      (dotimes (i count t)
        (declare (optimize (speed 3) (safety 0)))
        (unless (> num (setq num (%lexpr-ref more count i)))
          (return))))))

(defun >= (num &lexpr more)
  "Return T if arguments are in strictly non-increasing order, NIL otherwise."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (progn
        (require-type num 'real)
        t)
      (dotimes (i count t)
        (declare (optimize (speed 3) (safety 0)))
        (unless (>= num (setq num (%lexpr-ref more count i)))
          (return))))))

(defun max-2 (n0 n1)
  (if (> n0 n1) n0 n1))

(defun max (num &lexpr more)
  "Return the greatest of its arguments; among EQUALP greatest, return
   the first."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (require-type num 'real)
      (dotimes (i count num)
        (declare (optimize (speed 3) (safety 0)))
        (setq num (max-2 (%lexpr-ref more count i) num))))))

(defun min-2 (n0 n1)
  (if (< n0 n1) n0 n1))

(defun min (num &lexpr more)
  "Return the least of its arguments; among EQUALP least, return
  the first."
  (let* ((count (%lexpr-count more)))
    (declare (fixnum count))
    (if (zerop count)
      (require-type num 'real)
      (dotimes (i count num)
        (declare (optimize (speed 3) (safety 0)))
        (setq num (min-2 (%lexpr-ref more count i) num))))))
 


;Not CL. Used by transforms.
(defun deposit-byte (value size position integer)
  (let ((mask (byte-mask size)))
    (logior (ash (logand value mask) position)
            (logandc1 (ash mask position) integer))))

(defun deposit-field (value bytespec integer)
  "Return new integer with newbyte in specified position, newbyte is not right justified."
  (if (> bytespec 0)    
    (logior (logandc1 bytespec integer) (logand bytespec value))
    (progn
      (require-type value 'integer)
      (require-type integer 'integer))))

;;;;;;;;;;  Byte field functions ;;;;;;;;;;;;;;;;

;;; Size = 0, position = 0 -> 0
;;; size = 0, position > 0 -> -position
;;; else ->  (ash (byte-mask size) position)
(defun byte (size position)
  "Return a byte specifier which may be used by other byte functions
  (e.g. LDB)."
  (unless (and (typep size 'integer)
	       (>= size 0))
    (report-bad-arg size 'unsigned-byte))
  (unless (and (typep position 'integer)
	       (>= position 0))
    (report-bad-arg position 'unsigned-byte))
  (if (eql 0 size)
    (if (eql 0 position)
      0
      (- position))
    (ash (byte-mask size) position)))



(defun byte-size (bytespec)
  "Return the size part of the byte specifier bytespec."
  (if (> bytespec 0)
    (logcount bytespec)
    0))

(defun ldb (bytespec integer)
  "Extract the specified byte from integer, and right justify result."
  (if (and (fixnump bytespec) (> (the fixnum bytespec) 0)  (fixnump integer))
    (%ilsr (byte-position bytespec) (%ilogand bytespec integer))
    (let ((size (byte-size bytespec))
          (position (byte-position bytespec)))
      (if (eql size 0)
	(progn
	  (require-type integer 'integer)
	  0)
	(if (and (bignump integer)
		 (<= size  (- (1- target::nbits-in-word)  target::fixnumshift))
		 (fixnump position))
          (%ldb-fixnum-from-bignum integer size position)
          (ash (logand bytespec integer) (- position)))))))

(defun mask-field (bytespec integer)
  "Extract the specified byte from integer, but do not right justify result."
  (if (>= bytespec 0)
    (logand bytespec integer)
    (logand integer 0)))

(defun dpb (value bytespec integer)
  "Return new integer with newbyte in specified position, newbyte is right justified."
  (if (and (fixnump value)
	   (fixnump bytespec)
	   (> (the fixnum bytespec) 0)
	   (fixnump integer))
    (%ilogior (%ilogand bytespec (%ilsl (byte-position bytespec) value))
              (%ilogand (%ilognot bytespec) integer))
    (deposit-field (ash value (byte-position bytespec)) bytespec integer)))

(defun ldb-test (bytespec integer)
  "Return T if any of the specified bits in integer are 1's."
  (if (> bytespec 0)
    (logtest bytespec integer)
    (progn
      (require-type integer 'integer)
      nil)))

;;; random associated stuff except for the print-object method which
;;; is still in "lib;numbers.lisp"

(defun init-random-state-seeds ()
  (let* ((ticks (ldb (byte 32 0)
		     (+ (mixup-hash-code (%current-tcr))
			(let* ((iface (primary-ip-interface)))
			  (or (and iface (ip-interface-addr iface))
			      0))
			(mixup-hash-code
			 (logand (get-internal-real-time)
				 (1- target::target-most-positive-fixnum))))))
	 (high (ldb (byte 16 16) (if (zerop ticks) #x10000 ticks)))
	 (low (ldb (byte 16 0) ticks)))
    (declare (fixnum high low))
    (values high low)))

(defun %cons-mrg31k3p-state (x0 x1 x2 x3 x4 x5)
  (let ((array (make-array 6 :element-type '(unsigned-byte 32)
			   :initial-contents (list x0 x1 x2 x3 x4 x5))))
    (%istruct 'random-state array)))

(defun initialize-mrg31k3p-state (x0 x1 x2 x3 x4 x5)
  (let ((args (list x0 x1 x2 x3 x4 x5)))
    (declare (dynamic-extent args))
    (dolist (a args)
      (unless (and (integerp a) (<= 0 a) (< a mrg31k3p-limit))
	(report-bad-arg a `(integer 0 (,mrg31k3p-limit)))))
    (when (and (zerop x0) (zerop x1) (zerop x2))
      (error "The first three arguments must not all be zero."))
    (when (and (zerop x3) (zerop x4) (zerop x5))
      (error "The second three arguments must not all be zero."))
    (%cons-mrg31k3p-state x0 x1 x2 x3 x4 x5)))

#+windows-target
(defun random-mrg31k3p-state ()
  (flet ((random-u32 ()
	   (%stack-block ((buf 4))
	     ;; BOOLEAN RtlGenRandom(PVOID buf, ULONG len)
	     (let ((r (external-call "SystemFunction036" :address buf
				     :unsigned 4 :byte)))
	       (if (plusp r)
		 (%get-unsigned-long buf)
		 (init-random-state-seeds))))))
    (loop repeat 6
	  for n = (random-u32)
	  ;; The first three seed elements must not be all zero, and
	  ;; likewise for the second three.  Avoid the issue by
	  ;; excluding zero values.
	  collect (1+ (mod n (1- mrg31k3p-limit))) into seed
	  finally (return (apply #'%cons-mrg31k3p-state seed)))))

#-windows-target
(defun random-mrg31k3p-state ()
  (with-open-file (stream "/dev/urandom" :element-type '(unsigned-byte 32)
			  :if-does-not-exist nil)
    (loop repeat 6
	  for n = (if stream (read-byte stream) (init-random-state-seeds))
	  ;; The first three seed elements must not be all zero, and
	  ;; likewise for the second three.  Avoid the issue by
	  ;; excluding zero values.
	  collect (1+ (mod n (1- mrg31k3p-limit))) into seed
	  finally (return (apply #'%cons-mrg31k3p-state seed)))))

(defun initial-random-state ()
  (initialize-mrg31k3p-state 314159 42 1776 271828 6021023 1066))

(defun make-random-state (&optional state)
  "Make a new random state object. If STATE is not supplied, return a
  copy of the current random state. If STATE is a random state, then
  return a copy of it. If STATE is T then return a randomly
  initialized random state."
  (if (eq state t)
    (random-mrg31k3p-state)
    (progn
      (setq state (require-type (or state *random-state*) 'random-state))
      (let ((seed (coerce (random.mrg31k3p-state state) 'list)))
	(apply #'%cons-mrg31k3p-state seed)))))

(defun random-state-p (thing) (istruct-typep thing 'random-state))

(defun %random-state-equalp (x y)
  ;; x and y are both random-state objects
  (equalp (random.mrg31k3p-state x) (random.mrg31k3p-state y)))

;;; transcendental stuff.  Should go in level-0;l0-float
;;; but shleps don't work in level-0.  Or do they ?
; Destructively set z to x^y and return z.
(defun %double-float-expt! (b e result)
  (declare (double-float b e result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float temp (#_pow b e))
    (%df-check-exception-2 'expt b e (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+(and 32-bit-target (not win32-target))
(defun %single-float-expt! (b e result)
  (declare (single-float b e result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float temp (#_powf b e))
    (%sf-check-exception-2 'expt b e (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+win32-target
(defun %single-float-expt! (b e result)
  (declare (single-float b e result))
  (with-stack-double-floats ((temp) (db b) (de e))
    (%setf-double-float temp (#_pow db de))
    (%df-check-exception-2 'expt b e (%ffi-exception-status))
    (%double-float->short-float temp result)))

#+64-bit-target
(defun %single-float-expt (b e)
  (declare (single-float b e))
  (let* ((result (#_powf b e)))
    (%sf-check-exception-2 'expt b e (%ffi-exception-status))
    result))

(defun %double-float-sin! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_sin n))
    (%df-check-exception-1 'sin n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-sin! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "sinf" :single-float n :single-float))
    (%sf-check-exception-1 'sin n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-sin (n)
  (declare (single-float n))
  (let* ((result (#_sinf n)))
    (%sf-check-exception-1 'sin n (%ffi-exception-status))
    result))

(defun %double-float-cos! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_cos n))
    (%df-check-exception-1 'cos n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-cos! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_cosf n))
    (%sf-check-exception-1 'cos n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-cos (n)
  (declare (single-float n))
  (let* ((result (#_cosf n)))
    (%sf-check-exception-1 'cos n (%ffi-exception-status))
    result))

(defun %double-float-acos! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_acos n))
    (%df-check-exception-1 'acos n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-acos! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_acosf n))
    (%sf-check-exception-1 'acos n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-acos (n)
  (declare (single-float n))
  (let* ((result (#_acosf n)))
    (%sf-check-exception-1 'acos n (%ffi-exception-status))
    result))

(defun %double-float-asin! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_asin n))
    (%df-check-exception-1 'asin n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-asin! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_asinf n))
    (%sf-check-exception-1 'asin n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-asin (n)
  (declare (single-float n))
  (let* ((result (#_asinf n)))
    (%sf-check-exception-1 'asin n (%ffi-exception-status))
    result))

(defun %double-float-cosh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_cosh n))
    (%df-check-exception-1 'cosh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-cosh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "coshf" :single-float n :single-float))
    (%sf-check-exception-1 'cosh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-cosh (n)
  (declare (single-float n))
  (let* ((result (#_coshf n)))
    (%sf-check-exception-1 'cosh n (%ffi-exception-status))
    result))

(defun %double-float-log! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_log n))
    (%df-check-exception-1 'log n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-log! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_logf n))
    (%sf-check-exception-1 'log n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-log (n)
  (let* ((result (#_logf n)))
    (%sf-check-exception-1 'log n (%ffi-exception-status))
    result))

(defun %double-float-tan! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_tan n))
    (%df-check-exception-1 'tan n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-tan! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_tanf n))
    (%sf-check-exception-1 'tan n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-tan (n)
  (declare (single-float n))
  (let* ((result (#_tanf n)))
    (%sf-check-exception-1 'tan n (%ffi-exception-status))
    result))

(defun %double-float-atan! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_atan n))
    (%df-check-exception-1 'atan n (%ffi-exception-status))
    (%setf-double-float result TEMP)))


#+32-bit-target
(defun %single-float-atan! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_atanf n))
    (%sf-check-exception-1 'atan n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-atan (n)
  (declare (single-float n))
  (let* ((temp (#_atanf n)))
    (%sf-check-exception-1 'atan n (%ffi-exception-status))
    temp))

;;; On current (early 2013) versions of x8664 Linux,
;;; (#_atan2 most-positive-double-float most-positive-double-float)
;;; returns the correct answer but generates an intermediate
;;; invalid-operation exception. #_atan2[f] is documented to never
;;; raise fp exceptions, so don't check for them.
(defun %double-float-atan2! (x y result)
  (declare (double-float x y result))
  (%setf-double-float result (#_atan2 x y)))

#+32-bit-target
(defun %single-float-atan2! (x y result)
  (declare (single-float x y result))
  (%setf-short-float result (#_atan2f x y)))

#+64-bit-target
(defun %single-float-atan2 (x y)
  (declare (single-float x y))
  (#_atan2f x y))

(defun %double-float-exp! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_exp n))
    (%df-check-exception-1 'exp n (%ffi-exception-status))
    #+(or linux-target freebsdx8632-target)
    (and (infinity-p TEMP)
         (not (infinity-p n))
         (get-fpu-mode :overflow)
         (error 'floating-point-overflow
                :operation 'exp
                :operands (list n)))
    (%setf-double-float result TEMP)))

#+(and 32-bit-target (not windows-target))
(defun %single-float-exp! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_expf n))
    (%sf-check-exception-1 'exp n (%ffi-exception-status))
    #+(or linux-target freebsdx8632-target)
    (and (infinity-p TEMP)
         (not (infinity-p n))
         (get-fpu-mode :overflow)
         (error 'floating-point-overflow
                :operation 'exp
                :operands (list n)))
    (%setf-short-float result TEMP)))

#+(and 32-bit-target windows-target)
(defun %single-float-exp! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    (%setf-short-float TEMP (external-call "expf" :single-float n :single-float))
    (%sf-check-exception-1 'exp n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-exp (n)
  (declare (single-float n))
  (let* ((result (#_expf n)))
    (%sf-check-exception-1 'exp n (%ffi-exception-status))
    #+linux-target
    (and (infinity-p result)
         (not (infinity-p n))
         (get-fpu-mode :overflow)
         (error 'floating-point-overflow
                :operation 'exp
                :operands (list n)))
    result))

(defun %double-float-sinh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_sinh n))
    (%df-check-exception-1 'sinh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-sinh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "sinhf" :single-float n :single-float))
    (%sf-check-exception-1 'sinh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-sinh (n)
  (declare (single-float n))
  (let* ((result (#_sinhf n)))
    (%sf-check-exception-1 'sinh n (%ffi-exception-status))
    result))

(defun %double-float-tanh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_tanh n))
    (%df-check-exception-1 'tanh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-tanh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "tanhf" :single-float n :single-float))
    (%sf-check-exception-1 'tanh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-tanh (n)
  (declare (single-float n))
  (let* ((result (#_tanhf n)))
    (%sf-check-exception-1 'tanh n (%ffi-exception-status))
    result))

#+windows-target
(progn
(defun %double-float-asinh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    (%setf-double-float TEMP (external-call "asinh" :double-float n :double-float))
    (%df-check-exception-1 'asinh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-asinh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "asinhf" :float n :float))
    (%sf-check-exception-1 'asinh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-asinh (n)
  (declare (single-float n))
  (let* ((result (external-call "asinhf" :float n :float)))
    (%sf-check-exception-1 'asinh n (%ffi-exception-status))
    result)))

#-windows-target
(progn
(defun %double-float-asinh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_asinh n))
    (%df-check-exception-1 'asinh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))


#+32-bit-target
(defun %single-float-asinh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_asinhf n))
    (%sf-check-exception-1 'asinh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-asinh (n)
  (declare (single-float n))
  (let* ((result (#_asinhf n)))
    (%sf-check-exception-1 'asinh n (%ffi-exception-status))
    result))
)

#+windows-target
(progn
(defun %double-float-acosh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    (%setf-double-float TEMP (external-call "acosh" :double  n :double))
    (%df-check-exception-1 'acosh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-acosh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "acoshf" :float n :float))
    (%sf-check-exception-1 'acosh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-acosh (n)
  (declare (single-float n))
  (let* ((result (external-call "acoshf" :float n :float)))
    (%sf-check-exception-1 'acosh n (%ffi-exception-status))
    result))

)

#-windows-target
(progn
(defun %double-float-acosh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_acosh n))
    (%df-check-exception-1 'acosh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-acosh! (n result)
  (declare (single-float n result))
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_acoshf n))
    (%sf-check-exception-1 'acosh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-acosh (n)
  (declare (single-float n))
  (let* ((result (#_acoshf n)))
    (%sf-check-exception-1 'acosh n (%ffi-exception-status))
    result))
)

#+windows-target
(progn
(defun %double-float-atanh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    (%setf-double-float TEMP (external-call "atanh" :double n :double))
    (%df-check-exception-1 'atanh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-atanh! (n result)
  (declare (single-float n result)) 
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (external-call "atanhf" :float n :float))
    (%sf-check-exception-1 'atanh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-atanh (n)
  (declare (single-float n)) 
  (let* ((result (external-call "atanhf" :float n :float)))
    (%sf-check-exception-1 'atanh n (%ffi-exception-status))
    result))

)

#-windows-target
(progn
(defun %double-float-atanh! (n result)
  (declare (double-float n result))
  (with-stack-double-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-double-float TEMP (#_atanh n))
    (%df-check-exception-1 'atanh n (%ffi-exception-status))
    (%setf-double-float result TEMP)))

#+32-bit-target
(defun %single-float-atanh! (n result)
  (declare (single-float n result)) 
  (target::with-stack-short-floats ((temp))
    #+arm-target (%set-fpscr-status 0)
    (%setf-short-float TEMP (#_atanhf n))
    (%sf-check-exception-1 'atanh n (%ffi-exception-status))
    (%setf-short-float result TEMP)))

#+64-bit-target
(defun %single-float-atanh (n)
  (declare (single-float n)) 
  (let* ((result (#_atanhf n)))
    (%sf-check-exception-1 'atanh n (%ffi-exception-status))
    result))
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-numbers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-boot-1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; L1-boot.lisp

(in-package "CCL")

(defparameter *gensym-counter* 0 "counter for generating unique GENSYM symbols")

(defparameter *inhibit-greeting* nil)

;the below 3 variables are expected to be redefined in the user's init file
(defparameter *short-site-name* nil)
(defparameter *long-site-name* nil)
#|
(defparameter *machine-instance* nil)
|#

(defun lisp-implementation-type ()
  #+clozure-common-lisp "Clozure Common Lisp"
  #-clozure-common-lisp "OpenMCL")


(defparameter *platform-os-names*
  `((,platform-os-vxworks . :vxwork)
    (,platform-os-linux . :linux)
    (,platform-os-solaris . :solaris)
    (,platform-os-darwin . :darwin)
    (,platform-os-freebsd . :freebsd)
    (,platform-os-windows . :windows)
    (,platform-os-android . :android)))

(defparameter *platform-cpu-names*
  `((,platform-cpu-ppc . :ppc)
    (,platform-cpu-sparc . :sparc)
    (,platform-cpu-x86 . :x86)
    (,platform-cpu-arm . :arm)))

(defun host-platform ()
  (let* ((pf (%get-kernel-global 'host-platform)))
    (values
     (or (cdr (assoc (logand pf platform-os-mask)
                     *platform-os-names*))
         :unknown)
     (if (logtest pf platform-word-size-mask)
       64
       32)
     (or (cdr (assoc (logand pf platform-cpu-mask)
                     *platform-cpu-names*))
         :unknown))))


(defun platform-description ()
  (multiple-value-bind (os bits cpu) (host-platform)
    (format nil "~a~a~d" (string-capitalize os) cpu bits)))

(defun lisp-implementation-version ()
  (%str-cat "Version " (format nil *openmcl-version* (platform-description))))




(defun replace-base-translation (host-dir new-base-dir)
  (let* ((host (pathname-host host-dir))
         (device (pathname-device new-base-dir))
         (host-dir (full-pathname host-dir))
         (trans (logical-pathname-translations host))
         (host-wild (merge-pathnames "**/*.*" host-dir)))
    (setq host-dir (pathname-directory host-dir))
    (setq new-base-dir (pathname-directory new-base-dir))
    (setf 
     (logical-pathname-translations host)
     (mapcar
      #'(lambda (pair)
          (let ((rhs (cadr pair)))
            (if (and (physical-pathname-p rhs)
                     (pathname-match-p rhs host-wild))
              (list (car pair)
                    (merge-pathnames 
                     (make-pathname 
                      :defaults nil
                      :device device
                      :directory (append new-base-dir
                                         (nthcdr (length host-dir) 
                                                 (pathname-directory rhs))))
                     rhs))
              pair)))
      trans))))

(defun set-ccl-directory (path)
  (replace-base-translation "ccl:" (translate-logical-pathname path)))




; only do these if exist
(defun init-logical-directories ()
  (replace-base-translation "home:"  (user-homedir-pathname))
  (replace-base-translation "ccl:" (ccl-directory)))

(push #'init-logical-directories *lisp-system-pointer-functions*)


(catch :toplevel
  (init-logical-directories)
  )






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-boot-1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-application.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;; Application classes

(defstruct command-line-argument
  keyword
  help-string
  option-char
  long-name
  may-take-operand
  allow-multiple			; option can appear multiple times
)

(defvar *standard-help-argument*
  (make-command-line-argument
   :keyword :help
   :help-string "this text"
   :option-char #\h
   :long-name "help"))

(defvar *standard-version-argument*
  (make-command-line-argument
   :keyword :version
   :help-string "print (LISP-IMPLEMENTATION-VERSION) and exit"
   :option-char #\V
   :long-name "version"))

(defvar *standard-terminal-encoding-argument*
  (make-command-line-argument
   :option-char #\K
   :long-name "terminal-encoding"
   :help-string "specify character encoding to use for *TERMINAL-IO*"
   :may-take-operand t
   :keyword :terminal-encoding
   :allow-multiple nil))

(defclass application ()
    ((command-line-arguments
      :initform
      (list *standard-help-argument* *standard-version-argument*))
     (ui-object :initform (make-instance 'ui-object) :initarg :ui-object :accessor application-ui-object)))
       
(defclass ui-object ()
    ())

;;; It's intended that this be specialized ...
(defmethod ui-object-do-operation ((u ui-object) operation &rest args)
  (declare (ignore operation args)))


(defun %usage-exit (banner exit-status other-args)
  (with-cstrs ((banner banner)
	       (other-args other-args))
    (ff-call (%kernel-import target::kernel-import-usage-exit)
	     :address banner
	     :signed-fullword exit-status
	     :address other-args
	     :void)))

(defloadvar *unprocessed-command-line-arguments* ())

;;; Returns four values: error-flag, options-alist, non-option-arguments, unprocessed arguments
(defmethod parse-application-arguments ((a application))
  (let* ((cla (slot-value a 'command-line-arguments))
	 (vals (cdr *command-line-argument-list*))
	 (options ())
	 (non-options ())
         (rest-arg nil))
    (do* ()
	 ((null vals)
	  (values nil (nreverse options) (nreverse non-options) rest-arg))
      (let* ((val (pop vals))
	     (val-len (length val))
	     (short-p nil)
	     (option
	      (if (and (>= val-len 2)
		       (eql (schar val 0) #\-))
		(if (eql (schar val 1) #\-)
		  (find val cla
			:key #'command-line-argument-long-name
			:test #'(lambda (k v) (string= k v :start1 2)))
		  (progn
		    (setq short-p t)
		    (find (schar val 1) cla
			  :key #'command-line-argument-option-char))))))
	(if (null option)
	  (if (and (>= val-len 1)
		   (eql (schar val 0) #\-))
            (if (and (= val-len 2)
                     (eql (schar val 1) #\-))
              (setq rest-arg vals
                    vals nil)
              (return (values :unknown-option val nil nil)))
	    (push val non-options))	;non-option argument
	  ;; We recognized the option.  Is it a duplicate of
	  ;; something already seen?
	  (let* ((key (command-line-argument-keyword option))
		 (operand nil))
	    (when (and (assoc key options)
		       (not (command-line-argument-allow-multiple option)))
	      (return (values :duplicate-option val nil)))
	    (when (command-line-argument-may-take-operand option)
	      ;; A short option name can be followed by the operand,
	      ;; without intervening whitespace.
	      (if (and short-p (> val-len 2))
		(setq operand (subseq val 2))
		(if vals
		  (setq operand (pop vals))
		  (return (values :missing-operand val nil)))))
	    (push (cons key operand) options)))))))

(defmethod summarize-option-syntax ((a application))
  (flet ((summarize-option (o)
	   (format nil "~8t-~a, --~a : ~a~%"
		   (command-line-argument-option-char o)
		   (command-line-argument-long-name o)
		   (command-line-argument-help-string o))))
    (format nil "~{~a~}" (mapcar #'summarize-option
				 (slot-value a 'command-line-arguments)))))

  
;;; Process the "help" and "version" options, report parsing errors.
(defmethod process-application-arguments ((a application) error-flag opts args)
  (declare (ignore args))
  (if (null error-flag)
    (if (assoc :help opts)
      (%usage-exit "" 0 (summarize-option-syntax a))
      (if (assoc :version opts)
        ;; Can't use lisp streams yet.
	(progn
          (with-cstrs ((s (format nil "~&~a~&" (application-version-string a))))
            (fd-write 1 s (%cstrlen s)))
	  (#_ _exit 0))
        (let* ((encoding (assoc :terminal-encoding opts)))
          (when (cdr encoding)
            (let* ((encoding-name
                    (let* ((*package* (find-package "KEYWORD")))
                      (ignore-errors (read-from-string (cdr encoding))))))
              (when encoding-name
                (let* ((character-encoding (lookup-character-encoding encoding-name)))
                  (when character-encoding
                    (setq *terminal-character-encoding-name*
                          (character-encoding-name character-encoding))))))))))
    (%usage-exit
     (format nil
	     (case error-flag
	       (:missing-argument "Missing argument to ~a option")
	       (:duplicate-argument "Duplicate ~a option")
	       (:unknown-option "Unknown option: ~a")
	       (t "~a"))
	     opts)
     #-windows-target #-android-target #$EX_USAGE #+android-target 64 #+windows-target #$EXIT_FAILURE
     (summarize-option-syntax a))))
	       

;;; an example method to base a specialization on
(defmethod toplevel-function  ((a application) init-file)
  (declare (ignore init-file))
  nil )

(defmethod toplevel-function :before ((a application) init-file)
  (declare (ignore init-file))
  (multiple-value-bind (error-flag options args rest-arg)
      (parse-application-arguments a)
    (setq *unprocessed-command-line-arguments* rest-arg)
    (process-application-arguments a error-flag options args)
    (let* ((encoding (lookup-character-encoding *terminal-character-encoding-name*)))
      (when encoding
         (set-terminal-encoding (character-encoding-name encoding))))))

(defmethod repl-function-name ((a application))
  "Return the name of a function that should be run in a TTY-like
listener thread (if that concept makes sense); return NIL otherwise."
  nil)

(defmethod application-version-string ((a application))
  "Return a string which (arbitrarily) represents the application version.
Default version returns Clozure CL version info."
  (lisp-implementation-version))

(defmethod application-ui-operation ((a application) operation &rest args)
  (let* ((ui-object (application-ui-object a)))
    (when ui-object
      (apply #'ui-object-do-operation ui-object operation args))))




(defmethod application-init-file     ((app application)) nil)


(defclass lisp-development-system (application) 
  ((command-line-arguments
    :initform
    (list *standard-help-argument*
	  *standard-version-argument*
          *standard-terminal-encoding-argument*
	  (make-command-line-argument
	   :option-char #\n
	   :long-name "no-init"
	   :keyword :noinit
	   :help-string "suppress loading of init file")
	  (make-command-line-argument
	   :option-char #\e
	   :long-name "eval"
	   :keyword :eval
	   :help-string "evaluate <form> (may need to quote <form> in shell)"
	   :may-take-operand t
	   :allow-multiple t)
	  (make-command-line-argument
	   :option-char #\l
	   :long-name "load"
	   :keyword :load
	   :help-string "load <file>"
	   :may-take-operand t
	   :allow-multiple t)
	  (make-command-line-argument
	   :option-char #\T
	   :long-name "set-lisp-heap-gc-threshold"
	   :help-string "set lisp-heap-gc-threshold to <n>"
	   :keyword :gc-threshold
	   :may-take-operand t
	   :allow-multiple nil)
          (make-command-line-argument
           :option-char #\Q
           :long-name "quiet"
           :help-string "if --batch, also suppress printing of heralds, prompts"
           :keyword :quiet
           :may-take-operand nil
           :allow-multiple nil)
          ))
   (initial-listener-process :initform nil)))

(defparameter *application*
  (make-instance 'lisp-development-system))

(defvar *ccl-init-file*
  #+unix '("home:ccl-init" "home:\\.ccl-init")
  #+windows "home:ccl-init"
  "Global default init file for CCL. This file will be loaded by the first listener process.
   It's probably a better idea to specialize application-init-file than to override this value.")

(defloadvar *load-lisp-init-file* t)
(defloadvar *lisp-startup-parameters* ())

(defmethod process-application-arguments ((a lisp-development-system)
					  error-flag options args)
  (declare (ignorable error-flag))
  (call-next-method)			; handle help, errors
  (if args
    (%usage-exit (format nil "Unrecognized non-option arguments: ~a" args)
		 #-windows-target #-android-target #$EX_USAGE #+android-target 64 #+windows-target #$EXIT_FAILURE
		 (summarize-option-syntax a))
    (progn
      (setq *load-lisp-init-file* (not (assoc :noinit options))
            *quiet-flag* (if *batch-flag*
                           (not (null (assoc :quiet options))))
            *lisp-startup-parameters*
            (mapcan #'(lambda (x)
                        (and (member (car x) '(:load :eval :gc-threshold)) (list x)))
                    options)))))
	

(defmethod repl-function-name ((a lisp-development-system))
  'listener-function)

(defmethod toplevel-function ((a lisp-development-system) init-file)
  (let* ((sr (input-stream-shared-resource *terminal-input*))
         (f (or (repl-function-name a) 'listener-function)))
    (with-slots (initial-listener-process) a
      (setq initial-listener-process
            (make-mcl-listener-process
             "listener"
             *terminal-input*
             *terminal-output*
             #'(lambda () (when sr (setf (shared-resource-primary-owner sr)
                                         *initial-process*)))
             :initial-function
             #'(lambda ()
                 (startup-ccl (and *load-lisp-init-file* init-file))
                 (funcall f)
                 nil)
             :close-streams nil
             :control-stack-size *initial-listener-default-control-stack-size*
             :value-stack-size *initial-listener-default-value-stack-size*
             :temp-stack-size *initial-listener-default-temp-stack-size*
             :class 'tty-listener
             :process initial-listener-process))))
  (%set-toplevel (lambda ()
                   (with-standard-initial-bindings
                       (housekeeping-loop))))
  (toplevel))

(defun housekeeping-loop ()
  (with-standard-abort-handling nil 
    (loop
      #+windows-target (#_SleepEx 333 #$true)
      #-windows-target (%nanosleep *periodic-task-seconds* *periodic-task-nanoseconds*)
      (housekeeping))))
  

(defmethod application-init-file ((app lisp-development-system))
  ;; This is the init file loaded before cocoa.
  *ccl-init-file*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-application.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/x86-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 2005-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


(in-package "CCL")

#+x8664-target
(defun xp-argument-count (xp)
  (ldb (byte (- 16 x8664::fixnumshift) 0)
                    (encoded-gpr-lisp xp x8664::nargs.q)))

#+x8632-target
(defun xp-argument-count (xp)
  (encoded-gpr-lisp xp target::nargs))

#+x8664-target
(defun xp-argument-list (xp)
  (let ((nargs (xp-argument-count xp))
        (arg-x (encoded-gpr-lisp xp x8664::arg_x))
        (arg-y (encoded-gpr-lisp xp x8664::arg_y))
        (arg-z (encoded-gpr-lisp xp x8664::arg_z)))
    (cond ((eql nargs 0) nil)
          ((eql nargs 1) (list arg-z))
          ((eql nargs 2) (list arg-y arg-z))
          (t
           (let ((args (list arg-x arg-y arg-z)))
             (if (eql nargs 3)
               args
               (let ((sp (%inc-ptr (encoded-gpr-macptr xp x8664::rsp)
                                   (+ x8664::node-size x8664::xcf.size))))
                 (dotimes (i (- nargs 3))
                   (push (%get-object sp (* i x8664::node-size)) args))
                 args)))))))

#+x8632-target
(defun xp-argument-list (xp)
  (let ((nargs (xp-argument-count xp))
        (arg-y (encoded-gpr-lisp xp x8632::arg_y))
        (arg-z (encoded-gpr-lisp xp x8632::arg_z)))
    (cond ((eql nargs 0) nil)
          ((eql nargs 1) (list arg-z))
	  (t
	   (let ((args (list arg-y arg-z)))
	     (if (eql nargs 2)
	       args
	       (let ((sp (%inc-ptr (encoded-gpr-macptr xp x8632::ebp)
				   (+ x8632::node-size x8632::xcf.size))))
		 (dotimes (i (- nargs 2))
		   (push (%get-object sp (* i x8632::node-size)) args))
		 args)))))))

;;; Making this be continuable is hard, because of the xcf on the
;;; stack and the way that the kernel saves/restores rsp and rbp
;;; before calling out.  If we get around those problems, then
;;; we have to also deal with the fact that the return address
;;; is on the stack.  Easiest to make the kernel deal with that,
;;; and just set %fn to the function that returns the values
;;; returned by the (newly defined) function and %arg_z to
;;; that list of values.
(defun handle-udf-call (xp frame-ptr)
  (let* ((args (xp-argument-list xp))
         (values (multiple-value-list
                  (%kernel-restart-internal
                   $xudfcall
                   (list (maybe-setf-name (encoded-gpr-lisp xp target::fname)) args)
                   frame-ptr)))
         (f #'(lambda (values) (apply #'values values))))
    (setf (encoded-gpr-lisp xp target::arg_z) values
          (encoded-gpr-lisp xp target::fn) f)))

#+x8664-target
(defcallback %xerr-disp (:address xp :address xcf :int)
  (with-error-reentry-detection
      (let* ((frame-ptr (macptr->fixnum xcf))
             (fn (%get-object xcf x8664::xcf.nominal-function))
             (op0 (%get-xcf-byte xcf 0))
             (op1 (%get-xcf-byte xcf 1))
             (op2 (%get-xcf-byte xcf 2)))
        (declare (type (unsigned-byte 8) op0 op1 op2))
        (let* ((skip 2))
          (if (and (= op0 #xcd)
                   (>= op1 #x70))
            (cond ((< op1 #x90)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (setq *error-reentry-count* 0)
                   (setf (encoded-gpr-lisp xp (ldb (byte 4 0) op1))
                         (%slot-unbound-trap
                          (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                          (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                          frame-ptr)))
                  ((= op1 #x90)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (setf (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                         (%kernel-restart-internal $xvunbnd
                                                   (list
                                                    (encoded-gpr-lisp
                                                     xp
                                                     (ldb (byte 4 0) op2)))
                                                   frame-ptr)))
                  ((< op1 #xa0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   ;; #x9x, x>0 - register X is a symbol.  It's unbound,
                   ;; but we don't have enough info to offer USE-VALUE,
                   ;; STORE-VALUE, or CONTINUE restarts.
                   (%error (make-condition 'unbound-variable
                                           :name
                                           (encoded-gpr-lisp
                                               xp
                                               (ldb (byte 4 0) op1)))
                           ()
                           frame-ptr))
                  ((< op1 #xb0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%err-disp-internal $xfunbnd
                                       (list (encoded-gpr-lisp
                                              xp
                                              (ldb (byte 4 0) op1)))
                                       frame-ptr))
                  ((< op1 #xc0)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (%err-disp-internal 
                    #.(car (rassoc 'type-error *kernel-simple-error-classes*))
                    (list (encoded-gpr-lisp
                           xp
                           (ldb (byte 4 0) op1))
                          (logandc2 op2 arch::error-type-error))
                    frame-ptr))
                  ((= op1 #xc0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error 'too-few-arguments
                           (list :nargs (xp-argument-count xp)
                                 :fn fn)
                           frame-ptr))
                  ((= op1 #xc1)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error 'too-many-arguments
                           (list :nargs (xp-argument-count xp)
                                 :fn fn)
                           frame-ptr))
                  ((= op1 #xc2)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (let* ((flags (xp-flags-register xp))
                          (nargs (xp-argument-count xp))
                          (carry-bit (logbitp x86::x86-carry-flag-bit flags)))
                     (if carry-bit
                       (%error 'too-few-arguments
                               (list :nargs nargs
                                     :fn fn)
                               frame-ptr)
                       (%error 'too-many-arguments
                               (list :nargs nargs
                                     :fn fn)
                               frame-ptr))))
                  ((= op1 #xc3)         ;array rank
                   (setq skip (%check-anchored-uuo xcf 3))                   
                   (%err-disp-internal $XNDIMS
                                       (list (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                                             (encoded-gpr-lisp xp (ldb (byte 4 0) op2)))
                                       frame-ptr))
                  ((= op1 #xc6)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp xp x8664::temp0)
                                           :expected-type '(or symbol function)
                                           :format-control
                                           "~S is not of type ~S, and can't be FUNCALLed or APPLYed")
                           nil frame-ptr))
                  ((= op1 #xc7)
                   (handle-udf-call xp frame-ptr)
                   (setq skip 0))
                  ((or (= op1 #xc8) (= op1 #xcb))
                   (setq skip (%check-anchored-uuo xcf 3))
                   (%error (%rsc-string $xarroob)
                           (list (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                                 (encoded-gpr-lisp xp (ldb (byte 4 0) op2)))
                           frame-ptr))
                  ((= op1 #xc9)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%err-disp-internal $xnotfun
                                       (list (encoded-gpr-lisp xp x8664::temp0))
                                       frame-ptr))
                  ;; #xca = uuo-error-debug-trap
                  ((= op1 #xcc)
                   ;; external entry point or foreign variable
                   (setq skip (%check-anchored-uuo xcf 3))
                   (let* ((eep-or-fv (encoded-gpr-lisp xp (ldb (byte 4 4) op2))))
                     (etypecase eep-or-fv
                       (external-entry-point
                        (resolve-eep eep-or-fv)
                        (setf (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                              (eep.address eep-or-fv)))
                       (foreign-variable
                        (resolve-foreign-variable eep-or-fv)
                        (setf (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                              (fv.addr eep-or-fv))))))
                  ((< op1 #xe0)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (if (= op2 x8664::subtag-catch-frame)
                     (%error (make-condition 'cant-throw-error
                                             :tag (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 4 0) op1)))
                             nil frame-ptr)
                     (let* ((typename
                             (cond ((= op2 x8664::tag-fixnum) 'fixnum)
                                   ((= op2 x8664::tag-single-float) 'single-float)
                                   ((= op2 x8664::subtag-character) 'character)
                                   ((= op2 x8664::fulltag-cons) 'cons)
                                   ((= op2 x8664::tag-misc) 'uvector)
                                   ((= op2 x8664::fulltag-symbol) 'symbol)
                                   ((= op2 x8664::fulltag-function) 'function)
                                   (t (let* ((class (logand op2 x8664::fulltagmask))
                                             (high4 (ash op2 (- x8664::ntagbits))))
                                        (cond ((= class x8664::fulltag-nodeheader-0)
                                               (svref *nodeheader-0-types* high4))
                                              ((= class x8664::fulltag-nodeheader-1)
                                               (svref *nodeheader-1-types* high4))
                                              ((= class x8664::fulltag-immheader-0)
                                               (svref *immheader-0-types* high4))
                                              ((= class x8664::fulltag-immheader-1)
                                               (svref *immheader-1-types* high4))
                                              ((= class x8664::fulltag-immheader-2)
                                               (svref *immheader-2-types* high4))
                                              (t (list 'bogus op2))))))))
                       (%error (make-condition 'type-error
                                               :datum (encoded-gpr-lisp
                                                       xp
                                                       (ldb (byte 4 0) op1))
                                               :expected-type typename)
                               nil
                               frame-ptr))))
                  ((< op1 #xf0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 4 0) op1))
                                           :expected-type 'list)
                           nil
                           frame-ptr))
                  (t
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 4 0) op1))
                                           :expected-type 'fixnum)
                           nil
                           frame-ptr)))
            (%error "Unknown trap: #x~x~%xp=~s"
                    (list (list op0 op1 op2) xp)
                    frame-ptr))
          skip))))

;;; lots of duplicated code here
#+x8632-target
(defcallback %xerr-disp (:address xp :address xcf :int)
  (with-error-reentry-detection
      (let* ((frame-ptr (macptr->fixnum xcf))
             (fn (%get-object xcf x8632::xcf.nominal-function))
             (op0 (%get-xcf-byte xcf 0))
             (op1 (%get-xcf-byte xcf 1))
             (op2 (%get-xcf-byte xcf 2)))
        (declare (type (unsigned-byte 8) op0 op1 op2))
        (let* ((skip 2))
          (if (and (= op0 #xcd)
                   (>= op1 #x70))
            (cond ((< op1 #x90)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (setq *error-reentry-count* 0)
                   (setf (encoded-gpr-lisp xp (ldb (byte 3 0) op1))
                         (%slot-unbound-trap
                          (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                          (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                          frame-ptr)))
                  ((= op1 #x90)
		   (setq skip (%check-anchored-uuo xcf 3))
                   (setf (encoded-gpr-lisp
                          xp
                          (ldb (byte 3 0) op2))
                         (%kernel-restart-internal $xvunbnd
                                                   (list
                                                    (encoded-gpr-lisp
                                                     xp
                                                     (ldb (byte 3 0) op2)))
                                                   frame-ptr)))
                  ((< op1 #xa0)
		   (setq skip (%check-anchored-uuo xcf 2))
                   ;; #x9x, x>- - register X is a symbol.  It's unbound,
                   ;; but we don't have enough info to offer USE-VALUE,
                   ;; STORE-VALUE, or CONTINUE restart
                   (%error (make-condition 'unbound-variable
                                           :name
                                           (encoded-gpr-lisp
                                               xp
                                               (ldb (byte 3 0) op1)))
                           ()
                           frame-ptr))
                  ((< op1 #xb0)
		   (setq skip (%check-anchored-uuo xcf 2))
                   (%err-disp-internal $xfunbnd
                                       (list (encoded-gpr-lisp
                                              xp
                                              (ldb (byte 3 0) op1)))
                                       frame-ptr))
                  ((< op1 #xc0)
		   (setq skip (%check-anchored-uuo xcf 3))
                   (%err-disp-internal 
                    #.(car (rassoc 'type-error *kernel-simple-error-classes*))
                    (list (encoded-gpr-lisp
                           xp
                           (ldb (byte 3 0) op1))
                          (logandc2 op2 arch::error-type-error))
                    frame-ptr))
                  ((= op1 #xc0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error 'too-few-arguments
                           (list :nargs (xp-argument-count xp)
                                 :fn fn)
                           frame-ptr))
                  ((= op1 #xc1)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error 'too-many-arguments
                           (list :nargs (xp-argument-count xp)
                                 :fn fn)
                           frame-ptr))
                  ((= op1 #xc2)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (let* ((flags (xp-flags-register xp))
                          (nargs (xp-argument-count xp))
                          (carry-bit (logbitp x86::x86-carry-flag-bit flags)))
                     (if carry-bit
                       (%error 'too-few-arguments
                               (list :nargs nargs
                                     :fn fn)
                               frame-ptr)
                       (%error 'too-many-arguments
                               (list :nargs nargs
                                     :fn fn)
                               frame-ptr))))
                  ((= op1 #xc3)         ;array rank
                   (setq skip (%check-anchored-uuo xcf 3))
                   (%err-disp-internal $XNDIMS
                                       (list (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                                             (encoded-gpr-lisp xp (ldb (byte 4 0) op2)))
                                       frame-ptr))
                  ((= op1 #xc6)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp xp x8632::temp0)
                                           :expected-type '(or symbol function)
                                           :format-control
                                           "~S is not of type ~S, and can't be FUNCALLed or APPLYed")
                           nil frame-ptr))
                  ((= op1 #xc7)
                   (handle-udf-call xp frame-ptr)
                   (setq skip 0))
                  ((or (= op1 #xc8) (= op1 #xcb))
                   (setq skip (%check-anchored-uuo xcf 3))
                   (%error (%rsc-string $xarroob)
                           (list (encoded-gpr-lisp xp (ldb (byte 4 4) op2))
                                 (encoded-gpr-lisp xp (ldb (byte 4 0) op2)))
                           frame-ptr))
                  ((= op1 #xc9)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%err-disp-internal $xnotfun
                                       (list (encoded-gpr-lisp xp x8632::temp0))
                                       frame-ptr))
                  ;; #xca = uuo-error-debug-trap
                  ((= op1 #xcc)
                   ;; external entry point or foreign variable
                   (setq skip (%check-anchored-uuo xcf 3))
                   (let* ((eep-or-fv (encoded-gpr-lisp xp (ldb (byte 4 4) op2))))
                     (etypecase eep-or-fv
                       (external-entry-point
                        (resolve-eep eep-or-fv)
                        (setf (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                              (eep.address eep-or-fv)))
                       (foreign-variable
                        (resolve-foreign-variable eep-or-fv)
                        (setf (encoded-gpr-lisp xp (ldb (byte 4 0) op2))
                              (fv.addr eep-or-fv))))))
                  ((< op1 #xe0)
                   (setq skip (%check-anchored-uuo xcf 3))
                   (if (= op2 x8632::subtag-catch-frame)
                     (%error (make-condition 'cant-throw-error
                                             :tag (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 3 0) op1)))
                             nil frame-ptr)
                     (let* ((typename
                             (cond ((= op2 x8632::tag-fixnum) 'fixnum)
                                   ((= op2 x8632::subtag-character) 'character)
                                   ((= op2 x8632::fulltag-cons) 'cons)
                                   ((= op2 x8632::tag-misc) 'uvector)
				   (t (let* ((class (logand op2 x8632::fulltagmask))
                                             (high5 (ash op2 (- x8632::ntagbits))))
                                        (cond ((= class x8632::fulltag-nodeheader)
                                               (svref *nodeheader-types* high5))
                                              ((= class x8632::fulltag-immheader)
                                               (svref *immheader-types* high5))
                                              (t (list 'bogus op2))))))))
                       (%error (make-condition 'type-error
                                               :datum (encoded-gpr-lisp
                                                       xp
                                                       (ldb (byte 3 0) op1))
                                               :expected-type typename)
                               nil
                               frame-ptr))))
                  ((< op1 #xf0)
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 3 0) op1))
                                           :expected-type 'list)
                           nil
                           frame-ptr))
                  (t
                   (setq skip (%check-anchored-uuo xcf 2))
                   (%error (make-condition 'type-error
                                           :datum (encoded-gpr-lisp
                                                   xp
                                                   (ldb (byte 3 0) op1))
                                           :expected-type 'fixnum)
                           nil
                           frame-ptr)))
            (%error "Unknown trap: #x~x~%xp=~s"
                    (list (list op0 op1 op2) xp)
                    frame-ptr))
          skip))))
                 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/x86-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-init.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :execute :load-toplevel)

(defconstant most-positive-short-float (make-short-float-from-fixnums (1- (ash 1 23)) 254 0))
(defconstant most-negative-short-float (make-short-float-from-fixnums (1- (ash 1 23)) 254 -1))
(defconstant most-positive-single-float (make-short-float-from-fixnums (1- (ash 1 23)) 254 0))
(defconstant most-negative-single-float (make-short-float-from-fixnums (1- (ash 1 23)) 254 -1))


(defconstant least-positive-short-float (make-short-float-from-fixnums 1 0 0))
(defconstant least-negative-short-float (make-short-float-from-fixnums 1 0 -1))
(defconstant least-positive-single-float (make-short-float-from-fixnums 1 0 0))
(defconstant least-negative-single-float (make-short-float-from-fixnums 1 0 -1))

(defconstant short-float-epsilon (make-short-float-from-fixnums 1 103 0))
(defconstant short-float-negative-epsilon (make-short-float-from-fixnums 1 102 0))
(defconstant single-float-epsilon (make-short-float-from-fixnums 1 103 0))
(defconstant single-float-negative-epsilon (make-short-float-from-fixnums 1 102 0))

(defconstant least-positive-normalized-short-float (make-short-float-from-fixnums 1 1 0))
(defconstant least-negative-normalized-short-float (make-short-float-from-fixnums 1 1 -1))
(defconstant least-positive-normalized-single-float (make-short-float-from-fixnums 1 1 0))
(defconstant least-negative-normalized-single-float (make-short-float-from-fixnums 1 1 -1))

(let ((bigfloat (make-float-from-fixnums #x1ffffff #xfffffff #x7fe 0)))
  ; do it this way if you want to be able to compile before reading floats works  
  (defconstant most-positive-double-float bigfloat)
  (defconstant most-positive-long-float bigfloat)
  )

(let ((littleposfloat (make-float-from-fixnums 0 1 0 0 )))
  (defconstant least-positive-double-float littleposfloat)
  (defconstant least-positive-long-float littleposfloat)
  )

(let ((littlenegfloat (make-float-from-fixnums 0 1 0 -1)))  
  (defconstant least-negative-double-float littlenegfloat)
  (defconstant least-negative-long-float littlenegfloat)
  )

(let ((bignegfloat (make-float-from-fixnums #x1ffffff #xfffffff #x7fe -1)))
  (defconstant most-negative-double-float bignegfloat)
  (defconstant most-negative-long-float bignegfloat)
  )

(let ((eps (make-float-from-fixnums #x1000000 1 #x3ca 0))) ;was wrong
  (defconstant double-float-epsilon eps)
  (defconstant long-float-epsilon eps)
  )

(let ((eps- (make-float-from-fixnums #x1000000 1 #x3c9 1)))
  (defconstant double-float-negative-epsilon eps-)
  (defconstant long-float-negative-epsilon eps-)
  )

(let ((norm (make-float-from-fixnums 0 0 1 0)))
  (defconstant least-positive-normalized-double-float norm)
  (defconstant least-positive-normalized-long-float norm)
  )

(let ((norm- (make-float-from-fixnums 0 0 1 -1)))
  (defconstant least-negative-normalized-double-float norm-)
  (defconstant least-negative-normalized-long-float norm-)
  )

(defconstant pi (make-float-from-fixnums #x921fb5 #x4442d18 #x400 0))

)



(defconstant boole-clr 0
  "Boole function op, makes BOOLE return 0.")
(defconstant boole-set 1
  "Boole function op, makes BOOLE return -1.")
(defconstant boole-1 2
  "Boole function op, makes BOOLE return integer1.")
(defconstant boole-2 3
  "Boole function op, makes BOOLE return integer2.")
(defconstant boole-c1 4
  "Boole function op, makes BOOLE return complement of integer1.")
(defconstant boole-c2 5
  "Boole function op, makes BOOLE return complement of integer2.")
(defconstant boole-and 6
  "Boole function op, makes BOOLE return logand of integer1 and integer2.")
(defconstant boole-ior 7
  "Boole function op, makes BOOLE return logior of integer1 and integer2.")
(defconstant boole-xor 8
  "Boole function op, makes BOOLE return logxor of integer1 and integer2.")
(defconstant boole-eqv 9
  "Boole function op, makes BOOLE return logeqv of integer1 and integer2.")
(defconstant boole-nand 10
  "Boole function op, makes BOOLE return log nand of integer1 and integer2.")
(defconstant boole-nor 11
  "Boole function op, makes BOOLE return lognor of integer1 and integer2.")
(defconstant boole-andc1 12
  "Boole function op, makes BOOLE return logandc1 of integer1 and integer2.")
(defconstant boole-andc2 13
  "Boole function op, makes BOOLE return logandc2 of integer1 and integer2.")
(defconstant boole-orc1 14
  "Boole function op, makes BOOLE return logorc1 of integer1 and integer2.")
(defconstant boole-orc2 15
  "Boole function op, makes BOOLE return logorc2 of integer1 and integer2.")



(defconstant internal-time-units-per-second #+64-bit-target 1000000 #-64-bit-target 1000
  "The number of internal time units that fit into a second. See
  GET-INTERNAL-REAL-TIME and GET-INTERNAL-RUN-TIME.")

(defconstant char-code-limit #.(arch::target-char-code-limit
                                (backend-target-arch *target-backend*))
  "the upper exclusive bound on values produced by CHAR-CODE")

(defconstant array-rank-limit (floor #x8000 target::node-size)
  "the exclusive upper bound on the rank of an array")
(defconstant multiple-values-limit 200
  "The exclusive upper bound on the number of multiple VALUES that you can
  return.")
(defconstant lambda-parameters-limit (floor #x8000 target::node-size)
  "The exclusive upper bound on the number of parameters which may be specifed
  in a given lambda list. This is actually the limit on required and &OPTIONAL
  parameters. With &KEY and &AUX you can get more.")
(defconstant call-arguments-limit #+ppc-target (floor #x8000 target::node-size)
	                          #-ppc-target #x10000
  "The exclusive upper bound on the number of arguments which may be passed
  to a function, including &REST args."
)

; Currently, vectors can be at most (expt 2 22) bytes, and
; the largest element (double-float or long-float) is 8 bytes:
#| to get largest element size...
(apply #'max (mapcar #'(lambda (type)
                         (%vect-byte-size (make-array 1 :element-type type)))
                     *cl-types*))
|#

(defconstant array-dimension-limit array-total-size-limit
  "the exclusive upper bound on any given dimension of an array")

(defconstant most-positive-fixnum target::target-most-positive-fixnum
  "the fixnum closest in value to positive infinity")
(defconstant most-negative-fixnum target::target-most-negative-fixnum
  "the fixnum closest in value to negative infinity")

(defstatic *least-positive-bignum* (1+ target::target-most-positive-fixnum)
  "used internally; value should be treated as a constant")


(defconstant lambda-list-keywords 
  '(&OPTIONAL &REST &AUX &KEY &ALLOW-OTHER-KEYS &BODY &ENVIRONMENT &WHOLE
    &lexpr &lap)
  "symbols which are magical in a lambda list")

(defstatic *type-system-initialized* nil)

(defparameter %toplevel-catch% ':toplevel)



(defparameter *warn-if-redefine-kernel* nil
  "When true, attempts to redefine (via DEFUN or DEFMETHOD) functions and
methods that are marked as being predefined signal continuable errors.")

(defvar *next-screen-context-lines* 2 "Number of lines to show of old screen
  after a scroll-up or scroll-down.")

(defparameter *compiling-file* nil 
  "Name of outermost file being compiled or NIL if not compiling a file.")

(defvar *eval-fn-name* nil)


(defvar *compile-definitions* t
  "When non-NIL and the evaluator's lexical environment contains no
  lexical entities, causes FUNCTION and NFUNCTION forms to be compiled.")
#|
(defvar *fast-eval* ()
  "If non-nil, compile-and-call any forms which would be expensive to evaluate.")
|#
(defvar *declaration-handlers* ())


(defvar *lisp-system-pointer-functions* nil)
(defvar *lisp-user-pointer-functions* nil)
(defvar *lisp-cleanup-functions* nil)   ; list of (0-arg) functions to call before quitting Lisp
(defvar *lisp-startup-functions* nil)   ; list of funs to call after startup.
(defvar %lisp-system-fixups% nil)


(setf (*%saved-method-var%*) nil)

; The GC expects these to be NIL or a function of no args
(defvar *pre-gc-hook* nil)
(defvar *post-gc-hook* nil)

; These are used by add-gc-hook, delete-gc-hook
(defvar *pre-gc-hook-list* nil)
(defvar *post-gc-hook-list* nil)

(defvar *backtrace-dialogs* nil)
;(defvar *stepper-running* nil)
(defparameter *last-mouse-down-time* 0)
(defparameter *last-mouse-down-position* 0)

(defvar %handlers% ())


#|
(defvar %restarts% (list (list (%cons-restart 'abort
                                              #'(lambda (&rest ignore)
                                                  (declare (ignore ignore))
                                                  (throw :toplevel nil))
                                              "Restart the toplevel loop."
                                              nil
                                              nil))))
|#

(defvar %restarts% nil)

(defvar ccl::*kernel-restarts* nil)
(defvar *condition-restarts* nil "explicit mapping between c & r")
(declaim (list %handlers% %restarts% ccl::*kernel-restarts* *condition-restarts*))




(defparameter *%periodic-tasks%* nil)
(defparameter *dribble-stream* nil)

(defconstant *keyword-package* *keyword-package*)
(defconstant *common-lisp-package* *common-lisp-package*)
(defconstant *ccl-package* *ccl-package*)

(defparameter *load-print* nil "the default for the :PRINT argument to LOAD")
(defparameter *loading-files* nil)
(defparameter *break-level* 0)
(defparameter *last-break-level* 0)
(defparameter *warn-if-redefine* nil)
(defvar *record-source-file*)           ; set in l1-utils.
(defparameter *level-1-loaded* nil)     ; set t by l1-boot
(defparameter *save-definitions* nil)
(defparameter *save-local-symbols* t)
(defparameter *save-source-locations* T
  "Controls whether source location information is saved, both for definitions (names) and
in function objects.

If NIL we don't store any source locations (other than the filename if *record-source-file* is non-NIL).

If T we store as much source location information as we have available.

If :NO-TEXT we don't store a copy of the original source text.  This is a space optimization useful
for compiling files that are not expected to change.")

(defparameter *record-pc-mapping* t "True to record pc -> source mapping (but only if
*save-source-locations* is also true)")

(defvar *modules* nil
  "This is a list of module names that have been loaded into Lisp so far.
   The names are case sensitive strings.  It is used by PROVIDE and REQUIRE.")





(defparameter *eof-value* (cons nil nil))

(defvar *gc-event-status-bits*)         ; also initialized by kernel

(defparameter *top-listener* nil)







(defvar *listener-indent* nil)

(defparameter *autoload-lisp-package* nil)   ; Make 'em suffer
(defparameter *apropos-case-sensitive-p* nil)

(defloadvar *total-gc-microseconds* (let* ((timeval-size
                                            #.(%foreign-type-or-record-size
                                               :timeval :bytes))
                                           (p (malloc (* 5 timeval-size))))
                                      (#_memset p 0 (* 5 timeval-size))
                                      p))


(defloadvar *total-bytes-freed* (let* ((p (malloc 8)))
                                  (setf (%get-long p 0) 0
                                        (%get-long p 4) 0)
                                  p))



(defvar *terminal-character-encoding-name* :utf-8
  "NIL (implying :ISO-8859-1), or a keyword which names a defined
character encoding to be used for *TERMINAL-IO* and other predefined
initial streams.  The value of *TERMINAL-CHARACTER-ENCODING-NAME*
persists across calls to SAVE-APPLICATION; it can be specified via
the command-line argument --terminal-encoding (-K)")


(defconstant +null-ptr+ (%null-ptr))

(defparameter *load-preserves-optimization-settings* nil
  "When true, the effects of (PROCLAIM (OPTIMIZE ...)) - or the
   load-time effects of (DECLAIM (OPTIMIZE ...)) - in files being
   loaded do not persist after the containing file has been loaded.
   When false, those effects persist until superseded.")

;;; end of L1-init.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-init.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-reader.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; READ and related functions.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
  (defconstant readtable-case-keywords '((:upcase . 1) (:downcase . 2) (:preserve . 0)
                                         (:invert . -1) (:studly . -2)))
  (defmacro readtable-case-keywords () `',readtable-case-keywords))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod make-load-form ((ref package-ref) &optional env)
  (declare (ignore env))
  `(register-package-ref ',(package-ref.name ref)))

(defmethod print-object ((ref package-ref) stream)
  (print-unreadable-object (ref stream :type t :identity t)
    (format stream "for ~s [~s]" (package-ref.name ref) (package-ref.pkg ref))))

;;; Maps character names to characters
(defvar *name->char* (make-hash-table :test #'equalp))
;;; Maps characters to (canonical) character names.
(defvar *char->name* (make-hash-table :test #'eql))

;;; This isn't thread-safe.  If the user really wants to register character
;;; names from multiple threads, they should do their own locking.
(defun register-character-name (name char)
  (setf (gethash name *name->char*) char)    
  (unless (gethash char *char->name*)
    (setf (gethash char *char->name*) name)))

(dolist (pair '(
                ;; Standard character names
                ("Newline" .  #\012) ("Space" . #\040)
                ;; Semi-standard character names
                ("Rubout" . #\177) ("Page" . #\014) ("Tab" . #\011)
                ("Backspace" . #\010) ("Return" . #\015) ("Linefeed" . #\012)
                ;; Other character names.  (When available, standard
                ;; names should be used for printing in preference to
                ;; any non-standard names.)
                ("Null" . #\000) ("Nul" . #\000)
		("SOH" . #\001)
		("STX" . #\002)
		("ETX" . #\003)
		("EOT" . #\004)
		("ENQ" . #\005)
		("ACK" . #\006)
                ("Bell"  . #\007) ("BEL" . #\007)       ; ^G , used by Franz (and others with bells.)
                ("Delete" . #\010) ("BS" . #\010)
		("HT" . #\011)
                ("LF" . #\012) ("NL" . #\012)
                ("PageUp" . #\013) ("VT" . #\013)
                ("PageDown" . #\014) ("Formfeed" . #\014) ("FF" . #\014) ("NP" . #\014)
                ("CR" . #\015)
		("SO" . #\016)
		("SI" . #\017)
                ("Sub" . #\032)
                ("ESC" .  #\033) ("Escape" . #\033) ("Clear" .  #\033)
                ("Altmode" .  #\033) ("ALT" .  #\033)
                ("Fs" . #\034)
                ("Gs" . #\035)
                ("Rs" . #\036)
                ("Us" . #\037)
                ("Dle" . #\020)
                ("Dc1" . #\021)
                ("Dc2" . #\022)
                ("Dc3" . #\023)
                ("Dc4" . #\024)
                ("Nak" . #\025)
                ("Syn" . #\026)
                ("Etb" . #\027)
                ("Can" . #\030)
                ("Em" . #\031)
                ("Sp" . #\040)
                ("DEL" . #\177)("ForwardDelete" . #\177)
                ("No-Break_Space" . #\u+00a0)
                ("Inverted_Exclamation_Mark" . #\u+00a1)
                ("Cent_Sign" . #\u+00a2)
                ("Pound_Sign" . #\u+00a3)
                ("Currency_Sign" . #\u+00a4)
                ("Yen_Sign" . #\u+00a5)
                ("Broken_Bar" . #\u+00a6)
                ("Section_Sign" . #\u+00a7)
                ("Diaeresis" . #\u+00a8)
                ("Copyright_Sign" . #\u+00a9)
                ("Feminine_Ordinal_Indicator" . #\u+00aa)
                ("Left-Pointing_Double_Angle_Quotation_Mark" . #\u+00ab)
                ("Not_Sign" . #\u+00ac)
                ("Soft_Hyphen" . #\u+00ad)
                ("Registered_Sign" . #\u+00ae)
                ("Macron" . #\u+00af)
                ("Degree_Sign" . #\u+00b0)
                ("Plus-Minus_Sign" . #\u+00b1)
                ("Superscript_Two" . #\u+00b2)
                ("Superscript_Three" . #\u+00b3)
                ("Acute_Accent" . #\u+00b4)
                ("Micro_Sign" . #\u+00b5)
                ("Pilcrow_Sign" . #\u+00b6)
                ("Middle_Dot" . #\u+00b7)
                ("Cedilla" . #\u+00b8)
                ("Superscript_One" . #\u+00b9)
                ("Masculine_Ordinal_Indicator" . #\u+00ba)
                ("Right-Pointing_Double_Angle_Quotation_Mark" . #\u+00bb)
                ("Vulgar_Fraction_One_Quarter" . #\u+00bc)
                ("Vulgar_Fraction_One_Half" . #\u+00bd)
                ("Vulgar_Fraction_Three_Quarters" . #\u+00be)
                ("Inverted_Question_Mark" . #\u+00bf)
                ("Latin_Capital_Letter_A_With_Grave" . #\u+00c0)
                ("Latin_Capital_Letter_A_With_Acute" . #\u+00c1)
                ("Latin_Capital_Letter_A_With_Circumflex" . #\u+00c2)
                ("Latin_Capital_Letter_A_With_Tilde" . #\u+00c3)
                ("Latin_Capital_Letter_A_With_Diaeresis" . #\u+00c4)
                ("Latin_Capital_Letter_A_With_Ring_Above" . #\u+00c5)
                ("Latin_Capital_Letter_Ae" . #\u+00c6)
                ("Latin_Capital_Letter_C_With_Cedilla" . #\u+00c7)
                ("Latin_Capital_Letter_E_With_Grave" . #\u+00c8)
                ("Latin_Capital_Letter_E_With_Acute" . #\u+00c9)
                ("Latin_Capital_Letter_E_With_Circumflex" . #\u+00ca)
                ("Latin_Capital_Letter_E_With_Diaeresis" . #\u+00cb)
                ("Latin_Capital_Letter_I_With_Grave" . #\u+00cc)
                ("Latin_Capital_Letter_I_With_Acute" . #\u+00cd)
                ("Latin_Capital_Letter_I_With_Circumflex" . #\u+00ce)
                ("Latin_Capital_Letter_I_With_Diaeresis" . #\u+00cf)
                ("Latin_Capital_Letter_Eth" . #\u+00d0)
                ("Latin_Capital_Letter_N_With_Tilde" . #\u+00d1)
                ("Latin_Capital_Letter_O_With_Grave" . #\u+00d2)
                ("Latin_Capital_Letter_O_With_Acute" . #\u+00d3)
                ("Latin_Capital_Letter_O_With_Circumflex" . #\u+00d4)
                ("Latin_Capital_Letter_O_With_Tilde" . #\u+00d5)
                ("Latin_Capital_Letter_O_With_Diaeresis" . #\u+00d6)
                ("Multiplication_Sign" . #\u+00d7)
                ("Latin_Capital_Letter_O_With_Stroke" . #\u+00d8)
                ("Latin_Capital_Letter_U_With_Grave" . #\u+00d9)
                ("Latin_Capital_Letter_U_With_Acute" . #\u+00da)
                ("Latin_Capital_Letter_U_With_Circumflex" . #\u+00db)
                ("Latin_Capital_Letter_U_With_Diaeresis" . #\u+00dc)
                ("Latin_Capital_Letter_Y_With_Acute" . #\u+00dd)
                ("Latin_Capital_Letter_Thorn" . #\u+00de)
                ("Latin_Small_Letter_Sharp_S" . #\u+00df)
                ("Latin_Small_Letter_A_With_Grave" . #\u+00e0)
                ("Latin_Small_Letter_A_With_Acute" . #\u+00e1)
                ("Latin_Small_Letter_A_With_Circumflex" . #\u+00e2)
                ("Latin_Small_Letter_A_With_Tilde" . #\u+00e3)
                ("Latin_Small_Letter_A_With_Diaeresis" . #\u+00e4)
                ("Latin_Small_Letter_A_With_Ring_Above" . #\u+00e5)
                ("Latin_Small_Letter_Ae" . #\u+00e6)
                ("Latin_Small_Letter_C_With_Cedilla" . #\u+00e7)
                ("Latin_Small_Letter_E_With_Grave" . #\u+00e8)
                ("Latin_Small_Letter_E_With_Acute" . #\u+00e9)
                ("Latin_Small_Letter_E_With_Circumflex" . #\u+00ea)
                ("Latin_Small_Letter_E_With_Diaeresis" . #\u+00eb)
                ("Latin_Small_Letter_I_With_Grave" . #\u+00ec)
                ("Latin_Small_Letter_I_With_Acute" . #\u+00ed)
                ("Latin_Small_Letter_I_With_Circumflex" . #\u+00ee)
                ("Latin_Small_Letter_I_With_Diaeresis" . #\u+00ef)
                ("Latin_Small_Letter_Eth" . #\u+00f0)
                ("Latin_Small_Letter_N_With_Tilde" . #\u+00f1)
                ("Latin_Small_Letter_O_With_Grave" . #\u+00f2)
                ("Latin_Small_Letter_O_With_Acute" . #\u+00f3)
                ("Latin_Small_Letter_O_With_Circumflex" . #\u+00f4)
                ("Latin_Small_Letter_O_With_Tilde" . #\u+00f5)
                ("Latin_Small_Letter_O_With_Diaeresis" . #\u+00f6)
                ("Division_Sign" . #\u+00f7)
                ("Latin_Small_Letter_O_With_Stroke" . #\u+00f8)
                ("Latin_Small_Letter_U_With_Grave" . #\u+00f9)
                ("Latin_Small_Letter_U_With_Acute" . #\u+00fa)
                ("Latin_Small_Letter_U_With_Circumflex" . #\u+00fb)
                ("Latin_Small_Letter_U_With_Diaeresis" . #\u+00fc)
                ("Latin_Small_Letter_Y_With_Acute" . #\u+00fd)
                ("Latin_Small_Letter_Thorn" . #\u+00fe)
                ("Latin_Small_Letter_Y_With_Diaeresis" . #\u+00ff)
                ("Latin_Capital_Letter_A_With_Macron" . #\u+0100)
                ("Latin_Small_Letter_A_With_Macron" . #\u+0101)
                ("Latin_Capital_Letter_A_With_Breve" . #\u+0102)
                ("Latin_Small_Letter_A_With_Breve" . #\u+0103)
                ("Latin_Capital_Letter_A_With_Ogonek" . #\u+0104)
                ("Latin_Small_Letter_A_With_Ogonek" . #\u+0105)
                ("Latin_Capital_Letter_C_With_Acute" . #\u+0106)
                ("Latin_Small_Letter_C_With_Acute" . #\u+0107)
                ("Latin_Capital_Letter_C_With_Circumflex" . #\u+0108)
                ("Latin_Small_Letter_C_With_Circumflex" . #\u+0109)
                ("Latin_Capital_Letter_C_With_Dot_Above" . #\u+010a)
                ("Latin_Small_Letter_C_With_Dot_Above" . #\u+010b)
                ("Latin_Capital_Letter_C_With_Caron" . #\u+010c)
                ("Latin_Small_Letter_C_With_Caron" . #\u+010d)
                ("Latin_Capital_Letter_D_With_Caron" . #\u+010e)
                ("Latin_Small_Letter_D_With_Caron" . #\u+010f)
                ("Latin_Capital_Letter_D_With_Stroke" . #\u+0110)
                ("Latin_Small_Letter_D_With_Stroke" . #\u+0111)
                ("Latin_Capital_Letter_E_With_Macron" . #\u+0112)
                ("Latin_Small_Letter_E_With_Macron" . #\u+0113)
                ("Latin_Capital_Letter_E_With_Breve" . #\u+0114)
                ("Latin_Small_Letter_E_With_Breve" . #\u+0115)
                ("Latin_Capital_Letter_E_With_Dot_Above" . #\u+0116)
                ("Latin_Small_Letter_E_With_Dot_Above" . #\u+0117)
                ("Latin_Capital_Letter_E_With_Ogonek" . #\u+0118)
                ("Latin_Small_Letter_E_With_Ogonek" . #\u+0119)
                ("Latin_Capital_Letter_E_With_Caron" . #\u+011a)
                ("Latin_Small_Letter_E_With_Caron" . #\u+011b)
                ("Latin_Capital_Letter_G_With_Circumflex" . #\u+011c)
                ("Latin_Small_Letter_G_With_Circumflex" . #\u+011d)
                ("Latin_Capital_Letter_G_With_Breve" . #\u+011e)
                ("Latin_Small_Letter_G_With_Breve" . #\u+011f)
                ("Latin_Capital_Letter_G_With_Dot_Above" . #\u+0120)
                ("Latin_Small_Letter_G_With_Dot_Above" . #\u+0121)
                ("Latin_Capital_Letter_G_With_Cedilla" . #\u+0122)
                ("Latin_Small_Letter_G_With_Cedilla" . #\u+0123)
                ("Latin_Capital_Letter_H_With_Circumflex" . #\u+0124)
                ("Latin_Small_Letter_H_With_Circumflex" . #\u+0125)
                ("Latin_Capital_Letter_H_With_Stroke" . #\u+0126)
                ("Latin_Small_Letter_H_With_Stroke" . #\u+0127)
                ("Latin_Capital_Letter_I_With_Tilde" . #\u+0128)
                ("Latin_Small_Letter_I_With_Tilde" . #\u+0129)
                ("Latin_Capital_Letter_I_With_Macron" . #\u+012a)
                ("Latin_Small_Letter_I_With_Macron" . #\u+012b)
                ("Latin_Capital_Letter_I_With_Breve" . #\u+012c)
                ("Latin_Small_Letter_I_With_Breve" . #\u+012d)
                ("Latin_Capital_Letter_I_With_Ogonek" . #\u+012e)
                ("Latin_Small_Letter_I_With_Ogonek" . #\u+012f)
                ("Latin_Capital_Letter_I_With_Dot_Above" . #\u+0130)
                ("Latin_Small_Letter_Dotless_I" . #\u+0131)
                ("Latin_Capital_Ligature_Ij" . #\u+0132)
                ("Latin_Small_Ligature_Ij" . #\u+0133)
                ("Latin_Capital_Letter_J_With_Circumflex" . #\u+0134)
                ("Latin_Small_Letter_J_With_Circumflex" . #\u+0135)
                ("Latin_Capital_Letter_K_With_Cedilla" . #\u+0136)
                ("Latin_Small_Letter_K_With_Cedilla" . #\u+0137)
                ("Latin_Small_Letter_Kra" . #\u+0138)
                ("Latin_Capital_Letter_L_With_Acute" . #\u+0139)
                ("Latin_Small_Letter_L_With_Acute" . #\u+013a)
                ("Latin_Capital_Letter_L_With_Cedilla" . #\u+013b)
                ("Latin_Small_Letter_L_With_Cedilla" . #\u+013c)
                ("Latin_Capital_Letter_L_With_Caron" . #\u+013d)
                ("Latin_Small_Letter_L_With_Caron" . #\u+013e)
                ("Latin_Capital_Letter_L_With_Middle_Dot" . #\u+013f)
                ("Latin_Small_Letter_L_With_Middle_Dot" . #\u+0140)
                ("Latin_Capital_Letter_L_With_Stroke" . #\u+0141)
                ("Latin_Small_Letter_L_With_Stroke" . #\u+0142)
                ("Latin_Capital_Letter_N_With_Acute" . #\u+0143)
                ("Latin_Small_Letter_N_With_Acute" . #\u+0144)
                ("Latin_Capital_Letter_N_With_Cedilla" . #\u+0145)
                ("Latin_Small_Letter_N_With_Cedilla" . #\u+0146)
                ("Latin_Capital_Letter_N_With_Caron" . #\u+0147)
                ("Latin_Small_Letter_N_With_Caron" . #\u+0148)
                ("Latin_Small_Letter_N_Preceded_By_Apostrophe" . #\u+0149)
                ("Latin_Capital_Letter_Eng" . #\u+014a)
                ("Latin_Small_Letter_Eng" . #\u+014b)
                ("Latin_Capital_Letter_O_With_Macron" . #\u+014c)
                ("Latin_Small_Letter_O_With_Macron" . #\u+014d)
                ("Latin_Capital_Letter_O_With_Breve" . #\u+014e)
                ("Latin_Small_Letter_O_With_Breve" . #\u+014f)
                ("Latin_Capital_Letter_O_With_Double_Acute" . #\u+0150)
                ("Latin_Small_Letter_O_With_Double_Acute" . #\u+0151)
                ("Latin_Capital_Ligature_Oe" . #\u+0152)
                ("Latin_Small_Ligature_Oe" . #\u+0153)
                ("Latin_Capital_Letter_R_With_Acute" . #\u+0154)
                ("Latin_Small_Letter_R_With_Acute" . #\u+0155)
                ("Latin_Capital_Letter_R_With_Cedilla" . #\u+0156)
                ("Latin_Small_Letter_R_With_Cedilla" . #\u+0157)
                ("Latin_Capital_Letter_R_With_Caron" . #\u+0158)
                ("Latin_Small_Letter_R_With_Caron" . #\u+0159)
                ("Latin_Capital_Letter_S_With_Acute" . #\u+015a)
                ("Latin_Small_Letter_S_With_Acute" . #\u+015b)
                ("Latin_Capital_Letter_S_With_Circumflex" . #\u+015c)
                ("Latin_Small_Letter_S_With_Circumflex" . #\u+015d)
                ("Latin_Capital_Letter_S_With_Cedilla" . #\u+015e)
                ("Latin_Small_Letter_S_With_Cedilla" . #\u+015f)
                ("Latin_Capital_Letter_S_With_Caron" . #\u+0160)
                ("Latin_Small_Letter_S_With_Caron" . #\u+0161)
                ("Latin_Capital_Letter_T_With_Cedilla" . #\u+0162)
                ("Latin_Small_Letter_T_With_Cedilla" . #\u+0163)
                ("Latin_Capital_Letter_T_With_Caron" . #\u+0164)
                ("Latin_Small_Letter_T_With_Caron" . #\u+0165)
                ("Latin_Capital_Letter_T_With_Stroke" . #\u+0166)
                ("Latin_Small_Letter_T_With_Stroke" . #\u+0167)
                ("Latin_Capital_Letter_U_With_Tilde" . #\u+0168)
                ("Latin_Small_Letter_U_With_Tilde" . #\u+0169)
                ("Latin_Capital_Letter_U_With_Macron" . #\u+016a)
                ("Latin_Small_Letter_U_With_Macron" . #\u+016b)
                ("Latin_Capital_Letter_U_With_Breve" . #\u+016c)
                ("Latin_Small_Letter_U_With_Breve" . #\u+016d)
                ("Latin_Capital_Letter_U_With_Ring_Above" . #\u+016e)
                ("Latin_Small_Letter_U_With_Ring_Above" . #\u+016f)
                ("Latin_Capital_Letter_U_With_Double_Acute" . #\u+0170)
                ("Latin_Small_Letter_U_With_Double_Acute" . #\u+0171)
                ("Latin_Capital_Letter_U_With_Ogonek" . #\u+0172)
                ("Latin_Small_Letter_U_With_Ogonek" . #\u+0173)
                ("Latin_Capital_Letter_W_With_Circumflex" . #\u+0174)
                ("Latin_Small_Letter_W_With_Circumflex" . #\u+0175)
                ("Latin_Capital_Letter_Y_With_Circumflex" . #\u+0176)
                ("Latin_Small_Letter_Y_With_Circumflex" . #\u+0177)
                ("Latin_Capital_Letter_Y_With_Diaeresis" . #\u+0178)
                ("Latin_Capital_Letter_Z_With_Acute" . #\u+0179)
                ("Latin_Small_Letter_Z_With_Acute" . #\u+017a)
                ("Latin_Capital_Letter_Z_With_Dot_Above" . #\u+017b)
                ("Latin_Small_Letter_Z_With_Dot_Above" . #\u+017c)
                ("Latin_Capital_Letter_Z_With_Caron" . #\u+017d)
                ("Latin_Small_Letter_Z_With_Caron" . #\u+017e)
                ("Latin_Small_Letter_Long_S" . #\u+017f)
                ("Latin_Small_Letter_B_With_Stroke" . #\u+0180)
                ("Latin_Capital_Letter_B_With_Hook" . #\u+0181)
                ("Latin_Capital_Letter_B_With_Topbar" . #\u+0182)
                ("Latin_Small_Letter_B_With_Topbar" . #\u+0183)
                ("Latin_Capital_Letter_Tone_Six" . #\u+0184)
                ("Latin_Small_Letter_Tone_Six" . #\u+0185)
                ("Latin_Capital_Letter_Open_O" . #\u+0186)
                ("Latin_Capital_Letter_C_With_Hook" . #\u+0187)
                ("Latin_Small_Letter_C_With_Hook" . #\u+0188)
                ("Latin_Capital_Letter_African_D" . #\u+0189)
                ("Latin_Capital_Letter_D_With_Hook" . #\u+018a)
                ("Latin_Capital_Letter_D_With_Topbar" . #\u+018b)
                ("Latin_Small_Letter_D_With_Topbar" . #\u+018c)
                ("Latin_Small_Letter_Turned_Delta" . #\u+018d)
                ("Latin_Capital_Letter_Reversed_E" . #\u+018e)
                ("Latin_Capital_Letter_Schwa" . #\u+018f)
                ("Latin_Capital_Letter_Open_E" . #\u+0190)
                ("Latin_Capital_Letter_F_With_Hook" . #\u+0191)
                ("Latin_Small_Letter_F_With_Hook" . #\u+0192)
                ("Latin_Capital_Letter_G_With_Hook" . #\u+0193)
                ("Latin_Capital_Letter_Gamma" . #\u+0194)
                ("Latin_Small_Letter_Hv" . #\u+0195)
                ("Latin_Capital_Letter_Iota" . #\u+0196)
                ("Latin_Capital_Letter_I_With_Stroke" . #\u+0197)
                ("Latin_Capital_Letter_K_With_Hook" . #\u+0198)
                ("Latin_Small_Letter_K_With_Hook" . #\u+0199)
                ("Latin_Small_Letter_L_With_Bar" . #\u+019a)
                ("Latin_Small_Letter_Lambda_With_Stroke" . #\u+019b)
                ("Latin_Capital_Letter_Turned_M" . #\u+019c)
                ("Latin_Capital_Letter_N_With_Left_Hook" . #\u+019d)
                ("Latin_Small_Letter_N_With_Long_Right_Leg" . #\u+019e)
                ("Latin_Capital_Letter_O_With_Middle_Tilde" . #\u+019f)
                ("Latin_Capital_Letter_O_With_Horn" . #\u+01a0)
                ("Latin_Small_Letter_O_With_Horn" . #\u+01a1)
                ("Latin_Capital_Letter_Oi" . #\u+01a2)
                ("Latin_Small_Letter_Oi" . #\u+01a3)
                ("Latin_Capital_Letter_P_With_Hook" . #\u+01a4)
                ("Latin_Small_Letter_P_With_Hook" . #\u+01a5)
                ("Latin_Letter_Yr" . #\u+01a6)
                ("Latin_Capital_Letter_Tone_Two" . #\u+01a7)
                ("Latin_Small_Letter_Tone_Two" . #\u+01a8)
                ("Latin_Capital_Letter_Esh" . #\u+01a9)
                ("Latin_Letter_Reversed_Esh_Loop" . #\u+01aa)
                ("Latin_Small_Letter_T_With_Palatal_Hook" . #\u+01ab)
                ("Latin_Capital_Letter_T_With_Hook" . #\u+01ac)
                ("Latin_Small_Letter_T_With_Hook" . #\u+01ad)
                ("Latin_Capital_Letter_T_With_Retroflex_Hook" . #\u+01ae)
                ("Latin_Capital_Letter_U_With_Horn" . #\u+01af)
                ("Latin_Small_Letter_U_With_Horn" . #\u+01b0)
                ("Latin_Capital_Letter_Upsilon" . #\u+01b1)
                ("Latin_Capital_Letter_V_With_Hook" . #\u+01b2)
                ("Latin_Capital_Letter_Y_With_Hook" . #\u+01b3)
                ("Latin_Small_Letter_Y_With_Hook" . #\u+01b4)
                ("Latin_Capital_Letter_Z_With_Stroke" . #\u+01b5)
                ("Latin_Small_Letter_Z_With_Stroke" . #\u+01b6)
                ("Latin_Capital_Letter_Ezh" . #\u+01b7)
                ("Latin_Capital_Letter_Ezh_Reversed" . #\u+01b8)
                ("Latin_Small_Letter_Ezh_Reversed" . #\u+01b9)
                ("Latin_Small_Letter_Ezh_With_Tail" . #\u+01ba)
                ("Latin_Letter_Two_With_Stroke" . #\u+01bb)
                ("Latin_Capital_Letter_Tone_Five" . #\u+01bc)
                ("Latin_Small_Letter_Tone_Five" . #\u+01bd)
                ("Latin_Letter_Inverted_Glottal_Stop_With_Stroke" . #\u+01be)
                ("Latin_Letter_Wynn" . #\u+01bf)
                ("Latin_Letter_Dental_Click" . #\u+01c0)
                ("Latin_Letter_Lateral_Click" . #\u+01c1)
                ("Latin_Letter_Alveolar_Click" . #\u+01c2)
                ("Latin_Letter_Retroflex_Click" . #\u+01c3)
                ("Latin_Capital_Letter_Dz_With_Caron" . #\u+01c4)
                ("Latin_Capital_Letter_D_With_Small_Letter_Z_With_Caron" . #\u+01c5)
                ("Latin_Small_Letter_Dz_With_Caron" . #\u+01c6)
                ("Latin_Capital_Letter_Lj" . #\u+01c7)
                ("Latin_Capital_Letter_L_With_Small_Letter_J" . #\u+01c8)
                ("Latin_Small_Letter_Lj" . #\u+01c9)
                ("Latin_Capital_Letter_Nj" . #\u+01ca)
                ("Latin_Capital_Letter_N_With_Small_Letter_J" . #\u+01cb)
                ("Latin_Small_Letter_Nj" . #\u+01cc)
                ("Latin_Capital_Letter_A_With_Caron" . #\u+01cd)
                ("Latin_Small_Letter_A_With_Caron" . #\u+01ce)
                ("Latin_Capital_Letter_I_With_Caron" . #\u+01cf)
                ("Latin_Small_Letter_I_With_Caron" . #\u+01d0)
                ("Latin_Capital_Letter_O_With_Caron" . #\u+01d1)
                ("Latin_Small_Letter_O_With_Caron" . #\u+01d2)
                ("Latin_Capital_Letter_U_With_Caron" . #\u+01d3)
                ("Latin_Small_Letter_U_With_Caron" . #\u+01d4)
                ("Latin_Capital_Letter_U_With_Diaeresis_And_Macron" . #\u+01d5)
                ("Latin_Small_Letter_U_With_Diaeresis_And_Macron" . #\u+01d6)
                ("Latin_Capital_Letter_U_With_Diaeresis_And_Acute" . #\u+01d7)
                ("Latin_Small_Letter_U_With_Diaeresis_And_Acute" . #\u+01d8)
                ("Latin_Capital_Letter_U_With_Diaeresis_And_Caron" . #\u+01d9)
                ("Latin_Small_Letter_U_With_Diaeresis_And_Caron" . #\u+01da)
                ("Latin_Capital_Letter_U_With_Diaeresis_And_Grave" . #\u+01db)
                ("Latin_Small_Letter_U_With_Diaeresis_And_Grave" . #\u+01dc)
                ("Latin_Small_Letter_Turned_E" . #\u+01dd)
                ("Latin_Capital_Letter_A_With_Diaeresis_And_Macron" . #\u+01de)
                ("Latin_Small_Letter_A_With_Diaeresis_And_Macron" . #\u+01df)
                ("Latin_Capital_Letter_A_With_Dot_Above_And_Macron" . #\u+01e0)
                ("Latin_Small_Letter_A_With_Dot_Above_And_Macron" . #\u+01e1)
                ("Latin_Capital_Letter_Ae_With_Macron" . #\u+01e2)
                ("Latin_Small_Letter_Ae_With_Macron" . #\u+01e3)
                ("Latin_Capital_Letter_G_With_Stroke" . #\u+01e4)
                ("Latin_Small_Letter_G_With_Stroke" . #\u+01e5)
                ("Latin_Capital_Letter_G_With_Caron" . #\u+01e6)
                ("Latin_Small_Letter_G_With_Caron" . #\u+01e7)
                ("Latin_Capital_Letter_K_With_Caron" . #\u+01e8)
                ("Latin_Small_Letter_K_With_Caron" . #\u+01e9)
                ("Latin_Capital_Letter_O_With_Ogonek" . #\u+01ea)
                ("Latin_Small_Letter_O_With_Ogonek" . #\u+01eb)
                ("Latin_Capital_Letter_O_With_Ogonek_And_Macron" . #\u+01ec)
                ("Latin_Small_Letter_O_With_Ogonek_And_Macron" . #\u+01ed)
                ("Latin_Capital_Letter_Ezh_With_Caron" . #\u+01ee)
                ("Latin_Small_Letter_Ezh_With_Caron" . #\u+01ef)
                ("Latin_Small_Letter_J_With_Caron" . #\u+01f0)
                ("Latin_Capital_Letter_Dz" . #\u+01f1)
                ("Latin_Capital_Letter_D_With_Small_Letter_Z" . #\u+01f2)
                ("Latin_Small_Letter_Dz" . #\u+01f3)
                ("Latin_Capital_Letter_G_With_Acute" . #\u+01f4)
                ("Latin_Small_Letter_G_With_Acute" . #\u+01f5)
                ("Latin_Capital_Letter_Hwair" . #\u+01f6)
                ("Latin_Capital_Letter_Wynn" . #\u+01f7)
                ("Latin_Capital_Letter_N_With_Grave" . #\u+01f8)
                ("Latin_Small_Letter_N_With_Grave" . #\u+01f9)
                ("Latin_Capital_Letter_A_With_Ring_Above_And_Acute" . #\u+01fa)
                ("Latin_Small_Letter_A_With_Ring_Above_And_Acute" . #\u+01fb)
                ("Latin_Capital_Letter_Ae_With_Acute" . #\u+01fc)
                ("Latin_Small_Letter_Ae_With_Acute" . #\u+01fd)
                ("Latin_Capital_Letter_O_With_Stroke_And_Acute" . #\u+01fe)
                ("Latin_Small_Letter_O_With_Stroke_And_Acute" . #\u+01ff)
                ("Latin_Capital_Letter_A_With_Double_Grave" . #\u+0200)
                ("Latin_Small_Letter_A_With_Double_Grave" . #\u+0201)
                ("Latin_Capital_Letter_A_With_Inverted_Breve" . #\u+0202)
                ("Latin_Small_Letter_A_With_Inverted_Breve" . #\u+0203)
                ("Latin_Capital_Letter_E_With_Double_Grave" . #\u+0204)
                ("Latin_Small_Letter_E_With_Double_Grave" . #\u+0205)
                ("Latin_Capital_Letter_E_With_Inverted_Breve" . #\u+0206)
                ("Latin_Small_Letter_E_With_Inverted_Breve" . #\u+0207)
                ("Latin_Capital_Letter_I_With_Double_Grave" . #\u+0208)
                ("Latin_Small_Letter_I_With_Double_Grave" . #\u+0209)
                ("Latin_Capital_Letter_I_With_Inverted_Breve" . #\u+020a)
                ("Latin_Small_Letter_I_With_Inverted_Breve" . #\u+020b)
                ("Latin_Capital_Letter_O_With_Double_Grave" . #\u+020c)
                ("Latin_Small_Letter_O_With_Double_Grave" . #\u+020d)
                ("Latin_Capital_Letter_O_With_Inverted_Breve" . #\u+020e)
                ("Latin_Small_Letter_O_With_Inverted_Breve" . #\u+020f)
                ("Latin_Capital_Letter_R_With_Double_Grave" . #\u+0210)
                ("Latin_Small_Letter_R_With_Double_Grave" . #\u+0211)
                ("Latin_Capital_Letter_R_With_Inverted_Breve" . #\u+0212)
                ("Latin_Small_Letter_R_With_Inverted_Breve" . #\u+0213)
                ("Latin_Capital_Letter_U_With_Double_Grave" . #\u+0214)
                ("Latin_Small_Letter_U_With_Double_Grave" . #\u+0215)
                ("Latin_Capital_Letter_U_With_Inverted_Breve" . #\u+0216)
                ("Latin_Small_Letter_U_With_Inverted_Breve" . #\u+0217)
                ("Latin_Capital_Letter_S_With_Comma_Below" . #\u+0218)
                ("Latin_Small_Letter_S_With_Comma_Below" . #\u+0219)
                ("Latin_Capital_Letter_T_With_Comma_Below" . #\u+021a)
                ("Latin_Small_Letter_T_With_Comma_Below" . #\u+021b)
                ("Latin_Capital_Letter_Yogh" . #\u+021c)
                ("Latin_Small_Letter_Yogh" . #\u+021d)
                ("Latin_Capital_Letter_H_With_Caron" . #\u+021e)
                ("Latin_Small_Letter_H_With_Caron" . #\u+021f)
                ("Latin_Capital_Letter_N_With_Long_Right_Leg" . #\u+0220)
                ("Latin_Small_Letter_D_With_Curl" . #\u+0221)
                ("Latin_Capital_Letter_Ou" . #\u+0222)
                ("Latin_Small_Letter_Ou" . #\u+0223)
                ("Latin_Capital_Letter_Z_With_Hook" . #\u+0224)
                ("Latin_Small_Letter_Z_With_Hook" . #\u+0225)
                ("Latin_Capital_Letter_A_With_Dot_Above" . #\u+0226)
                ("Latin_Small_Letter_A_With_Dot_Above" . #\u+0227)
                ("Latin_Capital_Letter_E_With_Cedilla" . #\u+0228)
                ("Latin_Small_Letter_E_With_Cedilla" . #\u+0229)
                ("Latin_Capital_Letter_O_With_Diaeresis_And_Macron" . #\u+022a)
                ("Latin_Small_Letter_O_With_Diaeresis_And_Macron" . #\u+022b)
                ("Latin_Capital_Letter_O_With_Tilde_And_Macron" . #\u+022c)
                ("Latin_Small_Letter_O_With_Tilde_And_Macron" . #\u+022d)
                ("Latin_Capital_Letter_O_With_Dot_Above" . #\u+022e)
                ("Latin_Small_Letter_O_With_Dot_Above" . #\u+022f)
                ("Latin_Capital_Letter_O_With_Dot_Above_And_Macron" . #\u+0230)
                ("Latin_Small_Letter_O_With_Dot_Above_And_Macron" . #\u+0231)
                ("Latin_Capital_Letter_Y_With_Macron" . #\u+0232)
                ("Latin_Small_Letter_Y_With_Macron" . #\u+0233)
                ("Latin_Small_Letter_L_With_Curl" . #\u+0234)
                ("Latin_Small_Letter_N_With_Curl" . #\u+0235)
                ("Latin_Small_Letter_T_With_Curl" . #\u+0236)
                ("Latin_Small_Letter_Dotless_J" . #\u+0237)
                ("Latin_Small_Letter_Db_Digraph" . #\u+0238)
                ("Latin_Small_Letter_Qp_Digraph" . #\u+0239)
                ("Latin_Capital_Letter_A_With_Stroke" . #\u+023a)
                ("Latin_Capital_Letter_C_With_Stroke" . #\u+023b)
                ("Latin_Small_Letter_C_With_Stroke" . #\u+023c)
                ("Latin_Capital_Letter_L_With_Bar" . #\u+023d)
                ("Latin_Capital_Letter_T_With_Diagonal_Stroke" . #\u+023e)
                ("Latin_Small_Letter_S_With_Swash_Tail" . #\u+023f)
                ("Latin_Small_Letter_Z_With_Swash_Tail" . #\u+0240)
                ("Latin_Capital_Letter_Glottal_Stop" . #\u+0241)
                ("Latin_Small_Letter_Glottal_Stop" . #\u+0242)
                ("Latin_Capital_Letter_B_With_Stroke" . #\u+0243)
                ("Latin_Capital_Letter_U_Bar" . #\u+0244)
                ("Latin_Capital_Letter_Turned_V" . #\u+0245)
                ("Latin_Capital_Letter_E_With_Stroke" . #\u+0246)
                ("Latin_Small_Letter_E_With_Stroke" . #\u+0247)
                ("Latin_Capital_Letter_J_With_Stroke" . #\u+0248)
                ("Latin_Small_Letter_J_With_Stroke" . #\u+0249)
                ("Latin_Capital_Letter_Small_Q_With_Hook_Tail" . #\u+024a)
                ("Latin_Small_Letter_Q_With_Hook_Tail" . #\u+024b)
                ("Latin_Capital_Letter_R_With_Stroke" . #\u+024c)
                ("Latin_Small_Letter_R_With_Stroke" . #\u+024d)
                ("Latin_Capital_Letter_Y_With_Stroke" . #\u+024e)
                ("Latin_Small_Letter_Y_With_Stroke" . #\u+024f)
                ("Latin_Small_Letter_Turned_A" . #\u+0250)
                ("Latin_Small_Letter_Alpha" . #\u+0251)
                ("Latin_Small_Letter_Turned_Alpha" . #\u+0252)
                ("Latin_Small_Letter_B_With_Hook" . #\u+0253)
                ("Latin_Small_Letter_Open_O" . #\u+0254)
                ("Latin_Small_Letter_C_With_Curl" . #\u+0255)
                ("Latin_Small_Letter_D_With_Tail" . #\u+0256)
                ("Latin_Small_Letter_D_With_Hook" . #\u+0257)
                ("Latin_Small_Letter_Reversed_E" . #\u+0258)
                ("Latin_Small_Letter_Schwa" . #\u+0259)
                ("Latin_Small_Letter_Schwa_With_Hook" . #\u+025a)
                ("Latin_Small_Letter_Open_E" . #\u+025b)
                ("Latin_Small_Letter_Reversed_Open_E" . #\u+025c)
                ("Latin_Small_Letter_Reversed_Open_E_With_Hook" . #\u+025d)
                ("Latin_Small_Letter_Closed_Reversed_Open_E" . #\u+025e)
                ("Latin_Small_Letter_Dotless_J_With_Stroke" . #\u+025f)
                ("Latin_Small_Letter_G_With_Hook" . #\u+0260)
                ("Latin_Small_Letter_Script_G" . #\u+0261)
                ("Latin_Letter_Small_Capital_G" . #\u+0262)
                ("Latin_Small_Letter_Gamma" . #\u+0263)
                ("Latin_Small_Letter_Rams_Horn" . #\u+0264)
                ("Latin_Small_Letter_Turned_H" . #\u+0265)
                ("Latin_Small_Letter_H_With_Hook" . #\u+0266)
                ("Latin_Small_Letter_Heng_With_Hook" . #\u+0267)
                ("Latin_Small_Letter_I_With_Stroke" . #\u+0268)
                ("Latin_Small_Letter_Iota" . #\u+0269)
                ("Latin_Letter_Small_Capital_I" . #\u+026a)
                ("Latin_Small_Letter_L_With_Middle_Tilde" . #\u+026b)
                ("Latin_Small_Letter_L_With_Belt" . #\u+026c)
                ("Latin_Small_Letter_L_With_Retroflex_Hook" . #\u+026d)
                ("Latin_Small_Letter_Lezh" . #\u+026e)
                ("Latin_Small_Letter_Turned_M" . #\u+026f)
                ("Latin_Small_Letter_Turned_M_With_Long_Leg" . #\u+0270)
                ("Latin_Small_Letter_M_With_Hook" . #\u+0271)
                ("Latin_Small_Letter_N_With_Left_Hook" . #\u+0272)
                ("Latin_Small_Letter_N_With_Retroflex_Hook" . #\u+0273)
                ("Latin_Letter_Small_Capital_N" . #\u+0274)
                ("Latin_Small_Letter_Barred_O" . #\u+0275)
                ("Latin_Letter_Small_Capital_Oe" . #\u+0276)
                ("Latin_Small_Letter_Closed_Omega" . #\u+0277)
                ("Latin_Small_Letter_Phi" . #\u+0278)
                ("Latin_Small_Letter_Turned_R" . #\u+0279)
                ("Latin_Small_Letter_Turned_R_With_Long_Leg" . #\u+027a)
                ("Latin_Small_Letter_Turned_R_With_Hook" . #\u+027b)
                ("Latin_Small_Letter_R_With_Long_Leg" . #\u+027c)
                ("Latin_Small_Letter_R_With_Tail" . #\u+027d)
                ("Latin_Small_Letter_R_With_Fishhook" . #\u+027e)
                ("Latin_Small_Letter_Reversed_R_With_Fishhook" . #\u+027f)
                ("Latin_Letter_Small_Capital_R" . #\u+0280)
                ("Latin_Letter_Small_Capital_Inverted_R" . #\u+0281)
                ("Latin_Small_Letter_S_With_Hook" . #\u+0282)
                ("Latin_Small_Letter_Esh" . #\u+0283)
                ("Latin_Small_Letter_Dotless_J_With_Stroke_And_Hook" . #\u+0284)
                ("Latin_Small_Letter_Squat_Reversed_Esh" . #\u+0285)
                ("Latin_Small_Letter_Esh_With_Curl" . #\u+0286)
                ("Latin_Small_Letter_Turned_T" . #\u+0287)
                ("Latin_Small_Letter_T_With_Retroflex_Hook" . #\u+0288)
                ("Latin_Small_Letter_U_Bar" . #\u+0289)
                ("Latin_Small_Letter_Upsilon" . #\u+028a)
                ("Latin_Small_Letter_V_With_Hook" . #\u+028b)
                ("Latin_Small_Letter_Turned_V" . #\u+028c)
                ("Latin_Small_Letter_Turned_W" . #\u+028d)
                ("Latin_Small_Letter_Turned_Y" . #\u+028e)
                ("Latin_Letter_Small_Capital_Y" . #\u+028f)
                ("Latin_Small_Letter_Z_With_Retroflex_Hook" . #\u+0290)
                ("Latin_Small_Letter_Z_With_Curl" . #\u+0291)
                ("Latin_Small_Letter_Ezh" . #\u+0292)
                ("Latin_Small_Letter_Ezh_With_Curl" . #\u+0293)
                ("Latin_Letter_Glottal_Stop" . #\u+0294)
                ("Latin_Letter_Pharyngeal_Voiced_Fricative" . #\u+0295)
                ("Latin_Letter_Inverted_Glottal_Stop" . #\u+0296)
                ("Latin_Letter_Stretched_C" . #\u+0297)
                ("Latin_Letter_Bilabial_Click" . #\u+0298)
                ("Latin_Letter_Small_Capital_B" . #\u+0299)
                ("Latin_Small_Letter_Closed_Open_E" . #\u+029a)
                ("Latin_Letter_Small_Capital_G_With_Hook" . #\u+029b)
                ("Latin_Letter_Small_Capital_H" . #\u+029c)
                ("Latin_Small_Letter_J_With_Crossed-Tail" . #\u+029d)
                ("Latin_Small_Letter_Turned_K" . #\u+029e)
                ("Latin_Letter_Small_Capital_L" . #\u+029f)
                ("Latin_Small_Letter_Q_With_Hook" . #\u+02a0)
                ("Latin_Letter_Glottal_Stop_With_Stroke" . #\u+02a1)
                ("Latin_Letter_Reversed_Glottal_Stop_With_Stroke" . #\u+02a2)
                ("Latin_Small_Letter_Dz_Digraph" . #\u+02a3)
                ("Latin_Small_Letter_Dezh_Digraph" . #\u+02a4)
                ("Latin_Small_Letter_Dz_Digraph_With_Curl" . #\u+02a5)
                ("Latin_Small_Letter_Ts_Digraph" . #\u+02a6)
                ("Latin_Small_Letter_Tesh_Digraph" . #\u+02a7)
                ("Latin_Small_Letter_Tc_Digraph_With_Curl" . #\u+02a8)
                ("Latin_Small_Letter_Feng_Digraph" . #\u+02a9)
                ("Latin_Small_Letter_Ls_Digraph" . #\u+02aa)
                ("Latin_Small_Letter_Lz_Digraph" . #\u+02ab)
                ("Latin_Letter_Bilabial_Percussive" . #\u+02ac)
                ("Latin_Letter_Bidental_Percussive" . #\u+02ad)
                ("Latin_Small_Letter_Turned_H_With_Fishhook" . #\u+02ae)
                ("Latin_Small_Letter_Turned_H_With_Fishhook_And_Tail" . #\u+02af)
                ("Modifier_Letter_Small_H" . #\u+02b0)
                ("Modifier_Letter_Small_H_With_Hook" . #\u+02b1)
                ("Modifier_Letter_Small_J" . #\u+02b2)
                ("Modifier_Letter_Small_R" . #\u+02b3)
                ("Modifier_Letter_Small_Turned_R" . #\u+02b4)
                ("Modifier_Letter_Small_Turned_R_With_Hook" . #\u+02b5)
                ("Modifier_Letter_Small_Capital_Inverted_R" . #\u+02b6)
                ("Modifier_Letter_Small_W" . #\u+02b7)
                ("Modifier_Letter_Small_Y" . #\u+02b8)
                ("Modifier_Letter_Prime" . #\u+02b9)
                ("Modifier_Letter_Double_Prime" . #\u+02ba)
                ("Modifier_Letter_Turned_Comma" . #\u+02bb)
                ("Modifier_Letter_Apostrophe" . #\u+02bc)
                ("Modifier_Letter_Reversed_Comma" . #\u+02bd)
                ("Modifier_Letter_Right_Half_Ring" . #\u+02be)
                ("Modifier_Letter_Left_Half_Ring" . #\u+02bf)
                ("Modifier_Letter_Glottal_Stop" . #\u+02c0)
                ("Modifier_Letter_Reversed_Glottal_Stop" . #\u+02c1)
                ("Modifier_Letter_Left_Arrowhead" . #\u+02c2)
                ("Modifier_Letter_Right_Arrowhead" . #\u+02c3)
                ("Modifier_Letter_Up_Arrowhead" . #\u+02c4)
                ("Modifier_Letter_Down_Arrowhead" . #\u+02c5)
                ("Modifier_Letter_Circumflex_Accent" . #\u+02c6)
                ("Caron" . #\u+02c7)
                ("Modifier_Letter_Vertical_Line" . #\u+02c8)
                ("Modifier_Letter_Macron" . #\u+02c9)
                ("Modifier_Letter_Acute_Accent" . #\u+02ca)
                ("Modifier_Letter_Grave_Accent" . #\u+02cb)
                ("Modifier_Letter_Low_Vertical_Line" . #\u+02cc)
                ("Modifier_Letter_Low_Macron" . #\u+02cd)
                ("Modifier_Letter_Low_Grave_Accent" . #\u+02ce)
                ("Modifier_Letter_Low_Acute_Accent" . #\u+02cf)
                ("Modifier_Letter_Triangular_Colon" . #\u+02d0)
                ("Modifier_Letter_Half_Triangular_Colon" . #\u+02d1)
                ("Modifier_Letter_Centred_Right_Half_Ring" . #\u+02d2)
                ("Modifier_Letter_Centred_Left_Half_Ring" . #\u+02d3)
                ("Modifier_Letter_Up_Tack" . #\u+02d4)
                ("Modifier_Letter_Down_Tack" . #\u+02d5)
                ("Modifier_Letter_Plus_Sign" . #\u+02d6)
                ("Modifier_Letter_Minus_Sign" . #\u+02d7)
                ("Breve" . #\u+02d8)
                ("Dot_Above" . #\u+02d9)
                ("Ring_Above" . #\u+02da)
                ("Ogonek" . #\u+02db)
                ("Small_Tilde" . #\u+02dc)
                ("Double_Acute_Accent" . #\u+02dd)
                ("Modifier_Letter_Rhotic_Hook" . #\u+02de)
                ("Modifier_Letter_Cross_Accent" . #\u+02df)
                ("Modifier_Letter_Small_Gamma" . #\u+02e0)
                ("Modifier_Letter_Small_L" . #\u+02e1)
                ("Modifier_Letter_Small_S" . #\u+02e2)
                ("Modifier_Letter_Small_X" . #\u+02e3)
                ("Modifier_Letter_Small_Reversed_Glottal_Stop" . #\u+02e4)
                ("Modifier_Letter_Extra-High_Tone_Bar" . #\u+02e5)
                ("Modifier_Letter_High_Tone_Bar" . #\u+02e6)
                ("Modifier_Letter_Mid_Tone_Bar" . #\u+02e7)
                ("Modifier_Letter_Low_Tone_Bar" . #\u+02e8)
                ("Modifier_Letter_Extra-Low_Tone_Bar" . #\u+02e9)
                ("Modifier_Letter_Yin_Departing_Tone_Mark" . #\u+02ea)
                ("Modifier_Letter_Yang_Departing_Tone_Mark" . #\u+02eb)
                ("Modifier_Letter_Voicing" . #\u+02ec)
                ("Modifier_Letter_Unaspirated" . #\u+02ed)
                ("Modifier_Letter_Double_Apostrophe" . #\u+02ee)
                ("Modifier_Letter_Low_Down_Arrowhead" . #\u+02ef)
                ("Modifier_Letter_Low_Up_Arrowhead" . #\u+02f0)
                ("Modifier_Letter_Low_Left_Arrowhead" . #\u+02f1)
                ("Modifier_Letter_Low_Right_Arrowhead" . #\u+02f2)
                ("Modifier_Letter_Low_Ring" . #\u+02f3)
                ("Modifier_Letter_Middle_Grave_Accent" . #\u+02f4)
                ("Modifier_Letter_Middle_Double_Grave_Accent" . #\u+02f5)
                ("Modifier_Letter_Middle_Double_Acute_Accent" . #\u+02f6)
                ("Modifier_Letter_Low_Tilde" . #\u+02f7)
                ("Modifier_Letter_Raised_Colon" . #\u+02f8)
                ("Modifier_Letter_Begin_High_Tone" . #\u+02f9)
                ("Modifier_Letter_End_High_Tone" . #\u+02fa)
                ("Modifier_Letter_Begin_Low_Tone" . #\u+02fb)
                ("Modifier_Letter_End_Low_Tone" . #\u+02fc)
                ("Modifier_Letter_Shelf" . #\u+02fd)
                ("Modifier_Letter_Open_Shelf" . #\u+02fe)
                ("Modifier_Letter_Low_Left_Arrow" . #\u+02ff)
                ("Combining_Grave_Accent" . #\u+0300)
                ("Combining_Acute_Accent" . #\u+0301)
                ("Combining_Circumflex_Accent" . #\u+0302)
                ("Combining_Tilde" . #\u+0303)
                ("Combining_Macron" . #\u+0304)
                ("Combining_Overline" . #\u+0305)
                ("Combining_Breve" . #\u+0306)
                ("Combining_Dot_Above" . #\u+0307)
                ("Combining_Diaeresis" . #\u+0308)
                ("Combining_Hook_Above" . #\u+0309)
                ("Combining_Ring_Above" . #\u+030a)
                ("Combining_Double_Acute_Accent" . #\u+030b)
                ("Combining_Caron" . #\u+030c)
                ("Combining_Vertical_Line_Above" . #\u+030d)
                ("Combining_Double_Vertical_Line_Above" . #\u+030e)
                ("Combining_Double_Grave_Accent" . #\u+030f)
                ("Combining_Candrabindu" . #\u+0310)
                ("Combining_Inverted_Breve" . #\u+0311)
                ("Combining_Turned_Comma_Above" . #\u+0312)
                ("Combining_Comma_Above" . #\u+0313)
                ("Combining_Reversed_Comma_Above" . #\u+0314)
                ("Combining_Comma_Above_Right" . #\u+0315)
                ("Combining_Grave_Accent_Below" . #\u+0316)
                ("Combining_Acute_Accent_Below" . #\u+0317)
                ("Combining_Left_Tack_Below" . #\u+0318)
                ("Combining_Right_Tack_Below" . #\u+0319)
                ("Combining_Left_Angle_Above" . #\u+031a)
                ("Combining_Horn" . #\u+031b)
                ("Combining_Left_Half_Ring_Below" . #\u+031c)
                ("Combining_Up_Tack_Below" . #\u+031d)
                ("Combining_Down_Tack_Below" . #\u+031e)
                ("Combining_Plus_Sign_Below" . #\u+031f)
                ("Combining_Minus_Sign_Below" . #\u+0320)
                ("Combining_Palatalized_Hook_Below" . #\u+0321)
                ("Combining_Retroflex_Hook_Below" . #\u+0322)
                ("Combining_Dot_Below" . #\u+0323)
                ("Combining_Diaeresis_Below" . #\u+0324)
                ("Combining_Ring_Below" . #\u+0325)
                ("Combining_Comma_Below" . #\u+0326)
                ("Combining_Cedilla" . #\u+0327)
                ("Combining_Ogonek" . #\u+0328)
                ("Combining_Vertical_Line_Below" . #\u+0329)
                ("Combining_Bridge_Below" . #\u+032a)
                ("Combining_Inverted_Double_Arch_Below" . #\u+032b)
                ("Combining_Caron_Below" . #\u+032c)
                ("Combining_Circumflex_Accent_Below" . #\u+032d)
                ("Combining_Breve_Below" . #\u+032e)
                ("Combining_Inverted_Breve_Below" . #\u+032f)
                ("Combining_Tilde_Below" . #\u+0330)
                ("Combining_Macron_Below" . #\u+0331)
                ("Combining_Low_Line" . #\u+0332)
                ("Combining_Double_Low_Line" . #\u+0333)
                ("Combining_Tilde_Overlay" . #\u+0334)
                ("Combining_Short_Stroke_Overlay" . #\u+0335)
                ("Combining_Long_Stroke_Overlay" . #\u+0336)
                ("Combining_Short_Solidus_Overlay" . #\u+0337)
                ("Combining_Long_Solidus_Overlay" . #\u+0338)
                ("Combining_Right_Half_Ring_Below" . #\u+0339)
                ("Combining_Inverted_Bridge_Below" . #\u+033a)
                ("Combining_Square_Below" . #\u+033b)
                ("Combining_Seagull_Below" . #\u+033c)
                ("Combining_X_Above" . #\u+033d)
                ("Combining_Vertical_Tilde" . #\u+033e)
                ("Combining_Double_Overline" . #\u+033f)
                ("Combining_Grave_Tone_Mark" . #\u+0340)
                ("Combining_Acute_Tone_Mark" . #\u+0341)
                ("Combining_Greek_Perispomeni" . #\u+0342)
                ("Combining_Greek_Koronis" . #\u+0343)
                ("Combining_Greek_Dialytika_Tonos" . #\u+0344)
                ("Combining_Greek_Ypogegrammeni" . #\u+0345)
                ("Combining_Bridge_Above" . #\u+0346)
                ("Combining_Equals_Sign_Below" . #\u+0347)
                ("Combining_Double_Vertical_Line_Below" . #\u+0348)
                ("Combining_Left_Angle_Below" . #\u+0349)
                ("Combining_Not_Tilde_Above" . #\u+034a)
                ("Combining_Homothetic_Above" . #\u+034b)
                ("Combining_Almost_Equal_To_Above" . #\u+034c)
                ("Combining_Left_Right_Arrow_Below" . #\u+034d)
                ("Combining_Upwards_Arrow_Below" . #\u+034e)
                ("Combining_Grapheme_Joiner" . #\u+034f)
                ("Combining_Right_Arrowhead_Above" . #\u+0350)
                ("Combining_Left_Half_Ring_Above" . #\u+0351)
                ("Combining_Fermata" . #\u+0352)
                ("Combining_X_Below" . #\u+0353)
                ("Combining_Left_Arrowhead_Below" . #\u+0354)
                ("Combining_Right_Arrowhead_Below" . #\u+0355)
                ("Combining_Right_Arrowhead_And_Up_Arrowhead_Below" . #\u+0356)
                ("Combining_Right_Half_Ring_Above" . #\u+0357)
                ("Combining_Dot_Above_Right" . #\u+0358)
                ("Combining_Asterisk_Below" . #\u+0359)
                ("Combining_Double_Ring_Below" . #\u+035a)
                ("Combining_Zigzag_Above" . #\u+035b)
                ("Combining_Double_Breve_Below" . #\u+035c)
                ("Combining_Double_Breve" . #\u+035d)
                ("Combining_Double_Macron" . #\u+035e)
                ("Combining_Double_Macron_Below" . #\u+035f)
                ("Combining_Double_Tilde" . #\u+0360)
                ("Combining_Double_Inverted_Breve" . #\u+0361)
                ("Combining_Double_Rightwards_Arrow_Below" . #\u+0362)
                ("Combining_Latin_Small_Letter_A" . #\u+0363)
                ("Combining_Latin_Small_Letter_E" . #\u+0364)
                ("Combining_Latin_Small_Letter_I" . #\u+0365)
                ("Combining_Latin_Small_Letter_O" . #\u+0366)
                ("Combining_Latin_Small_Letter_U" . #\u+0367)
                ("Combining_Latin_Small_Letter_C" . #\u+0368)
                ("Combining_Latin_Small_Letter_D" . #\u+0369)
                ("Combining_Latin_Small_Letter_H" . #\u+036a)
                ("Combining_Latin_Small_Letter_M" . #\u+036b)
                ("Combining_Latin_Small_Letter_R" . #\u+036c)
                ("Combining_Latin_Small_Letter_T" . #\u+036d)
                ("Combining_Latin_Small_Letter_V" . #\u+036e)
                ("Combining_Latin_Small_Letter_X" . #\u+036f)
                ("Greek_Numeral_Sign" . #\u+0374)
                ("Greek_Lower_Numeral_Sign" . #\u+0375)
                ("Greek_Ypogegrammeni" . #\u+037a)
                ("Greek_Small_Reversed_Lunate_Sigma_Symbol" . #\u+037b)
                ("Greek_Small_Dotted_Lunate_Sigma_Symbol" . #\u+037c)
                ("Greek_Small_Reversed_Dotted_Lunate_Sigma_Symbol" . #\u+037d)
                ("Greek_Question_Mark" . #\u+037e)
                ("Greek_Tonos" . #\u+0384)
                ("Greek_Dialytika_Tonos" . #\u+0385)
                ("Greek_Capital_Letter_Alpha_With_Tonos" . #\u+0386)
                ("Greek_Ano_Teleia" . #\u+0387)
                ("Greek_Capital_Letter_Epsilon_With_Tonos" . #\u+0388)
                ("Greek_Capital_Letter_Eta_With_Tonos" . #\u+0389)
                ("Greek_Capital_Letter_Iota_With_Tonos" . #\u+038a)
                ("Greek_Capital_Letter_Omicron_With_Tonos" . #\u+038c)
                ("Greek_Capital_Letter_Upsilon_With_Tonos" . #\u+038e)
                ("Greek_Capital_Letter_Omega_With_Tonos" . #\u+038f)
                ("Greek_Small_Letter_Iota_With_Dialytika_And_Tonos" . #\u+0390)
                ("Greek_Capital_Letter_Alpha" . #\u+0391)
                ("Greek_Capital_Letter_Beta" . #\u+0392)
                ("Greek_Capital_Letter_Gamma" . #\u+0393)
                ("Greek_Capital_Letter_Delta" . #\u+0394)
                ("Greek_Capital_Letter_Epsilon" . #\u+0395)
                ("Greek_Capital_Letter_Zeta" . #\u+0396)
                ("Greek_Capital_Letter_Eta" . #\u+0397)
                ("Greek_Capital_Letter_Theta" . #\u+0398)
                ("Greek_Capital_Letter_Iota" . #\u+0399)
                ("Greek_Capital_Letter_Kappa" . #\u+039a)
                ("Greek_Capital_Letter_Lamda" . #\u+039b)
                ("Greek_Capital_Letter_Mu" . #\u+039c)
                ("Greek_Capital_Letter_Nu" . #\u+039d)
                ("Greek_Capital_Letter_Xi" . #\u+039e)
                ("Greek_Capital_Letter_Omicron" . #\u+039f)
                ("Greek_Capital_Letter_Pi" . #\u+03a0)
                ("Greek_Capital_Letter_Rho" . #\u+03a1)
                ("Greek_Capital_Letter_Sigma" . #\u+03a3)
                ("Greek_Capital_Letter_Tau" . #\u+03a4)
                ("Greek_Capital_Letter_Upsilon" . #\u+03a5)
                ("Greek_Capital_Letter_Phi" . #\u+03a6)
                ("Greek_Capital_Letter_Chi" . #\u+03a7)
                ("Greek_Capital_Letter_Psi" . #\u+03a8)
                ("Greek_Capital_Letter_Omega" . #\u+03a9)
                ("Greek_Capital_Letter_Iota_With_Dialytika" . #\u+03aa)
                ("Greek_Capital_Letter_Upsilon_With_Dialytika" . #\u+03ab)
                ("Greek_Small_Letter_Alpha_With_Tonos" . #\u+03ac)
                ("Greek_Small_Letter_Epsilon_With_Tonos" . #\u+03ad)
                ("Greek_Small_Letter_Eta_With_Tonos" . #\u+03ae)
                ("Greek_Small_Letter_Iota_With_Tonos" . #\u+03af)
                ("Greek_Small_Letter_Upsilon_With_Dialytika_And_Tonos" . #\u+03b0)
                ("Greek_Small_Letter_Alpha" . #\u+03b1)
                ("Greek_Small_Letter_Beta" . #\u+03b2)
                ("Greek_Small_Letter_Gamma" . #\u+03b3)
                ("Greek_Small_Letter_Delta" . #\u+03b4)
                ("Greek_Small_Letter_Epsilon" . #\u+03b5)
                ("Greek_Small_Letter_Zeta" . #\u+03b6)
                ("Greek_Small_Letter_Eta" . #\u+03b7)
                ("Greek_Small_Letter_Theta" . #\u+03b8)
                ("Greek_Small_Letter_Iota" . #\u+03b9)
                ("Greek_Small_Letter_Kappa" . #\u+03ba)
                ("Greek_Small_Letter_Lamda" . #\u+03bb)
                ("Greek_Small_Letter_Mu" . #\u+03bc)
                ("Greek_Small_Letter_Nu" . #\u+03bd)
                ("Greek_Small_Letter_Xi" . #\u+03be)
                ("Greek_Small_Letter_Omicron" . #\u+03bf)
                ("Greek_Small_Letter_Pi" . #\u+03c0)
                ("Greek_Small_Letter_Rho" . #\u+03c1)
                ("Greek_Small_Letter_Final_Sigma" . #\u+03c2)
                ("Greek_Small_Letter_Sigma" . #\u+03c3)
                ("Greek_Small_Letter_Tau" . #\u+03c4)
                ("Greek_Small_Letter_Upsilon" . #\u+03c5)
                ("Greek_Small_Letter_Phi" . #\u+03c6)
                ("Greek_Small_Letter_Chi" . #\u+03c7)
                ("Greek_Small_Letter_Psi" . #\u+03c8)
                ("Greek_Small_Letter_Omega" . #\u+03c9)
                ("Greek_Small_Letter_Iota_With_Dialytika" . #\u+03ca)
                ("Greek_Small_Letter_Upsilon_With_Dialytika" . #\u+03cb)
                ("Greek_Small_Letter_Omicron_With_Tonos" . #\u+03cc)
                ("Greek_Small_Letter_Upsilon_With_Tonos" . #\u+03cd)
                ("Greek_Small_Letter_Omega_With_Tonos" . #\u+03ce)
                ("Greek_Beta_Symbol" . #\u+03d0)
                ("Greek_Theta_Symbol" . #\u+03d1)
                ("Greek_Upsilon_With_Hook_Symbol" . #\u+03d2)
                ("Greek_Upsilon_With_Acute_And_Hook_Symbol" . #\u+03d3)
                ("Greek_Upsilon_With_Diaeresis_And_Hook_Symbol" . #\u+03d4)
                ("Greek_Phi_Symbol" . #\u+03d5)
                ("Greek_Pi_Symbol" . #\u+03d6)
                ("Greek_Kai_Symbol" . #\u+03d7)
                ("Greek_Letter_Archaic_Koppa" . #\u+03d8)
                ("Greek_Small_Letter_Archaic_Koppa" . #\u+03d9)
                ("Greek_Letter_Stigma" . #\u+03da)
                ("Greek_Small_Letter_Stigma" . #\u+03db)
                ("Greek_Letter_Digamma" . #\u+03dc)
                ("Greek_Small_Letter_Digamma" . #\u+03dd)
                ("Greek_Letter_Koppa" . #\u+03de)
                ("Greek_Small_Letter_Koppa" . #\u+03df)
                ("Greek_Letter_Sampi" . #\u+03e0)
                ("Greek_Small_Letter_Sampi" . #\u+03e1)
                ("Coptic_Capital_Letter_Shei" . #\u+03e2)
                ("Coptic_Small_Letter_Shei" . #\u+03e3)
                ("Coptic_Capital_Letter_Fei" . #\u+03e4)
                ("Coptic_Small_Letter_Fei" . #\u+03e5)
                ("Coptic_Capital_Letter_Khei" . #\u+03e6)
                ("Coptic_Small_Letter_Khei" . #\u+03e7)
                ("Coptic_Capital_Letter_Hori" . #\u+03e8)
                ("Coptic_Small_Letter_Hori" . #\u+03e9)
                ("Coptic_Capital_Letter_Gangia" . #\u+03ea)
                ("Coptic_Small_Letter_Gangia" . #\u+03eb)
                ("Coptic_Capital_Letter_Shima" . #\u+03ec)
                ("Coptic_Small_Letter_Shima" . #\u+03ed)
                ("Coptic_Capital_Letter_Dei" . #\u+03ee)
                ("Coptic_Small_Letter_Dei" . #\u+03ef)
                ("Greek_Kappa_Symbol" . #\u+03f0)
                ("Greek_Rho_Symbol" . #\u+03f1)
                ("Greek_Lunate_Sigma_Symbol" . #\u+03f2)
                ("Greek_Letter_Yot" . #\u+03f3)
                ("Greek_Capital_Theta_Symbol" . #\u+03f4)
                ("Greek_Lunate_Epsilon_Symbol" . #\u+03f5)
                ("Greek_Reversed_Lunate_Epsilon_Symbol" . #\u+03f6)
                ("Greek_Capital_Letter_Sho" . #\u+03f7)
                ("Greek_Small_Letter_Sho" . #\u+03f8)
                ("Greek_Capital_Lunate_Sigma_Symbol" . #\u+03f9)
                ("Greek_Capital_Letter_San" . #\u+03fa)
                ("Greek_Small_Letter_San" . #\u+03fb)
                ("Greek_Rho_With_Stroke_Symbol" . #\u+03fc)
                ("Greek_Capital_Reversed_Lunate_Sigma_Symbol" . #\u+03fd)
                ("Greek_Capital_Dotted_Lunate_Sigma_Symbol" . #\u+03fe)
                ("Greek_Capital_Reversed_Dotted_Lunate_Sigma_Symbol" . #\u+03ff)
                ("Cyrillic_Capital_Letter_Ie_With_Grave" . #\u+0400)
                ("Cyrillic_Capital_Letter_Io" . #\u+0401)
                ("Cyrillic_Capital_Letter_Dje" . #\u+0402)
                ("Cyrillic_Capital_Letter_Gje" . #\u+0403)
                ("Cyrillic_Capital_Letter_Ukrainian_Ie" . #\u+0404)
                ("Cyrillic_Capital_Letter_Dze" . #\u+0405)
                ("Cyrillic_Capital_Letter_Byelorussian-Ukrainian_I" . #\u+0406)
                ("Cyrillic_Capital_Letter_Yi" . #\u+0407)
                ("Cyrillic_Capital_Letter_Je" . #\u+0408)
                ("Cyrillic_Capital_Letter_Lje" . #\u+0409)
                ("Cyrillic_Capital_Letter_Nje" . #\u+040a)
                ("Cyrillic_Capital_Letter_Tshe" . #\u+040b)
                ("Cyrillic_Capital_Letter_Kje" . #\u+040c)
                ("Cyrillic_Capital_Letter_I_With_Grave" . #\u+040d)
                ("Cyrillic_Capital_Letter_Short_U" . #\u+040e)
                ("Cyrillic_Capital_Letter_Dzhe" . #\u+040f)
                ("Cyrillic_Capital_Letter_A" . #\u+0410)
                ("Cyrillic_Capital_Letter_Be" . #\u+0411)
                ("Cyrillic_Capital_Letter_Ve" . #\u+0412)
                ("Cyrillic_Capital_Letter_Ghe" . #\u+0413)
                ("Cyrillic_Capital_Letter_De" . #\u+0414)
                ("Cyrillic_Capital_Letter_Ie" . #\u+0415)
                ("Cyrillic_Capital_Letter_Zhe" . #\u+0416)
                ("Cyrillic_Capital_Letter_Ze" . #\u+0417)
                ("Cyrillic_Capital_Letter_I" . #\u+0418)
                ("Cyrillic_Capital_Letter_Short_I" . #\u+0419)
                ("Cyrillic_Capital_Letter_Ka" . #\u+041a)
                ("Cyrillic_Capital_Letter_El" . #\u+041b)
                ("Cyrillic_Capital_Letter_Em" . #\u+041c)
                ("Cyrillic_Capital_Letter_En" . #\u+041d)
                ("Cyrillic_Capital_Letter_O" . #\u+041e)
                ("Cyrillic_Capital_Letter_Pe" . #\u+041f)
                ("Cyrillic_Capital_Letter_Er" . #\u+0420)
                ("Cyrillic_Capital_Letter_Es" . #\u+0421)
                ("Cyrillic_Capital_Letter_Te" . #\u+0422)
                ("Cyrillic_Capital_Letter_U" . #\u+0423)
                ("Cyrillic_Capital_Letter_Ef" . #\u+0424)
                ("Cyrillic_Capital_Letter_Ha" . #\u+0425)
                ("Cyrillic_Capital_Letter_Tse" . #\u+0426)
                ("Cyrillic_Capital_Letter_Che" . #\u+0427)
                ("Cyrillic_Capital_Letter_Sha" . #\u+0428)
                ("Cyrillic_Capital_Letter_Shcha" . #\u+0429)
                ("Cyrillic_Capital_Letter_Hard_Sign" . #\u+042a)
                ("Cyrillic_Capital_Letter_Yeru" . #\u+042b)
                ("Cyrillic_Capital_Letter_Soft_Sign" . #\u+042c)
                ("Cyrillic_Capital_Letter_E" . #\u+042d)
                ("Cyrillic_Capital_Letter_Yu" . #\u+042e)
                ("Cyrillic_Capital_Letter_Ya" . #\u+042f)
                ("Cyrillic_Small_Letter_A" . #\u+0430)
                ("Cyrillic_Small_Letter_Be" . #\u+0431)
                ("Cyrillic_Small_Letter_Ve" . #\u+0432)
                ("Cyrillic_Small_Letter_Ghe" . #\u+0433)
                ("Cyrillic_Small_Letter_De" . #\u+0434)
                ("Cyrillic_Small_Letter_Ie" . #\u+0435)
                ("Cyrillic_Small_Letter_Zhe" . #\u+0436)
                ("Cyrillic_Small_Letter_Ze" . #\u+0437)
                ("Cyrillic_Small_Letter_I" . #\u+0438)
                ("Cyrillic_Small_Letter_Short_I" . #\u+0439)
                ("Cyrillic_Small_Letter_Ka" . #\u+043a)
                ("Cyrillic_Small_Letter_El" . #\u+043b)
                ("Cyrillic_Small_Letter_Em" . #\u+043c)
                ("Cyrillic_Small_Letter_En" . #\u+043d)
                ("Cyrillic_Small_Letter_O" . #\u+043e)
                ("Cyrillic_Small_Letter_Pe" . #\u+043f)
                ("Cyrillic_Small_Letter_Er" . #\u+0440)
                ("Cyrillic_Small_Letter_Es" . #\u+0441)
                ("Cyrillic_Small_Letter_Te" . #\u+0442)
                ("Cyrillic_Small_Letter_U" . #\u+0443)
                ("Cyrillic_Small_Letter_Ef" . #\u+0444)
                ("Cyrillic_Small_Letter_Ha" . #\u+0445)
                ("Cyrillic_Small_Letter_Tse" . #\u+0446)
                ("Cyrillic_Small_Letter_Che" . #\u+0447)
                ("Cyrillic_Small_Letter_Sha" . #\u+0448)
                ("Cyrillic_Small_Letter_Shcha" . #\u+0449)
                ("Cyrillic_Small_Letter_Hard_Sign" . #\u+044a)
                ("Cyrillic_Small_Letter_Yeru" . #\u+044b)
                ("Cyrillic_Small_Letter_Soft_Sign" . #\u+044c)
                ("Cyrillic_Small_Letter_E" . #\u+044d)
                ("Cyrillic_Small_Letter_Yu" . #\u+044e)
                ("Cyrillic_Small_Letter_Ya" . #\u+044f)
                ("Cyrillic_Small_Letter_Ie_With_Grave" . #\u+0450)
                ("Cyrillic_Small_Letter_Io" . #\u+0451)
                ("Cyrillic_Small_Letter_Dje" . #\u+0452)
                ("Cyrillic_Small_Letter_Gje" . #\u+0453)
                ("Cyrillic_Small_Letter_Ukrainian_Ie" . #\u+0454)
                ("Cyrillic_Small_Letter_Dze" . #\u+0455)
                ("Cyrillic_Small_Letter_Byelorussian-Ukrainian_I" . #\u+0456)
                ("Cyrillic_Small_Letter_Yi" . #\u+0457)
                ("Cyrillic_Small_Letter_Je" . #\u+0458)
                ("Cyrillic_Small_Letter_Lje" . #\u+0459)
                ("Cyrillic_Small_Letter_Nje" . #\u+045a)
                ("Cyrillic_Small_Letter_Tshe" . #\u+045b)
                ("Cyrillic_Small_Letter_Kje" . #\u+045c)
                ("Cyrillic_Small_Letter_I_With_Grave" . #\u+045d)
                ("Cyrillic_Small_Letter_Short_U" . #\u+045e)
                ("Cyrillic_Small_Letter_Dzhe" . #\u+045f)
                ("Cyrillic_Capital_Letter_Omega" . #\u+0460)
                ("Cyrillic_Small_Letter_Omega" . #\u+0461)
                ("Cyrillic_Capital_Letter_Yat" . #\u+0462)
                ("Cyrillic_Small_Letter_Yat" . #\u+0463)
                ("Cyrillic_Capital_Letter_Iotified_E" . #\u+0464)
                ("Cyrillic_Small_Letter_Iotified_E" . #\u+0465)
                ("Cyrillic_Capital_Letter_Little_Yus" . #\u+0466)
                ("Cyrillic_Small_Letter_Little_Yus" . #\u+0467)
                ("Cyrillic_Capital_Letter_Iotified_Little_Yus" . #\u+0468)
                ("Cyrillic_Small_Letter_Iotified_Little_Yus" . #\u+0469)
                ("Cyrillic_Capital_Letter_Big_Yus" . #\u+046a)
                ("Cyrillic_Small_Letter_Big_Yus" . #\u+046b)
                ("Cyrillic_Capital_Letter_Iotified_Big_Yus" . #\u+046c)
                ("Cyrillic_Small_Letter_Iotified_Big_Yus" . #\u+046d)
                ("Cyrillic_Capital_Letter_Ksi" . #\u+046e)
                ("Cyrillic_Small_Letter_Ksi" . #\u+046f)
                ("Cyrillic_Capital_Letter_Psi" . #\u+0470)
                ("Cyrillic_Small_Letter_Psi" . #\u+0471)
                ("Cyrillic_Capital_Letter_Fita" . #\u+0472)
                ("Cyrillic_Small_Letter_Fita" . #\u+0473)
                ("Cyrillic_Capital_Letter_Izhitsa" . #\u+0474)
                ("Cyrillic_Small_Letter_Izhitsa" . #\u+0475)
                ("Cyrillic_Capital_Letter_Izhitsa_With_Double_Grave_Accent" . #\u+0476)
                ("Cyrillic_Small_Letter_Izhitsa_With_Double_Grave_Accent" . #\u+0477)
                ("Cyrillic_Capital_Letter_Uk" . #\u+0478)
                ("Cyrillic_Small_Letter_Uk" . #\u+0479)
                ("Cyrillic_Capital_Letter_Round_Omega" . #\u+047a)
                ("Cyrillic_Small_Letter_Round_Omega" . #\u+047b)
                ("Cyrillic_Capital_Letter_Omega_With_Titlo" . #\u+047c)
                ("Cyrillic_Small_Letter_Omega_With_Titlo" . #\u+047d)
                ("Cyrillic_Capital_Letter_Ot" . #\u+047e)
                ("Cyrillic_Small_Letter_Ot" . #\u+047f)
                ("Cyrillic_Capital_Letter_Koppa" . #\u+0480)
                ("Cyrillic_Small_Letter_Koppa" . #\u+0481)
                ("Cyrillic_Thousands_Sign" . #\u+0482)
                ("Combining_Cyrillic_Titlo" . #\u+0483)
                ("Combining_Cyrillic_Palatalization" . #\u+0484)
                ("Combining_Cyrillic_Dasia_Pneumata" . #\u+0485)
                ("Combining_Cyrillic_Psili_Pneumata" . #\u+0486)
                ("Combining_Cyrillic_Hundred_Thousands_Sign" . #\u+0488)
                ("Combining_Cyrillic_Millions_Sign" . #\u+0489)
                ("Cyrillic_Capital_Letter_Short_I_With_Tail" . #\u+048a)
                ("Cyrillic_Small_Letter_Short_I_With_Tail" . #\u+048b)
                ("Cyrillic_Capital_Letter_Semisoft_Sign" . #\u+048c)
                ("Cyrillic_Small_Letter_Semisoft_Sign" . #\u+048d)
                ("Cyrillic_Capital_Letter_Er_With_Tick" . #\u+048e)
                ("Cyrillic_Small_Letter_Er_With_Tick" . #\u+048f)
                ("Cyrillic_Capital_Letter_Ghe_With_Upturn" . #\u+0490)
                ("Cyrillic_Small_Letter_Ghe_With_Upturn" . #\u+0491)
                ("Cyrillic_Capital_Letter_Ghe_With_Stroke" . #\u+0492)
                ("Cyrillic_Small_Letter_Ghe_With_Stroke" . #\u+0493)
                ("Cyrillic_Capital_Letter_Ghe_With_Middle_Hook" . #\u+0494)
                ("Cyrillic_Small_Letter_Ghe_With_Middle_Hook" . #\u+0495)
                ("Cyrillic_Capital_Letter_Zhe_With_Descender" . #\u+0496)
                ("Cyrillic_Small_Letter_Zhe_With_Descender" . #\u+0497)
                ("Cyrillic_Capital_Letter_Ze_With_Descender" . #\u+0498)
                ("Cyrillic_Small_Letter_Ze_With_Descender" . #\u+0499)
                ("Cyrillic_Capital_Letter_Ka_With_Descender" . #\u+049a)
                ("Cyrillic_Small_Letter_Ka_With_Descender" . #\u+049b)
                ("Cyrillic_Capital_Letter_Ka_With_Vertical_Stroke" . #\u+049c)
                ("Cyrillic_Small_Letter_Ka_With_Vertical_Stroke" . #\u+049d)
                ("Cyrillic_Capital_Letter_Ka_With_Stroke" . #\u+049e)
                ("Cyrillic_Small_Letter_Ka_With_Stroke" . #\u+049f)
                ("Cyrillic_Capital_Letter_Bashkir_Ka" . #\u+04a0)
                ("Cyrillic_Small_Letter_Bashkir_Ka" . #\u+04a1)
                ("Cyrillic_Capital_Letter_En_With_Descender" . #\u+04a2)
                ("Cyrillic_Small_Letter_En_With_Descender" . #\u+04a3)
                ("Cyrillic_Capital_Ligature_En_Ghe" . #\u+04a4)
                ("Cyrillic_Small_Ligature_En_Ghe" . #\u+04a5)
                ("Cyrillic_Capital_Letter_Pe_With_Middle_Hook" . #\u+04a6)
                ("Cyrillic_Small_Letter_Pe_With_Middle_Hook" . #\u+04a7)
                ("Cyrillic_Capital_Letter_Abkhasian_Ha" . #\u+04a8)
                ("Cyrillic_Small_Letter_Abkhasian_Ha" . #\u+04a9)
                ("Cyrillic_Capital_Letter_Es_With_Descender" . #\u+04aa)
                ("Cyrillic_Small_Letter_Es_With_Descender" . #\u+04ab)
                ("Cyrillic_Capital_Letter_Te_With_Descender" . #\u+04ac)
                ("Cyrillic_Small_Letter_Te_With_Descender" . #\u+04ad)
                ("Cyrillic_Capital_Letter_Straight_U" . #\u+04ae)
                ("Cyrillic_Small_Letter_Straight_U" . #\u+04af)
                ("Cyrillic_Capital_Letter_Straight_U_With_Stroke" . #\u+04b0)
                ("Cyrillic_Small_Letter_Straight_U_With_Stroke" . #\u+04b1)
                ("Cyrillic_Capital_Letter_Ha_With_Descender" . #\u+04b2)
                ("Cyrillic_Small_Letter_Ha_With_Descender" . #\u+04b3)
                ("Cyrillic_Capital_Ligature_Te_Tse" . #\u+04b4)
                ("Cyrillic_Small_Ligature_Te_Tse" . #\u+04b5)
                ("Cyrillic_Capital_Letter_Che_With_Descender" . #\u+04b6)
                ("Cyrillic_Small_Letter_Che_With_Descender" . #\u+04b7)
                ("Cyrillic_Capital_Letter_Che_With_Vertical_Stroke" . #\u+04b8)
                ("Cyrillic_Small_Letter_Che_With_Vertical_Stroke" . #\u+04b9)
                ("Cyrillic_Capital_Letter_Shha" . #\u+04ba)
                ("Cyrillic_Small_Letter_Shha" . #\u+04bb)
                ("Cyrillic_Capital_Letter_Abkhasian_Che" . #\u+04bc)
                ("Cyrillic_Small_Letter_Abkhasian_Che" . #\u+04bd)
                ("Cyrillic_Capital_Letter_Abkhasian_Che_With_Descender" . #\u+04be)
                ("Cyrillic_Small_Letter_Abkhasian_Che_With_Descender" . #\u+04bf)
                ("Cyrillic_Letter_Palochka" . #\u+04c0)
                ("Cyrillic_Capital_Letter_Zhe_With_Breve" . #\u+04c1)
                ("Cyrillic_Small_Letter_Zhe_With_Breve" . #\u+04c2)
                ("Cyrillic_Capital_Letter_Ka_With_Hook" . #\u+04c3)
                ("Cyrillic_Small_Letter_Ka_With_Hook" . #\u+04c4)
                ("Cyrillic_Capital_Letter_El_With_Tail" . #\u+04c5)
                ("Cyrillic_Small_Letter_El_With_Tail" . #\u+04c6)
                ("Cyrillic_Capital_Letter_En_With_Hook" . #\u+04c7)
                ("Cyrillic_Small_Letter_En_With_Hook" . #\u+04c8)
                ("Cyrillic_Capital_Letter_En_With_Tail" . #\u+04c9)
                ("Cyrillic_Small_Letter_En_With_Tail" . #\u+04ca)
                ("Cyrillic_Capital_Letter_Khakassian_Che" . #\u+04cb)
                ("Cyrillic_Small_Letter_Khakassian_Che" . #\u+04cc)
                ("Cyrillic_Capital_Letter_Em_With_Tail" . #\u+04cd)
                ("Cyrillic_Small_Letter_Em_With_Tail" . #\u+04ce)
                ("Cyrillic_Small_Letter_Palochka" . #\u+04cf)
                ("Cyrillic_Capital_Letter_A_With_Breve" . #\u+04d0)
                ("Cyrillic_Small_Letter_A_With_Breve" . #\u+04d1)
                ("Cyrillic_Capital_Letter_A_With_Diaeresis" . #\u+04d2)
                ("Cyrillic_Small_Letter_A_With_Diaeresis" . #\u+04d3)
                ("Cyrillic_Capital_Ligature_A_Ie" . #\u+04d4)
                ("Cyrillic_Small_Ligature_A_Ie" . #\u+04d5)
                ("Cyrillic_Capital_Letter_Ie_With_Breve" . #\u+04d6)
                ("Cyrillic_Small_Letter_Ie_With_Breve" . #\u+04d7)
                ("Cyrillic_Capital_Letter_Schwa" . #\u+04d8)
                ("Cyrillic_Small_Letter_Schwa" . #\u+04d9)
                ("Cyrillic_Capital_Letter_Schwa_With_Diaeresis" . #\u+04da)
                ("Cyrillic_Small_Letter_Schwa_With_Diaeresis" . #\u+04db)
                ("Cyrillic_Capital_Letter_Zhe_With_Diaeresis" . #\u+04dc)
                ("Cyrillic_Small_Letter_Zhe_With_Diaeresis" . #\u+04dd)
                ("Cyrillic_Capital_Letter_Ze_With_Diaeresis" . #\u+04de)
                ("Cyrillic_Small_Letter_Ze_With_Diaeresis" . #\u+04df)
                ("Cyrillic_Capital_Letter_Abkhasian_Dze" . #\u+04e0)
                ("Cyrillic_Small_Letter_Abkhasian_Dze" . #\u+04e1)
                ("Cyrillic_Capital_Letter_I_With_Macron" . #\u+04e2)
                ("Cyrillic_Small_Letter_I_With_Macron" . #\u+04e3)
                ("Cyrillic_Capital_Letter_I_With_Diaeresis" . #\u+04e4)
                ("Cyrillic_Small_Letter_I_With_Diaeresis" . #\u+04e5)
                ("Cyrillic_Capital_Letter_O_With_Diaeresis" . #\u+04e6)
                ("Cyrillic_Small_Letter_O_With_Diaeresis" . #\u+04e7)
                ("Cyrillic_Capital_Letter_Barred_O" . #\u+04e8)
                ("Cyrillic_Small_Letter_Barred_O" . #\u+04e9)
                ("Cyrillic_Capital_Letter_Barred_O_With_Diaeresis" . #\u+04ea)
                ("Cyrillic_Small_Letter_Barred_O_With_Diaeresis" . #\u+04eb)
                ("Cyrillic_Capital_Letter_E_With_Diaeresis" . #\u+04ec)
                ("Cyrillic_Small_Letter_E_With_Diaeresis" . #\u+04ed)
                ("Cyrillic_Capital_Letter_U_With_Macron" . #\u+04ee)
                ("Cyrillic_Small_Letter_U_With_Macron" . #\u+04ef)
                ("Cyrillic_Capital_Letter_U_With_Diaeresis" . #\u+04f0)
                ("Cyrillic_Small_Letter_U_With_Diaeresis" . #\u+04f1)
                ("Cyrillic_Capital_Letter_U_With_Double_Acute" . #\u+04f2)
                ("Cyrillic_Small_Letter_U_With_Double_Acute" . #\u+04f3)
                ("Cyrillic_Capital_Letter_Che_With_Diaeresis" . #\u+04f4)
                ("Cyrillic_Small_Letter_Che_With_Diaeresis" . #\u+04f5)
                ("Cyrillic_Capital_Letter_Ghe_With_Descender" . #\u+04f6)
                ("Cyrillic_Small_Letter_Ghe_With_Descender" . #\u+04f7)
                ("Cyrillic_Capital_Letter_Yeru_With_Diaeresis" . #\u+04f8)
                ("Cyrillic_Small_Letter_Yeru_With_Diaeresis" . #\u+04f9)
                ("Cyrillic_Capital_Letter_Ghe_With_Stroke_And_Hook" . #\u+04fa)
                ("Cyrillic_Small_Letter_Ghe_With_Stroke_And_Hook" . #\u+04fb)
                ("Cyrillic_Capital_Letter_Ha_With_Hook" . #\u+04fc)
                ("Cyrillic_Small_Letter_Ha_With_Hook" . #\u+04fd)
                ("Cyrillic_Capital_Letter_Ha_With_Stroke" . #\u+04fe)
                ("Cyrillic_Small_Letter_Ha_With_Stroke" . #\u+04ff)
                ("Cyrillic_Capital_Letter_Komi_De" . #\u+0500)
                ("Cyrillic_Small_Letter_Komi_De" . #\u+0501)
                ("Cyrillic_Capital_Letter_Komi_Dje" . #\u+0502)
                ("Cyrillic_Small_Letter_Komi_Dje" . #\u+0503)
                ("Cyrillic_Capital_Letter_Komi_Zje" . #\u+0504)
                ("Cyrillic_Small_Letter_Komi_Zje" . #\u+0505)
                ("Cyrillic_Capital_Letter_Komi_Dzje" . #\u+0506)
                ("Cyrillic_Small_Letter_Komi_Dzje" . #\u+0507)
                ("Cyrillic_Capital_Letter_Komi_Lje" . #\u+0508)
                ("Cyrillic_Small_Letter_Komi_Lje" . #\u+0509)
                ("Cyrillic_Capital_Letter_Komi_Nje" . #\u+050a)
                ("Cyrillic_Small_Letter_Komi_Nje" . #\u+050b)
                ("Cyrillic_Capital_Letter_Komi_Sje" . #\u+050c)
                ("Cyrillic_Small_Letter_Komi_Sje" . #\u+050d)
                ("Cyrillic_Capital_Letter_Komi_Tje" . #\u+050e)
                ("Cyrillic_Small_Letter_Komi_Tje" . #\u+050f)
                ("Cyrillic_Capital_Letter_Reversed_Ze" . #\u+0510)
                ("Cyrillic_Small_Letter_Reversed_Ze" . #\u+0511)
                ("Cyrillic_Capital_Letter_El_With_Hook" . #\u+0512)
                ("Cyrillic_Small_Letter_El_With_Hook" . #\u+0513)
                ("Armenian_Capital_Letter_Ayb" . #\u+0531)
                ("Armenian_Capital_Letter_Ben" . #\u+0532)
                ("Armenian_Capital_Letter_Gim" . #\u+0533)
                ("Armenian_Capital_Letter_Da" . #\u+0534)
                ("Armenian_Capital_Letter_Ech" . #\u+0535)
                ("Armenian_Capital_Letter_Za" . #\u+0536)
                ("Armenian_Capital_Letter_Eh" . #\u+0537)
                ("Armenian_Capital_Letter_Et" . #\u+0538)
                ("Armenian_Capital_Letter_To" . #\u+0539)
                ("Armenian_Capital_Letter_Zhe" . #\u+053a)
                ("Armenian_Capital_Letter_Ini" . #\u+053b)
                ("Armenian_Capital_Letter_Liwn" . #\u+053c)
                ("Armenian_Capital_Letter_Xeh" . #\u+053d)
                ("Armenian_Capital_Letter_Ca" . #\u+053e)
                ("Armenian_Capital_Letter_Ken" . #\u+053f)
                ("Armenian_Capital_Letter_Ho" . #\u+0540)
                ("Armenian_Capital_Letter_Ja" . #\u+0541)
                ("Armenian_Capital_Letter_Ghad" . #\u+0542)
                ("Armenian_Capital_Letter_Cheh" . #\u+0543)
                ("Armenian_Capital_Letter_Men" . #\u+0544)
                ("Armenian_Capital_Letter_Yi" . #\u+0545)
                ("Armenian_Capital_Letter_Now" . #\u+0546)
                ("Armenian_Capital_Letter_Sha" . #\u+0547)
                ("Armenian_Capital_Letter_Vo" . #\u+0548)
                ("Armenian_Capital_Letter_Cha" . #\u+0549)
                ("Armenian_Capital_Letter_Peh" . #\u+054a)
                ("Armenian_Capital_Letter_Jheh" . #\u+054b)
                ("Armenian_Capital_Letter_Ra" . #\u+054c)
                ("Armenian_Capital_Letter_Seh" . #\u+054d)
                ("Armenian_Capital_Letter_Vew" . #\u+054e)
                ("Armenian_Capital_Letter_Tiwn" . #\u+054f)
                ("Armenian_Capital_Letter_Reh" . #\u+0550)
                ("Armenian_Capital_Letter_Co" . #\u+0551)
                ("Armenian_Capital_Letter_Yiwn" . #\u+0552)
                ("Armenian_Capital_Letter_Piwr" . #\u+0553)
                ("Armenian_Capital_Letter_Keh" . #\u+0554)
                ("Armenian_Capital_Letter_Oh" . #\u+0555)
                ("Armenian_Capital_Letter_Feh" . #\u+0556)
                ("Armenian_Modifier_Letter_Left_Half_Ring" . #\u+0559)
                ("Armenian_Apostrophe" . #\u+055a)
                ("Armenian_Emphasis_Mark" . #\u+055b)
                ("Armenian_Exclamation_Mark" . #\u+055c)
                ("Armenian_Comma" . #\u+055d)
                ("Armenian_Question_Mark" . #\u+055e)
                ("Armenian_Abbreviation_Mark" . #\u+055f)
                ("Armenian_Small_Letter_Ayb" . #\u+0561)
                ("Armenian_Small_Letter_Ben" . #\u+0562)
                ("Armenian_Small_Letter_Gim" . #\u+0563)
                ("Armenian_Small_Letter_Da" . #\u+0564)
                ("Armenian_Small_Letter_Ech" . #\u+0565)
                ("Armenian_Small_Letter_Za" . #\u+0566)
                ("Armenian_Small_Letter_Eh" . #\u+0567)
                ("Armenian_Small_Letter_Et" . #\u+0568)
                ("Armenian_Small_Letter_To" . #\u+0569)
                ("Armenian_Small_Letter_Zhe" . #\u+056a)
                ("Armenian_Small_Letter_Ini" . #\u+056b)
                ("Armenian_Small_Letter_Liwn" . #\u+056c)
                ("Armenian_Small_Letter_Xeh" . #\u+056d)
                ("Armenian_Small_Letter_Ca" . #\u+056e)
                ("Armenian_Small_Letter_Ken" . #\u+056f)
                ("Armenian_Small_Letter_Ho" . #\u+0570)
                ("Armenian_Small_Letter_Ja" . #\u+0571)
                ("Armenian_Small_Letter_Ghad" . #\u+0572)
                ("Armenian_Small_Letter_Cheh" . #\u+0573)
                ("Armenian_Small_Letter_Men" . #\u+0574)
                ("Armenian_Small_Letter_Yi" . #\u+0575)
                ("Armenian_Small_Letter_Now" . #\u+0576)
                ("Armenian_Small_Letter_Sha" . #\u+0577)
                ("Armenian_Small_Letter_Vo" . #\u+0578)
                ("Armenian_Small_Letter_Cha" . #\u+0579)
                ("Armenian_Small_Letter_Peh" . #\u+057a)
                ("Armenian_Small_Letter_Jheh" . #\u+057b)
                ("Armenian_Small_Letter_Ra" . #\u+057c)
                ("Armenian_Small_Letter_Seh" . #\u+057d)
                ("Armenian_Small_Letter_Vew" . #\u+057e)
                ("Armenian_Small_Letter_Tiwn" . #\u+057f)
                ("Armenian_Small_Letter_Reh" . #\u+0580)
                ("Armenian_Small_Letter_Co" . #\u+0581)
                ("Armenian_Small_Letter_Yiwn" . #\u+0582)
                ("Armenian_Small_Letter_Piwr" . #\u+0583)
                ("Armenian_Small_Letter_Keh" . #\u+0584)
                ("Armenian_Small_Letter_Oh" . #\u+0585)
                ("Armenian_Small_Letter_Feh" . #\u+0586)
                ("Armenian_Small_Ligature_Ech_Yiwn" . #\u+0587)
                ("Armenian_Full_Stop" . #\u+0589)
                ("Armenian_Hyphen" . #\u+058a)
                ("Hebrew_Accent_Etnahta" . #\u+0591)
                ("Hebrew_Accent_Segol" . #\u+0592)
                ("Hebrew_Accent_Shalshelet" . #\u+0593)
                ("Hebrew_Accent_Zaqef_Qatan" . #\u+0594)
                ("Hebrew_Accent_Zaqef_Gadol" . #\u+0595)
                ("Hebrew_Accent_Tipeha" . #\u+0596)
                ("Hebrew_Accent_Revia" . #\u+0597)
                ("Hebrew_Accent_Zarqa" . #\u+0598)
                ("Hebrew_Accent_Pashta" . #\u+0599)
                ("Hebrew_Accent_Yetiv" . #\u+059a)
                ("Hebrew_Accent_Tevir" . #\u+059b)
                ("Hebrew_Accent_Geresh" . #\u+059c)
                ("Hebrew_Accent_Geresh_Muqdam" . #\u+059d)
                ("Hebrew_Accent_Gershayim" . #\u+059e)
                ("Hebrew_Accent_Qarney_Para" . #\u+059f)
                ("Hebrew_Accent_Telisha_Gedola" . #\u+05a0)
                ("Hebrew_Accent_Pazer" . #\u+05a1)
                ("Hebrew_Accent_Atnah_Hafukh" . #\u+05a2)
                ("Hebrew_Accent_Munah" . #\u+05a3)
                ("Hebrew_Accent_Mahapakh" . #\u+05a4)
                ("Hebrew_Accent_Merkha" . #\u+05a5)
                ("Hebrew_Accent_Merkha_Kefula" . #\u+05a6)
                ("Hebrew_Accent_Darga" . #\u+05a7)
                ("Hebrew_Accent_Qadma" . #\u+05a8)
                ("Hebrew_Accent_Telisha_Qetana" . #\u+05a9)
                ("Hebrew_Accent_Yerah_Ben_Yomo" . #\u+05aa)
                ("Hebrew_Accent_Ole" . #\u+05ab)
                ("Hebrew_Accent_Iluy" . #\u+05ac)
                ("Hebrew_Accent_Dehi" . #\u+05ad)
                ("Hebrew_Accent_Zinor" . #\u+05ae)
                ("Hebrew_Mark_Masora_Circle" . #\u+05af)
                ("Hebrew_Point_Sheva" . #\u+05b0)
                ("Hebrew_Point_Hataf_Segol" . #\u+05b1)
                ("Hebrew_Point_Hataf_Patah" . #\u+05b2)
                ("Hebrew_Point_Hataf_Qamats" . #\u+05b3)
                ("Hebrew_Point_Hiriq" . #\u+05b4)
                ("Hebrew_Point_Tsere" . #\u+05b5)
                ("Hebrew_Point_Segol" . #\u+05b6)
                ("Hebrew_Point_Patah" . #\u+05b7)
                ("Hebrew_Point_Qamats" . #\u+05b8)
                ("Hebrew_Point_Holam" . #\u+05b9)
                ("Hebrew_Point_Holam_Haser_For_Vav" . #\u+05ba)
                ("Hebrew_Point_Qubuts" . #\u+05bb)
                ("Hebrew_Point_Dagesh_Or_Mapiq" . #\u+05bc)
                ("Hebrew_Point_Meteg" . #\u+05bd)
                ("Hebrew_Punctuation_Maqaf" . #\u+05be)
                ("Hebrew_Point_Rafe" . #\u+05bf)
                ("Hebrew_Punctuation_Paseq" . #\u+05c0)
                ("Hebrew_Point_Shin_Dot" . #\u+05c1)
                ("Hebrew_Point_Sin_Dot" . #\u+05c2)
                ("Hebrew_Punctuation_Sof_Pasuq" . #\u+05c3)
                ("Hebrew_Mark_Upper_Dot" . #\u+05c4)
                ("Hebrew_Mark_Lower_Dot" . #\u+05c5)
                ("Hebrew_Punctuation_Nun_Hafukha" . #\u+05c6)
                ("Hebrew_Point_Qamats_Qatan" . #\u+05c7)
                ("Hebrew_Letter_Alef" . #\u+05d0)
                ("Hebrew_Letter_Bet" . #\u+05d1)
                ("Hebrew_Letter_Gimel" . #\u+05d2)
                ("Hebrew_Letter_Dalet" . #\u+05d3)
                ("Hebrew_Letter_He" . #\u+05d4)
                ("Hebrew_Letter_Vav" . #\u+05d5)
                ("Hebrew_Letter_Zayin" . #\u+05d6)
                ("Hebrew_Letter_Het" . #\u+05d7)
                ("Hebrew_Letter_Tet" . #\u+05d8)
                ("Hebrew_Letter_Yod" . #\u+05d9)
                ("Hebrew_Letter_Final_Kaf" . #\u+05da)
                ("Hebrew_Letter_Kaf" . #\u+05db)
                ("Hebrew_Letter_Lamed" . #\u+05dc)
                ("Hebrew_Letter_Final_Mem" . #\u+05dd)
                ("Hebrew_Letter_Mem" . #\u+05de)
                ("Hebrew_Letter_Final_Nun" . #\u+05df)
                ("Hebrew_Letter_Nun" . #\u+05e0)
                ("Hebrew_Letter_Samekh" . #\u+05e1)
                ("Hebrew_Letter_Ayin" . #\u+05e2)
                ("Hebrew_Letter_Final_Pe" . #\u+05e3)
                ("Hebrew_Letter_Pe" . #\u+05e4)
                ("Hebrew_Letter_Final_Tsadi" . #\u+05e5)
                ("Hebrew_Letter_Tsadi" . #\u+05e6)
                ("Hebrew_Letter_Qof" . #\u+05e7)
                ("Hebrew_Letter_Resh" . #\u+05e8)
                ("Hebrew_Letter_Shin" . #\u+05e9)
                ("Hebrew_Letter_Tav" . #\u+05ea)
                ("Hebrew_Ligature_Yiddish_Double_Vav" . #\u+05f0)
                ("Hebrew_Ligature_Yiddish_Vav_Yod" . #\u+05f1)
                ("Hebrew_Ligature_Yiddish_Double_Yod" . #\u+05f2)
                ("Hebrew_Punctuation_Geresh" . #\u+05f3)
                ("Hebrew_Punctuation_Gershayim" . #\u+05f4)
                ("Arabic_Number_Sign" . #\u+0600)
                ("Arabic_Sign_Sanah" . #\u+0601)
                ("Arabic_Footnote_Marker" . #\u+0602)
                ("Arabic_Sign_Safha" . #\u+0603)
                ("Afghani_Sign" . #\u+060b)
                ("Arabic_Comma" . #\u+060c)
                ("Arabic_Date_Separator" . #\u+060d)
                ("Arabic_Poetic_Verse_Sign" . #\u+060e)
                ("Arabic_Sign_Misra" . #\u+060f)
                ("Arabic_Sign_Sallallahou_Alayhe_Wassallam" . #\u+0610)
                ("Arabic_Sign_Alayhe_Assallam" . #\u+0611)
                ("Arabic_Sign_Rahmatullah_Alayhe" . #\u+0612)
                ("Arabic_Sign_Radi_Allahou_Anhu" . #\u+0613)
                ("Arabic_Sign_Takhallus" . #\u+0614)
                ("Arabic_Small_High_Tah" . #\u+0615)
                ("Arabic_Semicolon" . #\u+061b)
                ("Arabic_Triple_Dot_Punctuation_Mark" . #\u+061e)
                ("Arabic_Question_Mark" . #\u+061f)
                ("Arabic_Letter_Hamza" . #\u+0621)
                ("Arabic_Letter_Alef_With_Madda_Above" . #\u+0622)
                ("Arabic_Letter_Alef_With_Hamza_Above" . #\u+0623)
                ("Arabic_Letter_Waw_With_Hamza_Above" . #\u+0624)
                ("Arabic_Letter_Alef_With_Hamza_Below" . #\u+0625)
                ("Arabic_Letter_Yeh_With_Hamza_Above" . #\u+0626)
                ("Arabic_Letter_Alef" . #\u+0627)
                ("Arabic_Letter_Beh" . #\u+0628)
                ("Arabic_Letter_Teh_Marbuta" . #\u+0629)
                ("Arabic_Letter_Teh" . #\u+062a)
                ("Arabic_Letter_Theh" . #\u+062b)
                ("Arabic_Letter_Jeem" . #\u+062c)
                ("Arabic_Letter_Hah" . #\u+062d)
                ("Arabic_Letter_Khah" . #\u+062e)
                ("Arabic_Letter_Dal" . #\u+062f)
                ("Arabic_Letter_Thal" . #\u+0630)
                ("Arabic_Letter_Reh" . #\u+0631)
                ("Arabic_Letter_Zain" . #\u+0632)
                ("Arabic_Letter_Seen" . #\u+0633)
                ("Arabic_Letter_Sheen" . #\u+0634)
                ("Arabic_Letter_Sad" . #\u+0635)
                ("Arabic_Letter_Dad" . #\u+0636)
                ("Arabic_Letter_Tah" . #\u+0637)
                ("Arabic_Letter_Zah" . #\u+0638)
                ("Arabic_Letter_Ain" . #\u+0639)
                ("Arabic_Letter_Ghain" . #\u+063a)
                ("Arabic_Tatweel" . #\u+0640)
                ("Arabic_Letter_Feh" . #\u+0641)
                ("Arabic_Letter_Qaf" . #\u+0642)
                ("Arabic_Letter_Kaf" . #\u+0643)
                ("Arabic_Letter_Lam" . #\u+0644)
                ("Arabic_Letter_Meem" . #\u+0645)
                ("Arabic_Letter_Noon" . #\u+0646)
                ("Arabic_Letter_Heh" . #\u+0647)
                ("Arabic_Letter_Waw" . #\u+0648)
                ("Arabic_Letter_Alef_Maksura" . #\u+0649)
                ("Arabic_Letter_Yeh" . #\u+064a)
                ("Arabic_Fathatan" . #\u+064b)
                ("Arabic_Dammatan" . #\u+064c)
                ("Arabic_Kasratan" . #\u+064d)
                ("Arabic_Fatha" . #\u+064e)
                ("Arabic_Damma" . #\u+064f)
                ("Arabic_Kasra" . #\u+0650)
                ("Arabic_Shadda" . #\u+0651)
                ("Arabic_Sukun" . #\u+0652)
                ("Arabic_Maddah_Above" . #\u+0653)
                ("Arabic_Hamza_Above" . #\u+0654)
                ("Arabic_Hamza_Below" . #\u+0655)
                ("Arabic_Subscript_Alef" . #\u+0656)
                ("Arabic_Inverted_Damma" . #\u+0657)
                ("Arabic_Mark_Noon_Ghunna" . #\u+0658)
                ("Arabic_Zwarakay" . #\u+0659)
                ("Arabic_Vowel_Sign_Small_V_Above" . #\u+065a)
                ("Arabic_Vowel_Sign_Inverted_Small_V_Above" . #\u+065b)
                ("Arabic_Vowel_Sign_Dot_Below" . #\u+065c)
                ("Arabic_Reversed_Damma" . #\u+065d)
                ("Arabic_Fatha_With_Two_Dots" . #\u+065e)
                ("Arabic-Indic_Digit_Zero" . #\u+0660)
                ("Arabic-Indic_Digit_One" . #\u+0661)
                ("Arabic-Indic_Digit_Two" . #\u+0662)
                ("Arabic-Indic_Digit_Three" . #\u+0663)
                ("Arabic-Indic_Digit_Four" . #\u+0664)
                ("Arabic-Indic_Digit_Five" . #\u+0665)
                ("Arabic-Indic_Digit_Six" . #\u+0666)
                ("Arabic-Indic_Digit_Seven" . #\u+0667)
                ("Arabic-Indic_Digit_Eight" . #\u+0668)
                ("Arabic-Indic_Digit_Nine" . #\u+0669)
                ("Arabic_Percent_Sign" . #\u+066a)
                ("Arabic_Decimal_Separator" . #\u+066b)
                ("Arabic_Thousands_Separator" . #\u+066c)
                ("Arabic_Five_Pointed_Star" . #\u+066d)
                ("Arabic_Letter_Dotless_Beh" . #\u+066e)
                ("Arabic_Letter_Dotless_Qaf" . #\u+066f)
                ("Arabic_Letter_Superscript_Alef" . #\u+0670)
                ("Arabic_Letter_Alef_Wasla" . #\u+0671)
                ("Arabic_Letter_Alef_With_Wavy_Hamza_Above" . #\u+0672)
                ("Arabic_Letter_Alef_With_Wavy_Hamza_Below" . #\u+0673)
                ("Arabic_Letter_High_Hamza" . #\u+0674)
                ("Arabic_Letter_High_Hamza_Alef" . #\u+0675)
                ("Arabic_Letter_High_Hamza_Waw" . #\u+0676)
                ("Arabic_Letter_U_With_Hamza_Above" . #\u+0677)
                ("Arabic_Letter_High_Hamza_Yeh" . #\u+0678)
                ("Arabic_Letter_Tteh" . #\u+0679)
                ("Arabic_Letter_Tteheh" . #\u+067a)
                ("Arabic_Letter_Beeh" . #\u+067b)
                ("Arabic_Letter_Teh_With_Ring" . #\u+067c)
                ("Arabic_Letter_Teh_With_Three_Dots_Above_Downwards" . #\u+067d)
                ("Arabic_Letter_Peh" . #\u+067e)
                ("Arabic_Letter_Teheh" . #\u+067f)
                ("Arabic_Letter_Beheh" . #\u+0680)
                ("Arabic_Letter_Hah_With_Hamza_Above" . #\u+0681)
                ("Arabic_Letter_Hah_With_Two_Dots_Vertical_Above" . #\u+0682)
                ("Arabic_Letter_Nyeh" . #\u+0683)
                ("Arabic_Letter_Dyeh" . #\u+0684)
                ("Arabic_Letter_Hah_With_Three_Dots_Above" . #\u+0685)
                ("Arabic_Letter_Tcheh" . #\u+0686)
                ("Arabic_Letter_Tcheheh" . #\u+0687)
                ("Arabic_Letter_Ddal" . #\u+0688)
                ("Arabic_Letter_Dal_With_Ring" . #\u+0689)
                ("Arabic_Letter_Dal_With_Dot_Below" . #\u+068a)
                ("Arabic_Letter_Dal_With_Dot_Below_And_Small_Tah" . #\u+068b)
                ("Arabic_Letter_Dahal" . #\u+068c)
                ("Arabic_Letter_Ddahal" . #\u+068d)
                ("Arabic_Letter_Dul" . #\u+068e)
                ("Arabic_Letter_Dal_With_Three_Dots_Above_Downwards" . #\u+068f)
                ("Arabic_Letter_Dal_With_Four_Dots_Above" . #\u+0690)
                ("Arabic_Letter_Rreh" . #\u+0691)
                ("Arabic_Letter_Reh_With_Small_V" . #\u+0692)
                ("Arabic_Letter_Reh_With_Ring" . #\u+0693)
                ("Arabic_Letter_Reh_With_Dot_Below" . #\u+0694)
                ("Arabic_Letter_Reh_With_Small_V_Below" . #\u+0695)
                ("Arabic_Letter_Reh_With_Dot_Below_And_Dot_Above" . #\u+0696)
                ("Arabic_Letter_Reh_With_Two_Dots_Above" . #\u+0697)
                ("Arabic_Letter_Jeh" . #\u+0698)
                ("Arabic_Letter_Reh_With_Four_Dots_Above" . #\u+0699)
                ("Arabic_Letter_Seen_With_Dot_Below_And_Dot_Above" . #\u+069a)
                ("Arabic_Letter_Seen_With_Three_Dots_Below" . #\u+069b)
                ("Arabic_Letter_Seen_With_Three_Dots_Below_And_Three_Dots_Above" . #\u+069c)
                ("Arabic_Letter_Sad_With_Two_Dots_Below" . #\u+069d)
                ("Arabic_Letter_Sad_With_Three_Dots_Above" . #\u+069e)
                ("Arabic_Letter_Tah_With_Three_Dots_Above" . #\u+069f)
                ("Arabic_Letter_Ain_With_Three_Dots_Above" . #\u+06a0)
                ("Arabic_Letter_Dotless_Feh" . #\u+06a1)
                ("Arabic_Letter_Feh_With_Dot_Moved_Below" . #\u+06a2)
                ("Arabic_Letter_Feh_With_Dot_Below" . #\u+06a3)
                ("Arabic_Letter_Veh" . #\u+06a4)
                ("Arabic_Letter_Feh_With_Three_Dots_Below" . #\u+06a5)
                ("Arabic_Letter_Peheh" . #\u+06a6)
                ("Arabic_Letter_Qaf_With_Dot_Above" . #\u+06a7)
                ("Arabic_Letter_Qaf_With_Three_Dots_Above" . #\u+06a8)
                ("Arabic_Letter_Keheh" . #\u+06a9)
                ("Arabic_Letter_Swash_Kaf" . #\u+06aa)
                ("Arabic_Letter_Kaf_With_Ring" . #\u+06ab)
                ("Arabic_Letter_Kaf_With_Dot_Above" . #\u+06ac)
                ("Arabic_Letter_Ng" . #\u+06ad)
                ("Arabic_Letter_Kaf_With_Three_Dots_Below" . #\u+06ae)
                ("Arabic_Letter_Gaf" . #\u+06af)
                ("Arabic_Letter_Gaf_With_Ring" . #\u+06b0)
                ("Arabic_Letter_Ngoeh" . #\u+06b1)
                ("Arabic_Letter_Gaf_With_Two_Dots_Below" . #\u+06b2)
                ("Arabic_Letter_Gueh" . #\u+06b3)
                ("Arabic_Letter_Gaf_With_Three_Dots_Above" . #\u+06b4)
                ("Arabic_Letter_Lam_With_Small_V" . #\u+06b5)
                ("Arabic_Letter_Lam_With_Dot_Above" . #\u+06b6)
                ("Arabic_Letter_Lam_With_Three_Dots_Above" . #\u+06b7)
                ("Arabic_Letter_Lam_With_Three_Dots_Below" . #\u+06b8)
                ("Arabic_Letter_Noon_With_Dot_Below" . #\u+06b9)
                ("Arabic_Letter_Noon_Ghunna" . #\u+06ba)
                ("Arabic_Letter_Rnoon" . #\u+06bb)
                ("Arabic_Letter_Noon_With_Ring" . #\u+06bc)
                ("Arabic_Letter_Noon_With_Three_Dots_Above" . #\u+06bd)
                ("Arabic_Letter_Heh_Doachashmee" . #\u+06be)
                ("Arabic_Letter_Tcheh_With_Dot_Above" . #\u+06bf)
                ("Arabic_Letter_Heh_With_Yeh_Above" . #\u+06c0)
                ("Arabic_Letter_Heh_Goal" . #\u+06c1)
                ("Arabic_Letter_Heh_Goal_With_Hamza_Above" . #\u+06c2)
                ("Arabic_Letter_Teh_Marbuta_Goal" . #\u+06c3)
                ("Arabic_Letter_Waw_With_Ring" . #\u+06c4)
                ("Arabic_Letter_Kirghiz_Oe" . #\u+06c5)
                ("Arabic_Letter_Oe" . #\u+06c6)
                ("Arabic_Letter_U" . #\u+06c7)
                ("Arabic_Letter_Yu" . #\u+06c8)
                ("Arabic_Letter_Kirghiz_Yu" . #\u+06c9)
                ("Arabic_Letter_Waw_With_Two_Dots_Above" . #\u+06ca)
                ("Arabic_Letter_Ve" . #\u+06cb)
                ("Arabic_Letter_Farsi_Yeh" . #\u+06cc)
                ("Arabic_Letter_Yeh_With_Tail" . #\u+06cd)
                ("Arabic_Letter_Yeh_With_Small_V" . #\u+06ce)
                ("Arabic_Letter_Waw_With_Dot_Above" . #\u+06cf)
                ("Arabic_Letter_E" . #\u+06d0)
                ("Arabic_Letter_Yeh_With_Three_Dots_Below" . #\u+06d1)
                ("Arabic_Letter_Yeh_Barree" . #\u+06d2)
                ("Arabic_Letter_Yeh_Barree_With_Hamza_Above" . #\u+06d3)
                ("Arabic_Full_Stop" . #\u+06d4)
                ("Arabic_Letter_Ae" . #\u+06d5)
                ("Arabic_Small_High_Ligature_Sad_With_Lam_With_Alef_Maksura" . #\u+06d6)
                ("Arabic_Small_High_Ligature_Qaf_With_Lam_With_Alef_Maksura" . #\u+06d7)
                ("Arabic_Small_High_Meem_Initial_Form" . #\u+06d8)
                ("Arabic_Small_High_Lam_Alef" . #\u+06d9)
                ("Arabic_Small_High_Jeem" . #\u+06da)
                ("Arabic_Small_High_Three_Dots" . #\u+06db)
                ("Arabic_Small_High_Seen" . #\u+06dc)
                ("Arabic_End_Of_Ayah" . #\u+06dd)
                ("Arabic_Start_Of_Rub_El_Hizb" . #\u+06de)
                ("Arabic_Small_High_Rounded_Zero" . #\u+06df)
                ("Arabic_Small_High_Upright_Rectangular_Zero" . #\u+06e0)
                ("Arabic_Small_High_Dotless_Head_Of_Khah" . #\u+06e1)
                ("Arabic_Small_High_Meem_Isolated_Form" . #\u+06e2)
                ("Arabic_Small_Low_Seen" . #\u+06e3)
                ("Arabic_Small_High_Madda" . #\u+06e4)
                ("Arabic_Small_Waw" . #\u+06e5)
                ("Arabic_Small_Yeh" . #\u+06e6)
                ("Arabic_Small_High_Yeh" . #\u+06e7)
                ("Arabic_Small_High_Noon" . #\u+06e8)
                ("Arabic_Place_Of_Sajdah" . #\u+06e9)
                ("Arabic_Empty_Centre_Low_Stop" . #\u+06ea)
                ("Arabic_Empty_Centre_High_Stop" . #\u+06eb)
                ("Arabic_Rounded_High_Stop_With_Filled_Centre" . #\u+06ec)
                ("Arabic_Small_Low_Meem" . #\u+06ed)
                ("Arabic_Letter_Dal_With_Inverted_V" . #\u+06ee)
                ("Arabic_Letter_Reh_With_Inverted_V" . #\u+06ef)
                ("Extended_Arabic-Indic_Digit_Zero" . #\u+06f0)
                ("Extended_Arabic-Indic_Digit_One" . #\u+06f1)
                ("Extended_Arabic-Indic_Digit_Two" . #\u+06f2)
                ("Extended_Arabic-Indic_Digit_Three" . #\u+06f3)
                ("Extended_Arabic-Indic_Digit_Four" . #\u+06f4)
                ("Extended_Arabic-Indic_Digit_Five" . #\u+06f5)
                ("Extended_Arabic-Indic_Digit_Six" . #\u+06f6)
                ("Extended_Arabic-Indic_Digit_Seven" . #\u+06f7)
                ("Extended_Arabic-Indic_Digit_Eight" . #\u+06f8)
                ("Extended_Arabic-Indic_Digit_Nine" . #\u+06f9)
                ("Arabic_Letter_Sheen_With_Dot_Below" . #\u+06fa)
                ("Arabic_Letter_Dad_With_Dot_Below" . #\u+06fb)
                ("Arabic_Letter_Ghain_With_Dot_Below" . #\u+06fc)
                ("Arabic_Sign_Sindhi_Ampersand" . #\u+06fd)
                ("Arabic_Sign_Sindhi_Postposition_Men" . #\u+06fe)
                ("Arabic_Letter_Heh_With_Inverted_V" . #\u+06ff)
                ("Syriac_End_Of_Paragraph" . #\u+0700)
                ("Syriac_Supralinear_Full_Stop" . #\u+0701)
                ("Syriac_Sublinear_Full_Stop" . #\u+0702)
                ("Syriac_Supralinear_Colon" . #\u+0703)
                ("Syriac_Sublinear_Colon" . #\u+0704)
                ("Syriac_Horizontal_Colon" . #\u+0705)
                ("Syriac_Colon_Skewed_Left" . #\u+0706)
                ("Syriac_Colon_Skewed_Right" . #\u+0707)
                ("Syriac_Supralinear_Colon_Skewed_Left" . #\u+0708)
                ("Syriac_Sublinear_Colon_Skewed_Right" . #\u+0709)
                ("Syriac_Contraction" . #\u+070a)
                ("Syriac_Harklean_Obelus" . #\u+070b)
                ("Syriac_Harklean_Metobelus" . #\u+070c)
                ("Syriac_Harklean_Asteriscus" . #\u+070d)
                ("Syriac_Abbreviation_Mark" . #\u+070f)
                ("Syriac_Letter_Alaph" . #\u+0710)
                ("Syriac_Letter_Superscript_Alaph" . #\u+0711)
                ("Syriac_Letter_Beth" . #\u+0712)
                ("Syriac_Letter_Gamal" . #\u+0713)
                ("Syriac_Letter_Gamal_Garshuni" . #\u+0714)
                ("Syriac_Letter_Dalath" . #\u+0715)
                ("Syriac_Letter_Dotless_Dalath_Rish" . #\u+0716)
                ("Syriac_Letter_He" . #\u+0717)
                ("Syriac_Letter_Waw" . #\u+0718)
                ("Syriac_Letter_Zain" . #\u+0719)
                ("Syriac_Letter_Heth" . #\u+071a)
                ("Syriac_Letter_Teth" . #\u+071b)
                ("Syriac_Letter_Teth_Garshuni" . #\u+071c)
                ("Syriac_Letter_Yudh" . #\u+071d)
                ("Syriac_Letter_Yudh_He" . #\u+071e)
                ("Syriac_Letter_Kaph" . #\u+071f)
                ("Syriac_Letter_Lamadh" . #\u+0720)
                ("Syriac_Letter_Mim" . #\u+0721)
                ("Syriac_Letter_Nun" . #\u+0722)
                ("Syriac_Letter_Semkath" . #\u+0723)
                ("Syriac_Letter_Final_Semkath" . #\u+0724)
                ("Syriac_Letter_E" . #\u+0725)
                ("Syriac_Letter_Pe" . #\u+0726)
                ("Syriac_Letter_Reversed_Pe" . #\u+0727)
                ("Syriac_Letter_Sadhe" . #\u+0728)
                ("Syriac_Letter_Qaph" . #\u+0729)
                ("Syriac_Letter_Rish" . #\u+072a)
                ("Syriac_Letter_Shin" . #\u+072b)
                ("Syriac_Letter_Taw" . #\u+072c)
                ("Syriac_Letter_Persian_Bheth" . #\u+072d)
                ("Syriac_Letter_Persian_Ghamal" . #\u+072e)
                ("Syriac_Letter_Persian_Dhalath" . #\u+072f)
                ("Syriac_Pthaha_Above" . #\u+0730)
                ("Syriac_Pthaha_Below" . #\u+0731)
                ("Syriac_Pthaha_Dotted" . #\u+0732)
                ("Syriac_Zqapha_Above" . #\u+0733)
                ("Syriac_Zqapha_Below" . #\u+0734)
                ("Syriac_Zqapha_Dotted" . #\u+0735)
                ("Syriac_Rbasa_Above" . #\u+0736)
                ("Syriac_Rbasa_Below" . #\u+0737)
                ("Syriac_Dotted_Zlama_Horizontal" . #\u+0738)
                ("Syriac_Dotted_Zlama_Angular" . #\u+0739)
                ("Syriac_Hbasa_Above" . #\u+073a)
                ("Syriac_Hbasa_Below" . #\u+073b)
                ("Syriac_Hbasa-Esasa_Dotted" . #\u+073c)
                ("Syriac_Esasa_Above" . #\u+073d)
                ("Syriac_Esasa_Below" . #\u+073e)
                ("Syriac_Rwaha" . #\u+073f)
                ("Syriac_Feminine_Dot" . #\u+0740)
                ("Syriac_Qushshaya" . #\u+0741)
                ("Syriac_Rukkakha" . #\u+0742)
                ("Syriac_Two_Vertical_Dots_Above" . #\u+0743)
                ("Syriac_Two_Vertical_Dots_Below" . #\u+0744)
                ("Syriac_Three_Dots_Above" . #\u+0745)
                ("Syriac_Three_Dots_Below" . #\u+0746)
                ("Syriac_Oblique_Line_Above" . #\u+0747)
                ("Syriac_Oblique_Line_Below" . #\u+0748)
                ("Syriac_Music" . #\u+0749)
                ("Syriac_Barrekh" . #\u+074a)
                ("Syriac_Letter_Sogdian_Zhain" . #\u+074d)
                ("Syriac_Letter_Sogdian_Khaph" . #\u+074e)
                ("Syriac_Letter_Sogdian_Fe" . #\u+074f)
                ("Arabic_Letter_Beh_With_Three_Dots_Horizontally_Below" . #\u+0750)
                ("Arabic_Letter_Beh_With_Dot_Below_And_Three_Dots_Above" . #\u+0751)
                ("Arabic_Letter_Beh_With_Three_Dots_Pointing_Upwards_Below" . #\u+0752)
                ("Arabic_Letter_Beh_With_Three_Dots_Pointing_Upwards_Below_And_Two_Dots_Above" . #\u+0753)
                ("Arabic_Letter_Beh_With_Two_Dots_Below_And_Dot_Above" . #\u+0754)
                ("Arabic_Letter_Beh_With_Inverted_Small_V_Below" . #\u+0755)
                ("Arabic_Letter_Beh_With_Small_V" . #\u+0756)
                ("Arabic_Letter_Hah_With_Two_Dots_Above" . #\u+0757)
                ("Arabic_Letter_Hah_With_Three_Dots_Pointing_Upwards_Below" . #\u+0758)
                ("Arabic_Letter_Dal_With_Two_Dots_Vertically_Below_And_Small_Tah" . #\u+0759)
                ("Arabic_Letter_Dal_With_Inverted_Small_V_Below" . #\u+075a)
                ("Arabic_Letter_Reh_With_Stroke" . #\u+075b)
                ("Arabic_Letter_Seen_With_Four_Dots_Above" . #\u+075c)
                ("Arabic_Letter_Ain_With_Two_Dots_Above" . #\u+075d)
                ("Arabic_Letter_Ain_With_Three_Dots_Pointing_Downwards_Above" . #\u+075e)
                ("Arabic_Letter_Ain_With_Two_Dots_Vertically_Above" . #\u+075f)
                ("Arabic_Letter_Feh_With_Two_Dots_Below" . #\u+0760)
                ("Arabic_Letter_Feh_With_Three_Dots_Pointing_Upwards_Below" . #\u+0761)
                ("Arabic_Letter_Keheh_With_Dot_Above" . #\u+0762)
                ("Arabic_Letter_Keheh_With_Three_Dots_Above" . #\u+0763)
                ("Arabic_Letter_Keheh_With_Three_Dots_Pointing_Upwards_Below" . #\u+0764)
                ("Arabic_Letter_Meem_With_Dot_Above" . #\u+0765)
                ("Arabic_Letter_Meem_With_Dot_Below" . #\u+0766)
                ("Arabic_Letter_Noon_With_Two_Dots_Below" . #\u+0767)
                ("Arabic_Letter_Noon_With_Small_Tah" . #\u+0768)
                ("Arabic_Letter_Noon_With_Small_V" . #\u+0769)
                ("Arabic_Letter_Lam_With_Bar" . #\u+076a)
                ("Arabic_Letter_Reh_With_Two_Dots_Vertically_Above" . #\u+076b)
                ("Arabic_Letter_Reh_With_Hamza_Above" . #\u+076c)
                ("Arabic_Letter_Seen_With_Two_Dots_Vertically_Above" . #\u+076d)
                ("Thaana_Letter_Haa" . #\u+0780)
                ("Thaana_Letter_Shaviyani" . #\u+0781)
                ("Thaana_Letter_Noonu" . #\u+0782)
                ("Thaana_Letter_Raa" . #\u+0783)
                ("Thaana_Letter_Baa" . #\u+0784)
                ("Thaana_Letter_Lhaviyani" . #\u+0785)
                ("Thaana_Letter_Kaafu" . #\u+0786)
                ("Thaana_Letter_Alifu" . #\u+0787)
                ("Thaana_Letter_Vaavu" . #\u+0788)
                ("Thaana_Letter_Meemu" . #\u+0789)
                ("Thaana_Letter_Faafu" . #\u+078a)
                ("Thaana_Letter_Dhaalu" . #\u+078b)
                ("Thaana_Letter_Thaa" . #\u+078c)
                ("Thaana_Letter_Laamu" . #\u+078d)
                ("Thaana_Letter_Gaafu" . #\u+078e)
                ("Thaana_Letter_Gnaviyani" . #\u+078f)
                ("Thaana_Letter_Seenu" . #\u+0790)
                ("Thaana_Letter_Daviyani" . #\u+0791)
                ("Thaana_Letter_Zaviyani" . #\u+0792)
                ("Thaana_Letter_Taviyani" . #\u+0793)
                ("Thaana_Letter_Yaa" . #\u+0794)
                ("Thaana_Letter_Paviyani" . #\u+0795)
                ("Thaana_Letter_Javiyani" . #\u+0796)
                ("Thaana_Letter_Chaviyani" . #\u+0797)
                ("Thaana_Letter_Ttaa" . #\u+0798)
                ("Thaana_Letter_Hhaa" . #\u+0799)
                ("Thaana_Letter_Khaa" . #\u+079a)
                ("Thaana_Letter_Thaalu" . #\u+079b)
                ("Thaana_Letter_Zaa" . #\u+079c)
                ("Thaana_Letter_Sheenu" . #\u+079d)
                ("Thaana_Letter_Saadhu" . #\u+079e)
                ("Thaana_Letter_Daadhu" . #\u+079f)
                ("Thaana_Letter_To" . #\u+07a0)
                ("Thaana_Letter_Zo" . #\u+07a1)
                ("Thaana_Letter_Ainu" . #\u+07a2)
                ("Thaana_Letter_Ghainu" . #\u+07a3)
                ("Thaana_Letter_Qaafu" . #\u+07a4)
                ("Thaana_Letter_Waavu" . #\u+07a5)
                ("Thaana_Abafili" . #\u+07a6)
                ("Thaana_Aabaafili" . #\u+07a7)
                ("Thaana_Ibifili" . #\u+07a8)
                ("Thaana_Eebeefili" . #\u+07a9)
                ("Thaana_Ubufili" . #\u+07aa)
                ("Thaana_Ooboofili" . #\u+07ab)
                ("Thaana_Ebefili" . #\u+07ac)
                ("Thaana_Eybeyfili" . #\u+07ad)
                ("Thaana_Obofili" . #\u+07ae)
                ("Thaana_Oaboafili" . #\u+07af)
                ("Thaana_Sukun" . #\u+07b0)
                ("Thaana_Letter_Naa" . #\u+07b1)
                ("Nko_Digit_Zero" . #\u+07c0)
                ("Nko_Digit_One" . #\u+07c1)
                ("Nko_Digit_Two" . #\u+07c2)
                ("Nko_Digit_Three" . #\u+07c3)
                ("Nko_Digit_Four" . #\u+07c4)
                ("Nko_Digit_Five" . #\u+07c5)
                ("Nko_Digit_Six" . #\u+07c6)
                ("Nko_Digit_Seven" . #\u+07c7)
                ("Nko_Digit_Eight" . #\u+07c8)
                ("Nko_Digit_Nine" . #\u+07c9)
                ("Nko_Letter_A" . #\u+07ca)
                ("Nko_Letter_Ee" . #\u+07cb)
                ("Nko_Letter_I" . #\u+07cc)
                ("Nko_Letter_E" . #\u+07cd)
                ("Nko_Letter_U" . #\u+07ce)
                ("Nko_Letter_Oo" . #\u+07cf)
                ("Nko_Letter_O" . #\u+07d0)
                ("Nko_Letter_Dagbasinna" . #\u+07d1)
                ("Nko_Letter_N" . #\u+07d2)
                ("Nko_Letter_Ba" . #\u+07d3)
                ("Nko_Letter_Pa" . #\u+07d4)
                ("Nko_Letter_Ta" . #\u+07d5)
                ("Nko_Letter_Ja" . #\u+07d6)
                ("Nko_Letter_Cha" . #\u+07d7)
                ("Nko_Letter_Da" . #\u+07d8)
                ("Nko_Letter_Ra" . #\u+07d9)
                ("Nko_Letter_Rra" . #\u+07da)
                ("Nko_Letter_Sa" . #\u+07db)
                ("Nko_Letter_Gba" . #\u+07dc)
                ("Nko_Letter_Fa" . #\u+07dd)
                ("Nko_Letter_Ka" . #\u+07de)
                ("Nko_Letter_La" . #\u+07df)
                ("Nko_Letter_Na_Woloso" . #\u+07e0)
                ("Nko_Letter_Ma" . #\u+07e1)
                ("Nko_Letter_Nya" . #\u+07e2)
                ("Nko_Letter_Na" . #\u+07e3)
                ("Nko_Letter_Ha" . #\u+07e4)
                ("Nko_Letter_Wa" . #\u+07e5)
                ("Nko_Letter_Ya" . #\u+07e6)
                ("Nko_Letter_Nya_Woloso" . #\u+07e7)
                ("Nko_Letter_Jona_Ja" . #\u+07e8)
                ("Nko_Letter_Jona_Cha" . #\u+07e9)
                ("Nko_Letter_Jona_Ra" . #\u+07ea)
                ("Nko_Combining_Short_High_Tone" . #\u+07eb)
                ("Nko_Combining_Short_Low_Tone" . #\u+07ec)
                ("Nko_Combining_Short_Rising_Tone" . #\u+07ed)
                ("Nko_Combining_Long_Descending_Tone" . #\u+07ee)
                ("Nko_Combining_Long_High_Tone" . #\u+07ef)
                ("Nko_Combining_Long_Low_Tone" . #\u+07f0)
                ("Nko_Combining_Long_Rising_Tone" . #\u+07f1)
                ("Nko_Combining_Nasalization_Mark" . #\u+07f2)
                ("Nko_Combining_Double_Dot_Above" . #\u+07f3)
                ("Nko_High_Tone_Apostrophe" . #\u+07f4)
                ("Nko_Low_Tone_Apostrophe" . #\u+07f5)
                ("Nko_Symbol_Oo_Dennen" . #\u+07f6)
                ("Nko_Symbol_Gbakurunen" . #\u+07f7)
                ("Nko_Comma" . #\u+07f8)
                ("Nko_Exclamation_Mark" . #\u+07f9)
                ("Nko_Lajanyalan" . #\u+07fa)
		("Figure_Space" . #\u+2007)
		("Zero_Width_Space" . #\u+200b)
                ("Line_Separator" . #\u+2028)
                ("Paragraph_Separator" . #\u+2029)
                ("Replacement_Character" . #\u+fffd)
                ("Skull_And_Crossbones" . #\u+2620)))
  (destructuring-bind (name . char) pair
    (register-character-name name char)))

(defun need-char-code (char)
  (or (char-code char) (error "undefined charactern ~a" char)))



;;;(NAME-CHAR name)
;;;If name has an entry in the *NAME->CHAR*, return first such entry.
;;;Otherwise, if it consists of one char, return it.
;;;Otherwise, if it consists of two chars, the first of which  is ^,
;;; return %code-char(c xor 64), where c is the uppercased second char.
;;;Otherwise, if it starts with the prefix "u+" or "U+" followed by
;;; hex digits, the number denoted by those hex digits is interpreted as the
;;; unicode code of the character; if this value is less than
;;; CHAR-CODE-LIMIT, CODE-CHAR of that value is returned.
;;;Otherwise, if it consists of octal digits, the number denoted by
;;;  those octal digits is interpreted as per the U+ case above.
;;;Otherwise return NIL.


(defun name-char (name)
  "Given an argument acceptable to STRING, NAME-CHAR returns a character
  whose name is that string, if one exists. Otherwise, NIL is returned."
  (if (characterp name)
    name
    (let* ((name (string name)))
      (let* ((namelen (length name)))
        (declare (fixnum namelen))
        (or (gethash name *name->char*)
            (if (= namelen 1)
              (char name 0)
              (if (and (= namelen 2) (eq (char name 0) #\^))
                (let* ((c1 (char-code (char-upcase (char name 1)))))
                  (if (and (>= c1 64) (< c1 96))
                    (code-char (the fixnum (logxor (the fixnum c1) #x40)))))
                (let* ((n 0)
                       (start 1))
                  (declare (fixnum start))
                  (or
                   (if (and (> namelen 1)
                            (or (eql (char name 0) #\U)
                                (eql (char name 0) #\u))
                            (or (= namelen 2)
                                (progn
                                  (when (eql (char name 1) #\+)
                                    (incf start))
                                  t)))
                     (do* ((i start (1+ i)))
                          ((= i namelen) (if (< n char-code-limit)
                                           (code-char n)))
                       (declare (fixnum i))
                       (let* ((pos (position (char-upcase (char name i))
                                             "0123456789ABCDEF")))
                         (if pos
                           (setq n (logior (ash n 4) pos))
                           (progn
                             (setq n 0)
                             (return))))))
                   (dotimes (i namelen (if (< n char-code-limit)
                                         (code-char n)))
                     (let* ((code (the fixnum (- (the fixnum (char-code (char name i)))
                                                 (char-code #\0)))))
                       (declare (fixnum code))
                       (if (and (>= code 0)
                                (<= code 7))
                         (setq n (logior code (the fixnum (ash n 3))))
                         (return)))))))))))))

(eval-when (:compile-toplevel :load-toplevel :execute)
(defconstant wsp #.(let ((str (make-string 6  :element-type 'base-char)))
                      (set-schar str 0 #\Space)
                      (set-schar str 1 #\^I)
                      (set-schar str 2 #\^L)
                      (set-schar str 3 #\^@)
                      (set-schar str 4 #\^J)
                      (set-schar str 5 (code-char #xa0))
                      str))

(defconstant wsp&cr #.(let ((str (make-string 7 :element-type 'base-char)))
                        (set-schar str 0 #\Space)
                        (set-schar str 1 #\^M)
                        (set-schar str 2 #\^I)
                        (set-schar str 3 #\^L)
                        (set-schar str 4 #\^@)
                        (set-schar str 5 #\^J)
                        (set-schar str 0 #\Space)
                        (set-schar str 6 (code-char #xa0))
                        str))
)

(defun whitespacep (char)
  (eql $cht_wsp (%character-attribute char (rdtab.ttab *readtable*))))
	   
	 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;			Readtables					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Readtable = istructure with data [1] type-table and [2] macro-char-alist
;;; Type-table is a 256 byte ivector with a type byte for each char.
;;; macro-char-alist is a list of (char . defn).  The defn is either a
;;; cons of (#'read-dispatch . macro-char-alist) for
;;; dispatch macros, or it is a function or a symbol to call for simple macros.

(defun readtablep (object) (istruct-typep object 'readtable)) 

(defun readtable-arg (object)
  (if (null object) (setq object *readtable*))
  (unless (istruct-typep object 'readtable)
    (report-bad-arg object 'readtable))
  object)

(eval-when (:compile-toplevel :execute)
  (def-accessors %svref
      token.string
    token.ipos
    token.opos
    token.len
    )

  (defmacro with-token-buffer ((name) &body body &environment env)
    (multiple-value-bind (body decls) (parse-body body env nil)
      `(let* ((,name (vector (%get-token-string 16) 0 0 16 nil)))
        (declare (dynamic-extent ,name))
        (unwind-protect
             (locally ,@decls ,@body)
          (%return-token-string ,name)))))
  )

(defun read-dispatch (stream char)
  (let* ((alistp (typep (rdtab.macros *readtable*) 'list))
         (info (if alistp
                 (cdr (assq char (rdtab.macros *readtable*)))
                 (let* ((code (need-char-code char)))
                   (sparse-vector-ref (rdtab.macros *readtable*) code)))))
    (with-token-buffer (tb)
      (let* ((subchar nil)
             (numarg nil))
        (loop
            (if (digit-char-p (setq subchar (%read-char-no-eof stream)))
                (%add-char-to-token subchar tb)
                (return (setq subchar (char-upcase subchar) 
                              numarg (%token-to-number tb 10)))))
        (let* ((dispfun (if alistp (cdr (assq subchar (cdr info)))
                          (and (consp info) (sparse-vector-ref (cdr info) (need-char-code subchar))))))
   ; <== WAS char
               
                          
          (if dispfun
              (funcall dispfun stream subchar numarg)
              (signal-reader-error stream "Undefined character ~S in a ~S dispatch macro." subchar char)))))))

;;; This -really- gets initialized later in the file
(defvar %standard-readtable%
  (let* ((ttab (make-sparse-vector char-code-limit '(unsigned-byte 8) $cht_cnst))
         (macs (make-sparse-vector char-code-limit t nil))
         (case :upcase))
  (setf (sparse-vector-ref macs (char-code #\#)) (cons #'read-dispatch (make-sparse-vector char-code-limit t nil))) 
    (dotimes (ch (1+ (char-code #\Space)))
      (setf (sparse-vector-ref ttab ch) $cht_wsp))
    (setf (sparse-vector-ref ttab #xa0) $cht_wsp)
    (setf (sparse-vector-ref ttab (char-code #\\)) $cht_sesc)
    (setf (sparse-vector-ref ttab (char-code #\|)) $cht_mesc)
    (setf (sparse-vector-ref ttab (char-code #\#)) $cht_ntmac)
    (setf (sparse-vector-ref ttab (char-code #\Backspace)) $cht_ill)
    (setf (sparse-vector-ref ttab (char-code #\Rubout)) $cht_ill)
    (%istruct 'readtable ttab macs case)))

(defvar %initial-readtable%)
(setq *readtable* %standard-readtable%)
(def-standard-initial-binding *readtable* )
(queue-fixup (setq %initial-readtable% (copy-readtable *readtable*)))

(defun %get-readtable-char (char &optional (readtable *readtable*))
  (setq char (require-type char 'character))
  (let* ((attr (%character-attribute char (rdtab.ttab readtable))))
    (declare (fixnum attr))
    (values attr (if (logbitp $cht_macbit attr)
                     (sparse-vector-ref
                      (rdtab.macros readtable)
                      (need-char-code char))))))

(defun copy-macro-table (table)
  (let*  ((out (copy-sparse-vector table))
          (outtab (sparse-vector-table out)))
    
   (dotimes (i (length outtab) out)
      (let* ((v (svref outtab i)))
        (when v
          (dotimes (j (length v))
            (let* ((datum (svref v j)))
              (when (consp datum)
                (setf (svref v j)
                      (cons (car datum)
                            (copy-macro-table (cdr datum))))))))))))
    


(defun copy-readtable (&optional (from *readtable*) to)
  (setq from (if from (readtable-arg from)  %standard-readtable%))
  (let* ((fttab (rdtab.ttab from)))
    (setq to (if to 
               (readtable-arg to)
               (%istruct 'readtable
                         (copy-sparse-vector fttab)
                         nil (rdtab.case from))))
    (setf (rdtab.macros to) (copy-macro-table (rdtab.macros from)))


    (setf (rdtab.case to) (rdtab.case from))
    to))

(declaim (inline %character-attribute))

(defun %character-attribute (char attrtab)
  (declare (character char)
           (optimize (speed 3) (safety 0)))
  (let* ((code (char-code char)))
    (declare (fixnum code))
    (sparse-vector-ref attrtab code)))

(defun %set-character-attribute (char readtable attr)
  (let* ((code (char-code char))
         (attrtab (rdtab.ttab readtable)))
    (declare (type (mod #x110000) code))
    (setf (sparse-vector-ref attrtab code) attr)))







(defun set-syntax-from-char (to-char from-char &optional to-readtable from-readtable)
  "Causes the syntax of TO-CHAR to be the same as FROM-CHAR in the
  optional readtable (defaults to the current readtable). The
  FROM-TABLE defaults to the standard Lisp readtable when NIL."
  (setq to-char (require-type to-char 'base-char))
  (setq from-char (require-type from-char 'base-char))
  (setq to-readtable (readtable-arg to-readtable))
  (setq from-readtable (readtable-arg (or from-readtable %initial-readtable%)))
  (let* ((from-attr (%character-attribute from-char (rdtab.ttab from-readtable)))
         (from-info (sparse-vector-ref (rdtab.macros from-readtable) (need-char-code from-char))))
    (if (atom from-info)
      (setf (sparse-vector-ref (rdtab.macros to-readtable) (need-char-code to-char)) from-info)
      (setf (sparse-vector-ref (rdtab.macros to-readtable) (need-char-code to-char))
            (cons (car from-info)
                  (copy-macro-table  (cdr from-info)))))
     
    (%set-character-attribute  to-char
                               to-readtable
                               (if (and (= from-attr $cht_cnst)
                                        (member to-char '(#\Newline #\Linefeed #\Page #\Return
                                                          #\Space #\Tab #\Backspace #\Rubout)))
                                 $cht_ill
                                 from-attr)))
  t)

(defun get-macro-character (char &optional readtable)
  "Return the function associated with the specified CHAR which is a macro
  character, or NIL if there is no such function. As a second value, return
  T if CHAR is a macro character which is non-terminating, i.e. which can
  be embedded in a symbol name."
  (setq readtable (readtable-arg readtable))
    
  (let* ((code (need-char-code char))
         (info (sparse-vector-ref (rdtab.macros readtable) code)))
      
             
    (values (if (atom info) info (car info))
            (= (%character-attribute  char (rdtab.ttab readtable)) $cht_ntmac))))

      

(defun set-macro-character (char fn &optional non-terminating-p readtable)
  "Causes CHAR to be a macro character which invokes FUNCTION when seen
   by the reader. The NON-TERMINATINGP flag can be used to make the macro
   character non-terminating, i.e. embeddable in a symbol name."
  (setq char (require-type char 'base-char))
  (setq readtable (readtable-arg readtable))
  (when fn
    (unless (or (symbolp fn) (functionp fn))
      (setq fn (require-type fn '(or symbol function)))))
  (%set-character-attribute char readtable
                            (if (null fn) $cht_cnst (if non-terminating-p $cht_ntmac $cht_tmac)))
  (let* ((code (or (need-char-code char) ))
         (info (sparse-vector-ref (rdtab.macros readtable) code)))
    (if (consp info)
      (setf (car info) fn)
      (setf (sparse-vector-ref (rdtab.macros readtable) code) fn))
    t)) 

(defun readtable-case (readtable)
  (unless (istruct-typep readtable 'readtable)
    (report-bad-arg readtable 'readtable))
  (let* ((case (rdtab.case (readtable-arg readtable))))
    (if (symbolp case)
      case
      (%car (rassoc case (readtable-case-keywords) :test #'eq)))))

(defun %set-readtable-case (readtable case)
  (unless (istruct-typep readtable 'readtable)
    (report-bad-arg readtable 'readtable))
  (check-type case (member :upcase :downcase :preserve :invert))
  (setf (rdtab.case (readtable-arg readtable)) case))
  
(defsetf readtable-case %set-readtable-case)

(defun make-dispatch-macro-character (char &optional non-terminating-p readtable)
  "Cause CHAR to become a dispatching macro character in readtable (which
   defaults to the current readtable). If NON-TERMINATING-P, the char will
   be non-terminating."
  (setq readtable (readtable-arg readtable))
  (setq char (require-type char 'base-char))
  (%set-character-attribute char readtable
                            (if non-terminating-p $cht_ntmac $cht_tmac))
  (setf (sparse-vector-ref (rdtab.macros readtable) (need-char-code char))
        (cons #'read-dispatch (make-sparse-vector char-code-limit t nil)))
  t)

(defun get-dispatch-macro-character (disp-ch sub-ch &optional (readtable *readtable*))
  "Return the macro character function for SUB-CHAR under DISP-CHAR
   or NIL if there is no associated function."
  (setq readtable (readtable-arg (or readtable %initial-readtable%)))
  (setq disp-ch (require-type disp-ch 'base-char))
  (setq sub-ch (char-upcase (require-type sub-ch 'base-char)))
  (unless (digit-char-p sub-ch 10)
    (let* ((code (char-code disp-ch))
           (info (sparse-vector-ref (rdtab.macros readtable) code)))
      (if (atom info)
        (error "~A is not a dispatching macro character in ~s ." disp-ch readtable)
        (let* ((subcode (char-code sub-ch)))
          (sparse-vector-ref (cdr info) subcode))))))

(defun set-dispatch-macro-character (disp-ch sub-ch fn &optional readtable)
  "Cause FUNCTION to be called whenever the reader reads DISP-CHAR
   followed by SUB-CHAR."
  (setq readtable (readtable-arg readtable))
  (setq disp-ch (require-type disp-ch 'base-char))
  (setq sub-ch (char-upcase (require-type sub-ch 'base-char)))
  (when (digit-char-p sub-ch 10)
    (error "subchar can't be a decimal digit - ~a ." sub-ch))
  (let* ((code (char-code disp-ch))
         (info (sparse-vector-ref (rdtab.macros readtable) code)))
    (if (atom info)
      (error "~A is not a dispatching macro character in ~s ." disp-ch readtable)
      (let* ((subcode (char-code sub-ch)))
        (setf (sparse-vector-ref (cdr info) subcode) fn)))))


#+bootstrapping
(defun convert-readtable-macros (readtable)
  (let*  ((alist (rdtab.macros readtable)))
    (when (listp alist)
      (let* ((new (make-sparse-vector char-code-limit t  nil)))
        (dolist (pair alist)
          (destructuring-bind (char . f) pair
            (if (atom f)
              (setf (sparse-vector-ref new (need-char-code char)) f)
              (let* ((sub (make-sparse-vector char-code-limit t nil)))
                (dolist (pair (cdr f))
                  (destructuring-bind (subch . subf) pair
                    (setf (sparse-vector-ref sub (need-char-code subch)) subf)))
                (setf (sparse-vector-ref new (need-char-code char))(cons (car f) sub))))))
      (setf (rdtab.macros readtable) new)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				Reader					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def-standard-initial-binding *read-eval* t "When nil, #. signals an error.")
(def-standard-initial-binding *read-default-float-format* 'single-float)

(def-standard-initial-binding *read-suppress* nil
  "Suppress most interpreting in the reader when T.")

(def-standard-initial-binding *read-base* 10.
  "the radix that Lisp reads numbers in")

(defvar %read-objects% nil)
(defvar %keep-whitespace% nil)




(def-standard-initial-binding %token-strings% (%cons-pool nil))


(defun %return-token-string (token)
  (let* ((str (token.string token))
         (pool %token-strings%))
    (setf (token.string token) nil)
    (without-interrupts
     (setf (pool.data pool)
           (cheap-cons str (pool.data pool))))))

;;;Look for an exact match, else create a simple-string.
(defun %get-token-string (len)
  (declare (fixnum len))
  (without-interrupts
   (do* ((pool %token-strings%)
         (head (cons nil (pool.data pool)))
         (prev head next)
         (next (cdr prev) (cdr next)))
        ((null next)
         (make-string len :element-type 'base-char))
     (declare (dynamic-extent head)
              (list head prev next))
     (let* ((s (car next)))
       (when (= len (length s))
         (rplacd prev (cdr next))
         (setf (pool.data pool) (cdr head))
         (free-cons next)
         (return s))))))

(defun %extend-token-string (token)
  (let* ((old-string (token.string token))
         (old-length (token.len token)))
    (declare (fixnum old-length))
    (let* ((new-length (the fixnum (ash old-length 1)))
           (new-string (%get-token-string new-length)))
      (dotimes (i old-length)
        (setf (%schar new-string i)
              (%schar old-string i)))
      (%return-token-string token)
      (setf (token.string token) new-string
            (token.len token) new-length)
      token)))

(defun %add-char-to-token (char token)
  (let* ((len (token.len token))
         (opos (token.opos token)))
    (declare (fixnum len opos))
    (when (= opos len)
      (%extend-token-string token))
    (setf (token.opos token) (the fixnum (1+ opos))
          (%schar (token.string token) opos) char)))

(defun %string-from-token (token)
  (let* ((opos (token.opos token))
         (ipos (token.ipos token))
         (tstr (token.string token))
         (len (the fixnum (- opos ipos)))
         (string (make-string len :element-type 'base-char)))
    (do* ((k 0 (1+ k))
          (i ipos (1+ i)))
         ((= i opos) string)
      (declare (fixnum i k))
      (setf (%schar string k) (%schar tstr i)))))

(defun %next-token-char (token)
  (let* ((ipos (token.ipos token)))
    (declare (fixnum ipos))
    (when (< ipos (the fixnum (token.opos token)))
      (setf (token.ipos token) (the fixnum (1+ ipos)))
      (%schar (token.string token) ipos))))
      
(defun input-stream-arg (stream)
  (cond ((null stream) *standard-input*)
        ((eq stream t) *terminal-io*)
        ;Otherwise, let ASK complain...
        (t stream)))

(defun %read-char-no-eof (stream)
  (read-char stream))

(defun %next-char-and-attr (stream &optional (attrtab (rdtab.ttab *readtable*)))
  (let* ((ch (read-char stream nil :eof)))
    (if (eq ch :eof)
      (values nil nil)
      (values ch (%character-attribute ch attrtab)))))

(defun %next-non-whitespace-char-and-attr (stream)
  (let* ((attrtab (rdtab.ttab *readtable*)))
    (loop
      (multiple-value-bind (ch attr) (%next-char-and-attr stream attrtab)
        (if (null ch)
          (return (values nil nil))
          (unless (eql attr $cht_wsp)
            (return (values ch attr))))))))

(defun %next-char-and-attr-no-eof (stream &optional (attrtab (rdtab.ttab *readtable*)))
  (let* ((ch (%read-char-no-eof stream)))
    (values ch (%character-attribute ch attrtab))))

(defun %next-non-whitespace-char-and-attr-no-eof (stream)
  (let* ((attrtab (rdtab.ttab *readtable*)))
    (loop
      (multiple-value-bind (ch attr) (%next-char-and-attr-no-eof stream attrtab)
        (declare (fixnum attr))
        (unless (= attr $cht_wsp)
          (return (values ch attr)))))))

;;; "escapes" is a list of escaped character positions, in reverse order
(defun %casify-token (token escapes)
  (let* ((case (readtable-case *readtable*))
         (opos (token.opos token))
         (string (token.string token)))
    (declare (fixnum opos))
    (if (and (null escapes) (eq case :upcase))          ; Most common case, pardon the pun
      ; %strup is faster - boot probs tho
      (dotimes (i opos)
        (setf (%schar string i) (char-upcase (%schar string i))))
      (unless (eq case :preserve)
        (when (eq case :invert)
          (let* ((lower-seen nil)
                 (upper-seen nil))
            (do* ((i (1- opos) (1- i))
                  (esclist escapes)
                  (nextesc (if esclist (pop esclist) -1)))
                 ((< i 0) (if upper-seen (unless lower-seen (setq case :downcase))
                                         (when lower-seen (setq case :upcase))))
              (declare (fixnum i nextesc))
              (if (= nextesc i)
                (setq nextesc (if esclist (pop esclist) -1))
                (let* ((ch (%schar string i)))
                  (if (upper-case-p ch)
                    (setq upper-seen t)
                    (if (lower-case-p ch)
                      (setq lower-seen t))))))))
        (if (eq case :upcase)
          (do* ((i (1- opos) (1- i))
                  (nextesc (if escapes (pop escapes) -1)))
               ((< i 0))
            (declare (fixnum i nextesc))
            (if (= nextesc i)
                (setq nextesc (if escapes (pop escapes) -1))
                (setf (%schar string i) (char-upcase (%schar string i)))))
          (if (eq case :downcase)
            (do* ((i (1- opos) (1- i))
                  (nextesc (if escapes (pop escapes) -1)))
               ((< i 0))
            (declare (fixnum i nextesc))
            (if (= nextesc i)
                (setq nextesc (if escapes (pop escapes) -1))
                (setf (%schar string i) (char-downcase (%schar string i)))))))))))

;;; MCL's reader has historically treated ||:foo as a reference to the
;;; symbol FOO in the package which has the null string as its name.
;;; Some other implementations treat it as a keyword.  This takes an
;;; argument indicating whether or not something was "seen" before the
;;; first colon was read, even if that thing caused no characters to
;;; be added to the token.

(defun %token-package (token colonpos seenbeforecolon stream)
  (declare (ignorable stream))
  (if colonpos
    (if (and (eql colonpos 0) (not seenbeforecolon))
      *keyword-package*
      (let* ((string (token.string token)))
        (or (%find-pkg string colonpos)
            (subseq string 0 colonpos)
            #+nomore
            (signal-reader-error stream "Reference to unknown package ~s." (subseq string 0 colonpos)))))
    *package*))

;;; Returns 4 values: reversed list of escaped character positions,
;;; explicit package (if unescaped ":" or "::") or nil, t iff any
;;; non-dot, non-escaped chars in token, and t if either no explicit
;;; package or "::"

(defun %collect-xtoken (token stream 1stchar)
  (let* ((escapes ())
         (nondots nil)
         (explicit-package *read-suppress*)
         (double-colon t)
         (multi-escaped nil))
    (do* ((attrtab (rdtab.ttab *readtable*))
          (char 1stchar (read-char stream nil :eof )))
         ((eq char :eof))
      (flet ((add-note-escape-pos (char token escapes)
               (push (token.opos token) escapes)
               (%add-char-to-token char token)
               escapes))
        (let* ((attr (%character-attribute char attrtab)))
          (declare (fixnum attr))
          (when (or (= attr $cht_tmac)
                    (= attr $cht_wsp))
            (when (or (not (= attr $cht_wsp)) %keep-whitespace%)
              (unread-char char stream))
            (return ))
          (if (= attr $cht_ill)
              (signal-reader-error stream "Illegal character ~S." char)
              (if (= attr $cht_sesc)
                  (setq nondots t 
                        escapes (add-note-escape-pos (%read-char-no-eof stream) token escapes))
                  (if (= attr $cht_mesc)
                      (progn 
                        (setq nondots t)
                        (loop
                            (multiple-value-bind (nextchar nextattr) (%next-char-and-attr-no-eof stream attrtab)
                              (declare (fixnum nextattr))
                              (if (= nextattr $cht_mesc) 
                                  (return (setq multi-escaped t))
                                  (if (= nextattr $cht_sesc)
                                      (setq escapes (add-note-escape-pos (%read-char-no-eof stream) token escapes))
                            (setq escapes (add-note-escape-pos nextchar token escapes)))))))
                  (let* ((opos (token.opos token)))         ; Add char to token, note 1st colonpos
                    (declare (fixnum opos))
                    (if (and (eq char #\:)       ; (package-delimiter-p char ?)
                             (not explicit-package))
                      (let* ((nextch (%read-char-no-eof stream)))
                        (if (eq nextch #\:)
                          (setq double-colon t)
                          (progn
			    (unread-char nextch stream)
                            (setq double-colon nil)))
                        (%casify-token token escapes)
                        (setq explicit-package (%token-package token opos nondots stream)
                              nondots t
                              escapes nil)
                        (setf (token.opos token) 0))
                      (progn
                        (unless (eq char #\.) (setq nondots t))
                        (%add-char-to-token char token))))))))))
        (values (or escapes multi-escaped) (if *read-suppress* nil explicit-package) nondots double-colon)))
          
(defun %validate-radix (radix)
  (if (and (typep radix 'fixnum)
           (>= (the fixnum radix) 2)
           (<= (the fixnum radix) 36))
    radix
    (progn
      (check-type radix (integer 2 36))
      radix)))

(defun %token-to-number (token radix &optional no-rat)
  (new-numtoken (token.string token) (token.ipos token) (token.opos token) radix no-rat))

;;; If we're allowed to have a single "." in this context, DOT-OK is some distinguished
;;; value that's returned to the caller when exactly one dot is present.
(defun %parse-token (stream firstchar dot-ok)
  (with-token-buffer (tb)
    (multiple-value-bind (escapes explicit-package nondots double-colon) (%collect-xtoken tb stream firstchar)
      (unless *read-suppress* 
        (let* ((string (token.string tb))
               (len (token.opos tb)))
          (declare (fixnum len))
          (if (not nondots)
            (if (= len 1)
              (or dot-ok
                  (signal-reader-error stream "Dot context error in ~s." (%string-from-token tb)))
              (signal-reader-error stream "Illegal symbol syntax in ~s." (%string-from-token tb)))
            ;; Something other than a buffer full of dots.  Thank god.
            (let* ((num (if (null escapes)
                            (handler-case
                                (%token-to-number tb (%validate-radix *read-base*))
                              (arithmetic-error (c)
                                (error 'impossible-number
                                       :stream stream
                                       :token (%string-from-token tb)
                                       :condition c))))))
              (if (and num (not explicit-package))
                num
                (if (and (zerop len) (null escapes))
                  (%err-disp $XBADSYM)
                  (progn                  ; Muck with readtable case of extended token.
                    (%casify-token tb (unless (atom escapes) escapes))
                    (let* ((pkg (if explicit-package (pkg-arg explicit-package) *package*)))
                      (if (or double-colon (eq pkg *keyword-package*))
                        (with-package-lock (pkg)
			  (multiple-value-bind (symbol access internal-offset external-offset)
			      (%find-symbol string len pkg)
			    (if access
			      symbol
			      (%add-symbol (%string-from-token tb) pkg internal-offset external-offset))))
                        (multiple-value-bind (found symbol) (%get-htab-symbol string len (pkg.etab pkg))
                          (if found
                            symbol
                            (let* ((token (%string-from-token tb))
                                   (symbol (find-symbol token pkg)))
                              (with-simple-restart (continue
                                                    "~:[Create and use the internal symbol ~a::~a~;Use the internal symbol ~:*~s~]"
                                                    symbol (package-name pkg) token)
                                (%err-disp $XNOESYM token pkg))
                              (or symbol (intern token pkg)))))))))))))))))
                    
#|
(defun %parse-token-test (string &key dot-ok (case (readtable-case *readtable*)))
  (let* ((stream (make-string-input-stream string))
         (oldcase (readtable-case *readtable*)))
    (unwind-protect
      (progn
        (setf (readtable-case *readtable*) case) 
        (%parse-token stream (read-char stream t) dot-ok))
      (setf (readtable-case *readtable*) oldcase))))

(%parse-token-test "ABC")
(%parse-token-test "TRAPS::_DEBUGGER")
(%parse-token-test "3.14159")
(ignore-errors (%parse-token-test "BAD-PACKAGE:WORSE-SYMBOL"))
(ignore-errors (%parse-token-test "CCL::"))
(%parse-token-test "TRAPS::_debugger" :case :preserve)
(%parse-token-test ":foo")
|#

;;; firstchar must not be whitespace.
;;; People who think that there's so much overhead in all of
;;; this (multiple-value-list, etc.) should probably consider
;;; rewriting those parts of the CLOS and I/O code that make
;;; using things like READ-CHAR impractical...

;;; mb: the reason multiple-value-list is used here is that we need to distunguish between the
;;; recursive parse call returning (values nil) and (values).
(defun %parse-expression (stream firstchar dot-ok)
  (let* ((readtable *readtable*)
         (attrtab (rdtab.ttab readtable))
         (attr (%character-attribute firstchar attrtab))
         (start-pos (stream-position stream)))
    (declare (fixnum attr))
    (when (eql attr $cht_ill)
      (signal-reader-error stream "Illegal character ~S." firstchar))
    (let* ((vals (multiple-value-list 
                     (if (not (logbitp $cht_macbit attr))
                       (%parse-token stream firstchar dot-ok)
                       (let* ((def (sparse-vector-ref (rdtab.macros readtable) (need-char-code firstchar ))))
                         (cond ((null def))
                               ((atom def)
                                (funcall def stream firstchar))
                               #+no     ; include if %initial-readtable% broken (see above)
                               ((and (consp (car def))
                                     (eq (caar def) 'function))
                                (funcall (cadar def) stream firstchar))
                               ((functionp (car def))
                                (funcall (car def) stream firstchar))
                               (t (error "Bogus default dispatch fn: ~S" (car def)) nil))))))
           (end-pos (and start-pos (stream-position stream))))
      (declare (dynamic-extent vals)
               (list vals))
      (if (null vals)
        (values nil nil)
        (destructuring-bind (form &optional nested-source-notes)
                            vals
          ;; Can't really trust random reader macros to return source notes...
          (unless (and (consp nested-source-notes)
                       (source-note-p (car nested-source-notes)))
            (setq nested-source-notes nil))
          (values form
                  t
                  (and start-pos
                       (record-source-note :form form
                                           :stream stream
                                           :start-pos (1- start-pos)
                                           :end-pos end-pos
                                           :subform-notes nested-source-notes))))))))

#|
(defun %parse-expression-test (string)
  (let* ((stream (make-string-input-stream string)))
    (%parse-expression stream (read-char stream t) nil)))

(%parse-expression-test ";hello")
(%parse-expression-test "#'cdr")
(%parse-expression-test "#+foo 1 2")

|#

(defun %read-list-expression (stream dot-ok &optional (termch #\)))
  (loop
      (let* ((firstch (%next-non-whitespace-char-and-attr-no-eof stream)))
        (if (eq firstch termch)
            (return (values nil nil nil))
            (multiple-value-bind (val val-p source-info)
                (%parse-expression stream firstch dot-ok)
              (if val-p
                  (return (values val t source-info))))))))

(defun read-list (stream &optional nodots (termch #\)))
  (let* ((dot-ok (cons nil nil))
         (head (cons nil nil))
         (tail head)
         (source-note-list nil))
    (declare (dynamic-extent dot-ok head)
             (list head tail))
    (if nodots (setq dot-ok nil))
    (multiple-value-bind (firstform firstform-p firstform-source-note)
        (%read-list-expression stream dot-ok termch)
      (when firstform-source-note
        (push firstform-source-note source-note-list))
      (when firstform-p
        (if (and dot-ok (eq firstform dot-ok))       ; just read a dot
            (signal-reader-error stream "Dot context error."))
        (rplacd tail (setq tail (cons firstform nil)))
        (loop
          (multiple-value-bind (nextform nextform-p nextform-source-note)
              (%read-list-expression stream dot-ok termch)
            (when nextform-source-note
              (push nextform-source-note source-note-list))
            (if (not nextform-p) (return))
            (if (and dot-ok (eq nextform dot-ok))    ; just read a dot
                (if (multiple-value-bind (lastform lastform-p lastform-source-note)
                        (%read-list-expression stream nil termch)
                      (when lastform-source-note
                        (push lastform-source-note source-note-list))
                      (and lastform-p
                           (progn (rplacd tail lastform)
                                  (not (nth-value 1 (%read-list-expression stream nil termch))))))
                    (return)
                    (signal-reader-error stream "Dot context error."))
              (rplacd tail (setq tail (cons nextform nil))))))))
    (values (cdr head) source-note-list)))

#|
(defun read-list-test (string &optional nodots)
  (read-list (make-string-input-stream string) nodots))

(read-list-test ")")
(read-list-test "a b c)" t)
(read-list-test "a b ;hello
c)" t)

|#

(set-macro-character
 #\(
 #'(lambda (stream ignore)
     (declare (ignore ignore))
     (read-list stream nil #\))))

(set-macro-character 
 #\' 
 (nfunction |'-reader| 
            (lambda (stream ignore)
              (declare (ignore ignore))
              (multiple-value-bind (form source-note)
                  (read-internal stream t nil t)
                (values `(quote ,form) (and source-note (list source-note)))))))

(defparameter *alternate-line-terminator*
    #+darwin-target #\Return
    #-darwin-target nil
    "This variable is currently only used by the standard reader macro
function for #\; (single-line comments); that function reads successive
characters until EOF, a #\NewLine is read, or a character EQL to the value
of *alternate-line-terminator* is read. In Clozure CL for Darwin, the value
of this variable is initially #\Return ; in Clozure CL for other OSes, it's
initially NIL.")
	     
(set-macro-character
 #\;
 (nfunction |;-reader|
            (lambda (stream ignore)
              (declare (ignore ignore))
              (let* ((ch nil))
                (loop 
                    (if (or (eq :eof (setq ch (read-char stream nil :eof)))
                            (eq ch #\NewLine)
			    (eq ch *alternate-line-terminator*))
                        (return (values))))))))

(defun read-string (stream termch)
  (with-token-buffer (tb)
    (do* ((attrs (rdtab.ttab *readtable*))
          (ch (%read-char-no-eof stream)
              (%read-char-no-eof stream)))
         ((eq ch termch)
          (%string-from-token tb))
      (if (= (the fixnum (%character-attribute ch attrs)) $CHT_SESC)
          (setq ch (%read-char-no-eof stream)))
      (%add-char-to-token ch tb))))

(set-macro-character #\" #'read-string)

(defparameter *ignore-extra-close-parenthesis* nil)

(set-macro-character 
 #\)
 #'(lambda (stream ch)
     (let* ((pos (if (typep stream 'file-stream)
                     (file-position stream))))
       (if *ignore-extra-close-parenthesis*
           (warn "Ignoring extra \"~c\" ~@[near position ~d~] on ~s ." ch pos stream)
           (signal-reader-error stream "Unmatched ')' ~@[near position ~d~]." pos)))))




(eval-when (:load-toplevel)             ; But not when mousing around!
  (make-dispatch-macro-character #\# t))


(set-dispatch-macro-character
 #\#
 #\(
 (nfunction 
  |#(-reader| 
  (lambda (stream subchar numarg)
    (declare (ignore subchar))
    (if (or (null numarg) *read-suppress*)
      (multiple-value-bind (lst notes) (read-list stream t)
        (let* ((len (length lst))
               (vec (make-array len)))
          (declare (list lst) (fixnum len) (simple-vector vec))
          (dotimes (i len)
            (setf (svref vec i) (pop lst)))
          (values vec notes)))
      (locally
          (declare (fixnum numarg))
        (do* ((vec (make-array numarg))
              (notes ())
              (lastform)
              (i 0 (1+ i)))
            ((multiple-value-bind (form form-p source-info)
                 (%read-list-expression stream nil)
               (if form-p
                 (progn
                   (setq lastform form)
                   (when source-info (push source-info notes)))
                 (unless (= i numarg)
                   (if (= i 0) 
                     (%err-disp $XARROOB -1 vec)
                     (do* ((j i (1+ j)))
                         ((= j numarg))
                       (declare (fixnum j))
                       (setf (svref vec j) lastform)))))
               (not form-p))
               (values vec notes))
          (declare (fixnum i))
          (setf (svref vec i) lastform)))))))

(defun %read-rational (stream subchar radix)
  (declare (ignore subchar))
  (with-token-buffer (tb)
      (multiple-value-bind (escapes xpackage)
                           (%collect-xtoken tb stream (%next-non-whitespace-char-and-attr-no-eof stream))
        (unless *read-suppress*
          (let* ((val (%token-to-number tb radix)))
          (or (and (null escapes)
                   (null xpackage)
                   (typep val 'rational)
                   val)
              (%err-disp $xbadnum)))))))

(defun require-numarg (subchar numarg)
  (or numarg *read-suppress*
      (error "Numeric argument required for #~A reader macro ." subchar)))

(defun require-no-numarg (subchar numarg)
  (if (and numarg (not *read-suppress*))
      (error "Spurious numeric argument in #~D~A reader macro ." numarg subchar)))

(defun read-eval (stream subchar numarg)
  (require-no-numarg subchar numarg)
  (if *read-eval*
    (let* ((exp (%read-list-expression stream nil)))
      (unless *read-suppress*
        (eval exp)))
    (signal-reader-error stream "#. reader macro invoked when ~S is false ."
                         '*read-eval*)))

(set-dispatch-macro-character 
 #\# 
 #\C
 #'(lambda (stream char arg)
     (require-no-numarg char arg )
     (multiple-value-bind (form note) (read-internal stream t nil t)
       (values (unless *read-suppress* (apply #'complex form)) (and note (list note))))))

(set-dispatch-macro-character 
 #\#
 #\.
 #'read-eval)

;;; Read a valid, non-numeric token string from stream; *READ-SUPPRESS*
;;; is known to be false.
(defun read-symbol-token (stream)
  (multiple-value-bind (firstch attr) (%next-non-whitespace-char-and-attr-no-eof stream)
    (declare (fixnum attr))
    (with-token-buffer (tb)
      (if (or (= attr $CHT_ILL)
              (logbitp $cht_macbit attr)
              (multiple-value-bind (escapes explicit-package nondots) (%collect-xtoken tb stream firstch)
                (declare (ignore nondots))
                (%casify-token tb (unless (atom escapes) escapes))
                (or explicit-package
                    (and (not escapes)
                         (%token-to-number tb (%validate-radix *read-base*))))))
        (%err-disp $XBADSYM)
        (%string-from-token tb)))))

(set-dispatch-macro-character
 #\#
 #\:
 #'(lambda (stream subchar numarg)
     (require-no-numarg subchar numarg)
     (if (not *read-suppress*)
       (make-symbol (read-symbol-token stream))
       (progn
         (%read-list-expression stream nil)
         nil))))

(set-dispatch-macro-character 
 #\# 
 #\b
 #'(lambda (stream subchar numarg)
     (require-no-numarg subchar numarg)
     (%read-rational stream subchar 2)))

(set-dispatch-macro-character 
 #\# 
 #\o
 #'(lambda (stream subchar numarg)
     (require-no-numarg subchar numarg)
     (%read-rational stream subchar 8)))

(set-dispatch-macro-character 
 #\# 
 #\x
 #'(lambda (stream subchar numarg)
     (require-no-numarg subchar numarg)
     (%read-rational stream subchar 16)))

(set-dispatch-macro-character 
 #\# 
 #\r
 #'(lambda (stream subchar numarg)
     (unless *read-suppress*
       (require-numarg subchar numarg)
       (check-type numarg (integer 2 36)))
     (%read-rational stream subchar numarg)))

(set-dispatch-macro-character
 #\#
 #\'
 (nfunction |#'-reader| 
            (lambda (stream subchar numarg)
              (require-no-numarg subchar numarg)
              (multiple-value-bind (form note) (read-internal stream t nil t)
                (values `(function ,form) (and note (list note)))))))

(set-dispatch-macro-character
 #\#
 #\|
 (nfunction |#\|-reader| 
            (lambda (stream subchar numarg)
              (require-no-numarg subchar numarg)
              (do* ((lastch nil ch)
                    (ch )
                    (level 1))
                   ((= level 0) (values))
                (declare (fixnum level))
                (setq ch (%read-char-no-eof stream))
                (if (and (eq ch #\|)
                         (eq lastch #\#))
                    (progn 
                      (setq ch nil)
                      (incf level))
                    (if (and (eq ch #\#)
                             (eq lastch #\|))
                        (progn 
                          (setq ch nil)
                          (decf level))))))))

(defun %unreadable (stream description)
  (signal-reader-error stream "~S encountered." description))

(set-dispatch-macro-character
 #\#
 #\<
 #'(lambda (stream &rest ignore)
     (declare (ignore ignore))
     (%unreadable stream "#<")))

(dolist (ch '(#\null #\tab #\linefeed #\page #\return #\space))
  (set-dispatch-macro-character
   #\#
   ch
   #'(lambda (stream &rest ignore)
       (declare (ignore ignore))
       (%unreadable stream "#<whitespace>"))))

(set-dispatch-macro-character
 #\#
 #\)
 #'(lambda (stream &rest ignore)
     (declare (ignore ignore))
     (%unreadable stream "#)")))

(set-dispatch-macro-character
 #\#
 #\\
 #'(lambda (stream subchar numarg)
     (require-no-numarg subchar numarg)
     (with-token-buffer (tb)
       (%collect-xtoken tb stream #\\)
       (unless *read-suppress*
         (let* ((str (%string-from-token tb)))
           (or (name-char str)
               (error "Unknown character name - \"~a\" ." str)))))))


     
;;;Since some built-in read macros used to use internal reader entry points
;;;for efficiency, we couldn't reliably offer a protocol for stream-dependent
;;;recursive reading.  So recursive reads always get done via tyi's, and streams
;;;only get to intercept toplevel reads.
(defun read (&optional stream (eof-error-p t) eof-value recursive-p)
  (declare (resident))
  ;; just return the first value of read-internal
  (values (read-internal stream eof-error-p eof-value recursive-p)))

(defun read-internal (stream eof-error-p eof-value recursive-p)
  (setq stream (input-stream-arg stream))
  (if recursive-p
    (%read-form stream (if eof-error-p 0) nil)
    (let ((%read-objects% nil) (%keep-whitespace% nil))
      (%read-form stream (if eof-error-p 0) eof-value))))

(defun read-preserving-whitespace (&optional stream (eof-error-p t) eof-value recursive-p)
  "Read from STREAM and return the value read, preserving any whitespace
   that followed the object."
  (setq stream (input-stream-arg stream))
  (values
    (if recursive-p
      (%read-form stream 0 nil)
      (let ((%read-objects% nil) (%keep-whitespace% t))
        (%read-form stream (if eof-error-p 0) eof-value)))))


(defun read-delimited-list (char &optional stream recursive-p)
  "Read Lisp values from INPUT-STREAM until the next character after a
   value's representation is CHAR, and return the objects as a list."
  (setq char (require-type char 'character))
  (setq stream (input-stream-arg stream))
  (values
   (let ((%keep-whitespace% nil))
     (if recursive-p
       (%read-form stream char nil)
       (let ((%read-objects% nil))
         (%read-form stream char nil))))))

(defun read-conditional (stream subchar int)
  (declare (ignore int))
  (cond ((eq subchar (read-feature stream))
         (multiple-value-bind (form note) (read-internal stream t nil t)
           (values form (and note (list note)))))
        (t (let* ((*read-suppress* t))
             (read stream t nil t)
             (values)))))

(defun read-feature (stream)
  (let* ((f (let* ((*package* *keyword-package*))
              (read stream t nil t))))
    (labels ((eval-feature (form)
               (cond ((atom form) 
                      (member form *features*))
                     ((eq (car form) :not) 
                      (not (eval-feature (cadr form))))
                     ((eq (car form) :and) 
                      (dolist (subform (cdr form) t)
                        (unless (eval-feature subform) (return))))
                     ((eq (car form) :or) 
                      (dolist (subform (cdr form) nil)
                        (when (eval-feature subform) (return t))))
                     (t (%err-disp $XRDFEATURE form)))))
      (if (eval-feature f) #\+ #\-))))

(set-dispatch-macro-character #\# #\+ #'read-conditional)
(set-dispatch-macro-character #\# #\- #'read-conditional)

(defun %read-form (stream arg eof-val)
  "Read a lisp form from STREAM

arg=0 : read form, error if eof
arg=nil : read form, eof-val if eof.
arg=char : read delimited list"
  (declare (resident))
  (check-type *readtable* readtable)
  (check-type *package* package)
  (if (and arg (not (eq arg 0)))
      (read-list stream nil arg)
      (loop
        (let* ((ch (%next-non-whitespace-char-and-attr stream)))
          (if (null ch)
            (if arg 
              (error 'end-of-file :stream stream)
              (return eof-val))
            (multiple-value-bind (form form-p source-note)
                (%parse-expression stream ch nil)
              (when form-p
                (return
                 (values (if *read-suppress* nil form)
                         source-note)))))))))

;;;Until load backquote...
(set-macro-character #\`
  #'(lambda (stream char) (declare (ignore stream)) (%err-disp $xbadmac char)))
(set-macro-character #\, (get-macro-character #\`))



(set-dispatch-macro-character #\# #\P
 (qlfun |#P-reader| (stream char flags &aux (invalid-string "Invalid flags (~S) for pathname ~S"))
   (declare (ignore char))
   (when (null flags) (setq flags 0))
   (unless (memq flags '(0 1 2 3 4))
     (unless *read-suppress* (report-bad-arg flags '(integer 0 4))))
   (multiple-value-bind (path note) (read-internal stream t nil t)
     (unless *read-suppress*
       (unless (stringp path) (report-bad-arg path 'string))
       (setq path (pathname path))
       (when (%ilogbitp 0 flags)
         (when (%pathname-type path) (error invalid-string flags path))
         (setf (%pathname-type path) :unspecific))
       (when (%ilogbitp 1 flags)
         (when (%pathname-name path) (error invalid-string flags path))
         (setf (%pathname-name path) ""))
       (values path (and note (list note)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defstruct (source-note (:conc-name "SOURCE-NOTE.") (:constructor %make-source-note))
  ;; For an inner source form, the source-note of the outer source form.
  ;; For outer source note, octets
  source
  filename
  ;; start and end file positions (NOT characters positions)
  file-range)

(defun make-source-note (&key filename start-pos end-pos source)
  (%make-source-note :filename filename
                     :file-range (encode-file-range start-pos end-pos)
                     :source source))

(defmethod print-object ((sn source-note) stream)
  (print-unreadable-object (sn stream :type t :identity nil)
    (print-source-note sn stream)))

(defun print-source-note (sn stream)
  (let* ((file (source-note-filename sn))
         (text (ignore-errors (source-note-text sn))))
    (when file
      ;; Should fix this when record the name.
      (when (eq (pathname-version file) :newest)
	(setq file (namestring (make-pathname :version nil :defaults file)))))
    (when text
      (setq text (string-sans-most-whitespace text 121))
      (when (> (length text) 120)
        (setq text (concatenate 'string (subseq text 0 120) "..."))))
    (if file
      (format stream "~s:~s-~s ~s" file
	      (source-note-start-pos sn) (source-note-end-pos sn)
	      text)
      (format stream "Interactive ~s" text))))

(defun source-note-filename (source)
  (if (source-note-p source)
    (source-note.filename source)
    ;;  else null or a pathname, as in record-source-file
    source))

(defun (setf source-note-filename) (filename source-note)
  (setf (source-note.filename (require-type source-note 'source-note)) filename))

;; Since source notes are optional, it simplifies a lot of code
;; to have these accessors allow NIL.

(defun source-note-source (source-note)
  (when source-note
    (loop for note = (require-type source-note 'source-note) then source
       for source = (source-note.source note)
       unless (source-note-p source)
       return (if (eq source-note note)
                  source
                  ;; Cache the toplevel note, don't really need the intermediate pointers
                  (setf (source-note.source source-note) note)))))

(defun source-note-file-range (source-note)
  (when source-note
    (source-note.file-range (require-type source-note 'source-note))))

(defun source-note-start-pos (source-note)
  (let ((range (source-note-file-range source-note)))
    (when range
      (if (consp range) (car range) (ash range -14)))))

(defun source-note-end-pos (source-note)
  (let ((range (source-note-file-range source-note)))
    (when range
      (if (consp range) (cdr range) (+ (ash range -14) (logand range #x3FFF))))))

(defun encode-file-range (start-pos end-pos)
  (let ((len (- end-pos start-pos)))
    (if (< len (ash 1 14))
      (+ (ash start-pos 14) len)
      (cons start-pos end-pos))))

(defun decode-file-range (range)
  (when range
    (if (consp range)
      (values (car range) (cdr range))
      (let ((start-pos (ash range -14)))
        (values start-pos (+ start-pos (logand range #x3FFF)))))))

(defun source-note-text (source-note &optional start end)
  (when source-note
    (let* ((source (source-note-source source-note))
	   (start-pos (source-note-start-pos source-note))
	   (end-pos (source-note-end-pos source-note))
	   (start (or start start-pos))
	   (end (or end end-pos)))
      (etypecase source
	(source-note
         (assert (<= (source-note-start-pos source) start end (source-note-end-pos source)))
         (source-note-text source start end))
	((simple-array (unsigned-byte 8) (*))
         (decf start start-pos)
         (decf end start-pos)
         (assert (and (<= 0 start end (length source))))
         (decode-string-from-octets source :start start :end end :external-format :utf-8))
	(null source)))))

(defun source-note-toplevel-note (source-note)
  (when source-note
    (loop for source = (source-note-source source-note)
          while (source-note-p source)
          do (setq source-note source))
    source-note))

(defvar *recording-source-streams* ())

(defun record-source-note (&key form stream start-pos end-pos subform-notes)
  (let ((recording (assq stream *recording-source-streams*)))
    (when (and recording (not *read-suppress*))
      (destructuring-bind (map file-name stream-offset) (cdr recording)
        ;; Don't record notes for entries with multiple sources, which can happen for atoms:
        ;;   if we can't tell which instance we mean, then we don't have useful source info.
        (let ((note (when (eq (gethash form map 'first) 'first)
                      (make-source-note :filename file-name
                                        :start-pos (+ stream-offset start-pos)
                                        :end-pos (+ stream-offset end-pos)))))
          (setf (gethash form map) note)
          (when note
            (loop for subnote in subform-notes
               do (when (source-note.source subnote) (error "Subnote ~s already owned?" subnote))
               do (setf (source-note.source subnote) note)))
          note)))))

(defun read-recording-source (stream &key eofval file-name start-offset map save-source-text)
  "Read a top-level form, perhaps recording source locations.
If MAP is NIL, just reads a form as if by READ.
If MAP is non-NIL, returns a second value of a source-note object describing the form.
In addition, if MAP is a hash table, it gets filled with source-note's for all
non-atomic nested subforms."
  (when (null start-offset) (setq start-offset 0))
  (typecase map
    (null (values (read-internal stream nil eofval nil) nil))
    (hash-table
       (let* ((stream (recording-input-stream stream))
	      (recording (list stream map file-name start-offset))
              (*recording-source-streams* (cons recording *recording-source-streams*)))
         (declare (dynamic-extent recording *recording-source-streams*))
         (multiple-value-bind (form source-note) (read-internal stream nil eofval nil)
           (when (and source-note (not (eq form eofval)))
             (assert (null (source-note.source source-note)))
             (when save-source-text
               (setf (source-note.source source-note)
                     (fetch-octets-from-stream stream
                                               (- (source-note-start-pos source-note)
                                                  start-offset)
                                               (- (source-note-end-pos source-note)
                                                  start-offset)))))
           (values form source-note))))
    (T ;; not clear if this is ever useful
       (let* ((start-pos (stream-position stream))
              (form (read-internal stream nil eofval nil))
              (end-pos (and start-pos (neq form eofval) (stream-position stream)))
              (source-note (and end-pos
                                (make-source-note :filename file-name
                                                  :start-pos (+ start-offset start-pos)
                                                  :end-pos (+ start-offset end-pos)))))
         (when (and source-note save-source-text)
           (setf (source-note.source source-note) (fetch-octets-from-stream stream start-pos end-pos)))
         (values form source-note)))))

(defmethod fetch-octets-from-stream ((stream input-stream) start-offset end-offset)
  ;; We basically want to read the bytes between two positions, but there is no
  ;; direct interface for that.  So we let the stream decode and then we re-encode.
  ;; (Just as well, since otherwise we'd have to remember the file's encoding).
  (declare (fixnum start-offset))
  (when (< start-offset end-offset)
    (let* ((cur-pos (stream-position stream))
           (noctets (- end-offset start-offset))
           (vec (make-array noctets :element-type '(unsigned-byte 8)))
           (index 0)
           (crlfp (eq :crlf
                      (cdr (assoc (external-format-line-termination
                                   (stream-external-format stream))
                                  *canonical-line-termination-conventions*)))))
      (declare (type fixnum end-offset noctets index)
               (type (simple-array (unsigned-byte 8) (*)) vec))
      (macrolet ((out (code)
                   `(progn
                      (setf (aref vec index) ,code)
                      (when (eql (incf index) noctets) (return)))))
        (stream-position stream start-offset)
        (loop
          (let ((code (char-code (read-char stream))))
            (declare (fixnum code))
            (cond ((< code #x80)
                   (when (and crlfp (= code (char-code #\NewLine)))
                     (out (char-code #\Return)))
                   (out code))
                  ((< code #x800)
                   (out (logior #xc0 (ldb (byte 5 6) code)))
                   (out (logior #x80 (ldb (byte 6 0) code))))
                  ((< code #x10000)
                   (out (logior #xe0 (ldb (byte 4 12) code)))
                   (out (logior #x80 (ldb (byte 6 6) code)))
                   (out (logior #x80 (ldb (byte 6 0) code))))
                  (t
                   (out (logior #xf0 (ldb (byte 3 18) code)))
                   (out (logior #xe0 (ldb (byte 6 12) code)))
                   (out (logior #x80 (ldb (byte 6 6) code)))
                   (out (logior #x80 (ldb (byte 6 0) code))))))))
      (stream-position stream cur-pos)
      vec)))

(defun ensure-source-note-text (source-note &key (if-does-not-exist nil))
  "Fetch source text from file if don't have it"
  (setq if-does-not-exist (require-type if-does-not-exist '(member :error nil)))
  (if source-note
    (let ((source (source-note-source source-note))
	  (filename (source-note-filename source-note)))
      (etypecase source
	(null
	 (if filename
	   (with-open-file (stream filename :if-does-not-exist if-does-not-exist)
	     (when stream
	       (let ((start (source-note-start-pos source-note))
		     (end (source-note-end-pos source-note))
		     (len (file-length stream)))
		 (if (<= end len)
		     (setf (source-note.source source-note)
			   (fetch-octets-from-stream stream start end))
		     (when if-does-not-exist
		       (error 'simple-file-error :pathname filename
			      :error-type "File ~s changed since source info recorded"))))))
	   (when if-does-not-exist
	     (error "Missing source text in internative source note"))))
	(source-note
	 (ensure-source-note-text source))
	((simple-array (unsigned-byte 8) (*))
	 source)))
    (when if-does-not-exist
      (error "Missing source note"))))


;; This can be called explicitly by macros that do more complicated transforms
(defun note-source-transformation (original new)
  (nx-note-source-transformation original new))


;;; Wrapper stream for recording source of non-random-access streams.
(defclass recording-character-input-stream (fundamental-stream character-input-stream)
  ((input-stream :initarg :input-stream)
   (string :initform (make-array 1024 :element-type 'character :fill-pointer 0 :adjustable t))))

(defmethod stream-element-type ((s recording-character-input-stream))
  (with-slots (input-stream) s
    (stream-element-type input-stream)))

(defmethod stream-read-char ((s recording-character-input-stream))
  (with-slots (input-stream string) s
    (let ((char (stream-read-char input-stream)))
      (when (and char (neq char :eof))
	(vector-push-extend char string))
      char)))

(defmethod stream-read-char-no-hang ((s recording-character-input-stream))
  (with-slots (input-stream string) s
    (let ((char (stream-read-char-no-hang input-stream)))
      (when (and char (neq char :eof))
	(vector-push-extend char string))
      char)))

(defmethod stream-peek-char ((s recording-character-input-stream))
  (with-slots (input-stream) s
    (stream-peek-char input-stream)))

(defmethod stream-listen ((s recording-character-input-stream))
  (with-slots (input-stream) s
    (stream-listen input-stream)))

(defmethod stream-read-line ((s recording-character-input-stream))
  (generic-read-line s))

(defmethod stream-read-list ((s recording-character-input-stream) list count)
  (generic-character-read-list s list count))

(defmethod stream-read-vector ((s recording-character-input-stream) vector start end)
  (generic-character-read-vector s vector start end))

(defmethod stream-unread-char ((s recording-character-input-stream) char)
  (with-slots (input-stream string) s
    (vector-pop string)    ;; Error if no characters read since last reset.
    (stream-unread-char input-stream char)))

(defmethod stream-eofp ((s recording-character-input-stream))
  (with-slots (input-stream) s
    (stream-eofp input-stream)))

(defmethod stream-clear-input ((s recording-character-input-stream))
  (with-slots (input-stream) s
    (stream-clear-input input-stream)))

(defmethod stream-position ((s recording-character-input-stream) &optional newpos)
  (with-slots (string) s
    (unless newpos
      (fill-pointer string))))

(defun recording-input-stream (stream)
  (let ((pos (stream-position stream)))
    (if (and pos (stream-position stream pos))
      stream
      (make-instance 'recording-character-input-stream :input-stream stream))))

(defmethod fetch-octets-from-stream ((s recording-character-input-stream) start-offset end-offset)
  (declare (fixnum start-offset end-offset))
  (with-slots (string) s
    (when (< start-offset end-offset)
      (let* ((sstring (array-data-and-offset string))
	     (noctets (loop for i fixnum from start-offset below end-offset
			 as code fixnum = (%char-code (%schar sstring i))
			 sum (cond ((< code #x80) 1)
				   ((< code #x800) 2)
				   ((< code #x10000) 3)
				   (t 4))
			 of-type fixnum))
	     (vec (make-array noctets :element-type '(unsigned-byte 8)))
	     (index 0))
	(declare (type fixnum noctets index)
		 (type simple-base-string sstring)
		 (type (simple-array (unsigned-byte 8) (*)) vec))
	(macrolet ((out (octet) `(progn
				   (setf (aref vec index) ,octet)
				   (incf index))))
	  (loop for i fixnum from start-offset below end-offset
	     as code fixnum = (%char-code (%schar sstring i))
	     do (cond ((< code #x80)
		       (out code))
		      ((< code #x800)
		       (out (logior #xc0 (ldb (byte 5 6) code)))
		       (out (logior #x80 (ldb (byte 6 0) code))))
		      ((< code #x10000)
		       (out (logior #xe0 (ldb (byte 4 12) code)))
		       (out (logior #x80 (ldb (byte 6 6) code)))
		       (out (logior #x80 (ldb (byte 6 0) code))))
		      (t
		       (out (logior #xf0 (ldb (byte 3 18) code)))
		       (out (logior #xe0 (ldb (byte 6 12) code)))
		       (out (logior #x80 (ldb (byte 6 6) code)))
		       (out (logior #x80 (ldb (byte 6 0) code)))))))
	(setf (fill-pointer string) 0) ;; reset
	vec))))




; end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-reader.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-readloop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;L1-readloop.lisp


(defvar *break-on-signals* nil
  "When (TYPEP condition *BREAK-ON-SIGNALS*) is true, then calls to SIGNAL will
   enter the debugger prior to signalling that condition.")
(defvar *break-on-warnings* nil)
(defvar *break-on-errors* t "Not CL.")
(defvar *debugger-hook* nil
  "This is either NIL or a function of two arguments, a condition and the value
   of *DEBUGGER-HOOK*. This function can either handle the condition or return
   which causes the standard debugger to execute. The system passes the value
   of this variable to the function because it binds *DEBUGGER-HOOK* to NIL
   around the invocation.")
(defvar *backtrace-on-break* nil)
(defvar *** nil
  "the previous value of **")
(defvar ** nil
  "the previous value of *")
(defvar * nil
  "the value of the most recent top level EVAL")
(defvar /// nil
  "the previous value of //")
(defvar // nil
  "the previous value of /")
(defvar / nil
  "a list of all the values returned by the most recent top level EVAL")
(defvar +++ nil
  "the previous value of ++")
(defvar ++ nil
  "the previous value of +")
(defvar + nil
  "the value of the most recent top level READ")
(defvar - nil
  "the form currently being evaluated")

(defvar *continuablep* nil)
(defvar *in-read-loop* nil 
 "Is T if waiting for input in the read loop")


(defvar *did-startup* nil)



(defmacro catch-cancel (&body body)
  `(catch :cancel ,@body))

(defmacro throw-cancel (&optional value)
  `(throw :cancel ,value))

;;; Throwing like this works in listeners and in the initial process.
;;; Can't easily tell if a process is a listener.  Should be able to.
(defun toplevel ()
  (throw :toplevel nil))


;;; It's not clear that this is the right behavior, but aborting CURRENT-PROCESS -
;;; when no one's sure just what CURRENT-PROCESS is - doesn't seem right either.
(defun interactive-abort ()
  (interactive-abort-in-process *current-process*))

(defun interactive-abort-in-process (p)
  (if p (process-interrupt p 
                           #'(lambda ()
                               (unless *inhibit-abort*
                                 (if *in-read-loop* 
                                        (abort-break)
                                        (abort))
                                 )))))


(defun abort (&optional condition)
  "Transfer control to a restart named ABORT, signalling a CONTROL-ERROR if
   none exists."
  (invoke-restart-no-return (find-restart 'abort condition)))

(defun continue (&optional condition)
  "Transfer control to a restart named CONTINUE, or return NIL if none exists."
  (let ((r (find-restart 'continue condition)))
    (if r (invoke-restart r))))

(defun muffle-warning (&optional condition)
  "Transfer control to a restart named MUFFLE-WARNING, signalling a
   CONTROL-ERROR if none exists."
  (invoke-restart-no-return (find-restart 'muffle-warning condition)))

(defun abort-break ()
  (invoke-restart-no-return 'abort-break))


(defun quit (&optional (exit 0) &key error-handler)
  "exit must be either a (signed-byte 32) exit status or a function to call to exit lisp
   error-handler can be a function of one argument, the condition, that will be called if an
   error occurs while preparing to quit.  The error handler should exit"
  (if (or (null exit) (typep exit '(signed-byte 32)))
    (setq exit (let ((exit-status (or exit 0)))
                 #'(lambda () (#__exit exit-status))))
    (unless (typep exit 'function)
      (report-bad-arg exit '(or (signed-byte 32) function))))
  (let* ((ip *initial-process*)
	 (cp *current-process*))
    (when (process-verify-quit ip)
      (process-interrupt ip
			 #'(lambda ()
                             (handler-bind ((error (lambda (c)
                                                     (when error-handler
                                                       (funcall error-handler c)))))
                               (process-exit-application *current-process*
                                                         #'(lambda ()
                                                             (%set-toplevel nil)
                                                             (funcall exit) ;; must exit
                                                             (bug "Exit function didn't exit"))))))
      (unless (eq cp ip)
	(process-kill cp)))))


(defloadvar *quitting* nil)


(defun prepare-to-quit (&optional part)
  (let-globally ((*quitting* t))
    (when (or (null part) (eql 0 part))
      (dolist (f *lisp-cleanup-functions*)
	(funcall f)))
    (let* (#+forcibly-kill-threads (stragglers ()))
      (dolist (p (all-processes))
	(unless (or (eq p *initial-process*)
		    (not (process-active-p p)))
	  (if (process-persistent p)
	    (process-reset p :shutdown)
	    (process-kill p))))
      (dolist (p (all-processes))
        (let* ((semaphore (process-termination-semaphore p)))
          (when semaphore
            (unless (eq p *initial-process*)
              (unless (timed-wait-on-semaphore semaphore 0.05)
           #+forcibly-kill-threads     (push p stragglers))))))
      #+forcibly-kill-threads
      (dolist (p stragglers)
        (let* ((semaphore (process-termination-semaphore p)))
          (maybe-finish-process-kill p :kill)
          (when semaphore
            (timed-wait-on-semaphore semaphore 0.10)))))
    (shutdown-lisp-threads)
    (loop
      (let* ((streams (open-file-streams)))
        (when (null streams) (return))
        (let* ((ioblock (stream-ioblock (car streams) nil)))
          (when ioblock
            (setf (ioblock-inbuf-lock ioblock) nil
                  (ioblock-outbuf-lock ioblock) nil
                  (ioblock-owner ioblock) nil)))
        (close (car streams))))
    (setf (interrupt-level) -1)         ; can't abort after this
    )
  ;; Didn't abort, so really quitting.
  (setq *quitting* t))


(defun signal (condition &rest args)
  "Invokes the signal facility on a condition formed from DATUM and
   ARGUMENTS. If the condition is not handled, NIL is returned. If
   (TYPEP condition *BREAK-ON-SIGNALS*) is true, the debugger is invoked
   before any signalling is done."
  (setq condition (condition-arg condition args 'simple-condition))
  (let* ((*break-on-signals* *break-on-signals*))
     (let* ((old-bos *break-on-signals*))
       (when (unknown-ctype-p (let* ((*break-on-signals* nil)) (specifier-type old-bos)))
	 (setq *break-on-signals* nil)
	 (warn "~S : Ignoring invalid type specifier ~s." '*break-on-signals* old-bos)))
	 
   (when (typep condition *break-on-signals*)
     (let ((*break-on-signals* nil))
       (cbreak-loop "Signal" "Signal the condition." condition (%get-frame-ptr)))))
  (let ((%handlers% %handlers%))
    (while %handlers%
      (do* ((tag (pop %handlers%)) (handlers tag (cddr handlers)))
           ((null handlers))
        (when (typep condition (car handlers))
          (let ((fn (cadr handlers)))
            (cond ((null fn) (throw tag condition))
                  ((fixnump fn) (throw tag (cons fn condition)))
                  (t (funcall fn condition)))))))))

(defvar *error-print-circle* nil)   ; reset to T when we actually can print-circle



;;;***********************************
;;;Mini-evaluator
;;;***********************************

(defun new-lexical-environment (&optional parent)
  (%istruct 'lexical-environment parent nil nil nil nil nil nil))

(defmethod make-load-form ((e lexical-environment) &optional env)
  (declare (ignore env))
  nil)

(defun new-definition-environment (&optional (type 'compile-file))
  (%istruct 'definition-environment (list type)  nil nil nil nil nil nil nil nil nil nil nil nil ))

(defun definition-environment (env &optional clean-only &aux parent)
  (if (and env (not (istruct-typep env 'lexical-environment))) (report-bad-arg env 'lexical-environment))
  (do* () 
       ((or (null env) 
            (listp (setq parent (lexenv.parent-env env)))
            (and clean-only (or (lexenv.variables env) (lexenv.functions env)))))
    (setq env parent))
  (if (consp parent)
    env))

(defvar *symbol-macros* (make-hash-table :test #'eq))

(defun %define-symbol-macro (name expansion)
  (if (or (constant-symbol-p name)
	  (proclaimed-special-p name))
      (signal-program-error "Symbol ~s already globally defined as a ~A"
			    name (if (constant-symbol-p name)
				     'constant
				     'variable)))
  (setf (gethash name *symbol-macros*) expansion)
  name)

(defvar *macroexpand-hook* 'funcall
  "The value of this variable must be a designator for a function that can
  take three arguments, a macro expander function, the macro form to be
  expanded, and the lexical environment to expand in. The function should
  return the expanded form. This function is called by MACROEXPAND-1
  whenever a runtime expansion is needed. Initially this is set to
  FUNCALL.") ; Should be #'funcall. 
;(queue-fixup (setq *macroexpand-hook* #'funcall)) ;  No it shouldn't.

(defun %symbol-macroexpand-1 (sym env)
  (flet ((expand-it (expansion)
           (funcall *macroexpand-hook*
                    (constantly expansion)
                    sym
                    env)))
    (if (and env (not (istruct-typep env 'lexical-environment)))
      (report-bad-arg env 'lexical-environment))
    (do* ((env env (lexenv.parent-env env)))
         ((null env))
      (if (istruct-typep env 'definition-environment)
	(let* ((info (assq sym (defenv.symbol-macros env))))
	  (if info
	    (return-from %symbol-macroexpand-1 (values (expand-it (cdr info)) t))
	    (return)))
	(let* ((vars (lexenv.variables env)))
          (dolist (vdecl (lexenv.vdecls env))
            (if (and (eq (car vdecl) sym)
                     (eq (cadr vdecl) 'special))
              (return-from %symbol-macroexpand-1 (values sym nil))))
	  (when (consp vars)
	    (let* ((info (dolist (var vars)
			   (if (eq (var-name var) sym)
                             (return var)))))            
	      (when info
		(if (and (consp (setq info (var-expansion info)))
			 (eq (%car info) :symbol-macro))
                  (return-from %symbol-macroexpand-1 (values (expand-it (%cdr info)) t))
                  (return-from %symbol-macroexpand-1 (values sym nil)))))))))
    ;; Look it up globally.
    (multiple-value-bind (expansion win) (gethash sym *symbol-macros*)
      (if win (values (expand-it expansion) t) (values sym nil)))))

(defun macroexpand-all (form &optional (env (new-lexical-environment)))
  "Recursivly expand all macros in FORM."
  (flet ((mexpand (forms env)
           (mapcar (lambda (form) (macroexpand-all form env)) forms)))
    (macrolet ((destructuring-bind-body (binds form &body body)
                 (if (eql '&body (first (last binds)))
                   (let ((&body (gensym "&BODY")))
                     `(destructuring-bind ,(append (butlast binds) (list '&body &body))
                          ,form
                        (multiple-value-bind (body decls)
                            (parse-body ,&body env nil)
                          ,@body)))
                   `(destructuring-bind ,binds ,form ,@body))))
      (multiple-value-bind (expansion win)
          (macroexpand-1 form env)
        (if win
          (macroexpand-all expansion env)
          (if (atom form)
            form
            (case (first form)
              (macrolet
               (destructuring-bind-body (macros &body) (rest form)
                (setf env (augment-environment env
                                               :macro (mapcar (lambda (macro)
                                                                (destructuring-bind
                                                                      (name arglist &body body)
                                                                    macro
                                                                  (list name (enclose (parse-macro name arglist body env)))))
                                                              macros)
                                               :declare (decl-specs-from-declarations decls)))
                (let ((body (mexpand body env)))
                  (if decls
                    `(locally ,@decls ,@body)
                    `(progn ,@body)))))
              (symbol-macrolet
               (destructuring-bind-body (symbol-macros &body) (rest form)
                (setf env (augment-environment env :symbol-macro symbol-macros :declare (decl-specs-from-declarations decls)))
                (let ((body (mexpand body env)))
                  (if decls
                    `(locally ,@decls ,@body)
                    `(progn ,@body)))))
              ((let let* compiler-let)
               (destructuring-bind-body (bindings &body) (rest form)
                `(,(first form)
                   ,(mapcar (lambda (binding)
                              
                              (if (listp binding)
                                (list (first binding) (macroexpand-all (second binding) env))
                                binding))
                            bindings)
                   ,@decls
                   ,@(mexpand body env))))
              ((flet labels)
               (destructuring-bind-body (bindings &body) (rest form)
                 (let ((augmented-env
                        (augment-environment env :function (mapcar #'car bindings))))
                  `(,(first form)
                     ,(mapcar (lambda (binding)
                                (list* (first binding)
                                       (cdr (macroexpand-all `(lambda ,@(rest binding))
                                                             (if (eq (first form) 'labels)
                                                                 augmented-env
                                                                 env)))))
                              bindings)
                     ,@decls
                     ,@(mexpand body augmented-env)))))
              (nfunction (list* 'nfunction (second form) (macroexpand-all (third form) env)))
              (function
                 (if (and (consp (second form))
                          (eql 'lambda (first (second form))))
                   (destructuring-bind (lambda arglist &body body&decls)
                       (second form)
                     (declare (ignore lambda))
                     (multiple-value-bind (body decls)
                         (parse-body body&decls env)
                       `(lambda ,arglist ,@decls ,@(mexpand body env))))
                   form))
              ((eval-when the locally block return-from)
                 (list* (first form) (second form) (mexpand (cddr form) env)))
              (setq
                 `(setq ,@(loop for (name value) on (rest form) by #'cddr
                                collect name
                                collect (macroexpand-all value env))))
              ((go quote) form)
              ((fbind with-c-frame with-variable-c-frame ppc-lap-function)
               (error "Unable to macroexpand ~S." form))
              ((catch if load-time-value multiple-value-call multiple-value-prog1 progn
                progv tagbody throw unwind-protect)
               (cons (first form) (mexpand (rest form) env)))
              (t
               ;; need to check that (first form) is either fboundp or a local function...
               (cons (first form) (mexpand (rest form) env))))))))))

(defun macroexpand-1 (form &optional env &aux fn)
  "If form is a macro (or symbol macro), expand it once. Return two values,
   the expanded form and a T-or-NIL flag indicating whether the form was, in
   fact, a macro. ENV is the lexical environment to expand in, which defaults
   to the null environment."
  (declare (resident))
  (if (and (consp form)
           (symbolp (%car form)))
    (if (setq fn (macro-function (%car form) env))
      (values (funcall *macroexpand-hook* fn form env) t)
      (values form nil))
    (if (and form (symbolp form))
      (%symbol-macroexpand-1 form env)
      (values form nil))))

(defun macroexpand (form &optional env)
  "Repetitively call MACROEXPAND-1 until the form can no longer be expanded.
   Returns the final resultant form, and T if it was expanded. ENV is the
   lexical environment to expand in, or NIL (the default) for the null
   environment."
  (declare (resident))
  (multiple-value-bind (new win) (macroexpand-1 form env)
    (do* ((won-at-least-once win))
         ((null win) (values new won-at-least-once))
      (multiple-value-setq (new win) (macroexpand-1 new env)))))

(defun %symbol-macroexpand (form env &aux win won)
  ; Keep expanding until no longer a symbol-macro or no longer a symbol.
  (loop
    (unless (and form (symbolp form)) (return))
    (multiple-value-setq (form win) (macroexpand-1 form env))
    (if win (setq won t) (return)))
  (values form won))

(defun %cons-def-info (type &optional lfbits keyvect data specializers qualifiers)
  (ecase type
    (defun nil)
    (defmacro (setq data '(macro) lfbits nil)) ;; some code assumes lfbits=nil
    (defgeneric (setq data (list :methods) lfbits (logior (ash 1 $lfbits-gfn-bit) lfbits)))
    (defmethod (setq data (list :methods
                                (%cons-def-info-method lfbits keyvect qualifiers specializers))
                     lfbits (logandc2 lfbits (ash 1 $lfbits-aok-bit))
                     keyvect nil))
    (deftype (setq data '(type) lfbits (cons nil *loading-file-source-file*))))
  (vector lfbits keyvect *loading-file-source-file* data))

(defun def-info.lfbits (def-info)
  (and def-info
       (let ((lfbits (svref def-info 0)))
	 (if (consp lfbits) (%car lfbits) lfbits))))

(defun def-info.keyvect (def-info)
  (and def-info (svref def-info 1)))

(defun def-info.file (def-info)
  (and def-info (svref def-info 2)))

(defun def-info.lambda (def-info)
  (%def-info.lambda def-info))

(defun def-info.environment (def-info)
  (%def-info.environment def-info))



(defun def-info.methods (def-info)
  (and def-info
       (let ((data (svref def-info 3)))
	 (and (eq (car data) :methods) (%cdr data)))))


(defun %cons-def-info-method (lfbits keyvect qualifiers specializers)
  (cons (cons (and keyvect
		   (if (logbitp $lfbits-aok-bit lfbits)
		     (and (not (logbitp $lfbits-rest-bit lfbits))
			  (list keyvect))
		     keyvect))
              *loading-file-source-file*)
        (cons qualifiers specializers)))

(defun def-info-method.keyvect (def-info-method)
  (let ((kv (caar def-info-method)))
    (if (listp kv)
      (values (car kv) t)
      (values kv  nil))))

(defun def-info-method.file (def-info-method)
  (cdar def-info-method))

(defun def-info-with-new-methods (def-info new-bits new-methods)
  (if (and (eq new-methods (def-info.methods def-info))
           (eql new-bits (def-info.lfbits def-info)))
    def-info
    (let ((new (copy-seq def-info))
          (old-bits (svref def-info 0)))
      (setf (svref new 0) (if (consp old-bits) (cons new-bits (cdr old-bits)) old-bits))
      (setf (svref new 3) (cons :methods new-methods))
      new)))

(defun def-info.macro-p (def-info)
  (let ((data (and def-info (svref def-info 3))))
    (eq (car data) 'macro)))

(defun def-info.function-p (def-info)
  (not (and def-info (eq (car (svref def-info 3)) 'type))))



(defun def-info.deftype (def-info)
  (and def-info
       (let ((bits (svref def-info 0)))
	 ;; bits or (bits . type-source-file)
	 (and (consp bits) bits))))

(defun def-info.deftype-type (def-info)
  ;; 'class (for defclass/defstruct) or 'macro (for deftype et. al.)
  (and def-info
       (consp (svref def-info 0))
       (svref def-info 1)))



(defvar *compiler-warn-on-duplicate-definitions* t)

(defun combine-deftype-infos (name def-info old-deftype new-deftype)
  (when (or new-deftype old-deftype)
    (when (and old-deftype new-deftype *compiler-warn-on-duplicate-definitions*)
      (nx1-whine :duplicate-definition
		 `(type ,name)
		 (cdr old-deftype)
		 (cdr new-deftype)))
    (let ((target (if new-deftype
		      (or (cdr new-deftype) (cdr old-deftype))
		      (cdr old-deftype)))
	  (target-deftype (def-info.deftype def-info)))
      (unless (and target-deftype (eq (cdr target-deftype) target))
	(setq def-info (copy-seq (or def-info '#(nil nil nil (ftype)))))
	(setf (svref def-info 0) (cons (def-info.lfbits def-info) target)))))
  def-info)

#+debug
(defun describe-def-info (def-info)
  (list :lfbits (def-info.lfbits def-info)
	:keyvect (def-info.keyvect def-info)
	:macro-p (def-info.macro-p def-info)
	:function-p (def-info.function-p def-info)
	:lambda (and (def-info.function-p def-info) (def-info.lambda def-info))
	:methods (and (def-info.function-p def-info) (def-info.methods def-info))
	:function-type (def-info.function-type def-info)
	:deftype (def-info.deftype def-info)
	:deftype-type (def-info.deftype-type def-info)))

(defun combine-gf-def-infos (name old-info new-info)
  (let* ((old-bits (def-info.lfbits old-info))
         (new-bits (def-info.lfbits new-info))
         (old-methods (def-info.methods old-info))
         (new-methods (def-info.methods new-info)))
    (when (and (logbitp $lfbits-gfn-bit old-bits) (logbitp $lfbits-gfn-bit new-bits))
      (when *compiler-warn-on-duplicate-definitions*
        (nx1-whine :duplicate-definition
                   name
                   (def-info.file old-info)
                   (def-info.file new-info)))
      (return-from combine-gf-def-infos new-info))
    (unless (congruent-lfbits-p old-bits new-bits)
      (if (logbitp $lfbits-gfn-bit new-bits)
        ;; A defgeneric, incongruent with previously defined methods
        (nx1-whine :incongruent-gf-lambda-list name)
        ;; A defmethod incongruent with previously defined explicit or implicit generic
        (nx1-whine :incongruent-method-lambda-list
                   (if new-methods `(:method ,@(cadar new-methods) ,name ,(cddar new-methods)) name)
                   name))
      ;; Perhaps once this happens, should just mark it somehow to not complain again
      (return-from combine-gf-def-infos 
        (if (logbitp $lfbits-gfn-bit old-bits) old-info new-info)))
    (loop for new-method in new-methods
          as old = (member (cdr new-method) old-methods :test #'equal :key #'cdr)
          do (when old
               (when *compiler-warn-on-duplicate-definitions*
                 (nx1-whine :duplicate-definition
                            `(:method ,@(cadr new-method) ,name ,(cddr new-method))
                            (def-info-method.file (car old))
                            (def-info-method.file new-method)))
               (setq old-methods (remove (car old) old-methods :test #'eq)))
          do (push new-method old-methods))
    (cond ((logbitp $lfbits-gfn-bit new-bits)
           ;; If adding a defgeneric, use its info.
           (setq old-info new-info old-bits new-bits))
          ((not (logbitp $lfbits-gfn-bit old-bits))
           ;; If no defgeneric (yet?) just remember whether any method has &key
           (setq old-bits (logior old-bits (logand new-bits (ash 1 $lfbits-keys-bit))))))
    ;; Check that all methods implement defgeneric keys
    (let ((gfkeys (and (logbitp $lfbits-gfn-bit old-bits) (def-info.keyvect old-info))))
      (when (> (length gfkeys) 0)
        (loop for minfo in old-methods
              do (multiple-value-bind (mkeys aok) (def-info-method.keyvect minfo)
                   (when (and mkeys
                              (not aok)
                              (setq mkeys (loop for gk across gfkeys
                                                unless (find gk mkeys) collect gk)))
                     (nx1-whine :gf-keys-not-accepted
                                `(:method ,@(cadr minfo) ,name ,(cddr minfo))
                                mkeys))))))
    (def-info-with-new-methods old-info old-bits old-methods)))

(defun combine-definition-infos (name old-info new-info)
  (let ((old-type (def-info.function-type old-info))
	(old-deftype (def-info.deftype old-info))
        (new-type (def-info.function-type new-info))
	(new-deftype (def-info.deftype new-info)))
    (cond ((and (eq old-type 'defgeneric) (eq new-type 'defgeneric))
           (setq new-info (combine-gf-def-infos name old-info new-info)))
	  ((or (eq (or old-type 'defun) (or new-type 'defun))
	       (eq (or old-type 'defgeneric) (or new-type 'defgeneric)))
           (when (and old-type new-type *compiler-warn-on-duplicate-definitions*)
             (nx1-whine :duplicate-definition name (def-info.file old-info) (def-info.file new-info)))
	   (unless new-info (setq new-info old-info)))
          (t
	   (when (and (def-info.function-p old-info) (def-info.function-p new-info)
		      *compiler-warn-on-duplicate-definitions*)
             (apply #'nx1-whine :duplicate-definition
                    name
                    (def-info.file old-info)
                    (def-info.file new-info)
                    (cond ((eq old-type 'defmacro) '("macro" "function"))
                          ((eq new-type 'defmacro) '("function" "macro"))
                          ((eq old-type 'defgeneric) '("generic function" "function"))
                          (t '("function" "generic function")))))
	   (unless new-type (setq new-info old-info))))
    (combine-deftype-infos name new-info old-deftype new-deftype)))

(defun record-definition-info (name info env)
  (let* ((definition-env (definition-environment env)))
    (if definition-env
      (let* ((defs (defenv.defined definition-env))
             (already (if (listp defs) (assq name defs) (gethash name defs))))
        (if already
          (setf (%cdr already) (combine-definition-infos name (%cdr already) info))
          (let ((outer (loop for defer = (cdr (defenv.type definition-env))
                               then (deferred-warnings.parent defer)
                             while (typep defer 'deferred-warnings)
                             thereis (gethash name (deferred-warnings.defs defer)))))
            (when outer
              (setq info (combine-definition-infos name (%cdr outer) info)))
            (let ((new (cons name info)))
              (if (listp defs)
                (setf (defenv.defined definition-env) (cons new defs))
                (setf (gethash name defs) new)))))
        info))))

(defun record-function-info (name info env)
  (record-definition-info name info env))

;;; This is different from AUGMENT-ENVIRONMENT.
(defun note-function-info (name lambda-expression env)
  (let* ((info nil)
         (name (maybe-setf-function-name name)))
    (when (lambda-expression-p lambda-expression)
      (multiple-value-bind (lfbits keyvect) (encode-lambda-list (cadr lambda-expression) t)
        (setq info (%cons-def-info 'defun lfbits keyvect
                                   (retain-lambda-expression name lambda-expression env)))))
    (record-function-info name info env))
  name)

(defun note-type-info (name kind env)
  (record-definition-info name (%cons-def-info 'deftype nil kind) env))


; And this is different from FUNCTION-INFORMATION.
(defun retrieve-environment-function-info (name env)
 (let ((defenv (definition-environment env)))
   (when defenv
     (let* ((defs (defenv.defined defenv))
	    (sym (maybe-setf-function-name name))
	    (info (if (listp defs) (assq sym defs) (gethash sym defs))))
       (and info (def-info.function-p (cdr info)) info)))))

;;; Must differ from -something-, but not sure what ... 
(defun note-variable-info (name info env)
  (let ((definition-env (definition-environment env)))
    (if definition-env (push (cons name info) (defenv.specials definition-env)))
    name))

(defun compile-file-environment-p (env)
  (let ((defenv (definition-environment env)))
    (and defenv (eq 'compile-file (car (defenv.type defenv))))))

;; This is EVAL.
(defun cheap-eval (form)
  ;; Don't record source locations for explicit calls to EVAL.
  (let ((*nx-source-note-map* nil))
    (cheap-eval-in-environment form nil)))

; used by nfcomp too
; Should preserve order of decl-specs; it sometimes matters.
(defun decl-specs-from-declarations (declarations)
  (let ((decl-specs nil))
    (dolist (declaration declarations decl-specs)
      ;(unless (eq (car declaration) 'declare) (say "what"))
      (dolist (decl-spec (cdr declaration))
        (setq decl-specs (nconc decl-specs (list decl-spec)))))))

(defun cheap-eval-macroexpand-1 (form env)
  (multiple-value-bind (new win) (macroexpand-1 form env)
    (when win
      (note-source-transformation form new))
    (values new win)))

(defun cheap-eval-transform (original new)
  (note-source-transformation original new)
  new)

(defun cheap-eval-function (name lambda env)
  (multiple-value-bind (lfun warnings)
                       (compile-named-function lambda
                                               :name name
                                               :env env
                                               :function-note *loading-toplevel-location*
                                               :keep-lambda *save-definitions*
                                               :keep-symbols *save-local-symbols*
                                               :source-notes *nx-source-note-map*)
    (signal-or-defer-warnings warnings env)
    lfun))

(fset 'nx-source-note (nlambda bootstrapping-source-note (form) (declare (ignore form)) nil))

(defun cheap-eval-in-environment (form env &aux sym)
  ;; Allow ADVICE, TRACE to have effects on self-calls.
  (declare (notinline cheap-eval-in-environment))
  ;; records source locations if *nx-source-note-map* is bound by caller
  (setq *loading-toplevel-location* (or (nx-source-note form) *loading-toplevel-location*))
  (flet ((progn-in-env (body&decls parse-env base-env)
           (multiple-value-bind (body decls) (parse-body body&decls parse-env)
             (setq base-env (augment-environment base-env :declare (decl-specs-from-declarations decls)))
             (loop with default-location = *loading-toplevel-location*
               while (cdr body) as form = (pop body)
               do (cheap-eval-in-environment form base-env)
               do (setq *loading-toplevel-location* default-location))
             (cheap-eval-in-environment (car body) base-env))))
    (if form
      (cond ((symbolp form) 
             (multiple-value-bind (expansion win) (cheap-eval-macroexpand-1 form env)
               (if win 
                 (cheap-eval-in-environment expansion env)
                 (let* ((defenv (definition-environment env))
                        (constant (if defenv (assq form (defenv.constants defenv))))
                        (constval (%cdr constant)))
                   (if constant
                     (if (neq (%unbound-marker-8) constval)
                       constval
                       (error "Can't determine value of constant symbol ~s" form))
                     (if (constant-symbol-p form)
                       (%sym-global-value form)
                       (symbol-value form)))))))
            ((atom form) form)
            ((eq (setq sym (%car form)) 'quote)
             (verify-arg-count form 1 1)
             (%cadr form))
            ((eq sym 'function)
             (verify-arg-count form 1 1)
             (cond ((symbolp (setq sym (%cadr form)))
                    (multiple-value-bind (kind local-p)
                        (function-information sym env)
                      (if (and local-p (eq kind :macro))
                        (error "~s can't be used to reference lexically defined macro ~S" 'function sym)))
                    (%function sym))
                   ((setf-function-name-p sym)
                    (multiple-value-bind (kind local-p)
                        (function-information sym env)
                      (if (and local-p (eq kind :macro))
                        (error "~s can't be used to reference lexically defined macro ~S" 'function sym)))
                    (%function (setf-function-name (%cadr sym))))
                   (t (cheap-eval-function nil sym env))))
            ((eq sym 'nfunction)
             (verify-arg-count form 2 2)
             (cheap-eval-function (%cadr form) (%caddr form) env))
            ((eq sym 'progn) (progn-in-env (%cdr form) env env))
            ((eq sym 'setq)
             (if (not (%ilogbitp 0 (list-length form)))
               (verify-arg-count form 0 0)) ;Invoke a "Too many args" error.
             (let* ((sym nil)
                    (val nil)
                    (original form))
               (while (setq form (%cdr form))
                 (setq sym (require-type (pop form) 'symbol))
                 (multiple-value-bind (expansion expanded)
                                      (cheap-eval-macroexpand-1 sym env)
                   (if expanded
                     (setq val (cheap-eval-in-environment
                                (cheap-eval-transform original `(setf ,expansion ,(%car form)))
                                env))
                     (set sym (setq val (cheap-eval-in-environment (%car form) env))))))
               val))
            ((eq sym 'eval-when)
             (destructuring-bind (when . body) (%cdr form)
               (when (or (memq 'eval when) (memq :execute when)) (progn-in-env body env env))))
            ((eq sym 'if)
             (destructuring-bind (test true &optional false) (%cdr form)
               (setq test (let ((*loading-toplevel-location* *loading-toplevel-location*))
                            (cheap-eval-in-environment test env)))
               (cheap-eval-in-environment (if test true false) env)))
            ((eq sym 'locally) (progn-in-env (%cdr form) env env))
            #|
            ((eq sym 'symbol-macrolet)
	     (multiple-value-bind (body decls) (parse-body (cddr form) env)
	       (progn-in-env body env (augment-environment env :symbol-macro (cadr form) :declare (decl-specs-from-declarations decls)))))
            ((eq sym 'macrolet)
             (let ((temp-env (augment-environment env
                                                  :macro 
                                                  (mapcar #'(lambda (m)
                                                              (destructuring-bind (name arglist &body body) m
                                                                (setq name (nx-need-function-name name))
                                                                (list name (enclose (parse-macro name arglist body env)
                                                                                    env))))
                                                          (cadr form)))))
               (progn-in-env (cddr form) temp-env temp-env)))
            |#
            ((and (symbolp sym) 
                  (compiler-special-form-p sym)
                  (not (functionp (fboundp sym))))
             (if (eq sym 'unwind-protect)
               (destructuring-bind (protected-form . cleanup-forms) (cdr form)
                 (unwind-protect
                     (let ((*loading-toplevel-location* *loading-toplevel-location*))
                       (cheap-eval-in-environment protected-form env))
                   (progn-in-env cleanup-forms env env)))
               (let ((fn (cheap-eval-function nil (cheap-eval-transform form `(lambda () (progn ,form))) env)))
                 (funcall fn))))
            ((and (symbolp sym) (macro-function sym env))
             (cheap-eval-in-environment (cheap-eval-macroexpand-1 form env) env))
            ((or (symbolp sym)
                 (and (consp sym) (eq (%car sym) 'lambda)))
             (let ((args nil) (form-location *loading-toplevel-location*))
               (dolist (elt (%cdr form))
                 (push (cheap-eval-in-environment elt env) args)
                 (setq *loading-toplevel-location* form-location))
               (apply #'call-check-regs (if (symbolp sym) sym (cheap-eval-function nil sym env))
                      (nreverse args))))
            (t
             (signal-simple-condition 'simple-program-error "Car of ~S is not a function name or lambda-expression." form))))))


(%fhave 'eval #'cheap-eval)



  
(defun call-check-regs (fn &rest args)
  (declare (dynamic-extent args)
           (optimize (debug 3)))        ; don't use any saved registers
  (let ((old-regs (multiple-value-list (get-saved-register-values))))
    (declare (dynamic-extent old-regs))
    (multiple-value-prog1 (apply fn args)
      (let* ((new-regs (multiple-value-list (get-saved-register-values)))
             (new-regs-tail new-regs))
        (declare (dynamic-extent new-regs))
        (unless (dolist (old-reg old-regs t)
                  (unless (eq old-reg (car new-regs-tail))
                    (return nil))
                  (pop new-regs-tail))
          (apply 'error "Registers clobbered applying ~s to ~s~%~@{~a sb: ~s, Was: ~s~%~}"
                 fn args
                 (mapcan 'list
                         (let ((res nil))
                           (dotimes (i (length old-regs))
                             (push (format nil "save~d" i) res))
                           (nreverse res))
                         old-regs
                         new-regs)))))))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Stack frame accessors.

; Kinda scant, wouldn't you say ?


;end of L1-readloop.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-readloop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/linux-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defconstant unix-to-universal-time 2208988800)

#+windows-target
(progn


            



(defconstant univeral-time-start-in-windows-seconds 9435484800)

(defun windows-filetime-to-universal-time (ft)
  (let* ((100-ns (dpb (pref ft #>FILETIME.dwHighDateTime) (byte 32 32)
                      (pref ft #>FILETIME.dwLowDateTime)))
         (seconds-since-windows-epoch (floor 100-ns 10000000)))
    (- seconds-since-windows-epoch univeral-time-start-in-windows-seconds)))
)

(defun get-foreign-namestring (pointer)
  ;; On Darwin, foreign namestrings are encoded in UTF-8 and
  ;; are canonically decomposed (NFD).  Use PRECOMPOSE-SIMPLE-STRING
  ;; to ensure that the string is "precomposed" (NFC), like the
  ;; rest of the world and most sane people would expect.
  #+darwin-target
  (precompose-simple-string (%get-utf-8-cstring pointer))
  #+windows-target (nbackslash-to-forward-slash
                     (%get-native-utf-16-cstring pointer))
  ;; On some other platforms, the namestring is assumed to
  ;; be encoded according to the current locale's character
  ;; encoding (though FreeBSD seems to be moving towards
  ;; precomposed UTF-8.).
  #-(or darwin-target windows-target)
  (let* ((encoding-name (pathname-encoding-name)))
    (if encoding-name
      (get-encoded-cstring encoding-name pointer)
      (%get-cstring pointer))))

(defun nanoseconds (seconds)
  (when (and (typep seconds 'fixnum)
             (>= (the fixnum seconds) 0))
    (return-from nanoseconds (values seconds 0)))
  (check-type seconds (real 0 #.(1- (ash 1 (1- target::nbits-in-word)))))
  (multiple-value-bind (q r)
      (floor seconds)
    (if (zerop r)
      (setq r 0)
      (setq r (floor (* r 1000000000))))
    (values q r)))

(defun milliseconds (seconds)
  (when (and (typep seconds 'fixnum)
             (>= (the fixnum seconds) 0))
    (return-from milliseconds (values seconds 0)))
  (check-type seconds (real 0 #.(1- (ash 1 (1- target::nbits-in-word)))))
  (multiple-value-bind (q r)
      (floor seconds)
    (if (zerop r)
      (setq r 0)
      (setq r (floor (* r 1000))))
    (values q r)))

(defun microseconds (seconds)
  (when (and (typep seconds 'fixnum)
             (>= (the fixnum seconds) 0))
    (return-from microseconds (values seconds 0)))
  (check-type seconds (real 0 #.(1- (ash 1 (1- target::nbits-in-word)))))
  (multiple-value-bind (q r)
      (floor seconds)
    (if (zerop r)
      (setq r 0)
      (setq r (floor (* r 1000000))))
    (values q r)))

(defun semaphore-value (s)
  (if (istruct-typep s 'semaphore)
    (semaphore.value s)
    (semaphore-value (require-type s 'semaphore))))

(defun %wait-on-semaphore-ptr (s seconds milliseconds &optional flag)
  (if flag
    (if (istruct-typep flag 'semaphore-notification)
      (setf (semaphore-notification.status flag) nil)
      (report-bad-arg flag 'semaphore-notification)))
  (without-interrupts
   (let* ((status (ff-call
                   (%kernel-import target::kernel-import-wait-on-semaphore)
                   :address s
                   :unsigned seconds
                   :unsigned milliseconds
                   :signed))
          (result (zerop status)))     
     (declare (fixnum status))
     (when flag (setf (semaphore-notification.status flag) result))
     (values result status))))

(defun %process-wait-on-semaphore-ptr (s seconds milliseconds &optional
                                         (whostate "semaphore wait") flag)
  (or (%wait-on-semaphore-ptr s 0 0 flag)
      (with-process-whostate  (whostate)
        (loop
          (when (%wait-on-semaphore-ptr s seconds milliseconds flag)
            (return))))))

  
(defun wait-on-semaphore (s &optional flag (whostate "semaphore wait"))
  "Wait until the given semaphore has a positive count which can be
atomically decremented."
  (%process-wait-on-semaphore-ptr (semaphore-value s) #xffffff 0 whostate flag)
  t)


(defun %timed-wait-on-semaphore-ptr (semptr duration notification)
  (or (%wait-on-semaphore-ptr semptr 0 0 notification)
      (with-process-whostate ("Semaphore timed wait")
        (let* ((now (get-internal-real-time))
               (stop (+ now (floor (* duration internal-time-units-per-second)))))
          (multiple-value-bind (secs millis) (milliseconds duration)
            (loop
              (multiple-value-bind (success err)
                  (progn
                    (%wait-on-semaphore-ptr semptr secs millis notification))
                (when success
                  (return t))
                (when (or (not (eql err #$EINTR))
                          (>= (setq now (get-internal-real-time)) stop))
                  (return nil))
                (unless (zerop duration)
                  (let* ((diff (- stop now)))
                    (multiple-value-bind (remaining-seconds remaining-itus)
                        (floor diff internal-time-units-per-second)
                      (setq secs remaining-seconds
                            millis (floor remaining-itus (/ internal-time-units-per-second 1000)))))))))))))

(defun timed-wait-on-semaphore (s duration &optional notification)
  "Wait until the given semaphore has a positive count which can be
atomically decremented, or until a timeout expires."
  (%timed-wait-on-semaphore-ptr (semaphore-value s) duration notification))


(defun %signal-semaphore-ptr (p)
  (ff-call
   (%kernel-import target::kernel-import-signal-semaphore)
   :address p
   :signed-fullword))

(defun signal-semaphore (s)
  "Atomically increment the count of a given semaphore."
  (%signal-semaphore-ptr (semaphore-value s)))

(defun %timed-wait-for-signal (signo seconds millis)
  (let* ((status (ff-call
                  (%kernel-import target::kernel-import-wait-for-signal)
                  :int signo
                  :unsigned seconds
                  :unsigned millis
                  :int)))
    (values (eql status 0) status)))

(defun wait-for-signal (s duration)
  (if duration
    (check-type duration (real 0 #x7fffffff))
    (setq duration #x7fffffff))
  (or (multiple-value-bind (result err)
          (%timed-wait-for-signal s 0 0)
        (or result
            (if (or (eql err #$EINTR) ; probably not possible
                    (eql err #-windows-target #$ETIMEDOUT #+windows-target #$WAIT_TIMEOUT))
              nil
              (error "Error waiting for signal ~d: ~a." s (%strerror err)))))
      (with-process-whostate ("signal wait")
        (let* ((now (get-internal-real-time))
               (stop (+ now (floor (* duration internal-time-units-per-second)))))
          (multiple-value-bind (secs millis) (milliseconds duration)
            (loop
              (multiple-value-bind (success err)
                  (progn
                    (%timed-wait-for-signal s secs millis))
                (when success
                  (return t))
                (if (or (eql err #-windows-target #$ETIMEDOUT #+windows-target #$WAIT_TIMEOUT)
                        (>= (setq now (get-internal-real-time)) stop))
                  (return nil)
                  (unless (eql err #$EINTR)
                    (error "Error waiting for signal ~d: ~a." s (%strerror err))))
                (unless (zerop duration)
                  (let* ((diff (- stop now)))
                    (multiple-value-bind (remaining-seconds remaining-itus)
                        (floor diff internal-time-units-per-second)
                      (setq secs remaining-seconds
                            millis (floor remaining-itus (/ internal-time-units-per-second 1000)))))))))))))
  
(defun %os-getcwd (buf noctets)
  ;; Return N < 0, if error
  ;;        N < noctets: success, string is of length N (octets).
  ;;        N >= noctets: buffer needs to be larger.
  (let* ((p #+windows-target
           (#__wgetcwd buf (ash noctets -1))
           #-windows-target
           (#_getcwd buf noctets)))
    (declare (dynamic-extent p))
    (if (%null-ptr-p p)
      (let* ((err (%get-errno)))
	(if (eql err (- #$ERANGE))
	  (+ noctets noctets)
	  err))
      #+windows-target
      (do* ((i 0 (+ i 2)))
           ((= i noctets) (+ noctets noctets))
        (when (eql (%get-unsigned-word buf i) 0)
          (return i)))
      #-windows-target
      (dotimes (i noctets (+ noctets noctets))
	(when (eql 0 (%get-byte buf i))
	  (return i))))))

(defparameter *trust-paths-from-environment* t
  "When true (as it is by default), environment variables can be used
to initialize CCL's notion of some filesystem paths.  This may expose
CCL or your application to greater security risks in some cases; if you're
concerned about that, you may want to save an image with this variable
set to NIL.")


(defun temp-pathname ()
  "Return a suitable pathname for a temporary file.  A different name is returned
each time this is called in a session.  No file by that name existed when last
checked, though no guarantee is given that one hasn't been created since."
  (native-to-pathname
     #-windows-target
     #-android-target (get-foreign-namestring (#_tmpnam (%null-ptr)))
     #+android-target
     ;; Android dutifully implements #_tmpnam and returns a namestring
     ;; in /tmp, but of course they don't usually provide /tmp .
     (let* ((s (get-foreign-namestring (#_tmpnam (%null-ptr)))))
       (if (probe-file (make-pathname :directory (pathname-directory s) :defaults nil))
         s
         (let* ((dirname (or (and *trust-paths-from-environment*
                                  (let* ((p (getenv "TMPDIR")))
                                    (and p
                                         (eq (nth-value 1 (%probe-file-x p))
                                             :directory)
                                         p)))
                             "/data/local/tmp"))
                (filename (make-string 8)))
           (loop
             (flet ((random-char ()
                      (let* ((n (random 62)))
                        (cond ((< n 10) (code-char (+ (char-code #\0) n)))
                              ((< n 36) (code-char (+ (char-code #\A) (- n 10))))
                              (t (code-char (+ (char-code #\a) (- n 36))))))))
               (dotimes (i (length filename))
                 (setf (schar filename i) (random-char)))
               (let* ((path (make-pathname :name filename :directory dirname :defaults nil)))
                 (unless (probe-file path)
                   (return (namestring path)))))))))
     #+windows-target (rlet ((buffer (:array :wchar_t #.#$MAX_PATH)))
                        (#_GetTempPathW #$MAX_PATH buffer)
                        (with-filename-cstrs ((c-prefix "ccl")) 
                            (#_GetTempFileNameW buffer c-prefix 0 buffer)
                              (#_DeleteFileW buffer)
                              (%get-native-utf-16-cstring buffer)))))

(defun current-directory-name ()
  "Look up the current working directory of the Clozure CL process; unless
it has been changed, this is the directory Clozure CL was started in."
  (flet ((try-getting-dirname (bufsize)
	   (%stack-block ((buf bufsize))
	     (let* ((len (%os-getcwd buf bufsize)))
	       (cond ((< len 0) (%errno-disp len))
		     ((< len bufsize)
		      (setf (%get-unsigned-byte buf len) 0)
		      (values (get-foreign-namestring buf) len))
		     (t (values nil len)))))))
    (do* ((string nil)
	  (len #+windows-target 128 #-windows-target 64)
	  (bufsize len len))
	 ((multiple-value-setq (string len) (try-getting-dirname bufsize))
	  string))))


(defun current-directory ()
  (mac-default-directory))

(defun (setf current-directory) (path)
  (cwd path)
  path)

(defun cd (path)
  (cwd path))




(defun %chdir (dirname)
  (with-filename-cstrs ((dirname dirname))
    (int-errno-call (#+windows-target #__wchdir #-windows-target #_chdir dirname))))

(defun %mkdir (name mode)
  #+windows-target (declare (ignore mode))
  (let* ((name name)
         (len (length name)))
    (when (and (> len 0) (eql (char name (1- len)) #\/))
      (setq name (subseq name 0 (1- len))))
    (with-filename-cstrs ((name name))
      (int-errno-call (#+windows-target #__wmkdir #-windows-target #_mkdir  name #-windows-target mode)))))

(defun %rmdir (name)
  (let* ((last (1- (length name))))
    (when (and (>= last 0)
	       (eql (char name last) #\/))
      (setq name (subseq name 0 last)))
    (with-filename-cstrs ((name name))
      (int-errno-call (#+windows-target #__wrmdir #-windows-target #_rmdir  name)))))


(defun getenv (key)
  "Look up the value of the environment variable named by name, in the
OS environment."
  (with-cstrs ((key (string key)))
    (let* ((env-ptr (%null-ptr)))
      (declare (dynamic-extent env-ptr))
      (%setf-macptr env-ptr (#_getenv key))
      (unless (%null-ptr-p env-ptr)
	(%get-cstring env-ptr))))
  )

(defun setenv (key value &optional (overwrite t))
  "Set the value of the environment variable named by name, in the OS
environment. If there is no such environment variable, create it."
  #+windows-target (declare (ignore overwrite))
  #-windows-target
  (with-cstrs ((ckey key)
	       (cvalue value))
    (#_setenv ckey cvalue (if overwrite 1 0)))
  #+windows-target
  (with-cstrs ((pair (concatenate 'string key "=" value)))
    (#__putenv pair))
  )

(defun unsetenv (key)
  #-windows-target
  (with-cstrs ((ckey key))
    (#_unsetenv ckey))
  #+windows-target
  (with-cstrs ((ckey (concatenate 'string key "=")))
    (#__putenv ckey)))

#-windows-target                        ; Windows "impersonation" crap ?
(defun setuid (uid)
  "Attempt to change the current user ID (both real and effective);
fails unless the Clozure CL process has super-user privileges or the ID
given is that of the current user."
  (int-errno-call (#_setuid uid)))

#-windows-target
(defun setgid (uid)
  "Attempt to change the current group ID (both real and effective);
fails unless the Clozure CL process has super-user privileges or the ID
given is that of a group to which the current user belongs."
  (int-errno-call (#_setgid uid)))
  

;;; On Linux, "stat" & friends are implemented in terms of deeper,
;;; darker things that need to know what version of the stat buffer
;;; they're talking about.

#-windows-target
(defun %stat-values (result stat)
  (if (eql 0 (the fixnum result)) 
      (values
       t
       (pref stat :stat.st_mode)
       (pref stat :stat.st_size)
       #+android-target (pref stat :stat.st_mtime)
       #+(or (and linux-target (not android-target)) solaris-target)
       (pref stat :stat.st_mtim.tv_sec)
       #-(or linux-target solaris-target)
       (pref stat :stat.st_mtimespec.tv_sec)
       (pref stat :stat.st_ino)
       (pref stat :stat.st_uid)
       (pref stat :stat.st_blksize)
       #+(or linux-target solaris-target)
       (round (pref stat #-android-target :stat.st_mtim.tv_nsec
                         #+android-target :stat.st_mtime_nsec) 1000)
       #-(or linux-target solaris-target)
       (round (pref stat :stat.st_mtimespec.tv_nsec) 1000)
       (pref stat :stat.st_gid)
       (pref stat :stat.st_dev)
       #-(or linux-target solaris-target)
       (pref stat :stat.st_flags))
      (values nil nil nil nil nil nil nil nil nil nil nil)))

#+win64-target
(defun %stat-values (result stat)
  (if (eql 0 (the fixnum result)) 
      (values
       t
       (pref stat :_stat64.st_mode)
       (pref stat :_stat64.st_size)
       (pref stat :_stat64.st_mtime)
       (pref stat :_stat64.st_ino)
       (pref stat :_stat64.st_uid)
       #$BUFSIZ
       (pref stat :_stat64.st_mtime)     ; ???
       (pref stat :_stat64.st_gid)
       (pref stat :_stat64.st_dev))
      (values nil nil nil nil nil nil nil nil nil nil)))

#+win32-target
(defun %stat-values (result stat)
  (if (eql 0 (the fixnum result)) 
      (values
       t
       (pref stat :__stat64.st_mode)
       (pref stat :__stat64.st_size)
       (pref stat :__stat64.st_mtime)
       (pref stat :__stat64.st_ino)
       (pref stat :__stat64.st_uid)
       #$BUFSIZ
       (pref stat :__stat64.st_mtime)     ; ???
       (pref stat :__stat64.st_gid)
       (pref stat :__stat64.st_dev))
      (values nil nil nil nil nil nil nil nil nil nil)))

#+windows-target
(defun windows-strip-trailing-slash (namestring)
  (do* ((len (length namestring) (length namestring)))
       ((<= len 3) namestring)
    (let* ((p (1- len))
           (ch (char namestring p)))
      (unless (or (eql ch #\\)
                  (eql ch #\/))
        (return namestring))
      (setq namestring (subseq namestring 0 p)))))


(defun %%stat (name stat)
  (with-filename-cstrs ((cname #+windows-target (windows-strip-trailing-slash name) #-windows-target name))
    (%stat-values
     #+(and linux-target (not android-target))
     (#_ __xstat #$_STAT_VER_LINUX cname stat)
     #-(and linux-target (not android-target))
     (int-errno-ffcall (%kernel-import target::kernel-import-lisp-stat)
                       :address cname
                       :address stat
                       :int)
     stat)))

(defun %%fstat (fd stat)
  (%stat-values
   #+(and linux-target (not android-target))
   (#_ __fxstat #$_STAT_VER_LINUX fd stat)
   #-(and linux-target (not android-target))
   (int-errno-ffcall (%kernel-import target::kernel-import-lisp-fstat)
                     :int fd
                     :address stat
                     :int)
   stat))

#-windows-target
(defun %%lstat (name stat)
  (with-filename-cstrs ((cname name))
    (%stat-values
     #+(and linux-target (not android-target))
     (#_ __lxstat #$_STAT_VER_LINUX cname stat)
     #-(and linux-target (not android-target))
     (int-errno-ffcall (%kernel-import target::kernel-import-lisp-lstat)
		       :address cname
		       :address stat
		       :int)
     stat)))


;;; Returns: (values t mode size mtime inode uid blksize) on success,
;;;          (values nil nil nil nil nil nil nil) otherwise
;;; NAME should be a "native namestring", e.g,, have all lisp pathname
;;; escaping removed.
#-windows-target
(defun %stat (name &optional link-p)
  (rlet ((stat :stat))
    (if link-p
      (%%lstat name stat)
      (%%stat name stat))))

#+windows-target
(defun %stat (name &optional link-p)
  (declare (ignore link-p))
  (rlet ((stat  #+win64-target #>_stat64 #+win32-target #>__stat64))
    (%%stat name stat)))

(defun %fstat (fd)
  (rlet ((stat #+win64-target #>_stat64 #+win32-target #>__stat64 #-windows-target :stat))
    (%%fstat fd stat)))


(defun %file-kind (mode &optional fd)
  (declare (ignorable fd))
  (when mode
    (let* ((kind (logand mode #$S_IFMT)))
      (cond ((eql kind #$S_IFDIR) :directory)
	    ((eql kind #$S_IFREG) :file)
            #-windows-target
	    ((eql kind #$S_IFLNK) :link)
	    ((eql kind #$S_IFIFO) 
	     #-windows-target :pipe
             ;; Windows doesn't seem to be able to distinguish between
             ;; sockets and pipes.  Since this function is currently
             ;; (mostly) used for printing streams and since we've
             ;; already done something fairly expensive (stat, fstat)
             ;; to get here.  try to distinguish between pipes and
             ;; sockets by calling #_getsockopt.  If that succeeds,
             ;; we've got a socket; otherwise, we've probably got a pipe.
	     #+windows-target (rlet ((ptype :int)
				     (plen :int 4))
				(if (and fd (eql 0 (#_getsockopt fd #$SOL_SOCKET #$SO_TYPE  ptype plen)))
				    :socket
				    :pipe)))
            #-windows-target
	    ((eql kind #$S_IFSOCK) :socket)
	    ((eql kind #$S_IFCHR) :character-special)
	    (t :special)))))

(defun %unix-file-kind (native-namestring &optional check-for-link)
  (%file-kind (nth-value 1 (%stat native-namestring check-for-link))))

(defun %unix-fd-kind (fd)
  (if (isatty fd)
    :tty
    (%file-kind (nth-value 1 (%fstat fd)) fd)))

#-windows-target
(defun %uts-string (result idx buf)
  (if (>= result 0)
    (%get-cstring (%inc-ptr buf (* #+(and linux-target (not android-target)) #$_UTSNAME_LENGTH
                                   #+android-target (1+ #$__NEW_UTS_LEN)
				   #+darwin-target #$_SYS_NAMELEN
                                   #+(or freebsd-target solaris-target) #$SYS_NMLN
                                   idx)))
    "unknown"))

#-windows-target
(defun copy-file-attributes (source-path dest-path)
  "Copy the mode, owner, group and modification time of source-path to dest-path.
   Returns T if succeeded, NIL if some of the attributes couldn't be copied due to
   permission problems.  Any other failures cause an error to be signalled"
  (multiple-value-bind (win mode ignore mtime-sec ignore uid ignore mtime-usec gid)
                       (%stat (defaulted-native-namestring source-path) t)
    (declare (ignore ignore))
    (unless win
      (error "Cannot get attributes of ~s" source-path))
    (with-filename-cstrs ((cnamestr (defaulted-native-namestring dest-path)))
      (macrolet ((errchk (form)
                   `(let ((err ,form))
                      (unless (eql err 0)
                        (setq win nil)
                        (when (eql err -1)
                          (setq err (- (%get-errno))))
                        (unless (eql err #$EPERM) (%errno-disp err dest-path))))))
        (errchk (#_chmod cnamestr mode))
        (errchk (%stack-block ((times (record-length (:array (:struct :timeval) 2))))
                  (setf (pref times :timeval.tv_sec) mtime-sec)
                  (setf (pref times :timeval.tv_usec) mtime-usec)
                  (%incf-ptr times (record-length :timeval))
                  (setf (pref times :timeval.tv_sec) mtime-sec)
                  (setf (pref times :timeval.tv_usec) mtime-usec)
                  (%incf-ptr times (- (record-length :timeval)))
                  (#_utimes cnamestr times)))
        (errchk (#_chown cnamestr uid gid))))
    win))

#+windows-target
(defun copy-file-attributes (source-path dest-path)
  "could at least copy the file times"
  (declare (ignore source-path dest-path)))


#+(and linux-target (not android-target))
(defun %uname (idx)
  (%stack-block ((buf (* #$_UTSNAME_LENGTH 6)))  
    (%uts-string (#_uname buf) idx buf)))

#+android-target
(defun %uname (idx)
  (%stack-block ((buf (* (1+ #$__NEW_UTS_LEN) 6)))  
    (%uts-string (#_uname buf) idx buf)))

#+darwin-target
(defun %uname (idx)
  (%stack-block ((buf (* #$_SYS_NAMELEN 5)))
    (%uts-string (#_uname buf) idx buf)))

#+freebsd-target
(defun %uname (idx)
  (%stack-block ((buf (* #$SYS_NMLN 5)))
    (%uts-string (#___xuname #$SYS_NMLN buf) idx buf)))

#+solaris-target
(defun %uname (idx)
  (%stack-block ((buf (* #$SYS_NMLN 5)))
    (%uts-string (#_uname buf) idx buf)))

#-windows-target
(defun fd-dup (fd)
  (int-errno-call (#_dup fd)))

#+windows-target
(defun fd-dup (fd &key direction inheritable)
  (declare (ignore direction))
  (rlet ((handle #>HANDLE))
    (if (eql 0 (#_DuplicateHandle (#_GetCurrentProcess)
                                  (%int-to-ptr fd)
                                  (#_GetCurrentProcess) 
                                  handle
                                  0
                                  (if inheritable #$TRUE #$FALSE)
                                  #$DUPLICATE_SAME_ACCESS))
      (%windows-error-disp (#_GetLastError))
      (pref handle #>DWORD))))


(defun fd-fsync (fd)
  #+windows-target (#_FlushFileBuffers (%int-to-ptr fd))
  #-windows-target
  (int-errno-call (#_fsync fd)))

#-windows-target
(progn
(defun fd-get-flags (fd)
  (int-errno-call (#_fcntl fd #$F_GETFL)))

(defun fd-set-flags (fd new)
  (int-errno-call (#_fcntl fd #$F_SETFL :int new)))

(defun fd-set-flag (fd mask)
  (let* ((old (fd-get-flags fd)))
    (if (< old 0)
      old
      (fd-set-flags fd (logior old mask)))))

(defun fd-clear-flag (fd mask)
  (let* ((old (fd-get-flags fd)))
    (if (< old 0) 
      old
      (fd-set-flags fd (logandc2 old mask)))))
)

(defun tilde-expand (namestring)
  (let* ((len (length namestring)))
    (if (or (zerop len)
            (not (eql (schar namestring 0) #\~)))
      namestring
      (if (or (= len 1)
              (eql (schar namestring 1) #\/))
        (concatenate 'string (native-to-namestring (get-user-home-dir (getuid))) (if (= len 1) "/" (subseq namestring 1)))
        #+windows-target namestring
        #-windows-target
        (let* ((slash-pos (%path-mem "/" namestring))
               (user-name (namestring-unquote (subseq namestring 1 slash-pos)))
               (uid (or (get-uid-from-name user-name)
                        (error "Unknown user ~s in namestring ~s" user-name namestring))))
          (concatenate 'string (native-to-namestring (get-user-home-dir uid)) (if slash-pos (subseq namestring slash-pos) "/")))))))


#+windows-target
(defun %windows-realpath (namestring)
  (with-filename-cstrs ((path namestring))
    (do* ((bufsize 256))
         ()
      (%stack-block ((buf bufsize))
        (let* ((nchars (#_GetFullPathNameW path (ash bufsize -1) buf (%null-ptr))))
          (if (eql 0 nchars)
            (return nil)
            (let* ((max (+ nchars nchars 2)))
              (if (> max bufsize)
                (setq bufsize max)
                (let* ((real (get-foreign-namestring buf)))
                  (return (and (%stat real) real)))))))))))

    
;;; This doesn't seem to exist on VxWorks.  It's a POSIX
;;; function AFAIK, so the source should be somewhere ...

(defun %realpath (namestring)
  ;; It's not at all right to just return the namestring here.
  (when (zerop (length namestring))
    (setq namestring (current-directory-name)))
  #+windows-target (%windows-realpath namestring)
  #-windows-target
  (%stack-block ((resultbuf #$PATH_MAX))
    (with-filename-cstrs ((name namestring #|(tilde-expand namestring)|#))
      (let* ((result (#_realpath name resultbuf)))
        (declare (dynamic-extent result))
        (if (%null-ptr-p result)
	  (let ((errno (%get-errno)))
	    (unless (= errno (- #$ENOENT))
	      (signal-file-error errno namestring)))
          (get-foreign-namestring result))))))

;;; Return fully resolved pathname & file kind, or (values nil nil)

(defun %probe-file-x (namestring)
  (let* ((realpath (%realpath namestring))
	 (kind (if realpath (%unix-file-kind realpath))))
    (if kind
      (values realpath kind)
      (values nil nil))))

;;; The mingw headers define timeval.tv_sec and timeval.tv_usec to be
;;; signed 32-bit quantities.
(macrolet ((timeval-ref (ptr accessor)
             #+windows-target `(logand #xfffffffff (pref ,ptr ,accessor))
             #-windows-target `(pref ,ptr ,accessor))
           (set-timeval-ref (ptr accessor new)
           `(setf (pref ,ptr ,accessor)
             #+windows-target (u32->s32 ,new)
             #-windows-target ,new)))
  
(defun timeval->milliseconds (tv)
    (+ (* 1000 (timeval-ref tv :timeval.tv_sec)) (round (timeval-ref tv :timeval.tv_usec) 1000)))

(defun timeval->microseconds (tv)
    (+ (* 1000000 (timeval-ref tv :timeval.tv_sec)) (timeval-ref tv :timeval.tv_usec)))

(defun %add-timevals (result a b)
  (let* ((seconds (+ (timeval-ref a :timeval.tv_sec) (timeval-ref b :timeval.tv_sec)))
	 (micros (+ (timeval-ref a :timeval.tv_usec) (timeval-ref b :timeval.tv_usec))))
    (if (>= micros 1000000)
      (setq seconds (1+ seconds) micros (- micros 1000000)))
    (set-timeval-ref result :timeval.tv_sec seconds)
    (set-timeval-ref result :timeval.tv_usec micros)
    result))

(defun %sub-timevals (result a b)
  (let* ((seconds (- (timeval-ref a :timeval.tv_sec) (timeval-ref b :timeval.tv_sec)))
	 (micros (- (timeval-ref a :timeval.tv_usec) (timeval-ref b :timeval.tv_usec))))
    (if (< micros 0)
      (setq seconds (1- seconds) micros (+ micros 1000000)))
    (set-timeval-ref result :timeval.tv_sec  seconds)
    (set-timeval-ref result :timeval.tv_usec micros)
    result))

;;; Return T iff the time denoted by the timeval a is not later than the
;;; time denoted by the timeval b.
(defun %timeval<= (a b)
  (let* ((asec (timeval-ref a :timeval.tv_sec))
         (bsec (timeval-ref b :timeval.tv_sec)))
    (or (< asec bsec)
        (and (= asec bsec)
             (< (timeval-ref a :timeval.tv_usec)
                (timeval-ref b :timeval.tv_usec))))))

); windows signed nonsense.

#-windows-target
(defun %%rusage (usage &optional (who #$RUSAGE_SELF))
  (int-errno-call (#_getrusage who usage)))




(defun %file-write-date (namestring)
  (let* ((date (nth-value 3 (%stat namestring))))
    (if date
      (+ date unix-to-universal-time))))

#-windows-target
(defun %file-author (namestring)
  (let* ((uid (nth-value 5 (%stat namestring))))
    (if uid
      (with-macptrs ((pw (#_getpwuid uid)))
        (unless (%null-ptr-p pw)
          (without-interrupts
           (%get-cstring (pref pw :passwd.pw_name))))))))

#+windows-target
(defun %file-author (namestring)
  (declare (ignore namestring))
  nil)

#-windows-target
(defun %utimes (namestring)
  (with-filename-cstrs ((cnamestring namestring))
    (let* ((err (#_utimes cnamestring (%null-ptr))))
      (declare (fixnum err))
      (or (eql err 0)
          (%errno-disp err namestring)))))

#+windows-target
(defun %utimes (namestring)
  (with-filename-cstrs ((cnamestring namestring))
    (let* ((handle (#_CreateFileW
                    cnamestring
                    #$FILE_WRITE_ATTRIBUTES
                    (logior #$FILE_SHARE_READ #$FILE_SHARE_WRITE)
                    (%null-ptr)
                    #$OPEN_EXISTING
                    #$FILE_FLAG_BACKUP_SEMANTICS
                    (%null-ptr))))
      (if (eql handle *windows-invalid-handle*)
        (%windows-error-disp (#_GetLastError))
        (rlet ((st #>SYSTEMTIME)
               (ft #>FILETIME))
          (#_GetSystemTime st)
          (#_SystemTimeToFileTime st ft)
          (let* ((result (#_SetFileTime handle (%null-ptr) (%null-ptr) ft))
                 (err (when (eql 0 result) (#_GetLastError))))
            (#_CloseHandle handle)
            (if err
              (%windows-error-disp err)
              t)))))))


             

#-windows-target
(defun get-uid-from-name (name)
  (with-cstrs ((name name))
    (let* ((pwent (#_getpwnam name)))
      (unless (%null-ptr-p pwent)
        (pref pwent :passwd.pw_uid)))))


(defun isatty (fd)
  #+windows-target (declare (ignore fd))
  #+windows-target nil
  #-windows-target
  (= 1 (#_isatty fd)))

#-win64-target
(progn
(defun %open-dir (namestring)
  (with-filename-cstrs ((name namestring))
    (let* ((DIR (ff-call (%kernel-import target::kernel-import-lisp-opendir)
                         :address name
                         :address)))
      (unless (%null-ptr-p DIR)
	DIR))))

(defun close-dir (dir)
  (ff-call (%kernel-import target::kernel-import-lisp-closedir)
           :address dir
           :int))

(defun %read-dir (dir)
  (let* ((res (ff-call (%kernel-import target::kernel-import-lisp-readdir)
                       :address dir
                       :address)))
    (unless (%null-ptr-p res)
      (get-foreign-namestring (pref res
                                    #+windows-target :_wdirent.d_name
                                    #-windows-target :dirent.d_name)))))
)

#+win64-target
(progn
  (eval-when (:compile-toplevel :execute)
    (def-foreign-type nil
        (:struct :win64-dir
                 (:data #>WIN32_FIND_DATAW)
                 (:handle :address)
                 (:state :int))))

(defun %open-dir (namestring)
  ;;; Namestring should end in /*.  Honest.
  (let* ((len (length namestring))
         (lastchar (if (> len 0) (schar namestring (1- len))))
         (penultimatechar (if (> len 1) (schar namestring (- len 2)))))
    (unless (and (eql lastchar #\*)
                 (or (eql penultimatechar #\\)
                     (eql penultimatechar #\/)))
      (if (or (eql lastchar #\\)
              (eql lastchar #\/))
        (setq namestring (concatenate 'string namestring "*"))
        (setq namestring (concatenate 'string namestring "/*")))))
  (let* ((dir (malloc (record-length :win64-dir))))
    (with-filename-cstrs ((name namestring))
      (let* ((handle (#_FindFirstFileW name dir)))
        (cond ((eql handle #$INVALID_HANDLE_VALUE)
               (free dir)
               nil)
              (t
               (setf (pref dir :win64-dir.state) 0
                     (pref dir :win64-dir.handle) handle)
               dir))))))
          
(defun %read-dir (dir)
  (when (eql 0 (pref dir :win64-dir.state))
    (prog1
        (get-foreign-namestring (pref dir  #>WIN32_FIND_DATAW.cFileName))
      (if (eql 0 (#_FindNextFileW (pref dir :win64-dir.handle) dir))
        (setf (pref dir :win64-dir.state) -1)))))

(defun close-dir (dir) 
  (#_FindClose (pref dir :win64-dir.handle))
  (free dir)
  nil)
)
                       
  

                         


#-windows-target
(defun tcgetpgrp (fd)
  (#_tcgetpgrp fd))

(defun getpid ()
  "Return the ID of the Clozure CL OS process."
  #-windows-target
  (int-errno-call (#_getpid))
  #+windows-target (#_GetCurrentProcessId))


(defun getuid ()
  "Return the (real) user ID of the current user."
  #+windows-target 0
  #-windows-target (int-errno-call (#_getuid)))

(defun get-user-home-dir (userid)
  "Look up and return the defined home directory of the user identified
by uid, as a native namestring. This value comes from the OS user database, not from the $HOME
environment variable, unless *TRUST-PATHS-FROM-ENVIRONMENT* is true.
Returns NIL if there is no user with the ID uid."
  #+(or windows-target android-target)
  (declare (ignore userid))
  #+windows-target
  (dolist (k '(#||"HOME"||# "USERPROFILE")) 
    (with-native-utf-16-cstrs ((key k))
      (let* ((p (#__wgetenv key)))
        (unless (%null-ptr-p p)
          (return (get-foreign-namestring p))))))
  #-windows-target
  (or (and *trust-paths-from-environment*
           (let* ((p (getenv "HOME")))
             (and p
                  (eq (nth-value 1 (%probe-file-x p)) :directory)
                  p)))
      #+android-target "/data/local" ; for now
      #-android-target
      (rlet ((pwd :passwd)
             (result :address pwd))
        (do* ((buflen 512 (* 2 buflen)))
             ()
          (%stack-block ((buf buflen))
            (let* ((err
                    #-solaris-target
                     (#_getpwuid_r userid pwd buf buflen result)
                     #+solaris-target
                     (external-call "__posix_getpwuid_r"
                                    :uid_t userid
                                    :address pwd
                                    :address buf
                                    :int buflen
                                    :address result
                                    :int)))
              (if (eql 0 err)
                (let* ((rp (%get-ptr result))
                       (dir (and (not (%null-ptr-p rp))
                                 (get-foreign-namestring (pref rp :passwd.pw_dir)))))
                  (return (if (and dir (eq (%unix-file-kind dir) :directory))
                            dir)))
                (unless (eql err #$ERANGE)
                  (return nil)))))))))

(defun %delete-file (name)
  (with-filename-cstrs ((n name))
    (int-errno-call (#+windows-target #__wunlink #-windows-target #_unlink n))))

(defun os-command (string)
  "Invoke the Posix function system(), which invokes the user's default
system shell (such as sh or tcsh) as a new process, and has that shell
execute command-line.

If the shell was able to find the command specified in command-line, then
exit-code is the exit code of that command. If not, it is the exit code
of the shell itself."
  (with-cstrs ((s string))
    (#_system s)))

(defun %strerror (errno)
  (declare (fixnum errno))
  (if (< errno 0)
    (setq errno (- errno)))
  (with-macptrs (p)
    (%setf-macptr p (#_strerror errno))
    (if (%null-ptr-p p)
      (format nil "OS Error ~d" errno)
      (%get-cstring p))))

#+windows-target
(progn
(defun get-last-windows-error ()
  (#_GetLastError))

(defun %windows-error-string (error-number)
  (rlet ((pbuffer :address (%null-ptr)))
    (if (eql 0
             (#_FormatMessageW (logior #$FORMAT_MESSAGE_ALLOCATE_BUFFER
                                       #$FORMAT_MESSAGE_FROM_SYSTEM
                                       #$FORMAT_MESSAGE_IGNORE_INSERTS
                                       #$FORMAT_MESSAGE_MAX_WIDTH_MASK)
                               (%null-ptr)
                               (abs error-number)
                               0                 ; default langid, more-or-less
                               pbuffer
                               0
                               (%null-ptr)))
      (format nil "Windows error ~d" (abs error-number))
      (let* ((p (%get-ptr pbuffer))
             (q (%get-native-utf-16-cstring p)))
        (#_LocalFree p)
        q))))
)
        
(defun %probe-shared-library (shlib)
  #-(or windows-target android-target freebsd-target)
  (with-cstrs ((name (shlib.pathname shlib)))
    (not (%null-ptr-p (#_dlopen name (logior #$RTLD_NOW #$RTLD_NOLOAD)))))
  ;; FreeBSD may support #$RTLD_NOLOAD in 8.0, and that support may
  ;; have been backported to 7.2.  Until then ...
  #+(or freebsd-target android-target)
  (rlet ((info #>Dl_info))
    (not (eql 0 (#_dladdr (shlib.base shlib) info))))
  #+windows-target
  (with-filename-cstrs ((name (shlib.pathname shlib)))
    (not (%null-ptr-p (#_GetModuleHandleW name)))))


;;; Kind of has something to do with files, and doesn't work in level-0.
(defun close-shared-library (lib &key (completely t))
  "If completely is T, set the reference count of library to 0. Otherwise,
decrements it by 1. In either case, if the reference count becomes 0,
close-shared-library frees all memory resources consumed library and causes
any EXTERNAL-ENTRY-POINTs known to be defined by it to become unresolved."
  (let* ((lib (if (typep lib 'string)
		(or (shared-library-with-name lib)
		    (error "Shared library ~s not found." lib))
		(require-type lib 'shlib)))
	 (handle (shlib.handle lib))
         (opencount (shlib.opencount lib)))
      (when handle
        (dotimes (i (if completely opencount 1))
          (unless #-windows-target (eql 0 (#_dlclose handle))
                  #+windows-target (not (eql 0(#_FreeLibrary handle)))
                  (return))
          (decf (shlib.opencount lib)))
        (when (and (eql 0 (shlib.opencount lib))
                   t #||(not (%probe-shared-library lib))||#)
          (setf (shlib.pathname lib) nil
                (shlib.base lib) nil
                (shlib.handle lib) nil
                (shlib.map lib) nil)
          (unload-foreign-variables nil)
          (unload-library-entrypoints nil)))))





;;; Foreign (unix) processes.

(defun call-with-string-vector (function strings encoding)
  (let* ((encoding (if (typep encoding 'character-encoding)
                     encoding
                     (get-character-encoding encoding)))
         (bufsize (reduce #'+ strings
                          :key #'(lambda (s)
                                   (let* ((string (string s)))
                                     (cstring-encoded-length-in-bytes encoding
                                                                      string
                                                                      0
                                                                      (length string))))))
         (argvsize (ash (1+ (length strings)) target::word-shift))
         (bufpos 0)
         (argvpos 0))        
    (%stack-block ((buf bufsize) (argv argvsize))
      (flet ((init (s)
               (multiple-value-bind (sstr start end) (get-sstring s)
                 (declare (fixnum start end))
                 (let* ((len (- (encode-string-to-memory encoding buf bufpos sstr start end) bufpos)))
                   (declare (fixnum len))
                   (setf (%get-byte buf (%i+ bufpos len)) 0)
                   (setf (%get-ptr argv argvpos) (%inc-ptr buf bufpos))
                   (setq bufpos (%i+ bufpos len 1))
                   (setq argvpos (%i+ argvpos target::node-size))))))
	(declare (dynamic-extent #'init))
	(map nil #'init strings))
      (setf (%get-ptr argv argvpos) (%null-ptr))
      (funcall function argv))))

(defmacro with-string-vector ((var strings &optional encoding) &body body)
  `(call-with-string-vector #'(lambda (,var) ,@body) ,strings ,encoding))

(defloadvar *max-os-open-files* #-(or windows-target android-target) (#_getdtablesize) #+windows-target 32 #+android-target (#_sysconf #$_SC_OPEN_MAX))

(defun pipe ()
  ;;  (rlet ((filedes (:array :int 2)))
  (%stack-block ((filedes 8))
    (let* ((status (ff-call (%kernel-import target::kernel-import-lisp-pipe)
                            :address filedes :int))
           (errno (if (eql status 0) 0 (%get-errno))))
      (unless (zerop status)
        (when (or (eql errno (- #$EMFILE))
                  (eql errno (- #$ENFILE)))
          (gc)
          (drain-termination-queue)
          (setq status (ff-call (%kernel-import target::kernel-import-lisp-pipe)
                            :address filedes :int)
                errno (if (zerop status) 0 (%get-errno)))))
      (if (zerop status)
        (values (paref filedes (:array :int)  0) (paref filedes (:array :int)  1))
        (%errno-disp errno)))))

#-windows-target
(progn
  (defun %execvp (argv)
    (#_execvp (%get-ptr argv) argv)
    (#_exit #-android-target #$EX_OSERR #+android-target 71))

  (defun exec-with-io-redirection (new-in new-out new-err argv)
    (#_setpgid 0 0)
    (if new-in (#_dup2 new-in 0))
    (if new-out (#_dup2 new-out 1))
    (if new-err (#_dup2 new-err 2))
    (do* ((fd 3 (1+ fd)))
         ((= fd *max-os-open-files*) (%execvp argv))
      (declare (fixnum fd))
      (#_close fd)))





  (defstruct external-process
    pid
    %status
    %exit-code
    pty
    input
    output
    error
    status-hook
    plist
    token                               
    core
    args
    (signal (make-semaphore))
    (completed (make-semaphore))
    watched-fds
    watched-streams
    external-format
    )

  (defmethod print-object ((p external-process) stream)
    (print-unreadable-object (p stream :type t :identity t)
      (let* ((status (external-process-%status p)))
        (let* ((*print-length* 3))
          (format stream "~a" (external-process-args p)))
        (format stream "[~d] (~a" (external-process-pid p) status)
        (unless (eq status :running)
          (format stream " : ~d" (external-process-%exit-code p)))
        (format stream ")"))))

  (defun get-descriptor-for (object proc close-in-parent close-on-error
                                    &rest keys
                                    &key direction (element-type 'character)
                                    (sharing :private)
                                    external-format
                                    &allow-other-keys)
    (etypecase object
      ((eql t)
       (values nil nil close-in-parent close-on-error))
      (null
       (let* ((null-device #+windows-target "nul" #-windows-target "/dev/null")
              (fd (fd-open null-device (case direction
                                         (:input #$O_RDONLY)
                                         (:output #$O_WRONLY)
                                         (t #$O_RDWR)))))
         (if (< fd 0)
           (signal-file-error fd null-device))
         (values fd nil (cons fd close-in-parent) (cons fd close-on-error))))
      ((eql :stream)
       (multiple-value-bind (read-pipe write-pipe) (pipe)
         (case direction
           (:input
            (values read-pipe
                    (make-fd-stream write-pipe
                                    :direction :output
                                    :element-type element-type
                                    :interactive nil
                                    :sharing sharing
                                    :basic t
                                    :encoding (external-format-character-encoding external-format)
                                    :line-termination (external-format-line-termination external-format)
                                    :auto-close t)
                    (cons read-pipe close-in-parent)
                    (cons write-pipe close-on-error)))
           (:output
            (values write-pipe
                    (make-fd-stream read-pipe
                                    :direction :input
                                    :element-type element-type
                                    :interactive t
                                    :basic t
                                    :sharing sharing
                                    :encoding (external-format-character-encoding external-format)
                                    :line-termination (external-format-line-termination external-format)
                                    :auto-close t)
                    (cons write-pipe close-in-parent)
                    (cons read-pipe close-on-error)))
           (t
            (fd-close read-pipe)
            (fd-close write-pipe)
            (report-bad-arg direction '(member :input :output))))))
      ((or pathname string)
       (with-open-stream (file (apply #'open object keys))
         (let* ((fd (fd-dup (ioblock-device (stream-ioblock file t)))))
           (values fd
                   nil
                   (cons fd close-in-parent)
                   (cons fd close-on-error)))))
      #||
      ;; What's an FD-STREAM ?
      (fd-stream
       (let ((fd (fd-dup (ioblock-device (stream-ioblock object t)))))
         (values fd
                 nil
                 (cons fd close-in-parent)
                 (cons fd close-on-error))))
      ||#
      (stream
       (ecase direction
         (:input
          (with-cstrs ((template #-android-target "/tmp/lisp-tempXXXXXX"
                                 #+android-target "/data/local/tmp/lisp-tempXXXXXX"))
            (let* ((fd (#_mkstemp template)))
              (if (< fd 0)
                (%errno-disp fd))
              (#_unlink template)
              (let* ((out (make-fd-stream (fd-dup fd)
                                          :direction :output
                                          :encoding (external-format-character-encoding external-format)
                                          :line-termination (external-format-line-termination external-format))))
                (loop
                  (multiple-value-bind (line no-newline)
                      (read-line object nil nil)
                    (unless line
                      (return))
                    (if no-newline
                      (write-string line out)
                      (write-line line out))))
                (close out))
              (fd-lseek fd 0 #$SEEK_SET)
              (values fd nil (cons fd close-in-parent) (cons fd close-on-error)))))
         (:output
          (multiple-value-bind (read-pipe write-pipe) (pipe)
            (push read-pipe (external-process-watched-fds proc))
            (push object (external-process-watched-streams proc))
            (incf (car (external-process-token proc)))
            (values write-pipe
                    nil
                    (cons write-pipe close-in-parent)
                    (cons read-pipe close-on-error))))))))

  (let* ((external-processes ())
         (external-processes-lock (make-lock)))
    (defun add-external-process (p)
      (with-lock-grabbed (external-processes-lock)
        (push p external-processes)))
    (defun remove-external-process (p)
      (with-lock-grabbed (external-processes-lock)
        (setq external-processes (delete p external-processes))))
    ;; Likewise
    (defun external-processes ()
      (with-lock-grabbed (external-processes-lock)
        (copy-list external-processes)))
    )


  (defmacro wtermsig (status)
    `(ldb (byte 7 0) ,status))

  (defmacro wexitstatus (status)
    `(ldb (byte 8 8) (the fixnum ,status)))

  (defmacro wstopsig (status)
    `(wexitstatus ,status))

  (defmacro wifexited (status)
    `(eql (wtermsig ,status) 0))

  (defmacro wifstopped (status)
    `(eql #x7f (ldb (byte 7 0) (the fixnum ,status))))

  (defun monitor-external-process (p)
    (let* ((in-fds (external-process-watched-fds p))
           (out-streams (external-process-watched-streams p))
           (token (external-process-token p))
           (terminated)
           (changed)
           (maxfd 0)
           (external-format (external-process-external-format p))
           (encoding (external-format-character-encoding external-format))
           (line-termination (external-format-line-termination external-format))
           (pairs (pairlis
                   (mapcar (lambda (fd)
                             (cons fd
                                   (make-fd-stream fd
                                                   :direction :input
                                                   :sharing :private
                                                   :encoding encoding
                                                   :interactive t
                                                   :line-termination line-termination)))
                                     in-fds) out-streams)))
      (%stack-block ((in-fd-set *fd-set-size*))
        (rlet ((tv #>timeval))
          (loop
            (when changed
              (setq pairs (delete nil pairs :key #'car)
                    changed nil))
            (when (and terminated (null pairs))
              (signal-semaphore (external-process-completed p))
              (return))
            (when pairs
              (fd-zero in-fd-set)
              (setq maxfd 0)
              (dolist (p pairs)
                (let* ((fd (caar p)))
                  (when (> fd maxfd)
                    (setq maxfd fd))
                  (fd-set fd in-fd-set)))
              (setf (pref tv #>timeval.tv_sec) 1
                    (pref tv #>timeval.tv_usec) 0)
              (when (> (#_select (1+ maxfd) in-fd-set (%null-ptr) (%null-ptr) tv)
                       0)
                (dolist (p pairs)
                  (let* ((in-fd (caar p))
                         (in-stream (cdar p))
                         (out-stream (cdr p)))
                    (when (fd-is-set in-fd in-fd-set)
                      (let* ((buf (make-string 1024))
                             (n (ignore-errors (read-sequence buf in-stream))))
                        (declare (dynamic-extent buf))
                        (if (or (null n) (eql n 0))
                          (without-interrupts
                           (decf (car token))
                           (close in-stream)
                           (setf (car p) nil changed t))
                          (write-sequence buf out-stream :end n))))))))
            (let* ((statusflags (check-pid (external-process-pid p)
                                           (logior
                                            (if in-fds #$WNOHANG 0)
                                            #$WUNTRACED)))
                   (oldstatus (external-process-%status p)))
              (cond ((null statusflags)
                     (remove-external-process p)
                     (setq terminated t))
                    ((eq statusflags t)) ; Running.
                    (t
                     (multiple-value-bind (status code core)
                         (cond ((wifstopped statusflags)
                                (values :stopped (wstopsig statusflags)))
                               ((wifexited statusflags)
                                (values :exited (wexitstatus statusflags)))
                               (t
                                (let* ((signal (wtermsig statusflags)))
                                  (declare (fixnum signal))
                                  (values
                                   (if (or (= signal #$SIGSTOP)
                                           (= signal #$SIGTSTP)
                                           (= signal #$SIGTTIN)
                                           (= signal #$SIGTTOU))
                                     :stopped
                                     :signaled)
                                   signal
                                   (logtest #-(or solaris-target android-target)
                                            #$WCOREFLAG
                                            #+solaris-target #$WCOREFLG
                                            #+android-target #x80
                                            statusflags)))))
                       (setf (external-process-%status p) status
                             (external-process-%exit-code p) code
                             (external-process-core p) core)
                       (let* ((status-hook (external-process-status-hook p)))
                         (when (and status-hook (not (eq oldstatus status)))
                           (funcall status-hook p)))
                       (when (or (eq status :exited)
                                 (eq status :signaled))
                         (remove-external-process p)
                         (setq terminated t)))))))))))
      
  (defun run-external-process (proc in-fd out-fd error-fd argv &optional env)
    (let* ((signaled nil))
      (unwind-protect
           (let* ((child-pid (#-solaris-target #_fork #+solaris-target #_forkall)))
             (declare (fixnum child-pid))
             (cond ((zerop child-pid)
                    ;; Running in the child; do an exec
                    (setq signaled t)
                    (dolist (pair env)
                      (setenv (string (car pair)) (cdr pair)))
                    (without-interrupts
                     (exec-with-io-redirection
                      in-fd out-fd error-fd argv)))
                   ((> child-pid 0)
                    ;; Running in the parent: success
                    (setf (external-process-pid proc) child-pid)
                    (add-external-process proc)
                    (signal-semaphore (external-process-signal proc))
                    (setq signaled t)
                    (monitor-external-process proc))
                   (t
                    ;; Fork failed
                    (setf (external-process-%status proc) :error
                          (external-process-%exit-code proc) (%get-errno))
                    (signal-semaphore (external-process-signal proc))
                    (setq signaled t))))
        (unless signaled
          (setf (external-process-%status proc) :error
                (external-process-%exit-code proc) -1)
          (signal-semaphore (external-process-signal proc))))))

  (defparameter *silently-ignore-catastrophic-failure-in-run-program* nil
    "If NIL, signal an error if run-program is unable to start the program.
If non-NIL, treat failure to start the same as failure from the program
itself, by setting the status and exit-code fields.")

  (defun run-program (program args &key
                              (wait t) pty
                              input if-input-does-not-exist
                              output (if-output-exists :error)
                              (error :output) (if-error-exists :error)
                              status-hook (element-type 'character)
                              env
                              (sharing :private)
                              (external-format `(:character-encoding ,*terminal-character-encoding-name*))
                              (silently-ignore-catastrophic-failures
                               *silently-ignore-catastrophic-failure-in-run-program*))
    "Invoke an external program as an OS subprocess of lisp."
    (declare (ignore pty))
    (unless (every #'(lambda (a) (typep a 'simple-string)) args)
      (error "Program args must all be simple strings : ~s" args))
    (setq external-format (normalize-external-format t external-format))
    (dolist (pair env)
      (destructuring-bind (var . val) pair
        (check-type var (or string symbol character))
        (check-type val string)))
    (push (native-untranslated-namestring program) args)
    (let* ((token (list 0))
           (in-fd nil)
           (in-stream nil)
           (out-fd nil)
           (out-stream nil)
           (error-fd nil)
           (error-stream nil)
           (close-in-parent nil)
           (close-on-error nil)
           (proc
            (make-external-process
             :pid nil
             :args args
             :%status :running
             :input nil
             :output nil
             :error nil
             :token token
             :status-hook status-hook
             :external-format (setq external-format (normalize-external-format t external-format)))))
      (unwind-protect
           (progn
             (multiple-value-setq (in-fd in-stream close-in-parent close-on-error)
               (get-descriptor-for input proc  nil nil :direction :input
                                   :if-does-not-exist if-input-does-not-exist
                                   :element-type element-type
                                   :sharing sharing
                                   :external-format external-format))
             (multiple-value-setq (out-fd out-stream close-in-parent close-on-error)
               (get-descriptor-for output proc close-in-parent close-on-error
                                   :direction :output
                                   :if-exists if-output-exists
                                   :element-type element-type
                                   :sharing sharing
                                   :external-format external-format))
             (multiple-value-setq (error-fd error-stream close-in-parent close-on-error)
               (if (eq error :output)
                 (values out-fd out-stream close-in-parent close-on-error)
                 (get-descriptor-for error proc close-in-parent close-on-error
                                     :direction :output
                                     :if-exists if-error-exists
                                     :sharing sharing
                                     :element-type element-type
                                     :external-format external-format)))
             (setf (external-process-input proc) in-stream
                   (external-process-output proc) out-stream
                   (external-process-error proc) error-stream)
             (call-with-string-vector
              #'(lambda (argv)
                  (process-run-function
                   (list :name
                         (format nil "Monitor thread for external process ~a" args)
                         :stack-size (ash 128 10)
                         :vstack-size (ash 128 10)
                         :tstack-size (ash 128 10))
                   #'run-external-process proc in-fd out-fd error-fd argv env)
                  (wait-on-semaphore (external-process-signal proc)))
              args
              (external-format-character-encoding external-format)))
        (dolist (fd close-in-parent) (fd-close fd))
        (unless (external-process-pid proc)
          (dolist (fd close-on-error) (fd-close fd)))
        (when (and wait (external-process-pid proc))
          (with-interrupts-enabled
              (wait-on-semaphore (external-process-completed proc)))))
      (unless (external-process-pid proc)
        ;; something is wrong
        (if (eq (external-process-%status proc) :error)
          ;; Fork failed
          (unless silently-ignore-catastrophic-failures
            (cerror "Pretend the program ran and failed" 'external-process-creation-failure :proc proc))
          ;; Currently can't happen.
          (error "Bug: fork failed but status field not set?")))
      proc))



  (defmacro wifsignaled (status)
    (let* ((statname (gensym)))
      `(let* ((,statname ,status))
        (and (not (wifstopped ,statname)) (not (wifexited ,statname))))))


  (defun check-pid (pid &optional (flags (logior  #$WNOHANG #$WUNTRACED)))
    (declare (fixnum pid))
    (rlet ((status :signed))
      (let* ((retval (ff-call-ignoring-eintr (#_waitpid pid status flags))))
        (declare (fixnum retval))
        (if (= retval pid)
          (pref status :signed)
          (zerop retval)))))





  (defun external-process-wait (proc &optional check-stopped)
    (process-wait "external-process-wait"
                  #'(lambda ()
                      (case (external-process-%status proc)
                        (:running)
                        (:stopped
                         (when check-stopped
                           t))
                        (t
                         (when (zerop (car (external-process-token proc)))
                           t))))))
  
  (defun signal-external-process (proc signal &key (error-if-exited t))
    "Send the specified signal to the specified external process.  (Typically,
it would only be useful to call this function if the EXTERNAL-PROCESS was
created with :WAIT NIL.) Return T if successful; NIL if the process wasn't
created successfully, and signal an error otherwise."
    (require-type proc 'external-process)
    (let* ((pid (external-process-pid proc)))
      (when pid
        (let ((error (int-errno-call (#_kill pid signal))))
          (or (eql error 0)
              (unless (and (eql error (- #$ESRCH))
                           (not error-if-exited))
                (%errno-disp error)))))))

  )                                     ; #-windows-target (progn

#+windows-target
(progn
  (defun temp-file-name (prefix)
    "Returns a unique name for a temporary file, residing in system temp
space, and prefixed with PREFIX."
    (rlet ((buffer (:array :wchar_t #.#$MAX_PATH)))
      (#_GetTempPathW #$MAX_PATH buffer)
      (with-filename-cstrs ((c-prefix prefix)) 
        (#_GetTempFileNameW buffer c-prefix 0 buffer)
        (%get-native-utf-16-cstring buffer))))
  
  (defun get-descriptor-for (object proc close-in-parent close-on-error
                                    &rest keys
                                    &key
                                    direction (element-type 'character)
                                    (sharing :private)
                                    external-format
                                    &allow-other-keys)
    (etypecase object
      ((eql t)
       (values nil nil close-in-parent close-on-error))
      (null
       (let* ((null-device "nul")
              (fd (fd-open null-device (case direction
                                         (:input #$O_RDONLY)
                                         (:output #$O_WRONLY)
                                         (t #$O_RDWR)))))
         (if (< fd 0)
           (signal-file-error fd null-device))
         (values fd nil (cons fd close-in-parent) (cons fd close-on-error))))
      ((eql :stream)
       (multiple-value-bind (read-pipe write-pipe) (pipe)
         (case direction
           (:input
            (values read-pipe
                    (make-fd-stream (fd-uninheritable write-pipe :direction :output)
                                    :direction :output
                                    :element-type element-type
                                    :interactive nil
                                    :basic t
                                    :sharing sharing
                                    :encoding (external-format-character-encoding external-format)
                                    :line-termination (external-format-line-termination external-format)
                                    :auto-close t)
                    (cons read-pipe close-in-parent)
                    (cons write-pipe close-on-error)))
           (:output
            (values write-pipe
                    (make-fd-stream (fd-uninheritable read-pipe :direction :input)
                                    :direction :input
                                    :element-type element-type
                                    :interactive t
                                    :basic t
                                    :sharing sharing
                                    :encoding (external-format-character-encoding external-format)
                                    :line-termination (external-format-line-termination external-format)
                                    :auto-close t)
                    (cons write-pipe close-in-parent)
                    (cons read-pipe close-on-error)))
           (t
            (fd-close read-pipe)
            (fd-close write-pipe)
            (report-bad-arg direction '(member :input :output))))))
      ((or pathname string)
       (with-open-stream (file (apply #'open object keys))
         (let* ((fd (fd-dup (ioblock-device (stream-ioblock file t)) :direction direction :inheritable t)))
           (values fd
                   nil
                   (cons fd close-in-parent)
                   (cons fd close-on-error)))))
      (stream
       (ecase direction
         (:input
          (let* ((tempname (temp-file-name "lisp-temp"))
                 (fd (fd-open tempname #$O_RDWR)))
            (if (< fd 0)
              (%errno-disp fd))
            (let* ((out (make-fd-stream (fd-dup fd)
                                        :direction :output
                                        :encoding (external-format-character-encoding external-format)
                                        :line-termination (external-format-line-termination external-format))))            
              (loop
                (multiple-value-bind (line no-newline)
                    (read-line object nil nil)
                  (unless line
                    (return))
                  (if no-newline
                    (write-string line out)
                    (write-line line out))
                  ))
              (close out))
            (fd-lseek fd 0 #$SEEK_SET)
            (values fd nil (cons fd close-in-parent) (cons fd close-on-error))))
         (:output
          (multiple-value-bind (read-pipe write-pipe) (pipe)
            (push read-pipe (external-process-watched-fds proc))
            (push object (external-process-watched-streams proc))
            (incf (car (external-process-token proc)))
            (values write-pipe
                    nil
                    (cons write-pipe close-in-parent)
                    (cons read-pipe close-on-error))))))))

  (defstruct external-process
    pid
    %status
    %exit-code
    pty
    input
    output
    error
    status-hook
    plist
    token
    core
    args
    (signal (make-semaphore))
    (completed (make-semaphore))
    watched-fds
    watched-streams
    external-format
    )



  (defmethod print-object ((p external-process) stream)
    (print-unreadable-object (p stream :type t :identity t)
      (let* ((status (external-process-%status p)))
        (let* ((*print-length* 3))
          (format stream "~a" (external-process-args p)))
        (format stream "[~d] (~a" (external-process-pid p) status)
        (unless (eq status :running)
          (format stream " : ~d" (external-process-%exit-code p)))
        (format stream ")"))))

  (defun run-program (program args &key
                              (wait t) pty
                              input if-input-does-not-exist
                              output (if-output-exists :error)
                              (error :output) (if-error-exists :error)
                              status-hook (element-type 'character)
                              (sharing :private)
                              (external-format `(:character-encoding ,*terminal-character-encoding-name* :line-termination :crlf))
                              env)
    "Invoke an external program as an OS subprocess of lisp."
    (declare (ignore pty))
    (push program args)
    (unless (do* ((args args (cdr args)))
                 ((atom args)
                  (or (typep args 'simple-string)
                      (null args)))
              (unless (typep (car args) 'simple-string)
                (return)))
      (error "Program args must all be simple strings : ~s" args))
    (let* ((token (list 0))
           (in-fd nil)
           (in-stream nil)
           (out-fd nil)
           (out-stream nil)
           (error-fd nil)
           (error-stream nil)
           (close-in-parent nil)
           (close-on-error nil)
           (proc
            (make-external-process
             :pid nil
             :args args
             :%status :running
             :input nil
             :output nil
             :error nil
             :token token
             :external-format (setq external-format (normalize-external-format t external-format))
             :status-hook status-hook)))
      (unwind-protect
           (progn
             (multiple-value-setq (in-fd in-stream close-in-parent close-on-error)
               (get-descriptor-for input proc  nil nil :direction :input
                                   :if-does-not-exist if-input-does-not-exist
                                   :sharing sharing
                                   :element-type element-type
                                   :external-format external-format))
             (multiple-value-setq (out-fd out-stream close-in-parent close-on-error)
               (get-descriptor-for output proc close-in-parent close-on-error
                                   :direction :output
                                   :if-exists if-output-exists
                                   :sharing sharing
                                   :element-type element-type
                                   :external-format external-format))
             (multiple-value-setq (error-fd error-stream close-in-parent close-on-error)
               (if (eq error :output)
                 (values out-fd out-stream close-in-parent close-on-error)
                 (get-descriptor-for error proc close-in-parent close-on-error
                                     :direction :output
                                     :if-exists if-error-exists
                                     :sharing sharing
                                     :element-type element-type
                                     :external-format external-format)))
             (setf (external-process-input proc) in-stream
                   (external-process-output proc) out-stream
                   (external-process-error proc) error-stream)
             (process-run-function
              (format nil "Monitor thread for external process ~a" args)
                    
              #'run-external-process proc in-fd out-fd error-fd env)
             (wait-on-semaphore (external-process-signal proc))
             )
        (dolist (fd close-in-parent) (fd-close fd))
        (if (external-process-pid proc)
          (when (and wait (external-process-pid proc))
            (with-interrupts-enabled
                (wait-on-semaphore (external-process-completed proc))))
          (progn
            (dolist (fd close-on-error) (fd-close fd)))))
      proc))

  (let* ((external-processes ())
         (external-processes-lock (make-lock)))
    (defun add-external-process (p)
      (with-lock-grabbed (external-processes-lock)
        (push p external-processes)))
    (defun remove-external-process (p)
      (with-lock-grabbed (external-processes-lock)
        (setq external-processes (delete p external-processes))))
    ;; Likewise
    (defun external-processes ()
      (with-lock-grabbed (external-processes-lock)
        (copy-list external-processes)))
    )




  (defun run-external-process (proc in-fd out-fd error-fd &optional env)
    (let* ((args (external-process-args proc))
           (child-pid (exec-with-io-redirection in-fd out-fd error-fd args proc env)))
      (when child-pid
        (setf (external-process-pid proc) child-pid)
        (add-external-process proc)
        (signal-semaphore (external-process-signal proc))
        (monitor-external-process proc))))

  (defun make-windows-command-line (strings)
    (with-output-to-string (out)
      (do* ((strings strings (cdr strings)))
           ((atom strings)     
            (if strings (write-string strings out)))
        (let* ((string (car strings))
               (n (length string))
               (quote-backslash 0)
               (literal-backslash 0))
          (declare (fixnum n quote-backslash literal-backslash))
          (dotimes (i n)
            (let* ((c (schar string i)))
              (case c
                (#\\
                 (unless (or (> quote-backslash 0)
                             (> literal-backslash 0))
                   (do* ((j i (1+ j))
                         (k 0))
                        ((= j n) (setq literal-backslash k))
                     (case (schar string j)
                       (#\\ (incf k))
                       ((#\space #\tab #\")
                        (setq quote-backslash k)
                        (return))
                       (t (setq literal-backslash k)
                          (return)))))
                 (if (> quote-backslash 0)
                   (progn
                     (write-char #\\ out)
                     (write-char #\\ out)
                     (decf quote-backslash))
                   (progn
                     (write-char #\\ out)
                     (decf literal-backslash))))
                ((#\space #\tab)
                 (write-char #\" out)
                 (write-char c out)
                 (write-char #\" out))
                (#\"
                 (write-char #\\ out)
                 (write-char #\" out))
                (t (write-char c out)))))
          (when (cdr strings) (write-char #\space out))))))

  (defun create-windows-process (new-in new-out new-err cmdstring env)
    (declare (ignore env))              ; until we can do better.
    (with-filename-cstrs ((command cmdstring))
      (rletz ((proc-info #>PROCESS_INFORMATION)
              (si #>STARTUPINFO))
        (setf (pref si #>STARTUPINFO.cb) (record-length #>STARTUPINFO))
        (setf (pref si #>STARTUPINFO.dwFlags)
              (logior #$STARTF_USESTDHANDLES #$STARTF_USESHOWWINDOW))
        (setf (pref si #>STARTUPINFO.wShowWindow) #$SW_HIDE)
        (setf (pref si #>STARTUPINFO.hStdInput)
              (if new-in
                (%int-to-ptr new-in)
                (#_GetStdHandle #$STD_INPUT_HANDLE)))
        (setf (pref si #>STARTUPINFO.hStdOutput)
              (if new-out
                (%int-to-ptr new-out)
                (#_GetStdHandle #$STD_OUTPUT_HANDLE)))
        (setf (pref si #>STARTUPINFO.hStdError)
              (if new-err
                (%int-to-ptr new-err)
                (#_GetStdHandle #$STD_ERROR_HANDLE)))
        (if (zerop (#_CreateProcessW (%null-ptr)
                                     command
                                     (%null-ptr)
                                     (%null-ptr)
                                     1
                                     #$CREATE_NEW_CONSOLE
                                     (%null-ptr)
                                     (%null-ptr)
                                     si
                                     proc-info))
          (values nil (#_GetLastError))
          (progn
            (#_CloseHandle (pref proc-info #>PROCESS_INFORMATION.hThread))
            (values t (pref proc-info #>PROCESS_INFORMATION.hProcess)))))))

  (defun exec-with-io-redirection (new-in new-out new-err args proc &optional env)
    (multiple-value-bind (win handle-to-process-or-error)
        (create-windows-process new-in new-out new-err (make-windows-command-line args) env)
      (if win
        handle-to-process-or-error
        (progn
          (setf (external-process-%status proc) :error
                (external-process-%exit-code proc) handle-to-process-or-error)
          (signal-semaphore (external-process-signal proc))
          (signal-semaphore (external-process-completed proc))
          nil))))

  (defun fd-uninheritable (fd &key direction)
    (let ((new-fd (fd-dup fd :direction direction)))
      (fd-close fd)
      new-fd))

  
  (defun data-available-on-pipe-p (hpipe)
    (rlet ((navail #>DWORD 0))
      (unless (eql 0 (#_PeekNamedPipe (if (typep hpipe 'macptr)
                                        hpipe
                                        (%int-to-ptr hpipe))
                                      (%null-ptr)
                                      0
                                      (%null-ptr)
                                      navail
                                      (%null-ptr)))
        (not (eql 0 (pref navail #>DWORD))))))
    

  ;;; There doesn't seem to be any way to wait on input from an
  ;;; anonymous pipe in Windows (that would, after all, make too
  ;;; much sense.)  We -can- check for pending unread data on
  ;;; pipes, and can expect to eventually get EOF on a pipe.
  ;;; So, this tries to loop until the process handle is signaled and
  ;;; all data has been read.
  (defun monitor-external-process (p)
    (let* ((in-fds (external-process-watched-fds p))
           (out-streams (external-process-watched-streams p))
           (token (external-process-token p))
           (terminated)
           (changed)
           (external-format (external-process-external-format p))
           (encoding (external-format-character-encoding external-format))
           (line-termination (external-format-line-termination external-format))
           (pairs (pairlis (mapcar (lambda (fd)
                                     (cons fd
                                           (make-fd-stream fd
                                                           :direction :input
                                                           :sharing :private
                                                           :encoding encoding
                                                           :interactive t
                                                           :line-termination line-termination)))
                                   in-fds)
                           out-streams))
           )
      (loop
        (when changed
          (setq pairs (delete nil pairs :key #'car)
                changed nil))
        (when (and terminated (null pairs))
          (without-interrupts
           (rlet ((code #>DWORD))
             (loop
               (#_GetExitCodeProcess (external-process-pid p) code)
               (unless (eql (pref code #>DWORD) #$STILL_ACTIVE)
                 (return))
               (#_SleepEx 10 #$TRUE))
             (setf (external-process-%exit-code p) (pref code #>DWORD)))
           (#_CloseHandle (external-process-pid p))
           (setf (external-process-pid p) nil)
           (setf (external-process-%status p) :exited)
           (let ((status-hook (external-process-status-hook p)))
             (when status-hook
               (funcall status-hook p)))
           (remove-external-process p)
           (signal-semaphore (external-process-completed p))
           (return)))
        (dolist (p pairs)
          (let* ((in-fd (caar p))
                 (in-stream (cdar p))
                 (out-stream (cdr p)))
            (when (or terminated (data-available-on-pipe-p in-fd))
              (let* ((buf (make-string 1024)))
                (declare (dynamic-extent buf))
                (let* ((n (ignore-errors (read-sequence buf in-stream))))
                  (if (or (null n) (eql n 0))
                    (progn
                      (without-interrupts
                       (decf (car token))
                       (fd-close in-fd)
                       (setf (car p) nil changed t)))
                    (progn
                      (write-sequence buf out-stream :end n)
                      (force-output out-stream))))))))
        (unless terminated
          (setq terminated (eql (#_WaitForSingleObjectEx
                                 (external-process-pid p)
                                 1000
                                 #$true)
                                #$WAIT_OBJECT_0))))))
  

  (defun signal-external-process (proc signal)
    "Does nothing on Windows"
    (declare (ignore signal))
    (require-type proc 'external-process)
    nil)  


  )
                                        ;#+windows-target (progn


(defun external-process-input-stream (proc)
  "Return the lisp stream which is used to write input to a given OS
subprocess, if it has one."
  (require-type proc 'external-process)
  (external-process-input proc))

(defun external-process-output-stream (proc)
  "Return the lisp stream which is used to read output from a given OS
subprocess, if there is one."
  (require-type proc 'external-process)
  (external-process-output proc))

(defun external-process-error-stream (proc)
  "Return the stream which is used to read error output from a given OS
subprocess, if it has one."
  (require-type proc 'external-process)
  (external-process-error proc))

(defun external-process-id (proc)
  "Return the process id of an OS subprocess, a positive integer which
identifies it."
  (require-type proc 'external-process)
  (external-process-pid proc))

(defun external-process-status (proc)
  "Return information about whether an OS subprocess is running; or, if
not, why not; and what its result code was if it completed."
  (require-type proc 'external-process)
  (values (external-process-%status proc)
          (external-process-%exit-code proc)))

;;; EOF on a TTY is transient, but I'm less sure of other cases.
(defun eof-transient-p (fd)
  (case (%unix-fd-kind fd)
    (:tty t)
    #+windows-target (:character-special t)
    (t nil)))


(defstruct (shared-resource (:constructor make-shared-resource (name)))
  (name)
  (lock (make-lock))
  (primary-owner *current-process*)
  (primary-owner-notify (make-semaphore))
  (current-owner nil)
  (requestors (make-dll-header)))

(defstruct (shared-resource-request
	     (:constructor make-shared-resource-request (process))
	     (:include dll-node))
  process
  (signal (make-semaphore)))
	     

;; Returns NIL if already owned by calling thread, T otherwise
(defun %acquire-shared-resource (resource  &optional verbose)
  (let* ((current *current-process*))
    (with-lock-grabbed ((shared-resource-lock resource))
      (let* ((secondary (shared-resource-current-owner resource)))
	(if (or (eq current secondary)
		(and (null secondary)
		     (eq current (shared-resource-primary-owner resource))))
	  (return-from %acquire-shared-resource nil))))
    (let* ((request (make-shared-resource-request *current-process*)))
      (when verbose
	(format t "~%~%;;;~%;;; ~a requires access to ~a~%;;; Type (:y ~D) to yield control to this thread.~%;;;~%"
		*current-process* (shared-resource-name resource)
                (process-serial-number *current-process*))
        (force-output t))
      (with-lock-grabbed ((shared-resource-lock resource))
	(append-dll-node request (shared-resource-requestors resource)))
      (wait-on-semaphore (shared-resource-request-signal request))
      (assert (eq current (shared-resource-current-owner resource)))
      (when verbose
	(format t "~%~%;;;~%;;; ~a is now owned by ~a~%;;;~%~%"
		(shared-resource-name resource) current))
      t)))

;;; If we're the primary owner and there is no secondary owner, do nothing.
;;; If we're the secondary owner, cease being the secondary owner.
(defun %release-shared-resource (r)
  (let* ((not-any-owner ()))
    (with-lock-grabbed ((shared-resource-lock r))
      (let* ((current *current-process*)
	     (primary (shared-resource-primary-owner r))
	     (secondary (shared-resource-current-owner r)))
	(unless (setq not-any-owner
		      (not (or (eq current secondary)
                               (and (null secondary)
                                    (eq current primary)))))
	  (when (eq current secondary)
	    (setf (shared-resource-current-owner r) nil)
	    (signal-semaphore (shared-resource-primary-owner-notify r))))))
    (when not-any-owner
      (signal-program-error "Process ~a does not own ~a" *current-process*
			    (shared-resource-name r)))))

;;; The current thread should be the primary owner; there should be
;;; no secondary owner.  Wakeup the specified (or first) requesting
;;; process, then block on our semaphore 
(defun %yield-shared-resource (r &optional to)
  (let* ((request nil))
    (with-lock-grabbed ((shared-resource-lock r))
      (let* ((current *current-process*)
	     (primary (shared-resource-primary-owner r)))
	(when (and (eq current primary)
		   (null (shared-resource-current-owner r)))
	  (setq request
		(let* ((header (shared-resource-requestors r)))
		  (if to 
		    (do-dll-nodes (node header)
		      (when (eq to (shared-resource-request-process node))
			(return node)))
		    (let* ((first (dll-header-first header)))
		      (unless (eq first header)
			first)))))
	  (when request
	    (remove-dll-node request)
            (setf (shared-resource-current-owner r)
                  (shared-resource-request-process request))
	    (signal-semaphore (shared-resource-request-signal request))))))
    (when request
      (wait-on-semaphore (shared-resource-primary-owner-notify r))
      (format t "~%;;;~%;;;control of ~a restored to ~a~%;;;~&"
	      (shared-resource-name r)
	      *current-process*))))


      

(defun %shared-resource-requestor-p (r proc)
  (with-lock-grabbed ((shared-resource-lock r))
    (do-dll-nodes (node (shared-resource-requestors r))
      (when (eq proc (shared-resource-request-process node))
	(return t)))))

(defparameter *resident-editor-hook* nil
  "If non-NIL, should be a function that takes an optional argument
   (like ED) and invokes a \"resident\" editor.")

(defun ed (&optional arg)
  (if *resident-editor-hook*
    (funcall *resident-editor-hook* arg)
    (error "This implementation doesn't provide a resident editor.")))

(defun running-under-emacs-p ()
  (not (null (getenv "EMACS"))))

(defloadvar *cpu-count* nil)

(defun cpu-count ()
  (or *cpu-count*
      (setq *cpu-count*
            #+darwin-target
            (rlet ((info :host_basic_info)
                   (count :mach_msg_type_number_t #$HOST_BASIC_INFO_COUNT))
              (if (eql #$KERN_SUCCESS (#_host_info (#_mach_host_self)
                                                   #$HOST_BASIC_INFO
                                                   info
                                                   count))
                (pref info :host_basic_info.max_cpus)
                1))
            #+(or linux-target solaris-target)
            (or
             (let* ((n (#_sysconf #$_SC_NPROCESSORS_CONF)))
               (declare (fixnum n))
               (if (> n 0) n))
             #+linux-target
             (ignore-errors
               (with-open-file (p "/proc/cpuinfo")
                 (let* ((ncpu 0)
                        (match "processor")
                        (matchlen (length match)))
                   (do* ((line (read-line p nil nil) (read-line p nil nil)))
                        ((null line) ncpu)
                     (let* ((line-length (length line)))
                       (when (and
                              (> line-length matchlen)
                              (string= match line
                                       :end2 matchlen)
                              (whitespacep (schar line matchlen)))
                         (incf ncpu)))))))
             1)
            #+freebsd-target
            (rlet ((ret :uint))
              (%stack-block ((mib (* (record-length :uint) 2)))
              (setf (paref mib (:array :uint) 0)
                    #$CTL_HW
                    (paref mib (:array :uint) 1)
                    #$HW_NCPU)
              (rlet ((oldsize :uint (record-length :uint)))
                (if (eql 0 (#_sysctl mib 2 ret oldsize (%null-ptr) 0))
                  (pref ret :uint)
                  1))))
            #+windows-target
            (rlet ((procmask #>DWORD_PTR)
                   (sysmask #>DWORD_PTR))
              (if (eql 0 (#_GetProcessAffinityMask (#_GetCurrentProcess) procmask sysmask))
                1
                (logcount (pref sysmask #>DWORD_PTR)))))))

(def-load-pointers spin-count ()
  (if (eql 1 (cpu-count))
    (%defglobal '*spin-lock-tries* 1)
    (%defglobal '*spin-lock-tries* 1024))
  (%defglobal '*spin-lock-timeouts* 0))

(defun yield ()
  (process-allow-schedule))

(defloadvar *host-page-size*
    #-(or windows-target android-target)
    (#_getpagesize)
    #+windows-target
    (rlet ((info #>SYSTEM_INFO))
      (#_GetSystemInfo info)
      (pref info #>SYSTEM_INFO.dwPageSize))
    #+android-target
    (#_sysconf #$_SC_PAGE_SIZE)
    )

;;(assert (= (logcount *host-page-size*) 1))


(defun same-fd-p (a b)
  (or (eql a b)
      #-windows-target
      (let* ((a-stat (multiple-value-list (%fstat a)))
             (b-stat (multiple-value-list (%fstat b))))
        (declare (dynamic-extent a-stat b-stat))
        (and (car a-stat) (car b-stat)
             (eql (nth 9 a-stat)
                  (nth 9 b-stat))
             (eql (nth 4 a-stat)
                  (nth 4 b-stat))))
      #+windows-target
      (%stack-block ((a-info (record-length #>BY_HANDLE_FILE_INFORMATION))
                     (b-info (record-length #>BY_HANDLE_FILE_INFORMATION)))
        (unless (or (eql 0 (#_GetFileInformationByHandle (%int-to-ptr a) a-info))
                    (eql 0 (#_GetFileInformationByHandle (%int-to-ptr b) b-info)))
          (and (eql (pref a-info #>BY_HANDLE_FILE_INFORMATION.dwVolumeSerialNumber)
                    (pref b-info #>BY_HANDLE_FILE_INFORMATION.dwVolumeSerialNumber))
               (eql (pref a-info #>BY_HANDLE_FILE_INFORMATION.nFileIndexHigh)
                    (pref b-info #>BY_HANDLE_FILE_INFORMATION.nFileIndexHigh))
               (eql (pref a-info #>BY_HANDLE_FILE_INFORMATION.nFileIndexLow)
                    (pref b-info #>BY_HANDLE_FILE_INFORMATION.nFileIndexLow)))))))

  
(defun get-universal-time ()
  "Return a single integer for the current time of
   day in universal time format."
  (rlet ((tv :timeval))
    (gettimeofday tv)
    (+ (pref tv :timeval.tv_sec) unix-to-universal-time)))

#+windows-target
(defloadvar *windows-allocation-granularity*
    (rlet ((info #>SYSTEM_INFO))
      (#_GetSystemInfo info)
      (pref info #>SYSTEM_INFO.dwAllocationGranularity)))

#-windows-target
(defun %memory-map-fd (fd len bits-per-element)
  (let* ((nbytes (+ *host-page-size*
                    (logandc2 (+ len
                                 (1- *host-page-size*))
                              (1- *host-page-size*))))         
         (ndata-elements
          (ash len
               (ecase bits-per-element
                 (1 3)
                 (8 0)
                 (16 -1)
                 (32 -2)
                 (64 -3))))
         (nalignment-elements
          (ash target::nbits-in-word
               (ecase bits-per-element
                 (1 0)
                 (8 -3)
                 (16 -4)
                 (32 -5)
                 (64 -6)))))
    (if (>= (+ ndata-elements nalignment-elements)
            array-total-size-limit)
      (progn
        (fd-close fd)
        (error "Can't make a vector with ~s elements in this implementation." (+ ndata-elements nalignment-elements)))
      (let* ((addr (#_mmap (%null-ptr)
                           nbytes
                           #$PROT_NONE
                           (logior #$MAP_ANON #$MAP_PRIVATE)
                           -1
                           0)))              
        (if (eql addr (%int-to-ptr (1- (ash 1 target::nbits-in-word)))) ; #$MAP_FAILED
          (let* ((errno (%get-errno)))
            (fd-close fd)
            (error "Can't map ~d bytes: ~a" nbytes (%strerror errno)))
              ;;; Remap the first page so that we can put a vector header
              ;;; there; use the first word on the first page to remember
              ;;; the file descriptor.
          (progn
            (#_mmap addr
                    *host-page-size*
                    (logior #$PROT_READ #$PROT_WRITE)
                    (logior #$MAP_ANON #$MAP_PRIVATE #$MAP_FIXED)
                    -1
                    0)
            (setf (pref addr :int) fd)
            (let* ((header-addr (%inc-ptr addr (- *host-page-size*
                                                            (* 2 target::node-size)))))
              
              (when (> len 0)
                (let* ((target-addr (%inc-ptr header-addr (* 2 target::node-size))))
                  (unless (eql target-addr
                               (#_mmap target-addr
                                       len
                                       #$PROT_READ
                                       (logior #$MAP_PRIVATE #$MAP_FIXED)
                                       fd
                                       0))
                    (let* ((errno (%get-errno)))
                      (fd-close fd)
                      (#_munmap addr nbytes)
                      (error "Mapping failed: ~a" (%strerror errno))))))
              (values header-addr ndata-elements nalignment-elements))))))))

#+windows-target
(defun %memory-map-fd (fd len bits-per-element)
  (let* ((nbytes (+ *windows-allocation-granularity*
                    (logandc2 (+ len
                                 (1- *windows-allocation-granularity*))
                              (1- *windows-allocation-granularity*))))         
         (ndata-elements
          (ash len
               (ecase bits-per-element
                 (1 3)
                 (8 0)
                 (16 -1)
                 (32 -2)
                 (64 -3))))
         (nalignment-elements
          (ash target::nbits-in-word
               (ecase bits-per-element
                 (1 0)
                 (8 -3)
                 (16 -4)
                 (32 -5)
                 (64 -6)))))
    (if (>= (+ ndata-elements nalignment-elements)
            array-total-size-limit)
      (progn
        (fd-close fd)
        (error "Can't make a vector with ~s elements in this implementation." (+ ndata-elements nalignment-elements)))
      (let* ((mapping (#_CreateFileMappingA (%int-to-ptr fd) (%null-ptr) #$PAGE_READONLY 0 0 (%null-ptr))))
        (if (%null-ptr-p mapping)
          (let* ((err (#_GetLastError)))
            (fd-close fd)
            (error "Couldn't create a file mapping - ~a." (%windows-error-string err)))
          (loop
            (let* ((base (#_VirtualAlloc (%null-ptr) nbytes #$MEM_RESERVE #$PAGE_NOACCESS)))
              (if (%null-ptr-p base)
                (let* ((err (#_GetLastError)))
                  (#_CloseHandle mapping)
                  (fd-close fd)
                  (error "Couldn't reserve ~d bytes of address space for mapped file - ~a"
                         nbytes (%windows-error-string err)))
                ;; Now we have to free the memory and hope that we can reallocate it ...
                (progn
                  (#_VirtualFree base 0 #$MEM_RELEASE)
                  (unless (%null-ptr-p (#_VirtualAlloc base *windows-allocation-granularity* #$MEM_RESERVE #$PAGE_NOACCESS))
                    (let* ((fptr (%inc-ptr base *windows-allocation-granularity*)))
                      (if (%null-ptr-p (#_MapViewOfFileEx mapping #$FILE_MAP_READ 0 0 0 fptr))
                        (#_VirtualFree base 0 #$MEM_RELEASE)
                        (let* ((prefix-page (%inc-ptr base (- *windows-allocation-granularity*
                                                              *host-page-size*))))
                          (#_VirtualAlloc prefix-page *host-page-size* #$MEM_COMMIT #$PAGE_READWRITE)
                          (setf (paref prefix-page (:* :address) 0) mapping
                                (paref prefix-page (:* :address) 1) (%int-to-ptr fd))
                          (return (values
                                   (%inc-ptr prefix-page (- *host-page-size*
                                                            (* 2 target::node-size)))
                                   ndata-elements
                                   nalignment-elements)))))))))))))))
                       


(defun map-file-to-ivector (pathname element-type)
  (let* ((upgraded-type (upgraded-array-element-type element-type))
         (upgraded-ctype (specifier-type upgraded-type)))
    (unless (and (typep upgraded-ctype 'numeric-ctype)
                 (eq 'integer (numeric-ctype-class upgraded-ctype)))
      (error "Invalid element-type: ~s" element-type))
    (let* ((bits-per-element (integer-length (- (numeric-ctype-high upgraded-ctype)
                                                (numeric-ctype-low upgraded-ctype))))
           (fd (fd-open (defaulted-native-namestring pathname) #$O_RDONLY)))
      (if (< fd 0)
        (signal-file-error fd pathname)
        (let* ((len (fd-size fd)))
          (if (< len 0)
            (signal-file-error fd pathname)
            (multiple-value-bind (header-address ndata-elements nalignment-elements)
                (%memory-map-fd fd len bits-per-element)
              (setf (%get-natural header-address 0)
                    (logior (element-type-subtype upgraded-type)
                            (ash (+ ndata-elements nalignment-elements) target::num-subtag-bits)))
              (with-macptrs ((v (%inc-ptr header-address target::fulltag-misc)))
                          (let* ((vector (rlet ((p :address v)) (%get-object p 0))))
                            ;; Tell some parts of Clozure CL - notably the
                            ;; printer - that this thing off in foreign
                            ;; memory is a real lisp object and not
                            ;; "bogus".
                            (with-lock-grabbed (*heap-ivector-lock*)
                              (push vector *heap-ivectors*))
                            (make-array ndata-elements
                                        :element-type upgraded-type
                                        :displaced-to vector
                                        :adjustable t
                                        :displaced-index-offset nalignment-elements))))))))))

(defun map-file-to-octet-vector (pathname)
  (map-file-to-ivector pathname '(unsigned-byte 8)))

(defun mapped-vector-data-address-and-size (displaced-vector)
  (let* ((v (array-displacement displaced-vector))
         (element-type (array-element-type displaced-vector)))
    (if (or (eq v displaced-vector)
            (not (with-lock-grabbed (*heap-ivector-lock*)
                   (member v *heap-ivectors*))))
      (error "~s doesn't seem to have been allocated via ~s and not yet unmapped" displaced-vector 'map-file-to-ivector))
    (let* ((pv (rlet ((x :address)) (%set-object x 0 v) (pref x :address)))
           (ctype (specifier-type element-type))
           (arch (backend-target-arch *target-backend*)))
      (values (%inc-ptr pv (- (* 2 target::node-size) target::fulltag-misc))
              (- (funcall (locally
			      ;; Don't really care about speed, but need to turn off typechecking for bootstrapping reasons
			      (declare (optimize (speed 3) (safety 0)))
			    (arch::target-array-data-size-function arch))
                          (ctype-subtype ctype)
                          (length v))
                 target::node-size)))))


#-windows-target
(defun %unmap-file (data-address size-in-octets)
  (let* ((base-address (%inc-ptr data-address (- *host-page-size*)))
         (fd (pref base-address :int)))
    (#_munmap base-address (+ *host-page-size* size-in-octets))
    (fd-close fd)))

#+windows-target
(defun %unmap-file (data-address size-in-octets)
  (declare (ignore size-in-octets))
  (let* ((prefix-page (%inc-ptr data-address (- *host-page-size*)))
         (prefix-allocation (%inc-ptr data-address (- *windows-allocation-granularity*)))
         (mapping (paref prefix-page (:* :address) 0))
         (fd (%ptr-to-int (paref prefix-page (:* :address) 1))))
    (#_UnmapViewOfFile data-address)
    (#_CloseHandle mapping)
    (#_VirtualFree prefix-allocation 0 #$MEM_RELEASE)
    (fd-close fd)))

    

;;; Argument should be something returned by MAP-FILE-TO-IVECTOR;
;;; this should be called at most once for any such object.
(defun unmap-ivector (displaced-vector)
  (multiple-value-bind (data-address size-in-octets)
      (mapped-vector-data-address-and-size displaced-vector)
  (let* ((v (array-displacement displaced-vector)))
      (let* ((element-type (array-element-type displaced-vector)))
        (adjust-array displaced-vector 0
                      :element-type element-type
                      :displaced-to (make-array 0 :element-type element-type)
                      :displaced-index-offset 0))
      (with-lock-grabbed (*heap-ivector-lock*)
        (setq *heap-ivectors* (delete v *heap-ivectors*)))
      (%unmap-file data-address size-in-octets)
      t)))

(defun unmap-octet-vector (v)
  (unmap-ivector v))

#-windows-target
(progn
(defun lock-mapped-vector (v)
  (multiple-value-bind (address nbytes)
      (mapped-vector-data-address-and-size v)
    (eql 0 (#_mlock address nbytes))))

(defun unlock-mapped-vector (v)
  (multiple-value-bind (address nbytes)
      (mapped-vector-data-address-and-size v)
    (eql 0 (#_munlock address nbytes))))

(defun bitmap-for-mapped-range (address nbytes)
  (let* ((npages (ceiling nbytes *host-page-size*)))
    (%stack-block ((vec npages))
      (when (eql 0 (#_mincore address nbytes vec))
        (let* ((bits (make-array npages :element-type 'bit)))
          (dotimes (i npages bits)
            (setf (sbit bits i)
                  (logand 1 (%get-unsigned-byte vec i)))))))))

(defun percentage-of-resident-pages (address nbytes)
  (let* ((npages (ceiling nbytes *host-page-size*)))
    (%stack-block ((vec npages))
      (when (eql 0 (#_mincore address nbytes vec))
        (let* ((nresident 0))
          (dotimes (i npages (* 100.0 (/ nresident npages)))
            (when (logbitp 0 (%get-unsigned-byte vec i))
              (incf nresident))))))))

(defun mapped-vector-resident-pages (v)
  (multiple-value-bind (address nbytes)
      (mapped-vector-data-address-and-size v)
    (bitmap-for-mapped-range address nbytes)))

(defun mapped-vector-resident-pages-percentage (v)
  (multiple-value-bind (address nbytes)
      (mapped-vector-data-address-and-size v)
    (percentage-of-resident-pages address nbytes)))
)


#+windows-target
(defun cygpath (winpath)
  "Try to use the Cygwin \"cygpath\" program to map a Windows-style
   pathname to a POSIX-stype Cygwin pathname."
  (let* ((posix-path winpath))
    (with-output-to-string (s)
      (multiple-value-bind (status exit-code)
          (external-process-status
           (run-program "cygpath" (list "-u" winpath) :output s))
        (when (and (eq status :exited)
                   (eql exit-code 0))
          (with-input-from-string (output (get-output-stream-string s))
            (setq posix-path (read-line output nil nil))))))
    posix-path))

#-windows-target (defun cygpath (path) path)
      



#+x86-target
(progn
(defloadvar *last-rdtsc-time* 0)

(defstatic *rdtsc-estimated-increment* 1 "Should be positive ...")

(defun rdtsc-monotonic ()
  "Return monotonically increasing values, partly compensating for
   OSes that don't keep the TSCs of all processorsin synch."
  (loop
    (let* ((old *last-rdtsc-time*)
           (new (rdtsc)))
      (when (< new old)
        ;; We're running on a CPU whose TSC is behind the one
        ;; on the last CPU we were scheduled on.
        (setq new (+ old *rdtsc-estimated-increment*)))
      (when (%store-node-conditional target::symbol.vcell *last-rdtsc-time* old new)
        (return new)))))

(defun estimate-rdtsc-skew (&optional (niter 1000000))
  (do* ((i 0 (1+ i))
        (last (rdtsc) next)
        (next (rdtsc) (rdtsc))
        (skew 1))
       ((>= i niter) (setq *rdtsc-estimated-increment* skew))
    (declare (fixnum last next skew))
    (when (> last next)
      (let* ((s (- last next)))
        (declare (fixnum s))
        (when (> s skew) (setq skew s))))))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/linux-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-boot-2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; l1-boot-2.lisp
;; Second part of l1-boot

(in-package "CCL")

(macrolet ((l1-load (name)
	     (let* ((namestring
		     (concatenate 'simple-base-string
                                  "./l1-fasls/"
				  (string name)
                                  (namestring (backend-target-fasl-pathname
                                               *target-backend*)))))
               `(let* ((*loading-file-source-file* *loading-file-source-file*)
                       (*loading-toplevel-location* *loading-toplevel-location*))
                  (%fasload ,namestring))))
	   (bin-load (name)
	     (let* ((namestring
		     (concatenate 'simple-base-string
                                  "./bin/"
				  (string name)
                                  (namestring (backend-target-fasl-pathname
                                               *target-backend*)))))
               `(let* ((*loading-file-source-file* *loading-file-source-file*)
                       (*loading-toplevel-location* *loading-toplevel-location*))
                  (%fasload ,namestring)))))


(catch :toplevel
    #+ppc-target
    (l1-load "ppc-error-signal")
    #+x86-target
    (l1-load "x86-error-signal")
    #+arm-target
    (l1-load "arm-error-signal")
    (l1-load "l1-error-signal")
    (l1-load "l1-sockets")
    (setq *LEVEL-1-LOADED* t))

#+ppc-target
(defun altivec-available-p ()
  "Return non-NIL if AltiVec is available."
  (not (eql (%get-kernel-global 'ppc::altivec-present) 0)))

#+ppc-target
(defloadvar *altivec-available* (altivec-available-p)
  "This variable is intitialized each time a Clozure CL session starts based
on information provided by the lisp kernel. Its value is true if AltiVec is
present and false otherwise. This variable shouldn't be set by user code.")

       
(defstatic *auto-flush-streams* ())
(def-ccl-pointers *auto-flush-streams* () (setq *auto-flush-streams* nil))
(defstatic *auto-flush-streams-lock* (make-lock))


(defvar *batch-flag* (not (eql (%get-kernel-global 'batch-flag) 0)))
(defloadvar *quiet-flag* nil)
(defvar *terminal-input* ())
(defvar *terminal-output* ())
(defvar *stdin* ())
(defvar *stdout* ())
(defvar *stderr* ())


(defun set-basic-stream-prototype (class)
  (when (subtypep class 'basic-stream)
    (setf (%class.prototype class) (or (%class.prototype class)
                                       (allocate-basic-stream class)))
    (dolist (subclass (class-direct-subclasses class))
      (set-basic-stream-prototype subclass))))

(set-basic-stream-prototype (find-class 'basic-stream))


;;; The hard parts here have to do with setting up *TERMINAL-IO*.
;;; Note that opening /dev/tty can fail, and that failure would
;;; be reported as a negative return value from FD-OPEN.
;;; It's pretty important that nothing signals an error here,
;;; since there may not be any valid streams to write an error
;;; message to.

(defglobal *interactive-streams-initialized* nil)

#+windows-target
(progn


(defun validate-standard-io-handles ()
  (let* ((in (#_GetStdHandle #$STD_INPUT_HANDLE))
         (out (#_GetStdHandle #$STD_OUTPUT_HANDLE)))
    (when (or (%null-ptr-p in)
              (%null-ptr-p out))
      (let* ((nulldevice (open-null-device)))
        (when nulldevice
          (when (%null-ptr-p in)
            (#_SetStdHandle #$STD_INPUT_HANDLE nulldevice))
          (when (%null-ptr-p out)
            (#_SetStdHandle #$STD_OUTPUT_HANDLE nulldevice)
            (ff-call (ccl::%kernel-import target::kernel-import-open-debug-output)
                     :int (%ptr-to-int nulldevice)
                     :int)))))))
)

(defun initialize-interactive-streams ()
  (let* ((encoding (lookup-character-encoding *terminal-character-encoding-name*))
         (encoding-name (if encoding (character-encoding-name encoding))))
    #+windows-target (validate-standard-io-handles)
    (setq *stdin* (let* ((infd #-windows-target 0
                               #+windows-target (%ptr-to-int
                                                 (#_GetStdHandle #$STD_INPUT_HANDLE))))
                               (make-fd-stream infd
                                  :basic t
                                  :sharing :lock
                                  :direction :input
                                  :interactive (or (not *batch-flag*)
                                                   (< (fd-lseek infd 0 #$SEEK_CUR)                                                      
                                                      0))
                                  :encoding encoding-name
                                  #+windows-target :line-termination #+windows-target :cp/m)))
    (setq *stdout* (make-fd-stream #-windows-target 1
                                   #+windows-target (%ptr-to-int
                                                     (#_GetStdHandle #$STD_OUTPUT_HANDLE))
                                   :basic t :direction :output :sharing :lock :encoding encoding-name #+windows-target :line-termination #+windows-target :msdos))
    (setq *stderr* (make-fd-stream #-windows-target 2
                                   #+windows-target (%ptr-to-int
                                                     (#_GetStdHandle #$STD_ERROR_HANDLE))
                                   :basic t :direction :output :sharing :lock :encoding encoding-name #+windows-target :line-termination #+windows-target :crlf))
    (add-auto-flush-stream *stdout*)
    (add-auto-flush-stream *stderr*)
    (if *batch-flag*
      (let* ((tty-fd
              #-windows-target
               (let* ((fd (fd-open "/dev/tty" #$O_RDWR)))
                 (if (>= fd 0) fd)))
             (can-use-tty #-windows-target (and tty-fd (eql (tcgetpgrp tty-fd) (getpid)))))
        (if can-use-tty
          (progn
            (setq
             *terminal-input* (make-fd-stream tty-fd
                                              :basic t
                                              :direction :input
                                              :interactive t
                                              :sharing :lock
                                              :encoding encoding-name)
             *terminal-output* (make-fd-stream tty-fd :basic t :direction :output :sharing :lock :encoding encoding-name)
             *terminal-io* (make-echoing-two-way-stream
                            *terminal-input* *terminal-output*))
            (add-auto-flush-stream *terminal-output*))
          (progn
            (when tty-fd (fd-close tty-fd))
            (setq *terminal-input* *stdin*
                  *terminal-output* *stdout*
                  *terminal-io* (make-two-way-stream
                                 *terminal-input* *terminal-output*))))
        (setq *standard-input* *stdin*
              *standard-output* *stdout*))
      (progn
        (setq *terminal-input* *stdin*
              *terminal-output* *stdout*
              *terminal-io* (make-echoing-two-way-stream
                             *terminal-input* *terminal-output*))
        (setq *standard-input* (make-synonym-stream '*terminal-io*)
              *standard-output* (make-synonym-stream '*terminal-io*))))
    (setq *error-output* (if (or *batch-flag*
                                 (not (same-fd-p (stream-device *stderr* :output)
                                                 (stream-device *stdout* :output))))
                           (make-synonym-stream '*stderr*)
                           (make-synonym-stream '*terminal-io*)))
    (setq *query-io* (make-synonym-stream '*terminal-io*))
    (setq *debug-io* *query-io*)
    (setq *trace-output* *standard-output*)
    (push *stdout* *auto-flush-streams*)
    (setf (input-stream-shared-resource *terminal-input*)
          (make-shared-resource "Shared Terminal Input")))
  (setq *interactive-streams-initialized* t))

(initialize-interactive-streams)

(def-standard-initial-binding *standard-input*)
(def-standard-initial-binding *standard-output*)
(def-standard-initial-binding *error-output*)
(def-standard-initial-binding *trace-output*)
(def-standard-initial-binding *debug-io*)
(def-standard-initial-binding *query-io*)

;;; Things bound by WITH-STANDARD-IO-SYNTAX (and not otherwise thread-local)
(def-standard-initial-binding *read-base*)
(def-standard-initial-binding *read-default-float-format*)
(def-standard-initial-binding *read-eval*) 
(def-standard-initial-binding *read-suppress*)



(defun set-terminal-encoding (encoding-name)
  #+windows-target (when (atom encoding-name)
                     (setq encoding-name `(:character-encoding ,encoding-name
                                           :line-termination :crlf)))
  (let* ((exformat (normalize-external-format t encoding-name)))
    (setf (stream-external-format *stdin*) exformat
          (stream-external-format *stdout*) exformat
          (stream-external-format *stderr*) exformat
          (stream-external-format *terminal-input*) exformat
          (stream-external-format *terminal-output*) exformat))
  encoding-name)

(catch :toplevel
    (macrolet ((l1-load-provide (module path)
		 `(let* ((*package* *package*))
		   (l1-load ,path)
		   (provide ,module)))
	       (bin-load-provide (module path)
		 `(let* ((*package* *package*))
		   (bin-load ,path)
		   (provide ,module))))
      (bin-load-provide "SORT" "sort")
      (bin-load-provide "NUMBERS" "numbers")
      
      (bin-load-provide "SUBPRIMS" "subprims")
      #+ppc32-target
      (bin-load-provide "PPC32-ARCH" "ppc32-arch") 
      #+ppc64-target
      (bin-load-provide "PPC64-ARCH" "ppc64-arch")
      #+x86-target
      (bin-load-provide "X8632-ARCH" "x8632-arch")
      #+x86-target
      (bin-load-provide "X8664-ARCH" "x8664-arch")
      #+arm-target
      (bin-load-provide "ARM-ARCH" "arm-arch")
      (bin-load-provide "VREG" "vreg")
      
      #+ppc-target
      (bin-load-provide "PPC-ASM" "ppc-asm")
      #+arm-target
      (bin-load-provide "ARM-ASM" "arm-asm")
      
      (bin-load-provide "VINSN" "vinsn")
      (bin-load-provide "REG" "reg")
      
      #+ppc-target
      (bin-load-provide "PPC-LAP" "ppc-lap")
      #+arm-target
      (bin-load-provide "ARM-LAP" "arm-lap")
      (bin-load-provide "BACKEND" "backend")
      (bin-load-provide "NX2" "nx2")
     
      #+ppc-target
      (provide "PPC2")                  ; Lie, load the module manually

      #+x86-target
      (provide "X862")

      #+arm-target
      (provide "ARM2") 
      (bin-load-provide "ACODE-REWRITE" "acode-rewrite")
     
      (l1-load-provide "NX" "nx")
      
      #+ppc-target
      (bin-load "ppc2")

      #+x86-target
      (bin-load "x862")

      #+arm-target
      (bin-load "arm2")
      
      (bin-load-provide "LEVEL-2" "level-2")
      (bin-load-provide "MACROS" "macros")
      (bin-load-provide "SETF" "setf")
      (bin-load-provide "SETF-RUNTIME" "setf-runtime")
      (bin-load-provide "FORMAT" "format")
      (bin-load-provide "STREAMS" "streams")
      (bin-load-provide "OPTIMIZERS" "optimizers")      
      (bin-load-provide "DEFSTRUCT-MACROS" "defstruct-macros")
      (bin-load-provide "DEFSTRUCT-LDS" "defstruct-lds")
      (bin-load-provide "NFCOMP" "nfcomp")
      (bin-load-provide "BACKQUOTE" "backquote")
      (bin-load-provide "BACKTRACE-LDS" "backtrace-lds")
      (bin-load-provide "BACKTRACE" "backtrace")
      (bin-load-provide "READ" "read")
      (bin-load-provide "ARRAYS-FRY" "arrays-fry")
      (bin-load-provide "APROPOS" "apropos")
      (bin-load-provide "SOURCE-FILES" "source-files")
      
      #+ppc-target
      (progn
	(bin-load-provide "PPC-DISASSEMBLE" "ppc-disassemble")
	(bin-load-provide "PPC-LAPMACROS" "ppc-lapmacros"))

      #+x86-target
      (progn
	(bin-load-provide "X86-DISASSEMBLE" "x86-disassemble")
	(bin-load-provide "X86-LAPMACROS" "x86-lapmacros")
	(bin-load "x86-watch"))

      #+arm-target
      (progn
	(bin-load-provide "ARM-DISASSEMBLE" "arm-disassemble")
	(bin-load-provide "ARM-LAPMACROS" "arm-lapmacros"))

      (bin-load-provide "FOREIGN-TYPES" "foreign-types")
      (install-standard-foreign-types *host-ftd*)
      
      #+(and ppc32-target linux-target)
      (bin-load-provide "FFI-LINUXPPC32" "ffi-linuxppc32")
      #+(and ppc32-target darwin-target)
      (bin-load-provide "FFI-DARWINPPC32" "ffi-darwinppc32")
      #+(and ppc64-target darwin-target)
      (bin-load-provide "FFI-DARWINPPC64" "ffi-darwinppc64")
      #+(and ppc64-target linux-target)
      (bin-load-provide "FFI-LINUXPPC64" "ffi-linuxppc64")
      #+(and x8632-target darwin-target)
      (bin-load-provide "FFI-DARWINX8632" "ffi-darwinx8632")
      #+(and x8664-target linux-target)  
      (bin-load-provide "FFI-LINUXX8664" "ffi-linuxx8664")
      #+(and x8664-target darwin-target)  
      (bin-load-provide "FFI-DARWINX8664" "ffi-darwinx8664")
      #+(and x8664-target freebsd-target)  
      (bin-load-provide "FFI-FREEBSDX8664" "ffi-freebsdx8664")
      #+(and x8664-target solaris-target)
      (bin-load-provide "FFI-SOLARISX8664" "ffi-solarisx8664")
      #+win64-target
      (bin-load-provide "FFI-WIN64" "ffi-win64")
      #+linuxx8632-target
      (bin-load-provide "FFI-LINUXX8632" "ffi-linuxx8632")
      #+win32-target
      (bin-load-provide "FFI-WIN32" "ffi-win32")
      #+solarisx8632-target
      (bin-load-provide "FFI-SOLARISX8632" "ffi-solarisx8632")
      #+freebsdx8632-target
      (bin-load-provide "FFI-FREEBSDX8632" "ffi-freebsdx8632")
      #+(and arm-target linux-target (not android-target))
      (bin-load-provide "FFI-LINUXARM" "ffi-linuxarm")
      #+(and arm-target android-target)
      (bin-load-provide "FFI-ANDROIDARM" "ffi-androidarm")
      #+(and arm-target darwin-target)
      (bin-load-provide "FFI-DARWINARM" "ffi-darwinarm")


      ;; Knock wood: all standard reader macros and no non-standard
      ;; reader macros are defined at this point.
      (setq *readtable* (copy-readtable *readtable*))

      (bin-load-provide "DB-IO" "db-io")

      (canonicalize-foreign-type-ordinals *host-ftd*)
      
      (bin-load-provide "CASE-ERROR" "case-error")
      (bin-load-provide "ENCAPSULATE" "encapsulate")
      (bin-load-provide "METHOD-COMBINATION" "method-combination")
      (bin-load-provide "MISC" "misc")
      (bin-load-provide "PPRINT" "pprint")
      (bin-load-provide "DUMPLISP" "dumplisp")
      (bin-load-provide "PATHNAMES" "pathnames")
      (bin-load-provide "TIME" "time")
      (bin-load-provide "COMPILE-CCL" "compile-ccl")
      (bin-load-provide "ARGLIST" "arglist")
      (bin-load-provide "EDIT-CALLERS" "edit-callers")
      (bin-load-provide "DESCRIBE" "describe")
      (bin-load-provide "SWINK" "swink")
      (bin-load-provide "COVER" "cover")
      (bin-load-provide "LEAKS" "leaks")
      (bin-load-provide "CORE-FILES" "core-files")
      (bin-load-provide "DOMINANCE" "dominance")
      (bin-load-provide "SWANK-LOADER" "swank-loader")
      (bin-load-provide "REMOTE-LISP" "remote-lisp")
      (bin-load-provide "MCL-COMPAT" "mcl-compat")
      (require "LOOP")
      (bin-load-provide "CCL-EXPORT-SYMS" "ccl-export-syms")
      (l1-load-provide "VERSION" "version")
      (require "JP-ENCODE")
      (require "CN-ENCODE")
      (require "LISPEQU") ; Shouldn't need this at load time ...
      (require "SOCKETS")
      )
    (setq *%fasload-verbose* nil)
    )
)






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-boot-2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; L1-format.lisp
;
; This file contains the definition for SUB-FORMAT, the dispatching part
; of FORMAT. It also contains an interim definition for FORMAT and a few
; incompletely implemented directives.

(in-package "CCL")

(eval-when (eval compile #-bccl load)  ;Load-time as well so CCL can use it.
  (defmacro defformat (char name &rest def)
    `(progn
       (add-format-char ,char (nfunction ,name (lambda . ,def)))
       ',name))
  )

(defparameter *format-char-table* (let* ((x (make-array 128 :initial-element nil))) x))

(defun add-format-char (char def)
  (unless (and (characterp char) (%i< (%char-code char) 128))
    (report-bad-arg char 'standard-char))
  (setf (svref *format-char-table* (%char-code (char-upcase char))) def))

(proclaim '(special *format-original-arguments*   ;For ~*
                    *format-arguments*            ;For pop-format-arg
                    *format-control-string*       ;For ~?, ~{
                    *format-index*
                    *format-length*
                    *format-pprint*               ;~I,~W,~_,~:T seen?
                    *format-justification-semi*   ;~<..~:;..~> seen?
            ))

(defun pop-format-arg (&aux (args *format-arguments*))
  (if (null args)
    (format-error "Missing argument"))
  (progn
    (setq *format-arguments* (cdr args))
    (%car args)))
 
;SUB-FORMAT parses (a range of) the control string, finding the directives
;and applying them to their parameters.
;Implicit arguments to SUB-FORMAT: *format-control-string*, *format-arguments*,
;*format-original-arguments*, *standard-output*, *format-char-table*
;*format-control-string* must be a simple string.
;Directive functions' arglist should be (colon-p atsign-p &rest params)
;In addition when the directive is called, *format-index* and *format-length*
;are bound to start and end pos (in *format-control-string*) of the rest of the
; control string.  The directive may modify *format-index*, but not
; *format-control-string* and *format-length*, before returning.

(defun sub-format (stream *format-index* *format-length* &aux char)
  (prog* ((string (require-type *format-control-string* 'simple-string))
          (length *format-length*)
          (i *format-index*)
          (lastpos i))
    (declare (fixnum i length lastpos) (type simple-string string))
    (go START)
    EOF-ERROR
    (setq *format-index* *format-length*)
    (format-error "Premature end of control string")
    START
    (do* ()
         ((= i length) (unless (= i lastpos) 
                         (write-string string stream :start  lastpos :end i)))
      (setq char (schar string i) i (1+ i))
      (when (eq char #\~)
        (let* ((limit (the fixnum (1- i))))
          (unless (= limit lastpos) 
            (write-simple-string string stream  lastpos limit)))
        (let ((params nil) (fn) (colon nil) (atsign nil))
          (block nil
            (tagbody
              NEXT
              (if (= i length) (go EOF-ERROR))
              (setq char (schar string i) i (1+ i))
              (cond ((eq char #\#)
                     (push (list-length *format-arguments*) params))
                    ((eq char #\')
                     (if (= i length) (go EOF-ERROR))
                     (push (schar string i) params)
                     (incf i))
                    ((eq char #\,)
                     (push nil params)
                     (go NEXT))
                    ((or (eq char #\V) (eq char #\v))
                     (push (pop-format-arg) params))
                    ((or (eq char #\-) (eq char #\+) (digit-char-p char))
                     (let ((start (%i- i 1)) n)
                       (loop
                         (when (= i length) (go EOF-ERROR))
                         (unless (digit-char-p (schar string i)) (return))
                         (incf i))
                       (when (null (setq n (%parse-number-token string start i)))
                         (setq *format-index* i)
                         (format-error "Illegal parameter"))
                       (push n params)))
                    (t (return)))
              (if (= i length) (go EOF-ERROR))
              (setq char (schar string i) i (1+ i))
              (when (neq char #\,) (return))
              (go NEXT)))
          (cond ((eq char #\:) 
                 (if (= i length) (go EOF-ERROR))
                 (setq colon t char (schar string i) i (1+ i))
                 (when (eq char #\@)
                   (if (= i length) (go EOF-ERROR))                     
                   (setq atsign t char (schar string i) i (1+ i))))
                ((eq char #\@)
                 (if (= i length) (go EOF-ERROR))
                 (setq atsign t char (schar string i) i (1+ i))
                 (when (eq char #\:)
                   (if (= i length) (go EOF-ERROR))
                   (setq colon t char (schar string i) i (1+ i)))))
          (setq *format-index* (%i- i 1))
          (if (setq fn (svref *format-char-table* (%char-code (char-upcase char))))
            (apply fn stream colon atsign (nreverse params))
            (format-error "Unknown directive"))
          (setq i (%i+ *format-index* 1)
                lastpos i))))))


#||
(eval-when (load)
  ;The non-consing version.
(defun sub-format (stream *format-index* *format-length*)
  (declare (special *format-index* *format-length*))
  (old-lap-inline (stream)
    (preserve_regs #(asave0 asave1 dsave0 dsave1 dsave2))
    (defreg Control-string asave0 Index dsave0 Length dsave1 NumParams dsave2 Stream asave1)
    (move.l acc Stream)
    (move.l (special *format-index*) Index)       ; *format-index*
    (move.l (special *format-length*) Length)      ; *format-length*
    (specref *format-control-string*)
    (move.l acc Control-string)

    ;Make sure everything is in bounds, so don't have to worry about
    ;boxing, bounds checking, etc.
start
    (movereg Control-string arg_z)
    (jsr_subprim $sp-length)
    (ccall <= '0 Index Length acc)
    (cmp.l nilreg acc)
    (beq done)
    (move.l Index db)
    (loop#
      (if# (eq Length Index)
        (cmp.l db Index)
        (beq done)
        (ccall 'stream-write-string Stream Control-string db Index)
        (bra done))
      (move.l Index da)
      (getint da)
      (move.l ($ $t_imm_char 0) acc)
      (move.b (Control-string da.l $v_data) acc)
      (add.l (fixnum 1) Index)
      (cmp.b ($ #\~) acc)
      (beq tilde))

nextchar
    (if# (eq Length Index)
      (move.l '"Premature end of format control string" arg_z)
      (add.w ($ 4) sp)                  ; flush internal bsr.
      (bra error))
    (move.l Index da)
    (getint da)
    (move.b (Control-string da.l $v_data) acc)
    (add.l (fixnum 1) Index)
    (if# (and (ge (cmp.b ($ #\a) acc)) (le (cmp.b ($ #\z) acc)))
      (sub.b ($ 32) acc))
    (rts)

tilde
    (move.l Index da)
    (sub.l (fixnum 1) da)
    (if# (not (eq da db))      
      (ccall 'stream-write-string Stream Control-string db da))
    (vpush Stream)
    (vpush nilreg)             ;assume no :
    (vpush nilreg)             ;assume no @
    (move.l (fixnum 3) NumParams)
do-param
    (bsr nextchar)
    (if# (or (eq (cmp.b ($ #\+) acc))
             (eq (cmp.b ($ #\-) acc))
             (and (ge (cmp.b ($ #\0) acc)) (le (cmp.b ($ #\9) acc))))
      (move.l Index da)
      (sub.l (fixnum 1) da)
      (vpush da)
      (prog#
       (bsr nextchar)
       (until# (or (lt (cmp.b ($ #\0) acc)) (gt (cmp.b ($ #\9) acc)))))
      (sub.l (fixnum 1) Index)   ;unread the non-digit char
      (ccall %parse-number-token Control-string vsp@+ Index)
      (cmp.l nilreg acc)
      (bne push-param)
      (move.l '"Illegal format parameter" arg_z)
      (bra error))

    (if# (eq (cmp.b ($ #\#) acc))
      (move.l (special *format-arguments*) acc)
      (jsr_subprim $sp-length)
      (bra push-param))

    (if# (eq (cmp.b ($ #\') acc))
      (bsr nextchar)
      (move.l ($ $t_imm_char 0) acc)
      (move.b (Control-string da.l $v_data) acc)  ;Get the non-uppercased version...
      (swap acc)
      (bra push-param))

    (if# (eq (cmp.b ($ #\,) acc))
      (sub.l (fixnum 1) Index)   ;Re-read the comma.
      (move.l nilreg acc)
      (bra push-param))

    (if# (eq (cmp.b ($ #\V) acc))
      (ccall 'pop-format-arg)
      ;(bra push-param)
     push-param
      (vpush acc)
      (add.l (fixnum 1) NumParams)
      (bsr nextchar)
      (cmp.b ($ #\,) acc)
      (beq do-param))

    (move.l NumParams nargs)
    (vscale.l nargs)
    (cmp.b ($ #\:) acc)
    (if# eq
      (bsr nextchar)
      (cmp.b ($ #\@) acc)
      (bne @a)
      (move.l (a5 $t) (vsp nargs.w -12))
     else#
      (cmp.b ($ #\@) acc)
      (bne @b)
      (move.l (a5 $t) (vsp nargs.w -12))
      (bsr nextchar)
      (cmp.b ($ #\:) acc)
      (bne @b))
    (bsr nextchar)
@a  (move.l (a5 $t) (vsp nargs.w -8))
@b  (moveq 127 da)
    (and.w acc da)
    (bif (ne (cmp.b da acc)) nofun)
    (lsl.w 2 da)
    (move.l (special *format-char-table*) atemp0)
    (move.l (atemp0 da.w $v_data) atemp0)
    (cmp.l atemp0 nilreg)
    (beq nofun)
    (move.l Index da)
    (sub.l (fixnum 1) da)
    (move.l da (special *format-index*))
    (move.l NumParams nargs)
    (vscale.l nargs)                    ; at least 3 args.
    (movem.l vsp@+ #(arg_z arg_y arg_x))
    (jsr_subprim $sp-funcall)
    (specref '*format-index*)
    (add.l (fixnum 1) acc)
    (move.l acc Index)
    (bra start)

nofun
    (move.l '"Unknown format directive" acc)
error
    (move.l Index (special *format-index*))
    (fsymevalapply 'format-error 1)

done
    (restore_regs)
    ))
) ;end of eval-when (load)

||#

;;;Interim definitions

;;;This function is shadowed by CCL in order to use ~{ to print error messages.
(fset 'format 
      (nlambda bootstrapping-format (stream control-string &rest format-arguments)
        (declare (dynamic-extent format-arguments))
        (block format
          (when (null stream)
            (return-from format 
              (with-output-to-string (x)
                (apply #'format x control-string format-arguments))))
          (if (eq stream t)
            (setq stream *standard-output*)
            (unless (streamp stream) (report-bad-arg stream 'stream)))
          (if (functionp control-string)
            (apply control-string stream format-arguments)
            (progn
              (setq control-string (ensure-simple-string control-string))
              (let* ((*format-original-arguments* format-arguments)
                     (*format-arguments* format-arguments)
                     (*format-control-string* control-string))
                (catch 'format-escape
                  (sub-format stream 0 (length control-string)))
                nil))))))

(fset 'format-error
      (nlambda bootstrapping-format-error (&rest args)
        (format t "~&FORMAT error at position ~A in control string ~S "
                *format-index* *format-control-string*)
        (apply #'error args)))

(defun format-no-flags (colon atsign)
  (cond ((and colon atsign)
         (format-error "Flags not allowed"))
        (colon
         (format-error ": flag not allowed"))
        (atsign
         (format-error "@ flag not allowed"))))

;Redefined later
(defformat #\A format-a (stream colon atsign)
   (declare (ignore colon atsign))
   (princ (pop-format-arg) stream))

;Redefined later
(defformat #\S format-s (stream colon atsign)
  (declare (ignore colon atsign))
  (prin1 (pop-format-arg) stream))

;Redefined later
(defformat #\^ format-escape (stream colon atsign)
  (declare (ignore stream colon atsign))
  (throw 'format-escape t))

;Final version
(defformat #\% format-% (stream colon atsign &optional repeat-count)
  (format-no-flags colon atsign)
  (cond ((or (not repeat-count)
             (and (fixnump repeat-count)
                  (> repeat-count -1)))
         (dotimes (i (or repeat-count 1)) (declare (fixnum i)) (terpri stream)))
        (t (format-error "Bad repeat-count."))))

;Final version
(defformat #\& format-& (stream colon atsign &optional repeat-count)
  (format-no-flags colon atsign)
  (cond ((or (not repeat-count)
             (and (fixnump repeat-count)
                  (> repeat-count -1)))
         (unless (eq repeat-count 0)
           (fresh-line stream)
           (dotimes (i (1- (or repeat-count 1))) (declare (fixnum i)) (terpri stream))))
        (t (format-error "Bad repeat-count."))))

;Final version
(defformat #\~ format-~ (stream colon atsign &optional repeat-count)
  (format-no-flags colon atsign)
  (cond ((or (not repeat-count)
             (and (fixnump repeat-count)
                  (> repeat-count -1)))
         (dotimes (i (or repeat-count 1)) (declare (fixnum i)) (write-char #\~ stream)))
        (t (format-error "Bad repeat-count."))))

;Final version
(defformat #\P format-p (stream colon atsign)
  (when colon
     (let ((end *format-arguments*) (list *format-original-arguments*))
        (tagbody loop
           (if list
             (when (neq (cdr list) end)
               (setq list (%cdr list))
               (go loop))
             (format-error "No previous argument")))
        (setq *format-arguments* list)))
   (%write-string (if (eq (pop-format-arg) 1)
                    (if atsign "y" "")
                    (if atsign "ies" "s"))
                  stream))

;Final version
(defformat #\* format-* (stream colon atsign &optional count)
  (declare (ignore stream)(special *circularity-hash-table*))
  (let* ((orig *format-original-arguments*)
         (where (- (list-length orig)   ; will error if args circular
                   (list-length *format-arguments*)))
         (to (if atsign 
               (progn
                 (format-no-flags colon nil)
                 (or count 0)) ; absolute
               (progn
                 (when (null count)(setq count 1))
                 (when colon (setq count (- count)))
                 (%i+ where count))))
         (args (nthcdr-no-overflow to orig)))
    ; avoid bogus circularity indication
    (when (and nil (consp args) (<= to where) *circularity-hash-table*)
      ; copy only from to thru where in case  some real shared structure
      (let ((l args) new)
        (dotimes (i (1+  (- where to)))
          (declare (fixnum i))
          (push (car l) new)
          (setq l (cdr l)))
        (setq args (nreconc new (nthcdr (1+ where) orig))))) ;(copy-list args)))
    (setq *format-arguments* args)))

; Redefined later.
(defformat #\Newline format-newline (&rest ignore)
  (declare (ignore ignore))
  (do* ((i *format-index* (1+ i))
        (s *format-control-string*)
        (n *format-length*))
       ((or (= i n)
            (not (whitespacep (schar s i))))
        (setq *format-index* (1- i)))))

(defun nthcdr-no-overflow (count list)
  (if (or (> count (list-length list)) (< count 0))
    (format-error "non-existent target for ~~*")
    (nthcdr count list)))

;Redefined later
(defformat #\X format-x (stream colon atsign)
  (declare (ignore colon atsign))
  (let* ((*print-base* 16.)
         (*print-radix* nil))
    (prin1 (pop-format-arg) stream)))

;Redefined later
(defformat #\D format-d (stream colon atsign &rest ignore)
  (declare (ignore colon atsign ignore))
  (let* ((*print-base* 10.)
         (*print-radix* nil))
    (prin1 (pop-format-arg) stream)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2001 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; L1-files.lisp - Object oriented file stuff

(in-package "CCL")

(defconstant $paramErr -50)   ; put this with the rest when we find the rest

(defconstant pathname-case-type '(member :common :local :studly))
(defconstant pathname-arg-type '(or string pathname stream))

(defmacro signal-file-error (err-num &optional pathname &rest args)
  `(%signal-file-error ,err-num
    ,@(if pathname (list pathname))
              ,@(if args args)))

(defun %signal-file-error (err-num &optional pathname args)
  (declare (fixnum err-num))
  (let* ((err-code (logior (ash 2 16) (the fixnum (logand #xffff (the fixnum err-num))))))
    (funcall (if (< err-num 0) '%errno-disp '%err-disp)
	     err-code
	     pathname
	     args)))


(defvar %logical-host-translations% '())
(defvar *load-pathname* nil
  "the defaulted pathname that LOAD is currently loading")
(defvar *load-truename* nil
  "the TRUENAME of the file that LOAD is currently loading")


(defparameter *default-pathname-defaults*
  (let* ((hide-from-compile-file (%cons-pathname nil nil nil)))
    hide-from-compile-file))

;Right now, the only way it's used is that an explicit ";" expands into it.
;Used to merge with it before going to ROM.  Might be worth to bring that back,
;it doesn't hurt anything if you don't set it.
;(defparameter *working-directory* (%cons-pathname nil nil nil))

;These come in useful...  We should use them consistently and then document them,
;thereby earning the eternal gratitude of any users who find themselves with a
;ton of "foo.CL" files...
(defparameter *.fasl-pathname*
  (%cons-pathname nil nil
                  #.(pathname-type
                     (backend-target-fasl-pathname *target-backend*))))

(defparameter *.lisp-pathname* (%cons-pathname nil nil "lisp"))

(defun if-exists (if-exists filename &optional (prompt "Create ..."))
  (case if-exists
    (:error (signal-file-error (- #$EEXIST) filename))
    ((:dialog) (overwrite-dialog filename prompt))
    ((nil) nil)
    ((:ignored :overwrite :append :supersede :rename-and-delete :new-version :rename) filename)
    (t (report-bad-arg if-exists '(member :error :dialog nil :ignored :overwrite :append :supersede :rename-and-delete)))))

(defun if-does-not-exist (if-does-not-exist filename)
  (case if-does-not-exist 
    (:error (signal-file-error (- #$ENOENT) filename)) ; (%err-disp $err-no-file filename))
    (:create filename)
    ((nil) (return-from if-does-not-exist nil))
    (t (report-bad-arg if-does-not-exist '(member :error :create nil)))))


(defun defaulted-native-namestring (path)
  (native-translated-namestring (merge-pathnames path)))

(defun native-translated-namestring (path)
  (let ((name (namestring (translate-logical-pathname path))))
    ;; Check that no quoted /'s (or :'s on windows)
    (when (%path-mem-last-quoted #-windows-target "/" #+windows-target "/:" name)
      (signal-file-error $xbadfilenamechar name
                         #-windows-target #\/
                         #+windows-target (if (%path-mem-last-quoted ":" name) #\: #\/)))
    ;; Check that no unquoted wildcards.
    (when (%path-mem-last "*" name)
      (signal-file-error $xillwild name))
    (namestring-unquote name)))

;; TODO: change callers and get rid of this.
(defun native-untranslated-namestring (path)
  (native-translated-namestring path))

;; Reverse of above, take native namestring and make a Lisp pathname.
(defun native-to-pathname (name)
  ;; This assumes that NAME is absolute and fully qualified, and
  ;; that there'd be no benefit to (and some risk involved in)
  ;; effectively merging it with whatever random thing may be
  ;; in *DEFAULT-PATHNAME-DEFAULTS*.
  ;; I -think- that that's true for all callers of this function.
  (let* ((*default-pathname-defaults* #p""))
    (pathname (native-to-namestring name))))

;; this is used to quote full namestrings, so do not quote /'s, and on windows do not quote :'s either,
;; since those are syntactic.  See also native-to-filename.
(defun native-to-namestring (native)
  (%path-std-quotes native nil #+windows-target "*;" #-windows-target "*;:"))

(defun native-to-directory-pathname (name)
  (let* ((*default-pathname-defaults* #p""))
    #+windows-target
    (let* ((len (length name)))
      (when (and (> len 1) (not (or (eql (schar name (1- len)) #\/)
                                    (eql (schar name (1- len)) #\\))))
        (setq name (%str-cat name "/")))
      (string-to-pathname (native-to-namestring name)))
    #-windows-target
    (make-directory-pathname  :device nil :directory (native-to-namestring name))))

;; This is used to quote a single native filename component, so directory/device
;; markers have been removed.  See also native-to-namestring.
(defun native-to-filename (native)
  (%path-std-quotes native nil "/:;*"))

(defun %std-filename-quotes (name &optional quote-period)
  (if quote-period
    (%path-std-quotes name "./:;*" "./:;")
    (%path-std-quotes name "/:;*" "/:;")))


;;; Make a pathname which names the specified directory; use
;;; explict :NAME, :TYPE, and :VERSION components of NIL.
(defun make-directory-pathname (&key host device directory)
  (make-pathname :host host
		 :device device
		 :directory directory
                 :name nil
                 :type nil
                 :version nil))

		   
(defun namestring-unquote (name)
  (let ((esc *pathname-escape-character*))
    (multiple-value-bind (sstr start end) (get-sstring name)
      (declare (simple-string sstr) (fixnum start end))
      (let* ((ncopy 0)
             (skipped nil)
             (quote-next nil))
        (declare (fixnum ncopy))
        (do* ((i start (1+ i)))
             ((= i end))
          (declare (fixnum i))
          (let* ((ch (schar sstr i)))
            (cond ((or quote-next (not (eq ch esc)))
                   (incf ncopy)
                   (setq quote-next nil))
                  ((eq ch esc) (setq skipped t) (setq quote-next t)))))
        (if (not skipped)
          name
          (let ((result (make-string ncopy))
                (dest 0))
            (declare (fixnum dest))
            (setq quote-next nil)
            (do* ((i start (1+ i)))
                 ((= i end) result)
              (declare (fixnum i))
              (let* ((ch (schar sstr i)))
                (cond ((or quote-next (not (eq ch esc)))
                       (setf (schar result dest) ch)
                       (incf dest)
                       (setq quote-next nil))
                      ((eq ch esc) (setq quote-next t)))))))))))

(defun truename (path)
  "Return the pathname for the actual file described by PATHNAME.
  An error of type FILE-ERROR is signalled if no such file exists,
  or the pathname is wild.

  Under Unix, the TRUENAME of a broken symlink is considered to be
  the name of the broken symlink itself."
  (or (probe-file path)
      (signal-file-error $err-no-file path)))

(defun check-pathname-not-wild (path)
  (when (wild-pathname-p path)
    (error 'file-error :error-type "Inappropriate use of wild pathname ~s"
	   :pathname path))
  path)

(defun probe-file (path)
  "Return a pathname which is the truename of the file if it exists, or NIL
  otherwise. An error of type FILE-ERROR is signaled if pathname is wild."
  (check-pathname-not-wild path)
  (let* ((native (defaulted-native-namestring path))
         (realpath (%realpath native))
         (kind (if realpath (%unix-file-kind realpath))))
    ;; Darwin's #_realpath will happily return non-nil for
    ;; files that don't exist.  I don't think that
    ;; %UNIX-FILE-KIND would do so.
    (when kind
      (if (eq kind :directory)
          (unless (eq (aref realpath (1- (length realpath))) #\/)
            (setq realpath (%str-cat realpath "/"))))
      (if realpath
        (native-to-pathname realpath)
        nil))))

(defun cwd (path)  
  (multiple-value-bind (realpath kind) (%probe-file-x (defaulted-native-namestring path))
    (if kind
      (if (eq kind :directory)
	(let* ((error (%chdir realpath)))
	  (if (eql error 0)
	    (mac-default-directory)
	    (signal-file-error error path)))
	(error "~S is not a directory pathname." path))
      (error "Invalid pathname : ~s." path))))

(defun create-file (path &key (if-exists :error) (create-directory t))
  (let* ((p (%create-file path :if-exists if-exists
				      :create-directory create-directory)))
    (and p
         (native-to-pathname p))))

(defun %create-file (path &key
			 (if-exists :error)
			 (create-directory t))
  (when create-directory
    (create-directory path))
  (when (directory-pathname-p path)
    (return-from %create-file (probe-file-x path)))
  (let* ((unix-name (defaulted-native-namestring path))
	 (fd (fd-open unix-name (logior #$O_WRONLY #$O_CREAT
                                        (if (eq if-exists :overwrite)
                                          #$O_TRUNC
                                          #$O_EXCL)))))
    (when (and (neq if-exists :error)
               (or (eql fd (- #$EEXIST))
                   #+windows-target
                   (and (eql fd (- #$EPERM))
                        (probe-file path))))
      (when (null if-exists)
        (return-from %create-file nil))
      (error "~s ~s not implemented yet" :if-exists if-exists))

    (if (< fd 0)
      (signal-file-error fd path)
      (fd-close fd))
    (%realpath unix-name)))


;; The following assumptions are deeply embedded in all our pathname code:
;; (1) Non-logical pathname host is always :unspecific.
;; (2) Logical pathname host is never :unspecific.
;; (3) Logical pathname host can however be NIL, e.g. "foo;bar;baz".

(defun %pathname-host (pathname)
  (if (logical-pathname-p pathname)
      (%logical-pathname-host pathname)
      :unspecific))

(defun %pathname-version (pathname)
  (if (logical-pathname-p pathname)
    (%logical-pathname-version pathname)
    (%physical-pathname-version pathname)))



(fset 'pathname-host (nfunction bootstrapping-pathname-host   ; redefined later in this file
                                (lambda (thing)
                                  (declare (ignore thing))
                                  :unspecific)))

(fset 'pathname-version (nfunction bootstrapping-pathname-version   ; redefined later in this file
                                   (lambda (thing)
                                     (declare (ignore thing))
                                     nil)))

(defmethod print-object ((pathname pathname) stream)
  (let ((flags (if (logical-pathname-p pathname) 4
                   (%i+ (if (eq (%pathname-type pathname) ':unspecific) 1 0)
                        (if (equal (%pathname-name pathname) "") 2 0))))
        (name (namestring pathname)))
    (if (and (not *print-readably*) (not *print-escape*))
      (write-string name stream)
      (progn
        (format stream (if (or *print-escape* (eql flags 0)) "#P" "#~DP") flags)
        (write-escaped-string name stream #\")))))


(defun mac-default-directory ()
  (let* ((native-name (current-directory-name))
	 (len (length native-name)))
    (declare (fixnum len))
    (when (and (> len 1)
	       (not (eq #\/ (schar native-name (1- len)))))
      (setq native-name (%str-cat native-name "/")))
    (native-to-pathname native-name)))




;;; I thought I wanted to call this from elsewhere but perhaps not
(defun absolute-directory-list (dirlist)
  ; just make relative absolute and remove ups where possible
  (when (or (null dirlist) (eq (car dirlist) :relative))
    (let ((default (mac-default-directory)) default-dir)
      (when default
        (setq default-dir (%pathname-directory default))
        (when default-dir
          (setq dirlist (append default-dir (cdr dirlist)))))))
  (when (memq :up dirlist)
    (setq dirlist (remove-up (copy-list dirlist))))
  dirlist)

; destructively mungs dir
(defun remove-up (dir)
  (setq dir (delete "." dir  :test #'string=))
  (let ((n 0)
        (last nil)
        (sub dir)
        has-abs kept-up)
    ;; from %std-directory-component we get dir with :relative/:absolute stripped
    (when (memq :up dir)
      (when (memq (car dir) '(:relative :absolute))
	(setq sub (cdr dir) n 1 has-abs t))
      (do () ((null sub))
	(cond ((eq (car sub) :up)
	       (cond ((or (eq n 0)
			  (and (stringp last)(string= last "**"))
			  (eq last :wild-inferiors)
			  kept-up
			  (and has-abs (eq n 1)))
		      ;; up after "**" stays, initial :up stays, how bout 2 :ups
		      (setq kept-up t)
		      )
		     ((eq n 1) (setq dir (cddr dir) kept-up nil n -1))
		     (t (rplacd (nthcdr (- n 2) dir) (cdr sub))
			(setq n (- n 2) kept-up nil))))
	      (t (setq kept-up nil)))
	(setq last (car sub)
	      n (1+ n) 
	      sub (cdr sub))))
    dir))

(defun namestring (path)
  "Construct the full (name)string form of the pathname."
  (%str-cat (device-namestring path)
            (host-namestring path)
	    (directory-namestring path)
	    (file-namestring path)))

(defun device-namestring (path)
  (let* ((device (pathname-device path)))
    (if (and device (not (eq device :unspecific)))
      (%str-cat device ":")
      "")))

(defun host-namestring (path)
  "Return a string representation of the name of the host in the pathname."
  (let ((host (pathname-host path)))
    (if (and host (neq host :unspecific)) (%str-cat host ":") "")))

(defun directory-namestring (path)
  "Return a string representation of the directories used in the pathname."
  (%directory-list-namestring (pathname-directory path)
			      (neq (pathname-host path) :unspecific)))

(defun ensure-directory-namestring (string)
  (namestring (ensure-directory-pathname string)))

(defun ensure-directory-pathname (pathname)
  (let ((path (pathname pathname)))
    (if (directory-pathname-p path)
	path
	(cons-pathname (append (or (pathname-directory path)
				   ;; This makes sure "ccl:foo" maps to "ccl:foo;" (not
				   ;; "ccl:;foo;"), but "foo" maps to "foo/" (not "/foo/").
				   (if (eq (pathname-host path) :unspecific)
				       '(:relative)
				       '(:absolute)))
			       ;; Don't use file-namestring, because that
			       ;; includes the version for logical names.
			       (list (file-namestring-from-parts
				      (pathname-name path)
				      (pathname-type path)
				      nil)))
		       nil nil (pathname-host path) nil #+windows-target (pathname-device path)))))

(defun %directory-list-namestring (list &optional logical-p)
  (if (null list)
    ""
    (let ((len (if (eq (car list) (if logical-p :relative :absolute)) 1 0))

          result)
      (declare (fixnum len)(optimize (speed 3)(safety 0)))
      (dolist (s (%cdr list))
        (case s
          (:wild (setq len (+ len 2)))
          (:wild-inferiors (setq len (+ len 3)))
          (:up (setq len (+ len 3)))
          (t ;This assumes that special chars in dir components are escaped,
	     ;otherwise would have to pre-scan for escapes here.
	   (setq len (+ len 1 (length s))))))
      (setq result
	    (make-string len))
      (let ((i 0)
            (sep (if logical-p #\; #\/)))
        (declare (fixnum i))
        (when (eq (%car list) (if logical-p :relative :absolute))
          (setf (%schar result 0) sep)
          (setq i 1))
        (dolist (s (%cdr list))
	  (case s
	    (:wild (setq s "*"))
	    (:wild-inferiors (setq s "**"))
	    ;; There is no :up in logical pathnames, so this must be native
	    (:up (setq s "..")))
	  (let ((len (length s)))
	    (declare (fixnum len))
	    (move-string-bytes s result 0 i len)
	    (setq i (+ i len)))
	  (setf (%schar result i) sep)
	  (setq i (1+ i))))
      result)))

(defun file-namestring (path)
  "Return a string representation of the name used in the pathname."
  (let* ((path (pathname path))
         (name (pathname-name path))
         (type (pathname-type path))
         (version (if (typep path 'logical-pathname) (pathname-version path))))
    (file-namestring-from-parts name type version)))

(defun file-namestring-from-parts (name type version)
  (when (eq version :unspecific) (setq version nil))
  (when (eq type :unspecific) (setq type nil))
  (%str-cat (case name
	      ((nil :unspecific) "")
	      (:wild "*")
              ;; Quote periods if there is no type/version following, so don't get mistaken for a type.
              ;; Otherwise there is no need to quote them.
	      (t (%std-filename-quotes name (null (or type version)))))
	    (if (or type version)
	      (%str-cat (case type
			  ((nil) ".")
			  (:wild ".*")
			  (t (%str-cat "." (%std-filename-quotes type t))))
			(case version
			  ((nil) "")
			  (:newest ".newest")
			  (:wild ".*")
			  (t (%str-cat "." (if (fixnump version)
					     (%integer-to-string version)
					     version)))))
	      "")))

(defun enough-namestring (path &optional (defaults *default-pathname-defaults*))
  "Return an abbreviated pathname sufficent to identify the pathname relative
   to the defaults."
  (if (null defaults)
    (namestring path)
    (let* ((dir (pathname-directory path))
           (nam (pathname-name path))
           (typ (pathname-type path))
           (ver (pathname-version path))
           (host (pathname-host path))
           (logical-p (neq host :unspecific))
           (default-dir (pathname-directory defaults)))
      ;; enough-host-namestring
      (setq host (if (and host
                          (neq host :unspecific)
                          (not (equalp host (pathname-host defaults))))
                   (%str-cat host ":")
                   ""))
      ;; enough-directory-namestring
      (cond ((equalp dir default-dir)
             (setq dir '(:relative)))
            ((and dir default-dir
                  (eq (car dir) :absolute) (eq (car default-dir) :absolute))
             ;; maybe make it relative to defaults             
             (do ((p1 (cdr dir) (cdr p1))
                  (p2 (cdr default-dir) (cdr p2)))
                 ((or (null p2) (null p1) (not (equalp (car p1) (car p2))))
                  (when (and (null p2) (or t (neq p1 (cdr dir))))
                    (setq dir (cons :relative p1)))))))
      (setq dir (%directory-list-namestring dir logical-p))
      ;; enough-file-namestring
      (when (or (equalp ver (pathname-version defaults))
                (not logical-p))
        (setq ver nil))
      (when (and (null ver) (equalp typ (pathname-type defaults)))
        (setq typ nil))
      (when (and (null typ) (equalp nam (pathname-name defaults)))
        (setq nam nil))
      (setq nam (file-namestring-from-parts nam typ ver))
      (%str-cat host dir nam))))

(defun cons-pathname (dir name type &optional host version device)
  (if (neq host :unspecific)
    (%cons-logical-pathname dir name type host version)
    (%cons-pathname dir name type version device)))

(defun pathname (path)
  "Convert thing (a pathname, string or stream) into a pathname."
  (etypecase path
    (pathname path)
    (stream (%path-from-stream path))
    (string (string-to-pathname path))))

(defun %path-from-stream (stream)
  (or (pathname (stream-filename stream))
      (error "Can't determine pathname of ~S ." stream)))      ; ???

;Like (pathname stream) except returns NIL rather than error when there's no
;filename associated with the stream.
(defun stream-pathname (stream &aux (path (stream-filename stream)))
  (when path (pathname path)))

(defun get-pathname-sstring (string &optional (start 0) (end (length string)))
  #-windows-target
  (get-sstring string start end)
  #+windows-target
  (multiple-value-bind (sstr start end)
      (get-sstring string start end)
    (declare (fixnum start end)
             (simple-string sstr))
    (if (do* ((i start (1+ i)))
             ((= i end))
          (declare (fixnum i))
          (when (eql (schar sstr i) #\\)
            (return t)))
      (let* ((len (- end start))
             (new (make-string len)))
        (declare (fixnum len) (simple-string new))
        (dotimes (i len)
          (let* ((ch (schar sstr start)))
            (if (eql ch #\\)
              (setf (schar new i) #\/)
              (setf (schar new i) ch)))
          (incf start))
        (values new 0 len))
      (values sstr start end))))
              
(defun string-to-pathname (string &optional (start 0) (end (length string))
                                            (reference-host nil)
                                            (defaults *default-pathname-defaults*))
  (require-type reference-host '(or null string))
  (multiple-value-bind (sstr start end) (get-pathname-sstring string start end)
    (if (and (> end start)
             (eql (schar sstr start) #\~))
      (setq sstr (namestring-unquote (tilde-expand (subseq sstr start end)))
            start 0
            end (length sstr)))
    (let (directory name type host version device (start-pos start) (end-pos end) has-slashes)
      (multiple-value-setq (host start-pos has-slashes) (pathname-host-sstr sstr start-pos end-pos))
      (cond ((and host (neq host :unspecific))
             (when (and reference-host (not (string-equal reference-host host)))
               (error "Host in ~S does not match requested host ~S"
                      (%substr sstr start end) reference-host)))
            ((or reference-host
		 (and defaults
		      (neq (setq reference-host (pathname-host defaults)) :unspecific)))
	     ;;If either a reference-host is specified or defaults is a logical pathname
	     ;; then the string must be interpreted as a logical pathname.
	     (when has-slashes
	       (error "Illegal logical namestring ~S" (%substr sstr start end)))
             (setq host reference-host)))
      #+windows-target
      (when (and (eq host :unspecific)
                 (eql start-pos 0)
                 (eql (position #\: sstr) 1))
        (let* ((ch (schar sstr 0)))
          (when (and (alpha-char-p ch)
                     (standard-char-p ch))
            (setq device (make-string 1 :initial-element ch)
                  start-pos 2))))
      (multiple-value-setq (directory start-pos) (pathname-directory-sstr sstr start-pos end-pos host))
      (unless (eq host :unspecific)
	(multiple-value-setq (version end-pos) (pathname-version-sstr sstr start-pos end-pos)))
      (multiple-value-setq (type end-pos) (pathname-type-sstr sstr start-pos end-pos))
      ;; now everything else is the name
      (unless (eq start-pos end-pos)
        (setq name (%std-name-component (%substr sstr start-pos end-pos))))
      (if (eq host :unspecific)
	(%cons-pathname directory name type (if name :newest) device)
        (%cons-logical-pathname directory name type host version)))))

(defun parse-namestring (thing &optional host (defaults *default-pathname-defaults*)
                               &key (start 0) end junk-allowed)
  (declare (ignore junk-allowed))
  (unless (typep thing 'string)
    (let* ((path (pathname thing))
	   (pathname-host (pathname-host path)))
      (when (and host pathname-host
		 (or (eq pathname-host :unspecific) ;physical
		     (not (string-equal host pathname-host))))
	(error "Host in ~S does not match requested host ~S" path host))
      (return-from parse-namestring (values path start))))
  (when host
    (verify-logical-host-name host))
  (setq end (check-sequence-bounds thing start end))
  (values (string-to-pathname thing start end host defaults) end))



(defun %std-device-component (device host)
  (when (and (or (null host) (eq host :unspecific))
             (and device (not (eq device :unspecific))))
    #+windows-target
    (unless (and (typep device 'string)
                 (eql (length device) 1)
                 (alpha-char-p (char device 0))
                 (standard-char-p (char device 0)))
      (error "Invalid pathname device ~s" device))
    device))
    
(defun make-pathname (&key (host nil host-p) 
                           (device nil device-p)
                           (directory nil directory-p)
                           (name nil name-p)
                           (type nil type-p)
                           (version nil version-p)
                           (defaults nil defaults-p) case
                           &aux path)
  "Makes a new pathname from the component arguments. Note that host is
a host-structure or string."
  (when case (setq case (require-type case pathname-case-type)))
  (if (null host-p)
    (let ((defaulted-defaults (if defaults-p defaults *default-pathname-defaults*)))
      (setq host (if defaulted-defaults
		   (pathname-host defaulted-defaults)
		   :unspecific)))
    (unless host (setq host :unspecific)))
  (if directory-p 
    (setq directory (%std-directory-component directory host)))
  (if (and defaults (not directory-p))
    (setq directory (pathname-directory defaults)))
  (if (and defaults (not device-p))
    (setq device (pathname-device defaults)))
  (setq device (%std-device-component device host))
  (setq name
        (if name-p
             (%std-name-component name)
             (and defaults (pathname-name defaults))))
  (setq type
        (if type-p
             (%std-type-component type)
             (and defaults (pathname-type defaults))))
  (setq version (if version-p
                  (%logical-version-component version)
		  (if name-p
		    nil
		    (and defaults (pathname-version defaults)))))
  (setq path
        (if (eq host :unspecific)
          (%cons-pathname directory name type version device)
          (%cons-logical-pathname
	   (or directory
	       (unless directory-p '(:absolute)))
	   name type host version)))
  (when (and (eq (car directory) :absolute)
	     (member (cadr directory) '(:up :back)))
    (error 'simple-file-error :pathname path :error-type "Second element of absolute directory component in ~s is ~s" :format-arguments (list (cadr directory))))
  (let* ((after-wif (cadr (member :wild-inferiors directory))))
    (when (member after-wif '(:up :back))
          (error 'simple-file-error :pathname path :error-type "Directory component in ~s contains :WILD-INFERIORS followed by ~s" :format-arguments (list after-wif))))
	 
  (when (and case (neq case :local))
    (setf (%pathname-directory path) (%reverse-component-case (%pathname-directory path) case)
          (%pathname-name path) (%reverse-component-case (%pathname-name path) case)
          (%pathname-type path) (%reverse-component-case (%pathname-type path) case)))
  path)

;;;  In portable CL, if the :directory argument to make pathname is a
;;;  string, it should be the name of a top-level directory and should
;;;  not contain any punctuation characters such as "/" or ";".  In
;;;  MCL a string :directory argument with slashes or semi-colons will
;;;  be parsed as a directory in the obvious way.
(defun %std-directory-component (directory host)
  (cond ((null directory) nil)
        ((eq directory :wild) '(:absolute :wild-inferiors))
        ((stringp directory) (%directory-string-list directory 0 (length directory) host))
        ((listp directory)
         ;Standardize the directory list, taking care not to cons if nothing
         ;needs to be changed.
         (let ((names (%cdr directory)) (new-names ()))
           (do ((nn names (%cdr nn)))
               ((null nn) (setq new-names (if new-names (nreverse new-names) names)))
             (let* ((name (car nn))
                    (new-name (%std-directory-part name)))
               (unless (eq name new-name)
                 (unless new-names
                   (do ((new-nn names (%cdr new-nn)))
                       ((eq new-nn nn))
                     (push (%car new-nn) new-names))))
               (when (or new-names (neq name new-name))
                 (push new-name new-names))))
           (when (memq :up (or new-names names))
             (setq new-names (remove-up (copy-list (or new-names names)))))
           (ecase (%car directory)
             (:relative           
                  (cond (new-names         ; Just (:relative) is the same as NIL. - no it isnt
                         (if (eq new-names names)
                           directory
                           (cons ':relative new-names)))
                        (t directory)))
             (:absolute
                  (cond ((null new-names) directory)  ; But just (:absolute) IS the same as NIL
                        ((eq new-names names) directory)
                        (t (cons ':absolute new-names)))))))
        (t (report-bad-arg directory '(or string list (member :wild))))))

(defun %std-directory-part (name)
  (case name
    ((:wild :wild-inferiors :up) name)
    (:back :up)
    (t (cond ((string= name "*") :wild)
             ((string= name "**") :wild-inferiors)
	     ((string= name "..") :up)
             (t (%std-filename-quotes name))))))

; this will allow creation of garbage pathname "foo:bar;bas:" do we care?
(defun merge-pathnames (path &optional (defaults *default-pathname-defaults*)
                                       (default-version :newest))
  "Construct a filled in pathname by completing the unspecified components
   from the defaults."
  ;(declare (ignore default-version))
  (when (not (pathnamep path))(setq path (pathname path)))
  (when (and defaults (not (pathnamep defaults)))(setq defaults (pathname defaults)))
  (let* ((path-dir (pathname-directory path))
         (path-host (pathname-host path))
         (path-name (pathname-name path))
	 (path-type (pathname-type path))
         (path-device (pathname-device path))
         (default-dir (and defaults (pathname-directory defaults)))
         (default-host (and defaults (pathname-host defaults)))
         (default-device (and defaults (pathname-device defaults)))
         ; take host from defaults iff path-dir is logical or absent - huh? 
         (host (cond ((or (null path-host)  ; added 7/96
                          (and (eq path-host :unspecific)
                               (or (null path-dir)
                                   (null (cdr path-dir))
                                   (and (eq :relative (car path-dir))
                                        (not (memq default-host '(nil :unspecific)))))))
                          
                      default-host)
                     (t  path-host)))
         (dir (cond ((null path-dir) default-dir)
                    ((null default-dir) path-dir)
                    ((eq (car path-dir) ':relative)
                     (let ((the-dir (append default-dir (%cdr path-dir))))
                       (when (memq ':up the-dir)(setq the-dir (remove-up (copy-list the-dir))))
                       the-dir))
                    (t path-dir)))
         (nam (or path-name
                  (and defaults (pathname-name defaults))))
         (typ (or path-type
                  (and defaults (pathname-type defaults))))
         (version (or (pathname-version path)
		      (cond ((not path-name)
			     (or (and defaults (pathname-version defaults))
                                 default-version))
			    (t default-version))))
         (device (or path-device default-device)))
    (if (and (pathnamep path)
             (eq dir (%pathname-directory path))
             (eq nam path-name)
             (eq typ (%pathname-type path))
             (eq host path-host)
             (eq device path-device)
             (eq version (pathname-version path)))
      path 
      (cons-pathname dir nam typ host version device))))

(defun directory-pathname-p (path)
  (let ((name (pathname-name path))(type (pathname-type path)))
    (and  (or (null name) (eq name :unspecific) (%izerop (length name)))
          (or (null type) (eq type :unspecific)))))

;In CCL, a pathname is logical if and only if pathname-host is not :unspecific.
(defun pathname-host (thing &key case)
  "Return PATHNAME's host."
  (when (streamp thing)(setq thing (%path-from-stream thing)))
  (when case (setq case (require-type case pathname-case-type)))
  (let ((name
         (typecase thing    
           (logical-pathname (%logical-pathname-host thing))
           (pathname :unspecific)
           (string (multiple-value-bind (sstr start end) (get-pathname-sstring thing) 
                     (pathname-host-sstr sstr start end)))
           (t (report-bad-arg thing pathname-arg-type)))))
    (if (and case (neq case :local))
      (progn
	(when (and (eq case :common) (neq name :unspecific)) (setq case :logical))
	(%reverse-component-case name case))
      name)))

(defun pathname-host-sstr (sstr start end &optional no-check)
  ;; A pathname with any (unescaped) /'s is always a physical pathname.
  ;; Otherwise, if the pathname has either a : or a ;, then it's always logical.
  ;; Otherwise, it's probably physical.
  ;; Return :unspecific for physical, host string or nil for a logical.
  (let* ((slash (%path-mem "/" sstr start end))
	 (pos (and (not slash) (%path-mem ":;" sstr start end)))
	 (pos-char (and pos (%schar sstr pos)))
	 (host (and (eql pos-char #\:) (%substr sstr start pos))))
    (cond (host
	   (unless (or no-check (logical-host-p host))
	     (error "~S is not a defined logical host" host))
	   (values host (%i+ pos 1) nil))
	  ((eql pos-char #\;) ; logical pathname with missing host
	   (values nil start nil))
	  (t ;else a physical pathname.
	   (values :unspecific start slash)))))


(defun pathname-device (thing &key case)
  "Return PATHNAME's device."
  (declare (ignore case))
  (let* ((p (pathname thing)))
    (etypecase p
      (logical-pathname :unspecific)
      (pathname (%physical-pathname-device p)))))



;A directory is either NIL or a (possibly wildcarded) string ending in "/" or ";"
;Quoted /'s are allowed at this stage, though will get an error when go to the
;filesystem.
(defun pathname-directory (path &key case)
  "Return PATHNAME's directory."
  (when (streamp path) (setq path (%path-from-stream path)))
  (when case (setq case (require-type case pathname-case-type)))
  (let* ((logical-p nil)
	 (names (typecase path
		  (logical-pathname (setq logical-p t) (%pathname-directory path))
		  (pathname (%pathname-directory path))
		  (string
		   (multiple-value-bind (sstr start end) (get-pathname-sstring path)
		     (multiple-value-bind (host pos2) (pathname-host-sstr sstr start end)
		       (unless (eq host :unspecific) (setq logical-p t))
                       #+windows-target
                       (unless logical-p
                         (if (and (> end 1)
                                  (eql (schar sstr 1) #\:))
                           (setq pos2 2)))
                       (pathname-directory-sstr sstr pos2 end host))))
		  (t (report-bad-arg path pathname-arg-type)))))
    (if (and case (neq case :local))
      (progn
	(when (and (eq case :common) logical-p) (setq case :logical))
	(%reverse-component-case names case))
      names)))

;; Must match pathname-directory-end below
(defun pathname-directory-sstr (sstr start end host)
  (if (and (eq host :unspecific)
           (> end start)
           (eql (schar sstr start) #\~))
    (setq sstr (tilde-expand (subseq sstr start end))
          start 0
          end (length sstr)))
  (let ((pos (%path-mem-last (if (eq host :unspecific) "/" ";") sstr start end)))
    (if pos
      (values 
       (%directory-string-list sstr start (setq pos (%i+ pos 1)) host)
       pos)
      (values (and (neq host :unspecific)
                   ;;(neq start end)
		   '(:absolute))
	      start))))

;; Must match pathname-directory-sstr above
(defun pathname-directory-end (sstr start end)
  (multiple-value-bind (host pos2) (pathname-host-sstr sstr start end)
    (let ((pos (%path-mem-last (if (eq host :unspecific) "/" ";") sstr pos2 end)))
      (if pos
	(values (%i+ pos 1) host)
	(values pos2 host)))))

(defun %directory-string-list (sstr start &optional (end (length sstr)) host)
  ;; Should use host to split by / vs. ; but for now support both for either host,
  ;; like the mac version. It means that ';' has to be quoted in unix pathnames.
  (declare (ignore host))
  ;This must cons up a fresh list, %expand-logical-directory rplacd's it.
  (labels ((std-part (sstr start end)
             (%std-directory-part (if (and (eq start 0) (eq end (length sstr)))
                                    sstr (%substr sstr start end))))
           (split (sstr start end)
	     (unless (eql start end)
	       (let ((pos (%path-mem "/;" sstr start end)))
		 (if (eq pos start)
		   (split sstr (%i+ start 1) end) ;; treat multiple ////'s as one.
                   (cons (std-part sstr start (or pos end))
                         (when pos
                           (split sstr (%i+ pos 1) end))))))))
    (unless (eq start end)
      (let* ((slash-pos (%path-mem "/" sstr start end))
	     (semi-pos (%path-mem ";" sstr start end))
	     (pos (or slash-pos semi-pos)))
	; this never did anything sensible but did not signal an error
        (when (and slash-pos semi-pos)
	  (error "Illegal directory string ~s" (%substr sstr start end)))
        (if (null pos)
	  (list :absolute (std-part sstr start end))
	  (let ((pos-char (%schar sstr pos)))
	    (cons (if (eq pos start)
		    (if (eq pos-char #\/) ':absolute ':relative)
		    (if (eq pos-char #\/) ':relative ':absolute))
		  (split sstr start end))))))))

(defun pathname-version (path)
  "Return PATHNAME's version."
  (when (streamp path) (setq path (%path-from-stream path)))
  (typecase path
    (logical-pathname (%logical-pathname-version path))
    (pathname (%physical-pathname-version path))
    (string
     (multiple-value-bind (sstr start end) (get-pathname-sstring path)
       (multiple-value-bind (newstart host) (pathname-directory-end sstr start end)
	 (if (eq host :unspecific)
	   nil
	   (values (pathname-version-sstr sstr newstart end))))))
    (t (report-bad-arg path pathname-arg-type))))

(defun pathname-version-sstr (sstr start end)
  (declare (fixnum start end))
  (let ((pos (%path-mem-last "." sstr start end)))
    (if (and pos (%i> pos start) (%path-mem "." sstr start (%i- pos 1)))
      (values (%std-version-component (%substr sstr (%i+ pos 1) end)) pos)
      (values nil end))))

(defun %std-version-component (v)
  (cond ((or (null v) (eq v :unspecific)) v)
	((eq v :wild) "*")
	((string= v "") :unspecific)
	((string-equal v "newest") :newest)
	((every #'digit-char-p v) (parse-integer v))
	(t (%std-filename-quotes v t))))


;A name is either NIL or a (possibly wildcarded, possibly empty) string.
;Quoted /'s are allowed at this stage, though will get an error if go to the
;filesystem.
(defun pathname-name (path &key case)
  "Return PATHNAME's name."
  (when (streamp path) (setq path (%path-from-stream path)))
  (when case (setq case (require-type case pathname-case-type)))
  (let* ((logical-p nil)
	 (name (typecase path
		 (logical-pathname (setq logical-p t) (%pathname-name path))
		 (pathname (%pathname-name path))
		 (string
		  (multiple-value-bind (sstr start end) (get-pathname-sstring path)
		    (multiple-value-bind (newstart host) (pathname-directory-end sstr start end)
		      (setq start newstart)
		      (unless (eq host :unspecific)
			(setq logical-p t)
			(setq end (nth-value 1 (pathname-version-sstr sstr start end))))
		      ;; TODO: -->> Need to make an exception so that ".emacs" is name with no type.
		      ;;   -->> Need to make an exception so that foo/.. is a directory pathname,
		      ;; for native.
		      (setq end (or (%path-mem-last "." sstr start end) end));; strip off type
		      (unless (eq start end)
			(%std-name-component (%substr sstr start end))))))
		 (t (report-bad-arg path pathname-arg-type)))))
    (if (and case (neq case :local))
      (progn
	(when (and (eq case :common) logical-p) (setq case :logical))
	(%reverse-component-case name case))
      name)))

(defun %std-name-component (name)
  (cond ((or (null name) (eq name :unspecific) (eq name :wild)) name)
        ((equal name "*") :wild)
        (t (%std-filename-quotes name))))

;A type is either NIL or a (possibly wildcarded, possibly empty) string.
;Quoted :'s are allowed at this stage, though will get an error if go to the
;filesystem.
(defun pathname-type (path &key case)
  "Return PATHNAME's type."
  (when (streamp path) (setq path (%path-from-stream path)))
  (when case (setq case (require-type case pathname-case-type)))
  (let* ((logical-p nil)
	 (name (typecase path
		 (logical-pathname (setq logical-p t) (%pathname-type path))
		 (pathname (%pathname-type path))
		 (string
		  (multiple-value-bind (sstr start end) (get-pathname-sstring path)
		    (multiple-value-bind (newstart host) (pathname-directory-end sstr start end)
		      (setq start newstart)
		      (unless (eq host :unspecific)
			(setq logical-p t)
			(setq end (nth-value 1 (pathname-version-sstr sstr start end))))
		      ;; TODO: -->> Need to make an exception so that ".emacs" is name with no type.
		      ;;   -->> Need to make an exception so that foo/.. is a directory pathname,
		      ;; for native.
		      (pathname-type-sstr sstr start end))))
		 (t (report-bad-arg path pathname-arg-type)))))
    (if (and case (neq case :local))
      (progn
	(when (and (eq case :common) logical-p) (setq case :logical))
	(%reverse-component-case name case))
      name)))

; assumes dir & version if any has been stripped away
(defun pathname-type-sstr (sstr start end)
  (let ((pos (%path-mem-last "." sstr start end)))
    (if pos
      (values (%std-type-component (%substr sstr (%i+ 1 pos) end)) pos)
      (values nil end))))

(defun %std-type-component (type)
  (cond ((or (null type) (eq type :unspecific) (eq type :wild)) type)
        ((equal type "*") :wild)
        (t (%std-filename-quotes type t))))

(defun %std-name-and-type (native)
  (let* ((end (length native))
	 (pos (position #\. native :from-end t))
	 (type (and pos (native-to-filename (%substr native (%i+ 1 pos) end))))
	 (name (unless (eq (or pos end) 0)
		 (native-to-filename (if pos (%substr native 0 pos) native)))))
    (values name type)))

(defun %reverse-component-case (name case)
  (cond ((not (stringp name))
         (if (listp name)
           (mapcar #'(lambda (name) (%reverse-component-case name case))  name)
           name))
        #+advanced-studlification-feature
        ((eq case :studly) (string-studlify name))
	((eq case :logical)
	 (if (every #'(lambda (ch) (not (lower-case-p ch))) name)
	   name
	   (string-upcase name)))
        (t ; like %read-idiocy but non-destructive - need it be?
         (let ((which nil)
               (len (length name)))
           (dotimes (i len)
             (let ((c (%schar name i)))
               (if (alpha-char-p c)
                 (if (upper-case-p c)
                   (progn
                     (when (eq which :lower)(return-from %reverse-component-case name))
                     (setq which :upper))
                   (progn
                     (when (eq which :upper)(return-from %reverse-component-case name))
                     (setq which :lower))))))
           (case which
             (:lower (string-upcase name))
             (:upper (string-downcase name))
             (t name))))))

;;;;;;; String-with-quotes utilities
(defun %path-mem-last-quoted (chars sstr &optional (start 0) (end (length sstr)))
  (while (%i< start end)
    (when (and (%%str-member (%schar sstr (setq end (%i- end 1))) chars)
               (%path-quoted-p sstr end start))
      (return-from %path-mem-last-quoted end))))

(defun %path-mem-last (chars sstr &optional (start 0) (end (length sstr)))
  (while (%i< start end)
    (when (and (%%str-member (%schar sstr (setq end (%i- end 1))) chars)
               (not (%path-quoted-p sstr end start)))
      (return-from %path-mem-last end))))

(defun %path-mem (chars sstr &optional (start 0) (end (length sstr)))
  (let ((one-char (when (eq (length chars) 1) (%schar chars 0))))
    (while (%i< start end)
      (let ((char (%schar sstr start)))
        (when (if one-char (eq char one-char)(%%str-member char chars))
          (return-from %path-mem start))
        (when (eq char *pathname-escape-character*)
          (setq start (%i+ start 1)))
        (setq start (%i+ start 1))))))

; these for \:  meaning this aint a logical host. Only legal for top level dir
 
(defun %path-unquote-one-quoted (chars sstr &optional (start 0)(end (length sstr)))
  (let ((pos (%path-mem-last-quoted chars sstr start end)))
    (when (and pos (neq pos 1))
      (cond ((or (%path-mem chars sstr start (1- pos))
                 (%path-mem-last-quoted chars sstr start (1- pos)))
             nil)
            (t (%str-cat (%substr sstr start (1- pos))(%substr sstr  pos end)))))))

(defun %path-one-quoted-p (chars sstr &optional (start 0)(end (length sstr)))
  (let ((pos (%path-mem-last-quoted chars sstr start end)))
    (when (and pos (neq pos 1))
      (not (or (%path-mem-last-quoted chars sstr start (1- pos))
               (%path-mem chars sstr start (1- pos)))))))
 
(defun %path-quoted-p (sstr pos start &aux (esc *pathname-escape-character*) (q nil))
  (while (and (%i> pos start) (eq (%schar sstr (setq pos (%i- pos 1))) esc))
    (setq q (not q)))
  q)



;Standardize pathname quoting, so can do EQUAL.
;; Subtle point: when keep-quoted is NIL, arg is assumed native,
;; and therefore escape characters are made quoted.
;; if keep-quoted is not NIL, e.g. if it's "", arg is assumed
;;   to be escaped already, so escape chars are interpreted as quotes.
;; Note that this can't be used to remove quotes because it
;; always keeps the escape character quoted.
(defun %path-std-quotes (arg keep-quoted make-quoted)
  (when (symbolp arg)
    (error "Invalid pathname component ~S" arg))
  (let* ((str arg)
         (esc *pathname-escape-character*)
         (end (length str))
         res-str char)
    (multiple-value-bind (sstr start)(array-data-and-offset str)
      (setq end (+ start end))
      (let ((i start))
        (until (eq i end)
          (setq char (%schar sstr i))
          (cond ((or (%%str-member char make-quoted)
                     (and (null keep-quoted) (eq char esc)))
                 (unless res-str
                   (setq res-str (make-array (%i- end start)
                                             :element-type (array-element-type sstr)
                                             :adjustable t :fill-pointer 0))
                   (do ((j start (%i+ j 1))) ((eq j i))
                     (vector-push-extend (%schar sstr j) res-str)))
                 (vector-push-extend esc res-str))
                ((neq char esc) nil)
                ((eq (setq i (%i+ i 1)) end)
                 (error "Malformed pathname component string ~S" str))
                ((or (eq (setq char (%schar sstr i)) esc)
                     (%%str-member char keep-quoted))
                 (when res-str (vector-push-extend esc res-str)))
                (t
                 (unless res-str
                   (setq res-str (make-array (%i- end start)
                                             :element-type (array-element-type sstr)
                                             :adjustable t :fill-pointer 0))
                   (do ((j start (%i+ j 1)) (end (%i- i 1))) ((eq j end))
                     (vector-push-extend (%schar sstr j) res-str)))))
          (when res-str (vector-push-extend char res-str))
          (setq i (%i+ i 1)))
        (ensure-simple-string (or res-str str))))))



(defun %%str-member (char string)
  (locally (declare (optimize (speed 3)(safety 0)))
    (dotimes (i (the fixnum (length string)))
      (when (eq (%schar string i) char)
        (return i)))))


(defun file-write-date (path)
  "Return file's last modification date, or NIL if it doesn't exist.
  An error of type file-error is signaled if file is a wild pathname"
  (%file-write-date (defaulted-native-namestring path)))

(defun file-author (path)
  "Return the file author as a string, or NIL if the author cannot be
  determined. Signal an error of type FILE-ERROR if FILE doesn't exist,
  or FILE is a wild pathname."
  (%file-author (defaulted-native-namestring path)))

(defun file-data-size (path)
  "Returns size of file's data fork, without needing to open the file.
   If the file has a resource fork, its size is not included here."
  (nth-value 2 (ccl::%stat (defaulted-native-namestring path))))

(defun touch (path)
  (if (not (probe-file path))
    (progn
      (ensure-directories-exist path)
      (if (or (pathname-name path)
              (pathname-type path))
        (create-file path)))
    (%utimes (defaulted-native-namestring path)))
  t)


;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
; load, require, provide

(defun find-load-file (file-name)
  (let ((full-name (full-pathname file-name :no-error nil))
        (kind nil))
    (when full-name
      (let ((file-type (pathname-type full-name))
            (merged (pathname (merge-pathnames file-name))))
        (if (and file-type (neq file-type :unspecific))
          (values (probe-file full-name) merged (if (eq (pathname-host file-name) :unspecific) full-name file-name))
          (let* ((source (merge-pathnames file-name *.lisp-pathname*))
                 (fasl   (merge-pathnames file-name *.fasl-pathname*))
                 (true-source (probe-file source))
                 (true-fasl   (probe-file fasl)))
            (cond (true-source
                   (if (and true-fasl
                            (> (file-write-date true-fasl)
                               (file-write-date true-source)))
                     (values true-fasl merged source)
                     (values true-source merged source)))
                  (true-fasl
                   (values true-fasl merged fasl))
                  ((and (multiple-value-setq (full-name kind)
                          (let* ((realpath (%realpath (defaulted-native-namestring full-name))))
                            (if realpath
                              (%probe-file-x realpath ))))
                        (eq kind :file))
                   (values full-name merged file-name)))))))))





(defun load (file-name &key (verbose *load-verbose*)
                       (print *load-print*)
                       (if-does-not-exist :error)
		       (external-format :default)
                       (preserve-optimization-settings *load-preserves-optimization-settings*))
  "Load the file given by FILESPEC into the Lisp environment, returning
   T on success.

   Extension: :PRINT :SOURCE means print source as well as value"
  (loop
    (restart-case
     (return (%load file-name verbose print if-does-not-exist external-format preserve-optimization-settings))
      (retry-load ()
                  :report (lambda (stream) (format stream "Retry loading ~s" file-name)))
      (skip-load ()
                 :report (lambda (stream) (format stream "Skip loading ~s" file-name))
                 (return nil))
      (load-other ()
                  :report (lambda (stream) (format stream "Load other file instead of ~s" file-name))
                  (return
                   (load (choose-file-dialog)
                         :verbose verbose
                         :print print
                         :if-does-not-exist if-does-not-exist))))))


(defun %load (file-name verbose print if-does-not-exist external-format preserve-optimization-settings)
  (let ((*load-pathname* file-name)
        (*load-truename* file-name)
        (source-file file-name)
        (optimization-setting-vars '(*nx-speed* *nx-space* *nx-safety*
                                     *nx-debug* *nx-cspeed*)))
    (declare (special *load-pathname* *load-truename*))
    (progv
        (if preserve-optimization-settings optimization-setting-vars)
        (if preserve-optimization-settings (mapcar #'symbol-value optimization-setting-vars))
    (when (typep file-name 'string-input-stream)
      (when verbose
          (format t "~&;Loading from stream ~S..." file-name)
          (force-output))
      (let ((*package* *package*)
            (*readtable* *readtable*))
        (load-from-stream file-name print))
      (return-from %load file-name))
    (when (and (stringp file-name)
               (eql (length "http://") (string-lessp "http://" file-name)))
      (when verbose
        (format t "~&;Loading from URL ~S..." file-name)
        (force-output))
      (let* ((vec (if if-does-not-exist
                    (snarf-url file-name)
                    (handler-case (snarf-url file-name)
                      (error () (return-from %load nil)))))
             (*package* *package*)
             (*readtable* *readtable*)
             (*loading-file-source-file* file-name)
             (*loading-files* (cons file-name (specialv *loading-files*))))
        (with-input-from-vector (stream vec :external-format external-format)
          (load-from-stream stream print)))
      (return-from %load file-name))
    (unless (streamp file-name)
      (multiple-value-setq (*load-truename* *load-pathname* source-file)
        (find-load-file (merge-pathnames file-name)))
      (when (not *load-truename*)
        (return-from %load (if if-does-not-exist
                             (signal-file-error $err-no-file file-name))))
      (setq file-name *load-truename*))
    (let* ((*package* *package*)
           (*readtable* *readtable*)
           (*loading-files* (cons file-name (specialv *loading-files*)))
           ;;reset by fasload to logical name stored in the file
           (*loading-file-source-file* (namestring source-file))
           (*loading-toplevel-location* nil))
      (declare (special *loading-files* *loading-file-source-file*))
      (when verbose
	(format t "~&;Loading ~S..." *load-pathname*)
	(force-output))
      (cond ((fasl-file-p file-name)
	     (let ((*fasload-print* print)
		   (restart-setup nil)
		   (restart-source nil)
		   (restart-fasl nil))
	       (declare (special *fasload-print*))
	       (flet ((restart-test (c)
			(unless restart-setup
			  (setq restart-setup t)
			  (let ((source *loading-file-source-file*)
				(fasl *load-pathname*))
			    (when (and (not (typep c 'file-error))
				       source
				       fasl
				       (setq source (probe-file source))
				       (setq fasl (probe-file fasl))
				       (not (equalp source fasl)))
			      (setq restart-fasl (namestring *load-pathname*)
				    restart-source *loading-file-source-file*))))
			(not (null restart-fasl)))
		      (fname (p)
			#-versioned-file-system
			(namestring (make-pathname :version :unspecific :defaults p))
			#+versioned-file-system
			(namestring p)))
		 (restart-case (multiple-value-bind (winp err) 
				   (%fasload (defaulted-native-namestring file-name))
				 (if (not winp) 
				   (%err-disp err)))
		   (load-source 
		    ()
		    :test restart-test
		    :report (lambda (s) 
			      (format s "Load ~s instead of ~s" 
				      (fname restart-source) (fname restart-fasl)))
		    (%load source-file verbose print if-does-not-exist external-format preserve-optimization-settings))
		   (recompile
		    ()
		    :test restart-test
		    :report (lambda (s)
			      (let ((*print-circle* NIL))
				(format s
					(if (equalp
					     restart-source
					     (make-pathname :type (pathname-type *.lisp-pathname*)
							    :defaults restart-fasl))
					  "Compile ~s and then load ~s again"
					  "Compile ~s into ~s then load ~:*~s again")
					(fname restart-source) (fname restart-fasl))))
		    (compile-file restart-source :output-file restart-fasl)
		    (%load restart-fasl verbose print if-does-not-exist external-format preserve-optimization-settings))))))
	    (t 
	     (with-open-file (stream file-name
				     :element-type 'base-char
				     :external-format (if (eq external-format :default) :inferred external-format))
	       (load-from-stream stream print)))))))
  file-name)

(defun load-from-stream (stream print &aux (eof-val (list ())) val)
  (with-compilation-unit (:override nil) ; try this for included files
    (let ((env (new-lexical-environment (new-definition-environment 'eval)))
          ;; source note map to use with any compilations.
          (*nx-source-note-map*  (and *save-source-locations*
                                      (make-hash-table :test #'eq :shared nil)))
          (*loading-toplevel-location* nil))
      (%rplacd (defenv.type (lexenv.parent-env env)) *outstanding-deferred-warnings*)
      (loop
        (multiple-value-setq (val *loading-toplevel-location*)
          (read-recording-source stream
                                 :eofval eof-val
                                 :file-name *loading-file-source-file*
                                 :map *nx-source-note-map*
                                 :save-source-text (neq *save-source-locations* :no-text)))
        (when (eq eof-val val)
          (return))
        (when (eq print :source) (format t "~&Source: ~S~%" val))
        (setq val (cheap-eval-in-environment val env))
        (when print
          (format t "~&~A~S~%" (if (eq print :source) "Value: " "") val))))))

(defun include (filename)
  (load
   (if (null *loading-files*)
     filename
     (merge-pathnames filename (directory-namestring (car *loading-files*))))))

(%fhave '%include #'include)

(defun delete-file (path)
  "Delete the specified FILE."
  (let* ((namestring (defaulted-native-namestring path))
	 (err (%delete-file namestring)))
    (or (eql 0 err) (signal-file-error err path))))

(defvar *known-backends* ())

(defun fasl-file-p (pathname)
  (let* ((type (pathname-type pathname)))
    (or (and (null *known-backends*)
	     (equal type (pathname-type *.fasl-pathname*)))
	(dolist (b *known-backends*)
	  (when (equal type (pathname-type (backend-target-fasl-pathname b)))
	    (return t)))
        (ignore-errors
          (with-open-file (f pathname
                             :direction :input
                             :element-type '(unsigned-byte 8))
            ;; Assume that (potential) FASL files start with #xFF00 (big-endian),
            ;; and that source files don't.
            (and (eql (read-byte f nil nil) #xff)
                 (eql (read-byte f nil nil) #x00)))))))

(defun provide (module)
  "Adds a new module name to *MODULES* indicating that it has been loaded.
   Module-name is a string designator"
  (pushnew (string module) *modules* :test #'string=)
  module)

(defparameter *loading-modules* () "Internal. Prevents circularity")
(defparameter *module-provider-functions* '(module-provide-search-path)
  "A list of functions called by REQUIRE to satisfy an unmet dependency.
Each function receives a module name as a single argument; if the function knows how to load that module, it should do so, add the module's name as a string to *MODULES* (perhaps by calling PROVIDE) and return non-NIL."
  )

(defun module-provide-search-path (module)
  ;; (format *debug-io* "trying module-provide-search-path~%")
  (let* ((module-name (string module))
         (pathname (find-module-pathnames module-name)))
    (when pathname
      (if (consp pathname)
        (dolist (path pathname) (load path))
        (load pathname))
      (provide module))))

(defun require (module &optional pathname)
  "Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
   is a designator for a list of pathnames to be loaded if the module
   needs to be. If PATHNAMES is not supplied, functions from the list
   *MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
   as an argument, until one of them returns non-NIL.  User code is
   responsible for calling PROVIDE to indicate a successful load of the
   module."
  (let* ((str (string module))
	 (original-modules (copy-list *modules*)))
    (unless (or (member str *modules* :test #'string=)
		(member str *loading-modules* :test #'string=))
      ;; The check of (and binding of) *LOADING-MODULES* is a
      ;; traditional defense against circularity.  (Another
      ;; defense is not having circularity, of course.)  The
      ;; effect is that if something's in the process of being
      ;; REQUIREd and it's REQUIREd again (transitively),
      ;; the inner REQUIRE is a no-op.
      (let ((*loading-modules* (cons str *loading-modules*)))
	(if pathname
	  (dolist (path (if (atom pathname) (list pathname) pathname))
	    (load path))
	  (unless (some (lambda (p) (funcall p module))
			*module-provider-functions*)
	    (error "Module ~A was not provided by any function on ~S." module '*module-provider-functions*)))))
    (values module
	    (set-difference *modules* original-modules))))

(defun find-module-pathnames (module)
  "Returns the file or list of files making up the module"
  (let ((mod-path (make-pathname :name (string-downcase module) :defaults nil)) path)
        (dolist (path-cand *module-search-path* nil)
	  (let ((mod-cand (merge-pathnames mod-path path-cand)))
	    (if (wild-pathname-p path-cand)
		(let* ((untyped-p (member (pathname-type mod-cand) '(nil :unspecific)))
		       (matches (if untyped-p
				    (or (directory (merge-pathnames mod-cand *.lisp-pathname*))
					(directory (merge-pathnames mod-cand *.fasl-pathname*)))
				    (directory mod-cand))))
		  (when (and matches (null (cdr matches)))
		    (return (if untyped-p
				(make-pathname :type nil :defaults (car matches))
				(car matches)))))
		(when (setq path (find-load-file (merge-pathnames mod-path path-cand)))
		  (return path)))))))

(defun wild-pathname-p (pathname &optional field-key)
  "Predicate for determining whether pathname contains any wildcards."
  (flet ((wild-p (name) (or (eq name :wild)
                            (eq name :wild-inferiors)
                            (and (stringp name) (%path-mem "*" name)))))
    (case field-key
      ((nil)
       (or (some #'wild-p (pathname-directory pathname))
           (wild-p (pathname-name pathname))
           (wild-p (pathname-type pathname))
           (wild-p (pathname-version pathname))))
      (:host nil)
      (:device nil)
      (:directory (some #'wild-p (pathname-directory pathname)))
      (:name (wild-p (pathname-name pathname)))
      (:type (wild-p (pathname-type pathname)))
      (:version (wild-p (pathname-version pathname)))
      (t (wild-pathname-p pathname
                          (require-type field-key 
                                        '(member nil :host :device 
                                          :directory :name :type :version)))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-streams.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2001 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;;

(defclass stream ()
  ())


(defclass input-stream (stream)
  ())


(defclass output-stream (stream) ())

(defmethod stream-direction ((s stream))
  )

(defmethod stream-domain ((s stream))
  t)


(defmethod stream-direction ((s input-stream))
  (if (typep s 'output-stream)
    :io
    :input))

(defmethod stream-direction ((s output-stream))
  (if (typep s 'input-stream)
    :io
    :output))

(defun check-io-timeout (timeout)
  (when timeout
    (require-type timeout '(real 0 1000000))))

(defmethod stream-input-timeout ((s input-stream))
  nil)

(defmethod (setf input-stream-timeout) (new (s input-stream))
  (check-io-timeout new))

(defmethod stream-output-timeout ((s output-stream))
  nil)

(defmethod (setf stream-output-timeout) (new (s output-stream))
  (check-io-timeout new))

;;; Try to return a string containing characters that're near the
;;; stream's current position, if that makes sense.  Return NIL
;;; if it doesn't make sense.
;;; Some things (SOCKET-ERRORs) are signaled as STREAM-ERRORs
;;; whose STREAM args aren't streams.  That's wrong, but
;;; defining this method on T keeps things from blowing up worse.
(defmethod stream-surrounding-characters ((s t))
  (declare (ignore s))
  nil)


;;; The "direction" argument only helps us dispatch on two-way streams:
;;; it's legal to ask for the :output device of a stream that's only open
;;; for input, and one might get a non-null answer in that case.
(defmethod stream-device ((s stream) direction)
  (declare (ignore direction)))

;;; Some generic stream functions:
(defmethod stream-length ((x t) &optional new)
  (declare (ignore new))
  (report-bad-arg x 'stream))

(defmethod stream-position ((x t) &optional new)
  (declare (ignore new))
  (report-bad-arg x 'stream))

(defmethod stream-element-type ((x t))
  (report-bad-arg x 'stream))

(defmethod stream-force-output ((x t))
  (report-bad-arg x 'stream))

(defmethod stream-position ((s stream) &optional newpos)
  (declare (ignore newpos)))

;;; For input streams:

;;; From Shannon Spires, slightly modified.
(defun generic-read-line (s)
  (collect ((chunks))
    (let* ((pos 0)
           (len 0)
           (chunksize 8192)
           (str (make-string chunksize))
           (eof nil))
      (declare (fixnum pos len chunksize)
               (simple-string str)
               (dynamic-extent str))
      (do* ((ch (read-char s nil :eof) (read-char s nil :eof)))
           ((or (eq ch #\newline) (setq eof (eq ch :eof)))
            (if (zerop len)
              (values (subseq str 0 pos) eof)
              (let* ((outpos 0))
                (setq len (+ len pos))
                (let* ((out (make-string len)))
                  (dolist (s (chunks))
                    (%uvector-replace out outpos s 0 chunksize target::subtag-simple-base-string)
                    (incf outpos chunksize))
                  (%uvector-replace out outpos str 0 pos target::subtag-simple-base-string)
                  (values out eof)))))
        (when (= pos chunksize)
          (chunks str)
          (setq str (make-string chunksize)
                len (+ len pos)
                pos 0))
        (setf (schar str pos) ch
              pos (1+ pos))))))


(defun generic-character-read-list (stream list count)
  (declare (fixnum count))
  (do* ((tail list (cdr tail))
	(i 0 (1+ i)))
       ((= i count) count)
    (declare (fixnum i))
    (let* ((ch (read-char stream nil :eof)))
      (if (eq ch :eof)
	(return i)
	(rplaca tail ch)))))

(defun generic-binary-read-list (stream list count)
  (declare (fixnum count))
  (do* ((tail list (cdr tail))
	(i 0 (1+ i)))
       ((= i count) count)
    (declare (fixnum i))
    (let* ((ch (stream-read-byte stream)))
      (if (eq ch :eof)
	(return i)
	(rplaca tail ch)))))

(defun generic-character-read-vector (stream vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i)))
       ((= i end) end)
    (declare (fixnum i))
    (let* ((ch (stream-read-char stream)))
      (if (eq ch :eof)
	(return i)
	(setf (uvref vector i) ch)))))

(defun generic-binary-read-vector (stream vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i)))
       ((= i end) end)
    (declare (fixnum i))
    (let* ((byte (stream-read-byte stream)))
      (if (eq byte :eof)
	(return i)
	(setf (uvref vector i) byte)))))


;;; For output streams:

(defun generic-advance-to-column (s col)
  (let* ((current (column s)))
    (unless (null current)
      (when (< current col)
	(do* ((i current (1+ i)))
	     ((= i col))
	  (write-char #\Space s)))
      t)))



(defun generic-stream-write-string (stream string start end)
  (setq end (check-sequence-bounds string start end))
  (locally (declare (fixnum start end))
    (multiple-value-bind (vect offset) (array-data-and-offset string)
      (declare (fixnum offset))
      (unless (zerop offset)
	(incf start offset)
	(incf end offset))
      (do* ((i start (1+ i)))
	   ((= i end) string)
	(declare (fixnum i))
	(write-char (schar vect i) stream)))))












(defstatic *heap-ivectors* ())
(defvar *heap-ivector-lock* (make-lock))



(defun %make-heap-ivector (subtype size-in-bytes size-in-elts)
  (with-macptrs ((ptr (malloc (+ size-in-bytes
                                 #+32-bit-target (+ 4 2 7) ; 4 for header, 2 for delta, 7 for round up
                                 #+64-bit-target (+ 8 2 15) ; 8 for header, 2 for delta, 15 for round up
                                 ))))
    (let ((vect (fudge-heap-pointer ptr subtype size-in-elts))
          (p (%null-ptr)))
      (%vect-data-to-macptr vect p)
      (with-lock-grabbed (*heap-ivector-lock*)
        (push vect *heap-ivectors*))
      (values vect p))))

(defun %heap-ivector-p (v)
  (with-lock-grabbed (*heap-ivector-lock*)
    (not (null (member v *heap-ivectors* :test #'eq)))))


(defun dispose-heap-ivector (v)
  (if (%heap-ivector-p v)
    (with-macptrs (p)
      (with-lock-grabbed (*heap-ivector-lock*)
        (setq *heap-ivectors* (delq v *heap-ivectors*)))
      (%%make-disposable p v)
      (free p))))

(defun %dispose-heap-ivector (v)
  (dispose-heap-ivector v))

(defun make-heap-ivector (element-count element-type)
  (require-type element-count `(unsigned-byte ,(- target::nbits-in-word
						  target::num-subtag-bits)))
  (let* ((subtag (ccl::element-type-subtype element-type)))
    (unless
        #+ppc32-target
        (= (logand subtag ppc32::fulltagmask)
               ppc32::fulltag-immheader)
        #+ppc64-target
        (= (logand subtag ppc64::lowtagmask)
           ppc64::lowtag-immheader)
        #+x8632-target
        (= (logand subtag x8632::fulltagmask)
	   x8632::fulltag-immheader)
        #+x8664-target
        (logbitp (the (mod 16) (logand subtag x8664::fulltagmask))
                 (logior (ash 1 x8664::fulltag-immheader-0)
                         (ash 1 x8664::fulltag-immheader-1)
                         (ash 1 x8664::fulltag-immheader-2)))
        #+arm-target
        (= (logand subtag arm::fulltagmask)
           arm::fulltag-immheader)
      (error "~s is not an ivector subtype." element-type))
    (let* ((size-in-octets (ccl::subtag-bytes subtag element-count)))
      (multiple-value-bind (vector pointer)
          (ccl::%make-heap-ivector subtag size-in-octets element-count)
        (values vector pointer size-in-octets)))))









(defvar *elements-per-buffer* 2048)  ; default buffer size for file io

(defmethod streamp ((x t))
  nil)

(defmethod streamp ((x stream))
  t)

(defmethod stream-io-error ((stream stream) error-number context)
  (error 'simple-stream-error :stream stream
	 :format-control (format nil "~a during ~a"
				 (%strerror error-number) context)))



(defmethod stream-write-char ((stream stream) char)
  (declare (ignore char))
  (error "stream ~S is not capable of output" stream))

(defun stream-write-entire-string (stream string)
  (stream-write-string stream string))


(defmethod stream-read-char ((x t))
  (report-bad-arg x 'stream))

(defmethod stream-read-char ((stream stream))
  (error "~s is not capable of input" stream))

(defmethod stream-unread-char ((x t) char)
  (declare (ignore char))
  (report-bad-arg x 'stream))

(defmethod stream-unread-char ((stream stream) char)
  (declare (ignore char))
  (error "stream ~S is not capable of input" stream))



(defmethod stream-force-output ((stream output-stream)) nil)
(defmethod stream-maybe-force-output ((stream stream))
  (stream-force-output stream))

(defmethod stream-finish-output ((stream output-stream)) nil)



(defmethod stream-clear-output ((stream output-stream)) nil)

(defmethod close ((stream stream) &key abort)
  (declare (ignore abort))
  (open-stream-p stream))

(defmethod close-for-termination ((stream stream) abort)
  (close stream :abort abort))


(defmethod open-stream-p ((x t))
  (report-bad-arg x 'stream))

(defmethod open-stream-p ((stream stream))
  t)

(defmethod stream-external-format ((x t))
  (report-bad-arg x 'stream))

(defmethod stream-external-format ((s stream))
  nil)


(defmethod (setf stream-external-format) (new (s t))
  (normalize-external-format (stream-domain s) new)
  (report-bad-arg s 'stream))



    
(defmethod stream-fresh-line ((stream output-stream))
  (terpri stream)
  t)

(defmethod stream-line-length ((stream stream))
  "This is meant to be shadowed by particular kinds of streams,
   esp those associated with windows."
  *default-right-margin*)

(defmethod interactive-stream-p ((x t))
  (report-bad-arg x 'stream))

(defmethod interactive-stream-p ((stream stream)) nil)

(defmethod stream-clear-input ((x t))
  (report-bad-arg x 'input-stream))

(defmethod stream-clear-input ((stream input-stream)) nil)

(defmethod stream-listen ((stream input-stream))
  (not (eofp stream)))

(defmethod stream-filename ((stream stream))
  (report-bad-arg stream 'file-stream))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; For input streams, the IO-BUFFER-COUNT field denotes the number
;;; of elements read from the underlying input source (e.g., the
;;; file system.)  For output streams, it's the high-water mark of
;;; elements output to the buffer.

(defstruct io-buffer
               ;; This type is too complex during bootstrapping.
  (buffer nil #|:type (or (simple-array * (*)) null)|#)
  (bufptr nil :type (or macptr null))
  (size 0 :type fixnum)			; size (in octets) of buffer
  (idx 0 :type fixnum)			; index of next element
  (count 0 :type fixnum)		; count of active elements
  (limit 0 :type fixnum)		; size (in elements) of buffer
  (translate nil)                       ; newline-translation
  )

(defmethod print-object ((buf io-buffer) out)
  (print-unreadable-object (buf out :identity t :type t)
    (let* ((buffer (io-buffer-buffer buf)))
      (when buffer (format out " ~s " (array-element-type buffer))))
    (format out "~d/~d/~d"
	    (io-buffer-idx buf)
	    (io-buffer-count buf)
	    (io-buffer-limit buf))))

(defstruct ioblock
  stream                                ; the stream being buffered
  untyi-char                            ; nil or last value passed to
                                        ;  stream-unread-char
  (inbuf nil :type (or null io-buffer))
  (outbuf nil :type (or null io-buffer))
  (element-type 'character)
  (element-shift 0 :type fixnum)        ;element shift count
  (charpos 0 :type (or null fixnum))     ;position of cursor
  (device -1 :type (or null fixnum))     ;file descriptor
  (advance-function 'ioblock-advance)
  (listen-function 'ioblock-listen)
  (eofp-function 'ioblock-eofp)
  (force-output-function 'ioblock-force-output)
  (close-function 'ioblock-close)
  (inbuf-lock nil)
  (eof nil)
  (interactive nil)
  (dirty nil)
  (outbuf-lock nil)
  (owner nil)
  (read-char-function 'ioblock-no-char-input)
  (read-byte-function 'ioblock-no-binary-input)
  (write-byte-function 'ioblock-no-binary-output)
  (write-char-function 'ioblock-no-char-output)
  (encoding nil)
  (pending-byte-order-mark nil)
  (decode-literal-code-unit-limit 256)
  (encode-output-function nil)
  (decode-input-function nil)
  (read-char-when-locked-function 'ioblock-no-char-input)
  (write-simple-string-function 'ioblock-no-char-output)
  (character-read-vector-function 'ioblock-no-char-input)
  (read-line-function 'ioblock-no-char-input)
  (write-char-when-locked-function 'ioblock-no-char-output)
  (read-byte-when-locked-function 'ioblock-no-binary-input)
  (write-byte-when-locked-function 'ioblock-no-binary-output)
  (peek-char-function 'ioblock-no-char-input)
  (native-byte-order t)
  (read-char-without-translation-when-locked-function 'ioblock-no-char-input)
  (write-char-without-translation-when-locked-function 'iblock-no-char-output)
  (sharing nil)
  (line-termination nil)
  (unread-char-function 'ioblock-no-char-input)
  (encode-literal-char-code-limit 256)
  (input-timeout nil)			;in milliseconds
  (output-timeout nil)			;in milliseconds
  (deadline nil))


;;; Functions on ioblocks.  So far, we aren't saying anything
;;; about how streams use them.

(defun ioblock-no-binary-input (ioblock &rest otters)
  (declare (ignore otters))
  (report-bad-arg (ioblock-stream ioblock) '(and binary-stream input-stream)))

(defun ioblock-no-binary-output (ioblock &rest others)
  (declare (ignore others))
  (report-bad-arg (ioblock-stream ioblock) '(and binary-stream output-stream)))

(defun ioblock-no-char-input (ioblock &rest others)
  (declare (ignore others))
  (report-bad-arg (ioblock-stream ioblock) '(and character-stream input-stream)))

(defun ioblock-no-char-output (ioblock &rest others)
  (declare (ignore others))
  (report-bad-arg (ioblock-stream ioblock) '(and character-stream output-stream)))


(defun ioblock-octets-to-elements (ioblock octets)
  (let* ((shift (ioblock-element-shift ioblock)))
    (declare (fixnum shift))
    (if (zerop shift)
      octets
      (ash octets (- shift)))))

(defun ioblock-elements-to-octets (ioblock elements)
  (let* ((shift (ioblock-element-shift ioblock)))
    (declare (fixnum shift))
    (if (zerop shift)
      elements
      (ash elements shift))))



;;; ioblock must really be an ioblock or you will crash
;;; Also: the expression "ioblock" is evaluated multiple times.

(declaim (inline check-ioblock-owner))
(defun check-ioblock-owner (ioblock)
  (declare (optimize (speed 3)))
  (let* ((owner (ioblock-owner ioblock)))
    (if owner
      (or (eq owner *current-process*)
          (conditional-store (ioblock-owner ioblock) 0 *current-process*)
          (error "Stream ~s is private to ~s" (ioblock-stream ioblock) owner)))))



(declaim (inline %ioblock-advance))
(defun %ioblock-advance (ioblock read-p)
  (funcall (ioblock-advance-function ioblock)
           (ioblock-stream ioblock)
           ioblock
           read-p))


(defun %ioblock-surrounding-characters (ioblock)
  (let* ((inbuf (ioblock-inbuf ioblock)))
    (when inbuf
      (let* ((encoding (or (ioblock-encoding ioblock)
                           (get-character-encoding nil)))
             (size (ash (character-encoding-code-unit-size encoding) -3))
             (buffer (io-buffer-buffer inbuf))
             (idx (io-buffer-idx inbuf))
             (count (io-buffer-count inbuf)))
        (unless (= count 0)
          (let* ((start (max (- idx (* 10 size)) 0))
                 (end (min (+ idx (* 10 size)) count))
                 (string (make-string (funcall (character-encoding-length-of-vector-encoding-function encoding) buffer start end))))
            (funcall (character-encoding-vector-decode-function encoding)
                     buffer
                     start
                     (- end start)
                     string)
            (if (position #\Replacement_Character string)
              (string-trim (string #\Replacement_Character) string)
              string)))))))
             
        


(defun %bivalent-ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (setf (ioblock-untyi-char ioblock) nil)
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %bivalent-ioblock-read-u8-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 8) (*))
              (io-buffer-buffer buf)) idx)))


(declaim (inline %ioblock-read-u8-byte))
(defun %ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-u8-byte :eof))
      (setq idx (io-buffer-idx buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 8) (*))
            (io-buffer-buffer buf)) idx)))

(declaim (inline %ioblock-read-u8-code-unit))
(defun %ioblock-read-u8-code-unit (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-u8-code-unit :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 8) (*))
              (io-buffer-buffer buf)) idx)))             

(declaim (inline %ioblock-read-s8-byte))
(defun %ioblock-read-s8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-s8-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (signed-byte 8) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-s8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-s8-byte ioblock))

(defun %locked-ioblock-read-s8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-s8-byte ioblock)))


(declaim (inline %ioblock-read-u16-byte))
(defun %ioblock-read-u16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-u16-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 16) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-u16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u16-byte ioblock))

(defun %locked-ioblock-read-u16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u16-byte ioblock)))

(declaim (inline %ioblock-read-s16-byte))
(defun %ioblock-read-s16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-s16-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (signed-byte 16) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-s16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-s16-byte ioblock))

(defun %locked-ioblock-read-s16-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-s16-byte ioblock)))


(declaim (inline %ioblock-read-u32-byte))
(defun %ioblock-read-u32-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-u32-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 32) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-u32-byte (ioblock)
  (check-ioblock-owner ioblock)
  (%ioblock-read-u32-byte ioblock))

(defun %locked-ioblock-read-u32-byte (ioblock)
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u32-byte ioblock)))

(declaim (inline %ioblock-read-s32-byte))
(defun %ioblock-read-s32-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-s32-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (signed-byte 32) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-s32-byte (ioblock)
  (check-ioblock-owner ioblock)
  (%ioblock-read-s32-byte ioblock))

(defun %locked-ioblock-read-s32-byte (ioblock)
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-s32-byte ioblock)))

#+64-bit-target
(progn
(declaim (inline %ioblock-read-u64-byte))
(defun %ioblock-read-u64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-u64-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (unsigned-byte 64) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-u64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u64-byte ioblock))

(defun %locked-ioblock-read-u64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u64-byte ioblock)))

(defun %ioblock-read-s64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf)))
    (declare (fixnum idx limit))
    (when (= idx limit)
      (unless (%ioblock-advance ioblock t)
        (return-from %ioblock-read-s64-byte :eof))
      (setq idx (io-buffer-idx buf)
            limit (io-buffer-count buf)))
    (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
    (aref (the (simple-array (signed-byte 64) (*))
            (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-s64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-s64-byte ioblock))

(defun %locked-ioblock-read-s64-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-s64-byte ioblock)))
)


;;; Read a 16-bit code element from a stream with element-type
;;; (UNSIGNED-BYTE 8), in native byte-order.

(declaim (inline %ioblock-read-u16-code-unit))
(defun %ioblock-read-u16-code-unit (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf))
         (vector (io-buffer-buffer buf)))
    (declare (fixnum idx limit)
             (type (simple-array (unsigned-byte 8) (*)) vector))
    (if (<= (the fixnum (+ idx 2)) limit)
      (let* ((b0 (aref vector idx))
             (b1 (aref vector (the fixnum (1+ idx)))))
        (declare (type (unsigned-byte 8) b0 b1))
        (setf (io-buffer-idx buf) (the fixnum (+ idx 2)))
        #+big-endian-target
        (logior (the (unsigned-byte 16) (ash b0 8)) b1)
        #+little-endian-target
        (logior (the (unsigned-byte 16) (ash b1 8)) b0))
      (if (< idx limit)
        (let* ((b0 (aref vector idx))
               (n (%ioblock-advance ioblock t)))
          (declare (type (unsigned-byte 8) b0))
          (if (null n)
            :eof
            (let* ((b1 (aref vector 0)))
              (declare (type (unsigned-byte 8) b1))
              (setf (io-buffer-idx buf) 1)
              #+big-endian-target
              (logior (the (unsigned-byte 16) (ash b0 8)) b1)
              #+little-endian-target
              (logior (the (unsigned-byte 16) (ash b1 8)) b0))))
        (let* ((n (%ioblock-advance ioblock t)))
          (if (null n)
            :eof
            (if (eql n 1)
              (progn
                (setf (io-buffer-idx buf) 1)
                :eof)
              (let* ((b0 (aref vector 0))
                     (b1 (aref vector 1)))
                (declare (type (unsigned-byte 8) b0 b1))
                (setf (io-buffer-idx buf) 2)
                #+big-endian-target
                (logior (the (unsigned-byte 16) (ash b0 8)) b1)
                #+little-endian-target
                (logior (the (unsigned-byte 16) (ash b1 8)) b0)))))))))
  
(declaim (inline %ioblock-read-swapped-u16-code-unit))
(defun %ioblock-read-swapped-u16-code-unit (ioblock)
  (declare (optimize (speed 3) (safety 0)))
    (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf))
         (vector (io-buffer-buffer buf)))
    (declare (fixnum idx limit)
             (type (simple-array (unsigned-byte 8) (*)) vector))
    (if (<= (the fixnum (+ idx 2)) limit)
      (let* ((b0 (aref vector idx))
             (b1 (aref vector (the fixnum (1+ idx)))))
        (declare (type (unsigned-byte 8) b0 b1))
        (setf (io-buffer-idx buf) (the fixnum (+ idx 2)))
        #+little-endian-target
        (logior (the (unsigned-byte 16) (ash b0 8)) b1)
        #+big-endian-target
        (logior (the (unsigned-byte 16) (ash b1 8)) b0))
      (if (< idx limit)
        (let* ((b0 (aref vector idx))
               (n (%ioblock-advance ioblock t)))
          (declare (type (unsigned-byte 8) b0))
          (if (null n)
            :eof
            (let* ((b1 (aref vector 0)))
              (declare (type (unsigned-byte 8) b1))
              (setf (io-buffer-idx buf) 1)
              #+little-endian-target
              (logior (the (unsigned-byte 16) (ash b0 8)) b1)
              #+big-endian-target
              (logior (the (unsigned-byte 16) (ash b1 8)) b0))))
        (let* ((n (%ioblock-advance ioblock t)))
          (if (null n)
            :eof
            (if (eql n 1)
              (progn
                (setf (io-buffer-idx buf) 1)
                :eof)
              (let* ((b0 (aref vector 0))
                     (b1 (aref vector 1)))
                (declare (type (unsigned-byte 8) b0 b1))
                (setf (io-buffer-idx buf) 2)
                #+little-endian-target
                (logior (the (unsigned-byte 16) (ash b0 8)) b1)
                #+big-endian-target
                (logior (the (unsigned-byte 16) (ash b1 8)) b0)))))))))


(declaim (inline %ioblock-read-u32-code-unit))
(defun %ioblock-read-u32-code-unit (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf))
         (vector (io-buffer-buffer buf)))
    (declare (fixnum idx limit)
             (type (simple-array (unsigned-byte 8) (*)) vector))
    (cond ((<= (the fixnum (+ idx 4)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (b2 (aref vector (the fixnum (+ idx 2))))
                  (b3 (aref vector (the fixnum (+ idx 3)))))
             (declare (type (unsigned-byte 8) b0 b1 b2 b3))
             (setf (io-buffer-idx buf) (the fixnum (+ idx 4)))
             #+big-endian-target
             (logior (the (unsigned-byte 32) (ash b0 24))
                     (the (unsigned-byte 24) (ash b1 16))
                     (the (unsigned-byte 16) (ash b2 8))
                     b3)
             #+little-endian-target
             (logior (the (unsigned-byte 32) (ash b3 24))
                     (the (unsigned-byte 24) (ash b2 16))
                     (the (unsigned-byte 16) (ash b1 8))
                     b0)))
          ((= (the fixnum (+ idx 3)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (b2 (aref vector (the fixnum (+ idx 2))))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0 b1 b2))
             (if (null n)
               :eof
               (let* ((b3 (aref vector 0)))
                 (declare (type (unsigned-byte 8) b3))
                 (setf (io-buffer-idx buf) 1)
                 #+big-endian-target
                 (logior (the (unsigned-byte 32) (ash b0 24))
                         (the (unsigned-byte 24) (ash b1 16))
                         (the (unsigned-byte 16) (ash b2 8))
                         b3)
                 #+little-endian-target
                 (logior (the (unsigned-byte 32) (ash b3 24))
                         (the (unsigned-byte 24) (ash b2 16))
                         (the (unsigned-byte 16) (ash b1 8))
                         b0)))))
          ((= (the fixnum (+ idx 2)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0 b1))
             (if (null n)
               :eof
               (if (eql n 1)
                 (progn
                   (setf (io-buffer-idx buf) 1)
                   :eof)
                 (let* ((b2 (aref vector 0))
                        (b3 (aref vector 1)))
                   (declare (type (unsigned-byte 8) b2 b3))
                   (setf (io-buffer-idx buf) 2)
                   #+big-endian-target
                   (logior (the (unsigned-byte 32) (ash b0 24))
                           (the (unsigned-byte 24) (ash b1 16))
                           (the (unsigned-byte 16) (ash b2 8))
                           b3)
                   #+little-endian-target
                   (logior (the (unsigned-byte 32) (ash b3 24))
                           (the (unsigned-byte 24) (ash b2 16))
                           (the (unsigned-byte 16) (ash b1 8))
                           b0))))))
          ((= (the fixnum (1+ idx)) limit)
           (let* ((b0 (aref vector idx))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0))
             (if (null n)
               :eof
               (if (< n 3)
                 (progn
                   (setf (io-buffer-idx buf) n)
                   :eof)
                 (let* ((b1 (aref vector 0))
                        (b2 (aref vector 1))
                        (b3 (aref vector 2)))
                   (setf (io-buffer-idx buf) 3)
                   #+big-endian-target
                   (logior (the (unsigned-byte 32) (ash b0 24))
                           (the (unsigned-byte 24) (ash b1 16))
                           (the (unsigned-byte 16) (ash b2 8))
                           b3)
                   #+little-endian-target
                   (logior (the (unsigned-byte 32) (ash b3 24))
                           (the (unsigned-byte 24) (ash b2 16))
                           (the (unsigned-byte 16) (ash b1 8))
                           b0))))))
          (t
           (let* ((n (%ioblock-advance ioblock t)))
             (if (null n)
               :eof
               (if (< n 4)
                 (progn
                   (setf (io-buffer-idx buf) n)
                   :eof)
                 (let* ((b0 (aref vector 0))
                        (b1 (aref vector 1))
                        (b2 (aref vector 2))
                        (b3 (aref vector 3)))
                (declare (type (unsigned-byte 8) b0 b1 b2 b3))
                (setf (io-buffer-idx buf) 4)
                #+big-endian-target
                (logior (the (unsigned-byte 32) (ash b0 24))
                        (the (unsigned-byte 24) (ash b1 16))
                        (the (unsigned-byte 16) (ash b2 8))
                        b3)
                #+little-endian-target
                (logior (the (unsigned-byte 32) (ash b3 24))
                        (the (unsigned-byte 24) (ash b2 16))
                        (the (unsigned-byte 16) (ash b1 8))
                        b0)))))))))

(declaim (inline %ioblock-read-swapped-u32-code-unit))
(defun %ioblock-read-swapped-u32-code-unit (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx buf))
         (limit (io-buffer-count buf))
         (vector (io-buffer-buffer buf)))
    (declare (fixnum idx limit)
             (type (simple-array (unsigned-byte 8) (*)) vector))
    (cond ((<= (the fixnum (+ idx 4)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (b2 (aref vector (the fixnum (+ idx 2))))
                  (b3 (aref vector (the fixnum (+ idx 3)))))
             (declare (type (unsigned-byte 8) b0 b1 b2 b3))
             (setf (io-buffer-idx buf) (the fixnum (+ idx 4)))
             #+little-endian-target
             (logior (the (unsigned-byte 32) (ash b0 24))
                     (the (unsigned-byte 24) (ash b1 16))
                     (the (unsigned-byte 16) (ash b2 8))
                     b3)
             #+big-endian-target
             (logior (the (unsigned-byte 32) (ash b3 24))
                     (the (unsigned-byte 24) (ash b2 16))
                     (the (unsigned-byte 16) (ash b1 8))
                     b0)))
          ((= (the fixnum (+ idx 3)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (b2 (aref vector (the fixnum (+ idx 2))))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0 b1 b2))
             (if (null n)
               :eof
               (let* ((b3 (aref vector 0)))
                 (declare (type (unsigned-byte 8) b3))
                 (setf (io-buffer-idx buf) 1)
                 #+little-endian-target
                 (logior (the (unsigned-byte 32) (ash b0 24))
                         (the (unsigned-byte 24) (ash b1 16))
                         (the (unsigned-byte 16) (ash b2 8))
                         b3)
                 #+big-endian-target
                 (logior (the (unsigned-byte 32) (ash b3 24))
                         (the (unsigned-byte 24) (ash b2 16))
                         (the (unsigned-byte 16) (ash b1 8))
                         b0)))))
          ((= (the fixnum (+ idx 2)) limit)
           (let* ((b0 (aref vector idx))
                  (b1 (aref vector (the fixnum (1+ idx))))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0 b1))
             (if (null n)
               :eof
               (if (eql n 1)
                 (progn
                   (setf (io-buffer-idx buf) 1)
                   :eof)
                 (let* ((b2 (aref vector 0))
                        (b3 (aref vector 1)))
                   (declare (type (unsigned-byte 8) b2 b3))
                   (setf (io-buffer-idx buf) 2)
                   #+little-endian-target
                   (logior (the (unsigned-byte 32) (ash b0 24))
                           (the (unsigned-byte 24) (ash b1 16))
                           (the (unsigned-byte 16) (ash b2 8))
                           b3)
                   #+big-endian-target
                   (logior (the (unsigned-byte 32) (ash b3 24))
                           (the (unsigned-byte 24) (ash b2 16))
                           (the (unsigned-byte 16) (ash b1 8))
                           b0))))))
          ((= (the fixnum (1+ idx)) limit)
           (let* ((b0 (aref vector idx))
                  (n (%ioblock-advance ioblock t)))
             (declare (type (unsigned-byte 8) b0))
             (if (null n)
               :eof
               (if (< n 3)
                 (progn
                   (setf (io-buffer-idx buf) n)
                   :eof)
                 (let* ((b1 (aref vector 0))
                        (b2 (aref vector 1))
                        (b3 (aref vector 2)))
                   (setf (io-buffer-idx buf) 3)
                   #+little-endian-target
                   (logior (the (unsigned-byte 32) (ash b0 24))
                           (the (unsigned-byte 24) (ash b1 16))
                           (the (unsigned-byte 16) (ash b2 8))
                           b3)
                   #+big-endian-target
                   (logior (the (unsigned-byte 32) (ash b3 24))
                           (the (unsigned-byte 24) (ash b2 16))
                           (the (unsigned-byte 16) (ash b1 8))
                           b0))))))
          (t
           (let* ((n (%ioblock-advance ioblock t)))
             (if (null n)
               :eof
               (if (< n 4)
                 (progn
                   (setf (io-buffer-idx buf) n)
                   :eof)
                 (let* ((b0 (aref vector 0))
                        (b1 (aref vector 1))
                        (b2 (aref vector 2))
                        (b3 (aref vector 3)))
                (declare (type (unsigned-byte 8) b0 b1 b2 b3))
                (setf (io-buffer-idx buf) 4)
                #+little-endian-target
                (logior (the (unsigned-byte 32) (ash b0 24))
                        (the (unsigned-byte 24) (ash b1 16))
                        (the (unsigned-byte 16) (ash b2 8))
                        b3)
                #+big-endian-target
                (logior (the (unsigned-byte 32) (ash b3 24))
                        (the (unsigned-byte 24) (ash b2 16))
                        (the (unsigned-byte 16) (ash b1 8))
                        b0)))))))))


(defun %bivalent-private-ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (setf (ioblock-untyi-char ioblock) nil)
    (let* ((buf (ioblock-inbuf ioblock))
	   (idx (io-buffer-idx buf))
	   (limit (io-buffer-count buf)))
      (declare (fixnum idx limit))
      (when (= idx limit)
	(unless (%ioblock-advance ioblock t)
	  (return-from %bivalent-private-ioblock-read-u8-byte :eof))
	(setq idx (io-buffer-idx buf)
	      limit (io-buffer-count buf)))
      (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
      (aref (the (simple-array (unsigned-byte 8) (*))
              (io-buffer-buffer buf)) idx)))

(defun %private-ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u8-byte ioblock))

(defun %bivalent-locked-ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (setf (ioblock-untyi-char ioblock) nil)
    (let* ((buf (ioblock-inbuf ioblock))
           (idx (io-buffer-idx buf))
           (limit (io-buffer-count buf)))
      (declare (fixnum idx limit))
      (when (= idx limit)
        (unless (%ioblock-advance ioblock t)
          (return-from %bivalent-locked-ioblock-read-u8-byte :eof))
        (setq idx (io-buffer-idx buf)
              limit (io-buffer-count buf)))
      (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
      (aref (the (simple-array (unsigned-byte 8) (*))
              (io-buffer-buffer buf)) idx))))

(defun %locked-ioblock-read-u8-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u8-byte ioblock)))

(defun %general-ioblock-read-byte (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-locked (ioblock)
    (let* ((buf (ioblock-inbuf ioblock))
           (idx (io-buffer-idx buf))
           (limit (io-buffer-count buf)))
      (declare (fixnum idx limit))
      (when (= idx limit)
        (unless (%ioblock-advance ioblock t)
          (return-from %general-ioblock-read-byte :eof))
        (setq idx (io-buffer-idx buf)
              limit (io-buffer-count buf)))
      (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
      (uvref (io-buffer-buffer buf) idx))))


(declaim (inline %ioblock-tyi))
(defun %ioblock-tyi (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((buf (ioblock-inbuf ioblock))
             (idx (io-buffer-idx buf))
             (limit (io-buffer-count buf)))
        (declare (fixnum idx limit))
        (when (= idx limit)
          (unless (%ioblock-advance ioblock t)
            (return-from %ioblock-tyi :eof))
          (setq idx 0))
        (setf (io-buffer-idx buf) (the fixnum (1+ idx)))
        (%code-char (aref (the (simple-array (unsigned-byte 8) (*))
                                       (io-buffer-buffer buf)) idx))))))

(defun %private-ioblock-tyi (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-tyi ioblock))

(defun %locked-ioblock-tyi (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-tyi ioblock)))

;;; Read a character composed of one or more 8-bit code-units.
(declaim (inline %ioblock-read-u8-encoded-char))
(defun %ioblock-read-u8-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((1st-unit (%ioblock-read-u8-code-unit ioblock)))
        (if (eq 1st-unit :eof)
          1st-unit
          (locally
              (declare (type (unsigned-byte 8) 1st-unit))
            (if (< 1st-unit
                   (the (mod #x110000) (ioblock-decode-literal-code-unit-limit ioblock)))
              (%code-char 1st-unit)
              (funcall (ioblock-decode-input-function ioblock)
                       1st-unit
                       #'%ioblock-read-u8-code-unit
                       ioblock))))))))

(defun %private-ioblock-read-u8-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u8-encoded-char ioblock))

(defun %locked-ioblock-read-u8-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u8-encoded-char ioblock)))

(declaim (inline %ioblock-read-u16-encoded-char))
(defun %ioblock-read-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((1st-unit (%ioblock-read-u16-code-unit ioblock)))
        (if (eq 1st-unit :eof)
          1st-unit
          (locally
              (declare (type (unsigned-byte 16) 1st-unit))
            (if (< 1st-unit
                   (the (mod #x110000) (ioblock-decode-literal-code-unit-limit ioblock)))
              (code-char 1st-unit)
              (funcall (ioblock-decode-input-function ioblock)
                       1st-unit
                       #'%ioblock-read-u16-code-unit
                       ioblock))))))))

(defun %private-ioblock-read-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u16-encoded-char ioblock))

(defun %locked-ioblock-read-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u16-encoded-char ioblock)))

(declaim (inline %ioblock-read-swapped-u16-encoded-char))
(defun %ioblock-read-swapped-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((1st-unit (%ioblock-read-swapped-u16-code-unit ioblock)))
        (if (eq 1st-unit :eof)
          1st-unit
          (locally
              (declare (type (unsigned-byte 16) 1st-unit))
            (if (< 1st-unit
                   (the (mod #x110000) (ioblock-decode-literal-code-unit-limit ioblock)))
              (code-char 1st-unit)
              (funcall (ioblock-decode-input-function ioblock)
                       1st-unit
                       #'%ioblock-read-swapped-u16-code-unit
                       ioblock))))))))

(defun %private-ioblock-read-swapped-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-swapped-u16-encoded-char ioblock))

(defun %locked-ioblock-read-swapped-u16-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-swapped-u16-encoded-char ioblock)))

(declaim (inline %ioblock-read-u32-encoded-char))
(defun %ioblock-read-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((1st-unit (%ioblock-read-u32-code-unit ioblock)))
        (if (eq 1st-unit :eof)
          1st-unit
          (locally
              (declare (type (unsigned-byte 16) 1st-unit))
            (if (< 1st-unit
                   (the (mod #x110000) (ioblock-decode-literal-code-unit-limit ioblock)))
              (code-char 1st-unit)
              (funcall (ioblock-decode-input-function ioblock)
                       1st-unit
                       #'%ioblock-read-u32-code-unit
                       ioblock))))))))

(defun %private-ioblock-read-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-u32-encoded-char ioblock))

(defun %locked-ioblock-read-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-u32-encoded-char ioblock)))

(declaim (inline %ioblock-read-swapped-u32-encoded-char))
(defun %ioblock-read-swapped-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((ch (ioblock-untyi-char ioblock)))
    (if ch
      (prog1 ch
        (setf (ioblock-untyi-char ioblock) nil))
      (let* ((1st-unit (%ioblock-read-swapped-u32-code-unit ioblock)))
        (if (eq 1st-unit :eof)
          1st-unit
          (locally
              (declare (type (unsigned-byte 16) 1st-unit))
            (if (< 1st-unit
                   (the (mod #x110000) (ioblock-decode-literal-code-unit-limit ioblock)))
              (code-char 1st-unit)
              (funcall (ioblock-decode-input-function ioblock)
                       1st-unit
                       #'%ioblock-read-swapped-u32-code-unit
                       ioblock))))))))

(defun %private-ioblock-read-swapped-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-read-swapped-u32-encoded-char ioblock))

(defun %locked-ioblock-read-swapped-u32-encoded-char (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-swapped-u32-encoded-char ioblock)))

(declaim (inline %ioblock-tyi-no-hang))
(defun %ioblock-tyi-no-hang (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (if (ioblock-untyi-char ioblock)
    (prog1 (ioblock-untyi-char ioblock)
      (setf (ioblock-untyi-char ioblock) nil))
    (let* ((buf (ioblock-inbuf ioblock))
	   (idx (io-buffer-idx buf))
	   (limit (io-buffer-count buf)))
      (declare (fixnum idx limit))
      (when (= idx limit)
	(unless (%ioblock-advance ioblock nil)
	  (return-from %ioblock-tyi-no-hang (if (ioblock-eof ioblock) :eof))))
      (funcall (ioblock-read-char-when-locked-function ioblock) ioblock))))

;;; :iso-8859-1 only.
(defun %ioblock-peek-char (ioblock)
  (or (ioblock-untyi-char ioblock)
      (let* ((b (%ioblock-read-u8-byte ioblock)))
        (if (eq b :eof)
          b
          (let* ((ch (%code-char b))
                 (buf (ioblock-inbuf ioblock))
                 (idx (io-buffer-idx buf)))
            (declare (fixnum idx))
            (setf (io-buffer-idx buf) (the fixnum (1- idx)))
            ch)))))

(defun %encoded-ioblock-peek-char (ioblock)
  (or (ioblock-untyi-char ioblock)
      (let* ((ch (funcall (ioblock-read-char-when-locked-function ioblock) ioblock)))
        (unless (eq ch :eof)
          (funcall (ioblock-unread-char-function ioblock) ioblock ch))
        ch)))




(defun %ioblock-clear-input (ioblock)    
    (let* ((buf (ioblock-inbuf ioblock)))
      (setf (io-buffer-count buf) 0
	    (io-buffer-idx buf) 0
	    (ioblock-untyi-char ioblock) nil)))

(defun %ioblock-untyi (ioblock char)
  (if (ioblock-untyi-char ioblock)
    (error "Two UNREAD-CHARs without intervening READ-CHAR on ~s"
	   (ioblock-stream ioblock))
    (setf (ioblock-untyi-char ioblock) char)))

(declaim (inline ioblock-inpos))

(defun ioblock-inpos (ioblock)
  (io-buffer-idx (ioblock-inbuf ioblock)))

(declaim (inline ioblock-outpos))

(defun ioblock-outpos (ioblock)
  (io-buffer-count (ioblock-outbuf ioblock)))



(declaim (inline %ioblock-force-output))

(defun %ioblock-force-output (ioblock finish-p)
  (funcall (ioblock-force-output-function ioblock)
           (ioblock-stream ioblock)
           ioblock
           (ioblock-outpos ioblock)
           finish-p))

;;; ivector should be an ivector.  The ioblock should have an
;;; element-shift of 0; start-octet and num-octets should of course
;;; be sane.  This is mostly to give the fasdumper a quick way to
;;; write immediate data.
(defun %ioblock-out-ivect (ioblock ivector start-octet num-octets)
  (unless (= 0 (the fixnum (ioblock-element-shift ioblock)))
    (error "Can't write vector to stream ~s" (ioblock-stream ioblock)))
  (let* ((written 0)
	 (out (ioblock-outbuf ioblock)))
    (declare (fixnum written))
    (do* ((pos start-octet (+ pos written))
	  (left num-octets (- left written)))
	 ((= left 0) num-octets)
      (declare (fixnum pos left))
      (setf (ioblock-dirty ioblock) t)
      (let* ((index (io-buffer-idx out))
	     (count (io-buffer-count out))
	     (bufsize (io-buffer-size out))
             (avail (- bufsize index))
             (buffer (io-buffer-buffer out)))
	(declare (fixnum index avail count bufsize))
	(cond
	  ((= (setq written avail) 0)
	   (%ioblock-force-output ioblock nil))
	  (t
	   (if (> written left)
	     (setq written left))
	   (%copy-ivector-to-ivector ivector pos buffer index written)
	   (setf (ioblock-dirty ioblock) t)
	   (incf index written)
	   (if (> index count)
	     (setf (io-buffer-count out) index))
	   (setf (io-buffer-idx out) index)
	   (if (= index  bufsize)
	     (%ioblock-force-output ioblock nil))))))))


(defun %ioblock-unencoded-write-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars) (simple-string string))
  (let* ((written 0)
	 (col (ioblock-charpos ioblock))
	 (out (ioblock-outbuf ioblock)))
    (declare (fixnum written col)
	     (optimize (speed 3) (safety 0)))
    (do* ((pos start-char (+ pos written))
	  (left num-chars (- left written)))
	 ((= left 0) (setf (ioblock-charpos ioblock) col)  num-chars)
      (declare (fixnum pos left))
      (setf (ioblock-dirty ioblock) t)
      (let* ((index (io-buffer-idx out))
	     (count (io-buffer-count out))
             (bufsize (io-buffer-size out))
             (buffer (io-buffer-buffer out))
	     (avail (- bufsize index)))
	(declare (fixnum index bufsize avail count)
                 (type (simple-array (unsigned-byte 8) (*)) buffer))
	(cond
	  ((= (setq written avail) 0)
	   (%ioblock-force-output ioblock nil))
	  (t
	   (if (> written left)
	     (setq written left))
	   (do* ((p pos (1+ p))
		 (i index (1+ i))
		 (j 0 (1+ j)))
		((= j written))
	     (declare (fixnum p i j))
	     (let* ((ch (schar string p))
                    (code (char-code ch)))
               (declare (type (mod #x110000) code))
	       (if (eql ch #\newline)
		 (setq col 0)
		 (incf col))
	       (setf (aref buffer i) (if (>= code 256) (char-code #\Sub) code))))
	   (setf (ioblock-dirty ioblock) t)
	   (incf index written)
	   (if (> index count)
	     (setf (io-buffer-count out) index))
	   (setf (io-buffer-idx out) index)
	   (if (= index  bufsize)
	     (%ioblock-force-output ioblock nil))))))))



(defun %ioblock-eofp (ioblock)
  (let* ((buf (ioblock-inbuf ioblock)))
   (and (eql (io-buffer-idx buf)
             (io-buffer-count buf))
         (locally (declare (optimize (speed 3) (safety 0)))
           (with-ioblock-input-locked (ioblock)
             (funcall (ioblock-eofp-function ioblock)
		      (ioblock-stream ioblock)
		      ioblock))))))

(defun %ioblock-listen (ioblock)
  (let* ((buf (ioblock-inbuf ioblock)))
    (or (< (the fixnum (io-buffer-idx buf))
           (the fixnum (io-buffer-count buf)))
	(funcall (ioblock-listen-function ioblock)
		 (ioblock-stream ioblock)
		 ioblock))))



(declaim (inline %ioblock-write-u8-element))
(defun %ioblock-write-u8-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (unsigned-byte 8) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-s8-element))
(defun %ioblock-write-s8-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (signed-byte 8) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-u16-element))
(defun %ioblock-write-u16-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (unsigned-byte 16) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-u16-code-unit))
(defun %ioblock-write-u16-code-unit (ioblock element)
  (declare (optimize (speed 3) (safety 0))
           (type (unsigned-byte 16) element))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf))
         (vector (io-buffer-buffer buf))
         (b0 #+big-endian-target (ldb (byte 8 8) element)
             #+little-endian-target (ldb (byte 8 0) element))
         (b1 #+big-endian-target (ldb (byte 8 0) element)
             #+little-endian-target (ldb (byte 8 8) element)))
    (declare (fixnum idx limit count)
             (type (simple-array (unsigned-byte 8) (*)) vector)
             (type (unsigned-byte 8) b0 b1))
   
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref vector idx) b0)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref vector idx) b1)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-swapped-u16-code-unit))
(defun %ioblock-write-swapped-u16-code-unit (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
(let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf))
         (vector (io-buffer-buffer buf))
         (b0 #+big-endian-target (ldb (byte 8 8) element)
             #+little-endian-target (ldb (byte 8 0) element))
         (b1 #+big-endian-target (ldb (byte 8 0) element)
             #+little-endian-target (ldb (byte 8 8) element)))
    (declare (fixnum idx limit count)
             (type (simple-array (unsigned-byte 8) (*)) vector)
             (type (unsigned-byte 8) b0 b1))
   
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b1)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b0)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-u32-code-unit))
(defun %ioblock-write-u32-code-unit (ioblock element)
  (declare (optimize (speed 3) (safety 0))
           (type (unsigned-byte 16) element))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf))
         (vector (io-buffer-buffer buf))
         (b0 #+big-endian-target (ldb (byte 8 24) element)
             #+little-endian-target (ldb (byte 8 0) element))
         (b1 #+big-endian-target (ldb (byte 8 16) element)
             #+little-endian-target (ldb (byte 8 8) element))
         (b2 #+big-endian-target (ldb (byte 8 8) element)
             #+little-endian-target (ldb (byte 8 16) element))
         (b3 #+big-endian-target (ldb (byte 8 0) element)
             #+little-endian-target (ldb (byte 8 24) element)))
    (declare (fixnum idx limit count)
             (type (simple-array (unsigned-byte 8) (*)) vector)
             (type (unsigned-byte 8) b0 b1 b2 b3))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b0)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b1)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b2)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b3)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-swapped-u32-code-unit))
(defun %ioblock-write-swapped-u32-code-unit (ioblock element)
  (declare (optimize (speed 3) (safety 0))
           (type (unsigned-byte 16) element))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf))
         (vector (io-buffer-buffer buf))
         (b0 #+little-endian-target (ldb (byte 8 24) element)
             #+big-endian-target (ldb (byte 8 0) element))
         (b1 #+little-endian-target (ldb (byte 8 16) element)
             #+big-endian-target (ldb (byte 8 8) element))
         (b2 #+little-endian-target (ldb (byte 8 8) element)
             #+big-endian-target (ldb (byte 8 16) element))
         (b3 #+little-endian-target (ldb (byte 8 0) element)
             #+big-endian-target (ldb (byte 8 24) element)))
    (declare (fixnum idx limit count)
             (type (simple-array (unsigned-byte 8) (*)) vector)
             (type (unsigned-byte 8) b0 b1 b2 b3))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b0)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref vector idx) b1)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b2)
    (incf idx)
    (when (= idx limit)
      (when (> idx count)
        (setf (io-buffer-count buf) idx))
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)
            vector (io-buffer-buffer buf)
            limit (io-buffer-limit buf)))
    (setf (aref vector idx) b3)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-s16-element))
(defun %ioblock-write-s16-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)))
    (setf (aref (the (simple-array (signed-byte 16) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-u32-element))
(defun %ioblock-write-u32-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)))
    (setf (aref (the (simple-array (unsigned-byte 32) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-swapped-u32-element))
(defun %ioblock-write-swapped-u32-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf)
            count (io-buffer-count buf)))
    (setf (aref (the (simple-array (unsigned-byte 32) (*)) (io-buffer-buffer buf)) idx)
          (%swap-u32 element))
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-s32-element))
(defun %ioblock-write-s32-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (signed-byte 32) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

#+64-bit-target
(progn
(declaim (inline %ioblock-write-u64-element))
(defun %ioblock-write-u64-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (unsigned-byte 64) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))

(declaim (inline %ioblock-write-s64-element))
(defun %ioblock-write-s64-element (ioblock element)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((buf (ioblock-outbuf ioblock))
         (idx (io-buffer-idx buf))
	 (count (io-buffer-count buf))
         (limit (io-buffer-limit buf)))
    (declare (fixnum idx limit count))
    (when (= idx limit)
      (%ioblock-force-output ioblock nil)
      (setq idx (io-buffer-idx buf) count (io-buffer-count buf)))
    (setf (aref (the (simple-array (signed-byte 64) (*)) (io-buffer-buffer buf)) idx) element)
    (incf idx)
    (setf (io-buffer-idx buf) idx)
    (when (> idx count)
      (setf (io-buffer-count buf) idx))
    (setf (ioblock-dirty ioblock) t)
    element))
)

(declaim (inline %ioblock-write-char))
(defun %ioblock-write-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code 256)
      (%ioblock-write-u8-element ioblock code)
      (%ioblock-write-u8-element ioblock (char-code #\Sub)))))

(defun %private-ioblock-write-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-char ioblock char))

(defun %locked-ioblock-write-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-char ioblock char)))

(declaim (inline %ioblock-write-u8-encoded-char))
(defun %ioblock-write-u8-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code (the fixnum (ioblock-encode-literal-char-code-limit ioblock)))
      (%ioblock-write-u8-element ioblock code)
      (funcall (ioblock-encode-output-function ioblock)
               char
               #'%ioblock-write-u8-element
               ioblock))))

(defun %private-ioblock-write-u8-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u8-encoded-char ioblock char))

(defun %locked-ioblock-write-u8-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock) 
    (%ioblock-write-u8-encoded-char ioblock char)))


(defun %ioblock-write-u8-encoded-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars)
           (simple-base-string string)
           (optimize (speed 3) (safety 0)))
  (do* ((i 0 (1+ i))
        (col (ioblock-charpos ioblock))
        (limit (ioblock-encode-literal-char-code-limit ioblock))
        (encode-function (ioblock-encode-output-function ioblock))
        (start-char start-char (1+ start-char)))
       ((= i num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
    (declare (fixnum i start-char limit))
    (let* ((char (schar string start-char))
           (code (char-code char)))
      (declare (type (mod #x110000) code))
      (if (eq char #\newline)
        (setq col 0)
        (incf col))
      (if (< code limit)
        (%ioblock-write-u8-element ioblock code)
        (funcall encode-function char #'%ioblock-write-u8-element ioblock)))))


(declaim (inline %ioblock-write-u16-encoded-char))
(defun %ioblock-write-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (when (ioblock-pending-byte-order-mark ioblock)
    (setf (ioblock-pending-byte-order-mark ioblock) nil)
    (%ioblock-write-u16-code-unit ioblock byte-order-mark-char-code))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code (the fixnum (ioblock-encode-literal-char-code-limit ioblock)))
      (%ioblock-write-u16-code-unit ioblock code)
      (funcall (ioblock-encode-output-function ioblock)
               char
               #'%ioblock-write-u16-code-unit
               ioblock))))

(defun %private-ioblock-write-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u16-encoded-char ioblock char))

(defun %locked-ioblock-write-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u16-encoded-char ioblock char)))


(defun %ioblock-write-u16-encoded-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars)
           (simple-base-string string)
           (optimize (speed 3) (safety 0)))
  (when (ioblock-pending-byte-order-mark ioblock)
    (setf (ioblock-pending-byte-order-mark ioblock) nil)
    (%ioblock-write-u16-code-unit ioblock byte-order-mark-char-code))
  (do* ((i 0 (1+ i))
        (col (ioblock-charpos ioblock))
        (limit (ioblock-encode-literal-char-code-limit ioblock))
        (encode-function (ioblock-encode-output-function ioblock))
        (start-char start-char (1+ start-char)))
       ((= i num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
    (declare (fixnum i start-char limit))
    (let* ((char (schar string start-char))
           (code (char-code char)))
      (declare (type (mod #x110000) code))
      (if (eq char #\newline)
        (setq col 0)
        (incf col))
      (if (< code limit)
        (%ioblock-write-u16-code-unit ioblock code)
        (funcall encode-function char #'%ioblock-write-u16-code-unit ioblock)))))

(declaim (inline %ioblock-write-swapped-u16-encoded-char))
(defun %ioblock-write-swapped-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code (the fixnum (ioblock-encode-literal-char-code-limit ioblock)))
      (%ioblock-write-swapped-u16-code-unit ioblock code)
      (funcall (ioblock-encode-output-function ioblock)
               char
               #'%ioblock-write-swapped-u16-code-unit
               ioblock))))

(defun %private-ioblock-write-swapped-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-swapped-u16-encoded-char ioblock char))

(defun %locked-ioblock-write-swapped-u16-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-swapped-u16-encoded-char ioblock char)))

(defun %ioblock-write-swapped-u16-encoded-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars)
           (simple-base-string string)
           (optimize (speed 3) (safety 0)))
  (do* ((i 0 (1+ i))
        (col (ioblock-charpos ioblock))
        (limit (ioblock-encode-literal-char-code-limit ioblock))
        (encode-function (ioblock-encode-output-function ioblock))
        (wcf (ioblock-write-char-when-locked-function ioblock))
        (start-char start-char (1+ start-char)))
       ((= i num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
    (declare (fixnum i start-char limit))
    (let* ((char (schar string start-char))
           (code (char-code char)))
      (declare (type (mod #x110000) code))
      (cond ((eq char #\newline)
             (setq col 0)
             (funcall wcf ioblock char))
            (t
             (incf col)
             (if (< code limit)
               (%ioblock-write-swapped-u16-code-unit ioblock code)
               (funcall encode-function char #'%ioblock-write-swapped-u16-code-unit ioblock)))))))


(declaim (inline %ioblock-write-u32-encoded-char))
(defun %ioblock-write-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (when (ioblock-pending-byte-order-mark ioblock)
    (setf (ioblock-pending-byte-order-mark ioblock) nil)
    (%ioblock-write-u32-code-unit ioblock byte-order-mark))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code (the fixnum (ioblock-encode-literal-char-code-limit ioblock)))
      (%ioblock-write-u32-code-unit ioblock code)
      (funcall (ioblock-encode-output-function ioblock)
               code
               #'%ioblock-write-u32-code-unit
               ioblock))))

(defun %private-ioblock-write-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u32-encoded-char ioblock char))

(defun %locked-ioblock-write-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))  
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u32-encoded-char ioblock char)))

(defun %ioblock-write-u32-encoded-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars)
           (simple-base-string string)
           (optimize (speed 3) (safety 0)))
  (when (ioblock-pending-byte-order-mark ioblock)
    (setf (ioblock-pending-byte-order-mark ioblock) nil)
    (%ioblock-write-u32-code-unit ioblock byte-order-mark-char-code))
  (do* ((i 0 (1+ i))
        (col (ioblock-charpos ioblock))
        (limit (ioblock-encode-literal-char-code-limit ioblock))
        (encode-function (ioblock-encode-output-function ioblock))
        (start-char start-char (1+ start-char)))
       ((= i num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
    (declare (fixnum i start-char limit))
    (let* ((char (schar string start-char))
           (code (char-code char)))
      (declare (type (mod #x110000) code))
      (if (eq char #\newline)
        (setq col 0)
        (incf col))
      (if (< code limit)
        (%ioblock-write-u32-code-unit ioblock code)
        (funcall encode-function char #'%ioblock-write-u32-code-unit ioblock)))))


(declaim (inline %ioblock-write-swapped-u32-encoded-char))
(defun %ioblock-write-swapped-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (if (eq char #\linefeed)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (< code (the fixnum (ioblock-encode-literal-char-code-limit ioblock)))
      (%ioblock-write-swapped-u32-code-unit ioblock code)
      (funcall (ioblock-encode-output-function ioblock)
               code
               #'%ioblock-write-swapped-u32-code-unit
               ioblock))))

(defun %private-ioblock-write-swapped-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-swapped-u32-encoded-char ioblock char))

(defun %locked-ioblock-write-swapped-u32-encoded-char (ioblock char)
  (declare (optimize (speed 3) (safety 0)))  
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-swapped-u32-encoded-char ioblock char)))

(defun %ioblock-write-swapped-u32-encoded-simple-string (ioblock string start-char num-chars)
  (declare (fixnum start-char num-chars)
           (simple-base-string string)
           (optimize (speed 3) (safety 0)))
  (do* ((i 0 (1+ i))
        (col (ioblock-charpos ioblock))
        (limit (ioblock-encode-literal-char-code-limit ioblock))
        (encode-function (ioblock-encode-output-function ioblock))
        (start-char start-char (1+ start-char)))
       ((= i num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
    (declare (fixnum i start-char limit))
    (let* ((char (schar string start-char))
           (code (char-code char)))
      (declare (type (mod #x110000) code))
      (if (eq char #\newline)
        (setq col 0)
        (incf col))
      (if (< code limit)
        (%ioblock-write-swapped-u32-code-unit ioblock code)
        (funcall encode-function char #'%ioblock-write-swapped-u32-code-unit ioblock)))))

(declaim (inline %ioblock-write-u8-byte))
(defun %ioblock-write-u8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-u8-element ioblock (require-type byte '(unsigned-byte 8))))

(defun %private-ioblock-write-u8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u8-byte ioblock byte))

(defun %locked-ioblock-write-u8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u8-byte ioblock byte)))

(declaim (inline %ioblock-write-s8-byte))
(defun %ioblock-write-s8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-s8-element ioblock (require-type byte '(signed-byte 8))))

(defun %private-ioblock-write-s8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-s8-byte ioblock byte))

(defun %locked-ioblock-write-s8-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-s8-byte ioblock byte)))

(declaim (inline %ioblock-write-u16-byte))
(defun %ioblock-write-u16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-u16-element ioblock (require-type byte '(unsigned-byte 16))))

(defun %private-ioblock-write-u16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u16-byte ioblock byte))

(defun %locked-ioblock-write-u16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u16-byte ioblock byte)))

(declaim (inline %ioblock-write-s16-byte))
(defun %ioblock-write-s16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-s16-element ioblock (require-type byte '(signed-byte 16))))

(defun %private-ioblock-write-s16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-s16-byte ioblock byte))

(defun %locked-ioblock-write-s16-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-s16-byte ioblock byte)))

(declaim (inline %ioblock-write-u32-byte))
(defun %ioblock-write-u32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-u32-element ioblock (require-type byte '(unsigned-byte 32))))

(defun %private-ioblock-write-u32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u32-byte ioblock byte))

(defun %locked-ioblock-write-u32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u32-byte ioblock byte)))

(declaim (inline %ioblock-write-s32-byte))
(defun %ioblock-write-s32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-s32-element ioblock (require-type byte '(signed-byte 32))))

(defun %private-ioblock-write-s32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-s32-byte ioblock byte))

(defun %locked-ioblock-write-s32-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-s32-byte ioblock byte)))

#+64-bit-target
(progn
(declaim (inline %ioblock-write-u64-byte))
(defun %ioblock-write-u64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-u64-element ioblock (require-type byte '(unsigned-byte 64))))

(defun %private-ioblock-write-u64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-u64-byte ioblock byte))

(defun %locked-ioblock-write-u64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-u64-byte ioblock byte)))

(declaim (inline %ioblock-write-s64-byte))
(defun %ioblock-write-s64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (%ioblock-write-s64-element ioblock (require-type byte '(signed-byte 64))))

(defun %private-ioblock-write-s64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (check-ioblock-owner ioblock)
  (%ioblock-write-s64-byte ioblock byte))

(defun %locked-ioblock-write-s64-byte (ioblock byte)
  (declare (optimize (speed 3) (safety 0)))
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-s64-byte ioblock byte)))
)                                       ;#+64-bit-target

(defun %ioblock-clear-output (ioblock)
  (let* ((buf (ioblock-outbuf ioblock)))                      
    (setf (io-buffer-count buf) 0
            (io-buffer-idx buf) 0)))


(defun %ioblock-unencoded-read-line (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (collect ((octet-vectors))
    (let* ((inbuf (ioblock-inbuf ioblock))
           (len 0)
           (buf (io-buffer-buffer inbuf)))
      (declare (fixnum len) (type (simple-array (unsigned-byte 8)(*)) buf))
      (let* ((ch (ioblock-untyi-char ioblock)))
        (when ch
          (setf (ioblock-untyi-char ioblock) nil)
          (if (eql ch #\newline)
            (return-from %ioblock-unencoded-read-line 
              (values "" nil))
            (progn
              (octet-vectors (make-array 1 :element-type '(unsigned-byte 8)
                                         :initial-element (char-code ch)))
              (setq len 1)))))
      (do* ((done nil)
            (idx (io-buffer-idx inbuf))
            (count (io-buffer-count inbuf)))
           (done (let* ((string (make-string len))
                        (outpos 0))
                   (declare (simple-string string) (fixnum outpos))
                   (dolist (v (octet-vectors) (values string (eq done :eof)))
                     (let* ((vlen (length v)))
                       (declare (fixnum vlen))
                       (%copy-u8-to-string v 0 string outpos vlen)
                       (incf outpos vlen)))))
        (declare (fixnum idx count))
        (when (= idx count)
          (%ioblock-advance ioblock t)
          (setq idx (io-buffer-idx inbuf)
                count (io-buffer-count inbuf)
                done (if (= idx count) :eof)))
        (unless done
          (let* ((p (do* ((i idx (1+ i)))
                         ((= i count)
                          (setf (io-buffer-idx inbuf) count)
                          nil)
                      (declare (fixnum i))
                      (when (eql (aref buf i) (char-code #\newline))
                        (setf (io-buffer-idx inbuf) (the fixnum (1+ i)))
                        (setq done t)
                        (return i))))
                 (end (or p count))
                 (n (- end idx)))
            (declare (fixnum p end n))
            (if (and p (eql len 0))
              ;; Likely a fairly common case
              (let* ((string (make-string n)))
                (%copy-u8-to-string buf idx string 0 n)
                (return-from %ioblock-unencoded-read-line
                  (values string nil)))
              (let* ((v (make-array n :element-type '(unsigned-byte 8))))
                (%copy-ivector-to-ivector buf idx v 0 n)
                (incf len n)
                (octet-vectors v)
                (setq idx count)))))))))


;;; There are lots of ways of doing better here, but in the most general
;;; case we can't tell (a) what a newline looks like in the buffer or (b)
;;; whether there's a 1:1 mapping between code units and characters.
(defun %ioblock-encoded-read-line (ioblock)
  (declare (optimize (speed 3) (safety 0)))
  (collect ((chunks))
    (let* ((pos 0)
           (len 0)
           (chunksize 8192)
           (str (make-string chunksize))
           (rcf (ioblock-read-char-when-locked-function ioblock))
           (eof nil))
      (declare (fixnum pos len chunksize)
               (simple-string str)
               (dynamic-extent str))
      (do* ((ch (funcall rcf ioblock) (funcall rcf ioblock)))
           ((or (eq ch #\newline) (setq eof (eq ch :eof)))
            (if (zerop len)
              (values (subseq str 0 pos) eof)
              (let* ((outpos 0))
                (declare (fixnum outpos))
                (setq len (+ len pos))
                (let* ((out (make-string len)))
                  (dolist (s (chunks))
                    (%copy-ivector-to-ivector s 0 out outpos (the fixnum (ash chunksize 2)))
                    (incf outpos (ash chunksize 2)))
                  (%copy-ivector-to-ivector str 0 out outpos (the fixnum (ash pos 2)))
                  (values out eof)))))
        (when (= pos chunksize)
          (chunks str)
          (setq str (make-string chunksize)
                len (+ len pos)
                pos 0))
        (setf (schar str pos) ch
              pos (1+ pos))))))
	 
(defun %ioblock-unencoded-character-read-vector (ioblock vector start end)
  (do* ((i start)
        (in (ioblock-inbuf ioblock))
        (inbuf (io-buffer-buffer in))
        (need (- end start)))
       ((= i end) end)
    (declare (fixnum i need))
    (let* ((ch (%ioblock-tyi ioblock)))
      (if (eq ch :eof)
        (return i))
      (setf (schar vector i) ch)
      (incf i)
      (decf need)
      (let* ((idx (io-buffer-idx in))
             (count (io-buffer-count in))
             (avail (- count idx)))
        (declare (fixnum idx count avail))
        (unless (zerop avail)
          (if (> avail need)
            (setq avail need))
          (%copy-u8-to-string inbuf idx vector i avail)
          (setf (io-buffer-idx in) (+ idx avail))
          (incf i avail)
          (decf need avail))))))

;;; Also used when newline translation complicates things.
(defun %ioblock-encoded-character-read-vector (ioblock vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i))
        (rcf (ioblock-read-char-when-locked-function ioblock)))
       ((= i end) end)
    (declare (fixnum i))
    (let* ((ch (funcall rcf ioblock)))
      (if (eq ch :eof)
	(return i))
      (setf (schar vector i) ch))))


(defun %ioblock-binary-read-vector (ioblock vector start end)
  (declare (fixnum start end))
  (let* ((in (ioblock-inbuf ioblock))
	 (inbuf (io-buffer-buffer in))
         (rbf (ioblock-read-byte-when-locked-function ioblock)))
    (setf (ioblock-untyi-char ioblock) nil)
    (if (not (= (the fixnum (typecode inbuf))
		(the fixnum (typecode vector))))
      (do* ((i start (1+ i)))
	   ((= i end) i)
	(declare (fixnum i))
	(let* ((b (funcall rbf ioblock)))
	  (if (eq b :eof)
	    (return i)
	    (setf (uvref vector i) b))))
      (do* ((i start)
	    (need (- end start)))
	   ((= i end) end)
	(declare (fixnum i need))
	(let* ((b (funcall rbf ioblock)))
	  (if (eq b :eof)
	    (return i))
	  (setf (uvref vector i) b)
	  (incf i)
	  (decf need)
	  (let* ((idx (io-buffer-idx in))
		 (count (io-buffer-count in))
		 (avail (- count idx)))
	    (declare (fixnum idx count avail))
	    (unless (zerop avail)
	      (if (> avail need)
		(setq avail need))
	      (%copy-ivector-to-ivector
	       inbuf
	       (ioblock-elements-to-octets ioblock idx)
	       vector
	       (ioblock-elements-to-octets ioblock i)
	       (ioblock-elements-to-octets ioblock avail))
	      (setf (io-buffer-idx in) (+ idx avail))
	      (incf i avail)
	      (decf need avail))))))))

;;; About the same, only less fussy about ivector's element-type.
;;; (All fussiness is about the stream's element-type ...).
;;; Whatever the element-type is, elements must be 1 octet in size.
(defun %ioblock-character-in-ivect (ioblock vector start nb)
  (declare (type (simple-array (unsigned-byte 8) (*)) vector)
	   (fixnum start nb)
	   (optimize (speed 3) (safety 0)))
  (unless (= 0 (the fixnum (ioblock-element-shift ioblock)))
    (error "Can't read vector from stream ~s" (ioblock-stream ioblock)))
  (do* ((i start)
	(in (ioblock-inbuf ioblock))
	(inbuf (io-buffer-buffer in))
	(need nb)
	(end (+ start nb)))
       ((= i end) end)
    (declare (fixnum i end need))
    (let* ((ch (%ioblock-tyi ioblock)))
      (if (eq ch :eof)
	(return (- i start)))
      (setf (aref vector i) (char-code ch))
      (incf i)
      (decf need)
      (let* ((idx (io-buffer-idx in))
	     (count (io-buffer-count in))
	     (avail (- count idx)))
	(declare (fixnum idx count avail))
	(unless (zerop avail)
	  (if (> avail need)
	    (setq avail need))
          (%copy-u8-to-string inbuf idx vector i avail)
	  (setf (io-buffer-idx in) (+ idx avail))
	  (incf i avail)
	  (decf need avail))))))

(defun %ioblock-binary-in-ivect (ioblock vector start nb)
  (declare (type (simple-array (unsigned-byte 8) (*)) vector)
	   (fixnum start nb)
	   (optimize (speed 3) (safety 0)))
  (unless (= 0 (the fixnum (ioblock-element-shift ioblock)))
    (error "Can't read vector from stream ~s" (ioblock-stream ioblock)))
  (setf (ioblock-untyi-char ioblock) nil)
  (do* ((i start)
        (rbf (ioblock-read-byte-when-locked-function ioblock))
	(in (ioblock-inbuf ioblock))
	(inbuf (io-buffer-buffer in))
	(need nb)
	(end (+ start nb)))
       ((= i end) nb)
    (declare (fixnum i end need))
    (let* ((b (funcall rbf ioblock)))
      (if (eq b :eof)
	(return (- i start)))
      (setf (aref vector i) b)
      (incf i)
      (decf need)
      (let* ((idx (io-buffer-idx in))
	     (count (io-buffer-count in))
	     (avail (- count idx)))
	(declare (fixnum idx count avail))
	(unless (zerop avail)
	  (if (> avail need)
	    (setq avail need))
	  (%copy-ivector-to-ivector inbuf idx vector i avail)
	  (setf (io-buffer-idx in) (+ idx avail))
	  (incf i avail)
	  (decf need avail))))))

;;; Thread must own ioblock lock(s).
(defun %%ioblock-close (ioblock)
  (when (ioblock-device ioblock)
    (let* ((stream (ioblock-stream ioblock)))
      (funcall (ioblock-close-function ioblock) stream ioblock)
      (setf (ioblock-device ioblock) nil)
      (setf (stream-ioblock stream) nil)
      (let* ((in-iobuf (ioblock-inbuf ioblock))
             (out-iobuf (ioblock-outbuf ioblock))
             (in-buffer (if in-iobuf (io-buffer-buffer in-iobuf)))
             (in-bufptr (if in-iobuf (io-buffer-bufptr in-iobuf)))
             (out-buffer (if out-iobuf (io-buffer-buffer out-iobuf)))
             (out-bufptr (if out-iobuf (io-buffer-bufptr out-iobuf))))
        (if (and in-buffer in-bufptr)
          (%dispose-heap-ivector in-buffer))
        (unless (eq in-buffer out-buffer)
          (if (and out-buffer out-bufptr)
            (%dispose-heap-ivector out-buffer)))
        (when in-iobuf
          (setf (io-buffer-buffer in-iobuf) nil
                (io-buffer-bufptr in-iobuf) nil
                (ioblock-inbuf ioblock) nil))
        (when out-iobuf
          (setf (io-buffer-buffer out-iobuf) nil
                (io-buffer-bufptr out-iobuf) nil
                (ioblock-outbuf ioblock) nil))
        t))))

(defun %ioblock-close (ioblock)
  (let* ((in-lock (ioblock-inbuf-lock ioblock))
         (out-lock (ioblock-outbuf-lock ioblock)))
    (if in-lock
      (with-lock-grabbed (in-lock)
        (if (and out-lock (not (eq out-lock in-lock)))
          (with-lock-grabbed (out-lock)
            (%%ioblock-close ioblock))
          (%%ioblock-close ioblock)))
      (if out-lock
        (with-lock-grabbed (out-lock)
          (%%ioblock-close ioblock))
        (progn
          (check-ioblock-owner ioblock)
          (%%ioblock-close ioblock))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Character-at-a-time line-termination-translation functions.
;;; It's not always possible to just blast through the buffer, blindly
;;; replacing #xd with #xa (for example), and it's not always desirable
;;; to do that (if we support changing encoding on open streams.)
;;; This is done at a fairly high level; some cases could be done at
;;; a lower level, and some cases are hard even at that lower level.
;;; This approach doesn't slow down the simple case (when no line-termination
;;; translation is used), and hopefully isn't -that- bad.

(declaim (inline %ioblock-read-char-translating-cr-to-newline))
(defun %ioblock-read-char-translating-cr-to-newline (ioblock)
  (let* ((ch (funcall
              (ioblock-read-char-without-translation-when-locked-function
               ioblock)
              ioblock)))
    (if (eql ch #\Return)
      #\Newline
      ch)))

(defun %private-ioblock-read-char-translating-cr-to-newline (ioblock)
  (check-ioblock-owner ioblock)
  (%ioblock-read-char-translating-cr-to-newline ioblock))

(defun %locked-ioblock-read-char-translating-cr-to-newline (ioblock)
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-char-translating-cr-to-newline ioblock)))

(declaim (inline %ioblock-read-char-translating-crlf-to-newline))
(defun %ioblock-read-char-translating-crlf-to-newline (ioblock)
  (let* ((ch (funcall
              (ioblock-read-char-without-translation-when-locked-function
               ioblock)
              ioblock)))
    (if (eql ch #\Return)
      (let* ((next (funcall
                    (ioblock-read-char-without-translation-when-locked-function
                     ioblock)
                    ioblock)))
        (if (eql next #\Linefeed)
          next
          (progn
            (unless (eq next :eof)
              (setf (ioblock-untyi-char ioblock) next))
            ch)))
      ch)))
    
(defun %private-ioblock-read-char-translating-crlf-to-newline (ioblock)
  (check-ioblock-owner ioblock)
  (%ioblock-read-char-translating-crlf-to-newline ioblock))

(defun %locked-ioblock-read-char-translating-crlf-to-newline (ioblock)
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-char-translating-crlf-to-newline ioblock)))

(declaim (inline %ioblock-read-char-translating-line-separator-to-newline))
(defun %ioblock-read-char-translating-line-separator-to-newline (ioblock)
  (let* ((ch (funcall
              (ioblock-read-char-without-translation-when-locked-function
               ioblock)
              ioblock)))
    (if (eql ch #\Line_Separator)
      #\Newline
      ch)))

(defun %private-ioblock-read-char-translating-line-separator-to-newline (ioblock)
  (check-ioblock-owner ioblock)
  (%ioblock-read-char-translating-line-separator-to-newline ioblock))

(defun %locked-ioblock-read-char-translating-line-separator-to-newline (ioblock)
  (with-ioblock-input-lock-grabbed (ioblock)
    (%ioblock-read-char-translating-line-separator-to-newline ioblock)))

(declaim (inline %ioblock-write-char-translating-newline-to-cr))
(defun %ioblock-write-char-translating-newline-to-cr (ioblock char)
  (funcall (ioblock-write-char-without-translation-when-locked-function
            ioblock)
           ioblock
           (if (eql char #\Newline) #\Return char)))

(defun %private-ioblock-write-char-translating-newline-to-cr (ioblock char)
  (check-ioblock-owner ioblock)
  (%ioblock-write-char-translating-newline-to-cr ioblock char))

(defun %locked-ioblock-write-char-translating-newline-to-cr (ioblock char)
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-char-translating-newline-to-cr ioblock char)))

(declaim (inline %ioblock-write-char-translating-newline-to-crlf))
(defun %ioblock-write-char-translating-newline-to-crlf (ioblock char)
  (when (eql char #\Newline)
    (funcall (ioblock-write-char-without-translation-when-locked-function
              ioblock)
             ioblock
             #\Return))    
  (funcall (ioblock-write-char-without-translation-when-locked-function
            ioblock)
           ioblock
           char))

(defun %private-ioblock-write-char-translating-newline-to-crlf (ioblock char)
  (check-ioblock-owner ioblock)
  (%ioblock-write-char-translating-newline-to-crlf ioblock char))

(defun %locked-ioblock-write-char-translating-newline-to-crlf (ioblock char)
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-char-translating-newline-to-crlf ioblock char)))

(declaim (inline %ioblock-write-char-translating-newline-to-line-separator))
(defun %ioblock-write-char-translating-newline-to-line-separator (ioblock char)
  (funcall (ioblock-write-char-without-translation-when-locked-function
            ioblock)
           ioblock
           (if (eql char #\Newline) #\Line_Separator char)))

(defun %private-ioblock-write-char-translating-newline-to-line-separator (ioblock char)
  (check-ioblock-owner ioblock)
  (%ioblock-write-char-translating-newline-to-line-separator ioblock char))

(defun %locked-ioblock-write-char-translating-newline-to-line-separator (ioblock char)
  (with-ioblock-output-lock-grabbed (ioblock)
    (%ioblock-write-char-translating-newline-to-line-separator ioblock char)))

;;; If we do newline translation, we probably can't be too clever about reading/writing
;;; strings.
(defun %ioblock-write-simple-string-with-newline-translation (ioblock string start-pos num-chars)
  (declare (fixnum start-pos num-chars) (simple-string string))
  (let* ((col (ioblock-charpos ioblock))
         (wcf (ioblock-write-char-when-locked-function ioblock)))
    (declare (fixnum col))
    (do* ((i start-pos (1+ i))
          (n 0 (1+ n)))
         ((= n num-chars) (setf (ioblock-charpos ioblock) col) num-chars)
      (let* ((char (schar string i)))
        (if (eql char #\Newline)
          (setq col 0)
          (incf col))
        (funcall wcf ioblock char)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun setup-ioblock-input (ioblock character-p element-type sharing encoding line-termination)
  (setf (ioblock-sharing ioblock) sharing)
  (when character-p
    (setf (ioblock-unread-char-function ioblock) (select-stream-untyi-function (ioblock-stream ioblock) :input))
    (setf (ioblock-decode-literal-code-unit-limit ioblock)
          (if (and encoding (not (eq encoding :inferred)))
            (character-encoding-decode-literal-code-unit-limit encoding)
            256))    
    (if (and encoding (not (eq encoding :inferred)))
      (let* ((unit-size (character-encoding-code-unit-size encoding)))
        (setf (ioblock-peek-char-function ioblock) '%encoded-ioblock-peek-char)
        (setf (ioblock-read-line-function ioblock)
              '%ioblock-encoded-read-line)
        (setf (ioblock-character-read-vector-function ioblock)
              '%ioblock-encoded-character-read-vector)        
        (setf (ioblock-decode-input-function ioblock)
              (character-encoding-stream-decode-function encoding))
        (setf (ioblock-read-char-function ioblock)
              (ecase unit-size
                (8
                 (setf (ioblock-read-char-when-locked-function ioblock)
                       '%ioblock-read-u8-encoded-char)
                 (case sharing
                   (:private '%private-ioblock-read-u8-encoded-char)
                   (:lock '%locked-ioblock-read-u8-encoded-char)
                   (t '%ioblock-read-u8-encoded-char)))
                (16
                 (if (character-encoding-native-endianness encoding)
                   (progn
                    (setf (ioblock-read-char-when-locked-function ioblock)
                          '%ioblock-read-u16-encoded-char)
                    (case sharing
                      (:private '%private-ioblock-read-u16-encoded-char)
                      (:lock '%locked-ioblock-read-u16-encoded-char)
                      (t '%ioblock-read-u16-encoded-char)))
                   (progn
                     (setf (ioblock-read-char-when-locked-function ioblock)
                           '%ioblock-read-swapped-u16-encoded-char)
                    (case sharing
                      (:private '%private-ioblock-read-swapped-u16-encoded-char)
                      (:lock '%locked-ioblock-read-swapped-u16-encoded-char)
                      (t '%ioblock-read-swapped-u16-encoded-char)))))
                (32
                 (if (character-encoding-native-endianness encoding)
                   (progn
                    (setf (ioblock-read-char-when-locked-function ioblock)
                          #'%ioblock-read-u32-encoded-char)
                    (case sharing
                      (:private #'%private-ioblock-read-u32-encoded-char)
                      (:lock #'%locked-ioblock-read-u32-encoded-char)
                      (t #'%ioblock-read-u32-encoded-char)))
                   (progn
                     (setf (ioblock-read-char-when-locked-function ioblock)
                           #'%ioblock-read-swapped-u32-encoded-char)
                    (case sharing
                      (:private '#'%private-ioblock-read-swapped-u16-encoded-char)
                      (:lock #'%locked-ioblock-read-swapped-u32-encoded-char)
                      (t #'%ioblock-read-swapped-u32-encoded-char))))))))
      (progn
        (setf (ioblock-peek-char-function ioblock) '%ioblock-peek-char)
        (setf (ioblock-read-char-function ioblock)
              (case sharing
                (:private '%private-ioblock-tyi)
                (:lock '%locked-ioblock-tyi)
                (t '%ioblock-tyi)))
        (setf (ioblock-read-char-when-locked-function ioblock)
              '%ioblock-tyi)
        (setf (ioblock-character-read-vector-function ioblock)
              '%ioblock-unencoded-character-read-vector)
        (setf (ioblock-read-line-function ioblock)
              '%ioblock-unencoded-read-line)))
    (when line-termination
      (install-ioblock-input-line-termination ioblock line-termination))
    )

  (unless (or (eq element-type 'character)
              (subtypep element-type 'character))
    (let* ((subtag (element-type-subtype element-type)))
      (declare (type (unsigned-byte 8) subtag))
      (setf (ioblock-read-byte-function ioblock)
            (cond ((= subtag target::subtag-u8-vector)
                   (if character-p
                     ;; The bivalent case, at least for now
                     (progn
                       (setf (ioblock-read-byte-when-locked-function ioblock)
                             '%bivalent-ioblock-read-u8-byte)
                       (case sharing
                         (:private '%bivalent-private-ioblock-read-u8-byte)
                         (:lock '%bivalent-locked-ioblock-read-u8-byte)
                         (t '%bivalent-ioblock-read-u8-byte)))
                     (progn
                       (setf (ioblock-read-byte-when-locked-function ioblock)
                             '%ioblock-read-u8-byte)
                       (case sharing
                         (:private '%private-ioblock-read-u8-byte)
                         (:lock '%locked-ioblock-read-u8-byte)
                         (t '%ioblock-read-u8-byte)))))
                  ((= subtag target::subtag-s8-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-s8-byte) 
                   (case sharing
                     (:private '%private-ioblock-read-s8-byte)
                     (:lock '%locked-ioblock-read-s8-byte)
                     (t '%ioblock-read-s8-byte)))
                  ((= subtag target::subtag-u16-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-u16-byte)
                   (case sharing
                     (:private '%private-ioblock-read-u16-byte)
                     (:lock '%locked-ioblock-read-u16-byte)
                     (t '%ioblock-read-u16-byte)))
                  ((= subtag target::subtag-s16-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-s16-byte)
                   (case sharing
                     (:private '%private-ioblock-read-s16-byte)
                     (:lock '%locked-ioblock-read-s16-byte)
                     (t '%ioblock-read-s16-byte)))
                  ((= subtag target::subtag-u32-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-u32-byte)
                   (case sharing
                     (:private '%private-ioblock-read-u32-byte)
                     (:lock '%locked-ioblock-read-u32-byte)
                     (t '%ioblock-read-u32-byte)))
                  ((= subtag target::subtag-s32-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-s32-byte)                   
                   (case sharing
                     (:private '%private-ioblock-read-s32-byte)
                     (:lock '%locked-ioblock-read-s32-byte)
                     (t '%ioblock-read-s32-byte)))
                  #+64-bit-target
                  ((= subtag target::subtag-u64-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-u64-byte)                   
                   (case sharing
                     (:private '%private-ioblock-read-u64-byte)
                     (:lock '%locked-ioblock-read-u64-byte)
                     (t '%ioblock-read-u64-byte)))
                  #+64-bit-target
                  ((= subtag target::subtag-s64-vector)
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%ioblock-read-s64-byte)
                   (case sharing
                     (:private '%private-ioblock-read-s64-byte)
                     (:lock '%locked-ioblock-read-s64-byte)
                     (t '%ioblock-read-s64-byte)))
                  ;; Not sure what this means, currently.
                  (t
                   (setf (ioblock-read-byte-when-locked-function ioblock)
                         '%general-ioblock-read-byte)
                   '%general-ioblock-read-byte))))))

(defun install-ioblock-input-line-termination (ioblock line-termination)
  (when line-termination
    (let* ((sharing (ioblock-sharing ioblock)))
      (setf (ioblock-read-char-without-translation-when-locked-function ioblock)
            (ioblock-read-char-when-locked-function ioblock)
            (ioblock-character-read-vector-function ioblock)
            '%ioblock-encoded-character-read-vector
            (ioblock-read-line-function ioblock) '%ioblock-encoded-read-line)
      (ecase line-termination
        (:cr (setf (ioblock-read-char-when-locked-function ioblock)
                   '%ioblock-read-char-translating-cr-to-newline
                   (ioblock-read-char-function ioblock)
                   (case sharing
                     (:private
                      '%private-ioblock-read-char-translating-cr-to-newline)
                     (:lock
                      '%locked-ioblock-read-char-translating-cr-to-newline)
                     (t '%ioblock-read-char-translating-cr-to-newline))))
        (:crlf (setf (ioblock-read-char-when-locked-function ioblock)
                     '%ioblock-read-char-translating-crlf-to-newline
                     (ioblock-read-char-function ioblock)
                     (case sharing
                       (:private
                        '%private-ioblock-read-char-translating-crlf-to-newline)
                       (:lock
                        '%locked-ioblock-read-char-translating-crlf-to-newline)
                       (t '%ioblock-read-char-translating-crlf-to-newline))))
        (:unicode (setf (ioblock-read-char-when-locked-function ioblock)
                        '%ioblock-read-char-translating-line-separator-to-newline
                        (ioblock-read-char-function ioblock)
                        (case sharing
                          (:private
                           '%private-ioblock-read-char-translating-line-separator-to-newline)
                          (:lock
                           '%locked-ioblock-read-char-translating-line-separator-to-newline)
                          (t '%ioblock-read-char-translating-line-separator-to-newline)))))
      (setf (ioblock-line-termination ioblock) line-termination))))
  
(defun setup-ioblock-output (ioblock character-p element-type sharing encoding line-termination)
  (or (ioblock-sharing ioblock)
      (setf (ioblock-sharing ioblock) sharing))
  (when character-p
    (setf (ioblock-encode-literal-char-code-limit ioblock)
          (if encoding
            (character-encoding-encode-literal-char-code-limit encoding)
            256))    
    (if encoding
      (let* ((unit-size (character-encoding-code-unit-size encoding)))
        (setf (ioblock-encode-output-function ioblock)
              (character-encoding-stream-encode-function encoding))
        (setf (ioblock-write-char-function ioblock)
              (ecase unit-size
                (8
                 (setf (ioblock-write-char-when-locked-function ioblock)
                       '%ioblock-write-u8-encoded-char) 
                 (case sharing
                   (:private '%private-ioblock-write-u8-encoded-char)
                   (:lock '%locked-ioblock-write-u8-encoded-char)
                   (t '%ioblock-write-u8-encoded-char)))
                (16
                 (if (character-encoding-native-endianness encoding)
                   (progn
                     (setf (ioblock-write-char-when-locked-function ioblock)
                           '%ioblock-write-u16-encoded-char) 
                     (case sharing
                       (:private '%private-ioblock-write-u16-encoded-char)
                       (:lock '%locked-ioblock-write-u16-encoded-char)
                       (t '%ioblock-write-u16-encoded-char)))
                   (progn
                     (setf (ioblock-write-char-when-locked-function ioblock)
                           '%ioblock-write-swapped-u16-encoded-char)
                     (case sharing
                       (:private '%private-ioblock-write-swapped-u16-encoded-char)
                       (:lock '%locked-ioblock-write-swapped-u16-encoded-char)
                       (t '%ioblock-write-swapped-u16-encoded-char)))))
                (32
                 (if (character-encoding-native-endianness encoding)
                   (progn
                     (setf (ioblock-write-char-when-locked-function ioblock)
                           #'%ioblock-write-u32-encoded-char) 
                     (case sharing
                       (:private #'%private-ioblock-write-u32-encoded-char)
                       (:lock #'%locked-ioblock-write-u32-encoded-char)
                       (t #'%ioblock-write-u32-encoded-char)))
                   (progn
                     (setf (ioblock-write-char-when-locked-function ioblock)
                           #'%ioblock-write-swapped-u32-encoded-char)
                     (case sharing
                       (:private #'%private-ioblock-write-swapped-u32-encoded-char)
                       (:lock #'%locked-ioblock-write-swapped-u32-encoded-char)
                       (t #'%ioblock-write-swapped-u32-encoded-char)))))))
        (setf (ioblock-write-simple-string-function ioblock)
              (ecase unit-size
                (8 '%ioblock-write-u8-encoded-simple-string)
                (16
                 (if (character-encoding-native-endianness encoding)
                   '%ioblock-write-u16-encoded-simple-string
                   '%ioblock-write-swapped-u16-encoded-simple-string))
                (32
                 (if (character-encoding-native-endianness encoding)
                   #'%ioblock-write-u32-encoded-simple-string
                   #'%ioblock-write-swapped-u32-encoded-simple-string))))
        (when (character-encoding-use-byte-order-mark encoding)
          (setf (ioblock-pending-byte-order-mark ioblock) t)))
      (progn
        (setf (ioblock-write-simple-string-function ioblock)
              '%ioblock-unencoded-write-simple-string)
        (setf (ioblock-write-char-when-locked-function ioblock)
              '%ioblock-write-char)
        (setf (ioblock-write-char-function ioblock)
              (case sharing
                (:private '%private-ioblock-write-char)
                (:lock '%locked-ioblock-write-char)
                (t '%ioblock-write-char)))))
    (when line-termination
      (install-ioblock-output-line-termination ioblock line-termination)))
  (unless (or (eq element-type 'character)
              (subtypep element-type 'character))
    (let* ((subtag (element-type-subtype element-type)))
      (declare (type (unsigned-byte 8) subtag))
      (setf (ioblock-write-byte-function ioblock)
            (cond ((= subtag target::subtag-u8-vector)
                   (progn
                     (setf (ioblock-write-byte-when-locked-function ioblock)
                           '%ioblock-write-u8-byte)
                     (case sharing
                       (:private '%private-ioblock-write-u8-byte)
                       (:lock '%locked-ioblock-write-u8-byte)
                       (t '%ioblock-write-u8-byte))))
                  ((= subtag target::subtag-s8-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-s8-byte)                   
                   (case sharing
                     (:private '%private-ioblock-write-s8-byte)
                     (:lock '%locked-ioblock-write-s8-byte)
                     (t '%ioblock-write-s8-byte)))
                  ((= subtag target::subtag-u16-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-u16-byte)                   
                   (case sharing
                     (:private '%private-ioblock-write-u16-byte)
                     (:lock '%locked-ioblock-write-u16-byte)
                     (t '%ioblock-write-u16-byte)))
                  ((= subtag target::subtag-s16-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-s16-byte)                                      
                   (case sharing
                     (:private '%private-ioblock-write-s16-byte)
                     (:lock '%locked-ioblock-write-s16-byte)
                     (t '%ioblock-write-s16-byte)))
                  ((= subtag target::subtag-u32-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-u32-byte)                                      
                   (case sharing
                     (:private '%private-ioblock-write-u32-byte)
                     (:lock '%locked-ioblock-write-u32-byte)
                     (t '%ioblock-write-u32-byte)))
                  ((= subtag target::subtag-s32-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-s32-byte)
                   (case sharing
                     (:private '%private-ioblock-write-s32-byte)
                     (:lock '%locked-ioblock-write-s32-byte)
                     (t '%ioblock-write-s32-byte)))
                  #+64-bit-target
                  ((= subtag target::subtag-u64-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-u64-byte)
                   (case sharing
                     (:private '%private-ioblock-write-u64-byte)
                     (:lock '%locked-ioblock-write-u64-byte)
                     (t '%ioblock-write-u64-byte)))
                  #+64-bit-target
                  ((= subtag target::subtag-s64-vector)
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%ioblock-write-u64-byte)
                   (case sharing
                     (:private '%private-ioblock-write-s64-byte)
                     (:lock '%locked-ioblock-write-s64-byte)
                     (t '%ioblock-write-s64-byte)))
                  (t
                   (setf (ioblock-write-byte-when-locked-function ioblock)
                         '%general-ioblock-write-byte)                   
                   '%general-ioblock-write-byte))))))

(defun install-ioblock-output-line-termination (ioblock line-termination)
  (let* ((sharing (ioblock-sharing ioblock)))
        (when line-termination
      (setf (ioblock-write-char-without-translation-when-locked-function ioblock)
            (ioblock-write-char-when-locked-function ioblock)
            (ioblock-write-simple-string-function ioblock)
            '%ioblock-write-simple-string-with-newline-translation)
      (ecase line-termination
        (:cr (setf (ioblock-write-char-when-locked-function ioblock)
                   '%ioblock-write-char-translating-newline-to-cr
                   (ioblock-write-char-function ioblock)
                   (case sharing
                     (:private
                      '%private-ioblock-write-char-translating-newline-to-cr)
                     (:lock
                      '%locked-ioblock-write-char-translating-newline-to-cr)
                     (t '%ioblock-write-char-translating-newline-to-cr))))
        (:crlf (setf (ioblock-write-char-when-locked-function ioblock)
                     '%ioblock-write-char-translating-newline-to-crlf
                     (ioblock-write-char-function ioblock)
                     (case sharing
                       (:private
                        '%private-ioblock-write-char-translating-newline-to-crlf)
                       (:lock
                        '%locked-ioblock-write-char-translating-newline-to-crlf)
                       (t '%ioblock-write-char-translating-newline-to-crlf))))
        (:unicode (setf (ioblock-write-char-when-locked-function ioblock)
                        '%ioblock-write-char-translating-newline-to-line-separator
                        (ioblock-write-char-function ioblock)
                        (case sharing
                          (:private
                           '%private-ioblock-write-char-translating-newline-to-line-separator)
                          (:lock
                           '%locked-ioblock-write-char-translating-newline-to-line-separator)
                          (t '%ioblock-write-char-translating-newline-to-line-separator)))))
      (setf (ioblock-line-termination ioblock) line-termination))))


(defun ensure-reasonable-element-type (element-type)
  (let* ((upgraded (upgraded-array-element-type element-type)))
    (if (eq upgraded 'bit)
      '(unsigned-byte 8)
      (if (eq upgraded 'fixnum)
        #+64-bit-target '(signed-byte 64) #+32-bit-target '(signed-byte 32)
        (if (eq upgraded t)
          (error "Stream element-type ~s can't be reasonably supported." element-type)
          upgraded)))))

(defun init-stream-ioblock (stream
                            &key
                            insize      ; integer to allocate inbuf here, nil
                                        ; otherwise
                            outsize     ; integer to allocate outbuf here, nil
                                        ; otherwise
                            share-buffers-p ; true if input and output
                                        ; share a buffer
                            element-type
                            device
                            advance-function
                            listen-function
                            eofp-function
                            force-output-function
                            close-function
                            element-shift
                            interactive
                            (sharing :private)
                            character-p
                            encoding
                            line-termination
                            input-timeout
                            output-timeout
                            deadline
                            &allow-other-keys)
  (declare (ignorable element-shift))
  (setq line-termination (cdr (assoc line-termination *canonical-line-termination-conventions*)))
  (when encoding
    (cond ((and (eq encoding :inferred)
                (typep stream 'file-stream)
                insize))
          (t
           (unless (typep encoding 'character-encoding)
             (setq encoding (get-character-encoding encoding)))
           (if (eq encoding (get-character-encoding nil))
             (setq encoding nil)))))
  (when sharing
    (unless (or (eq sharing :private)
                (eq sharing :lock))
      (if (eq sharing :external)
        (setq sharing nil)
        (report-bad-arg sharing '(member nil :private :lock :external)))))
  (let* ((ioblock (or (let* ((ioblock (stream-ioblock stream nil)))
                        (when ioblock
                          (setf (ioblock-stream ioblock) stream)
                          ioblock))
                      (stream-create-ioblock stream))))
    (when (eq sharing :private)
      (setf (ioblock-owner ioblock) 0))
    (setf (ioblock-encoding ioblock) encoding)
    (when insize
      (unless (ioblock-inbuf ioblock)
        (multiple-value-bind (buffer ptr in-size-in-octets)
            (make-heap-ivector insize
                               (if character-p
                                 '(unsigned-byte 8)
                                 (setq element-type
                                       (ensure-reasonable-element-type element-type))))
          (setf (ioblock-inbuf ioblock)
                (make-io-buffer :buffer buffer
                                :bufptr ptr
                                :size in-size-in-octets
                                :limit insize))
          (when (eq sharing :lock)
            (setf (ioblock-inbuf-lock ioblock) (make-lock)))
          (setf (ioblock-line-termination ioblock) line-termination)

          (setf (ioblock-element-shift ioblock)
                (let* ((octets-per-element (/ in-size-in-octets insize)))
                  (case octets-per-element
                    (1 0)
                    (2 1)
                    (4 2)
                    (8 3)
                    (t (max 0 (ceiling (log octets-per-element 2)))))))
          )))
    (when (ioblock-inbuf ioblock)
      (setup-ioblock-input ioblock character-p element-type sharing encoding line-termination))      
    (if share-buffers-p
      (if insize
        (progn (setf (ioblock-outbuf ioblock)
                     (ioblock-inbuf ioblock))
               (setf (ioblock-outbuf-lock ioblock)
                     (ioblock-inbuf-lock ioblock)))
        (error "Can't share buffers unless insize is non-zero and non-null"))
      (when outsize
        (unless (ioblock-outbuf ioblock)
          (multiple-value-bind (buffer ptr out-size-in-octets)
              (make-heap-ivector outsize
                                 (if character-p
                                   '(unsigned-byte 8)
                                   (setq element-type (ensure-reasonable-element-type element-type))))
            (setf (ioblock-outbuf ioblock)
                  (make-io-buffer :buffer buffer
                                  :bufptr ptr
                                  :count 0
                                  :limit outsize
                                  :size out-size-in-octets))
            (when (eq sharing :lock)
              (setf (ioblock-outbuf-lock ioblock) (make-lock)))
            (setf (ioblock-element-shift ioblock)
                  (let* ((octets-per-element (/ out-size-in-octets outsize)))
                    (case octets-per-element
                      (1 0)
                      (2 1)
                      (4 2)
                      (8 3)
                      (t 
                       (max 0 (ceiling (log octets-per-element 2)))))))
            ))))
    (when (ioblock-outbuf ioblock)
      (setup-ioblock-output ioblock character-p element-type sharing encoding line-termination))
    (when element-type
      (setf (ioblock-element-type ioblock) (if character-p 'character element-type)))
;    (when element-shift
;      (setf (ioblock-element-shift ioblock) element-shift))
    (when device
      (setf (ioblock-device ioblock) device))
    (when advance-function
      (setf (ioblock-advance-function ioblock) advance-function))
    (when listen-function
      (setf (ioblock-listen-function ioblock) listen-function))
    (when eofp-function
      (setf (ioblock-eofp-function ioblock) eofp-function))
    (when force-output-function
      (setf (ioblock-force-output-function ioblock) force-output-function))
    (when close-function
      (setf (ioblock-close-function ioblock) close-function))
    (when interactive
      (setf (ioblock-interactive ioblock) interactive))
    (setf (stream-ioblock stream) ioblock)
    (when (and encoding (not (eq encoding :inferred)))
      (setf (ioblock-native-byte-order ioblock)
            (character-encoding-native-endianness encoding)))
    (let* ((bom-info (and insize encoding (not (eq encoding :inferred)) (character-encoding-use-byte-order-mark encoding))))
      (when bom-info
        (ioblock-check-input-bom ioblock bom-info sharing)))
    (when input-timeout
      (check-io-timeout input-timeout)
      (setf (ioblock-input-timeout ioblock) (round (* 1000 input-timeout))))
    (when output-timeout
      (check-io-timeout output-timeout)
      (setf (ioblock-output-timeout ioblock) (round (* 1000 output-timeout))))
    (setf (ioblock-deadline ioblock) deadline)
    ioblock))

;;; If there's a byte-order-mark (or a reversed byte-order-mark) at
;;; the beginning of the input stream, deal with it.  If there's any
;;; input present, make sure that we don't write a BOM on output.  If
;;; this is a little-endian machine, input data was present, and there
;;; was no BOM in that data, make things big-endian.  If there's a
;;; leading BOM or swapped BOM, eat it (consume it so that it doesn't
;;; ordinarily appear as input.)
;;;
(defun ioblock-check-input-bom (ioblock swapped-encoding-name sharing)
  (let* ((n (%ioblock-advance ioblock nil))) ; try to read, don't block
    (when n
      (setf (ioblock-pending-byte-order-mark ioblock) nil)
      (let* ((inbuf (ioblock-inbuf ioblock))
             (unit-size (character-encoding-code-unit-size (ioblock-encoding ioblock)))
             (min (ash unit-size -3))
             (buf (io-buffer-buffer inbuf))
             (swapped-encoding
              (and
               (>= n min)
               (case (case unit-size
                       (16 (%native-u8-ref-u16 buf 0))
                       (32 (%native-u8-ref-u32 buf 0)))
                 (#.byte-order-mark-char-code
                  (setf (io-buffer-idx inbuf) min)
                  nil)
                 (#.swapped-byte-order-mark-char-code
                  (setf (io-buffer-idx inbuf) min)
                  t)
                 (t #+little-endian-target t))
               (lookup-character-encoding swapped-encoding-name))))
        (when swapped-encoding
          (let* ((output-p (not (null (ioblock-outbuf ioblock)))))
            (setf (ioblock-native-byte-order ioblock)
                  (character-encoding-native-endianness swapped-encoding))
            (ecase unit-size
              (16
               (setf (ioblock-read-char-when-locked-function ioblock)
                     '%ioblock-read-swapped-u16-encoded-char)
               (case sharing
                 (:private '%private-ioblock-read-swapped-u16-encoded-char)
                 (:lock '%locked-ioblock-read-swapped-u16-encoded-char)
                 (t '%ioblock-read-swapped-u16-encoded-char)))
              (32
               (setf (ioblock-read-char-when-locked-function ioblock)
                     '%ioblock-read-swapped-u32-encoded-char)
               (case sharing
                 (:private '%private-ioblock-read-swapped-u32-encoded-char)
                 (:lock '%locked-ioblock-read-swapped-u32-encoded-char)
                 (t '%ioblock-read-swapped-u16-encoded-char))))
            (when output-p
              (ecase unit-size
                (16
                 (setf (ioblock-write-char-when-locked-function ioblock)
                       '%ioblock-write-swapped-u16-encoded-char)
                 (case sharing
                   (:private '%private-ioblock-write-swapped-u16-encoded-char)
                   (:lock '%locked-ioblock-write-swapped-u16-encoded-char)
                   (t '%ioblock-write-swapped-u16-encoded-char))
                 (setf (ioblock-write-simple-string-function ioblock)
                       '%ioblock-write-swapped-u16-encoded-simple-string))
                (32
                 (setf (ioblock-write-char-when-locked-function ioblock)
                       '%ioblock-write-swapped-u32-encoded-char)
                 (case sharing
                   (:private '%private-ioblock-write-swapped-u32-encoded-char)
                   (:lock '%locked-ioblock-write-swapped-u32-encoded-char)
                   (t '%ioblock-write-swapped-u32-encoded-char))
                 (setf (ioblock-write-simple-string-function ioblock)
                       '%ioblock-write-swapped-u32-encoded-simple-string))))))))))



;;; We can't define a MAKE-INSTANCE method on STRUCTURE-CLASS subclasses
;;; in MCL; of course, calling the structure-class's constructor does
;;; much the same thing (but note that MCL only keeps track of the
;;; default, automatically generated constructor.)
;;; (As fascinating as that may be, that has nothing to do with any
;;; nearby code, though it may have once been relevant.)
(defun make-ioblock-stream (class
			    &rest initargs
			    &key 
			    &allow-other-keys)
  (declare (dynamic-extent initargs))
  (let* ((s
          (if (subtypep class 'basic-stream)
            (apply #'make-basic-stream-instance class :allow-other-keys t initargs)
            (apply #'make-instance class :allow-other-keys t initargs))))
    (apply #'init-stream-ioblock s initargs)
    s))





(defmethod select-stream-class ((s symbol) in-p out-p char-p)
  (select-stream-class (class-prototype (find-class s)) in-p out-p char-p))

(defmethod select-stream-class ((s structure-class) in-p out-p char-p)
  (select-stream-class (class-prototype s) in-p out-p char-p))

(defmethod select-stream-class ((s standard-class) in-p out-p char-p)
  (select-stream-class (class-prototype s) in-p out-p char-p))


(defparameter *canonical-line-termination-conventions*
  '((:unix . nil)
    (:macos . :cr)
    (:cr . :cr)
    (:crlf . :crlf)
    (:cp/m . :crlf)
    (:msdos . :crlf)
    (:dos . :crlf)
    (:windows . :crlf)
    (:inferred . nil)
    (:unicode . :unicode)))

(defun optimal-buffer-size (fd element-type)
  #+windows-target (declare (ignore fd))
  (flet ((scale-buffer-size (octets)
	   (case (subtag-bytes (element-type-subtype element-type) 1)
	     (1 octets)
	     (2 (ash octets -1))
	     (4 (ash octets -2))
	     (8 (ash octets -3)))))
    #+windows-target
    (let ((octets 4096))
      (scale-buffer-size octets))
    #-windows-target
    (let* ((nominal (or (nth-value 6 (%fstat fd)) *elements-per-buffer*))
	   (octets (case (%unix-fd-kind fd)
		     (:pipe (#_fpathconf fd #$_PC_PIPE_BUF))
		     (:socket
		      #+linux-target nominal
		      #-linux-target
		      (int-getsockopt fd #$SOL_SOCKET
				      #+solaris-target #$SO_SNDBUF
				      #-solaris-target #$SO_SNDLOWAT))
		     ((:character-special :tty)
		      (#_fpathconf fd #$_PC_MAX_INPUT))
		     (t nominal))))
      (when (<= octets 0) (setq octets nominal))
      (scale-buffer-size octets))))

(defun milliseconds-until-deadline (deadline ioblock)
  (let* ((now (get-internal-real-time)))
    (if (> now deadline)
      (error 'communication-deadline-expired :stream (ioblock-stream ioblock))
      (values (round (- deadline now) (/ internal-time-units-per-second 1000))))))


;;; Note that we can get "bivalent" streams by specifiying :character-p t
;;; with a reasonable element-type (e.g. (UNSIGNED-BYTE 8))
(defun make-fd-stream (fd &key
			  (direction :input)
			  (interactive t)
			  (element-type 'character)
			  (class 'fd-stream)
                          (sharing :private)
                          (character-p (or (eq element-type 'character)
                                           (subtypep element-type 'character)))
                          (basic nil)
                          encoding
                          line-termination
                          auto-close
                          input-timeout
                          output-timeout
                          deadline)
  (let* ((elements-per-buffer (optimal-buffer-size fd element-type)))
    (when line-termination
      (setq line-termination
            (cdr (assoc line-termination *canonical-line-termination-conventions*))))
    (when basic
      (setq class (map-to-basic-stream-class-name class))
      (setq basic (subtypep (find-class class) 'basic-stream)))
    (let* ((in-p (member direction '(:io :input)))
           (out-p (member direction '(:io :output)))
           (class-name (select-stream-class class in-p out-p character-p))
           (class (find-class class-name))
           (stream
            (make-ioblock-stream class
                                 :insize (if in-p elements-per-buffer)
                                 :outsize (if out-p elements-per-buffer)
                                 :device fd
                                 :interactive interactive
                                 :element-type element-type
                                 :advance-function (if in-p
                                                     (select-stream-advance-function class direction))
                                 :listen-function (if in-p 'fd-stream-listen)
                                 :eofp-function (if in-p 'fd-stream-eofp)
                                 :force-output-function (if out-p
                                                          (select-stream-force-output-function class direction))
                                 :close-function 'fd-stream-close
                                 :sharing sharing
                                 :character-p character-p
                                 :encoding encoding
                                 :line-termination line-termination
                                 :input-timeout input-timeout
                                 :output-timeout output-timeout
                                 :deadline deadline)))
      (if auto-close
        (terminate-when-unreachable stream
                                    (lambda (stream)
                                      (close-for-termination stream t))))
      stream)))

  
;;;  Fundamental streams.

(defclass fundamental-stream (stream)
    ())

(defclass fundamental-input-stream (fundamental-stream input-stream)
    ((shared-resource :initform nil :accessor input-stream-shared-resource)))

(defclass fundamental-output-stream (fundamental-stream output-stream)
    ())

(defmethod input-stream-p ((x t))
  (report-bad-arg x 'stream))
			   
(defmethod input-stream-p ((s input-stream))
  t)

(defmethod output-stream-p ((x t))
  (report-bad-arg x 'stream))

(defmethod output-stream-p ((s input-stream))
  (typep s 'output-stream))

(defmethod output-stream-p ((s output-stream))
  t)

(defmethod input-stream-p ((s output-stream))
  (typep s 'input-stream))

(defclass binary-stream (stream)
    ())

(defclass character-stream (stream)
    ())

(defmethod stream-external-format ((s character-stream))
  (make-external-format :character-encoding #+big-endian-target :utf-32be #+little-endian-target :utf-32le :line-termination :unix))


(defmethod (setf stream-external-format) (new (s character-stream))
  (check-type new external-format)
  (stream-external-format s))


(defclass fundamental-character-stream (fundamental-stream character-stream)
    ())

(defmethod stream-element-type ((s fundamental-character-stream))
  'character)

(defclass fundamental-binary-stream (fundamental-stream binary-stream)
    ())

(defclass character-input-stream (input-stream character-stream)
    ())

(defclass fundamental-character-input-stream (fundamental-input-stream
                                              fundamental-character-stream
                                              character-input-stream)
    ())

(defmethod stream-read-char-no-hang ((s fundamental-character-input-stream))
  (stream-read-char s))

(defmethod stream-peek-char ((s fundamental-character-input-stream))
  (let* ((ch (stream-read-char s)))
    (unless (eq ch :eof)
      (stream-unread-char s ch))
    ch))

(defmethod stream-listen ((s fundamental-character-input-stream))
  (let* ((ch (stream-read-char-no-hang s)))
    (when (and ch (not (eq ch :eof)))
      (stream-unread-char s ch))
    ch))

(defmethod stream-clear-input ((s fundamental-character-input-stream))
  )

(defmethod stream-read-line ((s character-input-stream))
  (generic-read-line s))

(defclass character-output-stream (output-stream character-stream)
    ())

(defclass fundamental-character-output-stream (fundamental-output-stream
                                               fundamental-character-stream
                                               character-output-stream)
    ())

(defclass binary-input-stream (input-stream binary-stream)
    ())

(defclass fundamental-binary-input-stream (fundamental-input-stream
                                           fundamental-binary-stream
                                           binary-input-stream)
    ())

(defclass binary-output-stream (output-stream binary-stream)
    ())

(defclass fundamental-binary-output-stream (fundamental-output-stream
                                            fundamental-binary-stream
                                            binary-output-stream)
    ())



(defmethod stream-read-byte ((s t))
  (report-bad-arg s '(and input-stream binary-stream)))

(defmethod stream-write-byte ((s t) b)
  (declare (ignore b))
  (report-bad-arg s '(and output-stream binary-stream)))

(defmethod stream-length ((s stream) &optional new)
  (declare (ignore new)))

(defmethod stream-start-line-p ((s character-output-stream))
  (eql 0 (stream-line-column s)))

(defmethod stream-terpri ((s character-output-stream))
  (stream-write-char s #\Newline))

(defmethod stream-fresh-line ((s character-output-stream))
  (unless (stream-start-line-p s)
    (stream-terpri s)
    t))

;;; The bad news is that this doesn't even bother to do the obvious
;;; (calling STREAM-WRITE-STRING with a longish string of spaces.)
;;; The good news is that this method is pretty useless to (format "~T" ...)
;;; anyhow.
(defmethod stream-advance-to-column ((s fundamental-character-output-stream)
				     col)
  (generic-advance-to-column s col))

(defmethod stream-write-string ((stream fundamental-character-output-stream) string &optional (start 0) end)
  (generic-stream-write-string stream string start end))


;;; The read-/write-vector methods could be specialized for stream classes
;;; that expose the underlying buffering mechanism.
;;; They can assume that the 'vector' argument is a simple one-dimensional
;;; array and that the 'start' and 'end' arguments are sane.

(defmethod stream-write-vector ((stream character-output-stream)
				vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i)))
       ((= i end))
    (declare (fixnum i))
    (write-char (uvref vector i) stream)))

(defmethod stream-write-vector ((stream binary-output-stream)
				vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i)))
       ((= i end))
    (declare (fixnum i))
    (write-byte (uvref vector i) stream)))

(defmethod stream-read-vector ((stream character-input-stream)
			       vector start end)
  (generic-character-read-vector stream vector start end))


(defmethod stream-read-vector ((stream binary-input-stream)
			       vector start end)
  (declare (fixnum start end))
  (do* ((i start (1+ i)))
       ((= i end) end)
    (declare (fixnum i))
    (let* ((b (read-byte stream nil :eof)))
      (if (eq b :eof)
	(return i)
	(setf (uvref vector i) b)))))




;;; File streams, in the abstract.

(defclass file-stream (stream)
    ())

(defmethod stream-domain ((s file-stream))
  :file)



;;; "Basic" (non-extensible) streams.


(declaim (inline basic-stream-p))

(defun basic-stream-p (x)
  (= (the fixnum (typecode x)) target::subtag-basic-stream))

(setf (type-predicate 'basic-stream) 'basic-stream-p)

(make-built-in-class 'basic-stream 'stream)
(make-built-in-class 'basic-file-stream 'basic-stream 'file-stream)
(make-built-in-class 'basic-character-stream 'basic-stream 'character-stream)
(make-built-in-class 'basic-binary-stream 'basic-stream 'binary-stream)

(make-built-in-class 'basic-input-stream 'basic-stream 'input-stream)
(make-built-in-class 'basic-output-stream 'basic-stream 'output-stream)
(make-built-in-class 'basic-io-stream 'basic-input-stream 'basic-output-stream)
(make-built-in-class 'basic-character-input-stream 'basic-input-stream 'basic-character-stream 'character-input-stream)
(make-built-in-class 'basic-character-output-stream 'basic-output-stream 'basic-character-stream 'character-output-stream)
(make-built-in-class 'basic-character-io-stream 'basic-character-input-stream 'basic-character-output-stream)
(make-built-in-class 'basic-binary-input-stream 'basic-input-stream 'basic-binary-stream 'binary-input-stream)
(make-built-in-class 'basic-binary-output-stream 'basic-output-stream 'basic-binary-stream 'binary-output-stream)
(make-built-in-class 'basic-binary-io-stream 'basic-binary-input-stream 'basic-binary-output-stream)


(defun %ioblock-external-format (ioblock)
  (let* ((encoding (or (ioblock-encoding ioblock)
                       (get-character-encoding nil)))
         (line-termination (or (ioblock-line-termination ioblock)
                               :unix)))
    (make-external-format :character-encoding (character-encoding-name encoding)
                          :line-termination line-termination)))

(defmethod input-stream-shared-resource ((s basic-input-stream))
  (getf (basic-stream.info s) :shared-resource))

(defmethod (setf input-stream-shared-resource) (new (s basic-input-stream))
  (setf (getf (basic-stream.info s) :shared-resource) new))

(defmethod print-object ((s basic-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (let* ((ioblock (basic-stream.state s))
           (fd (and ioblock (ioblock-device ioblock)))
           (encoding (and ioblock (encoding-name (ioblock-encoding ioblock)))))
      (if fd
        (format out "~a (~a/~d)" encoding (%unix-fd-kind fd) fd)
        (format out "~s" :closed)))))

(defmethod select-stream-class ((s (eql 'basic-stream)) in-p out-p char-p)
  (if char-p
    (if in-p
      (if out-p
        'basic-character-io-stream
        'basic-character-input-stream)
      'basic-character-output-stream)
    (if in-p
      (if out-p
        'basic-binary-io-stream
        'basic-binary-input-stream)
      'basic-binary-output-stream)))


(defmethod map-to-basic-stream-class-name (name)
  name)

(defmethod map-to-basic-stream-class-name ((name (eql 'fd-stream)))
  'basic-stream)

(defun allocate-basic-stream (class)
  (if (subtypep class 'basic-file-stream)
    (gvector :basic-stream (%class-own-wrapper class) 0 nil nil nil nil nil)
    (gvector :basic-stream (%class-own-wrapper class) 0 nil nil)))


(defmethod initialize-basic-stream ((s basic-stream) &key &allow-other-keys)
  )
  
(defmethod initialize-basic-stream :after  ((s basic-input-stream) &key &allow-other-keys)
  (setf (basic-stream.flags s)
        (logior (ash 1 basic-stream-flag.open-input) (basic-stream.flags s))))

(defmethod initialize-basic-stream :after ((s basic-output-stream) &key &allow-other-keys)
  (setf (basic-stream.flags s)
        (logior (ash 1 basic-stream-flag.open-output) (basic-stream.flags s))))

(defmethod initialize-basic-stream :after ((s basic-binary-stream) &key &allow-other-keys)
  (setf (basic-stream.flags s)
        (logior (ash 1 basic-stream-flag.open-binary) (basic-stream.flags s))))

(defmethod initialize-basic-stream :after ((s basic-character-stream) &key &allow-other-keys)
  (setf (basic-stream.flags s)
        (logior (ash 1 basic-stream-flag.open-character) (basic-stream.flags s))))

(defun make-basic-stream-instance (class &rest initargs)
  (let* ((s (allocate-basic-stream class)))
    (apply #'initialize-basic-stream s initargs)
    s))



(defmethod (setf stream-ioblock) (ioblock (s basic-stream))
  (setf (basic-stream.state s) ioblock))

(defmethod stream-create-ioblock ((stream basic-stream) &rest args &key)
  (declare (dynamic-extent args))
  (apply #'make-ioblock :stream stream args))


(defmethod stream-write-list ((stream fundamental-character-output-stream)
			      list count)
  (declare (fixnum count))
  (dotimes (i count)
    (stream-write-char stream (pop list))))

(defmethod stream-write-list ((stream basic-character-output-stream)
			      list count)
  (declare (fixnum count))
  (dotimes (i count)
    (stream-write-char stream (pop list))))

(defmethod stream-read-list ((stream character-input-stream)
			     list count)
  (generic-character-read-list stream list count))


(defmethod stream-write-list ((stream fundamental-binary-output-stream)
			      list count)
  (declare (fixnum count))
  (dotimes (i count)
    (let* ((element (pop list)))
      (if (typep element 'character)
        (write-char element stream)
        (write-byte element stream)))))

(defmethod stream-write-list ((stream basic-binary-output-stream)
			      list count)
  (declare (fixnum count))
  (dotimes (i count)
    (let* ((element (pop list)))
      (if (typep element 'character)
        (write-char element stream)
        (write-byte element stream)))))

(defmethod stream-read-list ((stream binary-input-stream)
			     list count)
  (declare (fixnum count))
  (do* ((tail list (cdr tail))
	(i 0 (1+ i)))
       ((= i count) count)
    (declare (fixnum i))
    (let* ((b (read-byte stream nil :eof)))
      (if (eq b :eof)
	(return i)
	(rplaca tail b)))))

(defun stream-is-closed (s)
  (error 'stream-is-closed-error :stream s))

(defmethod stream-read-char ((s basic-character-input-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (funcall (ioblock-read-char-function ioblock) ioblock)))


(defmethod
    stream-read-char-no-hang ((stream basic-character-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (values
          (%ioblock-tyi-no-hang ioblock)))))
       
(defmethod stream-peek-char ((stream basic-character-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (values
       (funcall (ioblock-peek-char-function ioblock) ioblock)))))

(defmethod stream-clear-input ((stream basic-character-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (values
        (%ioblock-clear-input ioblock)))))

(defmethod stream-unread-char ((s basic-character-input-stream) char)
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-input-locked (ioblock)
      (values
       (funcall (ioblock-unread-char-function ioblock) ioblock char)))))

(defmethod stream-read-ivector ((s basic-binary-input-stream)
				iv start nb)
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-input-locked (ioblock)
      (values
       (%ioblock-binary-in-ivect ioblock iv start nb)))))

(defmethod stream-read-vector ((stream basic-character-input-stream)
			       vector start end)
  (declare (fixnum start end))
  (if (not (typep vector 'simple-base-string))
    (generic-character-read-vector stream vector start end)
    (let* ((ioblock (basic-stream-ioblock stream)))
      (with-ioblock-input-locked (ioblock)
        (values
         (funcall (ioblock-character-read-vector-function ioblock)
                  ioblock vector start end))))))

(defmethod stream-read-line ((stream basic-character-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (funcall (ioblock-read-line-function ioblock) ioblock))))

                             
;;; Synonym streams.

(defclass synonym-stream (fundamental-stream)
    ((symbol :initarg :symbol :reader synonym-stream-symbol)))

(defmethod print-object ((s synonym-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (format out "to ~s" (synonym-stream-symbol s))))

(macrolet ((synonym-method (name &rest args)
            (let* ((stream (make-symbol "STREAM")))
              `(defmethod ,name ((,stream synonym-stream) ,@args)
                (,name (symbol-value (synonym-stream-symbol ,stream)) ,@args)))))
           (synonym-method stream-read-char)
           (synonym-method stream-read-byte)
           (synonym-method stream-unread-char c)
           (synonym-method stream-read-char-no-hang)
           (synonym-method stream-peek-char)
           (synonym-method stream-listen)
           (synonym-method stream-eofp)
           (synonym-method stream-clear-input)
           (synonym-method stream-read-line)
           (synonym-method stream-read-list l c)
           (synonym-method stream-read-vector v start end)
           (synonym-method stream-write-char c)
           ;(synonym-method stream-write-string str &optional (start 0) end)
           (synonym-method stream-write-byte b)
           (synonym-method stream-clear-output)
           (synonym-method stream-line-column)
           (synonym-method stream-line-length)
           (synonym-method stream-set-column new)
           (synonym-method stream-advance-to-column new)
           (synonym-method stream-start-line-p)
           (synonym-method stream-fresh-line)
           (synonym-method stream-terpri)
           (synonym-method stream-force-output)
           (synonym-method stream-finish-output)
           (synonym-method stream-write-list l c)
           (synonym-method stream-write-vector v start end)
           (synonym-method stream-element-type)
           (synonym-method input-stream-p)
           (synonym-method output-stream-p)
           (synonym-method interactive-stream-p)
           (synonym-method stream-direction)
	   (synonym-method stream-device direction)
           (synonym-method stream-surrounding-characters)
           (synonym-method stream-input-timeout)
           (synonym-method stream-output-timeout)
           (synonym-method stream-deadline)
           (synonym-method stream-eof-transient-p))

(defmethod (setf input-stream-timeout) (new (s synonym-stream))
  (setf (input-stream-timeout (symbol-value (synonym-stream-symbol s))) new))

(defmethod (setf output-stream-timeout) (new (s synonym-stream))
  (setf (output-stream-timeout (symbol-value (synonym-stream-symbol s))) new))


(defmethod stream-write-string ((s synonym-stream) string &optional (start 0) end)
  (stream-write-string (symbol-value (synonym-stream-symbol s)) string start end))

(defmethod stream-length ((s synonym-stream) &optional new)
  (stream-length (symbol-value (synonym-stream-symbol s)) new))

(defmethod stream-position ((s synonym-stream) &optional new)
  (stream-position (symbol-value (synonym-stream-symbol s)) new))

(defun make-synonym-stream (symbol)
  (make-instance 'synonym-stream :symbol (require-type symbol 'symbol)))

;;;
(defclass composite-stream-mixin ()
    ((open-p :initform t)))

(defmethod close :after ((stream composite-stream-mixin) &key abort)
  (declare (ignore abort))
  (with-slots (open-p) stream
    (setq open-p nil)))

(defmethod open-stream-p ((stream composite-stream-mixin))
  (slot-value stream 'open-p))


;;; Two-way streams.
(defclass two-way-stream (composite-stream-mixin fundamental-input-stream fundamental-output-stream)
    ((input-stream :initarg :input-stream :accessor two-way-stream-input-stream)
     (output-stream :initarg :output-stream :accessor two-way-stream-output-stream)))

(defmethod stream-eof-transient-p ((stream two-way-stream))
  (stream-eof-transient-p (two-way-stream-input-stream stream)))

(defmethod print-object ((s two-way-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (format out "input ~s, output ~s" 
            (two-way-stream-input-stream s)
            (two-way-stream-output-stream s))))

(macrolet ((two-way-input-method (name &rest args)
             (let* ((stream (make-symbol "STREAM")))
               `(defmethod ,name ((,stream two-way-stream) ,@args)
                 (,name (two-way-stream-input-stream ,stream) ,@args))))
           (two-way-output-method (name &rest args)
             (let* ((stream (make-symbol "STREAM")))
               `(defmethod ,name ((,stream two-way-stream) ,@args)
                 (,name (two-way-stream-output-stream ,stream) ,@args)))))
  (two-way-input-method stream-read-char)
  (two-way-input-method stream-read-byte)
  (two-way-input-method stream-unread-char c)
  (two-way-input-method stream-read-char-no-hang)
  (two-way-input-method stream-peek-char)
  (two-way-input-method stream-listen)
  (two-way-input-method stream-eofp)
  (two-way-input-method stream-clear-input)
  (two-way-input-method stream-read-line)
  (two-way-input-method stream-read-list l c)
  (two-way-input-method stream-read-vector v start end)
  (two-way-input-method stream-surrounding-characters)
  (two-way-input-method stream-input-timeout)
  (two-way-input-method interactive-stream-p)
  (two-way-output-method stream-write-char c)
  (two-way-output-method stream-write-byte b)
  (two-way-output-method stream-clear-output)
  (two-way-output-method stream-line-column)
  (two-way-output-method stream-line-length)
  (two-way-output-method stream-set-column new)
  (two-way-output-method stream-advance-to-column new)
  (two-way-output-method stream-start-line-p)
  (two-way-output-method stream-fresh-line)
  (two-way-output-method stream-terpri)
  (two-way-output-method stream-force-output)
  (two-way-output-method stream-finish-output)
  (two-way-output-method stream-write-list l c)
  (two-way-output-method stream-write-vector v start end)
  (two-way-output-method stream-output-timeout)
  (two-way-output-method stream-deadline))

(defmethod (setf stream-input-timeout) (new (s two-way-stream))
  (setf (stream-input-timeout (two-way-stream-input-stream s)) new))

(defmethod (setf stream-output-timeout) (new (s two-way-stream))
  (setf (stream-output-timeout (two-way-stream-output-stream s)) new))

(defmethod (setf stream-deadline) (new (s two-way-stream))
  (setf (stream-deadline (two-way-stream-output-stream s)) new))

(defmethod stream-device ((s two-way-stream) direction)
  (case direction
    (:input (stream-device (two-way-stream-input-stream s) direction))
    (:output (stream-device (two-way-stream-output-stream s) direction))))
    
(defmethod stream-write-string ((s two-way-stream) string &optional (start 0) end)
  (stream-write-string (two-way-stream-output-stream s) string start end))

(defmethod stream-element-type ((s two-way-stream))
  (let* ((in-type (stream-element-type (two-way-stream-input-stream s)))
         (out-type (stream-element-type (two-way-stream-output-stream s))))
    (if (equal in-type out-type)
      in-type
      `(and ,in-type ,out-type))))

(defun make-two-way-stream (in out)
  "Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM."
  (unless (input-stream-p in)
    (require-type in 'input-stream))
  (unless (output-stream-p out)
    (require-type out 'output-stream))
  (make-instance 'two-way-stream :input-stream in :output-stream out))

;;; This is intended for use with things like *TERMINAL-IO*, where the
;;; OS echoes interactive input.  Whenever we read a character from
;;; the underlying input-stream of such a stream, we need to update
;;; our notion of the underlying output-stream's STREAM-LINE-COLUMN.

(defclass echoing-two-way-stream (two-way-stream)
    ())

(defmethod stream-read-char ((s echoing-two-way-stream))
  (let* ((out (two-way-stream-output-stream s))
         (in (two-way-stream-input-stream s)))
    (force-output out)
    (let* ((ch (stream-read-char in)))
      (unless (eq ch :eof)
        (if (eq ch #\newline)
          (stream-set-column out 0)
          (let* ((cur (stream-line-column out)))
            (when cur
              (stream-set-column out (1+ (the fixnum cur)))))))
      ch)))

(defmethod stream-read-line ((s echoing-two-way-stream))
  (let* ((out (two-way-stream-output-stream s)))
    (force-output out)
    (multiple-value-bind (string eof)
        (call-next-method)
      (unless eof
        (stream-set-column out 0))
      (values string eof))))

(defun make-echoing-two-way-stream (in out)
  (make-instance 'echoing-two-way-stream :input-stream in :output-stream out))

;;;echo streams

(defclass echo-stream (two-way-stream)
    ((did-untyi :initform nil)))

(defmethod echo-stream-input-stream ((s echo-stream))
  (two-way-stream-input-stream s))

(defmethod echo-stream-output-stream ((s echo-stream))
  (two-way-stream-output-stream s))

(defmethod stream-read-char ((s echo-stream))
  (let* ((char (stream-read-char (echo-stream-input-stream s))))
    (unless (eq char :eof)
      (if (slot-value s 'did-untyi)
        (setf (slot-value s 'did-untyi) nil)
        (stream-write-char (echo-stream-output-stream s) char)))
    char))

(defmethod stream-unread-char ((s echo-stream) c)
  (call-next-method s c)
  (setf (slot-value s 'did-untyi) c))

(defmethod stream-read-char-no-hang ((s echo-stream))
  (let* ((char (stream-read-char-no-hang (echo-stream-input-stream s))))
    (unless (eq char :eof)
      (if (slot-value s 'did-untyi)
        (setf (slot-value s 'did-untyi) nil)
        (stream-write-char (echo-stream-output-stream s) char)))
    char))

(defmethod stream-clear-input ((s echo-stream))
  (call-next-method)
  (setf (slot-value s 'did-untyi) nil))

(defmethod stream-read-byte ((s echo-stream))
  (let* ((byte (stream-read-byte (echo-stream-input-stream s))))
    (unless (eq byte :eof)
      (stream-write-byte (echo-stream-output-stream s) byte))
    byte))

(defmethod stream-read-line ((s echo-stream))
  (generic-read-line s))

(defmethod stream-read-vector ((s echo-stream) vector start end)
  (if (subtypep (stream-element-type s) 'character)
      (generic-character-read-vector s vector start end)
    (generic-binary-read-vector s vector start end)))

(defun make-echo-stream (input-stream output-stream)
  "Return a bidirectional stream which gets its input from INPUT-STREAM and
   sends its output to OUTPUT-STREAM. In addition, all input is echoed to
   the output stream."
  (make-instance 'echo-stream
                 :input-stream input-stream
                 :output-stream output-stream))

;;;concatenated-streams

(defclass concatenated-stream (composite-stream-mixin fundamental-input-stream)
    ((streams :initarg :streams :accessor concatenated-stream-streams)))


(defun concatenated-stream-current-input-stream (s)
  (car (concatenated-stream-streams s)))

(defun concatenated-stream-next-input-stream (s)
  (setf (concatenated-stream-streams s)
	(cdr (concatenated-stream-streams s)))
  (concatenated-stream-current-input-stream s))

(defmethod stream-element-type ((s concatenated-stream))
  (let* ((c (concatenated-stream-current-input-stream s)))
    (if c
      (stream-element-type c)
      nil)))



(defmethod stream-read-char ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
	   (concatenated-stream-next-input-stream s)))
       ((null c) :eof)
    (let* ((ch (stream-read-char c)))
      (unless (eq ch :eof)
	(return ch)))))

(defmethod stream-read-char-no-hang ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
	   (concatenated-stream-next-input-stream s)))
       ((null c) :eof)
    (let* ((ch (stream-read-char-no-hang c)))
      (unless (eq ch :eof)
	(return ch)))))

(defmethod stream-read-byte ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
	   (concatenated-stream-next-input-stream s)))
       ((null c) :eof)
    (let* ((b (stream-read-byte c)))
      (unless (eq b :eof)
	(return b)))))

(defmethod stream-peek-char ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
       (concatenated-stream-next-input-stream s)))
       ((null c) :eof)
    (let* ((ch (stream-peek-char c)))
      (unless (eq ch :eof)
        (return ch)))))

(defmethod stream-read-line ((s concatenated-stream))
  (generic-read-line s))

(defmethod stream-read-list ((s concatenated-stream) list count)
  (generic-character-read-list s list count))

(defmethod stream-read-vector ((s concatenated-stream) vector start end)
  (if (subtypep (stream-element-type s) 'character)
      (generic-character-read-vector s vector start end)
    (generic-binary-read-vector s vector start end)))

(defmethod stream-unread-char ((s concatenated-stream) char)
  (let* ((c (concatenated-stream-current-input-stream s)))
    (if c
      (stream-unread-char c char))))

(defmethod stream-listen ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
	   (concatenated-stream-next-input-stream s)))
       ((null c))
    (cond ((stream-listen c)     (return t))
          ((not (stream-eofp c)) (return nil)))))

(defmethod stream-eofp ((s concatenated-stream))
  (do* ((c (concatenated-stream-current-input-stream s)
	   (concatenated-stream-next-input-stream s)))
       ((null c) t)
    (unless (stream-eofp c)
      (return nil))))

(defmethod stream-clear-input ((s concatenated-stream))
  (let* ((c (concatenated-stream-current-input-stream s)))
    (when c (stream-clear-input c))))


(defun make-concatenated-stream (&rest streams)
  "Return a stream which takes its input from each of the streams in turn,
   going on to the next at EOF."
  (dolist (s streams (make-instance 'concatenated-stream :streams streams))
    (unless (input-stream-p s)
      (error "~S is not an input stream" s))))

;;;broadcast-streams



(defclass broadcast-stream (fundamental-output-stream)
    ((streams :initarg :streams :reader broadcast-stream-streams)))

(macrolet ((broadcast-method
	       (op (stream &rest others )
                   &optional
                   (args (cons stream others)))
	     (let* ((sub (gensym))
		    (result (gensym)))
               `(defmethod ,op ((,stream broadcast-stream) ,@others)
		 (let* ((,result nil))
		   (dolist (,sub (broadcast-stream-streams ,stream) ,result)
			     (setq ,result (,op ,@(cons sub (cdr args))))))))))
	     (broadcast-method stream-write-char (s c))
	     (broadcast-method stream-write-string
				      (s str &optional (start 0) end)
				      (s str start end))
	     (broadcast-method stream-write-byte (s b))
	     (broadcast-method stream-clear-output (s))
	     (broadcast-method stream-line-column (s))
	     (broadcast-method stream-set-column (s new))
	     (broadcast-method stream-advance-to-column (s new))
	     (broadcast-method stream-start-line-p (s))
	     (broadcast-method stream-terpri (s))
	     (broadcast-method stream-force-output (s))
	     (broadcast-method stream-finish-output (s))
	     (broadcast-method stream-write-list (s l c))
	     (broadcast-method stream-write-vector (s v start end)))

(defun last-broadcast-stream (s)
  (car (last (broadcast-stream-streams s))))

(defmethod stream-fresh-line ((s broadcast-stream))
  (let* ((did-output-newline nil))
    (dolist (sub (broadcast-stream-streams s) did-output-newline)
      (setq did-output-newline (stream-fresh-line sub)))))

(defmethod stream-element-type ((s broadcast-stream))
  (let* ((last (last-broadcast-stream s)))
    (if last
      (stream-element-type last)
      t)))

(defmethod stream-length ((s broadcast-stream) &optional new)
  (unless new
    (let* ((last (last-broadcast-stream s)))
      (if last
	(stream-length last)
	0))))

(defmethod stream-position ((s broadcast-stream) &optional new)
  (unless new
    (let* ((last (last-broadcast-stream s)))
      (if last
	(stream-position last)
	0))))

(defun make-broadcast-stream (&rest streams)
  (dolist (s streams (make-instance 'broadcast-stream :streams streams))
    (unless (output-stream-p s)
      (report-bad-arg s '(satisfies output-stream-p)))))



;;; String streams.
(make-built-in-class 'string-stream 'basic-character-stream)

(defmethod print-object ((s string-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (unless (open-stream-p s)  (format out " ~s" :closed))))


                 

(defstruct (string-stream-ioblock (:include ioblock))
  string)

(defstruct (string-output-stream-ioblock (:include string-stream-ioblock))
  (index 0)
  freelist
  (line-length 80))

(defstatic *string-output-stream-class* (make-built-in-class 'string-output-stream 'string-stream 'basic-character-output-stream))
(defstatic *string-output-stream-class-wrapper* (%class-own-wrapper *string-output-stream-class*))

(defstatic *fill-pointer-string-output-stream-class* (make-built-in-class 'fill-pointer-string-output-stream 'string-output-stream))

(def-standard-initial-binding %string-output-stream-ioblocks% (%cons-pool nil))

(defmethod stream-force-output ((s string-output-stream))
  nil)

(defmethod stream-finish-output ((s string-output-stream))
  nil)

(defmethod stream-clear-output ((s string-output-stream))
  nil)

(defmethod stream-line-length ((s string-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (string-output-stream-ioblock-line-length ioblock)))

(defmethod (setf stream-line-length) (newlen (s string-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (setf (string-output-stream-ioblock-line-length ioblock) newlen)))


;;; Should only be used for a stream whose class is exactly
;;; *string-output-stream-class* 
(defun %close-string-output-stream (stream ioblock)
  (let* ((pool %string-output-stream-ioblocks%))
    (when (and pool
               (eq (basic-stream.wrapper stream)
                   *string-output-stream-class-wrapper*)
               (eq (string-output-stream-ioblock-freelist ioblock) pool))
      (without-interrupts
       (setf (ioblock-stream ioblock) (pool.data pool)
             (pool.data pool) ioblock)))))

;;; If this is the sort of string stream whose ioblock we recycle and
;;; there's a thread-local binding of the variable we use for a freelist,
;;; return the value of that binding.
(defun %string-stream-ioblock-freelist (stream)
  (and stream
       (eq (basic-stream.wrapper stream)
           *string-output-stream-class-wrapper*)
       (let* ((loc (%tcr-binding-location (%current-tcr) '%string-output-stream-ioblocks%)))
         (and loc (%fixnum-ref loc)))))


(defun create-string-output-stream-ioblock (stream string write-char-function write-string-function)
  (let* ((recycled (and stream
                        (eq (basic-stream.wrapper stream)
                            *string-output-stream-class-wrapper*)
                        (without-interrupts
                         (let* ((data (pool.data %string-output-stream-ioblocks%)))
                           (when data
                             (setf (pool.data %string-output-stream-ioblocks%)
                                   (ioblock-stream data)
                                   (ioblock-stream data) stream
                                   (ioblock-device data) -1
                                   (ioblock-charpos data) 0
                                   (string-output-stream-ioblock-index data) 0
                                   (string-output-stream-ioblock-line-length data) 80))
                           data)))))
    (or recycled
        (make-string-output-stream-ioblock :stream stream
                                           :string string
                                           :element-type 'character
                                           :write-char-function write-char-function
                                           :write-char-when-locked-function write-char-function
                                           :write-simple-string-function write-string-function
                                           :force-output-function #'false
                                           :freelist (%string-stream-ioblock-freelist stream)
                                           :close-function #'%close-string-output-stream
                                           :device -1))))
                        


(defun %%make-string-output-stream (class string write-char-function write-string-function)
  (let* ((stream (gvector :basic-stream (%class.own-wrapper class)
                          (logior (ash 1 basic-stream-flag.open-character)
                                  (ash 1 basic-stream-flag.open-output))
                          nil
                          nil))
         (ioblock (create-string-output-stream-ioblock stream string write-char-function write-string-function)))
      (setf (basic-stream.state stream) ioblock)
      stream))

(declaim (inline %string-push-extend))
(defun %string-push-extend (char string)
  (let* ((fill (%svref string target::vectorH.logsize-cell))
         (size (%svref string target::vectorH.physsize-cell)))
    (declare (fixnum fill size))
    (if (< fill size)
      (multiple-value-bind (data offset) (array-data-and-offset string)
        (declare (simple-string data) (fixnum offset))
        (setf (schar data (the fixnum (+ offset fill))) char
              (%svref string target::vectorH.logsize-cell) (the fixnum (1+ fill))))
      (vector-push-extend char string))))
              

(defun fill-pointer-string-output-stream-ioblock-write-char (ioblock char)
  ;; can do better (maybe much better) than VECTOR-PUSH-EXTEND here.
  (if (eql char #\Newline)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (%string-push-extend char (string-stream-ioblock-string ioblock)))

(defun fill-pointer-string-output-stream-ioblock-write-simple-string (ioblock string start-char num-chars)
  (let* ((end (+ start-char num-chars))
         (nlpos (position #\Newline string :start start-char :end end :from-end t)))
    (if nlpos
      (setf (ioblock-charpos ioblock) (- end nlpos))
      (incf (ioblock-charpos ioblock) num-chars))
    (let* ((out (string-stream-ioblock-string ioblock)))
      (do* ((n 0 (1+ n))
            (i start-char (1+ i)))
           ((= n num-chars) num-chars)
        (%string-push-extend (schar string i) out)))))

(defmethod stream-position ((s fill-pointer-string-output-stream) &optional newpos)
  (let* ((string (string-stream-string s)))
    (if newpos
      (setf (fill-pointer string) newpos)
      (fill-pointer string))))

;;; If the stream's string is adjustable, it doesn't really have a meaningful
;;; "maximum size".
(defmethod stream-length ((s string-output-stream) &optional newlen)
  (unless newlen
    (array-total-size (string-stream-string s))))

;;; This creates a FILL-POINTER-STRING-OUTPUT-STREAM.
(defun %make-string-output-stream (string)
  (unless (and (typep string 'string)
               (array-has-fill-pointer-p string))
    (error "~S must be a string with a fill pointer." string))
  (%%make-string-output-stream *fill-pointer-string-output-stream-class* string 'fill-pointer-string-output-stream-ioblock-write-char 'fill-pointer-string-output-stream-ioblock-write-simple-string))

(defun string-output-stream-ioblock-write-char (ioblock char)
  (let* ((string (string-output-stream-ioblock-string ioblock))
         (index (string-output-stream-ioblock-index ioblock))
         (len (length string)))
    (declare (simple-string string)
             (fixnum index len))
  (if (eql char #\Newline)
    (setf (ioblock-charpos ioblock) 0)
    (incf (ioblock-charpos ioblock)))
  (if (= index len)
      (let* ((newlen (if (zerop len) 20 (+ len len)))      ;non-zero !
             (new (make-string newlen)))
        (%copy-ivector-to-ivector string 0 new 0 (the fixnum (ash len 2)))
        (setq string new)
        (setf (string-output-stream-ioblock-string ioblock) new)))
    (setf (string-output-stream-ioblock-index ioblock) (the fixnum (1+ index))
          (schar string index) char)))

(defun string-output-stream-ioblock-write-simple-string (ioblock string start-char num-chars)
  (declare (simple-string string)
           (fixnum start-char num-chars)
           (optimize (speed 3) (safety 0)))
  (let* ((out (string-output-stream-ioblock-string ioblock))
         (index (string-output-stream-ioblock-index ioblock))
         (len (length out))
         (need (+ index num-chars)))
    (declare (simple-string out)
             (fixnum index len need))
    (if (< len need)
      (let* ((newlen (+ need need))
             (new (make-string newlen)))
        (declare (fixnum newlen) (simple-string new))
        (dotimes (i len)
          (setf (schar new i) (schar out i)))
        (setq out new)
        (setf (string-output-stream-ioblock-string ioblock) new)))
    (do* ((src start-char (1+ src))
          (dest index (1+ dest))
          (nlpos nil)
          (end (+ start-char num-chars)))
         ((= src end)
          (setf (string-output-stream-ioblock-index ioblock) need)
          (if nlpos
            (setf (ioblock-charpos ioblock) (the fixnum (- end (the fixnum nlpos))))
            (incf (ioblock-charpos ioblock) num-chars))
          num-chars)
      (declare (fixnum src dest end))
      (let* ((char (schar string src)))
        (if (eql char #\Newline)
          (setq nlpos (the fixnum (1+ src))))
        (setf (schar out dest) char)))))


(defmethod stream-position ((stream string-output-stream) &optional newpos)
  (let* ((ioblock (basic-stream-ioblock stream)))
    (if (null newpos)
      (string-output-stream-ioblock-index ioblock)
      (if (and (typep newpos 'fixnum)
               (>= (the fixnum newpos) 0)
               (<= (the fixnum newpos) (length (string-output-stream-ioblock-string ioblock))))
        (setf (string-output-stream-ioblock-index ioblock) newpos)))))

(defun make-simple-string-output-stream ()
  ;; There's a good chance that we'll get a recycled ioblock
  ;; that already has a string; if not, we defer actually
  ;; creating a usable string until write-char
  (%%make-string-output-stream *string-output-stream-class*
                               ""
                               'string-output-stream-ioblock-write-char
                               'string-output-stream-ioblock-write-simple-string))

(defun make-string-output-stream (&key (element-type 'character element-type-p))
  "Return an output stream which will accumulate all output given it for
   the benefit of the function GET-OUTPUT-STREAM-STRING."
  (when (and element-type-p
             (not (member element-type '(base-character character
                                         standard-char))))
    (unless (subtypep element-type 'character)
      (error "~S argument ~S is not a subtype of ~S."
             :element-type element-type 'character)))
  (make-simple-string-output-stream))


;;;"Bounded" string output streams.
(defstatic *truncating-string-output-stream-class* (make-built-in-class 'truncating-string-stream 'string-output-stream))

(defun truncating-string-output-stream-ioblock-write-char (ioblock char)
  (let* ((stream (ioblock-stream ioblock))
         (string (string-output-stream-ioblock-string ioblock))
         (index (string-output-stream-ioblock-index ioblock)))
    (declare (fixnum index) (simple-string string))
    (if (< index (the fixnum (length string)))
      (progn
        (setf (schar string index) char
              (string-output-stream-ioblock-index ioblock) (the fixnum (1+ index)))
        (if (eql char #\Newline)
          (setf (ioblock-charpos ioblock) 0)
          (incf (ioblock-charpos ioblock))))
      (setf (getf (basic-stream.info stream) :truncated) t))))

(defun truncating-string-output-stream-ioblock-write-simple-string (ioblock string start-char num-chars)
  (let* ((stream (ioblock-stream ioblock)))
  (do* ((n 0 (1+ n))
        (i start-char (1+ i)))
       ((= n num-chars) num-chars)
    (truncating-string-output-stream-ioblock-write-char ioblock (schar string i))
    (if (getf (basic-stream.info stream) :truncated)
      (return n)))))

(defun truncating-string-output-stream-truncated-p (stream)
  (getf (basic-stream.info stream) :truncated))

(defun make-truncating-string-stream (len)
  (%%make-string-output-stream *truncating-string-output-stream-class*
                               (make-string len)
                               'truncating-string-output-stream-ioblock-write-char
                               'truncating-string-output-stream-ioblock-write-simple-string))
                               

;;;One way to indent on newlines:

(defstatic *indenting-string-output-stream-class* (make-built-in-class 'indenting-string-output-stream 'string-output-stream))
(defstatic *indenting-string-output-stream-class-wrapper* (%class-own-wrapper *indenting-string-output-stream-class*))


(defun indenting-string-stream-ioblock-write-char (ioblock c)
  (string-output-stream-ioblock-write-char ioblock c)
  (if (eql c #\newline)
    (let* ((stream (ioblock-stream ioblock))
           (info (basic-stream.info stream))
           (indent (getf info 'indent))
           (prefixlen 0)
           (prefixchar (getf info 'prefixchar)))
      (when prefixchar
        (if (typep prefixchar 'character)
          (progn
            (setq prefixlen 1)
            (string-output-stream-ioblock-write-char ioblock prefixchar))
          (dotimes (i (setq prefixlen (length prefixchar)))
            (string-output-stream-ioblock-write-char ioblock (schar prefixchar i)))))
      (when indent
        (dotimes (i (the fixnum (- indent prefixlen)))
          (string-output-stream-ioblock-write-char ioblock #\Space)))))
  c)

(defun indenting-string-stream-ioblock-write-simple-string (ioblock string start-char num-chars)
  (do* ((n 0 (1+ n))
        (i start-char (1+ i)))
       ((= n num-chars) num-chars)
    (indenting-string-stream-ioblock-write-char ioblock (schar string i))))

(defun make-indenting-string-output-stream (prefixchar indent)
  (let* ((stream (%%make-string-output-stream
                   *indenting-string-output-stream-class*
                  (make-string 10)
                  'indenting-string-stream-ioblock-write-char
                  'indenting-string-stream-ioblock-write-simple-string)))
    (setf (getf (basic-stream.info stream) 'indent) indent
          (getf (basic-stream.info stream) 'prefixchar) prefixchar)
    stream))

(defun (setf indenting-string-output-stream-indent) (new stream)
  (if (and (typep stream 'basic-stream)
           (eq (basic-stream.wrapper stream) *indenting-string-output-stream-class-wrapper*))
    (setf (getf (basic-stream.info stream) 'indent) new)
    (report-bad-arg stream 'indenting-string-output-stream)))


(defun get-output-stream-string (s)
 (let* ((class (if (typep s 'basic-stream) (%wrapper-class (basic-stream.wrapper s)))))
    (or (eq class *string-output-stream-class*)
        (eq class *truncating-string-output-stream-class*)
        (eq class *indenting-string-output-stream-class*)
        (eq class *fill-pointer-string-output-stream-class*)
        (report-bad-arg s 'string-output-stream))
    (let* ((ioblock (basic-stream-ioblock s))
           (string (string-stream-ioblock-string ioblock)))
      (if (eq class *fill-pointer-string-output-stream-class*)
        (prog1 (ensure-simple-string string)
          (setf (fill-pointer string) 0))
        (let* ((index (string-output-stream-ioblock-index ioblock))
               (result (make-string index)))
          (declare (fixnum index))
          (%copy-ivector-to-ivector string 0 result 0 (the fixnum (ash index 2)))
          (setf (string-output-stream-ioblock-index ioblock) 0)
          result)))))

;;; String input streams.
(defstatic *string-input-stream-class* (make-built-in-class 'string-input-stream 'string-stream 'basic-character-input-stream))
(defstatic *string-input-stream-class-wrapper* (%class-own-wrapper *string-input-stream-class*))
(defstruct (string-input-stream-ioblock (:include string-stream-ioblock))
  (start 0)
  index
  end
  (offset 0))



(defun string-input-stream-index (s)
  (if (and (typep s 'basic-stream)
           (eq *string-input-stream-class-wrapper* (basic-stream.wrapper s)))
    (let* ((ioblock (basic-stream-ioblock s)))
      (- (string-input-stream-ioblock-index ioblock)
         (string-input-stream-ioblock-offset ioblock)))
    (report-bad-arg s 'string-input-stream)))


(defmethod stream-surrounding-characters ((s string-input-stream))
  (let* ((ioblock (basic-stream.state s)))
    (when ioblock
      (let* ((start (string-input-stream-ioblock-start ioblock))
             (idx (string-input-stream-ioblock-index ioblock))
             (end (string-input-stream-ioblock-end ioblock))
             (string (string-stream-ioblock-string ioblock)))
        (subseq string (max (- idx 10) start) (min (+ idx 10) end))))))
    

(defmethod stream-position ((s string-input-stream) &optional newpos)
  (let* ((ioblock (basic-stream-ioblock s))
         (start (string-input-stream-ioblock-start ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum end idx start))
    (if newpos
      (let* ((limit (- end start)))
        (declare (fixnum limit))
        (if (and (typep newpos 'fixnum)
                 (>= (the fixnum newpos) 0)
                 (<= (the fixnum newpos) limit))
          (progn
            (setf (string-input-stream-ioblock-index ioblock)
                  (the fixnum (+ start (the fixnum newpos))))
            newpos)
          (report-bad-arg newpos `(integer 0 ,limit))))
      (the fixnum (- idx start)))))
    
  

(defun string-input-stream-ioblock-read-char (ioblock)
  (let* ((string (string-stream-ioblock-string ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx end)
             (simple-string string))
    (if (< idx end)
      (progn (setf (string-input-stream-ioblock-index ioblock)
                   (the fixnum (1+ idx)))
             (schar string idx))
      :eof)))

(defun string-input-stream-ioblock-read-line (ioblock)
  (let* ((string (string-stream-ioblock-string ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx end)
             (simple-string string))
    (if (>= idx end)
      (values "" t)
      (let* ((pos (position #\Newline string :start idx :end end)))
        (if pos
          (locally (declare (type index pos))
            (let* ((new (make-string (the fixnum (- pos idx)))))
              (declare (simple-base-string new))
              (setf (string-input-stream-ioblock-index ioblock)
                    (the fixnum (1+ pos)))
              (do* ((src idx (1+ src))
                    (dest 0 (1+ dest)))
                   ((= src pos) (values new nil))
                (declare (fixnum src dest))
                (setf (schar new dest) (schar string src)))))
          (let* ((new (make-string (the fixnum (- end idx)))))
            (declare (simple-base-string new))
              (setf (string-input-stream-ioblock-index ioblock) end)
              (do* ((src idx (1+ src))
                    (dest 0 (1+ dest)))
                   ((= src end) (values new t))
                (declare (fixnum src dest))
                (setf (schar new dest) (schar string src)))))))))


(defun string-input-stream-ioblock-peek-char (ioblock)
  (let* ((string (string-stream-ioblock-string ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx end)
             (simple-string string))
    (if (< idx end)
      (schar string idx)
      :eof)))

(defun string-input-stream-ioblock-unread-char (ioblock char)
  (let* ((string (string-stream-ioblock-string ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (start (string-input-stream-ioblock-start ioblock)))
    (declare (fixnum idx start)
             (simple-string string))
    (unless (> idx start)
      (error "Nothing has been read from ~s yet." (ioblock-stream ioblock)))
    (decf idx)
    (unless (eq char (schar string idx))
      (error "~a was not the last character read from ~s" char (ioblock-stream ioblock)))
    (setf (string-input-stream-ioblock-index ioblock) idx)
    char))
  
  
(defmethod stream-length ((s string-input-stream) &optional new)
  (unless new
    (let ((ioblock (basic-stream-ioblock s)))
      (%i- (string-input-stream-ioblock-end ioblock)
	   (string-input-stream-ioblock-start ioblock)))))

(defmethod stream-eofp ((s string-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx end))
    (>= idx end)))

(defmethod stream-listen ((s string-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (idx (string-input-stream-ioblock-index ioblock))
         (end (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx end))
    (< idx end)))

(defmethod stream-clear-input ((s string-input-stream))
  (basic-stream-ioblock s)
  nil)

(defun string-input-stream-character-read-vector (ioblock vector start end)
  (let* ((string (string-stream-ioblock-string ioblock))
         (idx (string-input-stream-ioblock-index ioblock))
         (limit (string-input-stream-ioblock-end ioblock)))
    (declare (fixnum idx limit))
    (do* ((i start (1+ i)))
         ((= i end) (setf (string-input-stream-ioblock-index ioblock) idx) end)
      (declare (fixnum i))
      (if (< idx limit)
        (setf (uvref vector i) (schar string idx)
              idx (1+ idx))
        (progn
          (setf (string-input-stream-ioblock-index ioblock) idx)
          (return i))))))
         


(defun make-string-input-stream (string &optional (start 0)
                                        (end nil))
  "Return an input stream which will supply the characters of STRING between
  START and END in order."
  (setq end (check-sequence-bounds string start end))
  (multiple-value-bind (data offset) (array-data-and-offset string)
    (unless (typep data 'simple-base-string)
      (report-bad-arg string 'string))
    (incf start offset)
    (incf end offset)
    (let* ((stream (make-basic-stream-instance
                    *string-input-stream-class*
                    :element-type 'character))
           (ioblock (make-string-input-stream-ioblock
                     :stream stream
                     :offset offset
                     :string data
                     :start start
                     :index start
                     :end end
                     :read-char-function 'string-input-stream-ioblock-read-char
                     :read-char-when-locked-function 'string-input-stream-ioblock-read-char
                     :peek-char-function 'string-input-stream-ioblock-peek-char
                     :character-read-vector-function 'string-input-stream-character-read-vector
                     :close-function #'false
                     :unread-char-function 'string-input-stream-ioblock-unread-char
                     :read-line-function 'string-input-stream-ioblock-read-line
                     )))
      (setf (basic-stream.state stream) ioblock)
      stream)))

(defmethod stream-read-char-no-hang ((s string-input-stream))
  (stream-read-char s))

(defun string-stream-string (s)
  (let* ((class (if (typep s 'basic-stream) (%wrapper-class (basic-stream.wrapper s)))))
    (or (eq class *string-output-stream-class*)
        (eq class *truncating-string-output-stream-class*)
        (eq class *indenting-string-output-stream-class*)
        (report-bad-arg s 'string-output-stream)))
  (string-stream-ioblock-string (basic-stream-ioblock s)))



;;; A mixin to be used with FUNDAMENTAL-STREAMs that want to use ioblocks
;;; to buffer I/O.

(defclass buffered-stream-mixin ()
  ((ioblock :reader %stream-ioblock :writer (setf stream-ioblock) :initform nil)))

(defmethod open-stream-p ((s buffered-stream-mixin))
  (with-slots (ioblock) s
    (not (null ioblock))))

(declaim (inline stream-ioblock))

(defun stream-ioblock (stream error-if-nil)
  (or (if (typep stream 'basic-stream)
        (basic-stream.state stream)
        (%stream-ioblock stream))
      (when error-if-nil
        (stream-is-closed stream))))

(defmethod stream-device ((s buffered-stream-mixin) direction)
  (declare (ignore direction))
  (let* ((ioblock (stream-ioblock s nil)))
    (and ioblock (ioblock-device ioblock))))

(defmethod stream-device ((s basic-stream) direction)
  (declare (ignore direction))
  (let* ((ioblock (basic-stream.state s)))
    (and ioblock (ioblock-device ioblock))))
  
(defmethod stream-element-type ((s buffered-stream-mixin))
  (ioblock-element-type (stream-ioblock s t)))

(defmethod stream-element-type ((s basic-stream))
  (ioblock-element-type (basic-stream-ioblock s)))


(defmethod stream-create-ioblock ((stream buffered-stream-mixin) &rest args &key)
  (declare (dynamic-extent args))
  (apply #'make-ioblock :stream stream args))

(defmethod stream-owner ((stream stream))
  )

(defmethod stream-owner ((stream buffered-stream-mixin))
  (let* ((ioblock (stream-ioblock stream nil)))
    (and ioblock (let* ((owner (ioblock-owner ioblock)))
                   (unless (eql owner 0) owner)))))

(defmethod stream-owner ((stream basic-stream))
  (let* ((ioblock (basic-stream.state stream)))
    (and ioblock (let* ((owner (ioblock-owner ioblock)))
                   (unless (eql owner 0) owner)))))


(defclass buffered-input-stream-mixin
          (buffered-stream-mixin fundamental-input-stream)
  ())

(defclass buffered-output-stream-mixin
          (buffered-stream-mixin fundamental-output-stream)
  ())

(defclass buffered-io-stream-mixin
          (buffered-input-stream-mixin buffered-output-stream-mixin)
  ())

(defclass buffered-character-input-stream-mixin
          (buffered-input-stream-mixin fundamental-character-input-stream)
  ())

(defclass buffered-character-output-stream-mixin
          (buffered-output-stream-mixin fundamental-character-output-stream)
  ())

(defclass buffered-character-io-stream-mixin
          (buffered-character-input-stream-mixin buffered-character-output-stream-mixin)
  ())

(defclass buffered-binary-input-stream-mixin
          (buffered-input-stream-mixin fundamental-binary-input-stream)
  ())

(defclass buffered-binary-output-stream-mixin
          (buffered-output-stream-mixin fundamental-binary-output-stream)
  ())

(defclass buffered-binary-io-stream-mixin
          (buffered-binary-input-stream-mixin
           buffered-binary-output-stream-mixin)
  ())

(defmethod close :after ((stream buffered-stream-mixin) &key abort)
  (declare (ignore abort))
  (let* ((ioblock (stream-ioblock stream nil)))
    (when ioblock
      (%ioblock-close ioblock))))

(defmethod close :before ((stream buffered-output-stream-mixin) &key abort)
  (unless abort
    (when (open-stream-p stream)
      (stream-force-output stream))))

(defmethod close-for-termination ((stream buffered-output-stream-mixin) abort)
  ;; This method should only be invoked via the termination mechanism,
  ;; so it can safely assume that there's no contention for the stream.
  (let* ((ioblock (stream-ioblock stream nil)))
    (when ioblock (setf (ioblock-owner ioblock) nil)))
  (close stream :abort abort))


(defmethod interactive-stream-p ((stream buffered-stream-mixin))
  (let* ((ioblock (stream-ioblock stream nil)))
    (and ioblock (ioblock-interactive ioblock))))

(defmethod interactive-stream-p ((stream basic-stream))
  (let* ((ioblock (basic-stream.state stream)))
    (and ioblock (ioblock-interactive ioblock))))


(defmethod close :after ((stream basic-stream) &key abort)
  (declare (ignore abort))
  (let* ((ioblock (basic-stream.state stream)))
    (when ioblock
      (%ioblock-close ioblock))))

(defmethod close-for-termination  ((stream basic-stream) abort)
  (let* ((ioblock (basic-stream.state stream)))
    (when ioblock (setf (ioblock-owner ioblock) nil)))
  (close stream :abort abort))

  

(defmethod open-stream-p ((stream basic-stream))
  (not (null (basic-stream.state stream))))

(defmethod close :before ((stream basic-output-stream) &key abort)
  (unless abort
    (when (open-stream-p stream)
      (stream-force-output stream))))

(defmethod stream-surrounding-characters ((stream buffered-character-input-stream-mixin))
    (let* ((ioblock (stream-ioblock stream nil)))
      (and ioblock (%ioblock-surrounding-characters ioblock))))

(defmethod stream-surrounding-characters ((stream basic-character-input-stream))
    (let* ((ioblock (basic-stream.state stream)))
      (and ioblock (%ioblock-surrounding-characters ioblock))))


#|
(defgeneric ioblock-advance (stream ioblock readp)
  (:documentation
   "Called when the current input buffer is empty (or non-existent).
    readp true means the caller expects to return a byte now.
    Return value is meaningless unless readp is true, in which case
    it means that there is input ready"))

(defgeneric ioblock-listen (stream ioblock)
  (:documentation
   "Called in response to stream-listen when the current
    input buffer is empty.
    Returns a boolean"))

(defgeneric ioblock-eofp (stream ioblock)
  (:documentation
   "Called in response to stream-eofp when the input buffer is empty.
    Returns a boolean."))

(defgeneric ioblock-force-output (stream ioblock count finish-p)
  (:documentation
   "Called in response to stream-force-output.
    Write count bytes from ioblock-outbuf.
    Finish the I/O if finish-p is true."))

(defgeneric ioblock-close (stream ioblock)
  (:documentation
   "May free some resources associated with the ioblock."))
|#

(defmethod ioblock-close ((stream buffered-stream-mixin) ioblock)
  (declare (ignore ioblock)))

(defmethod ioblock-force-output ((stream buffered-output-stream-mixin)
                                   ioblock
                                   count
                                   finish-p)
  (declare (ignore ioblock count finish-p)))




(defmethod stream-read-char ((stream buffered-character-input-stream-mixin))
  (let* ((ioblock (stream-ioblock stream t)))
    (funcall (ioblock-read-char-function ioblock) ioblock)))

(defmethod stream-read-char-no-hang ((stream buffered-character-input-stream-mixin))
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (%ioblock-tyi-no-hang ioblock)))

(defmethod stream-peek-char ((stream buffered-character-input-stream-mixin))
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (values
        (%ioblock-peek-char ioblock))))

(defmethod stream-clear-input ((stream buffered-input-stream-mixin))
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (values
     (%ioblock-clear-input ioblock))))

(defmethod stream-unread-char ((stream buffered-character-input-stream-mixin) char)
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (funcall (ioblock-unread-char-function ioblock) ioblock char))
  char)

(defmethod stream-read-byte ((stream buffered-binary-input-stream-mixin))
  (let* ((ioblock (stream-ioblock stream t)))
    (funcall (ioblock-read-byte-function ioblock) ioblock)))

(defmethod stream-read-byte ((stream basic-binary-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (funcall (ioblock-read-byte-function ioblock) ioblock)))

(defmethod stream-eofp ((stream buffered-input-stream-mixin))
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (values
     (%ioblock-eofp ioblock))))

(defmethod stream-eofp ((stream basic-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (%ioblock-eofp ioblock))))

(defmethod stream-listen ((stream buffered-input-stream-mixin))
  (with-stream-ioblock-input (ioblock stream :speedy t)
    (values
     (%ioblock-listen ioblock))))

(defmethod stream-listen ((stream basic-input-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (ioblock)
      (values
       (%ioblock-listen ioblock)))))


(defmethod stream-write-byte ((stream buffered-binary-output-stream-mixin)
                              byte)
  (let* ((ioblock (stream-ioblock stream t)))
    (funcall (ioblock-write-byte-function ioblock) ioblock byte)))

(defmethod stream-write-byte ((stream basic-binary-output-stream) byte)
  (let* ((ioblock (basic-stream-ioblock stream)))
    (funcall (ioblock-write-byte-function ioblock) ioblock byte)))

(defmethod stream-write-char ((stream buffered-character-output-stream-mixin) char)
  (let* ((ioblock (stream-ioblock stream t)))
    (funcall (ioblock-write-char-function ioblock) ioblock char)))

(defmethod stream-write-char ((stream basic-character-output-stream) char)
  (let* ((ioblock (basic-stream-ioblock stream)))
    (funcall (ioblock-write-char-function ioblock) ioblock char)))


(defmethod stream-clear-output ((stream buffered-output-stream-mixin))
  (with-stream-ioblock-output (ioblock stream :speedy t)
    (%ioblock-clear-output ioblock))
  nil)

(defmethod stream-clear-output ((stream basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (ioblock)
      (%ioblock-clear-output ioblock))
    nil))

(defmethod stream-line-column ((stream buffered-character-output-stream-mixin))
  (let* ((ioblock (stream-ioblock stream nil)))
    (and ioblock (ioblock-charpos ioblock))))

(defmethod stream-line-column ((stream basic-character-output-stream))
  (let* ((ioblock (basic-stream.state stream)))
    (and ioblock (ioblock-charpos ioblock))))



(defmethod stream-set-column ((stream buffered-character-output-stream-mixin)
                              new)
  (let* ((ioblock (stream-ioblock stream nil)))
    (and ioblock (setf (ioblock-charpos ioblock) new))))

(defmethod stream-set-column ((stream basic-character-output-stream)
                              new)
  (let* ((ioblock (basic-stream.state stream)))
    (and ioblock (setf (ioblock-charpos ioblock) new))))

(defmethod stream-force-output ((stream buffered-output-stream-mixin))
  (with-stream-ioblock-output (ioblock stream :speedy t)
    (%ioblock-force-output ioblock nil)
    nil))

(defmethod stream-force-output ((stream basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (ioblock)
      (%ioblock-force-output ioblock nil)
      nil)))

(defmethod maybe-stream-force-output ((stream buffered-output-stream-mixin))
  (with-stream-ioblock-output-maybe (ioblock stream :speedy t)
    (%ioblock-force-output ioblock nil)
    nil))

(defmethod maybe-stream-force-output ((stream basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked-maybe (ioblock)
      (%ioblock-force-output ioblock nil)
      nil)))

(defmethod stream-finish-output ((stream buffered-output-stream-mixin))
  (with-stream-ioblock-output (ioblock stream :speedy t)
    (%ioblock-force-output ioblock t)
    nil))

(defmethod stream-finish-output ((stream basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (ioblock)
      (%ioblock-force-output ioblock t)
      nil)))


  
(defmethod stream-write-string ((stream buffered-character-output-stream-mixin)
				string &optional (start 0 start-p) end)
				
  (with-stream-ioblock-output (ioblock stream :speedy t)
    (if (and (typep string 'simple-string)
	     (not start-p))
      (funcall (ioblock-write-simple-string-function ioblock)
                   ioblock string 0 (length string))
      (progn
        (setq end (check-sequence-bounds string start end))
        (locally (declare (fixnum start end))
          (multiple-value-bind (arr offset)
              (if (typep string 'simple-string)
                (values string 0)
                (array-data-and-offset (require-type string 'string)))
            (unless (eql 0 offset)
              (incf start offset)
              (incf end offset))
            (funcall (ioblock-write-simple-string-function ioblock)
                     ioblock arr start (the fixnum (- end start))))))))
  string)

(defmethod stream-write-string ((stream basic-character-output-stream)
				string &optional (start 0 start-p) end)

  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (ioblock) 
      (if (and (typep string 'simple-string)
               (not start-p))
        (values
         (funcall (ioblock-write-simple-string-function ioblock)
                  ioblock string 0 (length string)))
        (progn
          (setq end (check-sequence-bounds string start end))
          (locally (declare (fixnum start end))
            (multiple-value-bind (arr offset)
                (if (typep string 'simple-string)
                  (values string 0)
                  (array-data-and-offset (require-type string 'string)))
              (unless (eql 0 offset)
                (incf start offset)
                (incf end offset))
              (values
                  (funcall (ioblock-write-simple-string-function ioblock)
                           ioblock arr start (the fixnum (- end start))))))))))
  string)


(defmethod stream-write-ivector ((s buffered-output-stream-mixin)
				 iv start length)
  (with-stream-ioblock-output (ioblock s :speedy t)
    (values    
        (%ioblock-out-ivect ioblock iv start length))))

(defmethod stream-write-ivector ((s basic-output-stream)
				 iv start length)
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-output-locked (ioblock)
      (values
          (%ioblock-out-ivect ioblock iv start length)))))


#+bad-idea
(defmethod stream-read-ivector ((s buffered-character-input-stream-mixin)
				iv start nb)
  (with-stream-ioblock-input (ioblock s :speedy t)
    (values
     (%ioblock-character-in-ivect ioblock iv start nb))))

(defmethod stream-read-ivector ((s buffered-binary-input-stream-mixin)
				iv start nb)
  (with-stream-ioblock-input (ioblock s :speedy t)
    (values
     (%ioblock-binary-in-ivect ioblock iv start nb))))


(defmethod stream-write-vector ((stream buffered-character-output-stream-mixin)
				vector start end)
  (declare (fixnum start end))
  (if (not (typep vector 'simple-base-string))
    (call-next-method)
    (with-stream-ioblock-output (ioblock stream :speedy t)
      (let* ((total (- end start)))
	(declare (fixnum total))
        (values
            (funcall (ioblock-write-simple-string-function ioblock)
                     ioblock vector start total))))))

(defmethod stream-write-vector ((stream basic-character-output-stream)
				vector start end)
  (declare (fixnum start end))
  (if (not (typep vector 'simple-base-string))
    (call-next-method)
    (let* ((ioblock (basic-stream-ioblock stream))
           (total (- end start)))
      (declare (fixnum total))
      (with-ioblock-output-locked (ioblock)
        (values
            (funcall (ioblock-write-simple-string-function ioblock)
                     ioblock vector start total))))))

;;; bivalence: we don't actually have a "bivalent stream" class;
;;; all actual (potentially) bivalent streams (sockets) include binary streams
;;; before character streams in their CPLs.  That effectively means that
;;; binary-stream methods for reading and writing sequences have to
;;; handle character I/O in some cases.  That may slow some things down
;;; (at least in theory), but the case where the stream's element-type
;;; matches the sequence's element-type isn't affected.
(defun %ioblock-binary-stream-write-vector (ioblock vector start end)
  (declare (fixnum start end))
  (declare (optimize (safety 3)))
  (let* ((out (ioblock-outbuf ioblock))
         (written 0)
         (total (- end start))
         (buftype (typecode (io-buffer-buffer out))))
    (declare (fixnum buftype written total))
    (if (not (= (the fixnum (typecode vector)) buftype))
      (if (typep vector 'string)
        (funcall (ioblock-write-simple-string-function ioblock)
                 ioblock
                 vector
                 start
                 (- end start))
        (do* ((i start (1+ i))
              (wbf (ioblock-write-byte-when-locked-function ioblock))
              (wcf (ioblock-write-char-when-locked-function ioblock)))
             ((= i end))
          (let ((byte (uvref vector i)))
            (if (characterp byte)
              (funcall wcf ioblock byte)
              (funcall wbf ioblock byte)))))
      (do* ((pos start (+ pos written))
            (left total (- left written)))
           ((= left 0))
        (declare (fixnum pos left))
        (setf (ioblock-dirty ioblock) t)
        (let* ((index (io-buffer-idx out))
               (count (io-buffer-count out))
               (limit (io-buffer-limit out))
               (buf (io-buffer-buffer out))
               (avail (- limit index)))
          (declare (fixnum index avail count limit))
          (cond
            ((= (setq written avail) 0)
             (%ioblock-force-output ioblock nil))
            (t
             (if (> written left)
               (setq written left))
             (%copy-ivector-to-ivector
              vector
              (ioblock-elements-to-octets ioblock pos)
              buf
              (ioblock-elements-to-octets ioblock index)
              (ioblock-elements-to-octets ioblock written))
             (setf (ioblock-dirty ioblock) t)
             (incf index written)
             (if (> index count)
               (setf (io-buffer-count out) index))
             (setf (io-buffer-idx out) index)
             (if (= index  limit)
               (%ioblock-force-output ioblock nil)))))))))

(defmethod stream-write-vector ((stream buffered-binary-output-stream-mixin)
				vector start end)
  (with-stream-ioblock-output (ioblock stream :speedy t)
    (%ioblock-binary-stream-write-vector ioblock vector start end)))


(defmethod stream-write-vector ((stream basic-binary-output-stream)
				vector start end)
  (declare (fixnum start end))
  (let* ((ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (ioblock)
      (%ioblock-binary-stream-write-vector ioblock vector start end))))



(defmethod stream-read-vector ((stream basic-binary-input-stream)
			       vector start end)
  (declare (fixnum start end))
  (if (typep vector 'simple-base-string)
    (call-next-method)
    (let* ((ioblock (basic-stream-ioblock stream)))
      (with-ioblock-input-locked (ioblock)
        (values
            (%ioblock-binary-read-vector ioblock vector start end))))))

(defmethod stream-read-vector ((stream buffered-character-input-stream-mixin)
			       vector start end)
  (declare (fixnum start end))
  (if (not (typep vector 'simple-base-string))
    (call-next-method)
    (with-stream-ioblock-input (ioblock stream :speedy t)
      (values
       (funcall (ioblock-character-read-vector-function ioblock)
                ioblock vector start end)))))



(defmethod stream-read-vector ((stream buffered-binary-input-stream-mixin)
			       vector start end)
  (declare (fixnum start end))
  (if (typep vector 'simple-base-string)
    (call-next-method)
    (with-stream-ioblock-input (ioblock stream :speedy t)
      (values
       (%ioblock-binary-read-vector ioblock vector start end)))))



(defloadvar *fd-set-size*
    (ff-call (%kernel-import target::kernel-import-fd-setsize-bytes)
             :unsigned-fullword))

(defun unread-data-available-p (fd)
  (fd-input-available-p fd 0))

;;; Read and discard any available unread input.
(defun %fd-drain-input (fd)
  (%stack-block ((buf 1024))
    (do* ((avail (unread-data-available-p fd) (unread-data-available-p fd)))
	 ((or (null avail) (eql avail 0)))
      (do* ((max (min avail 1024) (min avail 1024)))
	   ((zerop avail))
	(let* ((count (fd-read fd buf max)))
	  (if (< count 0)
	    (return)
	    (decf avail count)))))))

(defun fd-zero (fdset)
  (ff-call (%kernel-import target::kernel-import-do-fd-zero)
           :address fdset
           :void))

(defun fd-set (fd fdset)
  (ff-call (%kernel-import target::kernel-import-do-fd-set)
           :unsigned-fullword fd
           :address fdset
           :void))

(defun fd-clr (fd fdset)
  (ff-call (%kernel-import target::kernel-import-do-fd-clr)
           :unsigned-fullword fd
           :address fdset
           :void))

(defun fd-is-set (fd fdset)
  (not (= 0 (the fixnum (ff-call (%kernel-import target::kernel-import-do-fd-is-set)
                                 :unsigned-fullword fd
                                 :address fdset
                                 :unsigned-fullword)))))

(defun process-input-would-block (fd)
  #+windows-target (declare (ignore fd))
  #+windows-target t
  #-windows-target
  (if (logtest #$O_NONBLOCK (the fixnum (fd-get-flags fd)))
    (process-input-wait fd)
    (- #$ETIMEDOUT)))
    
(defun process-input-wait (fd &optional timeout)
  "Wait until input is available on a given file-descriptor."
  (rlet ((now :timeval))
    (let* ((wait-end 
            (when timeout
              (gettimeofday now)
              (+ (timeval->milliseconds now) timeout))))
      (loop
        (multiple-value-bind (win error)
            (fd-input-available-p fd (or timeout -1))
          (when win
            (return (values t nil nil)))
          (when (eql error 0)         ;timed out
            (return (values nil t nil)))
          ;; If it returned and a timeout was specified, check
          ;; to see if it's been exceeded.  If so, return NIL;
          ;; otherwise, adjust the remaining timeout.
          ;; If there was no timeout, continue to wait forever.
          (unless (eql error (- #$EINTR))
            (return (values nil nil error)))
          (when timeout
            (gettimeofday now)
            (setq timeout (- wait-end (timeval->milliseconds now)))
            (if (<= timeout 0)
              (return (values nil t nil)))))))))


(defun process-output-would-block (fd)
  #+windows-target (declare (ignore fd))
  #+windows-target t
  #-windows-target
  (if (logtest #$O_NONBLOCK (the fixnum (fd-get-flags fd)))
    (process-output-wait fd)
    (- #$ETIMEDOUT)))

(defun process-output-wait (fd &optional timeout)
  "Wait until output is possible on a given file descriptor."
  (rlet ((now :timeval))
    (let* ((wait-end 
            (when timeout
              (gettimeofday now)
              (+ (timeval->milliseconds now) timeout))))
      (loop
        (multiple-value-bind (win error)
            (fd-ready-for-output-p fd (or timeout -1))
          (when win
            (return (values t nil nil)))
          (when (eql error 0)
            (return (values nil t nil)))
          (unless (eql error (- #$EINTR))
            (return (values nil nil error)))
          ;; If it returned and a timeout was specified, check
          ;; to see if it's been exceeded.  If so, return NIL;
          ;; otherwise, adjust the remaining timeout.
          ;; If there was no timeout, continue to wait forever.
          (when timeout
            (gettimeofday now)
            (setq timeout (- wait-end (timeval->milliseconds now)))
            (if (<= timeout 0)
              (return (values nil t nil)))))))))



(defun ticks-to-timeval (ticks tv)
  (when ticks
    (let* ((total-us (* ticks (/ 1000000 *ticks-per-second*))))
      (multiple-value-bind (seconds us) (floor total-us 1000000)
	(setf (pref tv :timeval.tv_sec) seconds
	      (pref tv :timeval.tv_usec) us)))))

(defun fd-input-available-p (fd &optional milliseconds)
  "Returns true or false depending on whether input is available.
   In some cases on windows, it may return a count of the number of unread bytes.
   This behavior should not be depended upon."
  #+windows-target
  (case (%unix-fd-kind fd)
    (:socket
     (rlet ((infds #>fd_set)
            (tv :timeval :tv_sec 0 :tv_usec 0))
       (fd-zero infds)
       (fd-set fd infds)
       (when milliseconds
         (multiple-value-bind (seconds millis)
             (floor milliseconds 1000)
        (setf (pref tv :timeval.tv_sec) seconds
              (pref tv :timeval.tv_usec) (* 1000 millis))))
       (let* ((result (#_select 1 infds (%null-ptr) (%null-ptr) (if milliseconds tv (%null-ptr)))))
         (cond ((> result 0) (values t 0))
               ((= result 0) (values nil 0))
               (t (values nil (- (#_GetLastError))))))))
    (:pipe (if (data-available-on-pipe-p fd)
             (values t 0)
             (if (and milliseconds (> milliseconds 0))
               (values (process-wait-with-timeout "input-wait" milliseconds #'data-available-on-pipe-p fd) 0)
               (values nil 0))))
    (:file (let* ((curpos (fd-tell fd))
                  (eofpos (%stack-block ((peofpos 8))
                            (#_GetFileSizeEx (%int-to-ptr fd) peofpos)
                            (%%get-unsigned-longlong peofpos 0))))
             (values (< curpos eofpos) 0)))
    ;;(:character-special (windows-tty-input-available-p fd milliseconds))

    (t (values nil 0)))
  #-windows-target
  (rlet ((pollfds (:array (:struct :pollfd) 1)))
    (setf (pref (paref pollfds (:* (:struct :pollfd)) 0) :pollfd.fd) fd
          (pref (paref pollfds (:* (:struct :pollfd)) 0) :pollfd.events) #$POLLIN)
    (let* ((res (int-errno-call (#_poll pollfds 1 (or milliseconds -1)))))
      (declare (fixnum res))
      (values (> res 0) res))))


(defun fd-ready-for-output-p (fd &optional milliseconds)
  #+windows-target
  (case (%unix-fd-kind fd)
    (:socket
     (rlet ((tv :timeval :tv_sec 0 :tv_usec 0)
            (outfds :fd_set))
       (fd-zero outfds)
       (fd-set fd outfds)
       (when milliseconds
         (multiple-value-bind (seconds millis)
             (floor milliseconds 1000)
           (setf (pref tv #>timeval.tv_sec) seconds
                 (pref tv #>timeval.tv_usec) (* millis 1000))))
       (let* ((res (#_select 1 (%null-ptr) outfds (%null-ptr) (if milliseconds tv (%null-ptr)))))
         (cond ((> res 0) (values t 0))
               ((= res 0) (values nil 0))
               (t (values 0 (- (#_GetLastError))))))))
    (t (values t 0)))
  #-windows-target
  (rlet ((pollfds (:array (:struct :pollfd) 1)))
    (setf (pref (paref pollfds (:* (:struct :pollfd)) 0) :pollfd.fd) fd
          (pref (paref pollfds (:* (:struct :pollfd)) 0) :pollfd.events) #$POLLOUT)
    (let* ((res (int-errno-call (#_poll pollfds 1 (or milliseconds -1)))))
      (declare (fixnum res))
      (values (> res 0)  res))))



;;; FD-streams, built on top of the ioblock mechanism.
(defclass fd-stream (buffered-stream-mixin fundamental-stream) ())


(defmethod select-stream-advance-function ((s symbol) direction)
  (select-stream-advance-function (find-class s) direction))

(defmethod select-stream-advance-function ((c class) direction)
  (select-stream-advance-function (class-prototype c) direction))

(defmethod select-stream-advance-function ((s fd-stream) (direction t))
  'fd-stream-advance)

(defmethod select-stream-advance-function ((s basic-stream) (direction t))
  'fd-stream-advance)


(defmethod select-stream-force-output-function ((s symbol) direction)
  (select-stream-force-output-function (find-class s) direction))

(defmethod select-stream-force-output-function ((c class) direction)
  (select-stream-force-output-function (class-prototype c) direction))

(defmethod select-stream-force-output-function ((f fd-stream) (direction t))
  'fd-stream-force-output)

(defmethod select-stream-force-output-function ((f basic-stream) (direction t))
  'fd-stream-force-output)

(defmethod print-object ((s fd-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (let* ((ioblock (stream-ioblock s nil))
           (fd (and ioblock (ioblock-device ioblock)))
           (encoding (and ioblock (encoding-name (ioblock-encoding ioblock)))))
      (if fd
        (format out "~s (~a/~d)" encoding (%unix-fd-kind fd) fd)
        (format out "~s" :closed)))))

(defclass fd-input-stream (fd-stream buffered-input-stream-mixin)
    ())

(defclass fd-output-stream (fd-stream buffered-output-stream-mixin)
    ())

(defclass fd-io-stream (fd-stream buffered-io-stream-mixin)
    ())

(defclass fd-character-input-stream (fd-input-stream
                                     buffered-character-input-stream-mixin)
    ())

(defclass fd-character-output-stream (fd-output-stream
                                      buffered-character-output-stream-mixin)
    ())

(defclass fd-character-io-stream (fd-io-stream
                                  buffered-character-io-stream-mixin)
    ())

(defclass fd-binary-input-stream (fd-input-stream
                                  buffered-binary-input-stream-mixin)
    ())

(defclass fd-binary-output-stream (fd-output-stream
                                   buffered-binary-output-stream-mixin)
    ())

(defclass fd-binary-io-stream (fd-io-stream buffered-binary-io-stream-mixin)
    ())

(defun fd-stream-advance (s ioblock read-p)
  (let* ((fd (ioblock-device ioblock))
         (buf (ioblock-inbuf ioblock))
         (bufptr (io-buffer-bufptr buf))
         (size (io-buffer-size buf))
         (avail nil))
    (setf (io-buffer-idx buf) 0
          (io-buffer-count buf) 0
          (ioblock-eof ioblock) nil)
      (when (or read-p (setq avail (fd-input-available-p fd 0)))
        (unless avail
          (let* ((deadline (ioblock-deadline ioblock))
                 (timeout
                  (if deadline
                    (milliseconds-until-deadline deadline ioblock)
                    (ioblock-input-timeout ioblock))))
            (when timeout
              (multiple-value-bind (win timedout error)
                  (process-input-wait fd timeout)
                (unless win
                  (if timedout
                    (error (if deadline
                             'communication-deadline-expired
                             'input-timeout)
                           :stream s)
                    (stream-io-error s (- error) "read")))))))
        (let* ((n (with-eagain fd :input
		    (fd-read fd bufptr size))))
          (declare (fixnum n))
          (if (< n 0)
            (stream-io-error s (- n) "read")
            (if (> n 0)
              (setf (io-buffer-count buf)
		    (ioblock-octets-to-elements ioblock n))
              (progn (setf (ioblock-eof ioblock) t)
                     nil)))))))

(defun fd-stream-eofp (s ioblock)
  (or (ioblock-eof ioblock)
      (progn (fd-stream-advance s ioblock nil)
             (ioblock-eof ioblock))))

(defun fd-stream-listen (s ioblock)
  (if (interactive-stream-p s)
    (unread-data-available-p (ioblock-device ioblock))
    (not (fd-stream-eofp s ioblock))))

(defun fd-stream-close (s ioblock)
  (cancel-terminate-when-unreachable s)
  (when (ioblock-dirty ioblock)
    (stream-force-output s))
  (let* ((fd (ioblock-device ioblock)))
    (when fd
      (setf (ioblock-device ioblock) nil)
      (if (>= fd 0) (fd-close fd)))))

(defun fd-stream-force-output (s ioblock count finish-p)
  (when (or (ioblock-dirty ioblock) finish-p)
    (setf (ioblock-dirty ioblock) nil)
    (let* ((fd (ioblock-device ioblock))
	   (io-buffer (ioblock-outbuf ioblock))
	   (buf (%null-ptr))
	   (octets-to-write (ioblock-elements-to-octets ioblock count))
	   (octets octets-to-write))
      (declare (fixnum octets))
      (declare (dynamic-extent buf))
      (%setf-macptr buf (io-buffer-bufptr io-buffer))
      (setf (io-buffer-idx io-buffer) 0
	    (io-buffer-count io-buffer) 0)
      (do* ()
	   ((= octets 0)
	    (when finish-p
	      (case (%unix-fd-kind fd)
		(:file (fd-fsync fd))))
	    octets-to-write)
        (let* ((deadline (ioblock-deadline ioblock))
               (timeout
                (if deadline
                  (milliseconds-until-deadline deadline ioblock)
                  (ioblock-output-timeout ioblock))))
          (when timeout
            (multiple-value-bind (win timedout error)
                (process-output-wait fd timeout)
              (unless win
                (if timedout
                  (error (if deadline
                           'communication-deadline-expired
                           'output-timeout)
                         :stream s)
                  (stream-io-error s (- error) "write"))))))
	(let* ((written (with-eagain fd :output
			  (fd-write fd buf octets))))
	  (declare (fixnum written))
	  (if (< written 0)
	    (stream-io-error s (- written) "write"))
	  (decf octets written)
	  (unless (zerop octets)
	    (%incf-ptr buf written)))))))

(defmethod stream-read-line ((s buffered-input-stream-mixin))
   (with-stream-ioblock-input (ioblock s :speedy t)
     (funcall (ioblock-read-line-function ioblock) ioblock)))

(defmethod stream-clear-input ((s fd-input-stream))
  (call-next-method)
  (with-stream-ioblock-input (ioblock s :speedy t)
    (let* ((fd (ioblock-device ioblock)))
      (when fd (%fd-drain-input fd)))))

(defmethod select-stream-class ((class (eql 'fd-stream)) in-p out-p char-p)
  (if char-p
    (if in-p
      (if out-p
	'fd-character-io-stream
	'fd-character-input-stream)
      'fd-character-output-stream)
    (if in-p
      (if out-p
	'fd-binary-io-stream
	'fd-binary-input-stream)
      'fd-binary-output-stream)))

(defstruct (input-selection (:include dll-node))
  (package nil :type (or null string package))
  (source-file nil :type (or null string pathname))
  (string-stream nil :type (or null string-input-stream)))

(defstruct (input-selection-queue (:include locked-dll-header)))

(defclass selection-input-stream (fd-character-input-stream)
    ((package :initform nil :reader selection-input-stream-package)
     (pathname :initform nil :reader selection-input-stream-pathname)
     (peer-fd  :reader selection-input-stream-peer-fd)))

(defmethod select-stream-class ((class (eql 'selection-input-stream))
                                in-p out-p char-p)
  (if (and in-p char-p (not out-p))
    'selection-input-stream
    (error "Can't create that type of stream.")))

(defun make-selection-input-stream (fd &key peer-fd encoding)
  (let* ((s (make-fd-stream fd
                            :class 'selection-input-stream
                            :sharing :lock
                            :encoding encoding)))
    (setf (slot-value s 'peer-fd) peer-fd)
    s))


;;; Very simple protocol:
;;; ^ppackage-name#\newline
;;; ^vpathname#\newline
;;; ^q quotes next character
;;; else raw data
(defmethod stream-read-char ((s selection-input-stream))
  (with-slots (package pathname) s
    (let* ((quoted nil))
      (loop
        (let* ((ch (call-next-method)))
          (if quoted
            (return ch)
            (case ch
              (#\^p (setq package nil)
                    (let* ((p (read-line s nil nil)))
                      (unless (zerop (length p))
                        (setq package p))))
              (#\^v (setq pathname nil)
                    (let* ((p (read-line s nil nil)))
                      (unless (zerop (length p))
                        (setq pathname p))))
              (#\^q (setq quoted t))
              (t (return ch)))))))))

(defmethod stream-peek-char ((s selection-input-stream))
  (let* ((ch (stream-read-char s)))
    (unless (eq ch :eof)
      (stream-unread-char s ch))
    ch))

(defmethod stream-read-line ((s selection-input-stream))
  (generic-read-line s))

(defmethod stream-read-list ((stream selection-input-stream)
			     list count)
  (generic-character-read-list stream list count))

(defmethod stream-read-vector ((stream selection-input-stream)
			       vector start end)
  (generic-character-read-vector stream vector start end))


;;;File streams.

(let* ((open-file-streams ())
       (open-file-streams-lock (make-lock)))
  (defun open-file-streams ()
    (with-lock-grabbed (open-file-streams-lock)
      (copy-list open-file-streams)))
  (defun note-open-file-stream (f)
    (with-lock-grabbed (open-file-streams-lock)
      (push f open-file-streams))
    t)
  (defun remove-open-file-stream (f)
    (with-lock-grabbed (open-file-streams-lock)
      (setq open-file-streams (nremove f open-file-streams)))
    t)
  (defun clear-open-file-streams ()
    (with-lock-grabbed (open-file-streams-lock)
      (setq open-file-streams nil))))
            

(defun open (filename &key (direction :input)
                      (element-type 'base-char)
                      (if-exists (if (eq (pathname-version filename) :newest)
                                   :new-version
                                   :error))
                      (if-does-not-exist (cond ((eq direction :probe)
                                                nil)
                                               ((or (eq direction :input)
                                                    (eq if-exists :overwrite)
                                                    (eq if-exists :append))
                                                :error)
                                               (t :create)))
                      (external-format :default)
		      (class 'file-stream)
                      (sharing :private)
                      (basic t))
  "Return a stream which reads from or writes to FILENAME.
  Defined keywords:
   :DIRECTION - one of :INPUT, :OUTPUT, :IO, or :PROBE
   :ELEMENT-TYPE - the type of object to read or write, default BASE-CHAR
   :IF-EXISTS - one of :ERROR, :NEW-VERSION, :RENAME, :RENAME-AND-DELETE,
                       :OVERWRITE, :APPEND, :SUPERSEDE or NIL
   :IF-DOES-NOT-EXIST - one of :ERROR, :CREATE or NIL
  See the manual for details."
  (loop
    (restart-case
      (return
	(make-file-stream filename
			  direction
			  element-type
			  if-exists
			  if-does-not-exist
			  class
			  external-format
                          sharing
                          basic))
      (retry-open ()
                  :report (lambda (stream) (format stream "Retry opening ~s" filename))
                  nil))))





(defun gen-file-name (path)
  (let* ((base (random (ash target::target-most-positive-fixnum -1)))
         (tem-path (merge-pathnames (make-pathname :name (%integer-to-string base) :type "tem" :defaults nil) path)))
    (loop
      (when (%create-file tem-path :if-exists nil) (return tem-path))      
      (setf (%pathname-name tem-path) (%integer-to-string (setq base (1+ base)))))))

(defun probe-file-x (path)
  (%probe-file-x (defaulted-native-namestring path)))

(defun file-length (stream)
  (typecase stream
    ;; Don't use an OR type here
    (file-stream (stream-length stream))
    (synonym-stream (file-length
		     (symbol-value (synonym-stream-symbol stream))))
    (broadcast-stream (let* ((last (last-broadcast-stream stream)))
			(if last
			  (file-length last)
			  0)))
    (otherwise (report-bad-arg stream 'file-stream))))
  
(defun file-position (stream &optional position)
  (when position
    (if (eq position :start)
      (setq position 0)
      (if (eq position :end)
	(setq position (file-length stream))
	(unless (typep position 'unsigned-byte)
	  (report-bad-arg position '(or
				     null
				     (eql :start)
				     (eql :end)
				     unsigned-byte))))))
  (stream-position stream position))


(defun %request-terminal-input ()
  (let* ((shared-resource
	  (if (typep *terminal-io* 'two-way-stream)
	    (input-stream-shared-resource
	     (two-way-stream-input-stream *terminal-io*)))))
    (if shared-resource (%acquire-shared-resource shared-resource t))))




(defun %%yield-terminal-to (&optional process)
  (let* ((stream (if (typep *terminal-io* 'synonym-stream)
                   (symbol-value (synonym-stream-symbol *terminal-io*))
                   *terminal-io*))
         (shared-resource
	  (if (typep stream 'two-way-stream)
	    (input-stream-shared-resource
	     (two-way-stream-input-stream stream)))))
    (when shared-resource (%yield-shared-resource shared-resource process))))

(defun %restore-terminal-input (&optional took-it)
  (let* ((shared-resource
	  (if took-it
	    (if (typep *terminal-io* 'two-way-stream)
	      (input-stream-shared-resource
	       (two-way-stream-input-stream *terminal-io*))))))
    (when shared-resource
      (%release-shared-resource shared-resource))))

;;; Initialize the global streams
;;; These are defparameters because they replace the ones that were in l1-init
;;; while bootstrapping.

(defparameter *terminal-io* nil "terminal I/O stream")
(defparameter *debug-io* nil "interactive debugging stream")
(defparameter *query-io* nil "query I/O stream")
(defparameter *error-output* nil "error output stream")
(defparameter *standard-input* nil "default input stream")
(defparameter *standard-output* nil "default output stream")
(defparameter *trace-output* nil "trace output stream")

(proclaim '(stream 
          *query-io* *debug-io* *error-output* *standard-input* 
          *standard-output* *trace-output*))

;;; Interaction with the REPL.  READ-TOPLEVEL-FORM should return 3
;;; values: a form, a (possibly null) pathname, and a boolean that
;;; indicates whether or not the result(s) of evaluating the form
;;; should be printed.  (The last value has to do with how selections
;;; that contain multiple forms are handled; see *VERBOSE-EVAL-SELECTION*
;;; and the SELECTION-INPUT-STREAM method below.)

(defmethod read-toplevel-form ((stream synonym-stream) &rest keys)
  (apply #'read-toplevel-form (symbol-value (synonym-stream-symbol stream)) keys))

(defmethod read-toplevel-form ((stream two-way-stream) &rest keys)
  (if (typep stream 'echo-stream)
    (call-next-method)
    (apply #'read-toplevel-form (two-way-stream-input-stream stream) keys)))

(defmethod read-toplevel-form :after ((stream echoing-two-way-stream) &key &allow-other-keys)
  (stream-set-column (two-way-stream-output-stream stream) 0))

(defmethod read-toplevel-form ((stream input-stream) &key eof-value file-name start-offset map)
  (loop
    (let* ((*in-read-loop* nil)
           (first-char (peek-char t stream nil eof-value))
           (form
            (let ((*read-suppress* nil))
              (cond ((eq first-char #\:)
                     (read-command-or-keyword stream eof-value))
                    ((eq first-char eof-value) eof-value)
                    (t (multiple-value-bind (form note)
			   (read-recording-source stream :eofval eof-value
						  :file-name file-name
						  :start-offset start-offset
						  :map map
						  :save-source-text t)
			 (setq *loading-toplevel-location* note)
			 form))))))
      (if (eq form eof-value)
        (return (values form nil t))
        (progn
          (let ((ch))                   ;Trim whitespace
            (while (and (listen stream)
                        (setq ch (read-char stream nil nil))
                        (whitespacep cH))
              (setq ch nil))
            (when ch (unread-char ch stream)))
          (when *listener-indent* 
            (write-char #\space stream)
            (write-char #\space stream))
          (return (values (process-single-selection form) nil t)))))))

(defparameter *verbose-eval-selection* nil
  "When true, the results of evaluating all forms in an input selection
are printed.  When false, only the results of evaluating the last form
are printed.")

(defmethod read-toplevel-form ((stream selection-input-stream)
                               &key eof-value &allow-other-keys)
  (if (eq (stream-peek-char stream) :eof)
    (values eof-value nil t)
    (let* ((*package* *package*)
           (pkg-name (selection-input-stream-package stream)))
      (when pkg-name (setq *package* (pkg-arg pkg-name)))
      (let* ((form (call-next-method))
             (last-form-in-selection (not (listen stream))))
        (values form
                (selection-input-stream-pathname stream)
                (or last-form-in-selection *verbose-eval-selection*))))))


(defun (setf %ioblock-external-format) (ef ioblock)
  (let* ((encoding (get-character-encoding (external-format-character-encoding ef)))
         (line-termination (external-format-line-termination ef)))
    (when (eq encoding (get-character-encoding nil))
      (setq encoding nil))
    (setq line-termination (cdr (assoc line-termination
                                       *canonical-line-termination-conventions*)))
    (setf (ioblock-encoding ioblock) encoding)
    (when (ioblock-inbuf ioblock)
      (setup-ioblock-input ioblock t (ioblock-element-type ioblock) (ioblock-sharing ioblock) encoding line-termination))
    (when (ioblock-outbuf ioblock)
      (setup-ioblock-output ioblock t (ioblock-element-type ioblock) (ioblock-sharing ioblock) encoding line-termination))
    ef))

(defmethod stream-external-format ((s basic-character-stream))
  (%ioblock-external-format (basic-stream-ioblock s)))

(defmethod (setf stream-external-format) (new (s basic-character-stream))
  (setf (%ioblock-external-format (basic-stream-ioblock s))
        (normalize-external-format (stream-domain s) new)))

(defmethod stream-external-format ((s buffered-stream-mixin))
  (%ioblock-external-format (stream-ioblock s t)))

(defmethod (setf stream-external-format) (new (s buffered-stream-mixin))
  (setf (%ioblock-external-format (stream-ioblock s t))
        (normalize-external-format (stream-domain s) new)))

(defmethod stream-input-timeout ((s basic-input-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-input-locked (ioblock)
      (let* ((timeout (ioblock-input-timeout ioblock)))
        (when timeout
          (values (floor timeout 1000.0)))))))

(defmethod (setf stream-input-timeout) (new (s basic-input-stream))
  (setq new (check-io-timeout new))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-input-locked (ioblock)
      (setf (ioblock-input-timeout ioblock)
            (if new (round (* new 1000))))
      new)))

(defmethod stream-output-timeout ((s basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-output-locked (ioblock)
      (let* ((timeout (ioblock-output-timeout ioblock)))
        (when timeout
          (values (floor timeout 1000.0)))))))

(defmethod (setf stream-output-timeout) (new (s basic-output-stream))
  (setq new (check-io-timeout new))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-output-locked (ioblock)
      (setf (ioblock-output-timeout ioblock)
            (if new (round (* new 1000))))
      new)))

(defmethod stream-deadline ((s basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-output-locked (ioblock)
      (ioblock-deadline ioblock))))
 
(defmethod (setf stream-deadline) (new (s basic-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (with-ioblock-output-locked (ioblock)
      (setf (ioblock-deadline ioblock) new)
      new)))



(defmethod stream-input-timeout ((s buffered-input-stream-mixin))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-input-locked (ioblock)
      (let* ((timeout (ioblock-input-timeout ioblock)))
        (when timeout
          (values (floor timeout 1000.0)))))))

(defmethod (setf stream-input-timeout) (new (s buffered-input-stream-mixin))
  (setq new (check-io-timeout new))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-input-locked (ioblock)
      (setf (ioblock-input-timeout ioblock)
            (if new (round (* new 1000))))
      new)))

(defmethod stream-output-timeout ((s buffered-output-stream-mixin))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-output-locked (ioblock)
      (let* ((timeout (ioblock-output-timeout ioblock)))
        (when timeout
          (values (floor timeout 1000.0)))))))

(defmethod (setf stream-output-timeout) (new (s buffered-output-stream-mixin))
  (setq new (check-io-timeout new))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-output-locked (ioblock)
      (setf (ioblock-output-timeout ioblock)
            (if new (round (* new 1000))))
      new)))

(defmethod stream-deadline ((s buffered-output-stream-mixin))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-output-locked (ioblock)
      (ioblock-deadline ioblock))))
 
(defmethod (setf stream-deadline) (new (s buffered-output-stream-mixin))
  (let* ((ioblock (stream-ioblock s t)))
    (with-ioblock-output-locked (ioblock)
      (setf (ioblock-deadline ioblock) new)
      new)))


(defmethod select-stream-untyi-function ((s symbol) direction)
  (select-stream-untyi-function (find-class s) direction))

(defmethod select-stream-untyi-function ((c class) direction)
  (select-stream-untyi-function (class-prototype c) direction))

(defmethod select-stream-untyi-function ((s fd-stream) (direction t))
  '%ioblock-untyi)

(defmethod select-stream-untyi-function ((s basic-stream) (direction t))
  '%ioblock-untyi)




(defparameter *vector-output-stream-default-initial-allocation* 64 "Default size of the vector created by (MAKE-VECTOR-OUTPUT-STREAM), in octets.")

;;; Bivalent vector streams.
(make-built-in-class 'vector-stream 'basic-binary-stream 'basic-character-stream)

(defmethod print-object ((s vector-stream) out)
  (print-unreadable-object (s out :type t :identity t)
    (unless (open-stream-p s)  (format out " ~s" :closed))))


(defstruct (vector-stream-ioblock (:include ioblock))
  (displacement 0)                      ;displaced-index-offset
  )

(defstruct (vector-output-stream-ioblock (:include vector-stream-ioblock))
  (line-length 80)                      ;for pretty-printer 
  displaced                             ;original vector if fill-pointer case
 )

(defstatic *vector-output-stream-class* (make-built-in-class 'vector-output-stream 'vector-stream 'basic-binary-output-stream 'basic-character-output-stream))
(defstatic *vector-output-stream-class-wrapper* (%class-own-wrapper *vector-output-stream-class*))
(defstatic *vector-input-stream-class* (make-built-in-class 'vector-input-stream 'vector-stream 'basic-binary-input-stream 'basic-character-input-stream))
(defstatic *vector-input-stream-class-wrapper* (%class-own-wrapper *vector-input-stream-class*))

(defmethod initialize-basic-stream :after ((s vector-stream) &key ioblock &allow-other-keys)
  (setf (basic-stream.state s) ioblock))

(defmethod stream-force-output ((s vector-output-stream)))

(defmethod stream-finish-output ((s vector-output-stream)))



(defun %extend-vector-output-stream (s ioblock count finish-p)
  (declare (ignore s count finish-p))
  (check-ioblock-owner ioblock)
  (let* ((displaced (vector-output-stream-ioblock-displaced ioblock))
         (outbuf (ioblock-outbuf ioblock)))
    (cond (displaced
           (let* ((flags (%svref displaced target::arrayH.flags-cell)))
             (declare (fixnum flags))
             (unless (logbitp $arh_adjp_bit flags)
               (%err-disp $XMALADJUST displaced))
             (let* ((len (%svref displaced target::vectorH.physsize-cell))
                    (newlen (max (the fixnum (+ len len)) (+ len *vector-output-stream-default-initial-allocation*)))
                    (new (%alloc-misc newlen target::subtag-u8-vector)))
               (declare (fixnum len newlen)
                        ((simple-array (unsigned-byte 8) (*)) new))
               (multiple-value-bind (data offset)
                   (%array-header-data-and-offset displaced)
                 (declare ((simple-array (unsigned-byte 8) (*)) data)
                          (fixnum offset))
                 (%copy-ivector-to-ivector data 0 new offset len)
                 (setf (vector-output-stream-ioblock-displacement ioblock) 0)
                 (unless (= 0 offset)
                   (setf (io-buffer-idx outbuf) len
                         (io-buffer-count outbuf) len))
                 (setf (io-buffer-limit outbuf) newlen
                       (io-buffer-size outbuf) newlen
                       (io-buffer-buffer outbuf) new)
                 ;; Adjust the displaced vector.
                 (setf (%svref displaced target::vectorH.data-vector-cell) new
                       (%svref displaced target::vectorH.displacement-cell) 0
                       (%svref displaced target::vectorH.physsize-cell) newlen
                       (%svref displaced target::vectorH.flags-cell) (bitclr $arh_exp_disp_bit flags)
                       (%svref displaced target::vectorH.logsize-cell) len)))))
          (t
           ;; Simpler. Honest.
           (let* ((old (io-buffer-buffer outbuf))
                  (len (length old))
                  (newlen (max (the fixnum (+ len len)) 16))
                  (new (%alloc-misc newlen target::subtag-u8-vector)))
             (declare (fixnum len newlen)
                      ((simple-array (unsigned-byte 8) (*)) old new))
             (%copy-ivector-to-ivector old 0 new 0 len)
             (setf (io-buffer-buffer outbuf) new
                   (io-buffer-size outbuf) newlen
                   (io-buffer-limit outbuf) newlen))))))

(defun %vector-output-stream-close (s ioblock)
  (declare (ignore s))
  ;; If there's a displaced vector, fix its fill pointer.
  (let* ((displaced (vector-output-stream-ioblock-displaced ioblock)))
    (when displaced
      (setf (%svref displaced target::vectorH.logsize-cell)
            (the fixnum (- (the fixnum (io-buffer-count (ioblock-outbuf ioblock)))
                           (the fixnum (vector-output-stream-ioblock-displacement ioblock))))))))

(defmethod stream-line-length ((s vector-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (string-output-stream-ioblock-line-length ioblock)))

(defmethod (setf stream-line-length) (newlen (s vector-output-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (setf (vector-output-stream-ioblock-line-length ioblock) newlen)))

(defun get-output-stream-vector (s)
  (unless (and (typep s 'basic-stream)
               (eq *vector-output-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-output-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (outbuf (progn
                   (check-ioblock-owner ioblock)
                   (ioblock-outbuf ioblock)))
         (v (io-buffer-buffer outbuf))
         (offset (vector-output-stream-ioblock-displacement ioblock))
         (len (the fixnum (- (the fixnum (io-buffer-count outbuf)) offset)))
         (new (%alloc-misc len target::subtag-u8-vector)))
    (declare (fixnum offset len))
    (%copy-ivector-to-ivector v offset new 0 len)
    (setf (io-buffer-idx outbuf) offset
          (io-buffer-count outbuf) offset)
    new))


(defmethod unsigned-integer-to-binary (value len (s binary-output-stream))
  (unless (typep value 'unsigned-byte)
    (report-bad-arg value 'unsigned-byte))
  (do* ((shift (ash (1- len) 3) (- shift 8)))
       ((< shift 0) value)
    (write-byte (logand #xff (ash value (- shift))) s)))

(defun %unsigned-integer-to-binary (value len s)
  (declare (fixnum len))
  (unless (and (typep s 'basic-stream)
               (eq *vector-output-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (outbuf (progn
                   (check-ioblock-owner ioblock)
                   (ioblock-outbuf ioblock)))
         (idx (io-buffer-idx outbuf))
         (limit (io-buffer-limit outbuf))
         (buffer (io-buffer-buffer outbuf)))
    (declare (fixnum idx limit)
             ((simple-array (unsigned-byte 8) (*)) buffer)
             (optimize (speed 3) (safety 0)))
    (etypecase value
      (fixnum
       (if (< (the fixnum value) 0)
         (report-bad-arg value 'unsigned-byte))
       (do* ((shift (ash (the fixnum (1- len)) 3) (- shift 8)))
            ((< shift 0) (progn
                           (setf (io-buffer-idx outbuf) idx)
                           (if (> idx (the fixnum (io-buffer-count outbuf)))
                             (setf (io-buffer-count outbuf) idx))
                           value))
         (declare (fixnum shift))
         (when (= idx limit)
           (%ioblock-force-output ioblock nil)
           (setq limit (io-buffer-limit outbuf)
                 buffer (io-buffer-buffer outbuf)))
         (setf (aref buffer idx) (logand #xff (the fixnum (%iasr shift value))))
         (incf idx)))
      (bignum
       (locally
           (declare ((simple-array (unsigned-byte 8) (*)) value))
         (let* ((nbytes (ash (uvsize value) 2))
                (sign-byte (if (logbitp 7 (the (unsigned-byte 8) (aref value (the fixnum (- nbytes #+big-endian-target 4 #+little-endian-target 1))))) #xff #x00)))
           (declare (fixnum nbytes)
                    ((unsigned-byte 8) sign-byte))
           (unless (zerop sign-byte)
             (report-bad-arg value 'unsigned-byte))
           (do* ((n (1- len) (1- n)))
                ((< n 0) (progn
                           (setf (io-buffer-idx outbuf) idx)
                           (if (> idx (the fixnum (io-buffer-count outbuf)))
                             (setf (io-buffer-count outbuf) idx))
                           value))
             (declare (fixnum n))
             (when (= idx limit)
               (%ioblock-force-output ioblock nil)
               (setq limit (io-buffer-limit outbuf)
                     buffer (io-buffer-buffer outbuf)))
             (setf (aref buffer idx)
                   (if (>= n nbytes)
                     0
                     (aref value #+little-endian-target n #+big-endian-target (the fixnum (logxor n 3)))))
             (incf idx))))))))

(defmethod unsigned-integer-to-binary (value len (s vector-output-stream))
  (%unsigned-integer-to-binary value len s))

(defun %signed-integer-to-binary (value len s)
  (declare (fixnum len))
  (unless (and (typep s 'basic-stream)
               (eq *vector-output-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (outbuf (progn
                   (check-ioblock-owner ioblock)
                   (ioblock-outbuf ioblock)))
         (idx (io-buffer-idx outbuf))
         (limit (io-buffer-limit outbuf))
         (buffer (io-buffer-buffer outbuf)))
    (declare (fixnum idx limit)
             ((simple-array (unsigned-byte 8) (*)) buffer)
             (optimize (speed 3) (safety 0)))
    (do* ((newidx (+ idx len)))
         ((< newidx limit))
      (declare (fixnum newidx))
      (%ioblock-force-output ioblock nil)
      (setq limit (io-buffer-limit outbuf)
            buffer (io-buffer-buffer outbuf)))
    (etypecase value
      (fixnum
       (do* ((shift (ash (the fixnum (1- len)) 3) (- shift 8)))
            ((< shift 0) (progn
                           (setf (io-buffer-idx outbuf) idx)
                           (if (> idx (the fixnum (io-buffer-count outbuf)))
                             (setf (io-buffer-count outbuf) idx))
                           value))
         (declare (fixnum shift))
         (setf (aref buffer idx) (logand #xff (the fixnum (%iasr shift value))))
         (incf idx)))
      (bignum
       (locally
           (declare ((simple-array (unsigned-byte 8) (*)) value))
         (let* ((nbytes (ash (uvsize value) 2))
                (sign-byte (if (logbitp 7 (the (unsigned-byte 8) (aref value (the fixnum (- nbytes #+big-endian-target 4 #+little-endian-target 1))))) #xff #x00)))
           (declare (fixnum nbytes)
                    ((unsigned-byte 8) sign-byte))
           (do* ((n (1- len) (1- n)))
                ((< n 0) (progn
                           (setf (io-buffer-idx outbuf) idx)
                           (if (> idx (the fixnum (io-buffer-count outbuf)))
                             (setf (io-buffer-count outbuf) idx))
                           value))
             (declare (fixnum n))
             (setf (aref buffer idx)
                   (if (>= n nbytes)
                     sign-byte
                     (aref value #+little-endian-target n #+big-endian-target (the fixnum (logxor n 3)))))
             (incf idx))))))))

(defmethod signed-integer-to-binary (value len (s vector-output-stream))
  (%signed-integer-to-binary value len s))
      
(defmethod signed-integer-to-binary (value len (s binary-output-stream))
  (do* ((shift (ash (1- len) 3) (- shift 8)))
       ((< shift 0) value)
    (write-byte (logand #xff (ash value (- shift))) s)))             
               

         

(defun %make-vector-output-stream (vector external-format)
  (let* ((data nil)
         (len nil)
         (offset 0)
         (start 0)
         (displaced nil)
         (external-format (normalize-external-format t external-format))
         (encoding (external-format-character-encoding external-format))
         (line-termination (external-format-line-termination external-format)))
    (cond ((typep vector '(simple-array (unsigned-byte 8) (*)))
           (setq data vector len (length vector)))
          (t
           (multiple-value-setq (data offset) (array-data-and-offset vector))
           (unless (eql (typecode data) target::subtag-u8-vector)
             (report-bad-arg vector '(vector (unsigned-byte 8))))
           (unless (array-has-fill-pointer-p vector)
             (error "~S must be a vector with a fill pointer." vector))
           (setq start (+ (fill-pointer vector) offset)
                 len (+ (array-total-size vector) offset)
                 displaced vector)))
    (make-ioblock-stream *vector-output-stream-class*
                         :ioblock (make-vector-output-stream-ioblock
                                   :outbuf (make-io-buffer :buffer data
                                                           :idx start
                                                           :count start
                                                           :limit len
                                                           :size len)
                                   :displaced displaced
                                   :displacement offset)
                         :encoding encoding
                         :character-p t
                         :element-type '(unsigned-byte 8)
                         :line-termination line-termination
                         :force-output-function '%extend-vector-output-stream
                         :close-function '%vector-output-stream-close)))

    
(defun make-vector-output-stream (&key (external-format :default))
  (%make-vector-output-stream (make-array *vector-output-stream-default-initial-allocation* :element-type '(unsigned-byte 8))  external-format))

(defmethod stream-position ((s vector-output-stream) &optional newpos)
  (let* ((ioblock (basic-stream-ioblock s))
         (outbuf (ioblock-outbuf ioblock))
         (origin (vector-stream-ioblock-displacement ioblock)))
    (declare (fixnum origin))
    (if newpos
      (if (and (typep newpos 'fixnum)
               (> (the fixnum newpos) -1)
               (< (the fixnum newpos) (the fixnum (+ origin (the fixnum (io-buffer-limit outbuf))))))
        (let* ((scaled-new (+ origin (the fixnum newpos))))
          (declare (fixnum scaled-new))
          (setf (io-buffer-idx outbuf) scaled-new)
          (if (> (the fixnum (io-buffer-count outbuf)) scaled-new)
            (setf (io-buffer-count outbuf) scaled-new))
          (let* ((displaced (vector-output-stream-ioblock-displaced ioblock)))
            (when displaced
              (setf (fill-pointer displaced) newpos)))
          newpos)
        (report-bad-arg newpos `(integer 0 (,(- (the fixnum (io-buffer-limit outbuf)) origin)))))
      (the fixnum (- (the fixnum (io-buffer-idx outbuf)) origin)))))

(defun vector-input-stream-index (s)
  (unless (and (typep s 'basic-stream)
               (eq *vector-input-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-input-stream))
  (let* ((ioblock (basic-stream-ioblock s)))
    (check-ioblock-owner ioblock)
    (the fixnum (- (the fixnum (io-buffer-idx (ioblock-inbuf ioblock)))
                   (the fixnum (vector-stream-ioblock-displacement ioblock))))))
            

(defun %vector-input-stream-untyi (ioblock char)
  (check-ioblock-owner ioblock)
  (let* ((inbuf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx inbuf))
         (encoding (ioblock-encoding ioblock))
         (noctets (if encoding
                    (funcall (character-encoding-character-size-in-octets-function encoding) char)
                    1))
         (newidx (- idx noctets)))
    (declare (fixnum idx noctets newidx))
    (if (>= newidx (the fixnum (vector-stream-ioblock-displacement ioblock)))
      (setf (io-buffer-idx inbuf) newidx)
      (error "Invalid attempt to unread ~s on ~s." char (ioblock-stream ioblock)))))

  

(defmethod select-stream-untyi-function ((s vector-input-stream) (direction t))
  '%vector-input-stream-untyi)




(defun %make-vector-input-stream (vector start end external-format)
  (setq end (check-sequence-bounds vector start end))
  (let* ((data nil)
         (offset 0)
         (external-format (normalize-external-format t external-format))
         (encoding (external-format-character-encoding external-format))
         (line-termination (external-format-line-termination external-format)))

      (cond ((typep vector '(simple-array (unsigned-byte 8) (*)))
             (setq data vector                   offset start))
            (t (multiple-value-setq (data offset) (array-data-and-offset vector))
               (unless (typep data '(simple-array (unsigned-byte 8) (*)))
                 (report-bad-arg vector '(vector (unsigned-byte 8))))
               (incf start offset)
               (incf end offset)))
      (make-ioblock-stream *vector-input-stream-class*
                           :ioblock (make-vector-stream-ioblock
                                     :inbuf (make-io-buffer
                                             :buffer data
                                             :idx start
                                             :count end
                                             :limit end
                                             :size end)
                                     :displacement start)
                           :direction :input
                           :character-p t
                           :element-type '(unsigned-byte 8)
                           :encoding encoding
                           :line-termination line-termination
                           :listen-function 'false
                           :eofp-function 'true
                           :advance-function 'false
                           :close-function 'false)))
      
(defun make-vector-input-stream (vector &key (start 0) end external-format)
  (%make-vector-input-stream vector start end external-format))



(defmethod pui-stream ((s binary-input-stream) count)
  "Parse unsigned integer from a stream."
  (declare (fixnum count)               ; any integer that cannot be expressed in fixnum bytes is probably (ahem) too long to worry about
           (optimize (speed 3) (safety 1) (debug 1)))
  (let ((n 0))
    (dotimes (i count n)
      (declare (fixnum i))
      (setq n (+ (the fixnum (read-byte s)) (the integer (ash n 8)))))))

(defun %pui-stream (s count)
  (declare (fixnum count))
  (unless (and (typep s 'basic-stream)
               (eq *vector-input-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (inbuf (progn
                  (check-ioblock-owner ioblock)
                  (ioblock-inbuf ioblock)))
         (idx (io-buffer-idx inbuf))
         (end (+ idx count))
         (limit (io-buffer-limit inbuf))
         (vector (io-buffer-buffer inbuf)))
    (declare (fixnum idx limit end)
             ((simple-array (unsigned-byte 8) (*)) vector))
    (if (< limit end)
      (error "Integer decoding error"))
    (let* ((result (%parse-unsigned-integer vector idx end)))
      (setf (io-buffer-idx inbuf) end)
      result)))

(defmethod pui-stream ((s vector-input-stream) count)
  (%pui-stream s count))

(defmethod psi-stream ((s binary-input-stream) count)
  (declare (fixnum count))
  (if (zerop count)
    0
    (let* ((n (read-byte s)))
      (if (>= n 128)
        (setq n (- n 256)))
      (dotimes (i (the fixnum (1- count)) n)
        (setq n (logior (read-byte s) (ash n 8)))))))

(defun %psi-stream (s count)
  (declare (fixnum count))
  (unless (and (typep s 'basic-stream)
               (eq *vector-input-stream-class-wrapper*
                   (basic-stream.wrapper s)))
    (report-bad-arg s 'vector-input-stream))
  (let* ((ioblock (basic-stream-ioblock s))
         (inbuf (progn
                  (check-ioblock-owner ioblock)
                  (ioblock-inbuf ioblock)))
         (idx (io-buffer-idx inbuf))
         (end (+ idx count))
         (limit (io-buffer-limit inbuf))
         (vector (io-buffer-buffer inbuf)))
    (declare (fixnum idx limit end))
    (if (< limit end)
      (error "Integer decoding error"))
    (let* ((result (%parse-signed-integer vector idx end)))
      (setf (io-buffer-idx inbuf) end)
      result)))

(defmethod psi-stream ((s vector-input-stream) count)
  (%psi-stream s count))

(defmethod stream-position ((s vector-input-stream) &optional newpos)
  (let* ((ioblock (basic-stream-ioblock s))
         (inbuf (ioblock-inbuf ioblock))
         (origin (vector-stream-ioblock-displacement ioblock)))
    (declare (fixnum origin))
    (if newpos
      (if (and (typep newpos 'fixnum)
               (> (the fixnum newpos) -1)
               (< (the fixnum newpos) (the fixnum (+ origin (the fixnum (io-buffer-limit inbuf))))))
        (progn
          (setf (io-buffer-idx inbuf) (the fixnum (+ origin (the fixnum newpos))))
          newpos)
        (report-bad-arg newpos `(integer 0 (,(- (the fixnum (io-buffer-limit inbuf)) origin)))))
      (the fixnum (- (the fixnum (io-buffer-idx inbuf)) origin)))))

(defmethod stream-length ((s vector-input-stream) &optional new)
  (unless new
    (let ((ioblock (basic-stream-ioblock s)))
      (%i- (io-buffer-limit (ioblock-inbuf ioblock))
	   (vector-stream-ioblock-displacement ioblock)))))


; end of L1-streams.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-streams.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defun %kernel-restart (error-type &rest args)
  (%kernel-restart-internal error-type args (%get-frame-ptr)))

(defun %kernel-restart-internal (error-type args frame-ptr)
  ;(declare (dynamic-extent args))
  (dolist (f *kernel-restarts* (%err-disp-internal error-type args frame-ptr))
    (when (eq (car f) error-type)
      (return (apply (cdr f) frame-ptr args)))))

;;; this is the def of %err-disp.
;;; Yup.  That was my first guess.
(defun %err-disp (err-num &rest errargs)
  (%err-disp-internal err-num errargs (%get-frame-ptr)))

(defun %errno-disp (errno &rest errargs)
  (%errno-disp-internal errno errargs (%get-frame-ptr)))

#+windows-target
(defun %windows-error-disp (errno &rest errargs)
  (%err-disp-common errno 0 (%windows-error-string errno) errargs (%get-frame-ptr)))
  
(defun %errno-disp-internal (errno errargs frame-ptr)
  (declare (fixnum errno))
  (let* ((err-type (max (ash errno -16) 0))
	 (errno (%word-to-int errno))
	 (error-string (%strerror errno))
	 (format-string (if errargs
			  (format nil "~a : ~a" error-string "~s")
			  error-string)))
    (%err-disp-common nil err-type  format-string errargs frame-ptr)))


(defun %err-disp-internal (err-num errargs frame-ptr)
  (declare (fixnum err-num))
  ;;; The compiler (finally !) won't tail-apply error.  But we kind of
  ;;; expect it to ...
  (if (eql err-num $XARRLIMIT)
    (%error (make-condition 'vector-size-limitation
                            :subtag (cadr errargs)
                            :element-count (car errargs))
            nil
            frame-ptr)
    (let* ((err-typ (max (ash err-num -16) 0))
           (err-num (%word-to-int err-num))
           (format-string (%rsc-string err-num)))
      (%err-disp-common err-num err-typ format-string errargs frame-ptr))))

(defparameter *foreign-error-condition-recognizers* ())


(defun %err-disp-common (err-num err-typ format-string errargs frame-ptr)
  (let* ((condition-name (or (uvref *simple-error-types* err-typ)
                             (%cdr (assq err-num *kernel-simple-error-classes*)))))
    ;;(dbg format-string)
    (if condition-name      
      (funcall '%error
               (case condition-name
                 (type-error
                  (if (cdr errargs)
                    (make-condition condition-name
                                             :format-control format-string
                                             :datum (car errargs)
                                             :expected-type (%type-error-type (cadr errargs)))
                    (make-condition condition-name
                                             :format-control format-string
                                             :datum (car errargs))))
		 (improper-list (make-condition condition-name
						:datum (car errargs)))
                 (simple-file-error (make-condition condition-name
                                             :pathname (car errargs)
                                             :error-type format-string
                                             :format-arguments (cdr errargs)))
                 (undefined-function (make-condition condition-name
                                                     :name (car errargs)))
                 (call-special-operator-or-macro
                  (make-condition condition-name
                                  :name (car errargs)
                                  :function-arguments (cadr errargs)))
                 (sequence-index-type-error
                  (make-sequence-index-type-error (car errargs) (cadr errargs)))
		 (cant-construct-arglist
		  (make-condition condition-name
				  :datum (car errargs)
				  :format-control format-string))
                 (array-element-type-error
                  (let* ((array (cadr errargs)))
                    (make-condition condition-name
                                    :format-control format-string
                                    :datum (car errargs)
                                    :expected-type (array-element-type array)
                                    :array array)))
                 (division-by-zero (make-condition condition-name
                                                   :operation '/
                                                   :operands (if errargs
                                                               (list (car errargs)
                                                                     0)
                                                               (list 0))))
                 (t (make-condition condition-name 
                                    :format-control format-string
                                    :format-arguments errargs)))
               nil
               frame-ptr)
      (let* ((cond nil))
        (if (and (eql err-num $XFOREIGNEXCEPTION)
                 (dolist (recog *foreign-error-condition-recognizers*)
                   (let* ((c (funcall recog (car errargs))))
                     (when c (return (setq cond c))))))
          (funcall '%error cond nil frame-ptr)
          (funcall '%error format-string errargs frame-ptr))))))

(defun error (condition &rest args)
  "Invoke the signal facility on a condition formed from DATUM and ARGUMENTS.
  If the condition is not handled, the debugger is invoked."
  (%error condition args (%get-frame-ptr)))

(defun cerror (cont-string condition &rest args)
  (let* ((fp (%get-frame-ptr)))
    (restart-case (%error condition (if (condition-p condition) nil args) fp)
      (continue ()
                :report (lambda (stream) 
                            (apply #'format stream cont-string args))
                nil))))

(defun %error (condition args error-pointer)
  (setq *error-reentry-count* 0)
  (setq condition (condition-arg condition args 'simple-error))
  (signal condition)
  (unless *interactive-streams-initialized*
    (bug (format nil "Error during early application initialization:~%
~a" condition))
    (#_exit #-windows-target #-android-target #$EX_SOFTWARE #+android-target 70 #+windows-target #$EXIT_FAILURE))
  (application-error *application* condition error-pointer)
  (application-error
   *application*
   (condition-arg "~s returned. It shouldn't.~%If it returns again, I'll throw to toplevel."
                  '(application-error) 'simple-error)
   error-pointer)
  (toplevel))

(defun make-sequence-index-type-error (idx sequence)
  (let* ((upper (length sequence)))
    (make-condition 'sequence-index-type-error
                    :datum idx
                    :sequence sequence
                    :expected-type `(integer 0 (,upper)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-boot-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


; l1-boot-lds.lisp

(in-package "CCL")





(defun command-line-arguments ()
  *command-line-argument-list*)

(defun startup-ccl (&optional init-file)
  ;; Many of the things done here could enter a break loop on error.
  ;; If that break loop is exited via :q, quietly exit to here.
  (catch :toplevel
    (with-simple-restart (abort "Abort startup.")
      (let ((init-files (if (listp init-file) init-file (list init-file))))
        (dolist (init-file init-files)
          (with-simple-restart (continue "Skip loading init file.")
            (when (load init-file :if-does-not-exist nil :verbose nil)
              (return)))))
      (flet ((eval-string (s)
               (with-simple-restart (continue "Skip evaluation of ~a" s)
                 (eval (read-from-string s))))
             (load-file (name)
               (with-simple-restart (continue "Skip loading ~s" name)
                 (load name))))
        (dolist (p *lisp-startup-parameters*)
          (let* ((param (cdr p)))
            (case (car p)
              (:gc-threshold
               (multiple-value-bind (n last) (parse-integer param :junk-allowed t)
                 (when n
                   (if (< last (length param))
                     (case (schar param last)
                       ((#\k #\K) (setq n (ash n 10)))
                       ((#\m #\M) (setq n (ash n 20)))))
                   (set-lisp-heap-gc-threshold n)
                   (use-lisp-heap-gc-threshold))))
              (:eval (eval-string param))
              (:load (load-file param)))))))))

(defloadvar *did-show-marketing-blurb* nil)

(defparameter *marketing-blurb* "
For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
")

(defun listener-function ()
  (unless (or *inhibit-greeting* *quiet-flag*)
    (format t "~&~A ~A~%"
	    (lisp-implementation-type)
	    (lisp-implementation-version))
    (unless *did-show-marketing-blurb*
      (write-string *marketing-blurb* t)
      (setq *did-show-marketing-blurb* t)))
  (toplevel-loop))

(defun make-mcl-listener-process (procname
                                  input-stream
                                  output-stream
                                  cleanup-function
                                  &key
                                  (initial-function #'listener-function)
                                  (close-streams t)
                                  (class 'process)
                                  (control-stack-size *default-control-stack-size*)
                                  (auto-flush t)
                                  (value-stack-size *default-value-stack-size*)
                                  (temp-stack-size *default-temp-stack-size*)
                                  (echoing t)
                                  (process)
                                  (initargs nil))
  (let ((p (if (typep process class)
             (progn
               (setf (process-thread process)
                     (new-thread procname control-stack-size value-stack-size  temp-stack-size))
               process)
             (make-process procname
                           :class class :initargs initargs
                           :stack-size control-stack-size
                           :vstack-size value-stack-size
                           :tstack-size temp-stack-size))))
    (process-preset p #'(lambda ()
                          (let ((*terminal-io*
                                 (if echoing
                                   (make-echoing-two-way-stream
                                    input-stream output-stream)
                                   (make-two-way-stream
                                    input-stream output-stream))))
			    (unwind-protect
				 (progn
                                   (when auto-flush
                                     (add-auto-flush-stream output-stream))
				   (let* ((shared-input
					   (input-stream-shared-resource
					    input-stream)))
				     (when shared-input
				       (setf (shared-resource-primary-owner
					      shared-input)
					     *current-process*)))
                                   (application-ui-operation
                                    *application*
                                    :note-current-package *package*)
				   (funcall initial-function))
                              (remove-auto-flush-stream output-stream)
			      (funcall cleanup-function)
			      (when close-streams
				(close input-stream)
				(close output-stream))))))
    (process-enable p)
    p))


; End of l1-boot-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-boot-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/x86-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 2005-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


(in-package "CCL")


#+x8664-target  
(defun make-callback-trampoline (index &optional info)
  (declare (ignore info))
  (let* ((p (%allocate-callback-pointer 16))
         (addr #.(subprim-name->offset '.SPcallback)))
    (setf (%get-unsigned-byte p 0) #x41 ; movl $n,%r11d
          (%get-unsigned-byte p 1) #xc7
          (%get-unsigned-byte p 2) #xc3
          (%get-unsigned-byte p 3) (ldb (byte 8 0) index)
          (%get-unsigned-byte p 4) (ldb (byte 8 8) index)
          (%get-unsigned-byte p 5) (ldb (byte 8 16) index)
          (%get-unsigned-byte p 6) (ldb (byte 8 24) index)
          (%get-unsigned-byte p 7) #xff  ; jmp *
          (%get-unsigned-byte p 8) #x24
          (%get-unsigned-byte p 9) #x25
          (%get-unsigned-byte p 10) (ldb (byte 8 0) addr)
          (%get-unsigned-byte p 11) (ldb (byte 8 8) addr)
          (%get-unsigned-byte p 12) (ldb (byte 8 16) addr)
          (%get-unsigned-byte p 13) (ldb (byte 8 24) addr))
    p))
          
#+x8632-target          
(defun make-callback-trampoline (index &optional info)
  (let* ((p (%allocate-callback-pointer 12))
         (addr #.(subprim-name->offset '.SPcallback)))
    ;; If the optional info parameter is supplied, it will contain
    ;; some stuff in bits 23 through 31.
    ;;
    ;; If bit 23 is set, that indicates that the caller will pass a
    ;; "hidden" argument which is a pointer to appropriate storage for
    ;; holding a returned structure.  .SPcallback will have to discard
    ;; this extra argument upon return.
    ;;
    ;; The high 8 bits denote the number of words that .SPcallback
    ;; will have to discard upon return (used for _stdcall on
    ;; Windows).  Bit 23 won't be set in this case: we will have
    ;; already added in the extra word to discard if that's necessary.
    ;; 
    ;; These bits are be packed into the value that .SPcallback
    ;; receives in %eax.  Bits 0 through 22 are the callback index.
    (if info
      (setf (ldb (byte 23 0) info) index)
      (setq info index))
    (setf (%get-unsigned-byte p 0) #xb8 ; movl $n,%eax
          (%get-unsigned-byte p 1) (ldb (byte 8 0) info)
          (%get-unsigned-byte p 2) (ldb (byte 8 8) info)
          (%get-unsigned-byte p 3) (ldb (byte 8 16) info)
          (%get-unsigned-byte p 4) (ldb (byte 8 24) info)
          (%get-unsigned-byte p 5) #xff  ; jmp *
          (%get-unsigned-byte p 6) #x24
          (%get-unsigned-byte p 7) #x25
          (%get-unsigned-byte p 8) (ldb (byte 8 0) addr)
          (%get-unsigned-byte p 9) (ldb (byte 8 8) addr)
          (%get-unsigned-byte p 10) (ldb (byte 8 16) addr)
          (%get-unsigned-byte p 11) (ldb (byte 8 24) addr))
    p))
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/x86-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-processes.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


;; L1-processes.lisp

(cl:in-package "CCL")


(let* ((all-processes ())
       (shutdown-processes ())
       (all-processes-lock (make-lock)))
  (defun add-to-all-processes (p)
    (with-lock-grabbed (all-processes-lock)
      (pushnew p all-processes :test #'eq)
      p))
  (defun remove-from-all-processes (p)
    (with-lock-grabbed (all-processes-lock)
      (setq all-processes (delete p all-processes))
      t))
  (defun all-processes ()
    "Obtain a fresh list of all known Lisp threads."
    (with-lock-grabbed (all-processes-lock)
      (copy-list all-processes)))
  (defun shutdown-processes ()
    (with-lock-grabbed (all-processes-lock)
      (copy-list shutdown-processes)))
  (defun %clear-shutdown-proceses ()
    (setq shutdown-processes nil))
  (defun add-to-shutdown-processes (p)
    (with-lock-grabbed (all-processes-lock)
      (pushnew p shutdown-processes :test #'eq))
    t)
  (defun pop-shutdown-processes ()
    (with-lock-grabbed (all-processes-lock)
      (pop shutdown-processes)))
  (defun find-process (id)
    (etypecase id
      (process id)
      (integer (with-lock-grabbed (all-processes-lock)
		 (find id all-processes
		       :key #'(lambda (p)
				(process-serial-number p)))))
      (string (with-lock-grabbed (all-processes-lock)
		(find id all-processes
		      :key #'(lambda (p)
			       (process-name p))
		      :test #'equal))))))



(defun not-in-current-process (p operation)
  (if (eq p *current-process*)
    (error "The current process (~s) can't perform the ~a operation on itself."
	   p operation)))

(defun startup-shutdown-processes ()
  (let* ((p))
    (loop
      (unless (setq p (pop-shutdown-processes)) (return))
      (new-tcr-for-thread (process-thread p))
      (%process-preset-internal p)
      (process-enable p)
      )))

;;; Done with a queue-fixup so that it will be the last thing
;;; that happens on startup.
(queue-fixup
 (pushnew 'startup-shutdown-processes *lisp-system-pointer-functions*))







(defun wrap-initial-bindings (alist)
  (mapcar #'(lambda (pair)
              (destructuring-bind (symbol . valform) pair
                (cons (require-type symbol 'symbol)
                      (cond ((symbolp valform)
                             (constantly (symbol-value valform)))
                            ((typep valform 'function) valform)
                            ((consp valform)
                             (if (eq (car valform) 'quote)
                               (constantly (cadr valform))
                               #'(lambda () (apply (car valform) (cdr valform)))))
                            (t
                             (constantly valform))))))
          alist))


(defun valid-allocation-quantum-p (x)
  (and (>= x *host-page-size*)
       (<= x (default-allocation-quantum))
       (= (logcount x) 1)))

  
(let* ((psn -1))
  (defun %new-psn () (incf psn)))

(defclass process ()
    ((name :initform nil :initarg :name :accessor process-name)
     (thread :initarg :thread :initform nil :accessor process-thread)
     (initial-form :initform (cons nil nil) :reader process-initial-form)
     (priority :initform 0 :initarg :priority :accessor process-priority)
     (persistent :initform nil :initarg :persistent :reader process-persistent)
     (splice :initform (cons nil nil) :accessor process-splice)
     (initial-bindings :initform nil :initarg :initial-bindings
		       :accessor process-initial-bindings)
     (serial-number :initform (%new-psn) :accessor process-serial-number)
     (creation-time :initform (get-tick-count) :reader process-creation-time)
     (total-run-time :initform nil :accessor %process-total-run-time)
     (ui-object :initform (application-ui-object *application*)
                :accessor process-ui-object)
     (termination-semaphore :initform nil
                            :initarg :termination-semaphore
                            :accessor process-termination-semaphore
                            :type (or null semaphore))
     (allocation-quantum :initform (default-allocation-quantum)
                         :initarg :allocation-quantum
                         :reader process-allocation-quantum
                         :type (satisfies valid-allocation-quantum-p))
     (plist :initform nil :accessor process-plist)
     (dribble-stream :initform nil)
     (dribble-saved-terminal-io :initform nil)
     (result :initform (cons nil nil)
             :reader process-result)
     (whostate-cell :initform (list "Reset")
                    :reader process-whostate-cell))
  (:primary-p t))

(defparameter *print-process-whostate* t "make it optional")

(defmethod print-object ((p process) s)
  (print-unreadable-object (p s :type t :identity t)
    (format s "~a(~d)" (process-name p)
	    (process-serial-number p))
    (when *print-process-whostate*
      (format s " [~a]" (process-whostate p)))))

(defvar *process-class* (find-class 'process))

(defun processp (p)
  (memq *process-class* (class-precedence-list (class-of p))))

(set-type-predicate 'process 'processp)

(defun make-process (name &key 
			  thread
			  persistent
                          (priority 0)
                          (stack-size *default-control-stack-size*)
                          (vstack-size *default-value-stack-size*)
                          (tstack-size *default-temp-stack-size*)
                          (initial-bindings ())
			  (use-standard-initial-bindings t)
                          (class (find-class 'process))
                          (initargs nil)
                          (termination-semaphore ())
                          (allocation-quantum (default-allocation-quantum)))
  "Create and return a new process."
  (let* ((p (apply #'make-instance
	     class
	     :name name
	     :priority priority
	     :persistent persistent
	     :initial-bindings (append (if use-standard-initial-bindings
					 (standard-initial-bindings))
				       (wrap-initial-bindings
					initial-bindings))
             :termination-semaphore (or termination-semaphore
                                        (make-semaphore))
             :allocation-quantum allocation-quantum
             initargs)))
    (with-slots ((lisp-thread thread)) p
      (unless lisp-thread
        (setq lisp-thread
              (or thread
                  (new-thread name stack-size  vstack-size  tstack-size)))))
    (add-to-all-processes p)
    (setf (car (process-splice p)) p)
    p))


(defstatic *initial-process*
    (let* ((p (make-process
	       "Initial"
	       :thread *initial-lisp-thread*
	       :priority 0)))
      p))


(defvar *current-process* *initial-process*
  "Bound in each process, to that process itself.")

(defstatic *interactive-abort-process* *initial-process*)




(defun process-tcr (p)
  (lisp-thread.tcr (process-thread p)))



(defun process-exhausted-p (p)
  (let* ((thread (process-thread p)))
    (or (null thread)
	(thread-exhausted-p thread))))
  
;;; This should be way more concerned about being correct and thread-safe
;;; than about being quick: it's generally only called while printing
;;; or debugging, and there are all kinds of subtle race conditions
;;; here.
(defun process-whostate (p)
  "Return a string which describes the status of a specified process."
  (car (process-whostate-cell p)))

(defun (setf process-whostate) (new p)
  (setf (car (process-whostate-cell p)) new))



(defun process-total-run-time (p)
  (or (%process-total-run-time p)
      (thread-total-run-time (process-thread p))))




(defun initial-bindings (alist)
  (let* ((symbols ())
	 (values ()))
    (dolist (a alist (values (nreverse symbols) (nreverse values)))
      (push (car a) symbols)
      (push (funcall (cdr a)) values))))


                            
(defun symbol-value-in-process (sym process)
  (if (eq process *current-process*)
    (symbol-value sym)
    (let* ((val
            (without-interrupts
             (with-lock-grabbed (*kernel-exception-lock*)
               (with-lock-grabbed (*kernel-tcr-area-lock*)
                 (let* ((tcr (process-tcr process)))
                   (if tcr
                     (symbol-value-in-tcr sym tcr)
                     (%sym-global-value sym))))))))
      (if (eq val (%unbound-marker))
        ;; This might want to be a CELL-ERROR.
        (error "~S is unbound in ~S." sym process)
        val))))

(defun (setf symbol-value-in-process) (value sym process)
  (if (eq process *current-process*)
    (setf (symbol-value sym) value)
    (with-lock-grabbed (*kernel-exception-lock*)
      (with-lock-grabbed (*kernel-tcr-area-lock*)
        (let* ((tcr (process-tcr process)))
          (if tcr
            (setf (symbol-value-in-tcr sym tcr) value)
            (%set-sym-global-value sym value)))))))


(defmethod process-enable ((p process) &optional (wait (* 60 60 24) wait-p))
  "Begin executing the initial function of a specified process."
  (not-in-current-process p 'process-enable)
  (when wait-p
    (check-type wait (unsigned-byte 32)))
  (unless (car (process-initial-form p))
    (error "Process ~s has not been preset.  Use PROCESS-PRESET to preset the process." p))
  (let* ((thread (process-thread p)))
    (do* ((total-wait wait (+ total-wait wait)))
	 ((thread-enable thread (process-termination-semaphore p) (1- (integer-length (process-allocation-quantum p)))  wait)
          (process-tcr-enable p (lisp-thread.tcr thread))
	  p)
      (cerror "Keep trying."
	      "Unable to enable process ~s; have been trying for ~s seconds."
	      p total-wait))))

(defmethod process-tcr-enable ((process process) tcr)
  (when (and tcr (not (eql 0 tcr)))
    #+(and windows-target x8632-target)
    (let ((aux (%fixnum-ref tcr (- target::tcr.aux target::tcr-bias))))
      (%signal-semaphore-ptr (%fixnum-ref-macptr aux target::tcr-aux.activate)))
    #-(and windows-target x8632-target)
    (%signal-semaphore-ptr (%fixnum-ref-macptr tcr target::tcr.activate))
    ))



(defun process-resume (p)
  "Resume a specified process which had previously been suspended
by process-suspend."
  (setq p (require-type p 'process))
  (let* ((tcr (process-tcr p)))
    (and tcr (%resume-tcr tcr))))

(defun process-suspend (p)
  "Suspend a specified process."
  (setq p (require-type p 'process))
  (if (eq p *current-process*)
    (error "Suspending the current process can't work.  ~&(If the documentation claims otherwise, it's incorrect.)")
    (let* ((tcr (process-tcr p)))
      (and tcr (%suspend-tcr tcr)))))

(defun process-suspend-count (p)
  "Return the number of currently-pending suspensions applicable to
a given process."
  (setq p (require-type p 'process))
  (let* ((thread (process-thread p)))
    (if thread
      (lisp-thread-suspend-count thread))))

(defun process-active-p (p)
  (setq p (require-type p 'process))
  (and (eql 0 (process-suspend-count p))
       (not (process-exhausted-p p))))
  
;;; Used by process-run-function
(defmethod process-preset ((p process) function &rest args)
  "Set the initial function and arguments of a specified process."
  (let* ((f (require-type function 'function))
         (initial-form (process-initial-form p)))
    (declare (type cons initial-form))
    (not-in-current-process p 'process-preset)
    ; Not quite right ...
    (rplaca initial-form f)
    (rplacd initial-form args)
    (%process-preset-internal p)))

(defmethod %process-preset-internal ((process process))
   (let* ((initial-form (process-initial-form process))
         (thread (process-thread process)))
     (declare (type cons initial-form))
     (thread-preset
      thread
      #'(lambda (process initial-form)
	  (let* ((*current-process* process))
	    (add-to-all-processes process)
            (with-initial-bindings (process-initial-bindings process)
              (with-interrupts-enabled
                  (with-process-whostate ("Active")
                    (run-process-initial-form process initial-form))))))
      process
      initial-form)
     process))


(defun run-process-initial-form (process initial-form)
  (let* ((exited nil)
	 (kill (handler-case
		   (restart-case
		    (let ((values
                           (multiple-value-list
                            (apply (car initial-form)
                                   (cdr (the list initial-form)))))
                          (result (process-result process)))
                      (setf (cdr result) values
                            (car result) t)
		      (setq exited t)
		      nil)
                    (abort-break () :report "Reset this thread")
		    (abort () :report "Kill this thread" (setq exited t)))
		 (process-reset (condition)
		   (process-reset-kill condition)))))
    ;; We either exited from the initial form normally, were told to
    ;; exit prematurely, or are being reset and should enter the
    ;; "awaiting preset" state.
    (if (or kill exited) 
      (unless (eq kill :toplevel)
	(process-initial-form-exited process (or kill t)))
      (progn
	(thread-change-state (process-thread process) :run :reset)
	(tcr-set-preset-state (process-tcr process))))
    nil))

;;; Separated from run-process-initial-form just so I can change it easily.
(defun process-initial-form-exited (process kill)
  (without-interrupts
   (if (eq kill :shutdown)
     (progn
       (setf (car (process-whostate-cell process)) "Shutdown")
       (add-to-shutdown-processes process)))
   (let* ((semaphore (process-termination-semaphore process)))
     (when semaphore (signal-semaphore semaphore)))
   (maybe-finish-process-kill process kill)))

(defun maybe-finish-process-kill (process kill)
  (when (and kill (neq kill :shutdown))
    (setf (process-whostate process) "Dead")
    (remove-from-all-processes process)
    (let ((thread (process-thread process)))
      (unless (or (eq thread *current-lisp-thread*)
                  (thread-exhausted-p thread))
        (kill-lisp-thread thread))))
  nil)


 

(defun require-global-symbol (s &optional env)
  (let* ((s (require-type s 'symbol))
	 (bits (%symbol-bits s)))
    (unless (or (logbitp $sym_vbit_global bits)
		(let* ((defenv (if env (definition-environment env))))
		  (if defenv
		    (eq :global (%cdr (assq s (defenv.specials defenv)))))))
      (error "~s not defined with ~s" s 'defstatic))
    s))


(defmethod print-object ((s lock) stream)
  (print-unreadable-object (s stream :type t :identity t)
    (let* ((val (uvref s target::lock._value-cell))
	   (name (uvref s target::lock.name-cell)))
      (when name
	(format stream "~s " name))
      (if (typep val 'macptr)
        (format stream "[ptr @ #x~x]"
                (%ptr-to-int val))))))

(defun lockp (l)
  (eq target::subtag-lock (typecode l)))

(set-type-predicate 'lock 'lockp)

(defun recursive-lock-p (l)
  (and (eq target::subtag-lock (typecode l))
       (eq 'recursive-lock (%svref l target::lock.kind-cell))))

(defun read-write-lock-p (l)
  (and (eq target::subtag-lock (typecode l))
       (eq 'read-write-lock (%svref l target::lock.kind-cell))))

(setf (type-predicate 'recursive-lock) 'recursive-lock-p
      (type-predicate 'read-write-lock) 'read-write-lock-p)


(defun grab-lock (lock &optional flag)
  "Wait until a given lock can be obtained, then obtain it."
  (%lock-recursive-lock-object lock flag))

(defun release-lock (lock)
  "Relinquish ownership of a given lock."
  (%unlock-recursive-lock-object lock))

(defun try-lock (lock &optional flag)
  "Obtain the given lock, but only if it is not necessary to wait for it."
  (%try-recursive-lock-object lock flag))

(defun lock-acquisition-status (thing)
  (if (istruct-typep thing 'lock-acquisition)
    (lock-acquisition.status thing)
    (report-bad-arg thing 'lock-acquisition)))

(defun clear-lock-acquisition-status (thing)
  (if (istruct-typep thing 'lock-acquisition)
    (setf (lock-acquisition.status thing) nil)
    (report-bad-arg thing 'lock-acquisition)))

(defmethod print-object ((l lock-acquisition) stream)
  (print-unreadable-object (l stream :type t :identity t)
    (format stream "[status = ~s]" (lock-acquisition-status l))))

(defun semaphore-notification-status (thing)
  (if (istruct-typep thing 'semaphore-notification)
    (semaphore-notification.status thing)
    (report-bad-arg thing 'semaphore-notification)))

(defun clear-semaphore-notification-status (thing)
  (if (istruct-typep thing 'semaphore-notification)
    (setf (semaphore-notification.status thing) nil)
    (report-bad-arg thing 'semaphore-notification)))

(defmethod print-object ((l semaphore-notification) stream)
  (print-unreadable-object (l stream :type t :identity t)
    (format stream "[status = ~s]" (semaphore-notification-status l))))

(defun process-wait (whostate function &rest args)
  "Causes the current lisp process (thread) to wait for a given
predicate to return true."
  (declare (dynamic-extent args))
  (or (apply function args)
      (with-process-whostate (whostate)
        (loop
          (when (apply function args)
            (return))
          ;; Sleep for a tick
          #-windows-target
          (%nanosleep 0 *ns-per-tick*)
          #+windows-target
          (%windows-sleep 5)))))



(defun process-wait-with-timeout (whostate time function &rest args)
  "Cause the current thread to wait for a given predicate to return true,
or for a timeout to expire. Time is in ticks."
  (declare (dynamic-extent args))
  (cond ((null time)  (apply #'process-wait whostate function args) t)
        (t (let* ((win nil)
                  (when (+ (get-tick-count) time))
                  (f #'(lambda () (let ((val (apply function args)))
                                    (if val
                                      (setq win val)
                                      (> (get-tick-count) when))))))
             (declare (dynamic-extent f))
             (process-wait whostate f)
             win))))


(defmethod process-interrupt ((process process) function &rest args)
  "Arrange for the target process to invoke a specified function at
some point in the near future, and then return to what it was doing."
  (let* ((p (require-type process 'process)))
    (if (eq p *current-process*)
      (progn
        (apply function args)
        t)
      (thread-interrupt
       (process-thread p)
       process
       #'apply
       function args))))

(defmethod process-debug-condition ((p process) condition frame-pointer)
  (declare (ignore condition frame-pointer)))




;;; This one is in the Symbolics documentation
(defun process-allow-schedule ()
  "Used for cooperative multitasking; probably never necessary."
  (process-yield *current-process*))


;;; something unique that users won't get their hands on
(defun process-reset-tag (process)
  (process-splice process))

(defun process-run-function (name-or-keywords function &rest args)
  "Create a process, preset it, and enable it."
  (if (listp name-or-keywords)
    (%process-run-function name-or-keywords function args)
    (let ((keywords (list :name name-or-keywords)))
      (declare (dynamic-extent keywords))
      (%process-run-function keywords function args))))

(defun %process-run-function (keywords function args)
  (destructuring-bind (&key (name "Anonymous")
                            (priority  0)
			    (stack-size *default-control-stack-size*)
			    (vstack-size *default-value-stack-size*)
			    (tstack-size *default-temp-stack-size*)
                            (persistent nil)
			    (initial-bindings ())
			    (use-standard-initial-bindings t)
                            (class (find-class 'process))
                            (initargs nil)
                            (termination-semaphore nil)
                            (allocation-quantum (default-allocation-quantum)))
                      keywords
    (setq priority (require-type priority 'fixnum))
    (let* ((process (make-process name
                                  :priority priority
                                  :stack-size stack-size
				  :vstack-size vstack-size
				  :tstack-size tstack-size
                                  :persistent persistent
				  :use-standard-initial-bindings use-standard-initial-bindings
				  :initial-bindings initial-bindings
                                  :class class
                                  :initargs initargs
                                  :termination-semaphore termination-semaphore
                                  :allocation-quantum allocation-quantum)))
      (process-preset process #'(lambda () (apply function args)))
      (process-enable process)
      process)))

(defmethod process-reset ((process process) &optional kill)
  "Cause a specified process to cleanly exit from any ongoing computation."
  (setq process (require-type process 'process))
  (unless (memq kill '(nil :kill :shutdown))
    (setq kill (require-type kill '(member nil :kill :shutdown))))
  (if (eq process *current-process*)
    (%process-reset kill)
    (if (process-exhausted-p process)
      (maybe-finish-process-kill process kill)
      (progn
	(process-interrupt process '%process-reset kill)))))

(defmethod process-yield ((p process))
  #+windows-target (#_Sleep 0)
  #-windows-target (#_sched_yield))


(defun %process-reset (kill)
  (signal 'process-reset :kill kill)
  (maybe-finish-process-kill *current-process* kill))

;;; By default, it's just fine with the current process
;;; if the application/user wants to quit.
(defmethod process-verify-quit ((process process))
  t)

(defmethod process-exit-application ((process process) thunk)
  (when (eq process *initial-process*)
    (with-standard-abort-handling "Exit Lisp"
      (prepare-to-quit)
      ;; We may have abruptly terminated a thread which owned the
      ;; output lock on a stream we want to flush.  Don't block
      ;; waiting on the lock if so.
      (flet ((flush-stream (s)
	       (let* ((lock (ioblock-outbuf-lock (basic-stream-ioblock s)))
		      (locked (make-lock-acquisition)))
		 (declare (dynamic-extent locked))
		 (when (or (null lock)
			   (%try-recursive-lock-object lock locked))
		   (unwind-protect
			(progn
			  (fresh-line s)
			  (finish-output s))
		     (when (lock-acquisition.status locked)
		       (release-lock lock)))))))
	(flush-stream *stdout*)
	(flush-stream *stderr*)))
    (%set-toplevel thunk)
    (toplevel)))



(defmethod process-kill ((process process))
  "Cause a specified process to cleanly exit from any ongoing
computation, and then exit."
  (and (process-interrupt process #'%process-reset :kill)
       (setf (process-kill-issued process) t)))

(defun process-abort (process &optional condition)
  "Cause a specified process to process an abort condition, as if it
had invoked abort."
  (process-interrupt process
                     #'(lambda ()
                         (abort condition))))

(defmethod process-reset-and-enable ((process process))
  (not-in-current-process process 'process-reset-and-enable)
  (process-reset process)
  (process-enable process))

(defmethod process-kill-issued ((process process))
  (cdr (process-splice process)))

(defmethod (setf process-kill-issued) (val (process process))
  (setf (cdr (process-splice process)) val))

(defun tcr->process (tcr)
  (dolist (p (all-processes))
    (when (eq tcr (process-tcr p))
      (return p))))

(defun current-process-allocation-quantum ()
  (process-allocation-quantum *current-process*))

(defun (setf current-process-allocation-quantum) (new)
  (if (valid-allocation-quantum-p new)
    (with-macptrs (tcrp)
      (%setf-macptr-to-object tcrp (%current-tcr))
      #+(and windows-target x8632-target)
      (let ((aux (%get-ptr tcrp (- target::tcr.aux target::tcr-bias))))
	(setf (%get-natural aux target::tcr-aux.log2-allocation-quantum)
	      (1- (integer-length new))))
      #-(and windows-target x8632-target)
      (setf (%get-natural tcrp target::tcr.log2-allocation-quantum)
            (1- (integer-length new)))
      (setf (slot-value *current-process* 'allocation-quantum) new)
      new)
    (report-bad-arg new '(satisfies valid-allocation-quantum-p))))


(def-standard-initial-binding *backtrace-contexts* nil)

(defmethod exit-interactive-process ((p process))
  (unless (eq p *initial-process*)
    (when (eq p *current-process*)
      (process-kill p))))

(defclass tty-listener (process)
    ())

(defmethod exit-interactive-process ((p tty-listener))
  (when (eq p *current-process*)
    (quit)))

(defmethod process-stop-dribbling ((p process))
  (with-slots (dribble-stream dribble-saved-terminal-io) p
    (when dribble-stream
      (close dribble-stream)
      (setq dribble-stream nil))
    (when dribble-saved-terminal-io
      (setq *terminal-io* dribble-saved-terminal-io
            dribble-saved-terminal-io nil))))

(defmethod process-dribble ((p process) path)
  (with-slots (dribble-stream dribble-saved-terminal-io) p
    (process-stop-dribbling p)
    (when path
      (let* ((in (two-way-stream-input-stream *terminal-io*))
             (out (two-way-stream-output-stream *terminal-io*))
             (f (open path :direction :output :if-exists :append 
                      :if-does-not-exist :create)))
        (without-interrupts
         (setq dribble-stream f
               dribble-saved-terminal-io *terminal-io*
               *terminal-io* (make-echoing-two-way-stream
                              (make-echo-stream in f)
                              (make-broadcast-stream out f)))))
      path)))

(defmethod join-process ((p process) &key default)
  (wait-on-semaphore (process-termination-semaphore p) nil "join-process")
  (let ((result (process-result p)))
    (cond ((car result) (values-list (cdr result)))
          (t default))))

(defun call-in-process (f process)
  (let* ((return-values nil)
	 (done (make-semaphore)))
    (process-interrupt process
		       #'(lambda ()
			   (unwind-protect
				(progn
				  (setq return-values
					(multiple-value-list (funcall f))))
			     (signal-semaphore done))))
    (wait-on-semaphore done)
    (apply #'values return-values)))

(defun call-in-initial-process (f)
  (call-in-process f *initial-process*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-processes.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-cl-package.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; l1-cl-package.lisp

(in-package "CCL")


(eval-when (:compile-toplevel :execute)
  (defconstant %lisp-symbols%  
    '("&ALLOW-OTHER-KEYS" 
      "&AUX" 
      "&BODY" 
      "&ENVIRONMENT" 
      "&KEY" 
      "&OPTIONAL" 
      "&REST" 
      "&WHOLE" 
      "*" 
      "**" 
      "***" 
      "*BREAK-ON-SIGNALS*" 
      "*COMPILE-FILE-PATHNAME*" 
      "*COMPILE-FILE-TRUENAME*" 
      "*COMPILE-PRINT*" 
      "*COMPILE-VERBOSE*" 
      "*DEBUG-IO*" 
      "*DEBUGGER-HOOK*" 
      "*DEFAULT-PATHNAME-DEFAULTS*" 
      "*ERROR-OUTPUT*" 
      "*FEATURES*" 
      "*GENSYM-COUNTER*" 
      "*LOAD-PATHNAME*" 
      "*LOAD-PRINT*" 
      "*LOAD-TRUENAME*" 
      "*LOAD-VERBOSE*" 
      "*MACROEXPAND-HOOK*" 
      "*MODULES*" 
      "*PACKAGE*" 
      "*PRINT-ARRAY*" 
      "*PRINT-BASE*" 
      "*PRINT-CASE*" 
      "*PRINT-CIRCLE*" 
      "*PRINT-ESCAPE*" 
      "*PRINT-GENSYM*" 
      "*PRINT-LENGTH*" 
      "*PRINT-LEVEL*" 
      "*PRINT-LINES*" 
      "*PRINT-MISER-WIDTH*" 
      "*PRINT-PPRINT-DISPATCH*" 
      "*PRINT-PRETTY*" 
      "*PRINT-RADIX*" 
      "*PRINT-READABLY*" 
      "*PRINT-RIGHT-MARGIN*" 
      "*QUERY-IO*" 
      "*RANDOM-STATE*" 
      "*READ-BASE*" 
      "*READ-DEFAULT-FLOAT-FORMAT*" 
      "*READ-EVAL*" 
      "*READ-SUPPRESS*" 
      "*READTABLE*" 
      "*STANDARD-INPUT*" 
      "*STANDARD-OUTPUT*" 
      "*TERMINAL-IO*" 
      "*TRACE-OUTPUT*" 
      "+" 
      "++" 
      "+++" 
      "-" 
      "/" 
      "//" 
      "///" 
      "/=" 
      "1+" 
      "1-" 
      "<" 
      "<=" 
      "=" 
      ">" 
      ">=" 
      "ABORT" 
      "ABS" 
      "ACONS" 
      "ACOS" 
      "ACOSH" 
      "ADD-METHOD" 
      "ADJOIN" 
      "ADJUST-ARRAY" 
      "ADJUSTABLE-ARRAY-P" 
      "ALLOCATE-INSTANCE" 
      "ALPHA-CHAR-P" 
      "ALPHANUMERICP" 
      "AND" 
      "APPEND" 
      "APPLY" 
      "APROPOS" 
      "APROPOS-LIST" 
      "AREF" 
      "ARITHMETIC-ERROR" 
      "ARITHMETIC-ERROR-OPERANDS" 
      "ARITHMETIC-ERROR-OPERATION" 
      "ARRAY" 
      "ARRAY-DIMENSION" 
      "ARRAY-DIMENSION-LIMIT" 
      "ARRAY-DIMENSIONS" 
      "ARRAY-DISPLACEMENT" 
      "ARRAY-ELEMENT-TYPE" 
      "ARRAY-HAS-FILL-POINTER-P" 
      "ARRAY-IN-BOUNDS-P" 
      "ARRAY-RANK" 
      "ARRAY-RANK-LIMIT" 
      "ARRAY-ROW-MAJOR-INDEX" 
      "ARRAY-TOTAL-SIZE" 
      "ARRAY-TOTAL-SIZE-LIMIT" 
      "ARRAYP" 
      "ASH" 
      "ASIN" 
      "ASINH" 
      "ASSERT" 
      "ASSOC" 
      "ASSOC-IF" 
      "ASSOC-IF-NOT" 
      "ATAN" 
      "ATANH" 
      "ATOM" 
      "BASE-CHAR" 
      "BASE-STRING" 
      "BIGNUM" 
      "BIT" 
      "BIT-AND" 
      "BIT-ANDC1" 
      "BIT-ANDC2" 
      "BIT-EQV" 
      "BIT-IOR" 
      "BIT-NAND" 
      "BIT-NOR" 
      "BIT-NOT" 
      "BIT-ORC1" 
      "BIT-ORC2" 
      "BIT-VECTOR" 
      "BIT-VECTOR-P" 
      "BIT-XOR" 
      "BLOCK" 
      "BOOLE" 
      "BOOLE-1" 
      "BOOLE-2" 
      "BOOLE-AND" 
      "BOOLE-ANDC1" 
      "BOOLE-ANDC2" 
      "BOOLE-C1" 
      "BOOLE-C2" 
      "BOOLE-CLR" 
      "BOOLE-EQV" 
      "BOOLE-IOR" 
      "BOOLE-NAND" 
      "BOOLE-NOR" 
      "BOOLE-ORC1" 
      "BOOLE-ORC2" 
      "BOOLE-SET" 
      "BOOLE-XOR" 
      "BOOLEAN" 
      "BOTH-CASE-P" 
      "BOUNDP" 
      "BREAK" 
      "BROADCAST-STREAM" 
      "BROADCAST-STREAM-STREAMS" 
      "BUILT-IN-CLASS" 
      "BUTLAST" 
      "BYTE" 
      "BYTE-POSITION" 
      "BYTE-SIZE" 
      "CAAAAR" 
      "CAAADR" 
      "CAAAR" 
      "CAADAR" 
      "CAADDR" 
      "CAADR" 
      "CAAR" 
      "CADAAR" 
      "CADADR" 
      "CADAR" 
      "CADDAR" 
      "CADDDR" 
      "CADDR" 
      "CADR" 
      "CALL-ARGUMENTS-LIMIT" 
      "CALL-METHOD" 
      "CALL-NEXT-METHOD" 
      "CAR" 
      "CASE" 
      "CATCH" 
      "CCASE" 
      "CDAAAR" 
      "CDAADR" 
      "CDAAR" 
      "CDADAR" 
      "CDADDR" 
      "CDADR" 
      "CDAR" 
      "CDDAAR" 
      "CDDADR" 
      "CDDAR" 
      "CDDDAR" 
      "CDDDDR" 
      "CDDDR" 
      "CDDR" 
      "CDR" 
      "CEILING" 
      "CELL-ERROR" 
      "CELL-ERROR-NAME" 
      "CERROR" 
      "CHANGE-CLASS" 
      "CHAR" 
      "CHAR-CODE" 
      "CHAR-CODE-LIMIT" 
      "CHAR-DOWNCASE" 
      "CHAR-EQUAL" 
      "CHAR-GREATERP" 
      "CHAR-INT" 
      "CHAR-LESSP" 
      "CHAR-NAME" 
      "CHAR-NOT-EQUAL" 
      "CHAR-NOT-GREATERP" 
      "CHAR-NOT-LESSP" 
      "CHAR-UPCASE" 
      "CHAR/=" 
      "CHAR<" 
      "CHAR<=" 
      "CHAR=" 
      "CHAR>" 
      "CHAR>=" 
      "CHARACTER" 
      "CHARACTERP" 
      "CHECK-TYPE" 
      "CIS" 
      "CLASS" 
      "CLASS-NAME" 
      "CLASS-OF" 
      "CLEAR-INPUT" 
      "CLEAR-OUTPUT" 
      "CLOSE" 
      "CLRHASH" 
      "CODE-CHAR" 
      "COERCE" 
      "COMPILATION-SPEED" 
      "COMPILE" 
      "COMPILE-FILE" 
      "COMPILE-FILE-PATHNAME" 
      "COMPILED-FUNCTION" 
      "COMPILED-FUNCTION-P" 
      "COMPILER-MACRO" 
      "COMPILER-MACRO-FUNCTION" 
      "COMPLEMENT" 
      "COMPLEX" 
      "COMPLEXP" 
      "COMPUTE-APPLICABLE-METHODS" 
      "COMPUTE-RESTARTS" 
      "CONCATENATE" 
      "CONCATENATED-STREAM" 
      "CONCATENATED-STREAM-STREAMS" 
      "COND" 
      "CONDITION" 
      "CONJUGATE" 
      "CONS" 
      "CONSP" 
      "CONSTANTLY" 
      "CONSTANTP" 
      "CONTINUE" 
      "CONTROL-ERROR" 
      "COPY-ALIST" 
      "COPY-LIST" 
      "COPY-PPRINT-DISPATCH" 
      "COPY-READTABLE" 
      "COPY-SEQ" 
      "COPY-STRUCTURE" 
      "COPY-SYMBOL" 
      "COPY-TREE" 
      "COS" 
      "COSH" 
      "COUNT" 
      "COUNT-IF" 
      "COUNT-IF-NOT" 
      "CTYPECASE" 
      "DEBUG" 
      "DECF" 
      "DECLAIM" 
      "DECLARATION" 
      "DECLARE" 
      "DECODE-FLOAT" 
      "DECODE-UNIVERSAL-TIME" 
      "DEFCLASS" 
      "DEFCONSTANT" 
      "DEFGENERIC" 
      "DEFINE-COMPILER-MACRO" 
      "DEFINE-CONDITION" 
      "DEFINE-METHOD-COMBINATION" 
      "DEFINE-MODIFY-MACRO" 
      "DEFINE-SETF-EXPANDER" 
      "DEFINE-SYMBOL-MACRO" 
      "DEFMACRO" 
      "DEFMETHOD" 
      "DEFPACKAGE" 
      "DEFPARAMETER" 
      "DEFSETF" 
      "DEFSTRUCT" 
      "DEFTYPE" 
      "DEFUN" 
      "DEFVAR" 
      "DELETE" 
      "DELETE-DUPLICATES" 
      "DELETE-FILE" 
      "DELETE-IF" 
      "DELETE-IF-NOT" 
      "DELETE-PACKAGE" 
      "DENOMINATOR" 
      "DEPOSIT-FIELD" 
      "DESCRIBE" 
      "DESCRIBE-OBJECT" 
      "DESTRUCTURING-BIND" 
      "DIGIT-CHAR" 
      "DIGIT-CHAR-P" 
      "DIRECTORY" 
      "DIRECTORY-NAMESTRING" 
      "DISASSEMBLE" 
      "DIVISION-BY-ZERO" 
      "DO" 
      "DO*" 
      "DO-ALL-SYMBOLS" 
      "DO-EXTERNAL-SYMBOLS" 
      "DO-SYMBOLS" 
      "DOCUMENTATION" 
      "DOLIST" 
      "DOTIMES" 
      "DOUBLE-FLOAT" 
      "DOUBLE-FLOAT-EPSILON" 
      "DOUBLE-FLOAT-NEGATIVE-EPSILON" 
      "DPB" 
      "DRIBBLE" 
      "DYNAMIC-EXTENT" 
      "ECASE" 
      "ECHO-STREAM" 
      "ECHO-STREAM-INPUT-STREAM" 
      "ECHO-STREAM-OUTPUT-STREAM" 
      "ED" 
      "EIGHTH" 
      "ELT" 
      "ENCODE-UNIVERSAL-TIME" 
      "END-OF-FILE" 
      "ENDP" 
      "ENOUGH-NAMESTRING" 
      "ENSURE-DIRECTORIES-EXIST" 
      "ENSURE-GENERIC-FUNCTION" 
      "EQ" 
      "EQL" 
      "EQUAL" 
      "EQUALP" 
      "ERROR" 
      "ETYPECASE" 
      "EVAL" 
      "EVAL-WHEN" 
      "EVENP" 
      "EVERY" 
      "EXP" 
      "EXPORT" 
      "EXPT" 
      "EXTENDED-CHAR" 
      "FBOUNDP" 
      "FCEILING" 
      "FDEFINITION" 
      "FFLOOR" 
      "FIFTH" 
      "FILE-AUTHOR" 
      "FILE-ERROR" 
      "FILE-ERROR-PATHNAME" 
      "FILE-LENGTH" 
      "FILE-NAMESTRING" 
      "FILE-POSITION" 
      "FILE-STREAM" 
      "FILE-STRING-LENGTH" 
      "FILE-WRITE-DATE" 
      "FILL" 
      "FILL-POINTER" 
      "FIND" 
      "FIND-ALL-SYMBOLS" 
      "FIND-CLASS" 
      "FIND-IF" 
      "FIND-IF-NOT" 
      "FIND-METHOD" 
      "FIND-PACKAGE" 
      "FIND-RESTART" 
      "FIND-SYMBOL" 
      "FINISH-OUTPUT" 
      "FIRST" 
      "FIXNUM" 
      "FLET" 
      "FLOAT" 
      "FLOAT-DIGITS" 
      "FLOAT-PRECISION" 
      "FLOAT-RADIX" 
      "FLOAT-SIGN" 
      "FLOATING-POINT-INEXACT" 
      "FLOATING-POINT-INVALID-OPERATION" 
      "FLOATING-POINT-OVERFLOW" 
      "FLOATING-POINT-UNDERFLOW" 
      "FLOATP" 
      "FLOOR" 
      "FMAKUNBOUND" 
      "FORCE-OUTPUT" 
      "FORMAT" 
      "FORMATTER" 
      "FOURTH" 
      "FRESH-LINE" 
      "FROUND" 
      "FTRUNCATE" 
      "FTYPE" 
      "FUNCALL" 
      "FUNCTION" 
      "FUNCTION-KEYWORDS" 
      "FUNCTION-LAMBDA-EXPRESSION" 
      "FUNCTIONP" 
      "GCD" 
      "GENERIC-FUNCTION" 
      "GENSYM" 
      "GENTEMP" 
      "GET" 
      "GET-DECODED-TIME" 
      "GET-DISPATCH-MACRO-CHARACTER" 
      "GET-INTERNAL-REAL-TIME" 
      "GET-INTERNAL-RUN-TIME" 
      "GET-MACRO-CHARACTER" 
      "GET-OUTPUT-STREAM-STRING" 
      "GET-PROPERTIES" 
      "GET-SETF-EXPANSION" 
      "GET-UNIVERSAL-TIME" 
      "GETF" 
      "GETHASH" 
      "GO" 
      "GRAPHIC-CHAR-P" 
      "HANDLER-BIND" 
      "HANDLER-CASE" 
      "HASH-TABLE" 
      "HASH-TABLE-COUNT" 
      "HASH-TABLE-P" 
      "HASH-TABLE-REHASH-SIZE" 
      "HASH-TABLE-REHASH-THRESHOLD" 
      "HASH-TABLE-SIZE" 
      "HASH-TABLE-TEST" 
      "HOST-NAMESTRING" 
      "IDENTITY" 
      "IF" 
      "IGNORABLE" 
      "IGNORE" 
      "IGNORE-ERRORS" 
      "IMAGPART" 
      "IMPORT" 
      "IN-PACKAGE" 
      "INCF" 
      "INITIALIZE-INSTANCE" 
      "INLINE" 
      "INPUT-STREAM-P" 
      "INSPECT" 
      "INTEGER" 
      "INTEGER-DECODE-FLOAT" 
      "INTEGER-LENGTH" 
      "INTEGERP" 
      "INTERACTIVE-STREAM-P" 
      "INTERN" 
      "INTERNAL-TIME-UNITS-PER-SECOND" 
      "INTERSECTION" 
      "INVALID-METHOD-ERROR" 
      "INVOKE-DEBUGGER" 
      "INVOKE-RESTART" 
      "INVOKE-RESTART-INTERACTIVELY" 
      "ISQRT" 
      "KEYWORD" 
      "KEYWORDP" 
      "LABELS" 
      "LAMBDA" 
      "LAMBDA-LIST-KEYWORDS" 
      "LAMBDA-PARAMETERS-LIMIT" 
      "LAST" 
      "LCM" 
      "LDB" 
      "LDB-TEST" 
      "LDIFF" 
      "LEAST-NEGATIVE-DOUBLE-FLOAT" 
      "LEAST-NEGATIVE-LONG-FLOAT" 
      "LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT" 
      "LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT" 
      "LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT" 
      "LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT" 
      "LEAST-NEGATIVE-SHORT-FLOAT" 
      "LEAST-NEGATIVE-SINGLE-FLOAT" 
      "LEAST-POSITIVE-DOUBLE-FLOAT" 
      "LEAST-POSITIVE-LONG-FLOAT" 
      "LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT" 
      "LEAST-POSITIVE-NORMALIZED-LONG-FLOAT" 
      "LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT" 
      "LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT" 
      "LEAST-POSITIVE-SHORT-FLOAT" 
      "LEAST-POSITIVE-SINGLE-FLOAT" 
      "LENGTH" 
      "LET" 
      "LET*" 
      "LISP-IMPLEMENTATION-TYPE" 
      "LISP-IMPLEMENTATION-VERSION" 
      "LIST" 
      "LIST*" 
      "LIST-ALL-PACKAGES" 
      "LIST-LENGTH" 
      "LISTEN" 
      "LISTP" 
      "LOAD" 
      "LOAD-LOGICAL-PATHNAME-TRANSLATIONS" 
      "LOAD-TIME-VALUE" 
      "LOCALLY" 
      "LOG" 
      "LOGAND" 
      "LOGANDC1" 
      "LOGANDC2" 
      "LOGBITP" 
      "LOGCOUNT" 
      "LOGEQV" 
      "LOGICAL-PATHNAME" 
      "LOGICAL-PATHNAME-TRANSLATIONS" 
      "LOGIOR" 
      "LOGNAND" 
      "LOGNOR" 
      "LOGNOT" 
      "LOGORC1" 
      "LOGORC2" 
      "LOGTEST" 
      "LOGXOR" 
      "LONG-FLOAT" 
      "LONG-FLOAT-EPSILON" 
      "LONG-FLOAT-NEGATIVE-EPSILON" 
      "LONG-SITE-NAME" 
      "LOOP" 
      "LOOP-FINISH" 
      "LOWER-CASE-P" 
      "MACHINE-INSTANCE" 
      "MACHINE-TYPE" 
      "MACHINE-VERSION" 
      "MACRO-FUNCTION" 
      "MACROEXPAND" 
      "MACROEXPAND-1" 
      "MACROLET" 
      "MAKE-ARRAY" 
      "MAKE-BROADCAST-STREAM" 
      "MAKE-CONCATENATED-STREAM" 
      "MAKE-CONDITION" 
      "MAKE-DISPATCH-MACRO-CHARACTER" 
      "MAKE-ECHO-STREAM" 
      "MAKE-HASH-TABLE" 
      "MAKE-INSTANCE" 
      "MAKE-INSTANCES-OBSOLETE" 
      "MAKE-LIST" 
      "MAKE-LOAD-FORM" 
      "MAKE-LOAD-FORM-SAVING-SLOTS" 
      "MAKE-METHOD" 
      "MAKE-PACKAGE" 
      "MAKE-PATHNAME" 
      "MAKE-RANDOM-STATE" 
      "MAKE-SEQUENCE" 
      "MAKE-STRING" 
      "MAKE-STRING-INPUT-STREAM" 
      "MAKE-STRING-OUTPUT-STREAM" 
      "MAKE-SYMBOL" 
      "MAKE-SYNONYM-STREAM" 
      "MAKE-TWO-WAY-STREAM" 
      "MAKUNBOUND" 
      "MAP" 
      "MAP-INTO" 
      "MAPC" 
      "MAPCAN" 
      "MAPCAR" 
      "MAPCON" 
      "MAPHASH" 
      "MAPL" 
      "MAPLIST" 
      "MASK-FIELD" 
      "MAX" 
      "MEMBER" 
      "MEMBER-IF" 
      "MEMBER-IF-NOT" 
      "MERGE" 
      "MERGE-PATHNAMES" 
      "METHOD" 
      "METHOD-COMBINATION" 
      "METHOD-COMBINATION-ERROR" 
      "METHOD-QUALIFIERS" 
      "MIN" 
      "MINUSP" 
      "MISMATCH" 
      "MOD" 
      "MOST-NEGATIVE-DOUBLE-FLOAT" 
      "MOST-NEGATIVE-FIXNUM" 
      "MOST-NEGATIVE-LONG-FLOAT" 
      "MOST-NEGATIVE-SHORT-FLOAT" 
      "MOST-NEGATIVE-SINGLE-FLOAT" 
      "MOST-POSITIVE-DOUBLE-FLOAT" 
      "MOST-POSITIVE-FIXNUM" 
      "MOST-POSITIVE-LONG-FLOAT" 
      "MOST-POSITIVE-SHORT-FLOAT" 
      "MOST-POSITIVE-SINGLE-FLOAT" 
      "MUFFLE-WARNING" 
      "MULTIPLE-VALUE-BIND" 
      "MULTIPLE-VALUE-CALL" 
      "MULTIPLE-VALUE-LIST" 
      "MULTIPLE-VALUE-PROG1" 
      "MULTIPLE-VALUE-SETQ" 
      "MULTIPLE-VALUES-LIMIT" 
      "NAME-CHAR" 
      "NAMESTRING" 
      "NBUTLAST" 
      "NCONC" 
      "NEXT-METHOD-P" 
      "NIL" 
      "NINTERSECTION" 
      "NINTH" 
      "NO-APPLICABLE-METHOD" 
      "NO-NEXT-METHOD" 
      "NOT" 
      "NOTANY" 
      "NOTEVERY" 
      "NOTINLINE" 
      "NRECONC" 
      "NREVERSE" 
      "NSET-DIFFERENCE" 
      "NSET-EXCLUSIVE-OR" 
      "NSTRING-CAPITALIZE" 
      "NSTRING-DOWNCASE" 
      "NSTRING-UPCASE" 
      "NSUBLIS" 
      "NSUBST" 
      "NSUBST-IF" 
      "NSUBST-IF-NOT" 
      "NSUBSTITUTE" 
      "NSUBSTITUTE-IF" 
      "NSUBSTITUTE-IF-NOT" 
      "NTH" 
      "NTH-VALUE" 
      "NTHCDR" 
      "NULL" 
      "NUMBER" 
      "NUMBERP" 
      "NUMERATOR" 
      "NUNION" 
      "ODDP" 
      "OPEN" 
      "OPEN-STREAM-P" 
      "OPTIMIZE" 
      "OR" 
      "OTHERWISE" 
      "OUTPUT-STREAM-P" 
      "PACKAGE" 
      "PACKAGE-ERROR" 
      "PACKAGE-ERROR-PACKAGE" 
      "PACKAGE-NAME" 
      "PACKAGE-NICKNAMES" 
      "PACKAGE-SHADOWING-SYMBOLS" 
      "PACKAGE-USE-LIST" 
      "PACKAGE-USED-BY-LIST" 
      "PACKAGEP" 
      "PAIRLIS" 
      "PARSE-ERROR" 
      "PARSE-INTEGER" 
      "PARSE-NAMESTRING" 
      "PATHNAME" 
      "PATHNAME-DEVICE" 
      "PATHNAME-DIRECTORY" 
      "PATHNAME-HOST" 
      "PATHNAME-MATCH-P" 
      "PATHNAME-NAME" 
      "PATHNAME-TYPE" 
      "PATHNAME-VERSION" 
      "PATHNAMEP" 
      "PEEK-CHAR" 
      "PHASE" 
      "PI" 
      "PLUSP" 
      "POP" 
      "POSITION" 
      "POSITION-IF" 
      "POSITION-IF-NOT" 
      "PPRINT" 
      "PPRINT-DISPATCH" 
      "PPRINT-EXIT-IF-LIST-EXHAUSTED" 
      "PPRINT-FILL" 
      "PPRINT-INDENT" 
      "PPRINT-LINEAR" 
      "PPRINT-LOGICAL-BLOCK" 
      "PPRINT-NEWLINE" 
      "PPRINT-POP" 
      "PPRINT-TAB" 
      "PPRINT-TABULAR" 
      "PRIN1" 
      "PRIN1-TO-STRING" 
      "PRINC" 
      "PRINC-TO-STRING" 
      "PRINT" 
      "PRINT-NOT-READABLE" 
      "PRINT-NOT-READABLE-OBJECT" 
      "PRINT-OBJECT" 
      "PRINT-UNREADABLE-OBJECT" 
      "PROBE-FILE" 
      "PROCLAIM" 
      "PROG" 
      "PROG*" 
      "PROG1" 
      "PROG2" 
      "PROGN" 
      "PROGRAM-ERROR" 
      "PROGV" 
      "PROVIDE" 
      "PSETF" 
      "PSETQ" 
      "PUSH" 
      "PUSHNEW" 
      "QUOTE" 
      "RANDOM" 
      "RANDOM-STATE" 
      "RANDOM-STATE-P" 
      "RASSOC" 
      "RASSOC-IF" 
      "RASSOC-IF-NOT" 
      "RATIO" 
      "RATIONAL" 
      "RATIONALIZE" 
      "RATIONALP" 
      "READ" 
      "READ-BYTE" 
      "READ-CHAR" 
      "READ-CHAR-NO-HANG" 
      "READ-DELIMITED-LIST" 
      "READ-FROM-STRING" 
      "READ-LINE" 
      "READ-PRESERVING-WHITESPACE" 
      "READ-SEQUENCE" 
      "READER-ERROR" 
      "READTABLE" 
      "READTABLE-CASE" 
      "READTABLEP" 
      "REAL" 
      "REALP" 
      "REALPART" 
      "REDUCE" 
      "REINITIALIZE-INSTANCE" 
      "REM" 
      "REMF" 
      "REMHASH" 
      "REMOVE" 
      "REMOVE-DUPLICATES" 
      "REMOVE-IF" 
      "REMOVE-IF-NOT" 
      "REMOVE-METHOD" 
      "REMPROP" 
      "RENAME-FILE" 
      "RENAME-PACKAGE" 
      "REPLACE" 
      "REQUIRE" 
      "REST" 
      "RESTART" 
      "RESTART-BIND" 
      "RESTART-CASE" 
      "RESTART-NAME" 
      "RETURN" 
      "RETURN-FROM" 
      "REVAPPEND" 
      "REVERSE" 
      "ROOM" 
      "ROTATEF" 
      "ROUND" 
      "ROW-MAJOR-AREF" 
      "RPLACA" 
      "RPLACD" 
      "SAFETY" 
      "SATISFIES" 
      "SBIT" 
      "SCALE-FLOAT" 
      "SCHAR" 
      "SEARCH" 
      "SECOND" 
      "SEQUENCE" 
      "SERIOUS-CONDITION" 
      "SET" 
      "SET-DIFFERENCE" 
      "SET-DISPATCH-MACRO-CHARACTER" 
      "SET-EXCLUSIVE-OR" 
      "SET-MACRO-CHARACTER" 
      "SET-PPRINT-DISPATCH" 
      "SET-SYNTAX-FROM-CHAR" 
      "SETF" 
      "SETQ" 
      "SEVENTH" 
      "SHADOW" 
      "SHADOWING-IMPORT" 
      "SHARED-INITIALIZE" 
      "SHIFTF" 
      "SHORT-FLOAT" 
      "SHORT-FLOAT-EPSILON" 
      "SHORT-FLOAT-NEGATIVE-EPSILON" 
      "SHORT-SITE-NAME" 
      "SIGNAL" 
      "SIGNED-BYTE" 
      "SIGNUM" 
      "SIMPLE-ARRAY" 
      "SIMPLE-BASE-STRING" 
      "SIMPLE-BIT-VECTOR" 
      "SIMPLE-BIT-VECTOR-P" 
      "SIMPLE-CONDITION" 
      "SIMPLE-CONDITION-FORMAT-ARGUMENTS" 
      "SIMPLE-CONDITION-FORMAT-CONTROL" 
      "SIMPLE-ERROR" 
      "SIMPLE-STRING" 
      "SIMPLE-STRING-P" 
      "SIMPLE-TYPE-ERROR" 
      "SIMPLE-VECTOR" 
      "SIMPLE-VECTOR-P" 
      "SIMPLE-WARNING" 
      "SIN" 
      "SINGLE-FLOAT" 
      "SINGLE-FLOAT-EPSILON" 
      "SINGLE-FLOAT-NEGATIVE-EPSILON" 
      "SINH" 
      "SIXTH" 
      "SLEEP" 
      "SLOT-BOUNDP" 
      "SLOT-EXISTS-P" 
      "SLOT-MAKUNBOUND" 
      "SLOT-MISSING" 
      "SLOT-UNBOUND" 
      "SLOT-VALUE" 
      "SOFTWARE-TYPE" 
      "SOFTWARE-VERSION" 
      "SOME" 
      "SORT" 
      "SPACE" 
      "SPECIAL" 
      "SPECIAL-OPERATOR-P" 
      "SPEED" 
      "SQRT" 
      "STABLE-SORT" 
      "STANDARD" 
      "STANDARD-CHAR" 
      "STANDARD-CHAR-P" 
      "STANDARD-CLASS" 
      "STANDARD-GENERIC-FUNCTION" 
      "STANDARD-METHOD" 
      "STANDARD-OBJECT" 
      "STEP" 
      "STORAGE-CONDITION" 
      "STORE-VALUE" 
      "STREAM" 
      "STREAM-ELEMENT-TYPE" 
      "STREAM-ERROR" 
      "STREAM-ERROR-STREAM" 
      "STREAM-EXTERNAL-FORMAT" 
      "STREAMP" 
      "STRING" 
      "STRING-CAPITALIZE" 
      "STRING-DOWNCASE" 
      "STRING-EQUAL" 
      "STRING-GREATERP" 
      "STRING-LEFT-TRIM" 
      "STRING-LESSP" 
      "STRING-NOT-EQUAL" 
      "STRING-NOT-GREATERP" 
      "STRING-NOT-LESSP" 
      "STRING-RIGHT-TRIM" 
      "STRING-STREAM" 
      "STRING-TRIM" 
      "STRING-UPCASE" 
      "STRING/=" 
      "STRING<" 
      "STRING<=" 
      "STRING=" 
      "STRING>" 
      "STRING>=" 
      "STRINGP" 
      "STRUCTURE" 
      "STRUCTURE-CLASS" 
      "STRUCTURE-OBJECT" 
      "STYLE-WARNING" 
      "SUBLIS" 
      "SUBSEQ" 
      "SUBSETP" 
      "SUBST" 
      "SUBST-IF" 
      "SUBST-IF-NOT" 
      "SUBSTITUTE" 
      "SUBSTITUTE-IF" 
      "SUBSTITUTE-IF-NOT" 
      "SUBTYPEP" 
      "SVREF" 
      "SXHASH" 
      "SYMBOL" 
      "SYMBOL-FUNCTION" 
      "SYMBOL-MACROLET" 
      "SYMBOL-NAME" 
      "SYMBOL-PACKAGE" 
      "SYMBOL-PLIST" 
      "SYMBOL-VALUE" 
      "SYMBOLP" 
      "SYNONYM-STREAM" 
      "SYNONYM-STREAM-SYMBOL" 
      "T" 
      "TAGBODY" 
      "TAILP" 
      "TAN" 
      "TANH" 
      "TENTH" 
      "TERPRI" 
      "THE" 
      "THIRD" 
      "THROW" 
      "TIME" 
      "TRACE" 
      "TRANSLATE-LOGICAL-PATHNAME" 
      "TRANSLATE-PATHNAME" 
      "TREE-EQUAL" 
      "TRUENAME" 
      "TRUNCATE" 
      "TWO-WAY-STREAM" 
      "TWO-WAY-STREAM-INPUT-STREAM" 
      "TWO-WAY-STREAM-OUTPUT-STREAM" 
      "TYPE" 
      "TYPE-ERROR" 
      "TYPE-ERROR-DATUM" 
      "TYPE-ERROR-EXPECTED-TYPE" 
      "TYPE-OF" 
      "TYPECASE" 
      "TYPEP" 
      "UNBOUND-SLOT" 
      "UNBOUND-SLOT-INSTANCE" 
      "UNBOUND-VARIABLE" 
      "UNDEFINED-FUNCTION" 
      "UNEXPORT" 
      "UNINTERN" 
      "UNION" 
      "UNLESS" 
      "UNREAD-CHAR" 
      "UNSIGNED-BYTE" 
      "UNTRACE" 
      "UNUSE-PACKAGE" 
      "UNWIND-PROTECT" 
      "UPDATE-INSTANCE-FOR-DIFFERENT-CLASS" 
      "UPDATE-INSTANCE-FOR-REDEFINED-CLASS" 
      "UPGRADED-ARRAY-ELEMENT-TYPE" 
      "UPGRADED-COMPLEX-PART-TYPE" 
      "UPPER-CASE-P" 
      "USE-PACKAGE" 
      "USE-VALUE" 
      "USER-HOMEDIR-PATHNAME" 
      "VALUES" 
      "VALUES-LIST" 
      "VARIABLE" 
      "VECTOR" 
      "VECTOR-POP" 
      "VECTOR-PUSH" 
      "VECTOR-PUSH-EXTEND" 
      "VECTORP" 
      "WARN" 
      "WARNING" 
      "WHEN" 
      "WILD-PATHNAME-P" 
      "WITH-ACCESSORS" 
      "WITH-COMPILATION-UNIT" 
      "WITH-CONDITION-RESTARTS" 
      "WITH-HASH-TABLE-ITERATOR" 
      "WITH-INPUT-FROM-STRING" 
      "WITH-OPEN-FILE" 
      "WITH-OPEN-STREAM" 
      "WITH-OUTPUT-TO-STRING" 
      "WITH-PACKAGE-ITERATOR" 
      "WITH-SIMPLE-RESTART" 
      "WITH-SLOTS" 
      "WITH-STANDARD-IO-SYNTAX" 
      "WRITE" 
      "WRITE-BYTE" 
      "WRITE-CHAR" 
      "WRITE-LINE" 
      "WRITE-SEQUENCE" 
      "WRITE-STRING" 
      "WRITE-TO-STRING" 
      "Y-OR-N-P" 
      "YES-OR-NO-P" 
      "ZEROP"
      )
    ))

(let* ((pkg *common-lisp-package*)
       (etab (pkg.etab pkg))
       (itab (pkg.itab pkg)))
  (without-interrupts
   (dolist (name '#.%lisp-symbols%)
     (let* ((namelen (length name)))
       (multiple-value-bind (found-int symbol int-offset)
                            (%get-htab-symbol name namelen itab)
         (multiple-value-bind (found-ext ignore ext-offset)
                              (%get-htab-symbol name namelen etab)
           (declare (ignore ignore))
           (if found-int                ; This shouldn't happen.
             (progn
               (setf (%svref (car itab) int-offset) (%unbound-marker-8))
               (%htab-add-symbol symbol etab ext-offset))
             (unless found-ext
               (%add-symbol name pkg int-offset ext-offset t)))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-cl-package.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-callbacks.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; l1-callbacks.lisp

(in-package "CCL")

(defstatic *callback-lock* (make-lock))


;;; (defcallback ...) expands into a call to this function.
(defun define-callback-function (lisp-function  &optional doc-string (without-interrupts t) info &aux name trampoline)
  (unless (functionp lisp-function)
    (setq lisp-function (require-type lisp-function 'function)))
  (unless (and (symbolp (setq name (function-name lisp-function)))
               ;;Might as well err out now before do any _Newptr's...
               (not (constant-symbol-p name)))
    (report-bad-arg name '(and symbol (not (satisfies constantp)))))
  (with-lock-grabbed (*callback-lock*)
    (let ((len (length %pascal-functions%)))
      (declare (fixnum len))
      (when (and name (boundp name))
        (let ((old-tramp (symbol-value name)))
          (dotimes (i len)
            (let ((pfe (%svref %pascal-functions% i)))
              (when (and (vectorp pfe)
                         (eql old-tramp (pfe.routine-descriptor pfe)))
                
                (setf (pfe.without-interrupts pfe) without-interrupts)
                (setf (pfe.lisp-function pfe) lisp-function)
                (setq trampoline old-tramp))))))
      (unless trampoline
        (let ((index (dotimes (i (length %pascal-functions%)
                               (let* ((new-len (if (zerop len) 32 (* len 2)))
                                      (new-pf (make-array (the fixnum new-len))))
                                 (declare (fixnum new-len))
                                 (dotimes (i len)
                                   (setf (%svref new-pf i) (%svref %pascal-functions% i)))
                                 (do ((i len (1+ i)))
                                     ((>= i new-len))
                                   (declare (fixnum i))
                                   (setf (%svref new-pf i) nil))
                                 (setq %pascal-functions% new-pf)
                                 len))
                       (unless (%svref %pascal-functions% i)
                         (return i)))))
          (setq trampoline (make-callback-trampoline index info))
          (setf (%svref %pascal-functions% index)
                (%cons-pfe trampoline info lisp-function name without-interrupts))))))
  ;;(%proclaim-special name)          ;
  ;; already done by defpascal expansion
  (when name (set name trampoline))
  (record-source-file name 'callback)
  (when (and doc-string *save-doc-strings*)
    (setf (documentation name 'variable) doc-string))
  (when *fasload-print* (format t "~&~S~%" name))
  (or name trampoline))

(defun %lookup-pascal-function (index)
  (declare (optimize (speed 3) (safety 0)))
  (with-lock-grabbed (*callback-lock*)
    (let* ((pfe (svref %pascal-functions% index)))
      (values (pfe.lisp-function pfe)
              (pfe.without-interrupts pfe)
	      (pfe.trace-p pfe)))))


(defun %callback-function (pointer)
  (if (typep pointer 'symbol)
    (setq pointer (symbol-value pointer)))
  (with-lock-grabbed (*callback-lock*)
    (let* ((index (dotimes (i (length %pascal-functions%))
                    (when (eql (pfe.routine-descriptor (svref %pascal-functions% i)) pointer)
                      (return i)))))
      (when index
        (let* ((entry (svref %pascal-functions% index)))
          (pfe.lisp-function entry))))))

  
(defun %delete-pascal-function (pointer)
  (with-lock-grabbed (*callback-lock*)
    (let* ((index (dotimes (i (length %pascal-functions%))
                    (when (eql (pfe.routine-descriptor (svref %pascal-functions% i)) pointer)
                      (return i)))))
      (when index
        (let* ((entry (svref %pascal-functions% index))
               (sym (pfe.sym entry)))
          (setf (svref %pascal-functions% index) nil)
          (when (and sym
                     (boundp sym)
                     (eql (symbol-value sym)
                          (pfe.routine-descriptor entry)))
            (set (symbol-value sym) nil))
          (free (pfe.routine-descriptor entry))
          t)))))


;; The kernel only really knows how to call back to one function,
;; and you're looking at it ...
(defun %pascal-functions% (index args-ptr-fixnum)
  (declare (optimize (speed 3) (safety 0)))
  (multiple-value-bind (lisp-function without-interrupts *callback-trace-p*)
      (%lookup-pascal-function index)
    (declare (special *callback-trace-p*))
    (if without-interrupts
	(without-interrupts (funcall lisp-function args-ptr-fixnum))
      (funcall lisp-function args-ptr-fixnum))))

(defstatic *callback-alloc-lock* (make-lock))

;;; 
(defun %make-executable-page ()
  #-windows-target
  (#_mmap (%null-ptr)
          #-android-target (#_getpagesize) #+android-target (#_sysconf #$_SC_PAGE_SIZE)
          (logior #$PROT_READ #$PROT_WRITE #$PROT_EXEC)
          (logior #$MAP_PRIVATE #$MAP_ANON)
          -1
          0)
  #+windows-target
  (#_VirtualAlloc (%null-ptr)
                  (ash 1 16)            ; should use GetSystemInfo
                  (logior #$MEM_RESERVE #$MEM_COMMIT)
                  #$PAGE_EXECUTE_READWRITE)
  )

(defstatic *available-bytes-for-callbacks* 0)
(defstatic *current-callback-page* nil)

(defun reset-callback-storage ()
  (setq *available-bytes-for-callbacks* #-windows-target #-android-target (#_getpagesize) #+android-target (#_sysconf #$_SC_PAGE_SIZE) #+windows-target (ash 1 16)
        *current-callback-page* (%make-executable-page)))

(defun %allocate-callback-pointer (n)
  (with-lock-grabbed (*callback-alloc-lock*)
    (when (< *available-bytes-for-callbacks* n)
      (reset-callback-storage))
    (decf *available-bytes-for-callbacks* n)
    (values (%inc-ptr *current-callback-page* *available-bytes-for-callbacks*))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-callbacks.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-readloop-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; l1-readloop-lds.lisp

(in-package "CCL")


(defvar *read-loop-function* 'read-loop)

(defun run-read-loop (&rest args)
  (declare (dynamic-extent args))
  (apply *read-loop-function* args))

(defun toplevel-loop ()
  (loop
    (if (eq (catch :toplevel 
              (run-read-loop :break-level 0 )) $xstkover)
      (format t "~&;[Stacks reset due to overflow.]")
      (when (eq *current-process* *initial-process*)
        (toplevel)))))


(defvar *defined-toplevel-commands* ())
(defvar *active-toplevel-commands* ())

(defun %define-toplevel-command (group-name key name fn doc args)
  (let* ((group (or (assoc group-name *defined-toplevel-commands*)
		    (car (push (list group-name)
			       *defined-toplevel-commands*))))
	 (pair (assoc key (cdr group) :test #'eq)))
    (if pair
      (rplacd pair (list* fn doc args))
      (push (cons key (list* fn doc args)) (cdr group))))
  name)

(define-toplevel-command 
    :global y (&optional p) "Yield control of terminal-input to process
whose name or ID matches <p>, or to any process if <p> is null"
    (%%yield-terminal-to (if p (find-process p))))	;may be nil


(define-toplevel-command
    :global kill (p) "Kill process whose name or ID matches <p>"
    (let* ((proc (find-process p)))
      (if proc
	(process-kill proc))))

(define-toplevel-command 
    :global proc (&optional p) "Show information about specified process <p>/all processes"
    (flet ((show-process-info (proc)
	     (format t "~&~d : ~a ~a ~25t[~a] "
		     (process-serial-number proc)
		     (if (eq proc *current-process*)
		       "->"
		       "  ")
		     (process-name proc)
		     (process-whostate proc))
	     (let* ((suspend-count (process-suspend-count proc)))
	       (if (and suspend-count (not (eql 0 suspend-count)))
		 (format t " (Suspended)")))
	     (let* ((terminal-input-shared-resource
		     (if (typep *terminal-io* 'two-way-stream)
		       (input-stream-shared-resource
			(two-way-stream-input-stream *terminal-io*)))))
	       (if (and terminal-input-shared-resource
			(%shared-resource-requestor-p
			 terminal-input-shared-resource proc))
		 (format t " (Requesting terminal input)")))
	     (fresh-line)))
      (if p
	(let* ((proc (find-process p)))
	  (if (null proc)
	    (format t "~&;; not found - ~s" p)
	    (show-process-info proc)))
	(dolist (proc (all-processes) (values))
	  (show-process-info proc)))))

(define-toplevel-command :global cd (dir) "Change to directory DIR (e.g., #p\"ccl:\" or \"/some/dir\")" (setf (current-directory) dir) (toplevel-print (list (current-directory))))

(define-toplevel-command :global pwd () "Print the pathame of the current directory" (toplevel-print (list (current-directory))))



(defun list-restarts ()
  (format *debug-io* "~&>   Type (:C <n>) to invoke one of the following restarts:")
  (display-restarts))

(define-toplevel-command :break pop () "exit current break loop" (abort-break))
(define-toplevel-command :break a () "exit current break loop" (abort-break))
(define-toplevel-command :break go () "continue" (continue))
(define-toplevel-command :break q () "return to toplevel" (toplevel))
(define-toplevel-command :break r () "list restarts" (list-restarts))


(define-toplevel-command :break nframes ()
  "print the number of stack frames accessible from this break loop"
  (do* ((p *break-frame* (parent-frame p nil))
        (i 0 )
        (last (last-frame-ptr)))
      ((eql p last) (toplevel-print (list i)))
    (declare (fixnum i))
    (when (function-frame-p p nil)
      (incf i))))

(define-toplevel-command :global ? () "help"
  (format t "~&The following toplevel commands are available:")
  (when *default-integer-command*
    (format t "~& <n>  ~8Tthe same as (~s <n>)" (car *default-integer-command*)))
  (dolist (g *active-toplevel-commands*)
    (dolist (c (cdr g))
      (let* ((command (car c))
	     (doc (caddr c))
	     (args (cdddr c)))
	(if args
	  (format t "~& (~S~{ ~A~}) ~8T~A" command args doc)
	  (format t "~& ~S  ~8T~A" command doc)))))
  (format t "~&Any other form is evaluated and its results are printed out."))


(define-toplevel-command :break b (&key start count show-frame-contents) "backtrace"
  (when *break-frame*
      (print-call-history :detailed-p show-frame-contents
                          :origin *break-frame*
                          :count count
                          :start-frame-number (or start 0))))

(define-toplevel-command :break c (&optional n) "Choose restart <n>. If no <n>, continue"
  (if n
   (select-restart n)
   (continue)))

(define-toplevel-command :break f (n) "Show backtrace frame <n>"
   (print-call-history :origin *break-frame*
                       :start-frame-number n
                       :count 1
                       :detailed-p t))

(define-toplevel-command :break return-from-frame (i &rest values) "Return VALUES from the I'th stack frame"
  (let* ((frame-sp (nth-function-frame  i *break-frame* nil)))
    (if frame-sp
      (apply #'return-from-frame frame-sp values))))

(define-toplevel-command :break apply-in-frame (i function &rest args) "Applies FUNCTION to ARGS in the execution context of the Ith stack frame"
  (let* ((frame-sp (nth-function-frame  i *break-frame* nil)))
    (if frame-sp
      (apply-in-frame frame-sp function args))))
                         
                         

(define-toplevel-command :break raw (n) "Show raw contents of backtrace frame <n>"
   (print-call-history :origin *break-frame*
                       :start-frame-number n
                       :count 1
                       :detailed-p :raw))

(define-toplevel-command :break v (n frame-number) "Return value <n> in frame <frame-number>"
  (let* ((frame-sp (nth-function-frame frame-number *break-frame* nil)))
    (if frame-sp
      (toplevel-print (list (nth-value-in-frame frame-sp n nil))))))

(define-toplevel-command :break arg (name frame-number) "Return value of argument named <name> in frame <frame-number>"
  (let* ((frame-sp (nth-function-frame frame-number *break-frame* nil)))
    (when frame-sp
      (multiple-value-bind (lfun pc) (cfp-lfun frame-sp)
        (when (and lfun pc)
          (let* ((unavailable (cons nil nil)))
            (declare (dynamic-extent unavailable))
            (let* ((value (arg-value nil frame-sp lfun pc unavailable name)))
              (if (eq value unavailable)
                (format *debug-io* "~&;; Can't determine value of ~s in frame ~s." name frame-number)
                (toplevel-print (list value))))))))))

(define-toplevel-command :break set-arg (name frame-number new) "Set value of argument named <name> in frame <frame-number> to value <new>."
  (let* ((frame-sp (nth-function-frame frame-number *break-frame* nil)))
    (when frame-sp
      (multiple-value-bind (lfun pc) (cfp-lfun frame-sp)
        (when (and lfun pc)
          (or (set-arg-value nil frame-sp lfun pc name new)
              (format *debug-io* "~&;; Can't change value of ~s in frame ~s." name frame-number)))))))
   

(define-toplevel-command :break local (name frame-number) "Return value of local denoted by <name> in frame <frame-number> <name> can either be a symbol - in which case the most recent
binding of that symbol is used - or an integer index into the frame's set of local bindings."
  (let* ((frame-sp (nth-function-frame frame-number *break-frame* nil)))
    (when frame-sp
      (multiple-value-bind (lfun pc) (cfp-lfun frame-sp)
        (when (and lfun pc)
          (let* ((unavailable (cons nil nil)))
            (declare (dynamic-extent unavailable))
            (let* ((value (local-value nil frame-sp lfun pc unavailable name)))
              (if (eq value unavailable)
                (format *debug-io* "~&;; Can't determine value of ~s in frame ~s." name frame-number)
                (toplevel-print (list value))))))))))

(define-toplevel-command :break set-local (name frame-number new) "Set value of argument denoted <name> (see :LOCAL) in frame <frame-number> to value <new>."
  (let* ((frame-sp (nth-function-frame frame-number *break-frame* nil)))
    (when frame-sp
      (multiple-value-bind (lfun pc) (cfp-lfun frame-sp)
        (when (and lfun pc)
          (or (set-local-value nil frame-sp lfun pc name new)
              (format *debug-io* "~&;; Can't change value of ~s in frame ~s." name frame-number)))))))


(define-toplevel-command :break form (frame-number)
   "Return a form which looks like the call which established the stack frame identified by <frame-number>.  This is only well-defined in certain cases: when the function is globally named and not a lexical closure and when it was compiled with *SAVE-LOCAL-SYMBOLS* in effect."
   (let* ((form (dbg-form frame-number)))
     (when form
       (let* ((*print-level* (default-print-level *backtrace-print-level*))
              (*print-length* (default-print-length *backtrace-print-length*)))
         (toplevel-print (list form))))))

;;; Ordinarily, form follows function.
(define-toplevel-command :break function (frame-number)
  "Returns the function invoked in backtrace frame <frame-number>.  This may be useful for, e.g., disassembly"
  (let* ((cfp (nth-function-frame frame-number *break-frame* nil)))
    (when (and cfp (not (catch-csp-p cfp nil)))
      (let* ((function (cfp-lfun cfp)))
        (when function
          (toplevel-print (list function)))))))
  


          

  

(defun %use-toplevel-commands (group-name)
  ;; Push the whole group
  (pushnew (assoc group-name *defined-toplevel-commands*)
	   *active-toplevel-commands*
	   :key #'(lambda (x) (car x))))  ; #'car not defined yet ...

(%use-toplevel-commands :global)

(defparameter *toplevel-commands-dwim* t
 "If true, tries to interpret otherwise-erroneous toplevel expressions as commands.
In addition, will suppress standard error handling for expressions that look like
commands but aren't")

(defvar *default-integer-command* nil
  "If non-nil, should be (keyword  min max)), causing integers between min and max to be
  interpreted as (keyword integer)")

(defun check-toplevel-command (form)
  (when (and *default-integer-command*
             (integerp form)
             (<= (cadr *default-integer-command*) form (caddr *default-integer-command*)))
    (setq form `(,(car *default-integer-command*) ,form)))
  (let* ((cmd (if (consp form) (car form) form))
         (args (if (consp form) (cdr form))))
    (when (or (keywordp cmd)
              (and *toplevel-commands-dwim*
                   (non-nil-symbol-p cmd)
                   (not (if (consp form)
                          (fboundp cmd)
                          (or (boundp cmd)
                              (nth-value 1 (gethash cmd *symbol-macros*)))))
                   ;; Use find-symbol so don't make unneeded keywords.
                   (setq cmd (find-symbol (symbol-name cmd) :keyword))))
      (when (eq cmd :help) (setq cmd :?))
      (flet ((run (cmd form)
               (or (dolist (g *active-toplevel-commands*)
                     (let* ((pair (assoc cmd (cdr g))))
                       (when pair 
                         (apply (cadr pair) args)
                         (return t))))
                   ;; Try to detect user mistyping a command
                   (when (and *toplevel-commands-dwim*
                              (if (consp form)
                                (and (keywordp (%car form)) (not (fboundp (%car form))))
                                (keywordp form)))
                     (error "Unknown command ~s" cmd)))))
        (declare (dynamic-extent #'run))
        (if *toplevel-commands-dwim*
          (block nil
            (handler-bind ((error (lambda (c)
                                    (format t "~&~a" c)
                                    (return t))))
              (run cmd form)))
          (run cmd form))))))

(defparameter *quit-on-eof* nil)

(defparameter *consecutive-eof-limit* 2 "max number of consecutive EOFs at a given break level, before we give up and abruptly exit.")

(defmethod stream-eof-transient-p (stream)
  (let ((fd (stream-device stream :input)))
    (and fd (eof-transient-p fd))))

(defvar *save-interactive-source-locations* t)

;;; This is the part common to toplevel loop and inner break loops.
(defun read-loop (&key (input-stream *standard-input*)
                       (output-stream *standard-output*)
                       (break-level *break-level*)
		       (prompt-function #'(lambda (stream)
                                            (when (and *show-available-restarts* *break-condition*)
                                              (list-restarts)
                                              (setf *show-available-restarts* nil))
                                            (print-listener-prompt stream t))))
  (let* ((*break-level* break-level)
         (*last-break-level* break-level)
         (*loading-file-source-file* nil)
         (*loading-toplevel-location* nil)
         *in-read-loop*
         *** ** * +++ ++ + /// // / -
         (eof-value (cons nil nil))
         (eof-count 0)
         (*show-available-restarts* (and *show-restarts-on-break* *break-condition*))
         (map (make-hash-table :test #'eq :shared nil)))
    (declare (dynamic-extent eof-value))
    (loop
      (restart-case
       (catch :abort                    ;last resort...
         (loop
           (catch-cancel
            (loop                
              (setq *in-read-loop* nil
                    *break-level* break-level)
              (multiple-value-bind (form env print-result)
                  (toplevel-read :input-stream input-stream
                                 :output-stream output-stream
                                 :prompt-function prompt-function
                                 :eof-value eof-value
				 :map (when *save-interactive-source-locations*
                                        (clrhash map)
                                        map))
                (if (eq form eof-value)
                  (progn
                    (when (> (incf eof-count) *consecutive-eof-limit*)
                      (#_ _exit 0))
                    (if (and (not *batch-flag*)
                             (not *quit-on-eof*)
                             (stream-eof-transient-p input-stream))
                      (progn
                        (stream-clear-input input-stream)
                        (abort-break))
                      (exit-interactive-process *current-process*)))
                  (let ((*nx-source-note-map* (and *save-interactive-source-locations* map)))
                    (setq eof-count 0)
                    (or (check-toplevel-command form)
                        (let* ((values (toplevel-eval form env)))
                          (if print-result (toplevel-print values)))))))))
           (format *terminal-io* "~&Cancelled")))
       (abort () :report (lambda (stream)
                           (if (eq break-level 0)
                             (format stream "Return to toplevel.")
                             (format stream "Return to break level ~D." break-level)))
              #|                        ; Handled by interactive-abort
                                        ; go up one more if abort occurred while awaiting/reading input               
              (when (and *in-read-loop* (neq break-level 0))
              (abort))
              |#
               )
        (abort-break () 
                     (unless (eq break-level 0)
                       (abort))))
       (clear-input input-stream)
      (format output-stream "~%"))))

;;; The first non-whitespace character available on INPUT-STREAM is a colon.
;;; Try to interpret the line as a colon command (or possibly just a keyword.)
(defun read-command-or-keyword (input-stream eof-value)
  (let* ((line (read-line input-stream nil eof-value)))
    (if (eq line eof-value)
      eof-value
      (let* ((in (make-string-input-stream line))
             (keyword (read in nil eof-value)))
        (if (eq keyword eof-value)
          eof-value
          (if (not (keywordp keyword))
            keyword
            (collect ((params))
              (loop
                (let* ((param (read in nil eof-value)))
                  (if (eq param eof-value)
                    (return
                      (let* ((params (params)))
                        (if params
                          (cons keyword params)
                          keyword)))
                    (params (eval param))))))))))))

;;; Read a form from the specified stream.
(defun toplevel-read (&key (input-stream *standard-input*)
                           (output-stream *standard-output*)
                           (prompt-function #'print-listener-prompt)
                           (eof-value *eof-value*)
		           (map nil))
  (force-output output-stream)
  (funcall prompt-function output-stream)
  (read-toplevel-form input-stream :eof-value eof-value :map map))

(defvar *always-eval-user-defvars* nil)

(defun process-single-selection (form)
  (if (and *always-eval-user-defvars*
           (listp form) (eq (car form) 'defvar) (cddr form))
    `(defparameter ,@(cdr form))
    form))

(defun toplevel-eval (form &optional env)
  (destructuring-bind (vars . vals) (or env '(nil . nil))
    (progv vars vals
      (setq +++ ++ ++ + + - - form)
      (unwind-protect
           (let* ((package *package*)
                  (values (multiple-value-list (cheap-eval-in-environment form nil))))
             (unless (eq package *package*)
               ;; If changing a local value (e.g. buffer-local), not useful to notify app
               ;; without more info.  Perhaps should have a *source-context* that can send along?
               (unless (member '*package* vars)
                 (application-ui-operation *application* :note-current-package *package*)))
             values)
        (loop for var in vars as pval on vals
              do (setf (car pval) (symbol-value var)))))))


(defun toplevel-print (values &optional (out *standard-output*))
  (setq /// // // / / values)
  (unless (eq (car values) (%unbound-marker))
    (setq *** ** ** * *  (%car values)))
  (when values
    (fresh-line out)
    (dolist (val values) (write val :stream out) (terpri out))))

(defparameter *listener-prompt-format* "~[?~:;~:*~d >~] ")

  
(defun print-listener-prompt (stream &optional (force t))
  (unless *quiet-flag*
    (when (or force (neq *break-level* *last-break-level*))
      (let* ((*listener-indent* nil))
        (fresh-line stream)
        (format stream *listener-prompt-format* *break-level*))
      (setq *last-break-level* *break-level*)))
    (force-output stream))


;;; Fairly crude default error-handlingbehavior, and a fairly crude mechanism
;;; for customizing it.

(defvar *app-error-handler-mode* :quit
  "one of :quit, :quit-quietly, :listener might be useful.")

(defmethod application-error ((a application) condition error-pointer)
  (case *app-error-handler-mode*
    (:listener   (break-loop-handle-error condition error-pointer))
    (:quit-quietly (quit -1))
    (:quit  (format t "~&Fatal error in ~s : ~a"
                    (pathname-name (car *command-line-argument-list*))
                    condition)
                    (quit -1))))

(defun make-application-error-handler (app mode)
  (declare (ignore app))
  (setq *app-error-handler-mode* mode))


; You may want to do this anyway even if your application
; does not otherwise wish to be a "lisp-development-system"
(defmethod application-error ((a lisp-development-system) condition error-pointer)
  (break-loop-handle-error condition error-pointer))

(defun abnormal-application-exit ()
  (ignore-errors
    (print-call-history)
    (write-line (lisp-implementation-version) *debug-io*)
    (force-output *debug-io*)
    (quit -1))
  (#__exit -1))

;; Make these available to debugger hook
(defvar *top-error-frame* nil)
(defvar *break-loop-type* nil) ;; e.g. "Debug", "Signal", "Error".

(defun break-loop-handle-error (condition *top-error-frame*)
  (multiple-value-bind (bogus-globals newvals oldvals) (%check-error-globals)
    (dolist (x bogus-globals)
      (set x (funcall (pop newvals))))
    (let ((msg (if *batch-flag* ;; Give a little more info if exiting
                 (format nil "Error of type ~s" (type-of condition))
                 "Error")))
      (when (and *debugger-hook* *break-on-errors* (not *batch-flag*))
        (let ((hook *debugger-hook*)
              (*debugger-hook* nil)
              (*break-loop-type* msg))
          (funcall hook condition hook)))
      (%break-message msg condition))
    (let* ((s *error-output*))
      (dolist (bogusness bogus-globals)
        (let ((oldval (pop oldvals)))
          (format s "~&;  NOTE: ~S was " bogusness)
          (if (eq oldval (%unbound-marker-8))
            (format s "unbound")
            (format s "~s" oldval))
          (format s ", was reset to ~s ." (symbol-value bogusness)))))
    (if (and *break-on-errors* (not *batch-flag*))
      (break-loop condition)
      (if *batch-flag*
        (abnormal-application-exit)
        (abort)))))

(defun break (&optional string &rest args)
  "Print a message and invoke the debugger without allowing any possibility
   of condition handling occurring."
  (if *batch-flag*
    (apply #'error (or string "BREAK invoked in batch mode") args)
    (apply #'%break-in-frame (%get-frame-ptr) string args)))

(defun %break-in-frame (fp &optional string &rest args)
  (flet ((do-break-loop ()
           (let ((c (if (typep string 'condition)
                      string
                      (make-condition 'simple-condition
                                    :format-control (or string "")
                                    :format-arguments args))))
             (cbreak-loop "Break" "Return from BREAK." c fp))))
    (cond ((%i> *interrupt-level* -1)
           (do-break-loop))
          (*break-loop-when-uninterruptable*
           (format *error-output* "Break while interrupt-level less than zero; binding to 0 during break-loop.")
           (let ((interrupt-level (interrupt-level)))
	     (unwind-protect
		  (progn
		    (setf (interrupt-level) 0)
		    (do-break-loop))
	       (setf (interrupt-level) interrupt-level))))
          (t (format *error-output* "Break while interrupt-level less than zero; ignored.")))))


(defun invoke-debugger (condition &aux (*top-error-frame* (%get-frame-ptr)))
  "Enter the debugger."
  (let ((c (require-type condition 'condition))
        (msg "Debug"))
    (when *debugger-hook*
      (let ((hook *debugger-hook*)
            (*debugger-hook* nil)
            (*break-loop-type* msg))
        (funcall hook c hook)))
    (%break-message msg c)
    (break-loop c)))

(defvar *show-condition-context* t
  "The type of conditions which should include the execution context as part of their error-output message.
   E.g. value of 'error will prevent warnings from including the calling function and process in the warning message")

(defun %break-message (msg condition &optional (error-pointer *top-error-frame*) (prefixchar #\>))
  (let ((*print-circle* *error-print-circle*)
        ;(*print-prett*y nil)
        (*print-array* nil)
        (*print-escape* t)
        (*print-gensym* t)
        (*print-length* (default-print-length *error-print-length*))
        (*print-level* (default-print-level *error-print-level*))
        (*print-string-length* (default-print-string-length *error-print-string-length*))
        (*print-lines* nil)
        (*print-miser-width* nil)
        (*print-readably* nil)
        (*print-right-margin* nil)
        (*signal-printing-errors* nil)
        (s (make-indenting-string-output-stream prefixchar nil))
        (sub (make-string-output-stream))
        (show-context (typep condition *show-condition-context*))
        (indent 0))
    (format s "~A~@[ ~A:~] " prefixchar msg)
    (setf (indenting-string-output-stream-indent s) (setq indent (column s)))
    (decf (stream-line-length sub) indent)
    ;(format s "~A" condition) ; evil if circle
    (report-condition condition sub)
    (format s "~A" (get-output-stream-string sub))
    (if (and show-context
             (not (and (typep condition 'simple-program-error)
                       (simple-program-error-context condition))))
      (format *error-output* "~&~A~%~A While executing: ~S"
              (get-output-stream-string s) prefixchar (%real-err-fn-name error-pointer))
      (format *error-output* "~&~A"
              (get-output-stream-string s)))
    (when show-context
      (if *current-process*
        (format *error-output* ", in process ~a(~d).~%" (process-name *current-process*) (process-serial-number *current-process*))
        (format *error-output* ", in an uninitialized process~%")))
  (force-output *error-output*)))
					; returns NIL

(defvar *break-hook* nil)

(defun cbreak-loop (msg cont-string condition *top-error-frame*)
  (let* ((*print-readably* nil)
         (hook *break-hook*))
    (restart-case (progn
                    (when (and (eq (type-of condition) 'simple-condition)
                               (equal (simple-condition-format-control condition) ""))
                      (setq condition (make-condition 'simple-condition
                                        :format-control "~a"
                                        :format-arguments (list msg))))
                    (when hook
                      (let ((*break-hook* nil)
                            (*break-loop-type* msg))
                        (funcall hook condition hook))
                      (setq hook nil))
                    (%break-message msg condition)
                    (break-loop condition))
      (continue () :report (lambda (stream) (write-string cont-string stream))))
    (unless hook
      (fresh-line *error-output*))
    nil))

(defun warn (condition-or-format-string &rest args)
  "Warn about a situation by signalling a condition formed by DATUM and
   ARGUMENTS. While the condition is being signaled, a MUFFLE-WARNING restart
   exists that causes WARN to immediately return NIL."
  (when (typep condition-or-format-string 'condition)
    (unless (typep condition-or-format-string 'warning)
      (report-bad-arg condition-or-format-string 'warning))
    (when args
      (error 'type-error :datum args :expected-type 'null
	     :format-control "Extra arguments in ~s.")))
  (let ((fp (%get-frame-ptr))
        (c (require-type (condition-arg condition-or-format-string args 'simple-warning) 'warning)))
    (when *break-on-warnings*
      (cbreak-loop "Warning" "Signal the warning." c fp))
    (restart-case (signal c)
      (muffle-warning () :report "Skip the warning" (return-from warn nil)))
    (%break-message (if (typep c 'compiler-warning) "Compiler warning" "Warning") c fp #\;)
    ))

(defmacro new-backtrace-info (dialog youngest oldest tcr condition current fake db-link level)
  (let* ((cond (gensym)))
  `(let* ((,cond ,condition))
    (vector ,dialog ,youngest ,oldest ,tcr (cons nil (compute-restarts ,cond)) (%catch-top ,tcr) ,cond ,current ,fake ,db-link ,level))))

(defmethod backtrace-context-continuable-p ((context vector))
  (not (null (find 'continue (cdr (bt.restarts context)) :key #'restart-name))))

(defmethod backtrace-context-break-level ((context vector))
  (bt.break-level context))

(defmethod backtrace-context-restarts ((context vector))
  (cdr (bt.restarts context)))


;;; Each of these stack ranges defines the entire range of (control/value/temp)
;;; addresses; they can be used to addresses of stack-allocated objects
;;; for printing.
#-arm-target
(defun make-tsp-stack-range (tcr bt-info)
  (list (cons (%catch-tsp (bt.top-catch bt-info))
              (%fixnum-ref (%fixnum-ref tcr target::tcr.ts-area)
                                target::area.high))))

#+ppc-target
(defun make-vsp-stack-range (tcr bt-info)
  (list (cons (%fixnum-ref
               (%svref (bt.top-catch bt-info) target::catch-frame.csp-cell)
               target::lisp-frame.savevsp)
              (%fixnum-ref (%fixnum-ref tcr target::tcr.vs-area) target::area.high))))
#+x8632-target
(defun make-vsp-stack-range (tcr bt-info)
  (list (cons (%svref (bt.top-catch bt-info) target::catch-frame.esp-cell)
              (%fixnum-ref
               (%fixnum-ref tcr (- target::tcr.vs-area target::tcr-bias))
               target::area.high))))

#+x8664-target
(defun make-vsp-stack-range (tcr bt-info)
  (list (cons (%svref (bt.top-catch bt-info) target::catch-frame.rsp-cell)
              (%fixnum-ref (%fixnum-ref tcr target::tcr.vs-area) target::area.high))))

#+arm-target 
(defun make-vsp-stack-range (tcr bt-info)
  (list (cons (%fixnum-ref (catch-frame-sp (bt.top-catch bt-info)) target::lisp-frame.savevsp)
              (%fixnum-ref (%fixnum-ref tcr target::tcr.vs-area) target::area.high))))

#+ppc-target
(defun make-csp-stack-range (tcr bt-info)
  (list (cons (%svref (bt.top-catch bt-info) target::catch-frame.csp-cell)
              (%fixnum-ref (%fixnum-ref tcr target::tcr.cs-area) target::area.high))))

#+x8632-target
(defun make-csp-stack-range (tcr bt-info)
  (let ((cs-area nil))
    #+windows-target
    (let ((aux (%fixnum-ref tcr (- target::tcr.aux target::tcr-bias))))
      (setq cs-area (%fixnum-ref aux target::tcr-aux.cs-area)))
    #-windows-target
    (setq cs-area (%fixnum-ref tcr target::tcr.cs-area))
  (list (cons (%svref (bt.top-catch bt-info) target::catch-frame.foreign-sp-cell)
              (%fixnum-ref cs-area target::area.high)))))

#+x8664-target
(defun make-csp-stack-range (tcr bt-info)
  (list (cons (%svref (bt.top-catch bt-info) target::catch-frame.foreign-sp-cell)
              (%fixnum-ref (%fixnum-ref tcr target::tcr.cs-area) target::area.high))))

#+arm-target
(defun make-csp-stack-range (tcr bt-info)
  (list (cons (catch-frame-sp (bt.top-catch bt-info))
              (%fixnum-ref (%fixnum-ref tcr target::tcr.cs-area) target::area.high))))



(declaim (notinline select-backtrace))

(defun select-backtrace ()
  (declare (notinline select-backtrace))
  ;(require 'new-backtrace)
  (require :inspector)
  (select-backtrace))

(defvar *break-condition* nil "condition argument to innermost break-loop.")
(defvar *break-frame* nil "frame-pointer arg to break-loop")
(defvar *break-loop-when-uninterruptable* t)
(defvar *show-restarts-on-break* nil)
(defvar *show-available-restarts* nil)

(defvar *error-reentry-count* 0)

(defun funcall-with-error-reentry-detection (thunk)
  (let* ((count *error-reentry-count*)
         (*error-reentry-count* (1+ count)))
    (cond ((eql count 0) (funcall thunk))
          ((eql count 1) (error "Error reporting error"))
          (t (bug "Error reporting error")))))


(defvar %last-continue% nil)
(defun break-loop (condition &optional (frame-pointer *top-error-frame*))
  "Never returns"
  (let* ((%handlers% (last %handlers%)) ; firewall
         (*break-frame* frame-pointer)
         (*break-condition* condition)
         (*compiling-file* nil)
         (*backquote-stack* nil)
         (continue (find-restart 'continue))
         (*continuablep* (unless (eq %last-continue% continue) continue))
         (%last-continue% continue)
         (*standard-input* *debug-io*)
         (*standard-output* *debug-io*)
         (*signal-printing-errors* nil)
         (*read-suppress* nil)
         (*print-readably* nil)
	 (context (new-backtrace-info nil
                                      frame-pointer
                                      (if *backtrace-contexts*
                                        (or (child-frame
                                             (bt.youngest (car *backtrace-contexts*))
                                             nil)
                                            (last-frame-ptr))
                                        (last-frame-ptr))
                                      (%current-tcr)
                                      condition
                                      (%current-frame-ptr)
                                      #+ppc-target *fake-stack-frames*
                                      #+x86-target (%current-frame-ptr)
                                      #+arm-target (or (current-fake-stack-frame) (%current-frame-ptr))
                                      (db-link)
                                      (1+ *break-level*)))
         (*default-integer-command* `(:c 0 ,(1- (length (cdr (bt.restarts context))))))
         (*backtrace-contexts* (cons context *backtrace-contexts*)))
    (with-terminal-input
      (with-toplevel-commands :break
        (if *continuablep*
          (let* ((*print-circle* *error-print-circle*)
                 (*print-length* (default-print-length *error-print-length*))
                 (*print-level* (default-print-level *error-print-level*))
                 (*print-string-length* (default-print-string-length *error-print-string-length*))
                 ;(*print-pretty* nil)
                 (*print-array* nil))
            (format t (or (application-ui-operation *application* :break-options-string t)
                          "~&> Type :GO to continue, :POP to abort, :R for a list of available restarts."))
            (format t "~&> If continued: ~A~%" continue))
          (format t (or (application-ui-operation *application* :break-options-string nil)
                        "~&> Type :POP to abort, :R for a list of available restarts.~%")))
        (format t "~&> Type :? for other options.")
        (terpri)
        (force-output)

        (clear-input *debug-io*)
        (setq *error-reentry-count* 0)  ; succesfully reported error
        (ignoring-without-interrupts
          (unwind-protect
               (progn
                 (application-ui-operation *application*
                                           :enter-backtrace-context context)
                 (run-read-loop :break-level (1+ *break-level*)
                                :input-stream *debug-io*
                                :output-stream *debug-io*))
            (application-ui-operation *application* :exit-backtrace-context
                                      context)))))))



(defun display-restarts (&optional (condition *break-condition*))
  (loop
    for restart in (compute-restarts condition)
    for count upfrom 0
    do (format *debug-io* "~&~D. ~A" count restart)
    finally (fresh-line *debug-io*)))

(defun select-restart (n &optional (condition *break-condition*))
  (let* ((restarts (compute-restarts condition)))
    (invoke-restart-interactively
     (nth (require-type n `(integer 0 (,(length restarts)))) restarts))))




; End of l1-readloop-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-readloop-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/arm-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2010 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defun %frame-backlink (p &optional context)
  (declare (ignore context))
  (cond ((fake-stack-frame-p p)
         (%fixnum-ref p arm::fake-stack-frame.next-sp))
        ((fixnump p) (%%frame-backlink p))
        (t (error "~s is not a valid stack frame" p))))



(defun catch-frame-sp (catch)
  (%stack-block ((ptr arm::node-size))
    (%set-object ptr 0 catch)           ;catch frame is stack-consed
    (setf (%get-long ptr) (logandc2 (%get-long ptr) arm::fulltagmask))
    (+ (%get-object ptr 0)
       (1+ arm::catch-frame.element-count))))

(defun fake-stack-frame-p (x)
  (and (typep x 'fixnum)
       (evenp x)
       (eql (%fixnum-ref-natural x)
            (logior (ash (ash (- arm::fake-stack-frame.size arm::node-size)
                              (- arm::word-shift))
                         arm::num-subtag-bits)
                    arm::subtag-istruct))
       (let* ((type (%fixnum-ref x arm::node-size)))
         (and (consp type)
              (eq (car type) 'arm::fake-stack-frame)))))

(defun current-fake-stack-frame ()
  (do* ((p (%get-frame-ptr) (%%frame-backlink p)))
       ((or (zerop p) (bottom-of-stack-p p nil)))
    (when (fake-stack-frame-p p) (return p))))



(defun bottom-of-stack-p (p context)
  (and (fixnump p)
       (locally (declare (fixnum p))
	 (let* ((tcr (if context (bt.tcr context) (%current-tcr)))
                (cs-area (%fixnum-ref tcr target::tcr.cs-area)))
	   (not (%ptr-in-area-p p cs-area))))))

(defun lisp-frame-p (p context)
  (if (bottom-of-stack-p p context)
    (values nil t)
    (values (or (fake-stack-frame-p p)
                (eql (%fixnum-ref-natural p) arm::lisp-frame-marker)) nil)))





(defun valid-subtag-p (subtag)
  (declare (fixnum subtag))
  (let* ((tagval (ldb (byte (- arm::num-subtag-bits arm::ntagbits) arm::ntagbits) subtag)))
    (declare (fixnum tagval))
    (case (logand subtag arm::fulltagmask)
      (#. arm::fulltag-immheader (not (eq (%svref *immheader-types* tagval) 'bogus)))
      (#. arm::fulltag-nodeheader (not (eq (%svref *nodeheader-types* tagval) 'bogus)))
      (t nil))))



(defun valid-header-p (thing)
  (let* ((fulltag (fulltag thing)))
    (declare (fixnum fulltag))
    (case fulltag
      (#.arm::fulltag-misc (valid-subtag-p (typecode thing)))
      ((#.arm::fulltag-immheader #.arm::fulltag-nodeheader) nil)
      (t t))))






(defun bogus-thing-p (x)
  (when x
    #+cross-compiling (return-from bogus-thing-p nil)
    (or (not (valid-header-p x))
        (let ((tag (lisptag x)))
          (unless (or (eql tag arm::tag-fixnum)
                      (eql tag arm::tag-imm)
                      (in-any-consing-area-p x))
            ;; This is terribly complicated, should probably write some LAP
            (let ((typecode (typecode x)))
                  (not (or (case typecode
                             (#.arm::tag-list
                              (temporary-cons-p x))
                             ((#.arm::subtag-symbol #.arm::subtag-code-vector)
                              t)              ; no stack-consed symbols or code vectors
                             (#.arm::subtag-value-cell
                              (on-any-vstack x))
                             (t
                              (on-any-csp-stack x)))
                           (%heap-ivector-p x)))))))))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/arm-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/version.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defparameter *openmcl-major-version* 1)
(defparameter *openmcl-minor-version* 12)
(defparameter *openmcl-revision* "dev")
;;; May be set by xload-level-0
(defvar *openmcl-svn-revision* nil)
(defparameter *openmcl-dev-level* nil)

(defparameter *openmcl-version* (format nil "~d.~d~@[-~a~]~@[/~a~] ~@[+~s~] (~@[~A: ~]~~A)"
					*openmcl-major-version*
					*openmcl-minor-version*
					(unless (null *openmcl-revision*)
					  *openmcl-revision*)
					(if (and (typep *openmcl-svn-revision* 'string)
                                                 (> (length *openmcl-svn-revision*) 0))
                                          *openmcl-svn-revision*)
                                        *optional-features*
                                        *openmcl-dev-level*))




;;; end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/version.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-error-system.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


;;; This file contains the error/condition system.  Functions that
;;; signal/handle errors are defined later.

(in-package "CCL")

;;;***********************************
;;; Error System
;;;***********************************

(defclass condition () ())
(defclass warning (condition) ())
(defclass serious-condition (condition) ())
(defclass error (serious-condition) ())

(defun check-condition-superclasses (cond supers)
  (let* ((bad nil))
    (dolist (s supers)
      (let* ((class (find-class s nil)))
        (unless (and class (subtypep class 'condition))
          (push s bad))))
    (when bad
      (error "Parent types of condition named ~s being defined aren't known subtypes of CONDITION: ~s." cond bad))))


(define-condition simple-condition (condition)
  ((format-control :initarg :format-control
                  :reader simple-condition-format-control)
   (format-arguments :initarg :format-arguments
                     :initform nil
                     :reader simple-condition-format-arguments))
  (:report (lambda (c stream)  ;; If this were a method, slot value might be faster someday.  Accessors always faster ?
                               ;; And of course it's terribly important that this be as fast as humanly possible...
	    ;Use accessors because they're documented and users can specialize them.
            (apply #'format stream (simple-condition-format-control c)
                   (simple-condition-format-arguments c)))))


(define-condition storage-condition (serious-condition) ())

(define-condition thread-condition (condition) ())

(define-condition process-reset (thread-condition)
  ((kill :initarg :kill :initform nil :reader process-reset-kill)))

(define-condition encoding-problem (condition)
  ((character :initarg :character :reader encoding-problem-character)
   (destination :initarg :destination :reader encoding-problem-destination)
   (encoding-name :initarg :encoding-name :reader encoding-problem-encoding-name))
  (:report
   (lambda (c s)
     (with-slots (character destination encoding-name) c
       (format s "Character ~c can't be written to ~a in encoding ~a."
               character destination encoding-name)))))



(define-condition decoding-problem (condition)
  ((source :initarg :source :reader decoding-problem-source)
   (position :initarg :position :reader decoding-problem-position)
   (encoding-name :initarg :encoding-name :reader decoding-problem-encoding-name))
  (:report (lambda (c stream)
             (with-slots (source position encoding-name) c
               (format stream "Contents of ~a" source)
               (when position
                 (format stream ", near ~a ~d," (if (typep source 'stream) "position" "index") position))
               (format stream " don't represent a valid character in ~s." encoding-name)))))


             

(define-condition print-not-readable (error)
  ((object :initarg :object :reader print-not-readable-object)
   (stream :initarg :stream :reader print-not-readable-stream))
  (:report (lambda (c stream)
             (let* ((*print-readably* nil))
               (format stream "Attempt to print object ~S on stream ~S ."
                       (print-not-readable-object c)
                       (print-not-readable-stream c))))))

(define-condition simple-warning (simple-condition warning) ())

(define-condition compiler-warning (warning)
  ((function-name :initarg :function-name :initform nil :accessor compiler-warning-function-name)
   (source-note :initarg :source-note :initform nil :accessor compiler-warning-source-note)
   (warning-type :initarg :warning-type :reader compiler-warning-warning-type)
   (args :initarg :args :reader compiler-warning-args)
   (nrefs :initform () :accessor compiler-warning-nrefs))
  (:report report-compiler-warning))

;; Backward compatibility
(defmethod compiler-warning-file-name ((w compiler-warning))
  (source-note-filename (compiler-warning-source-note w)))

(define-condition style-warning (compiler-warning)
  ((warning-type :initform :unsure)
   (args :initform nil)))
(define-condition undefined-reference (style-warning) ())
(define-condition undefined-type-reference (undefined-reference) ())
(define-condition undefined-function-reference (undefined-reference) ())
(define-condition macro-used-before-definition (compiler-warning) ())
(define-condition invalid-type-warning (style-warning) ())
(define-condition invalid-arguments (style-warning) ())
(define-condition invalid-arguments-global (style-warning) ())
(define-condition undefined-keyword-reference (undefined-reference invalid-arguments) ())
(define-condition shadowed-typecase-clause (style-warning)
  ((construct :initarg :construct :initform 'typecase)
   (clause :initarg :clause)
   (by :initarg :by))
  (:report (lambda (c s)
             (with-slots (construct clause by) c
               (format s "Clause ~S ignored in ~S form - shadowed by ~S ."
                       clause construct by)))))

(define-condition simple-error (simple-condition error) ())

(define-condition simple-storage-condition (simple-condition storage-condition) ())
(define-condition stack-overflow-condition (simple-storage-condition) ())

(define-condition invalid-memory-access (storage-condition)
  ((address :initarg :address)
   (write-p :initform nil :initarg :write-p))
  (:report (lambda (c s)
             (with-slots (address write-p) c
               (format s "Fault during ~a memory address #x~x" (if write-p "write to" "read of") address)))))

(define-condition invalid-memory-operation (storage-condition)
  ()
  (:report (lambda (c s)
             (declare (ignore c))
             (format s "Invalid memory operation."))))

(define-condition write-to-watched-object (storage-condition)
  ((object :initform nil :initarg :object
	   :reader write-to-watched-object-object)
   (offset :initarg :offset
	   :reader write-to-watched-object-offset)
   (instruction :initarg :instruction
		:reader write-to-watched-object-instruction))
  (:report report-write-to-watched-object))

(defun report-write-to-watched-object (c s)
  (with-slots (object offset instruction) c
    (cond
      ((uvectorp object)
       (let* ((count (uvsize object))
	      (nbytes (if (ivectorp object)
			(subtag-bytes (typecode object) count)
			(* count target::node-size)))
	      (bytes-per-element (/ nbytes count))
	      (offset (- offset target::misc-data-offset))
	      (index (/ offset bytes-per-element)))
	 (format s "Write to watched uvector ~s at " object)
	 (if (fixnump index)
	   (format s "index ~s" index)
	   (format s "an apparently unaligned byte offset ~s" offset))))
      ((consp object)
       (format s "Write to ~a watched cons cell ~s"
               (cond
		 ((= offset target::cons.cdr) "the CDR of")
		 ((= offset target::cons.car) "the CAR of")
		 (t
		  (format nil "an apparently unaligned byte offset (~s) into"
			  offset)))
               object))
      (t
       (format s "Write to a strange object ~s at byte offset ~s"
	       object offset)))
    (when instruction
      (format s "~&Faulting instruction: ~s" instruction))))

(define-condition allocation-disabled (storage-condition)
  ()
  (:report (lambda (c s) (declare (ignore c)) (format s "Attempt to heap-allocate a lisp object when heap allocation is disabled."))))

(define-condition vector-size-limitation (storage-condition)
  ((subtag :initarg :subtag)
   (element-count :initarg :element-count))
  (:report (lambda (c s)
             (let* ((subtag (slot-value c 'subtag))
                    (element-count (slot-value c 'element-count))
                    (typename (if (eql subtag target::subtag-bignum)
                                'bignum
                                (if (eql subtag target::subtag-simple-vector)
                                  'simple-vector
                                  (if (eql subtag target::subtag-simple-base-string)
                                    'string
                                    (if (> subtag target::subtag-simple-vector)
                                      `(simple-array ,(element-subtype-type subtag) (*))
                                      `(ccl::uvector ,subtag))))))
                    (qualifier (if (eql subtag target::subtag-bignum)
                                 "32-bit "
                                 "")))
               (format s "Cannot allocate a ~s with ~d elements.~&Objects of type ~s can can have at most ~&~d ~aelements in this implementation."
                       typename
                       element-count
                       (copy-tree typename)
                       (1- target::array-total-size-limit)
                       qualifier)))))

(define-condition type-error (error)
  ((datum :initarg :datum)
   (expected-type :initarg :expected-type :reader type-error-expected-type)
   (format-control :initarg :format-control  :initform (%rsc-string  $xwrongtype) :reader type-error-format-control))
  (:report (lambda (c s)
             (format s (type-error-format-control c)
                     (type-error-datum c) 
                     (type-error-expected-type c)))))

(define-condition bad-slot-type (type-error)
  ((slot-definition :initform nil :initarg :slot-definition)
   (instance :initform nil :initarg :instance))
  (:report (lambda (c s)
	     (format s "The value ~s can not be used to set the value of the slot ~s in ~s, because it is not of type ~s. "
		     (type-error-datum c)
		     (slot-definition-name (slot-value c 'slot-definition))
		     (slot-value c 'instance)
		     (type-error-expected-type c)))))

(define-condition bad-slot-type-from-initform (bad-slot-type)
  ()
  (:report (lambda (c s)
	     (let* ((slotd (slot-value c 'slot-definition)))
	       (format s "The value ~s, derived from the initform ~s, can not be used to set the value of the slot ~s in ~s, because it is not of type ~s. "
		     (type-error-datum c)
		     (slot-definition-initform slotd)
		     (slot-definition-name slotd)
		     (slot-value c 'instance)
		     (type-error-expected-type c))))))

(define-condition bad-slot-type-from-initarg (bad-slot-type)
  ((initarg-name :initarg :initarg-name))
  (:report (lambda (c s)
	     (let* ((slotd (slot-value c 'slot-definition)))
	       (format s "The value ~s, derived from the initarg ~s, can not be used to set the value of the slot ~s in ~s, because it is not of type ~s. "
		     (type-error-datum c)
		     (slot-value c 'initarg-name)
		     (slot-definition-name slotd)
		     (slot-value c 'instance)
		     (type-error-expected-type c))))))
  

(define-condition improper-list (type-error)
  ((expected-type :initform '(satisfies proper-list-p) :reader type-error-expected-type)))

(define-condition cant-construct-arglist (improper-list)
  ())


(let* ((magic-token '("Unbound")))
  (defmethod type-error-datum ((c type-error))
    (let* ((datum-slot (slot-value c 'datum)))
      (if (eq magic-token datum-slot)
        (%unbound-marker-8)
        datum-slot)))

; do we need this
  (defun signal-type-error (datum expected &optional (format-string (%rsc-string  $xwrongtype)))
    (let ((error #'error))
      (funcall error (make-condition 'type-error
                                     :format-control format-string
                                     :datum (if (eq datum (%unbound-marker-8)) magic-token datum)
                                     :expected-type (%type-error-type expected)))))
)


(define-condition sequence-index-type-error (type-error)
  ((sequence :initarg :sequence))
  (:report (lambda (c s)
             (format s "~s is not a valid sequence index for ~s"
                     (type-error-datum c)
                     (slot-value c 'sequence)))))


;;; This is admittedly sleazy; ANSI CL requires TYPE-ERRORs to be
;;; signalled in cases where a type-specifier is not of an appropriate
;;; subtype.  The sleazy part is whether it's right to overload TYPE-ERROR
;;; like this.

(define-condition invalid-subtype-error (type-error)
  ()
  (:report (lambda (c s)
             (format s "The type specifier ~S is not determinably a subtype of the type ~S"
                     (type-error-datum c)
                     (type-error-expected-type c)))))

(define-condition simple-type-error (simple-condition type-error) ())

(define-condition array-element-type-error (simple-type-error)
  ((array :initarg :array :reader array-element-type-error-array))
  (:report (lambda (c s)
             (format s (simple-condition-format-control c)
                     (type-error-datum c)
                     (array-element-type-error-array c)))))
                  




(define-condition program-error (error) ())
(define-condition simple-program-error (simple-condition program-error)
  ((context :initarg :context :reader simple-program-error-context :initform nil)))

(define-condition invalid-type-specifier (program-error)
  ((typespec :initarg :typespec :reader invalid-type-specifier-typespec))
  (:report (lambda (c s)
             (with-slots (typespec) c
               (format s "Invalid type specifier: ~s ." typespec)))))

(defun signal-program-error (string &rest args)
  (let* ((e #'error))
    (funcall e
	     (make-condition 'simple-program-error
			     :format-control (if (fixnump string) (%rsc-string string) string)
			     :format-arguments args))))

(define-condition simple-destructuring-error (simple-program-error) ())

(define-condition wrong-number-of-arguments (program-error)
  ((nargs :initform nil
	  :initarg :nargs :reader wrong-number-of-arguments-nargs)
   (fn :initform nil :initarg :fn :reader wrong-number-of-arguments-fn))
  (:report report-argument-mismatch))
       
(define-condition too-many-arguments (wrong-number-of-arguments) ())

(define-condition too-few-arguments (wrong-number-of-arguments) ())

(defun report-argument-mismatch (c s)
  (let* ((nargs-provided (wrong-number-of-arguments-nargs c))
	 (fn (wrong-number-of-arguments-fn c))
	 (too-many (typep c 'too-many-arguments)))
    (multiple-value-bind (min max scaled-nargs)
	(min-max-actual-args fn nargs-provided)
      (if (not min)
	(progn
	  (format s "Function ~s called with too ~a arguments. "
                  fn
                  (if too-many
                    "many"
                    "few")))
	(if too-many
	  (format s "Too many arguments in call to ~s:~&~d argument~:p provided, at most ~d accepted. " fn scaled-nargs max)
	  (format s "Too few arguments in call to ~s:~&~d argument~:p provided, at least ~d required. " fn  scaled-nargs min))))))



(define-condition compile-time-program-error (simple-program-error)
  nil ;((context :initarg :context :reader compile-time-program-error-context))
  (:report
   (lambda (c s)
     (format s "While compiling ~a :~%~a" 
             (simple-program-error-context c)
             (apply #'format nil (simple-condition-format-control c) (simple-condition-format-arguments c))))))



;;; Miscellaneous error during compilation (caused by macroexpansion, transforms, compile-time evaluation, etc.)
;;; NOT program-errors.
(define-condition compile-time-error (simple-error)
  ((context :initarg :context :reader compile-time-error-context))
  (:report
   (lambda (c s)
     (format s "While compiling ~a :~%~a" 
             (compile-time-error-context c)
             (format nil "~a" c)))))

(define-condition control-error (error) ())

(define-condition cant-throw-error (control-error)
  ((tag :initarg :tag))
  (:report (lambda (c s)
             (format s "Can't throw to tag ~s" (slot-value c 'tag)))))

(define-condition inactive-restart (control-error)
  ((restart-name :initarg :restart-name))
  (:report (lambda (c s)
	     (format s "Restart ~s is not active" (slot-value c 'restart-name)))))

(define-condition lock-protocol-error (control-error)
  ((lock :initarg :lock)))

(define-condition not-lock-owner (lock-protocol-error)
  ()
  (:report (lambda (c s)
	     (format s "Current process ~s does not own lock ~s"
		     *current-process* (slot-value c 'lock)))))

(define-condition not-locked (lock-protocol-error)
  ()
  (:report (lambda (c s)
	     (format s "Lock ~s isn't locked." (slot-value c 'lock)))))

(define-condition deadlock (lock-protocol-error)
  ()
  (:report (lambda (c s)
	     (format s "Requested operation on ~s would cause deadlock." (slot-value c 'lock)))))

(define-condition package-error (error)
  ((package :initarg :package :reader package-error-package)))
(define-condition no-such-package (package-error)
  ()
  (:report (lambda (c s) (format s (%rsc-string $xnopkg) (package-error-package c)))))
(define-condition unintern-conflict-error (package-error)
  ((sym-to-unintern :initarg :sym)
   (conflicting-syms :initarg :conflicts))
  (:report (lambda (c s)
             (format s (%rsc-string $xunintc) (slot-value c 'sym-to-unintern) (package-error-package c) (slot-value c 'conflicting-syms)))))

(define-condition import-conflict-error (package-error)
  ((imported-sym :initarg :imported-sym)
   (conflicting-sym :initarg :conflicting-sym)
   (conflict-external-p :initarg :conflict-external))
  (:report (lambda (c s)
             (format s (%rsc-string (if (slot-value c 'conflict-external-p) $ximprtcx $ximprtc))
                     (slot-value c 'imported-sym)
                     (package-error-package c)
                     (slot-value c 'conflicting-sym)))))

(define-condition use-package-conflict-error (package-error)
  ((package-to-use :initarg :package-to-use)
   (conflicts :initarg :conflicts)
   (external-p :initarg :external-p))
  (:report (lambda (c s)
             (format s (%rsc-string (if (slot-value c 'external-p) $xusecX $xusec))
                     (slot-value c 'package-to-use)
                     (package-error-package c)
                     (slot-value c 'conflicts)))))

(define-condition export-conflict-error (package-error)
  ((conflicts :initarg :conflicts))
  (:report 
   (lambda (c s)
     (format s "Name conflict~p detected by ~A :" (length (slot-value c 'conflicts)) 'export)
     (let* ((package (package-error-package c)))
       (dolist (conflict (slot-value c 'conflicts))
         (destructuring-bind (inherited-p sym-to-export using-package conflicting-sym) conflict
           (format s "~&~A'ing ~S from ~S would cause a name conflict with ~&~
                      the ~a symbol ~S in the package ~s, which uses ~S."
                   'export 
                   sym-to-export 
                   package 
                   (if inherited-p "inherited" "present")
                   conflicting-sym
                   using-package
                   package)))))))

(define-condition export-requires-import (package-error)
  ((to-be-imported :initarg :to-be-imported))
  (:report
   (lambda (c s)
     (let* ((p (package-error-package c)))
       (format s "The following symbols need to be imported to ~S before they can be exported ~& from that package:~%~s:" p (slot-value c 'to-be-imported))))))


(define-condition package-name-conflict-error (package-error simple-error) ())

(define-condition package-is-used-by (package-error)
  ((using-packages :initarg :using-packages))
  (:report (lambda (c s)
             (format s "~S is used by ~S" (package-error-package c)
                     (slot-value c 'using-packages)))))

(define-condition symbol-name-not-accessible (package-error)
  ((symbol-name :initarg :symbol-name))
  (:report (lambda (c s)
             (format s "No aymbol named ~S is accessible in package ~s"
                     (slot-value c 'symbol-name)
                     (package-error-package c)))))

(define-condition stream-error (error)
  ((stream :initarg :stream :reader stream-error-stream)))

(defun stream-error-context (condition)
  (let* ((stream (stream-error-stream condition)))
    (with-output-to-string (s)
       (format s "on ~s" stream)
       (let* ((pos (ignore-errors (stream-position stream))))
         (when pos
           (format s ", near position ~d" pos)))
       (let* ((surrounding (stream-surrounding-characters stream)))
         (when surrounding
           (format s ", within ~s" surrounding))))))

(define-condition parse-error (error) ())
(define-condition parse-integer-not-integer-string (parse-error)
  ((string :initarg :string))
  (:report (lambda (c s)
	     (format s "Not an integer string: ~s" (slot-value c 'string)))))

(define-condition reader-error (parse-error stream-error) ())
(define-condition end-of-file (stream-error) ()
  (:report (lambda (c s)
             (format s "Unexpected end of file ~a" (stream-error-context c)))))

(define-condition stream-is-closed-error (stream-error)
  ()
  (:report (lambda (condition stream)
	     (format stream "~s is closed"
		     (stream-error-stream condition)))))

(define-condition io-timeout (stream-error)
  ())

(define-condition input-timeout (io-timeout)
  ()
  (:report (lambda (c s)
             (format s "Input timeout on ~s" (stream-error-stream c)))))
(define-condition output-timeout (io-timeout)
  ()
  (:report (lambda (c s)
             (format s "Output timeout on ~s" (stream-error-stream c)))))
(define-condition communication-deadline-expired (io-timeout)
  ()
  (:report (lambda (c s)
             (format s "Communication deadline timeout on ~s" (stream-error-stream c)))))
 



(define-condition impossible-number (reader-error)
  ((token :initarg :token :reader impossible-number-token)
   (condition :initarg :condition :reader impossible-number-condition))
  (:report (lambda (c s)
             (format s "Condition of type ~s raised ~&while trying to parse numeric token ~s ~&~s"
                     (type-of (impossible-number-condition c))
                     (impossible-number-token c)
                     (stream-error-context c)))))


    
(define-condition simple-stream-error (stream-error simple-condition) () 
  (:report (lambda (c s) 
             (format s "~a : ~&~a" (stream-error-context c) 
                     (apply #'format
                            nil
                            (simple-condition-format-control c)
                            (simple-condition-format-arguments c))))))




(define-condition file-error (error)
  ((pathname :initarg :pathname :initform "<unspecified>" :reader file-error-pathname)
   (error-type :initarg :error-type :initform "File error on file ~S"))
  (:report (lambda (c s)
              (format s (slot-value c 'error-type) 
                     (file-error-pathname c)))))

(define-condition simple-file-error (simple-condition file-error)
  ()
  (:report (lambda (c s)
	     (apply #'format s (slot-value c 'error-type) 
		    (file-error-pathname c)
		    (simple-condition-format-arguments c)))))


(define-condition namestring-parse-error (error)
  ((complaint :reader namestring-parse-error-complaint :initarg :complaint)
   (arguments :reader namestring-parse-error-arguments :initarg :arguments
	      :initform nil)
   (namestring :reader namestring-parse-error-namestring :initarg :namestring)
   (offset :reader namestring-parse-error-offset :initarg :offset))
  (:report (lambda (condition stream)  
  (format stream "Parse error in namestring: ~?~%  ~A~%  ~V@T^"
	  (namestring-parse-error-complaint condition)
	  (namestring-parse-error-arguments condition)
	  (namestring-parse-error-namestring condition)
	  (namestring-parse-error-offset condition)))))

(define-condition cell-error (error)
  ((name :initarg :name :reader cell-error-name)
   (error-type :initarg :error-type :initform "Cell error" :reader cell-error-type))
  (:report (lambda (c s) (format s "~A: ~S" (cell-error-type c) (cell-error-name c)))))

(define-condition unbound-variable (cell-error)
  ((error-type :initform "Unbound variable")))

(define-condition undefined-function (cell-error)
  ((error-type :initform "Undefined function")))
(define-condition undefined-function-call (control-error undefined-function)
  ((function-arguments :initarg :function-arguments :reader undefined-function-call-arguments))
  (:report (lambda (c s) (format s "Undefined function ~S called with arguments ~:S ."
                                 (cell-error-name c)
                                 (undefined-function-call-arguments c)))))

(define-condition call-special-operator-or-macro (undefined-function-call)
  ()
  (:report (lambda (c s) (format s "Special operator or global macro-function ~s can't be FUNCALLed or APPLYed" (cell-error-name c)))))

  
(define-condition unbound-slot (cell-error)
  ((instance :initarg :instance :accessor unbound-slot-instance))
  (:report (lambda (c s) (format s "Slot ~s is unbound in ~s"
                                 (cell-error-name c)
                                 (unbound-slot-instance c)))))
  

(define-condition arithmetic-error (error) 
  ((operation :initform nil :initarg :operation :reader arithmetic-error-operation)
   (operands :initform nil :initarg :operands :reader arithmetic-error-operands)
   (status :initform nil :initarg :status :reader arithmetic-error-status))
  (:report (lambda (c s)
             (format s "~S detected" (type-of c))
             (let* ((operands (arithmetic-error-operands c)))
               (when operands
                 (format s "~&performing ~A on ~:S"
                         (arithmetic-error-operation c) 
                         operands))))))

(define-condition division-by-zero (arithmetic-error) ())
  
(define-condition floating-point-underflow (arithmetic-error) ())
(define-condition floating-point-overflow (arithmetic-error) ())
(define-condition floating-point-inexact (arithmetic-error) ())
(define-condition floating-point-invalid-operation (arithmetic-error) ())

(define-condition compiler-bug (simple-error)
  ()
  (:report (lambda (c stream)
                  (format stream "Compiler bug or inconsistency:~%")
                  (apply #'format stream (simple-condition-format-control c)
                         (simple-condition-format-arguments c)))))

(define-condition external-process-creation-failure (serious-condition)
  ((proc :initarg :proc))
  (:report (lambda (c stream)
             (with-slots (proc) c
               (let* ((code (external-process-%exit-code proc)))
                 (format stream "Fork failed in ~s: ~a. " proc (if (eql code -1) "random lisp error" (%strerror code))))))))
   

(define-condition simple-reader-error (reader-error simple-error) ()
  (:report (lambda (c output-stream)
             (format output-stream "Reader error ~a:~%~?"
                     (stream-error-context c)
                     (simple-condition-format-control c)
                     (simple-condition-format-arguments c)))))

;;; This condition is signalled whenever we make a UNKNOWN-TYPE so that
;;; compiler warnings can be emitted as appropriate.
;;;
(define-condition parse-unknown-type (condition)
  ((specifier :reader parse-unknown-type-specifier :initarg :specifier))
  (:report (lambda (c s) (print-unreadable-object (c s :type t)
			   (format s "unknown type ~A" (parse-unknown-type-specifier c))))))

(define-condition no-applicable-method-exists (error)
  ((gf :initarg :gf)
   (args :initarg :args))
  (:report (lambda (c s)
             (with-slots (gf args) c
               (format s "There is no applicable method for the generic function:~%  ~s~%when called with arguments:~%  ~s" gf args)))))

(defun restartp (thing) 
  (istruct-typep thing 'restart))
(setf (type-predicate 'restart) 'restartp)

(defmethod print-object ((restart restart) stream)
  (let ((report (%restart-report restart)))
    (cond ((or *print-escape* (null report))
           (print-unreadable-object (restart stream :identity t)
             (format stream "~S ~S"
                     'restart (%restart-name restart))))
          ((stringp report)
           (write-string report stream))
          (t
           (funcall report stream)))))

(defun %make-restart (name action report interactive test)
  (%cons-restart name action report interactive test))

(defun make-restart (vector name action-function &key report-function interactive-function test-function)
  (unless vector (setq vector (%cons-restart nil nil nil nil nil)))
  (setf (%restart-name vector) name
        (%restart-action vector) (require-type action-function 'function)
        (%restart-report vector) (if report-function (require-type report-function 'function))
        (%restart-interactive vector) (if interactive-function (require-type interactive-function 'function))
        (%restart-test vector) (if test-function (require-type test-function 'function)))
  vector)

(defun restart-name (restart)
  "Return the name of the given restart object."
  (%restart-name (require-type restart 'restart)))

(defun applicable-restart-p (restart condition)
  (let* ((pair (if condition (assq restart *condition-restarts*)))
         (test (%restart-test restart)))
    (and (or (null pair) (eq (%cdr pair) condition))
         (or (null test) (funcall test condition)))))

(defun compute-restarts (&optional condition &aux restarts)
  "Return a list of all the currently active restarts ordered from most
   recently established to less recently established. If CONDITION is
   specified, then only restarts associated with CONDITION (or with no
   condition) will be returned."
  (dolist (cluster %restarts% (nreverse restarts))
    (dolist (restart cluster)
      (when (applicable-restart-p restart condition)
        (push restart restarts)))))

(defun find-restart (name &optional condition)
  "Return the first active restart named NAME. If NAME names a
   restart, the restart is returned if it is currently active. If no such
   restart is found, NIL is returned. It is an error to supply NIL as a
   name. If CONDITION is specified and not NIL, then only restarts
   associated with that condition (or with no condition) will be
   returned."
  (if (typep name 'restart)
    (dolist (cluster %restarts%)
      (dolist (restart cluster)
        (if (eq restart name)
          (return-from find-restart restart))))
    (dolist (cluster %restarts%)
      (dolist (restart cluster)
        (when (and (eq (restart-name restart) name)
                   (applicable-restart-p restart condition))
          (return-from find-restart restart))))))

(defun %active-restart (name)
  (dolist (cluster %restarts%)
    (dolist (restart cluster)
      (when (or (eq restart name)
                (let* ((rname (%restart-name restart)))
                  (and (eq rname name)
                       (applicable-restart-p restart nil))))
                (return-from %active-restart (values restart cluster)))))
  (error 'inactive-restart :restart-name name))

(defun invoke-restart (restart &rest values)
  "Calls the function associated with the given restart, passing any given
   arguments. If the argument restart is not a restart or a currently active
   non-nil restart name, then a CONTROL-ERROR is signalled."
  (multiple-value-bind (restart tag) (%active-restart restart)
    (let ((fn (%restart-action restart)))
      (cond ((null fn)                  ; simple restart
             (unless (null values) (%err-disp $xtminps))
             (throw tag nil))
            ((fixnump fn)               ; restart case
             (throw tag (cons fn values)))
            ((functionp fn)		; restart bind
	     (apply fn values))		
	    (t				; with-simple-restart
	     (throw tag (values nil t)))))))

(defun invoke-restart-no-return (restart &rest values)
  (declare (dynamic-extent values))
  (apply #'invoke-restart restart values)
  (error 'restart-failure :restart restart))

(defun invoke-restart-interactively (restart)
  "Calls the function associated with the given restart, prompting for any
   necessary arguments. If the argument restart is not a restart or a
   currently active non-NIL restart name, then a CONTROL-ERROR is signalled."
  (let* ((restart (%active-restart restart)))
    (format *error-output* "~&Invoking restart: ~a~&" restart)
    (let* ((argfn (%restart-interactive restart))
           (values (when argfn (funcall argfn))))
      (apply #'invoke-restart restart values))))



(defun maybe-invoke-restart (restart value condition)
  (let ((restart (find-restart restart condition)))
    (when restart (invoke-restart restart value))))

(defun use-value (value &optional condition)
  "Transfer control and VALUE to a restart named USE-VALUE, or return NIL if
   none exists."
  (maybe-invoke-restart 'use-value value condition))

(defun store-value (value &optional condition)
  "Transfer control and VALUE to a restart named STORE-VALUE, or return NIL if
   none exists."
  (maybe-invoke-restart 'store-value value condition))

(defun condition-arg (thing args type)
  (cond ((condition-p thing) (if args (%err-disp $xtminps) thing))
        ((symbolp thing) (apply #'make-condition thing args))
        (t (make-condition type :format-control thing :format-arguments args))))

(defun make-condition (name &rest init-list)
  "Make an instance of a condition object using the specified initargs."
  (declare (dynamic-extent init-list))
  (if (subtypep name 'condition)
    (apply #'make-instance name init-list)
    (let ((class (if (classp name)
		   name
		   (find-class name)))) ;; elicit an error if no such class
      (unless (class-finalized-p class)
	(finalize-inheritance class)) ;; elicit an error if forward refs.
      (error "~S is not a condition class" class))))

(defmethod print-object ((c condition) stream)
  (if *print-escape* 
    (call-next-method)
    (report-condition c stream)))

(defmethod report-condition ((c condition) stream)
  (princ (cond ((typep c 'error) "Error ")
               ((typep c 'warning) "Warning ")
               (t "Condition "))
         stream)
  ;Here should dump all slots or something.  For now...
  (let ((*print-escape* t))
    (print-object c stream)))

(defun signal-simple-condition (class-name format-string &rest args)
  (let ((e #'error))  ; Never-tail-call.
    (funcall e (make-condition class-name :format-control format-string :format-arguments args))))

(defun signal-simple-program-error (format-string &rest args)
  (apply #'signal-simple-condition 'simple-program-error format-string args))

;;getting the function name for error functions.


(defun %last-fn-on-stack (&optional (number 0) (s (%get-frame-ptr)))
  (let* ((fn nil))
    (let ((p s))
      (dotimes (i number)
        (declare (fixnum i))
        (unless (setq p (parent-frame p nil))
          (return)))
      (do* ((i number (1+ i)))
           ((null p))
        (if (setq fn (cfp-lfun p))
          (return (values fn i))
          (setq p (parent-frame p nil)))))))
 
(defun %err-fn-name (lfun)
  "given an lfun returns the name or the string \"Unknown\""
  (if (lfunp lfun) (or (lfun-name lfun) lfun)
     (or lfun "Unknown")))

(defun %real-err-fn-name (error-pointer)
  (multiple-value-bind (fn p) (%last-fn-on-stack 0 error-pointer)
    (let ((name (%err-fn-name fn)))
      (if (and (memq name '( call-check-regs)) p)
        (%err-fn-name (%last-fn-on-stack (1+ p) error-pointer))
        name))))


;; Some simple restarts for simple error conditions.  Callable from the kernel.

(defun find-unique-homonyms (name &optional (test (constantly t)))
  (delete-duplicates
   (loop
     with symbol = (if (consp name) (second name) name)
     with pname = (symbol-name symbol)
     for package in (list-all-packages)
     for other-package-symbol = (find-symbol pname package)
     for canditate = (and other-package-symbol
                          (neq other-package-symbol symbol)
                          (if (consp name)
                            (list (first name) other-package-symbol)
                            other-package-symbol))
     when (and canditate
               (funcall test canditate))
       collect canditate)
   :test #'equal))

(def-kernel-restart $xvunbnd %default-unbound-variable-restarts (frame-ptr cell-name)
  (unless *level-1-loaded*
    (dbg cell-name))       ;  user should never see this.
  (let ((condition (make-condition 'unbound-variable :name cell-name))
	(other-variables (find-unique-homonyms cell-name (lambda (name)
                                                           (and (not (keywordp name))
                                                                (boundp name))))))
    (flet ((new-value ()
             (catch-cancel
              (return-from new-value
                           (list (read-from-string 
                                  (get-string-from-user
                                   (format nil "New value for ~s : " cell-name))))))
             (continue condition))) ; force error again if cancelled, var still not set.
      (restart-case (%error condition nil frame-ptr)
        (continue ()
                  :report (lambda (s) (format s "Retry getting the value of ~S." cell-name))
                  (symbol-value cell-name))
        (use-homonym (homonym)
                     :test (lambda (c) (and (or (null c) (eq c condition)) other-variables))
                     :report (lambda (s)
                               (if (= 1 (length other-variables))
                                 (format s "Use the value of ~s this time." (first other-variables))
                                 (format s "Use one of the homonyms ~{~S or ~} this time." other-variables)))
                     :interactive (lambda ()
                                    (if (= 1 (length other-variables))
                                      other-variables
                                      (select-item-from-list other-variables :window-title "Select homonym to use")))
                     (symbol-value homonym))
        (use-value (value)
                   :interactive new-value
                   :report (lambda (s) (format s "Specify a value of ~S to use this time." cell-name))
                   value)
        (store-value (value)
                     :interactive new-value
                     :report (lambda (s) (format s "Specify a value of ~S to store and use." cell-name))
                     (setf (symbol-value cell-name) value))))))

(def-kernel-restart $xnopkg %default-no-package-restart (frame-ptr package-name)
  (or (and *autoload-lisp-package*
           (or (string-equal package-name "LISP") 
               (string-equal package-name "USER"))
           (progn
             (require "LISP-PACKAGE")
             (find-package package-name)))
      (let* ((alias (or (%cdr (assoc package-name '(("LISP" . "COMMON-LISP")
                                                    ("USER" . "CL-USER")) 
                                     :test #'string-equal))
                        (if (packagep *package*) (package-name *package*))))
             (condition (make-condition 'no-such-package :package package-name)))
        (flet ((try-again (p)
                          (or (find-package p) (%kernel-restart $xnopkg p))))
          (restart-case
            (restart-case (%error condition nil frame-ptr)
              (continue ()
                        :report (lambda (s) (format s "Retry finding package with name ~S." package-name))
                        (try-again package-name))
              (use-value (value)
                         :interactive (lambda () (block nil 
                                                   (catch-cancel
                                                    (return (list (get-string-from-user
                                                                   "Find package named : "))))
                                                   (continue condition)))
                         :report (lambda (s) (format s "Find specified package instead of ~S ." package-name))
                         (try-again value))
              (make-nickname ()
                             :report (lambda (s) (format s "Make ~S be a nickname for package ~S." package-name alias))
                             (let ((p (try-again alias)))
                               (push package-name (cdr (pkg.names p)))
                               p)))
            (require-lisp-package ()
                                  :test (lambda (c)
                                          (and (eq c condition)
                                               (or (string-equal package-name "LISP") (string-equal package-name "USER"))))
                                  :report (lambda (s) 
                                            (format s "(require :lisp-package) and retry finding package ~s"
                                                    package-name))
                                  (require "LISP-PACKAGE")
                                  (try-again package-name)))))))

(def-kernel-restart $xunintc unintern-conflict-restarts (frame-ptr sym package conflicts)
  (let ((condition (make-condition 'unintern-conflict-error :package package :sym sym :conflicts conflicts)))
    (restart-case (%error condition nil frame-ptr)
      (continue ()
                :report (lambda (s) (format s "Try again to unintern ~s from ~s" sym package))
                (unintern sym package))
      (do-shadowing-import (ssym)
                           :report (lambda (s) (format s "SHADOWING-IMPORT one of ~S in ~S." conflicts package))
                           :interactive (lambda ()
                                          (block nil
                                            (catch-cancel
                                             (return (select-item-from-list conflicts 
                                                                            :window-title 
                                                                            (format nil "Shadowing-import one of the following in ~s" package)
                                                                            :table-print-function #'prin1)))
                                            (continue condition)))
                           (shadowing-import (list ssym) package)))))


(def-kernel-restart $xusec blub (frame-ptr package-to-use using-package conflicts)
  (resolve-use-package-conflict-error frame-ptr package-to-use using-package conflicts nil))

(def-kernel-restart $xusecX blub (frame-ptr package-to-use using-package conflicts)
  (resolve-use-package-conflict-error frame-ptr package-to-use using-package conflicts t))

(defun resolve-use-package-conflict-error (frame-ptr package-to-use using-package conflicts external-p)
  (let ((condition (make-condition 'use-package-conflict-error 
                                   :package using-package
                                   :package-to-use package-to-use
                                   :conflicts conflicts
                                   :external-p external-p)))
    (flet ((external-test (&rest ignore) (declare (ignore ignore)) external-p)
           (present-test (&rest ignore) (declare (ignore ignore)) (not external-p)))
      (declare (dynamic-extent #'present-test #'external-test))
      (restart-case (%error condition nil frame-ptr)
        (continue ()
                  :report (lambda (s) (format s "Try again to use ~s in ~s" package-to-use using-package)))
        (resolve-by-shadowing-import (&rest shadowing-imports)
                                     :test external-test
                                     :interactive (lambda ()
                                                    (mapcar #'(lambda (pair) 
                                                                (block nil
                                                                  (catch-cancel
                                                                    (return (car (select-item-from-list pair
                                                                                                        :window-title 
                                                                                                        (format nil "Shadowing-import one of the following in ~s" using-package)
                                                                                                        :table-print-function #'prin1))))
                                                                  (continue condition)))
                                                            conflicts))
                                     :report (lambda (s) (format s "SHADOWING-IMPORT one of each pair of conflicting symbols."))
                                     (shadowing-import shadowing-imports using-package))
        (unintern-all ()
                      :test present-test
                      :report (lambda (s) (format s "UNINTERN all conflicting symbols from ~S" using-package))
                      (dolist (c conflicts)
                        (unintern (car c) using-package)))
        (shadow-all ()
                      :test present-test
                      :report (lambda (s) (format s "SHADOW all conflicting symbols in ~S" using-package))
                      (dolist (c conflicts)
                        (shadow-1 using-package (car c))))
        (resolve-by-unintern-or-shadow (&rest dispositions)
                                       :test present-test
                                       :interactive (lambda ()
                                                      (mapcar #'(lambda (pair)
                                                                  (let* ((present-sym (car pair)))
                                                                    (block nil
                                                                      (catch-cancel
                                                                        (return (car (select-item-from-list (list 'shadow 'unintern) 
                                                                                                            :window-title
                                                                                                            (format nil "SHADOW ~S in, or UNINTERN ~S from ~S" 
                                                                                                                    present-sym 
                                                                                                                    present-sym
                                                                                                                    using-package)
                                                                                                            :table-print-function #'prin1)))
                                                                        (continue condition)))))
                                                              conflicts))
                                       :report (lambda (s) (format s "SHADOW or UNINTERN the conflicting symbols in ~S." using-package))
                                       (dolist (d dispositions)
                                         (let* ((sym (car (pop conflicts))))
                                           (if (eq d 'shadow)
                                             (shadow-1 using-package sym)
                                             (unintern sym using-package)))))))))


(defun resolve-export-conflicts (conflicts package)
  (let* ((first-inherited (caar conflicts))
         (all-same (dolist (conflict (cdr conflicts) t)
                     (unless (eq (car conflict) first-inherited) (return nil))))
         (all-inherited (and all-same first-inherited))
         (all-present (and all-same (not first-inherited)))
         (condition (make-condition 'export-conflict-error
                                    :conflicts conflicts
                                    :package package)))
    (flet ((check-again () 
             (let* ((remaining-conflicts (check-export-conflicts (mapcar #'cadr conflicts) package)))
               (if remaining-conflicts (resolve-export-conflicts remaining-conflicts package)))))
      (restart-case (%error condition nil (%get-frame-ptr))
        (resolve-all-by-shadowing-import-inherited 
         ()
         :test (lambda (&rest ignore) (declare (ignore ignore)) all-inherited)
         :report (lambda (s) (format s "SHADOWING-IMPORT all conflicting inherited symbol(s) in using package(s)."))
         (dolist (conflict conflicts (check-again))
           (destructuring-bind (using-package inherited-sym) (cddr conflict)
             (shadowing-import-1 using-package inherited-sym))))
        (resolve-all-by-shadowing-import-exported 
         ()
         :test (lambda (&rest ignore) (declare (ignore ignore)) all-inherited)
         :report (lambda (s) (format s "SHADOWING-IMPORT all conflicting symbol(s) to be exported in using package(s)."))
         (dolist (conflict conflicts (check-again))
           (destructuring-bind (exported-sym using-package ignore) (cdr conflict)
             (declare (ignore ignore))
             (shadowing-import-1 using-package exported-sym))))
        (resolve-all-by-uninterning-present 
         ()
         :test (lambda (&rest ignore) (declare (ignore ignore)) all-present)
         :report (lambda (s) (format s "UNINTERN all present conflicting symbol(s) in using package(s)."))
         (dolist (conflict conflicts (check-again))
           (destructuring-bind (using-package inherited-sym) (cddr conflict)
             (unintern inherited-sym using-package))))
        (resolve-all-by-shadowing-present 
         ()
         :test (lambda (&rest ignore) (declare (ignore ignore)) all-present)
         :report (lambda (s) (format s "SHADOW all present conflicting symbol(s) in using package(s)."))
         (dolist (conflict conflicts (check-again))
           (destructuring-bind (using-package inherited-sym) (cddr conflict)
             (shadow-1 using-package inherited-sym))))
        (review-and-resolve 
         (dispositions)
         :report (lambda (s) (format s "Review each name conflict and resolve individually."))
         :interactive (lambda ()
                        (let* ((disp nil))
                          (block b
                            (catch-cancel
                              (dolist (conflict conflicts (return-from b (list disp)))
                                (destructuring-bind (inherited-p exported-sym using-package conflicting-sym) conflict
                                  (let* ((syms (list exported-sym conflicting-sym)))
                                    (if inherited-p
                                      (push (list 'shadowing-import
                                                  (select-item-from-list syms
                                                                              :window-title 
                                                                              (format nil "Shadowing-import one of the following in ~s" using-package)
                                                                              :table-print-function #'prin1)
                                                  using-package)
                                            disp)
                                      (let* ((selection (car (select-item-from-list syms
                                                                                    :window-title 
                                                                                    (format nil "Shadow ~S or unintern ~s in ~s"
                                                                                            exported-sym 
                                                                                            conflicting-sym using-package)
                                                                                    :table-print-function #'prin1))))
                                        (push (if (eq selection 'exported-sym)
                                                (list 'shadow (list exported-sym) using-package)
                                                (list 'unintern conflicting-sym using-package))
                                              disp)))))))
                            nil)))
         (dolist (disp dispositions (check-again))
           (apply (car disp) (cdr disp))))))))


(def-kernel-restart $xwrongtype default-require-type-restarts (frame-ptr value typespec)
  (setq typespec (%type-error-type typespec))
  (let ((condition (make-condition 'type-error 
                                   :datum value
                                   :expected-type typespec)))
    (restart-case (%error condition nil frame-ptr)
      (use-value (newval)
                 :report (lambda (s)
                           (format s "Use a new value of type ~s instead of ~s." typespec value))
                 :interactive (lambda ()
                                (format *query-io* "~&New value of type ~S :" typespec)
                                (list (read *query-io*)))
                 (require-type newval typespec)))))

(def-kernel-restart $xudfcall default-undefined-function-call-restarts (frame-ptr function-name args)
  (unless *level-1-loaded*
    (dbg function-name))   ; user should never see this
  (let ((condition (make-condition 'undefined-function-call
                                   :name function-name
                                   :function-arguments args))
	(other-functions (find-unique-homonyms function-name #'fboundp)))
    (restart-case (%error condition nil frame-ptr)
      (continue ()
                :report (lambda (s) (format s "Retry applying ~S to ~S." function-name args))
                (apply function-name args))
      (use-homonym (function-name)
                   :test (lambda (c) (and (or (null c) (eq c condition)) other-functions))
                   :report (lambda (s)
                             (if (= 1 (length other-functions))
                               (format s "Apply ~s to ~S this time." (first other-functions) args)
                               (format s "Apply one of ~{~S or ~} to ~S this time."
                                       other-functions args)))
                   :interactive (lambda ()
                                  (if (= 1 (length other-functions))
                                    other-functions
                                    (select-item-from-list other-functions :window-title "Select homonym to use")))
                   (apply (fdefinition function-name) args))
      (use-value (function)
                 :interactive (lambda ()
                                (format *query-io* "Function to apply instead of ~s :" function-name)
                                (let ((f (read *query-io*)))
                                  (unless (symbolp f) (setq f (eval f))) ; almost-the-right-thing (tm)
                                  (list (coerce f 'function))))
                 :report (lambda (s) (format s "Apply specified function to ~S this time." args))
                 (apply function args))
      (store-value (function)
                   :interactive (lambda ()
                                (format *query-io* "Function to apply as new definition of ~s :" function-name)
                                (let ((f (read *query-io*)))
                                  (unless (symbolp f) (setq f (eval f))) ; almost-the-right-thing (tm)
                                  (list (coerce f 'function))))
                   :report (lambda (s) (format s "Specify a function to use as the definition of ~S." function-name))
                   (apply (setf (symbol-function function-name) function) args)))))



(defun %check-type (value typespec placename typename)
  (let ((condition (make-condition 'type-error 
                                   :datum value
                                   :expected-type typespec)))
    (if typename
      (setf (slot-value condition 'format-control)
            (format nil "value ~~S is not ~A (~~S)." typename)))
    (restart-case (%error condition nil (%get-frame-ptr))
                  (store-value (newval)
                               :report (lambda (s)
                                         (format s "Assign a new value of type ~a to ~s" typespec placename))
                               :interactive (lambda ()
                                              (format *query-io* "~&New value for ~S :" placename)
                                              (list (eval (read))))
                               newval))))


; This has to be defined fairly early (assuming, of course, that it "has" to be defined at all ...

(defun ensure-value-of-type (value typespec placename &optional typename)
  (tagbody
    again
    (unless (typep value typespec)
      (let ((condition (make-condition 'type-error 
                                       :datum value
                                       :expected-type typespec)))
        (if typename
            (setf (slot-value condition 'format-control)
                  (format nil "value ~~S is not ~A (~~S)." typename)))
        (restart-case (%error condition nil (%get-frame-ptr))
          (store-value (newval)
                       :report (lambda (s)
                                 (format s "Assign a new value of type ~a to ~s" typespec placename))
                       :interactive (lambda ()
                                      (format *query-io* "~&New value for ~S :" placename)
                                      (list (eval (read))))
                       (setq value newval)
                       (go again))))))
  value)

;;;The Error Function

(defparameter *kernel-simple-error-classes*
  (list (cons $xcalltoofew 'simple-destructuring-error)
        (cons $xcalltoomany 'simple-destructuring-error)
        (cons $xstkover 'stack-overflow-condition)
        (cons $xmemfull 'simple-storage-condition)
        (cons $xwrongtype 'type-error) ; this one needs 2 args
        (cons $xdivzro 'division-by-zero)
        (cons $xflovfl 'floating-point-overflow)
        (cons $xfunbnd 'undefined-function)
	(cons $xbadkeys 'simple-program-error)
        (cons $xcallnomatch 'simple-program-error)
        (cons $xnotfun 'call-special-operator-or-macro)
        (cons $xaccessnth 'sequence-index-type-error)
	(cons $ximproperlist 'improper-list)
	(cons $xnospread 'cant-construct-arglist)
        (cons $xnotelt 'array-element-type-error)
        ))


(defparameter *simple-error-types*
  (vector nil 'simple-program-error 'simple-file-error))

(defconstant $pgm-err #x10000)




(defparameter %type-error-typespecs%
  #(array
    bignum
    fixnum
    character
    integer
    list
    number
    sequence
    simple-string
    simple-vector
    string
    symbol
    macptr
    real
    cons
    unsigned-byte
    (integer 2 36)
    float
    rational
    ratio
    short-float
    double-float
    complex
    vector
    simple-base-string
    function
    (unsigned-byte 16)
    (unsigned-byte 8)
    (unsigned-byte 32)
    (signed-byte 32)
    (signed-byte 16)
    (signed-byte 8)
    base-char
    bit
    (unsigned-byte 24)                  ; (integer 0 (array-total-size-limit))
    (unsigned-byte 64)
    (signed-byte 64)
    (unsigned-byte 56)
    (simple-array double-float (* *))
    (simple-array single-float (* *))
    (mod #x110000)
    (array * (* *))                     ;2d array
    (array * (* * *))                   ;3d array
    (array t)
    (array bit)
    (array (signed-byte 8))
    (array (unsigned-byte 8))
    (array (signed-byte 16))
    (array (unsigned-byte 16))
    (array (signed-byte 32))
    (array (unsigned-byte 32))
    (array (signed-byte 64))
    (array (unsigned-byte 64))
    (array fixnum)
    (array single-float)
    (array double-float)
    (array character)
    (array t (* *))
    (array bit (* *))
    (array (signed-byte 8) (* *))
    (array (unsigned-byte 8) (* *))
    (array (signed-byte 16) (* *))
    (array (unsigned-byte 16) (* *))
    (array (signed-byte 32) (* *))
    (array (unsigned-byte 32) (* *))
    (array (signed-byte 64) (* *))
    (array (unsigned-byte 64) (* *))
    (array fixnum (* *))
    (array single-float (* *))
    (array double-float (* *))
    (array character (* *))
    (simple-array t (* *))
    (simple-array bit (* *))
    (simple-array (signed-byte 8) (* *))
    (simple-array (unsigned-byte 8) (* *))
    (simple-array (signed-byte 16) (* *))
    (simple-array (unsigned-byte 16) (* *))
    (simple-array (signed-byte 32) (* *))
    (simple-array (unsigned-byte 32) (* *))
    (simple-array (signed-byte 64) (* *))
    (simple-array (unsigned-byte 64) (* *))
    (simple-array fixnum (* *))
    (simple-array character (* *))
    (array t (* * *))
    (array bit (* * *))
    (array (signed-byte 8) (* * *))
    (array (unsigned-byte 8) (* * *))
    (array (signed-byte 16) (* * *))
    (array (unsigned-byte 16) (* * *))
    (array (signed-byte 32) (* * *))
    (array (unsigned-byte 32) (* * *))
    (array (signed-byte 64) (* * *))
    (array (unsigned-byte 64) (* * *))
    (array fixnum (* * *))
    (array single-float (* * *))
    (array double-float (* * *))
    (array character (* * *))
    (simple-array t (* * *))
    (simple-array bit (* * *))
    (simple-array (signed-byte 8) (* * *))
    (simple-array (unsigned-byte 8) (* * *))
    (simple-array (signed-byte 16) (* * *))
    (simple-array (unsigned-byte 16) (* * *))
    (simple-array (signed-byte 32) (* * *))
    (simple-array (unsigned-byte 32) (* * *))
    (simple-array (signed-byte 64) (* * *))
    (simple-array (unsigned-byte 64) (* * *))
    (simple-array fixnum (* * *))
    (simple-array single-float (* * *))
    (simple-array double-float (* * *))
    (simple-array character (* * *))

    (vector t)
    bit-vector
    (vector (signed-byte 8))
    (vector (unsigned-byte 8))
    (vector (signed-byte 16))
    (vector (unsigned-byte 16))
    (vector (signed-byte 32))
    (vector (unsigned-byte 32))
    (vector (signed-byte 64))
    (vector (unsigned-byte 64))
    (vector fixnum)
    (vector single-float)
    (vector double-float)

    ))


(defun %type-error-type (type)
  (if (fixnump type) 
    (svref %type-error-typespecs% type)
    type))

(defun %typespec-id (typespec)
  (flet ((type-equivalent (t1 t2) (ignore-errors (and (subtypep t1 t2) (subtypep t2 t1)))))
    (position typespec %type-error-typespecs% :test #'type-equivalent)))


(defmethod condition-p ((x t)) nil)
(defmethod condition-p ((x condition)) t)



(let* ((globals ()))

  (defun %check-error-globals ()
    (let ((vars ())
          (valfs ())
          (oldvals ()))
      (dolist (g globals (values vars valfs oldvals))
        (destructuring-bind (sym predicate newvalf) g
          (let* ((boundp (boundp sym))
                 (oldval (if boundp (symbol-value sym) (%unbound-marker-8))))
          (unless (and boundp (funcall predicate oldval))
            (push sym vars)
            (push oldval oldvals)
            (push newvalf valfs)))))))

  (defun check-error-global (sym checkfn newvalfn)
    (setq sym (require-type sym 'symbol)
          checkfn (require-type checkfn 'function)
          newvalfn (require-type newvalfn 'function))
    (let ((found (assq sym globals)))
      (if found
        (setf (cadr found) checkfn (caddr found) newvalfn)
        (push (list sym checkfn newvalfn) globals))
      sym))
)

(check-error-global '*package* #'packagep #'(lambda () (find-package "CL-USER")))


(flet ((io-stream-p (x) (and (streamp x) (eq (stream-direction x) :io)))
       (is-input-stream-p (x) (and (streamp x) (input-stream-p x)))
       (is-output-stream-p (x) (and (streamp x) (output-stream-p x)))
       (default-terminal-io () (make-echoing-two-way-stream *stdin* *stdout*))
       (terminal-io () *terminal-io*)
       (standard-output () *standard-output*))

  ;; Note that order matters.  These need to come out of %check-error-globals with
  ;; *terminal-io* first and *trace-output* last
  (check-error-global '*terminal-io* #'io-stream-p #'default-terminal-io)
  (check-error-global '*query-io* #'io-stream-p #'terminal-io)
  (check-error-global '*debug-io* #'io-stream-p #'terminal-io)
  (check-error-global '*standard-input* #'is-input-stream-p #'terminal-io)
  (check-error-global '*standard-output* #'is-output-stream-p #'terminal-io)
  (check-error-global '*error-output* #'is-output-stream-p #'standard-output)
  (check-error-global '*trace-output* #'is-output-stream-p #'standard-output))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-error-system.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-typesys.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; This is a hacked-up version of the CMU CL type system.

(in-package "CCL")




(defun parse-lambda-list (list)
  (let* ((required)
         (optional)
         (keys)
         (aux))
    (let ((restp nil)
          (rest nil)
          (keyp nil)
          (allowp nil)
          (state :required))
      (dolist (arg list)
        (if (and (symbolp arg)
                 (let ((name (symbol-name arg)))
                   (and (/= (length name) 0)
                        (char= (char name 0) #\&))))
          (case arg
            (&optional
             (unless (eq state :required)
               (error "Misplaced &optional in lambda-list: ~S." list))
             (setq state '&optional))
            (&rest
             (unless (member state '(:required &optional))
               (error "Misplaced &rest in lambda-list: ~S." list))
             (setq state '&rest))
            (&key
             (unless (member state '(:required &optional :post-rest
                                     ))
               (error "Misplaced &key in lambda-list: ~S." list))
             (setq keyp t)
             (setq state '&key))
            (&allow-other-keys
             (unless (eq state '&key)
               (error "Misplaced &allow-other-keys in lambda-list: ~S." list))
             (setq allowp t  state '&allow-other-keys))
            (&aux
             (when (member state '(&rest))
               (error "Misplaced &aux in lambda-list: ~S." list))
             (setq state '&aux))
            (t
             (error "Unknown &keyword in lambda-list: ~S." arg)))
          (case state
            (:required (push arg required))
            (&optional (push arg optional))
            (&rest
             (setq restp t  rest arg  state :post-rest))
            (&key (push arg keys))
            (&aux (push arg aux))
            (t
             (error "Found garbage in lambda-list when expecting a keyword: ~S." arg)))))
      
      (values (nreverse required) (nreverse optional) restp rest keyp (nreverse keys) allowp (nreverse aux)))))

(defvar %deftype-expanders% (make-hash-table :test #'eq))
(defvar *type-translators* (make-hash-table :test #'eq))
(defvar *builtin-type-info* (make-hash-table :test #'equal))
(defvar %builtin-type-cells% (make-hash-table :test 'equal))

(defvar *use-implementation-types* t)

(defun info-type-builtin (name)
  (gethash name *builtin-type-info*))

(defun (setf info-type-builtin) (val name)
  (setf (gethash name *builtin-type-info*) val))

(defun info-type-translator (name)
  (gethash name *type-translators*))




;;; Allow bootstrapping: mostly, allow us to bootstrap the type system
;;; by having DEFTYPE expanders defined on built-in classes (the user
;;; shouldn't be allowed to do so, at least not easily.

;(defvar *type-system-initialized* nil)

(defun %deftype (name fn doc)
  (clear-type-cache)
  (cond ((null fn)
         (remhash name %deftype-expanders%))
        ((and *type-system-initialized*
              (or (built-in-type-p name)
                  (let ((c (find-class name nil)))
                    (and c (eq (class-name c) name)))))
	 (error "Cannot redefine type ~S because ~:[it is the name of a class~;it is a built-in type~]" name (built-in-type-p name)))
	((memq name *nx-known-declarations*)
	 (check-declaration-redefinition name 'deftype))
        (t (setf (gethash name %deftype-expanders%) fn)
           (record-source-file name 'type)))
  (set-documentation name 'type doc)   ; nil clears it.
  name)

(defun %define-type-translator (name fn doc)
  (declare (ignore doc))
  (setf (gethash name *type-translators*) fn)
  name)

;;;(defun %deftype-expander (name)
;;;  (or (gethash name %deftype-expanders%)
;;;      (and *compiling-file* (%cdr (assq name *compile-time-deftype-expanders*)))))
(defun %deftype-expander (name)
  (gethash name %deftype-expanders%))

(defun process-deftype-arglist (arglist &aux (in-optional? nil))
  "Returns a NEW list similar to arglist except
    inserts * as the default default for &optional args."
  (mapcar #'(lambda (item)
              (cond ((eq item '&optional) (setq in-optional? t) item)
                    ((memq item lambda-list-keywords) (setq in-optional? nil) item)
                    ((and in-optional? (symbolp item)) (list item ''*))
                    (t item)))
          arglist))


(defun expand-type-macro (definer name arglist body env)
  (setq name (require-type name 'symbol))
  (multiple-value-bind (lambda doc)
      (parse-macro-internal name arglist body env '*)
    `(progn
       (eval-when (:compile-toplevel)
	 (note-type-info ',name 'macro ,env))
       (eval-when (:compile-toplevel :load-toplevel :execute)
	 (,definer ',name
	     (nfunction ,name ,lambda)
	   ,doc)))))

(defmacro deftype (name arglist &body body &environment env)
  "Define a new type, with syntax like DEFMACRO."
  (expand-type-macro '%deftype name arglist body env))

(defmacro def-type-translator (name arglist &body body &environment env)
  (expand-type-macro '%define-type-translator name arglist body env))


(defun type-expand (form &optional env &aux def)
  (while (setq def (cond ((symbolp form)
                          (gethash form %deftype-expanders%))
                         ((and (consp form) (symbolp (%car form)))
                          (gethash (%car form) %deftype-expanders%))
                         (t nil)))
    (setq form (funcall def (if (consp form) form (list form)) env)))
  form)

(defmethod print-object ((tc type-class) stream)
  (print-unreadable-object (tc stream :type t :identity t)
    (format stream "~s" (type-class-name tc))))

(defmethod print-object ((c ctype) stream)
  (print-unreadable-object (c stream :type t)
    (format stream "~S" (type-specifier c))))

(defmethod make-load-form ((c ctype) &optional env)
  (declare (ignore env))
  `(specifier-type ',(type-specifier c)))

(defmethod make-load-form ((cell type-cell) &optional env)
  (declare (ignore env))
  `(register-type-cell `,(type-cell-type-specifier cell)))

(defmethod print-object ((cell type-cell) stream)
  (print-unreadable-object (cell stream :type t :identity t)
    (format stream "for ~s" (type-cell-type-specifier cell))))

(defun make-key-info (&key name type)
  (%istruct 'key-info name type))

(defun type-class-or-lose (name)
  (or (cdr (assq name *type-classes*))
      (error "~S is not a defined type class." name)))

(eval-when (:compile-toplevel :execute)

(defconstant type-class-function-slots
  '((:simple-subtypep . #.type-class-simple-subtypep)
    (:complex-subtypep-arg1 . #.type-class-complex-subtypep-arg1)
    (:complex-subtypep-arg2 . #.type-class-complex-subtypep-arg2)
    (:simple-union . #.type-class-simple-union)
    (:complex-union . #.type-class-complex-union)
    (:simple-intersection . #.type-class-simple-intersection)
    (:complex-intersection . #.type-class-complex-intersection)
    (:simple-= . #.type-class-simple-=)
    (:complex-= . #.type-class-complex-=)
    (:unparse . #.type-class-unparse)))

)

(defun class-typep (form class)
  (memq class (%inited-class-cpl (class-of form))))

;;; CLASS-FUNCTION-SLOT-OR-LOSE  --  Interface
;;;
(defun class-function-slot-or-lose (name)
  (or (cdr (assoc name type-class-function-slots))
      (error "~S is not a defined type class method." name)))


(eval-when (:compile-toplevel :execute)

;;; INVOKE-TYPE-METHOD  --  Interface
;;;
;;;    Invoke a type method on TYPE1 and TYPE2.  If the two types have the same
;;; class, invoke the simple method.  Otherwise, invoke any complex method.  If
;;; there isn't a distinct complex-arg1 method, then swap the arguments when
;;; calling type1's method.  If no applicable method, return DEFAULT.
;;;

(defmacro invoke-type-method (simple complex-arg2 type1 type2 &key
                                     (default '(values nil t))
                                     complex-arg1)
  (let ((simple (class-function-slot-or-lose simple))
        (cslot1 (class-function-slot-or-lose (or complex-arg1 complex-arg2)))
        (cslot2 (class-function-slot-or-lose complex-arg2)))
    (once-only ((n-type1 type1)
                (n-type2 type2))
      (once-only ((class1 `(ctype-class-info ,n-type1))
                  (class2 `(ctype-class-info ,n-type2)))
        `(if (eq ,class1 ,class2)
           (funcall (%svref ,class1 ,simple) ,n-type1 ,n-type2)
           ,(once-only ((complex1 `(%svref ,class1 ,cslot1))
                        (complex2 `(%svref ,class2 ,cslot2)))
              `(cond (,complex2 (funcall ,complex2 ,n-type1 ,n-type2))
                     (,complex1
                      ,(if complex-arg1
                         `(funcall ,complex1 ,n-type1 ,n-type2)
                         `(funcall ,complex1 ,n-type2 ,n-type1)))
                     (t ,default))))))))


;;;; Utilities:

;;; ANY-TYPE-OP, EVERY-TYPE-OP  --  Interface
;;;
;;;    Like ANY and EVERY, except that we handle two-arg uncertain predicates.
;;; If the result is uncertain, then we return Default from the block PUNT.
;;; If LIST-FIRST is true, then the list element is the first arg, otherwise
;;; the second.
;;;
(defmacro any-type-op (op thing list &key (default '(values nil nil))
			        list-first)
  (let ((n-this (gensym))
	  (n-thing (gensym))
	  (n-val (gensym))
	  (n-win (gensym))
	  (n-uncertain (gensym)))
    `(let ((,n-thing ,thing)
	     (,n-uncertain nil))
       (dolist (,n-this ,list
			      (if ,n-uncertain
			        (return-from PUNT ,default)
			        nil))
	   (multiple-value-bind (,n-val ,n-win)
			            ,(if list-first
				         `(,op ,n-this ,n-thing)
				         `(,op ,n-thing ,n-this))
	     (unless ,n-win (setq ,n-uncertain t))
	     (when ,n-val (return t)))))))
;;;
(defmacro every-type-op (op thing list &key (default '(values nil nil))
			          list-first)
  (let ((n-this (gensym))
	  (n-thing (gensym))
	  (n-val (gensym))
	  (n-win (gensym)))
    `(let ((,n-thing ,thing))
       (dolist (,n-this ,list t)
	   (multiple-value-bind (,n-val ,n-win)
			            ,(if list-first
				         `(,op ,n-this ,n-thing)
				         `(,op ,n-thing ,n-this))
	     (unless ,n-win (return-from PUNT ,default))
	     (unless ,n-val (return nil)))))))

)

  
;;; VANILLA-INTERSECTION  --  Interface
;;;
;;;    Compute the intersection for types that intersect only when one is a
;;; hierarchical subtype of the other.
;;;
(defun vanilla-intersection (type1 type2)
  (multiple-value-bind (stp1 win1)
		           (csubtypep type1 type2)
    (multiple-value-bind (stp2 win2)
			       (csubtypep type2 type1)
      (cond (stp1 (values type1 t))
	      (stp2 (values type2 t))
	      ((and win1 win2) (values *empty-type* t))
	      (t
	       (values type1 nil))))))


;;; VANILLA-UNION  --  Interface
;;;
(defun vanilla-union (type1 type2)
  (cond ((csubtypep type1 type2) type2)
	((csubtypep type2 type1) type1)
	(t nil)))

(defun hierarchical-intersection2 (type1 type2)
  (multiple-value-bind (subtypep1 win1) (csubtypep type1 type2)
    (multiple-value-bind (subtypep2 win2) (csubtypep type2 type1)
      (cond (subtypep1 type1)
	    (subtypep2 type2)
	    ((and win1 win2) *empty-type*)
	    (t nil)))))

(defun hierarchical-union2 (type1 type2)
  (cond ((csubtypep type1 type2) type2)
	((csubtypep type2 type1) type1)
	(t nil)))

;;; DELEGATE-COMPLEX-{SUBTYPEP-ARG2,INTERSECTION}  --  Interface
;;;
;;;    These functions are used as method for types which need a complex
;;; subtypep method to handle some superclasses, but cover a subtree of the
;;; type graph (i.e. there is no simple way for any other type class to be a
;;; subtype.)  There are always still complex ways, namely UNION and MEMBER
;;; types, so we must give TYPE1's method a chance to run, instead of
;;; immediately returning NIL, T.
;;;
(defun delegate-complex-subtypep-arg2 (type1 type2)
  (let ((subtypep-arg1
	 (type-class-complex-subtypep-arg1
	  (ctype-class-info type1))))
    (if subtypep-arg1
	(funcall subtypep-arg1 type1 type2)
	(values nil t))))
;;;
(defun delegate-complex-intersection (type1 type2)
  (let ((method (type-class-complex-intersection (ctype-class-info type1))))
    (if (and method (not (eq method #'delegate-complex-intersection)))
	(funcall method type2 type1)
	(hierarchical-intersection2 type1 type2))))

;;; HAS-SUPERCLASSES-COMPLEX-SUBTYPEP-ARG1  --  Internal
;;;
;;;    Used by DEFINE-SUPERCLASSES to define the SUBTYPE-ARG1 method.  Info is
;;; a list of conses (SUPERCLASS-CLASS . {GUARD-TYPE-SPECIFIER | NIL}).  Will
;;; never be called with a hairy type as type2, since the hairy type type2
;;; method gets first crack.
;;;
#|
(defun has-superclasses-complex-subtypep-arg1 (type1 type2 info)
  (values
   (and (typep type2 'class)
	(dolist (x info nil)
	  (when (or (not (cdr x))
		    (csubtypep type1 (specifier-type (cdr x))))
	    (return
	     (or (eq type2 (car x))
		 (let ((inherits (layout-inherits (class-layout (car x)))))
		   (dotimes (i (length inherits) nil)
		     (when (eq type2 (layout-class (svref inherits i)))
		       (return t)))))))))
   t))
|#

(eval-when (:compile-toplevel :execute)
;;; DEFINE-SUPERCLASSES  --  Interface
;;;
;;;    Takes a list of specs of the form (superclass &optional guard).
;;; Consider one spec (with no guard): any instance of type-class is also a
;;; subtype of SUPERCLASS and of any of its superclasses.  If there are
;;; multiple specs, then some will have guards.  We choose the first spec whose
;;; guard is a supertype of TYPE1 and use its superclass.  In effect, a
;;; sequence of guards G0, G1, G2 is actually G0, (and G1 (not G0)),
;;; (and G2 (not (or G0 G1))).
;;;
#|
(defmacro define-superclasses (type-class &rest specs)
  (let ((info
	 (mapcar #'(lambda (spec)
		     (destructuring-bind (super &optional guard)
					 spec
		       (cons (find-class super) guard)))
		 specs)))
    `(progn
      (setf (type-class-complex-subtypep-arg1
	     (type-class-or-lose ',type-class))
	    #'(lambda (type1 type2)
		(has-superclasses-complex-subtypep-arg1 type1 type2 ',info)))
       
       (setf (type-class-complex-subtypep-arg2
	      (type-class-or-lose ',type-class))
	     #'delegate-complex-subtypep-arg2)
       
       (setf (type-class-complex-intersection
	      (type-class-or-lose ',type-class))
	     #'delegate-complex-intersection))))
|#

); eval-when (compile eval)


(defun reparse-unknown-ctype (type)
  (if (unknown-ctype-p type)
    (specifier-type (type-specifier type))
    type))

(defun swapped-args-fun (f)
  #'(lambda (x y)
      (funcall f y x)))

(defun equal-but-no-car-recursion (x y)
  (cond ((eql x y) t)
	((consp x)
	 (and (consp y)
	      (eql (car x) (car y))
	      (equal-but-no-car-recursion (cdr x) (cdr y))))
	(t nil)))

(defun any/type (op thing list)
  (declare (type function op))
  (let ((certain? t))
    (dolist (i list (values nil certain?))
      (multiple-value-bind (sub-value sub-certain?) (funcall op thing i)
	(if sub-certain?
	    (when sub-value (return (values t t)))
	    (setf certain? nil))))))

(defun every/type (op thing list)
  (declare (type function op))
  (let ((certain? t))
    (dolist (i list (if certain? (values t t) (values nil nil)))
      (multiple-value-bind (sub-value sub-certain?) (funcall op thing i)
	(if sub-certain?
	    (unless sub-value (return (values nil t)))
	    (setf certain? nil))))))

(defun invoke-complex-=-other-method (type1 type2)
  (let* ((type-class (ctype-class-info type1))
	 (method-fun (type-class-complex-= type-class)))
    (if method-fun
	(funcall (the function method-fun) type2 type1)
	(values nil t))))

(defun invoke-complex-subtypep-arg1-method (type1 type2 &optional subtypep win)
  (let* ((type-class (ctype-class-info type1))
	 (method-fun (type-class-complex-subtypep-arg1 type-class)))
    (if method-fun
      (funcall (the function method-fun) type1 type2)
      (values subtypep win))))

(defun type-might-contain-other-types-p (type)
  (or (hairy-ctype-p type)
      (negation-ctype-p type)
      (union-ctype-p type)
      (intersection-ctype-p type)))


(eval-when (:compile-toplevel :execute)

(defmacro define-type-method ((class method &rest more-methods)
			            lambda-list &body body)
  `(progn
     (let* ((fn (nfunction (,class ,method ,@more-methods)
                           (lambda ,lambda-list ,@body))))
       ,@(mapcar #'(lambda (method)
		         `(setf (%svref
			           (type-class-or-lose ',class)
                             ,(class-function-slot-or-lose method))
			          fn))
		     (cons method more-methods)))
     nil))

)


(defun ctype-p (x)
  (and (eql (typecode x) target::subtag-istruct)
       (memq (istruct-type-name x)
             '#.(cons 'ctype 
                      (cons 'unknown-ctype                             
                            (append (mapcar #'class-name 
                                            (class-direct-subclasses (find-class 'args-ctype)))
                                    (mapcar #'class-name 
                                            (class-direct-subclasses (find-class 'ctype)))))))))


(setf (type-predicate 'ctype) 'ctype-p)


;;;; Function and Values types.
;;;
;;;    Pretty much all of the general type operations are illegal on VALUES
;;; types, since we can't discriminate using them, do SUBTYPEP, etc.  FUNCTION
;;; types are acceptable to the normal type operations, but are generally
;;; considered to be equivalent to FUNCTION.  These really aren't true types in
;;; any type theoretic sense, but we still parse them into CTYPE structures for
;;; two reasons:
;;; -- Parsing and unparsing work the same way, and indeed we can't tell
;;;    whether a type is a function or values type without parsing it.
;;; -- Many of the places that can be annotated with real types can also be
;;;    annotated function or values types.

;; Methods on the VALUES type class.

(defun make-values-ctype (&key
                          required
                          optional
                          rest
                          keyp
                          keywords
                          allowp)
  (%istruct 'values-ctype
            (type-class-or-lose 'values)
            nil
            required
            optional
            rest
            keyp
            keywords
            allowp
           ))

(defun values-ctype-p (x) (istruct-typep x 'values-ctype))
(setf (type-predicate 'values-ctype) 'values-ctype-p)


(define-type-method (values :simple-subtypep :complex-subtypep-arg1)
		    (type1 type2)
  (declare (ignore type2))
  (error "Subtypep is illegal on this type:~%  ~S" (type-specifier type1)))

(define-type-method (values :complex-subtypep-arg2)
		    (type1 type2)
  (declare (ignore type1))
  (error "Subtypep is illegal on this type:~%  ~S" (type-specifier type2)))


(define-type-method (values :unparse) (type)
  (cons 'values (unparse-args-types type)))


;;; TYPE=-LIST  --  Internal
;;;
;;;    Return true if List1 and List2 have the same elements in the same
;;; positions according to TYPE=.  We return NIL, NIL if there is an uncertain
;;; comparison. 
;;;
(defun type=-list (list1 list2)
  (declare (list list1 list2))
  (do ((types1 list1 (cdr types1))
       (types2 list2 (cdr types2)))
      ((or (null types1) (null types2))
       (if (or types1 types2)
	   (values nil t)
	   (values t t)))
    (multiple-value-bind (val win)
			       (type= (first types1) (first types2))
      (unless win
	  (return (values nil nil)))
      (unless val
	  (return (values nil t))))))

(define-type-method (values :simple-=) (type1 type2)
  (let ((rest1 (args-ctype-rest type1))
	(rest2 (args-ctype-rest type2)))
    (cond ((or (args-ctype-keyp type1) (args-ctype-keyp type2)
	       (args-ctype-allowp type1) (args-ctype-allowp type2))
	     (values nil nil))
	    ((and rest1 rest2 (type/= rest1 rest2))
	     (type= rest1 rest2))
	    ((or rest1 rest2)
	     (values nil t))
	    (t
	     (multiple-value-bind (req-val req-win)
		 (type=-list (values-ctype-required type1)
			     (values-ctype-required type2))
	       (multiple-value-bind (opt-val opt-win)
		   (type=-list (values-ctype-optional type1)
			       (values-ctype-optional type2))
	         (values (and req-val opt-val) (and req-win opt-win))))))))


;; Methods on the FUNCTION type class.


(defun make-function-ctype (&key
                            required
                            optional
                            rest
                            keyp
                            keywords
                            allowp
                            wild-args
                            returns)
  (%istruct 'function-ctype
            (type-class-or-lose 'function)
            nil
            required
            optional
            rest
            keyp
            keywords
            allowp
            wild-args
            returns
           ))

(defun function-ctype-p (x) (istruct-typep x 'function-ctype))
(setf (type-predicate 'function-ctype) 'function-ctype-p)

;;; A flag that we can bind to cause complex function types to be unparsed as
;;; FUNCTION.  Useful when we want a type that we can pass to TYPEP.
;;;
(defvar *unparse-function-type-simplify* nil)

(define-type-method (function :unparse) (type)
  (if *unparse-function-type-simplify*
    'function
    (list 'function
	    (if (function-ctype-wild-args type)
		'*
		(unparse-args-types type))
	    (type-specifier
	     (function-ctype-returns type)))))

;;; Since all function types are equivalent to FUNCTION, they are all subtypes
;;; of each other.
;;;

(define-type-method (function :simple-subtypep) (type1 type2)
 (flet ((fun-type-simple-p (type)
          (not (or (function-ctype-rest type)
                   (function-ctype-keyp type))))
        (every-csubtypep (types1 types2)
          (loop
             for a1 in types1
             for a2 in types2
             do (multiple-value-bind (res sure-p)
                    (csubtypep a1 a2)
                  (unless res (return (values res sure-p))))
             finally (return (values t t)))))
   (macrolet ((3and (x y)
                `(multiple-value-bind (val1 win1) ,x
                   (if (and (not val1) win1)
                       (values nil t)
                       (multiple-value-bind (val2 win2) ,y
                         (if (and val1 val2)
                             (values t t)
                             (values nil (and win2 (not val2)))))))))
     (3and (values-subtypep (function-ctype-returns type1)
                            (function-ctype-returns type2))
           (cond ((function-ctype-wild-args type2) (values t t))
                 ((function-ctype-wild-args type1)
                  (cond ((function-ctype-keyp type2) (values nil nil))
                        ((not (function-ctype-rest type2)) (values nil t))
                        ((not (null (function-ctype-required type2))) (values nil t))
                        (t (3and (type= *universal-type* (function-ctype-rest type2))
                                 (every/type #'type= *universal-type*
                                             (function-ctype-optional type2))))))
                 ((not (and (fun-type-simple-p type1)
                            (fun-type-simple-p type2)))
                  (values nil nil))
                 (t (multiple-value-bind (min1 max1) (function-type-nargs type1)
                      (multiple-value-bind (min2 max2) (function-type-nargs type2)
                        (cond ((or (> max1 max2) (< min1 min2))
                               (values nil t))
                              ((and (= min1 min2) (= max1 max2))
                               (3and (every-csubtypep (function-ctype-required type1)
                                                      (function-ctype-required type2))
                                     (every-csubtypep (function-ctype-optional type1)
                                                      (function-ctype-optional type2))))
                              (t (every-csubtypep
                                  (concatenate 'list
                                               (function-ctype-required type1)
                                               (function-ctype-optional type1))
                                  (concatenate 'list
                                               (function-ctype-required type2)
                                               (function-ctype-optional type2)))))))))))))


                   
;(define-superclasses function (function))       


;;; The union or intersection of two FUNCTION types is FUNCTION.
;;; (unless the types are type=)
;;;
(define-type-method (function :simple-union) (type1 type2)
  (if (type= type1 type2)
    type1
    (specifier-type 'function)))

;;;
(define-type-method (function :simple-intersection) (type1 type2)
  (if (type= type1 type2)
    type1
    (specifier-type 'function)))


(define-type-method (function :complex-intersection) (type1 type2)
  (declare (type function-ctype type2))
  (let ((function (specifier-type 'function)))
    (if (eq type1 function)
      type2
      (type-intersection2 type1 function))))



;;; ### Not very real, but good enough for redefining transforms according to
;;; type:
;;;
(define-type-method (function :simple-=) (type1 type2)
  (values (equalp type1 type2) t))

;;; The CONSTANT-TYPE structure represents a use of the CONSTANT-ARGUMENT "type
;;; specifier", which is only meaningful in function argument type specifiers
;;; used within the compiler.
;;;

(defun clone-type-class-methods (src-tc dest-tc)
  (do* ((n (uvsize src-tc))
        (i 2 (1+ i)))
       ((= i n) dest-tc)
    (declare (fixnum i n))
    (setf (%svref dest-tc i)
          (%svref src-tc i))))

(clone-type-class-methods (type-class-or-lose 'values) (type-class-or-lose 'constant))

(defun make-constant-ctype (&key type)
  (%istruct 'constant-ctype
            (type-class-or-lose 'constant)
            nil
            type))

(defun constant-ctype-p (x) (istruct-typep x 'constant-ctype))
(setf (type-predicate 'constant-ctype) 'constant-ctype-p)

(define-type-method (constant :unparse) (type)
  `(constant-argument ,(type-specifier (constant-ctype-type type))))

(define-type-method (constant :simple-=) (type1 type2)
  (type= (constant-ctype-type type1) (constant-ctype-type type2)))

(def-type-translator constant-argument (type &environment env)
  (make-constant-ctype :type (specifier-type type env)))


;;; Parse-Args-Types  --  Internal
;;;
;;;    Given a lambda-list like values type specification and a Args-Type
;;; structure, fill in the slots in the structure accordingly.  This is used
;;; for both FUNCTION and VALUES types.
;;;

(defun parse-args-types (lambda-list result &optional env)
  (multiple-value-bind (required optional restp rest keyp keys allowp aux)
		           (parse-lambda-list lambda-list)
    (when aux
      (error "&Aux in a FUNCTION or VALUES type: ~S." lambda-list))
    (flet ((parse (spec) (specifier-type spec env)))
      (setf (args-ctype-required result) (mapcar #'parse required))
      (setf (args-ctype-optional result) (mapcar #'parse optional))
      (setf (args-ctype-rest result) (if restp (parse rest) nil))
      (setf (args-ctype-keyp result) keyp)
      (let* ((key-info ()))
        (dolist (key keys)
	  (when (or (atom key) (/= (length key) 2))
	    (signal-program-error "Keyword type description is not a two-list: ~S." key))
	  (let ((kwd (first key)))
	    (when (member kwd key-info :test #'eq :key #'(lambda (x) (key-info-name x)))
	      (signal-program-error "Repeated keyword ~S in lambda list: ~S." kwd lambda-list))
	    (push (make-key-info :name kwd
                                 :type (parse (second key))) key-info)))
        (setf (args-ctype-keywords result) (nreverse key-info)))
      (setf (args-ctype-allowp result) allowp))))

;;; Unparse-Args-Types  --  Internal
;;;
;;;    Return the lambda-list like type specification corresponding
;;; to a Args-Type.
;;;
(defun unparse-args-types (type)
  (let* ((result ()))

    (dolist (arg (args-ctype-required type))
      (push (type-specifier arg) result))

    (when (args-ctype-optional type)
      (push '&optional result)
      (dolist (arg (args-ctype-optional type))
	  (push (type-specifier arg) result)))

    (when (args-ctype-rest type)
      (push '&rest result)
      (push (type-specifier (args-ctype-rest type)) result))

    (when (args-ctype-keyp type)
      (push '&key result)
      (dolist (key (args-ctype-keywords type))
	  (push (list (key-info-name key)
                    (type-specifier (key-info-type key))) result)))

    (when (args-ctype-allowp type)
      (push '&allow-other-keys result))

    (nreverse result)))

(def-type-translator function (&optional (args '*) (result '*) &environment env)
  (let ((res (make-function-ctype
	        :returns (values-specifier-type result env))))
    (if (eq args '*)
	(setf (function-ctype-wild-args res) t)
	(parse-args-types args res env))
    res))

(def-type-translator values (&rest values &environment env)
  (let ((res (make-values-ctype)))
    (parse-args-types values res env)
    (when (or (values-ctype-keyp res) (values-ctype-allowp res))
      (signal-program-error "&KEY or &ALLOW-OTHER-KEYS in values type: ~s"
			    res))
    res))

;;; Single-Value-Type  --  Interface
;;;
;;;    Return the type of the first value indicated by Type.  This is used by
;;; people who don't want to have to deal with values types.
;;;
(defun single-value-type (type)
  (declare (type ctype type))
  (cond ((values-ctype-p type)
	 (or (car (args-ctype-required type))
	     (if (args-ctype-optional type)
                 (type-union (car (args-ctype-optional type))
			     (specifier-type 'null)))
	     (args-ctype-rest type)
	     (specifier-type 'null)))
	((eq type *wild-type*)
	 *universal-type*)
	(t
	 type)))


;;; FUNCTION-TYPE-NARGS  --  Interface
;;;
;;;    Return the minmum number of arguments that a function can be called
;;; with, and the maximum number or NIL.  If not a function type, return
;;; NIL, NIL.
;;;
(defun function-type-nargs (type)
  (declare (type ctype type))
  (if (function-ctype-p type)
    (let ((fixed (length (args-ctype-required type))))
	(if (or (args-ctype-rest type)
		  (args-ctype-keyp type)
		  (args-ctype-allowp type))
        (values fixed nil)
        (values fixed (+ fixed (length (args-ctype-optional type))))))
    (values nil nil)))


;;; Values-Types  --  Interface
;;;
;;;    Determine if Type corresponds to a definite number of values.  The first
;;; value is a list of the types for each value, and the second value is the
;;; number of values.  If the number of values is not fixed, then return NIL
;;; and :Unknown.
;;;
(defun values-types (type)
  (declare (type ctype type))
  (cond ((eq type *wild-type*)
	   (values nil :unknown))
	  ((not (values-ctype-p type))
	   (values (list type) 1))
	  ((or (args-ctype-optional type)
	       (args-ctype-rest type)
	       (args-ctype-keyp type)
	       (args-ctype-allowp type))
	   (values nil :unknown))
	  (t
	   (let ((req (args-ctype-required type)))
	     (values (mapcar #'single-value-type req) (length req))))))


;;; Values-Type-Types  --  Internal
;;;
;;;    Return two values:
;;; 1] A list of all the positional (fixed and optional) types.
;;; 2] The rest type (if any).  If keywords allowed, *universal-type*.  If no
;;;    keywords or rest, *empty-type*.
;;;
(defun values-type-types (type &optional (default-type *empty-type*))
  (declare (type values-ctype type))
  (values (append (args-ctype-required type)
		  (args-ctype-optional type))
	    (cond ((args-ctype-keyp type) *universal-type*)
		  ((args-ctype-rest type))
		  (t default-type))))


;;; Fixed-Values-Op  --  Internal
;;;
;;;    Return a list of Operation applied to the types in Types1 and Types2,
;;; padding with Rest2 as needed.  Types1 must not be shorter than Types2.  The
;;; second value is T if Operation always returned a true second value.
;;;
(defun fixed-values-op (types1 types2 rest2 operation)
  (declare (list types1 types2) (type ctype rest2) (type function operation))
  (let ((exact t))
    (values (mapcar #'(lambda (t1 t2)
			      (multiple-value-bind (res win)
				  (funcall operation t1 t2)
			        (unless win (setq exact nil))
			        res))
		        types1
		        (append types2
				(make-list (- (length types1) (length types2))
					   :initial-element rest2)))
	      exact)))

;;; Coerce-To-Values  --  Internal
;;;
;;; If Type isn't a values type, then make it into one:
;;;    <type>  ==>  (values type &rest t)
;;;
(defun coerce-to-values (type)
  (declare (type ctype type))
  (if (values-ctype-p type)
    type
    (make-values-ctype :required (list type))))


;;; Args-Type-Op  --  Internal
;;;
;;;    Do the specified Operation on Type1 and Type2, which may be any type,
;;; including Values types.  With values types such as:
;;;    (values a0 a1)
;;;    (values b0 b1)
;;;
;;; We compute the more useful result:
;;;    (values (<operation> a0 b0) (<operation> a1 b1))
;;;
;;; Rather than the precise result:
;;;    (<operation> (values a0 a1) (values b0 b1))
;;;
;;; This has the virtue of always keeping the values type specifier outermost,
;;; and retains all of the information that is really useful for static type
;;; analysis.  We want to know what is always true of each value independently.
;;; It is worthless to know that IF the first value is B0 then the second will
;;; be B1.
;;;
;;; If the values count signatures differ, then we produce result with the
;;; required value count chosen by Nreq when applied to the number of required
;;; values in type1 and type2.  Any &key values become &rest T (anyone who uses
;;; keyword values deserves to lose.)
;;;
;;; The second value is true if the result is definitely empty or if Operation
;;; returned true as its second value each time we called it.  Since we
;;; approximate the intersection of values types, the second value being true
;;; doesn't mean the result is exact.
;;;
(defun args-type-op (type1 type2 operation nreq default-type)
  (declare (type ctype type1 type2 default-type)
	   (type function operation nreq))
  (if (eq type1 type2)
    (values type1 t)
    (if (or (values-ctype-p type1) (values-ctype-p type2))
      (let ((type1 (coerce-to-values type1))
	    (type2 (coerce-to-values type2)))
	(multiple-value-bind (types1 rest1)
	    (values-type-types type1 default-type)
	  (multiple-value-bind (types2 rest2)
	      (values-type-types type2 default-type)
	    (multiple-value-bind (rest rest-exact)
		(funcall operation rest1 rest2)
	      (multiple-value-bind
		  (res res-exact)
		  (if (< (length types1) (length types2))
		    (fixed-values-op types2 types1 rest1 operation)
		    (fixed-values-op types1 types2 rest2 operation))
		(let* ((req (funcall nreq
				     (length (args-ctype-required type1))
				     (length (args-ctype-required type2))))
		       (required (subseq res 0 req))
		       (opt (subseq res req))
		       (opt-last (position rest opt :test-not #'type=
					   :from-end t)))
		  (if (find *empty-type* required :test #'type=)
		    (values *empty-type* t)
		    (values (make-values-ctype
			     :required required
			     :optional (if opt-last
					 (subseq opt 0 (1+ opt-last))
					 ())
			     :rest (if (eq rest *empty-type*) nil rest))
			    (and rest-exact res-exact)))))))))
      (funcall operation type1 type2))))

;;; Values-Type-Union, Values-Type-Intersection  --  Interface
;;;
;;;    Do a union or intersection operation on types that might be values
;;; types.  The result is optimized for utility rather than exactness, but it
;;; is guaranteed that it will be no smaller (more restrictive) than the
;;; precise result.
;;;

(defun values-type-union (type1 type2)
  (declare (type ctype type1 type2))
  (cond ((or (eq type1 *wild-type*) (eq type2 *wild-type*)) *wild-type*)
	((eq type1 *empty-type*) type2)
	((eq type2 *empty-type*) type1)
	(t
	 (values (args-type-op type1 type2 #'type-union #'min *empty-type*)))))

(defun values-type-intersection (type1 type2)
  (declare (type ctype type1 type2))
  (cond ((eq type1 *wild-type*) (values type2 t))
	((eq type2 *wild-type*) (values type1 t))
	(t
	 (args-type-op type1 type2 #'type-intersection #'max
		       (specifier-type 'null)))))


;;; Values-Types-Intersect  --  Interface
;;;
;;;    Like Types-Intersect, except that it sort of works on values types.
;;; Note that due to the semantics of Values-Type-Intersection, this might
;;; return {T, T} when there isn't really any intersection (?).
;;;
(defun values-types-intersect (type1 type2)
  (cond ((or (eq type1 *empty-type*) (eq type2 *empty-type*))
	   (values t t))
	  ((or (values-ctype-p type1) (values-ctype-p type2))
	   (multiple-value-bind (res win)
			            (values-type-intersection type1 type2)
	     (values (not (eq res *empty-type*))
		       win)))
	  (t
	   (types-intersect type1 type2))))

;;; Values-Subtypep  --  Interface
;;;
;;;    A subtypep-like operation that can be used on any types, including
;;; values types.
;;;

(defun values-subtypep (type1 type2)
  (declare (type ctype type1 type2))
  (cond ((eq type2 *wild-type*) (values t t))
	((eq type1 *wild-type*)
	 (values (eq type2 *universal-type*) t))
	((not (values-types-intersect type1 type2))
	 (values nil t))
	(t
	 (if (or (values-ctype-p type1) (values-ctype-p type2))
	   (let ((type1 (coerce-to-values type1))
		 (type2 (coerce-to-values type2)))
	     (multiple-value-bind (types1 rest1)
		 (values-type-types type1)
	       (multiple-value-bind (types2 rest2)
		   (values-type-types type2)
		 (cond ((< (length (values-ctype-required type1))
			   (length (values-ctype-required type2)))
			(values nil t))
		       ((< (length types1) (length types2))
			(values nil nil))
		       ((or (values-ctype-keyp type1)
			    (values-ctype-keyp type2))
			(values nil nil))
		       (t
			(do ((t1 types1 (rest t1))
			     (t2 types2 (rest t2)))
			    ((null t2)
			     (csubtypep rest1 rest2))
			  (multiple-value-bind
			      (res win-p)
			      (csubtypep (first t1) (first t2))
			    (unless win-p
			      (return (values nil nil)))
			    (unless res
			      (return (values nil t))))))))))
	   (csubtypep type1 type2)))))
  

;;;; Type method interfaces:

;;; Csubtypep  --  Interface
;;;
;;;    Like subtypep, only works on Type structures.
;;;
(defun csubtypep (type1 type2)
  (declare (type ctype type1 type2))
  (unless (typep type1 'ctype)
    (report-bad-arg type1 'ctype))
  (unless (typep type2 'ctype)
    (report-bad-arg type2 'ctype))
  (cond ((or (eq type1 type2)
	     (eq type1 *empty-type*)
	     (eq type2 *wild-type*))
	 (values t t))
	(t
	 (invoke-type-method :simple-subtypep :complex-subtypep-arg2
			     type1 type2
			     :complex-arg1 :complex-subtypep-arg1))))

;;; Type1 is a type-epecifier; type2 is a TYPE-CELL which may cache
;;; a mapping between a type-specifier and a CTYPE.
(defun cell-csubtypep-2 (type-specifier type-cell)
  (let* ((type1 (specifier-type type-specifier))
         (type2 (or (type-cell-ctype type-cell)
                    (let* ((ctype (specifier-type
                                   (type-cell-type-specifier type-cell))))
                      (when (cacheable-ctype-p ctype)
                        (setf (type-cell-ctype type-cell) ctype))
                      ctype))))
    (cond ((or (eq type1 type2)
               (eq type1 *empty-type*)
               (eq type2 *wild-type*))
           (values t t))
          (t
           (invoke-type-method :simple-subtypep :complex-subtypep-arg2
                               type1 type2
                               :complex-arg1 :complex-subtypep-arg1)))))
                              


;;; Type=  --  Interface
;;;
;;;    If two types are definitely equivalent, return true.  The second value
;;; indicates whether the first value is definitely correct.  This should only
;;; fail in the presence of Hairy types.
;;;

(defun type= (type1 type2)
   (declare (type ctype type1 type2))
   (if (eq type1 type2)
     (values t t)
     (invoke-type-method :simple-= :complex-= type1 type2)))

;;; TYPE/=  --  Interface
;;;
;;;    Not exactly the negation of TYPE=, since when the relationship is
;;; uncertain, we still return NIL, NIL.  This is useful in cases where the
;;; conservative assumption is =.
;;;
(defun type/= (type1 type2)
  (declare (type ctype type1 type2))
  (multiple-value-bind (res win)
      (type= type1 type2)
    (if win
	(values (not res) t)
	(values nil nil))))

;;; Type-Union  --  Interface
;;;
;;;    Find a type which includes both types.  Any inexactness is represented
;;; by the fuzzy element types; we return a single value that is precise to the
;;; best of our knowledge.  This result is simplified into the canonical form,
;;; thus is not a UNION type unless there is no other way to represent the
;;; result.
;;; 

(defun type-union (&rest input-types)
  (%type-union input-types))

(defun %type-union (input-types)
  (let* ((simplified (simplify-unions input-types)))
    (cond ((null simplified) *empty-type*)
	  ((null (cdr simplified)) (car simplified))
	  (t (make-union-ctype simplified)))))

(defun simplify-unions (types)
  (when types
    (multiple-value-bind (first rest)
	(if (union-ctype-p (car types))
	  (values (car (union-ctype-types (car types)))
		  (append (cdr (union-ctype-types (car types)))
			  (cdr types)))
	  (values (car types) (cdr types)))
      (let ((rest (simplify-unions rest)) u)
	(dolist (r rest (cons first rest))
	  (when (setq u (type-union2 first r))
	    (return (simplify-unions (nsubstitute u r rest)))))))))

(defun type-union2 (type1 type2)
  (declare (type ctype type1 type2))
  (setq type1 (reparse-unknown-ctype type1))
  (setq type2 (reparse-unknown-ctype type2))
  (cond ((eq type1 type2) type1)
	((csubtypep type1 type2) type2)
	((csubtypep type2 type1) type1)
	(t
	 (flet ((1way (x y)
		  (invoke-type-method :simple-union :complex-union
				      x y
				      :default nil)))
	   (or (1way type1 type2)
	       (1way type2 type1))))))

;;; Return as restrictive and simple a type as we can discover that is
;;; no more restrictive than the intersection of TYPE1 and TYPE2. At
;;; worst, we arbitrarily return one of the arguments as the first
;;; value (trying not to return a hairy type).
(defun type-approx-intersection2 (type1 type2)
  (declare (type ctype type1 type2))
  (cond ((type-intersection2 type1 type2))
	((hairy-ctype-p type1) type2)
	(t type1)))


;;; Type-Intersection  --  Interface
;;;
;;;    Return as restrictive a type as we can discover that is no more
;;; restrictive than the intersection of Type1 and Type2.  The second value is
;;; true if the result is exact.  At worst, we randomly return one of the
;;; arguments as the first value (trying not to return a hairy type).
;;;

(defun type-intersection (&rest input-types)
  (%type-intersection input-types))

(defun %type-intersection (input-types)
  (let ((simplified (simplify-intersections input-types)))
    ;;(declare (type (vector ctype) simplified))
    ;; We want to have a canonical representation of types (or failing
    ;; that, punt to HAIRY-TYPE). Canonical representation would have
    ;; intersections inside unions but not vice versa, since you can
    ;; always achieve that by the distributive rule. But we don't want
    ;; to just apply the distributive rule, since it would be too easy
    ;; to end up with unreasonably huge type expressions. So instead
    ;; we try to generate a simple type by distributing the union; if
    ;; the type can't be made simple, we punt to HAIRY-TYPE.
    (if (and (cdr simplified) (some #'union-ctype-p simplified))
      (let* ((first-union (find-if #'union-ctype-p simplified))
             (other-types (remove first-union simplified))
             (distributed (maybe-distribute-one-union first-union other-types)))
        (if distributed
          (apply #'type-union distributed)
          (make-hairy-ctype
           :specifier `(and ,@(mapcar #'type-specifier simplified)))))
      (cond
        ((null simplified) *universal-type*)
        ((null (cdr simplified)) (car simplified))
        (t (make-intersection-ctype
            (some #'(lambda (c) (ctype-enumerable c)) simplified)
            simplified))))))

(defun simplify-intersections (types)
  (when types
    (let ((first (if (typep (car types) 'ctype)
		   (%car types)
		   (specifier-type (%car types)))))
      (multiple-value-bind (first rest)
	  (if (intersection-ctype-p first)
	    (values (car (intersection-ctype-types first))
		    (append (cdr (intersection-ctype-types first))
			    (cdr types)))
	    (values first (cdr types)))
	(let ((rest (simplify-intersections rest)) u)
	  (dolist (r rest (cons first rest))
	    (when (setq u (type-intersection2 first r))
	      (return (simplify-intersections (nsubstitute u r rest))))))))))

(defun type-intersection2 (type1 type2)
  (declare (type ctype type1 type2))
  (setq type1 (reparse-unknown-ctype type1))
  (setq type2 (reparse-unknown-ctype type2))
  (cond ((eq type1 type2)
	 type1)
	((or (intersection-ctype-p type1)
	     (intersection-ctype-p type2))
	 ;; Intersections of INTERSECTION-TYPE should have the
	 ;; INTERSECTION-CTYPE-TYPES values broken out and intersected
	 ;; separately. The full TYPE-INTERSECTION function knows how
	 ;; to do that, so let it handle it.
	 (type-intersection type1 type2))
	;;
	;; (AND (FUNCTION (T) T) GENERIC-FUNCTION) for instance, but
	;; not (AND (FUNCTION (T) T) (FUNCTION (T) T)).
	((let ((function (specifier-type 'function)))
	   (or (and (function-ctype-p type1)
		    (not (function-ctype-p type2))
		    (neq function type2)
		    (csubtypep type2 function)
		    (not (csubtypep function type2)))
	       (and (function-ctype-p type2)
		    (not (function-ctype-p type1))
		    (neq function type1)
		    (csubtypep type1 function)
		    (not (csubtypep function type1)))))
	 nil)
	(t
	 (flet ((1way (x y)
		  (invoke-type-method :simple-intersection
				      :complex-intersection
				      x y
				      :default :no-type-method-found)))
	   (let ((xy (1way type1 type2)))
	     (or (and (not (eql xy :no-type-method-found)) xy)
		 (let ((yx (1way type2 type1)))
		   (or (and (not (eql yx :no-type-method-found)) yx)
		       (cond ((and (eql xy :no-type-method-found)
				   (eql yx :no-type-method-found))
			      *empty-type*)
			     (t
			      nil))))))))))



(defun maybe-distribute-one-union (union-type types)
  (let* ((intersection (apply #'type-intersection types))
	 (union (mapcar (lambda (x) (type-intersection x intersection))
			(union-ctype-types union-type))))
    (if (notany (lambda (x)
		  (or (hairy-ctype-p x)
		      (intersection-ctype-p x)))
		union)
	union
	nil)))

;;; Types-Intersect  --  Interface
;;;
;;;    The first value is true unless the types don't intersect.  The second
;;; value is true if the first value is definitely correct.  NIL is considered
;;; to intersect with any type.  If T is a subtype of either type, then we also
;;; return T, T.  This way we consider hairy types to intersect with T.
;;;
(defun types-intersect (type1 type2)
  (declare (type ctype type1 type2))
  (if (or (eq type1 *empty-type*) (eq type2 *empty-type*))
      (values t t)
      (let ((intersection2 (type-intersection2 type1 type2)))
	(cond ((not intersection2)
	       (if (or (csubtypep *universal-type* type1)
		       (csubtypep *universal-type* type2))
		   (values t t)
		   (values t nil)))
	      ((eq intersection2 *empty-type*) (values nil t))
	      (t (values t t))))))

;;; Type-Specifier  --  Interface
;;;
;;;    Return a Common Lisp type specifier corresponding to this type.
;;;
(defun type-specifier (type)
  (unless (ctype-p type)
    (setq type (require-type type 'ctype)))
  (locally 
      (declare (type ctype type))
    (funcall (type-class-unparse (ctype-class-info type)) type)))


(defconstant compound-only-type-specifiers
  ;; See CLHS Figure 4-4.
  '(and mod satisfies eql not values member or))


;;; VALUES-SPECIFIER-TYPE  --  Interface
;;;
;;;    Return the type structure corresponding to a type specifier.  We pick
;;; off Structure types as a special case.
;;;

(defun values-specifier-type-internal (orig env)
  (or (info-type-builtin orig) ; this table could contain bytes etal and ands ors nots of built-in types - no classes
      
      ;; Now that we have our hands on the environment, we could pass it into type-expand,
      ;; but we'd have no way of knowing whether the expansion depended on the env, so
      ;; we wouldn't know if the result is safe to cache.   So for now don't let type
      ;; expanders see the env, which just means they won't see compile-time types.
      (let ((spec (type-expand orig #+not-yet env)))
        (cond
         ((and (not (eq spec orig))
               (info-type-builtin spec)))
         ((or (eq (info-type-kind spec) :instance)
              (and (symbolp spec)
                   (typep (find-class spec nil env) 'compile-time-class)))
          (let* ((class-ctype (%class.ctype (find-class spec t env))))
            (or (class-ctype-translation class-ctype)
                class-ctype)))
         ((typep spec 'class)
          (let* ((class-ctype (%class.ctype spec)))
            (or (class-ctype-translation class-ctype)
                class-ctype)))
         ((let ((cell (find-builtin-cell spec nil)))
           (and cell (cdr cell))))
         (t
          (when (member spec compound-only-type-specifiers)
            (error 'invalid-type-specifier :typespec spec))
          (let* ((lspec (if (atom spec) (list spec) spec))
                 (fun (info-type-translator (car lspec))))
            (cond (fun (funcall fun lspec env))
                  ((or (and (consp spec)
                            (symbolp (car spec))
                            (not (or (find-class (car spec) nil env)
                                     (info-type-builtin (car spec)))))
                       (symbolp spec))
                   (when *type-system-initialized*
                     (signal 'parse-unknown-type :specifier spec))
                   ;;
                   ;; Inhibit caching...
                   nil)
                  (t
                   (error 'invalid-type-specifier :typespec spec)))))))))

(eval-when (:compile-toplevel :execute)
  (defconstant type-cache-size (ash 1 12))
  (defconstant type-cache-mask (1- type-cache-size)))

(defun compile-time-ctype-p (ctype)
  (and (typep ctype 'class-ctype)
       (typep (class-ctype-class ctype) 'compile-time-class)))


;;; We can get in trouble if we try to cache certain kinds of ctypes,
;;; notably MEMBER types which refer to objects which might
;;; be stack-allocated or might be EQUAL without being EQL.
(defun cacheable-ctype-p (ctype)
  (case (istruct-cell-name (%svref ctype 0))
    (member-ctype
     (dolist (m (member-ctype-members ctype) t)
       (when (or (typep m 'cons)
		 (typep m 'array))
	 (return nil))))
    (union-ctype
     (every #'cacheable-ctype-p (union-ctype-types ctype)))
    (intersection-ctype
     (every #'cacheable-ctype-p (intersection-ctype-types ctype)))
    (array-ctype
     (cacheable-ctype-p (array-ctype-element-type ctype)))
    ((values-ctype function-ctype)
     (and (every #'cacheable-ctype-p (values-ctype-required ctype))
	  (every #'cacheable-ctype-p (values-ctype-optional ctype))
	  (let* ((rest (values-ctype-rest ctype)))
	    (or (null rest) (cacheable-ctype-p rest)))
	  (every #'(lambda (info)
		     (cacheable-ctype-p (key-info-type info)))
		 (values-ctype-keywords ctype))
	  (or (not (eq (istruct-cell-name (%svref ctype 0)) 'function-ctype))
	      (let* ((result (function-ctype-returns ctype)))
		(or (null result)
		    (cacheable-ctype-p result))))))
    (negation-ctype
     (cacheable-ctype-p (negation-ctype-type ctype)))
    (cons-ctype
     (and (cacheable-ctype-p (cons-ctype-car-ctype ctype))
	  (cacheable-ctype-p (cons-ctype-cdr-ctype ctype))))
    (unknown-ctype nil)
    (class-ctype
     (not (typep (class-ctype-class ctype) 'compile-time-class)))
    ;; Anything else ?  Simple things (numbers, classes) can't lose.
    (t t)))
		
      
    

(defun hash-type-specifier (spec)
  (logand (sxhash spec) type-cache-mask))


(let* ((type-cache-specs (make-array type-cache-size))
       (type-cache-ctypes (make-array type-cache-size))
       (probes 0)
       (hits 0)
       (ncleared 0)
       (locked nil)
       (lock (make-lock)))
  
  (defun clear-type-cache ()
    (with-lock-grabbed (lock)
      (%init-misc 0 type-cache-specs)
      (%init-misc 0 type-cache-ctypes)
      (incf ncleared))
    nil)

  (defun values-specifier-type (spec &optional env)
    (if (typep spec 'class)
      (let* ((class-ctype (%class.ctype spec)))
        (or (class-ctype-translation class-ctype) class-ctype))
      (handler-case
          (with-lock-grabbed (lock)
            (if locked
              (or (values-specifier-type-internal spec env)
                  (make-unknown-ctype :specifier spec))
              (unwind-protect
                   (progn
                     (setq locked t)
                     (if (or (symbolp spec)
                             (and (consp spec)
                                  (symbolp (car spec))
                                  ;; hashing scheme uses equal, so only use when equivalent to eql
                                  (not (and (eq (car spec) 'member)
                                            (some (lambda (x)
                                                    (typep x '(or cons string bit-vector pathname)))
                                                  (cdr spec))))))
                       (let* ((idx (hash-type-specifier spec)))
                         (incf probes)
                         (if (equal (svref type-cache-specs idx) spec)
                           (progn
                             (incf hits)
                             (svref type-cache-ctypes idx))
                           (let* ((ctype (values-specifier-type-internal spec env)))
                             (if ctype
                               (progn
                                 (when (cacheable-ctype-p ctype)
                                   (let* ((spec (copy-tree spec)))  ; in case it was stack-consed
                                     (without-interrupts
                                      (setf (svref type-cache-specs idx) spec
                                            (svref type-cache-ctypes idx) ctype))))
                                 ctype)
                               (make-unknown-ctype :specifier spec)))))
                       (values-specifier-type-internal spec env)))
                (setq locked nil))))
        (error (condition) (error condition)))))
  
  (defun type-cache-hit-rate ()
    (values hits probes))
  
  (defun type-cache-locked-p ()
    locked)

  (defun lock-type-cache ()
    (setq locked t)))
                    

  

;;; SPECIFIER-TYPE  --  Interface
;;;
;;;    Like VALUES-SPECIFIER-TYPE, except that we guarantee to never return a
;;; VALUES type.
;;; 
(defun specifier-type (x &optional env)
  (let ((res (values-specifier-type x env)))
    (when (values-ctype-p res)
      (signal-program-error "VALUES type illegal in this context:~%  ~S" x))
    res))

(defun single-value-specifier-type (x &optional env)
  (let ((res (specifier-type x env)))
    (if (eq res *wild-type*)
        *universal-type*
        res)))

(defun standardized-type-specifier (spec &optional env)
  (handler-case
      (type-specifier (specifier-type spec env))
    (program-error () spec)
    (parse-unknown-type () spec)))

(defun modified-numeric-type (base
			      &key
			      (class      (numeric-ctype-class      base))
			      (format     (numeric-ctype-format     base))
			      (complexp   (numeric-ctype-complexp   base))
			      (low        (numeric-ctype-low        base))
			      (high       (numeric-ctype-high       base))
			      (enumerable (ctype-enumerable base)))
  (make-numeric-ctype :class class
		     :format format
		     :complexp complexp
		     :low low
		     :high high
		     :enumerable enumerable))

;;; Precompute-Types  --  Interface
;;;
;;;    Take a list of type specifiers, compute the translation and define it as
;;; a builtin type.
;;;
 
(defun precompute-types (specs)
  (dolist (spec specs)
    (let ((res (specifier-type spec)))
      (when (numeric-ctype-p res)
        (let ((pred (make-numeric-ctype-predicate res)))
          (when pred (setf (numeric-ctype-predicate res) pred))))
      (unless (unknown-ctype-p res)
        (setf (info-type-builtin spec) res)
        (setf (info-type-kind spec) :primitive)))))

;;;; Builtin types.

;;; The NAMED-TYPE is used to represent *, T and NIL.  These types must be
;;; super or sub types of all types, not just classes and * & NIL aren't
;;; classes anyway, so it wouldn't make much sense to make them built-in
;;; classes.
;;;

(defun define-named-ctype (name)
  (let* ((ctype (%istruct 'named-ctype
                          (type-class-or-lose 'named)
                          nil
                          name)))
    (setf (info-type-kind name) :builtin
          (info-type-builtin name) ctype)))


(defvar *wild-type* (define-named-ctype '*))
(defvar *empty-type* (define-named-ctype nil))
(defvar *universal-type* (define-named-ctype t))

(defun named-ctype-p (x)
  (istruct-typep x 'named-ctype))

(setf (type-predicate 'named-ctype) 'named-ctype-p)

(define-type-method (named :simple-=) (type1 type2)
  (values (eq type1 type2) t))

(define-type-method (named :complex-=) (type1 type2)
  (cond
    ((and (eq type2 *empty-type*)
	  (intersection-ctype-p type1)
	  ;; not allowed to be unsure on these... FIXME: keep the list
	  ;; of CL types that are intersection types once and only
	  ;; once.
	  (not (or (type= type1 (specifier-type 'ratio))
		   (type= type1 (specifier-type 'keyword)))))
     ;; things like (AND (EQL 0) (SATISFIES ODDP)) or (AND FUNCTION
     ;; STREAM) can get here.  In general, we can't really tell
     ;; whether these are equal to NIL or not, so
     (values nil nil))
    ((type-might-contain-other-types-p type1)
     (invoke-complex-=-other-method type1 type2))
    (t (values nil t))))


(define-type-method (named :simple-subtypep) (type1 type2)
  (values (or (eq type1 *empty-type*) (eq type2 *wild-type*)) t))

(define-type-method (named :complex-subtypep-arg1) (type1 type2)
  (cond ((eq type1 *empty-type*)
	 t)
	(;; When TYPE2 might be the universal type in disguise
	 (type-might-contain-other-types-p type2)
	 ;; Now that the UNION and HAIRY COMPLEX-SUBTYPEP-ARG2 methods
	 ;; can delegate to us (more or less as CALL-NEXT-METHOD) when
	 ;; they're uncertain, we can't just barf on COMPOUND-TYPE and
	 ;; HAIRY-TYPEs as we used to. Instead we deal with the
	 ;; problem (where at least part of the problem is cases like
	 ;;   (SUBTYPEP T '(SATISFIES FOO))
	 ;; or
	 ;;   (SUBTYPEP T '(AND (SATISFIES FOO) (SATISFIES BAR)))
	 ;; where the second type is a hairy type like SATISFIES, or
	 ;; is a compound type which might contain a hairy type) by
	 ;; returning uncertainty.
	 (values nil nil))
	(t
	 ;; By elimination, TYPE1 is the universal type.
	 (assert (or (eq type1 *wild-type*) (eq type1 *universal-type*)))
	 ;; This case would have been picked off by the SIMPLE-SUBTYPEP
	 ;; method, and so shouldn't appear here.
	 (assert (not (eq type2 *universal-type*)))
	 ;; Since TYPE2 is not EQ *UNIVERSAL-TYPE* and is not the
	 ;; universal type in disguise, TYPE2 is not a superset of TYPE1.
	 (values nil t))))


(define-type-method (named :complex-subtypep-arg2) (type1 type2)
  (assert (not (eq type2 *wild-type*))) ; * isn't really a type.
  (cond ((eq type2 *universal-type*)
	 (values t t))
	((type-might-contain-other-types-p type1)
	 ;; those types can be *EMPTY-TYPE* or *UNIVERSAL-TYPE* in
	 ;; disguise.  So we'd better delegate.
	 (invoke-complex-subtypep-arg1-method type1 type2))
	(t
	 ;; FIXME: This seems to rely on there only being 2 or 3
	 ;; NAMED-TYPE values, and the exclusion of various
	 ;; possibilities above. It would be good to explain it and/or
	 ;; rewrite it so that it's clearer.
	 (values (not (eq type2 *empty-type*)) t))))


(define-type-method (named :complex-intersection) (type1 type2)
  (hierarchical-intersection2 type1 type2))

(define-type-method (named :unparse) (x)
  (named-ctype-name x))


;;;; Hairy and unknown types:

;;; The Hairy-Type represents anything too wierd to be described
;;; reasonably or to be useful, such as SATISFIES.  We just remember
;;; the original type spec.
;;;

(defun make-hairy-ctype (&key specifier (enumerable t))
  (%istruct 'hairy-ctype
            (type-class-or-lose 'hairy)
            enumerable
            specifier))

(defun hairy-ctype-p (x)
  (or (istruct-typep x 'hairy-ctype)
      (istruct-typep x 'unknown-ctype)))

(setf (type-predicate 'hairy-ctype) 'hairy-ctype-p)

(define-type-method (hairy :unparse) (x) (hairy-ctype-specifier x))

(define-type-method (hairy :simple-subtypep) (type1 type2)
  (let ((hairy-spec1 (hairy-ctype-specifier type1))
	(hairy-spec2 (hairy-ctype-specifier type2)))
    (cond ((equal-but-no-car-recursion hairy-spec1 hairy-spec2)
	   (values t t))
	  (t
	   (values nil nil)))))

(define-type-method (hairy :complex-subtypep-arg2) (type1 type2)
  (invoke-complex-subtypep-arg1-method type1 type2))

(define-type-method (hairy :complex-subtypep-arg1) (type1 type2)
  (declare (ignore type1 type2))
  (values nil nil))

(define-type-method (hairy :complex-=) (type1 type2)
  (if (and (unknown-ctype-p type2)
	   (let* ((specifier2 (unknown-ctype-specifier type2))
                  (name2 (if (consp specifier2)
			   (car specifier2)
			   specifier2)))
             (info-type-kind name2)))
      (let ((type2 (specifier-type (unknown-ctype-specifier type2))))
        (if (unknown-ctype-p type2)
            (values nil nil)
            (type= type1 type2)))
  (values nil nil)))

(define-type-method (hairy :simple-intersection :complex-intersection)
		    (type1 type2)
  (if (type= type1 type2)
    type1
    nil))


(define-type-method (hairy :simple-union) 
    (type1 type2)
  (if (type= type1 type2)
      type1
      nil))

(define-type-method (hairy :simple-=) (type1 type2)
  (if (equal-but-no-car-recursion (hairy-ctype-specifier type1)
				  (hairy-ctype-specifier type2))
      (values t t)
      (values nil nil)))



(def-type-translator satisfies (&whole x fun)
  (unless (symbolp fun)
    (report-bad-arg fun 'symbol))
  (make-hairy-ctype :specifier x))


;;; Negation Ctypes
(defun make-negation-ctype (&key type (enumerable t))
  (%istruct 'negation-ctype
	    (type-class-or-lose 'negation)
	    enumerable
	    type))

(defun negation-ctype-p (x)
  (istruct-typep x 'negation-ctype))

(setf (type-predicate 'negation-ctype) 'negation-ctype-p)

(define-type-method (negation :unparse) (x)
  `(not ,(type-specifier (negation-ctype-type x))))

(define-type-method (negation :simple-subtypep) (type1 type2)
  (csubtypep (negation-ctype-type type2) (negation-ctype-type type1)))

(define-type-method (negation :complex-subtypep-arg2) (type1 type2)
  (let* ((complement-type2 (negation-ctype-type type2))
	 (intersection2 (type-intersection type1 complement-type2)))
    (if intersection2
	;; FIXME: if uncertain, maybe try arg1?
	(type= intersection2 *empty-type*)
	(invoke-complex-subtypep-arg1-method type1 type2))))

(define-type-method (negation :complex-subtypep-arg1) (type1 type2)
  (block nil
    ;; (Several logical truths in this block are true as long as
    ;; b/=T. As of sbcl-0.7.1.28, it seems impossible to construct a
    ;; case with b=T where we actually reach this type method, but
    ;; we'll test for and exclude this case anyway, since future
    ;; maintenance might make it possible for it to end up in this
    ;; code.)
    (multiple-value-bind (equal certain)
	(type= type2 *universal-type*)
      (unless certain
	(return (values nil nil)))
      (when equal
	(return (values t t))))
    (let ((complement-type1 (negation-ctype-type type1)))
      ;; Do the special cases first, in order to give us a chance if
      ;; subtype/supertype relationships are hairy.
      (multiple-value-bind (equal certain) 
	  (type= complement-type1 type2)
	;; If a = b, ~a is not a subtype of b (unless b=T, which was
	;; excluded above).
	(unless certain
	  (return (values nil nil)))
	(when equal
	  (return (values nil t))))
      ;; KLUDGE: ANSI requires that the SUBTYPEP result between any
      ;; two built-in atomic type specifiers never be uncertain. This
      ;; is hard to do cleanly for the built-in types whose
      ;; definitions include (NOT FOO), i.e. CONS and RATIO. However,
      ;; we can do it with this hack, which uses our global knowledge
      ;; that our implementation of the type system uses disjoint
      ;; implementation types to represent disjoint sets (except when
      ;; types are contained in other types).  (This is a KLUDGE
      ;; because it's fragile. Various changes in internal
      ;; representation in the type system could make it start
      ;; confidently returning incorrect results.) -- WHN 2002-03-08
      (unless (or (type-might-contain-other-types-p complement-type1)
		  (type-might-contain-other-types-p type2))
	;; Because of the way our types which don't contain other
	;; types are disjoint subsets of the space of possible values,
	;; (SUBTYPEP '(NOT AA) 'B)=NIL when AA and B are simple (and B
	;; is not T, as checked above).
	(return (values nil t)))
      ;; The old (TYPE= TYPE1 TYPE2) branch would never be taken, as
      ;; TYPE1 and TYPE2 will only be equal if they're both NOT types,
      ;; and then the :SIMPLE-SUBTYPEP method would be used instead.
      ;; But a CSUBTYPEP relationship might still hold:
      (multiple-value-bind (equal certain)
	  (csubtypep complement-type1 type2)
	;; If a is a subtype of b, ~a is not a subtype of b (unless
	;; b=T, which was excluded above).
	(unless certain
	  (return (values nil nil)))
	(when equal
	  (return (values nil t))))
      (multiple-value-bind (equal certain)
	  (csubtypep type2 complement-type1)
	;; If b is a subtype of a, ~a is not a subtype of b.  (FIXME:
	;; That's not true if a=T. Do we know at this point that a is
	;; not T?)
	(unless certain
	  (return (values nil nil)))
	(when equal
	  (return (values nil t))))
      ;; old CSR comment ca. 0.7.2, now obsoleted by the SIMPLE-CTYPE?
      ;; KLUDGE case above: Other cases here would rely on being able
      ;; to catch all possible cases, which the fragility of this type
      ;; system doesn't inspire me; for instance, if a is type= to ~b,
      ;; then we want T, T; if this is not the case and the types are
      ;; disjoint (have an intersection of *empty-type*) then we want
      ;; NIL, T; else if the union of a and b is the *universal-type*
      ;; then we want T, T. So currently we still claim to be unsure
      ;; about e.g. (subtypep '(not fixnum) 'single-float).
      ;;
      ;; OTOH we might still get here:
      (values nil nil))))

(define-type-method (negation :complex-=) (type1 type2)
  ;; (NOT FOO) isn't equivalent to anything that's not a negation
  ;; type, except possibly a type that might contain it in disguise.
  (declare (ignore type2))
  (if (type-might-contain-other-types-p type1)
      (values nil nil)
      (values nil t)))

(define-type-method (negation :simple-intersection) (type1 type2)
  (let ((not1 (negation-ctype-type type1))
	(not2 (negation-ctype-type type2)))
    (cond
      ((csubtypep not1 not2) type2)
      ((csubtypep not2 not1) type1)
      ;; Why no analagous clause to the disjoint in the SIMPLE-UNION2
      ;; method, below?  The clause would read
      ;;
      ;; ((EQ (TYPE-UNION NOT1 NOT2) *UNIVERSAL-TYPE*) *EMPTY-TYPE*)
      ;;
      ;; but with proper canonicalization of negation types, there's
      ;; no way of constructing two negation types with union of their
      ;; negations being the universal type.
      (t
       nil))))

(define-type-method (negation :complex-intersection) (type1 type2)
  (cond
    ((csubtypep type1 (negation-ctype-type type2)) *empty-type*)
    ((eq (type-intersection type1 (negation-ctype-type type2)) *empty-type*)
     type1)
    (t nil)))

(define-type-method (negation :simple-union) (type1 type2)
  (let ((not1 (negation-ctype-type type1))
	(not2 (negation-ctype-type type2)))
    (cond
      ((csubtypep not1 not2) type1)
      ((csubtypep not2 not1) type2)
      ((eq (type-intersection not1 not2) *empty-type*)
       *universal-type*)
      (t nil))))

(define-type-method (negation :complex-union) (type1 type2)
  (cond
    ((csubtypep (negation-ctype-type type2) type1) *universal-type*)
    ((eq (type-intersection type1 (negation-ctype-type type2)) *empty-type*)
     type2)
    (t nil)))

(define-type-method (negation :simple-=) (type1 type2)
  (type= (negation-ctype-type type1) (negation-ctype-type type2)))

(def-type-translator not (typespec &environment env)
  (let* ((not-type (specifier-type typespec env))
	 (spec (type-specifier not-type)))
    (cond
      ;; canonicalize (NOT (NOT FOO))
      ((and (listp spec) (eq (car spec) 'not))
       (specifier-type (cadr spec) env))
      ;; canonicalize (NOT NIL) and (NOT T)
      ((eq not-type *empty-type*) *universal-type*)
      ((eq not-type *universal-type*) *empty-type*)
      ((and (numeric-ctype-p not-type)
	    (null (numeric-ctype-low not-type))
	    (null (numeric-ctype-high not-type)))
       (make-negation-ctype :type not-type))
      ((numeric-ctype-p not-type)
       (type-union
	(make-negation-ctype
	 :type (modified-numeric-type not-type :low nil :high nil))
	(cond
	  ((null (numeric-ctype-low not-type))
	   (modified-numeric-type
	    not-type
	    :low (let ((h (numeric-ctype-high not-type)))
		   (if (consp h) (car h) (list h)))
	    :high nil))
	  ((null (numeric-ctype-high not-type))
	   (modified-numeric-type
	    not-type
	    :low nil
	    :high (let ((l (numeric-ctype-low not-type)))
		    (if (consp l) (car l) (list l)))))
	  (t (type-union
	      (modified-numeric-type
	       not-type
	       :low nil
	       :high (let ((l (numeric-ctype-low not-type)))
		       (if (consp l) (car l) (list l))))
	      (modified-numeric-type
	       not-type
	       :low (let ((h (numeric-ctype-high not-type)))
		      (if (consp h) (car h) (list h)))
	       :high nil))))))
      ((intersection-ctype-p not-type)
       (apply #'type-union
	      (mapcar #'(lambda (x)
			  (specifier-type `(not ,(type-specifier x)) env))
		      (intersection-ctype-types not-type))))
      ((union-ctype-p not-type)
       (apply #'type-intersection
	      (mapcar #'(lambda (x)
			  (specifier-type `(not ,(type-specifier x)) env))
		      (union-ctype-types not-type))))
      ((member-ctype-p not-type)
       (let ((members (member-ctype-members not-type)))
	 (if (some #'floatp members)
	   (let (floats)
	     (dolist (pair '((0.0f0 . -0.0f0) (0.0d0 . -0.0d0)))
	       (when (member (car pair) members)
		 (assert (not (member (cdr pair) members)))
		 (push (cdr pair) floats)
		 (setf members (remove (car pair) members)))
	       (when (member (cdr pair) members)
		 (assert (not (member (car pair) members)))
		 (push (car pair) floats)
		 (setf members (remove (cdr pair) members))))
	     (apply #'type-intersection
		    (if (null members)
		      *universal-type*
		      (make-negation-ctype
		       :type (make-member-ctype :members members)))
		    (mapcar
		     (lambda (x)
		       (let ((type (ctype-of x)))
			 (type-union
			  (make-negation-ctype
			   :type (modified-numeric-type type
							  :low nil :high nil))
			    (modified-numeric-type type
						   :low nil :high (list x))
			    (make-member-ctype :members (list x))
			    (modified-numeric-type type
						   :low (list x) :high nil))))
		     floats)))
	     (make-negation-ctype :type not-type))))
      ((and (cons-ctype-p not-type)
	    (eq (cons-ctype-car-ctype not-type) *universal-type*)
	    (eq (cons-ctype-cdr-ctype not-type) *universal-type*))
       (make-negation-ctype :type not-type))
      ((cons-ctype-p not-type)
       (type-union
	(make-negation-ctype :type (specifier-type 'cons env))
	(cond
	  ((and (not (eq (cons-ctype-car-ctype not-type) *universal-type*))
		(not (eq (cons-ctype-cdr-ctype not-type) *universal-type*)))
	   (type-union
	    (make-cons-ctype
	     (specifier-type `(not ,(type-specifier
				     (cons-ctype-car-ctype not-type))) env)
	     *universal-type*)
	    (make-cons-ctype
	     *universal-type*
	     (specifier-type `(not ,(type-specifier
				     (cons-ctype-cdr-ctype not-type))) env))))
	  ((not (eq (cons-ctype-car-ctype not-type) *universal-type*))
	   (make-cons-ctype
	    (specifier-type `(not ,(type-specifier
				    (cons-ctype-car-ctype not-type))) env)
	    *universal-type*))
	  ((not (eq (cons-ctype-cdr-ctype not-type) *universal-type*))
	   (make-cons-ctype
	    *universal-type*
	    (specifier-type `(not ,(type-specifier
				    (cons-ctype-cdr-ctype not-type))) env)))
	  (t (error "Weird CONS type ~S" not-type)))))
      (t (make-negation-ctype :type not-type)))))


;;;; Numeric types.

;;; A list of all the float formats, in order of decreasing precision.
;;;
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant float-formats
    '(long-float double-float single-float short-float)))

;;; The type of a float format.
;;;
(deftype float-format () `(member ,@float-formats))

(defun type-bound-number (x)
  (if (consp x)
      (destructuring-bind (result) x result)
      x))

(defun make-numeric-ctype (&key class 
                                format
                                (complexp :real)
                                low
                                high
                                enumerable
                                predicate)
  ;; if interval is empty
  (if (and low
	   high
	   (if (or (consp low) (consp high)) ; if either bound is exclusive
	     (>= (type-bound-number low) (type-bound-number high))
	     (> low high)))
    *empty-type*
    (multiple-value-bind (canonical-low canonical-high)
	(case class
	  (integer
	   ;; INTEGER types always have their LOW and HIGH bounds
	   ;; represented as inclusive, not exclusive values.
	   (values (if (consp low)
		     (1+ (type-bound-number low))
		     low)
		   (if (consp high)
		     (1- (type-bound-number high))
		     high)))
	  (t 
	   ;; no canonicalization necessary
	   (values low high)))
      (when (and (eq class 'rational)
		 (integerp canonical-low)
		 (integerp canonical-high)
		 (= canonical-low canonical-high))
	(setf class 'integer))
      (%istruct 'numeric-ctype
		(type-class-or-lose 'number)
		enumerable
		class
		format
		complexp
		canonical-low
		canonical-high
		predicate))))
    

(defun make-numeric-ctype-predicate (ctype)
  (let ((class (numeric-ctype-class ctype))
        (lo (numeric-ctype-low ctype))
        (hi (numeric-ctype-high ctype)))
    (if (eq class 'integer)
      (if (and hi
               lo
               (<= hi target::target-most-positive-fixnum)
               (>= lo target::target-most-negative-fixnum))      
        #'(lambda (n)
            (and (fixnump n)
                 (locally (declare (fixnum n hi lo))
                   (and (%i>= n lo)
                        (%i<= n hi)))))))))

(defun numeric-ctype-p (x)
  (istruct-typep x 'numeric-ctype))

(setf (type-predicate 'numeric-ctype) 'numeric-ctype-p)

(define-type-method (number :simple-=) (type1 type2)
  (values
   (and (eq (numeric-ctype-class type1) (numeric-ctype-class type2))
	(eq (numeric-ctype-format type1) (numeric-ctype-format type2))
	(eq (numeric-ctype-complexp type1) (numeric-ctype-complexp type2))
	(equalp (numeric-ctype-low type1) (numeric-ctype-low type2))
	(equalp (numeric-ctype-high type1) (numeric-ctype-high type2)))
   t))

(define-type-method (number :unparse) (type)
  (let* ((complexp (numeric-ctype-complexp type))
	 (low (numeric-ctype-low type))
	 (high (numeric-ctype-high type))
	 (base (case (numeric-ctype-class type)
		 (integer 'integer)
		 (rational 'rational)
		 (float (or (numeric-ctype-format type) 'float))
		 (t 'real))))
    (let ((base+bounds
	   (cond ((and (eq base 'integer) high low)
		  (let ((high-count (logcount high))
			(high-length (integer-length high)))
		    (cond ((= low 0)
			   (cond ((= high 0) '(integer 0 0))
				 ((= high 1) 'bit)
				 ((and (= high-count high-length)
				       (plusp high-length))
				  `(unsigned-byte ,high-length))
				 (t
				  `(mod ,(1+ high)))))
			  ((and (= low target::target-most-negative-fixnum)
				(= high target::target-most-positive-fixnum))
			   'fixnum)
			  ((and (= low (lognot high))
				(= high-count high-length)
				(> high-count 0))
			   `(signed-byte ,(1+ high-length)))
			  (t
			   `(integer ,low ,high)))))
		 (high `(,base ,(or low '*) ,high))
		 (low
		  (if (and (eq base 'integer) (= low 0))
		      'unsigned-byte
		      `(,base ,low)))
		 (t base))))
      (ecase complexp
	(:real
	 base+bounds)
	(:complex
	 (if (eq base+bounds 'real)
	     'complex
	     `(complex ,base+bounds)))
	((nil)
	 (assert (eq base+bounds 'real))
	 'number)))))

;;; Numeric-Bound-Test  --  Internal
;;;
;;;    Return true if X is "less than or equal" to Y, taking open bounds into
;;; consideration.  Closed is the predicate used to test the bound on a closed
;;; interval (e.g. <=), and Open is the predicate used on open bounds (e.g. <).
;;; Y is considered to be the outside bound, in the sense that if it is
;;; infinite (NIL), then the test suceeds, whereas if X is infinite, then the
;;; test fails (unless Y is also infinite).
;;;
;;;    This is for comparing bounds of the same kind, e.g. upper and upper.
;;; Use Numeric-Bound-Test* for different kinds of bounds.
;;;
(defmacro numeric-bound-test (x y closed open)
  `(cond ((not ,y) t)
	   ((not ,x) nil)
	   ((consp ,x)
	    (if (consp ,y)
	      (,closed (car ,x) (car ,y))
	      (,closed (car ,x) ,y)))
	   (t
	    (if (consp ,y)
	      (,open ,x (car ,y))
	      (,closed ,x ,y)))))

;;; Numeric-Bound-Test*  --  Internal
;;;
;;;    Used to compare upper and lower bounds.  This is different from the
;;; same-bound case:
;;; -- Since X = NIL is -infinity, whereas y = NIL is +infinity, we return true
;;;    if *either* arg is NIL.
;;; -- an open inner bound is "greater" and also squeezes the interval, causing
;;;    us to use the Open test for those cases as well.
;;;
(defmacro numeric-bound-test* (x y closed open)
  `(cond ((not ,y) t)
         ((not ,x) t)
         ((consp ,x)
          (if (consp ,y)
	      (,open (car ,x) (car ,y))
	      (,open (car ,x) ,y)))
         (t
          (if (consp ,y)
	      (,open ,x (car ,y))
	      (,closed ,x ,y)))))

;;; Numeric-Bound-Max  --  Internal
;;;
;;;    Return whichever of the numeric bounds X and Y is "maximal" according to
;;; the predicates Closed (e.g. >=) and Open (e.g. >).  This is only meaningful
;;; for maximizing like bounds, i.e. upper and upper.  If Max-P is true, then
;;; we return NIL if X or Y is NIL, otherwise we return the other arg.
;;;
(defmacro numeric-bound-max (x y closed open max-p)
  (once-only ((n-x x)
	      (n-y y))
    `(cond
      ((not ,n-x) ,(if max-p nil n-y))
      ((not ,n-y) ,(if max-p nil n-x))
      ((consp ,n-x)
       (if (consp ,n-y)
	 (if (,closed (car ,n-x) (car ,n-y)) ,n-x ,n-y)
	 (if (,open (car ,n-x) ,n-y) ,n-x ,n-y)))
      (t
       (if (consp ,n-y)
	 (if (,open (car ,n-y) ,n-x) ,n-y ,n-x)
	 (if (,closed ,n-y ,n-x) ,n-y ,n-x))))))


(define-type-method (number :simple-subtypep) (type1 type2)
  (let ((class1 (numeric-ctype-class type1))
	  (class2 (numeric-ctype-class type2))
	  (complexp2 (numeric-ctype-complexp type2))
	  (format2 (numeric-ctype-format type2))
	  (low1 (numeric-ctype-low type1))
	  (high1 (numeric-ctype-high type1))
	  (low2 (numeric-ctype-low type2))
	  (high2 (numeric-ctype-high type2)))
    ;;
    ;; If one is complex and the other isn't, they are disjoint.
    (cond ((not (or (eq (numeric-ctype-complexp type1) complexp2)
		        (null complexp2)))
	     (values nil t))
	    ;;
	    ;; If the classes are specified and different, the types are
	    ;; disjoint unless type2 is rational and type1 is integer.
	    ((not (or (eq class1 class2) (null class2)
		        (and (eq class1 'integer) (eq class2 'rational))))
	     (values nil t))
	    ;;
	    ;; If the float formats are specified and different, the types
	    ;; are disjoint.
	    ((not (or (eq (numeric-ctype-format type1) format2)
		        (null format2)))
	     (values nil t))
	    ;;
	    ;; Check the bounds.
	    ((and (numeric-bound-test low1 low2 >= >)
		    (numeric-bound-test high1 high2 <= <))
	     (values t t))
	    (t
	     (values nil t)))))

;(define-superclasses number (generic-number))

;;; NUMERIC-TYPES-ADJACENT  --  Internal
;;;
;;;    If the high bound of Low is adjacent to the low bound of High, then
;;; return T, otherwise NIL.
;;;
(defun numeric-types-adjacent (low high)
  (let ((low-bound (numeric-ctype-high low))
	(high-bound (numeric-ctype-low high)))
    (cond ((not (and low-bound high-bound)) nil)
	    ((consp low-bound)
	     (eql (car low-bound) high-bound))
	    ((consp high-bound)
	     (eql (car high-bound) low-bound))
	    ((and (eq (numeric-ctype-class low) 'integer)
		    (eq (numeric-ctype-class high) 'integer))
	     (eql (1+ low-bound) high-bound))
	    (t
	     nil))))

;;;
;;; Return a numeric type that is a supertype for both type1 and type2.
;;; 
(define-type-method (number :simple-union) (type1 type2)
  (declare (type numeric-ctype type1 type2))
  (cond ((csubtypep type1 type2) type2)
	((csubtypep type2 type1) type1)
	(t
	 (let ((class1 (numeric-ctype-class type1))
	       (format1 (numeric-ctype-format type1))
	       (complexp1 (numeric-ctype-complexp type1))
	       (class2 (numeric-ctype-class type2))
	       (format2 (numeric-ctype-format type2))
	       (complexp2 (numeric-ctype-complexp type2)))
	   (cond
             ((and (eq class1 class2)
                   (eq format1 format2)
                   (eq complexp1 complexp2)
                   (or (numeric-types-intersect type1 type2)
                       (numeric-types-adjacent type1 type2)
                       (numeric-types-adjacent type2 type1)))
              (make-numeric-ctype
               :class class1
               :format format1
               :complexp complexp1
               :low (numeric-bound-max (numeric-ctype-low type1)
                                       (numeric-ctype-low type2)
                                       <= < t)
               :high (numeric-bound-max (numeric-ctype-high type1)
                                        (numeric-ctype-high type2)
                                        >= > t)))
             ;; FIXME: These two clauses are almost identical, and the
             ;; consequents are in fact identical in every respect.
             ((and (eq class1 'rational)
                   (eq class2 'integer)
                   (eq format1 format2)
                   (eq complexp1 complexp2)
                   (integerp (numeric-ctype-low type2))
                   (integerp (numeric-ctype-high type2))
                   (= (numeric-ctype-low type2) (numeric-ctype-high type2))
                   (or (numeric-types-adjacent type1 type2)
                       (numeric-types-adjacent type2 type1)))
              (make-numeric-ctype
               :class 'rational
               :format format1
               :complexp complexp1
               :low (numeric-bound-max (numeric-ctype-low type1)
                                       (numeric-ctype-low type2)
                                       <= < t)
               :high (numeric-bound-max (numeric-ctype-high type1)
                                        (numeric-ctype-high type2)
                                        >= > t)))
             ((and (eq class1 'integer)
                   (eq class2 'rational)
                   (eq format1 format2)
                   (eq complexp1 complexp2)
                   (integerp (numeric-ctype-low type1))
                   (integerp (numeric-ctype-high type1))
                   (= (numeric-ctype-low type1) (numeric-ctype-high type1))
                   (or (numeric-types-adjacent type1 type2)
                       (numeric-types-adjacent type2 type1)))
              (make-numeric-ctype
               :class 'rational
               :format format1
               :complexp complexp1
               :low (numeric-bound-max (numeric-ctype-low type1)
                                       (numeric-ctype-low type2)
                                       <= < t)
               :high (numeric-bound-max (numeric-ctype-high type1)
                                        (numeric-ctype-high type2)
                                        >= > t)))
             (t nil))))))

(setf (info-type-kind 'number) :primitive
      (info-type-builtin 'number) (make-numeric-ctype :complexp nil))

(def-type-translator complex (&optional spec &environment env)
  (if (eq spec '*)
      (make-numeric-ctype :complexp :complex)
      (labels ((not-numeric ()
                 (error "Component type for Complex is not numeric: ~S." spec))
               (not-real ()
                 (error "Component type for Complex is not a subtype of real: ~S." spec))
               (complex1 (component-type)
                 (unless (numeric-ctype-p component-type)
                   (not-numeric))
                 (when (eq (numeric-ctype-complexp component-type) :complex)
                   (not-real))
                 (let ((res (copy-uvector component-type)))
                   (setf (numeric-ctype-complexp res) :complex)
                   (setf (numeric-ctype-predicate res) nil) ; <<
                   res))
               (do-complex (ctype)
                 (cond
                   ((eq ctype *empty-type*) *empty-type*)
                   ((eq ctype *universal-type*) (not-real))
                   ((numeric-ctype-p ctype) (complex1 ctype))
                   ((union-ctype-p ctype)
                    (apply #'type-union
                           (mapcar #'do-complex (union-ctype-types ctype))))
                   ((member-ctype-p ctype)
                    (apply #'type-union
                           (mapcar (lambda (x) (do-complex (ctype-of x)))
                                   (member-ctype-members ctype))))
                   ((and (intersection-ctype-p ctype)
                         ;; just enough to handle simple types like RATIO.
                         (let ((numbers (remove-if-not
                                         #'numeric-ctype-p
                                         (intersection-ctype-types ctype))))
                           (and (car numbers)
                                (null (cdr numbers))
                                (eq (numeric-ctype-complexp (car numbers)) :real)
                                (complex1 (car numbers))))))
                   (t                   ; punt on harder stuff for now
                    (not-real)))))
        (let ((ctype (specifier-type spec env)))
          (do-complex ctype)))))

;;; Check-Bound  --  Internal
;;;
;;;    Check that X is a well-formed numeric bound of the specified Type.
;;; If X is *, return NIL, otherwise return the bound.
;;;
(defmacro check-bound (x type)
  `(cond ((eq ,x '*) nil)
	   ((or (typep ,x ',type)
	        (and (consp ,x) (typep (car ,x) ',type) (null (cdr ,x))))
	    ,x)
	   (t
	    (error "Bound is not *, a ~A or a list of a ~A: ~S" ',type ',type ,x))))

(def-type-translator integer (&optional low high)
  (let* ((l (check-bound low integer))
         (lb (if (consp l) (1+ (car l)) l))
         (h (check-bound high integer))
         (hb (if (consp h) (1- (car h)) h)))
    (if (and hb lb (< hb lb))
      *empty-type*
      (make-numeric-ctype :class 'integer  :complexp :real
                          :enumerable (not (null (and l h)))
                          :low lb
                          :high hb))))

(deftype mod (n)
  (unless (and (integerp n) (> n 0))
    (error "Bad N specified for MOD type specifier: ~S." n))
  `(integer 0 ,(1- n)))


(defmacro def-bounded-type (type class format)
  `(def-type-translator ,type (&optional low high)
     (let ((lb (check-bound low ,type))
	     (hb (check-bound high ,type)))
       (unless (numeric-bound-test* lb hb <= <)
	   (error "Lower bound ~S is not less than upper bound ~S." low high))
       (make-numeric-ctype :class ',class :format ',format :low lb :high hb))))

(def-bounded-type rational rational nil)

(defun coerce-bound (bound type inner-coerce-bound-fun)
  (declare (type function inner-coerce-bound-fun))
  (cond ((eql bound '*)
	 bound)
	((consp bound)
	 (destructuring-bind (inner-bound) bound
	   (list (funcall inner-coerce-bound-fun inner-bound type))))
	(t
	 (funcall inner-coerce-bound-fun bound type))))

(defun inner-coerce-real-bound (bound type)
  (ecase type
    (rational (rationalize bound))
    (float (if (floatp bound)
	       bound
	       ;; Coerce to the widest float format available, to
	       ;; avoid unnecessary loss of precision:
	       (coerce bound 'long-float)))))

(defun coerced-real-bound (bound type)
  (coerce-bound bound type #'inner-coerce-real-bound))

(defun coerced-float-bound (bound type)
  (coerce-bound bound type #'coerce))

#|
(def-type-translator real (&optional (low '*) (high '*))
  (specifier-type `(or (float ,(coerced-real-bound  low 'float)
			      ,(coerced-real-bound high 'float))
		       (rational ,(coerced-real-bound  low 'rational)
				 ,(coerced-real-bound high 'rational)))))

(def-type-translator float (&optional (low '*) (high '*))
  (specifier-type 
   `(or (single-float ,(coerced-float-bound  low 'single-float)
		      ,(coerced-float-bound high 'single-float))
	(double-float ,(coerced-float-bound  low 'double-float)
		      ,(coerced-float-bound high 'double-float)))))
|#

(def-bounded-type float float nil)
(def-bounded-type real nil nil)

(defmacro define-float-format (f)
  `(def-bounded-type ,f float ,f))

(define-float-format short-float)
(define-float-format single-float)
(define-float-format double-float)
(define-float-format long-float)

(defun numeric-types-intersect (type1 type2)
  (declare (type numeric-ctype type1 type2))
  (let* ((class1 (numeric-ctype-class type1))
	 (class2 (numeric-ctype-class type2))
	 (complexp1 (numeric-ctype-complexp type1))
	 (complexp2 (numeric-ctype-complexp type2))
	 (format1 (numeric-ctype-format type1))
	 (format2 (numeric-ctype-format type2))
	 (low1 (numeric-ctype-low type1))
	 (high1 (numeric-ctype-high type1))
	 (low2 (numeric-ctype-low type2))
	 (high2 (numeric-ctype-high type2)))
    ;;
    ;; If one is complex and the other isn't, then they are disjoint.
    (cond ((not (or (eq complexp1 complexp2)
		    (null complexp1) (null complexp2)))
	   nil)
	  ;;
	  ;; If either type is a float, then the other must either be specified
	  ;; to be a float or unspecified.  Otherwise, they are disjoint.
	  ((and (eq class1 'float) (not (member class2 '(float nil)))) nil)
	  ((and (eq class2 'float) (not (member class1 '(float nil)))) nil)
	  ;;
	  ;; If the float formats are specified and different, the types
	  ;; are disjoint.
	  ((not (or (eq format1 format2) (null format1) (null format2)))
	   nil)
	  (t
	   ;;
	   ;; Check the bounds.  This is a bit odd because we must always have
	   ;; the outer bound of the interval as the second arg.
	   (if (numeric-bound-test high1 high2 <= <)
	     (or (and (numeric-bound-test low1 low2 >= >)
		      (numeric-bound-test* low1 high2 <= <))
		 (and (numeric-bound-test low2 low1 >= >)
		      (numeric-bound-test* low2 high1 <= <)))
	     (or (and (numeric-bound-test* low2 high1 <= <)
		      (numeric-bound-test low2 low1 >= >))
		 (and (numeric-bound-test high2 high1 <= <)
		      (numeric-bound-test* high2 low1 >= >))))))))

;;; Round-Numeric-Bound  --  Internal
;;;
;;;    Take the numeric bound X and convert it into something that can be used
;;; as a bound in a numeric type with the specified Class and Format.  If up-p
;;; is true, then we round up as needed, otherwise we round down.  Up-p true
;;; implies that X is a lower bound, i.e. (N) > N.
;;;
;;; This is used by Numeric-Type-Intersection to mash the bound into the
;;; appropriate type number.  X may only be a float when Class is Float.
;;;
;;; ### Note: it is possible for the coercion to a float to overflow or
;;; underflow.  This happens when the bound doesn't fit in the specified
;;; format.  In this case, we should really return the appropriate
;;; {Most | Least}-{Positive | Negative}-XXX-Float float of desired format.
;;; But these conditions aren't currently signalled in any useful way.
;;;
;;; Also, when converting an open rational bound into a float we should
;;; probably convert it to a closed bound of the closest float in the specified
;;; format.  In general, open float bounds are fucked.
;;;
(defun round-numeric-bound (x class format up-p)
  (if x
    (let ((cx (if (consp x) (car x) x)))
	(ecase class
	  ((nil rational) x)
	  (integer
	   (if (and (consp x) (integerp cx))
	     (if up-p (1+ cx) (1- cx))
	     (if up-p (ceiling cx) (floor cx))))
	  (float
	   (let ((res (if format (coerce cx format) (float cx))))
	     (if (consp x) (list res) res)))))
    nil))

;;; Number :Simple-Intersection type method  --  Internal
;;;
;;;    Handle the case of Type-Intersection on two numeric types.  We use
;;; Types-Intersect to throw out the case of types with no intersection.  If an
;;; attribute in Type1 is unspecified, then we use Type2's attribute, which
;;; must be at least as restrictive.  If the types intersect, then the only
;;; attributes that can be specified and different are the class and the
;;; bounds.
;;;
;;;    When the class differs, we use the more restrictive class.  The only
;;; interesting case is rational/integer, since rational includes integer.
;;;
;;;    We make the result lower (upper) bound the maximum (minimum) of the
;;; argument lower (upper) bounds.  We convert the bounds into the
;;; appropriate numeric type before maximizing.  This avoids possible confusion
;;; due to mixed-type comparisons (but I think the result is the same).
;;;
(define-type-method (number :simple-intersection) (type1 type2)
  (declare (type numeric-ctype type1 type2))
  (if (numeric-types-intersect type1 type2)
    (let* ((class1 (numeric-ctype-class type1))
	   (class2 (numeric-ctype-class type2))
	   (class (ecase class1
		    ((nil) class2)
		    ((integer float) class1)
		    (rational (if (eq class2 'integer) 'integer 'rational))))
	   (format (or (numeric-ctype-format type1)
		       (numeric-ctype-format type2))))
      (make-numeric-ctype
       :class class
       :format format
       :complexp (or (numeric-ctype-complexp type1)
		     (numeric-ctype-complexp type2))
       :low (numeric-bound-max
	     (round-numeric-bound (numeric-ctype-low type1)
				  class format t)
	     (round-numeric-bound (numeric-ctype-low type2)
				  class format t)
	     > >= nil)
       :high (numeric-bound-max
	      (round-numeric-bound (numeric-ctype-high type1)
				   class format nil)
	      (round-numeric-bound (numeric-ctype-high type2)
				   class format nil)
	      < <= nil)))
    *empty-type*))

;;; Float-Format-Max  --  Interface
;;;
;;;    Given two float formats, return the one with more precision.  If either
;;; one is null, return NIL.
;;;
(defun float-format-max (f1 f2)
  (when (and f1 f2)
    (dolist (f float-formats (error "Bad float format: ~S." f1))
      (when (or (eq f f1) (eq f f2))
	  (return f)))))


;;; Numeric-Contagion  --  Interface
;;;
;;;    Return the result of an operation on Type1 and Type2 according to the
;;; rules of numeric contagion.  This is always NUMBER, some float format
;;; (possibly complex) or RATIONAL.  Due to rational canonicalization, there
;;; isn't much we can do here with integers or rational complex numbers.
;;;
;;;    If either argument is not a Numeric-Type, then return NUMBER.  This is
;;; useful mainly for allowing types that are technically numbers, but not a
;;; Numeric-Type. 
;;;
(defun numeric-contagion (type1 type2)
  (if (and (numeric-ctype-p type1) (numeric-ctype-p type2))
    (let ((class1 (numeric-ctype-class type1))
	    (class2 (numeric-ctype-class type2))
	    (format1 (numeric-ctype-format type1))
	    (format2 (numeric-ctype-format type2))
	    (complexp1 (numeric-ctype-complexp type1))
	    (complexp2 (numeric-ctype-complexp type2)))
	(cond ((or (null complexp1)
		   (null complexp2))
	       (specifier-type 'number))
	      ((eq class1 'float)
	       (make-numeric-ctype
		  :class 'float
		  :format (ecase class2
			      (float (float-format-max format1 format2))
			      ((integer rational) format1)
			      ((nil)
			       ;; A double-float with any real number is a
			       ;; double-float.
			       (if (eq format1 'double-float)
				 'double-float
				 nil)))
		  :complexp (if (or (eq complexp1 :complex)
				    (eq complexp2 :complex))
			      :complex
			      :real)))
	      ((eq class2 'float) (numeric-contagion type2 type1))
	      ((and (eq complexp1 :real) (eq complexp2 :real))
	       (make-numeric-ctype
		  :class (and class1 class2 'rational)
		  :complexp :real))
	      (t
	       (specifier-type 'number))))
    (specifier-type 'number)))




;;;; Array types:

;;; The Array-Type is used to represent all array types, including things such
;;; as SIMPLE-STRING.
;;;

(defun make-array-ctype (&key
                         (dimensions '*)
                         (complexp '*)
                         element-type
                         (specialized-element-type *wild-type*))
  (%istruct 'array-ctype
            (type-class-or-lose 'array)
            nil
            dimensions
            complexp
            element-type
            specialized-element-type
            (unless (eq specialized-element-type *wild-type*)
              (ctype-subtype specialized-element-type))))

(defun array-ctype-p (x) (istruct-typep x 'array-ctype))
(setf (type-predicate 'array-ctype) 'array-ctype-p)

;;; Specialized-Element-Type-Maybe  --  Internal
;;;
;;;      What this does depends on the setting of the
;;; *use-implementation-types* switch.  If true, return the specialized element
;;; type, otherwise return the original element type.
;;;
(defun specialized-element-type-maybe (type)
  (declare (type array-ctype type))
  (if *use-implementation-types*
    (array-ctype-specialized-element-type type)
    (array-ctype-element-type type)))

(define-type-method (array :simple-=) (type1 type2)
  (if (or (unknown-ctype-p (array-ctype-element-type type1))
	  (unknown-ctype-p (array-ctype-element-type type2)))
    (multiple-value-bind (equalp certainp)
	(type= (array-ctype-element-type type1)
	       (array-ctype-element-type type2))
      (assert (not (and (not equalp) certainp)))
      (values equalp certainp))
    (values (and (equal (array-ctype-dimensions type1)
			(array-ctype-dimensions type2))
		 (eq (array-ctype-complexp type1)
		     (array-ctype-complexp type2))
		 (type= (specialized-element-type-maybe type1)
			(specialized-element-type-maybe type2)))
	    t)))

(define-type-method (array :unparse) (type)
  (let ((dims (array-ctype-dimensions type))
	  (eltype (type-specifier (array-ctype-element-type type)))
	  (complexp (array-ctype-complexp type)))
    (cond ((eq dims '*)
	     (if (eq eltype '*)
	       (if complexp 'array 'simple-array)
	       (if complexp `(array ,eltype) `(simple-array ,eltype))))
	    ((= (length dims) 1) 
	     (if complexp
	       (if (eq (car dims) '*)
		   (case eltype
		     (bit 'bit-vector)
		     ((character base-char) 'base-string)
		     (* 'vector)
		     (t `(vector ,eltype)))
		   (case eltype
		     (bit `(bit-vector ,(car dims)))
		     ((character base-char) `(base-string ,(car dims)))
		     (t `(vector ,eltype ,(car dims)))))
	       (if (eq (car dims) '*)
		   (case eltype
		     (bit 'simple-bit-vector)
		     ((base-char character) 'simple-base-string)
		     ((t) 'simple-vector)
		     (t `(simple-array ,eltype (*))))
		   (case eltype
		     (bit `(simple-bit-vector ,(car dims)))
		     ((base-char character) `(simple-base-string ,(car dims)))
		     ((t) `(simple-vector ,(car dims)))
		     (t `(simple-array ,eltype ,dims))))))
	    (t
	     (if complexp
	       `(array ,eltype ,dims)
	       `(simple-array ,eltype ,dims))))))

(define-type-method (array :simple-subtypep) (type1 type2)
  (let ((dims1 (array-ctype-dimensions type1))
	(dims2 (array-ctype-dimensions type2))
	(complexp2 (array-ctype-complexp type2)))
    (cond (;; not subtypep unless dimensions are compatible
	   (not (or (eq dims2 '*)
		    (and (not (eq dims1 '*))
			 (= (length (the list dims1))
			    (length (the list dims2)))
			 (every (lambda (x y)
				  (or (eq y '*) (eql x y)))
				(the list dims1)
				(the list dims2)))))
	   (values nil t))
	  ;; not subtypep unless complexness is compatible
	  ((not (or (eq complexp2 :maybe)
		    (eq (array-ctype-complexp type1) complexp2)))
	   (values nil t))
	  ;; Since we didn't fail any of the tests above, we win
	  ;; if the TYPE2 element type is wild.
	  ((eq (array-ctype-element-type type2) *wild-type*)
	   (values t t))
	  (;; Since we didn't match any of the special cases above, we
	   ;; can't give a good answer unless both the element types
	   ;; have been defined.
	   (or (unknown-ctype-p (array-ctype-element-type type1))
	       (unknown-ctype-p (array-ctype-element-type type2)))
	   (values nil nil))
	  (;; Otherwise, the subtype relationship holds iff the
	   ;; types are equal, and they're equal iff the specialized
	   ;; element types are identical.
	   t
	   (values (type= (specialized-element-type-maybe type1)
			  (specialized-element-type-maybe type2))
		   t)))))

; (define-superclasses array (string string) (vector vector) (array))


(defun array-types-intersect (type1 type2)
  (declare (type array-ctype type1 type2))
  (let ((dims1 (array-ctype-dimensions type1))
	(dims2 (array-ctype-dimensions type2))
	(complexp1 (array-ctype-complexp type1))
	(complexp2 (array-ctype-complexp type2)))
    ;; See whether dimensions are compatible.
    (cond ((not (or (eq dims1 '*) (eq dims2 '*)
		    (and (= (length dims1) (length dims2))
			 (every (lambda (x y)
				  (or (eq x '*) (eq y '*) (= x y)))
				dims1 dims2))))
	   (values nil t))
	  ;; See whether complexpness is compatible.
	  ((not (or (eq complexp1 :maybe)
		    (eq complexp2 :maybe)
		    (eq complexp1 complexp2)))
	   (values nil t))
	  ((or (eq (array-ctype-specialized-element-type type1) *wild-type*)
	       (eq (array-ctype-specialized-element-type type2) *wild-type*)
	       (type= (specialized-element-type-maybe type1)
		      (specialized-element-type-maybe type2)))
	   (values t t))
	  (t
	   (values nil t)))))

(define-type-method (array :simple-intersection) (type1 type2)
  (declare (type array-ctype type1 type2))
  (if (array-types-intersect type1 type2)
    (let ((dims1 (array-ctype-dimensions type1))
          (dims2 (array-ctype-dimensions type2))
          (complexp1 (array-ctype-complexp type1))
          (complexp2 (array-ctype-complexp type2))
          (eltype1 (array-ctype-element-type type1))
          (eltype2 (array-ctype-element-type type2)))
      (specialize-array-type
       (make-array-ctype
        :dimensions (cond ((eq dims1 '*) dims2)
                          ((eq dims2 '*) dims1)
                          (t
                           (mapcar #'(lambda (x y) (if (eq x '*) y x))
                                   dims1 dims2)))
        :complexp (if (eq complexp1 :maybe) complexp2 complexp1)
        :element-type (cond
                        ((eq eltype1 *wild-type*) eltype2)
                        ((eq eltype2 *wild-type*) eltype1)
                        (t (type-intersection eltype1 eltype2))))))
      *empty-type*))

;;; Check-Array-Dimensions  --  Internal
;;;
;;;    Check a supplied dimension list to determine if it is legal.
;;;
(defun check-array-dimensions (dims)
  (typecase dims
    ((member *) dims)
    (integer
     (when (minusp dims)
       (signal-program-error "Arrays can't have a negative number of dimensions: ~D." dims))
     (when (>= dims array-rank-limit)
       (signal-program-error "Array type has too many dimensions: ~S." dims))
     (make-list dims :initial-element '*))
    (list
     (when (>= (length dims) array-rank-limit)
       (signal-program-error "Array type has too many dimensions: ~S." dims))
     (dolist (dim dims)
       (unless (eq dim '*)
	   (unless (and (integerp dim)
		          (>= dim 0) (< dim array-dimension-limit))
	     (signal-program-error "Bad dimension in array type: ~S." dim))))
     dims)
    (t
     (signal-program-error "Array dimensions is not a list, integer or *:~%  ~S"
			   dims))))

(def-type-translator array (&optional element-type dimensions &environment env)
  (specialize-array-type
   (make-array-ctype :dimensions (check-array-dimensions dimensions)
		     :complexp :maybe
		     :element-type (specifier-type element-type env))))

(def-type-translator simple-array (&optional element-type dimensions &environment env)
  (specialize-array-type
   (make-array-ctype :dimensions (check-array-dimensions dimensions)
		         :element-type (specifier-type element-type env)
		         :complexp nil)))

;;; Order matters here.
(defparameter specialized-array-element-types
  '(nil bit (unsigned-byte 8) (signed-byte 8) (unsigned-byte 16)
    (signed-byte 16) (unsigned-byte 32) #+32-bit-target fixnum (signed-byte 32)
    #+64-bit-target fixnum
    #+64-bit-target (unsigned-byte 64)
    #+64-bit-target (signed-byte 64)
    character  short-float double-float
    #||(complex short-float) (complex double-float)||#))

(defun specialize-array-type (type)
  (let* ((eltype (array-ctype-element-type type))
         (specialized-type (if (eq eltype *wild-type*)
                             *wild-type*
                             (dolist (stype-name specialized-array-element-types
                                      *universal-type*)
                               (let ((stype (specifier-type stype-name)))
                                 (when (csubtypep eltype stype)
                                   (return stype)))))))
    
    (setf (array-ctype-specialized-element-type type) specialized-type
          (array-ctype-typecode type) (unless (eq specialized-type *wild-type*)
                                        (ctype-subtype specialized-type)))
    type))


;;;; Member types.

;;; The Member-Type represents uses of the MEMBER type specifier.  We bother
;;; with this at this level because MEMBER types are fairly important and union
;;; and intersection are well defined.

(defun %make-member-ctype (members)
  (%istruct 'member-ctype
            (type-class-or-lose 'member)
            t
            members))

(defun make-member-ctype (&key members)
  (let* ((singlep (subsetp '(-0.0f0 0.0f0) members))
	 (doublep (subsetp '(-0.0d0 0.0d0) members))
	 (union-types
	  (if singlep
	    (if doublep
	      (list *ctype-of-single-float-0* *ctype-of-double-float-0*)
	      (list *ctype-of-single-float-0*))
	    (if doublep
	      (list *ctype-of-double-float-0*)))))
    (if union-types
      (progn
	(if singlep
	  (setq members (set-difference '(-0.0f0 0.0f0) members)))
	(if doublep
	  (setq members (set-difference '(-0.d00 0.0d0) members)))
	(make-union-ctype (if (null members)
			    union-types
			    (cons (%make-member-ctype members) union-types))))
      (%make-member-ctype members))))
	

(defun member-ctype-p (x) (istruct-typep x 'member-ctype))
(setf (type-predicate 'member-ctype) 'member-ctype-p)

(define-type-method (member :unparse) (type)
  (if (type= type (specifier-type 'standard-char))
    'standard-char
    (let ((members (member-ctype-members type)))
      (if (equal members '(nil))
	'null
	`(member ,@members)))))

(define-type-method (member :simple-subtypep) (type1 type2)
  (values (subsetp (member-ctype-members type1) (member-ctype-members type2))
	    t))


(define-type-method (member :complex-subtypep-arg1) (type1 type2)
  (every/type (swapped-args-fun #'ctypep)
	      type2
	      (member-ctype-members type1)))

;;; We punt if the odd type is enumerable and intersects with the member type.
;;; If not enumerable, then it is definitely not a subtype of the member type.
;;;
(define-type-method (member :complex-subtypep-arg2) (type1 type2)
  (cond ((not (ctype-enumerable type1)) (values nil t))
	  ((types-intersect type1 type2)
	   (invoke-complex-subtypep-arg1-method type1 type2))
	  (t
	   (values nil t))))

(define-type-method (member :simple-intersection) (type1 type2)
  (let ((mem1 (member-ctype-members type1))
	(mem2 (member-ctype-members type2)))
    (values (cond ((subsetp mem1 mem2) type1)
		  ((subsetp mem2 mem1) type2)
		  (t
		   (let ((res (intersection mem1 mem2)))
		     (if res
		       (make-member-ctype :members res)
		       *empty-type*))))
	    t)))

(define-type-method (member :complex-intersection) (type1 type2)
  (block PUNT
    (collect ((members))
      (let ((mem2 (member-ctype-members type2)))
        (dolist (member mem2)
	  (multiple-value-bind (val win) (ctypep member type1)
	    (unless win
	      (return-from punt nil))
	    (when val (members member))))
	(cond ((subsetp mem2 (members)) type2)
	      ((null (members)) *empty-type*)
	      (t
	       (make-member-ctype :members (members))))))))

;;; We don't need a :COMPLEX-UNION, since the only interesting case is a union
;;; type, and the member/union interaction is handled by the union type
;;; method.
(define-type-method (member :simple-union) (type1 type2)
  (let ((mem1 (member-ctype-members type1))
	(mem2 (member-ctype-members type2)))
    (cond ((subsetp mem1 mem2) type2)
	  ((subsetp mem2 mem1) type1)
	  (t
	   (make-member-ctype :members (union mem1 mem2))))))


(define-type-method (member :simple-=) (type1 type2)
  (let ((mem1 (member-ctype-members type1))
	(mem2 (member-ctype-members type2)))
    (values (and (subsetp mem1 mem2) (subsetp mem2 mem1))
	    t)))

(define-type-method (member :complex-=) (type1 type2)
  (if (ctype-enumerable type1)
    (multiple-value-bind (val win)
			       (csubtypep type2 type1)
	(if (or val (not win))
        (values nil nil)
        (values nil t)))
    (values nil t)))

(def-type-translator member (&rest members)
  (if members
    (collect ((non-numbers) (numbers))
      (dolist (m (remove-duplicates members))
	(if (and (numberp m)
		 (not (and (floatp m) (zerop m))))
	  (numbers (ctype-of m))
	  (non-numbers m)))
      (apply #'type-union
	     (if (non-numbers)
	       (make-member-ctype :members (non-numbers))
	       *empty-type*)
	     (numbers)))
    *empty-type*))



;;;; Union types:

;;; The Union-Type represents uses of the OR type specifier which can't be
;;; canonicalized to something simpler.  Canonical form:
;;;
;;; 1] There is never more than one Member-Type component.
;;; 2] There are never any Union-Type components.
;;;

(defun make-union-ctype (types)
  (declare (list types))
  (%istruct 'union-ctype
            (type-class-or-lose 'union)
            (every #'(lambda (x) (ctype-enumerable x)) types)
            types))

(defun union-ctype-p (x) (istruct-typep x 'union-ctype))
(setf (type-predicate 'union-ctype) 'union-ctype-p)


;;;    If List, then return that, otherwise the OR of the component types.
;;;
(define-type-method (union :unparse) (type)
  (declare (type ctype type))
    (cond
      ((type= type (specifier-type 'list)) 'list)
      ((type= type (specifier-type 'float)) 'float)
      ((type= type (specifier-type 'real)) 'real)
      ((type= type (specifier-type 'sequence)) 'sequence)
      ((type= type (specifier-type 'bignum)) 'bignum)
      (t `(or ,@(mapcar #'type-specifier (union-ctype-types type))))))



(define-type-method (union :simple-=) (type1 type2)
  (multiple-value-bind (subtype certain?)
      (csubtypep type1 type2)
    (if subtype
      (csubtypep type2 type1)
      (if certain?
	(values nil t)
	(multiple-value-bind (subtype certain?)
	    (csubtypep type2 type1)
	  (declare (ignore subtype))
	  (values nil certain?))))))


(define-type-method (union :complex-=) (type1 type2)
  (declare (ignore type1))
  (if (some #'type-might-contain-other-types-p 
	    (union-ctype-types type2))
    (values nil nil)
    (values nil t)))


(defun union-simple-subtypep (type1 type2)
  (every/type (swapped-args-fun #'union-complex-subtypep-arg2)
	      type2
	      (union-ctype-types type1)))

(define-type-method (union :simple-subtypep) (type1 type2)
  (union-simple-subtypep type1 type2))

(defun union-complex-subtypep-arg1 (type1 type2)
  (every/type (swapped-args-fun #'csubtypep)
	      type2
	      (union-ctype-types type1)))

(define-type-method (union :complex-subtypep-arg1) (type1 type2)
  (union-complex-subtypep-arg1 type1 type2))

(defun union-complex-subtypep-arg2 (type1 type2)
  (multiple-value-bind (sub-value sub-certain?)
      (progn
	(assert (union-ctype-p type2))
	(assert (not (union-ctype-p type1)))
	(type= type1
	       (apply #'type-union
		      (mapcar (lambda (x) (type-intersection type1 x))
			      (union-ctype-types type2)))))
    (if sub-certain?
      (values sub-value sub-certain?)
      (invoke-complex-subtypep-arg1-method type1 type2))))

(define-type-method (union :complex-subtypep-arg2) (type1 type2)
  (union-complex-subtypep-arg2 type1 type2))

(define-type-method (union :simple-intersection :complex-intersection)
    (type1 type2)
  (assert (union-ctype-p type2))
  (cond ((and (union-ctype-p type1)
	      (union-simple-subtypep type1 type2)) type1)
	((and (union-ctype-p type1)
	      (union-simple-subtypep type2 type1)) type2)
	((and (not (union-ctype-p type1))
	      (union-complex-subtypep-arg2 type1 type2))
	 type1)
	((and (not (union-ctype-p type1))
	      (union-complex-subtypep-arg1 type2 type1))
	 type2)
	(t 
	 (let ((accumulator *empty-type*))
	   (dolist (t2 (union-ctype-types type2) accumulator)
	     (setf accumulator
		   (type-union accumulator
			       (type-intersection type1 t2))))))))



(def-type-translator or (&rest type-specifiers &environment env)
  (apply #'type-union
	 (mapcar #'(lambda (spec) (specifier-type spec env)) type-specifiers)))


;;; Intersection types
(defun make-intersection-ctype (enumerable types)
  (%istruct 'intersection-ctype
	    (type-class-or-lose 'intersection)
	    enumerable
	    types))

(defun intersection-ctype-p (x)
  (istruct-typep x 'intersection-ctype))
(setf (type-predicate 'intersection-ctype) 'intersection-ctype-p)

(define-type-method (intersection :unparse) (type)
  (declare (type ctype type))
  (or (find type '(ratio keyword) :key #'specifier-type :test #'type=)
      `(and ,@(mapcar #'type-specifier (intersection-ctype-types type)))))

;;; shared machinery for type equality: true if every type in the set
;;; TYPES1 matches a type in the set TYPES2 and vice versa
(defun type=-set (types1 types2)
  (flet (;; true if every type in the set X matches a type in the set Y
	 (type<=-set (x y)
	   (declare (type list x y))
	   (every (lambda (xelement)
		    (position xelement y :test #'type=))
		  x)))
    (values (and (type<=-set types1 types2)
		 (type<=-set types2 types1))
	    t)))

(define-type-method (intersection :simple-=) (type1 type2)
  (type=-set (intersection-ctype-types type1)
	     (intersection-ctype-types type2)))

(defun %intersection-complex-subtypep-arg1 (type1 type2)
  (type= type1 (type-intersection type1 type2)))

(defun %intersection-simple-subtypep (type1 type2)
  (every/type #'%intersection-complex-subtypep-arg1
	      type1
	      (intersection-ctype-types type2)))

(define-type-method (intersection :simple-subtypep) (type1 type2)
  (%intersection-simple-subtypep type1 type2))
  
(define-type-method (intersection :complex-subtypep-arg1) (type1 type2)
  (%intersection-complex-subtypep-arg1 type1 type2))

(defun %intersection-complex-subtypep-arg2 (type1 type2)
  (every/type #'csubtypep type1 (intersection-ctype-types type2)))

(define-type-method (intersection :complex-subtypep-arg2) (type1 type2)
  (%intersection-complex-subtypep-arg2 type1 type2))

(define-type-method (intersection :simple-union :complex-union)
    (type1 type2)
  (assert (intersection-ctype-p type2))
  (cond ((and (intersection-ctype-p type1)
	      (%intersection-simple-subtypep type1 type2)) type2)
	((and (intersection-ctype-p type1)
	      (%intersection-simple-subtypep type2 type1)) type1)
	((and (not (intersection-ctype-p type1))
	      (%intersection-complex-subtypep-arg2 type1 type2))
	 type2)
	((and (not (intersection-ctype-p type1))
	      (%intersection-complex-subtypep-arg1 type2 type1))
	 type1)
	((and (csubtypep type2 (specifier-type 'ratio))
	      (numeric-ctype-p type1)
	      (csubtypep type1 (specifier-type 'integer))
	      (csubtypep type2
			 (make-numeric-ctype
			  :class 'rational
			  :complexp nil
			  :low (if (null (numeric-ctype-low type1))
				 nil
				 (list (1- (numeric-ctype-low type1))))
			  :high (if (null (numeric-ctype-high type1))
				  nil
				  (list (1+ (numeric-ctype-high type1)))))))
	 (type-union type1
		     (apply #'type-intersection
			    (remove (specifier-type '(not integer))
				    (intersection-ctype-types type2)
				    :test #'type=))))
	(t
	 (let ((accumulator *universal-type*))
	   (do ((t2s (intersection-ctype-types type2) (cdr t2s)))
	       ((null t2s) accumulator)
	     (let ((union (type-union type1 (car t2s))))
	       (when (union-ctype-p union)
		 (if (and (eq accumulator *universal-type*)
			  (null (cdr t2s)))
		     (return union)
		     (return nil)))
	       (setf accumulator
		     (type-intersection accumulator union))))))))

(def-type-translator and (&rest type-specifiers &environment env)
  (apply #'type-intersection
	 (mapcar #'(lambda (spec) (specifier-type spec env))
		 type-specifiers)))

;;; cons-ctype
(defun wild-ctype-to-universal-ctype (c)
  (if (type= c *wild-type*)
    *universal-type*
    c))

(defun make-cons-ctype (car-ctype-value cdr-ctype-value)
  (if (or (eq car-ctype-value *empty-type*)
	  (eq cdr-ctype-value *empty-type*))
    *empty-type*
    (%istruct 'cons-ctype
	      (type-class-or-lose 'cons)
	      nil
	      (wild-ctype-to-universal-ctype car-ctype-value)
	      (wild-ctype-to-universal-ctype cdr-ctype-value))))

(defun cons-ctype-p (x)
  (istruct-typep x 'cons-ctype))

(setf (type-predicate 'cons-ctype) 'cons-ctype-p)
  
(def-type-translator cons (&optional (car-type-spec '*) (cdr-type-spec '*) &environment env)
  (make-cons-ctype (specifier-type car-type-spec env)
                   (specifier-type cdr-type-spec env)))

(define-type-method (cons :unparse) (type)
  (let* ((car-spec (type-specifier (cons-ctype-car-ctype type)))
         (cdr-spec (type-specifier (cons-ctype-cdr-ctype type))))
    (if (and (member car-spec '(t *))
             (member cdr-spec '(t *)))
      'cons
      `(cons ,car-spec ,cdr-spec))))

(define-type-method (cons :simple-=) (type1 type2)
  (declare (cons-ctype type1 type2))
  (and (type= (cons-ctype-car-ctype type1) (cons-ctype-car-ctype type2))
       (type= (cons-ctype-cdr-ctype type1) (cons-ctype-cdr-ctype type2))))

(define-type-method (cons :simple-subtypep) (type1 type2)
  (declare (cons-ctype type1 type2))
  (multiple-value-bind (val-car win-car)
      (csubtypep (cons-ctype-car-ctype type1) (cons-ctype-car-ctype type2))
    (multiple-value-bind (val-cdr win-cdr)
	(csubtypep (cons-ctype-cdr-ctype type1) (cons-ctype-cdr-ctype type2))
      (if (and val-car val-cdr)
	(values t (and win-car win-cdr))
	(values nil (or win-car win-cdr))))))

(define-type-method (cons :simple-union) (type1 type2)
  (declare (type cons-ctype type1 type2))
  (let ((car-type1 (cons-ctype-car-ctype type1))
	(car-type2 (cons-ctype-car-ctype type2))
	(cdr-type1 (cons-ctype-cdr-ctype type1))
	(cdr-type2 (cons-ctype-cdr-ctype type2))
        (car-not1)
        (car-not2))
    (macrolet ((frob-car (car1 car2 cdr1 cdr2
                          &optional (not1 nil not1p))
		 `(type-union
		   (make-cons-ctype ,car1 (type-union ,cdr1 ,cdr2))
		   (make-cons-ctype
		    (type-intersection
                     ,car2
                     ,(if not1p
                          not1
                          `(specifier-type
                            `(not ,(type-specifier ,car1))))) 
		    ,cdr2))))
      (cond ((type= car-type1 car-type2)
	     (make-cons-ctype car-type1
                              (type-union cdr-type1 cdr-type2)))
	    ((type= cdr-type1 cdr-type2)
	     (make-cons-ctype (type-union car-type1 car-type2)
			      cdr-type1))
	    ((csubtypep car-type1 car-type2)
	     (frob-car car-type1 car-type2 cdr-type1 cdr-type2))
	    ((csubtypep car-type2 car-type1)
	     (frob-car car-type2 car-type1 cdr-type2 cdr-type1))
            ;; more general case of the above, but harder to compute
            ((progn
               (setf car-not1 (specifier-type
                               `(not ,(type-specifier car-type1))))
               (not (csubtypep car-type2 car-not1)))
             (frob-car car-type1 car-type2 cdr-type1 cdr-type2 car-not1))
            ((progn
               (setf car-not2 (specifier-type
                               `(not ,(type-specifier car-type2))))
               (not (csubtypep car-type1 car-not2)))
             (frob-car car-type2 car-type1 cdr-type2 cdr-type1 car-not2))))))
	    
(define-type-method (cons :simple-intersection) (type1 type2)
  (declare (type cons-ctype type1 type2))
  (let ((car-int2 (type-intersection2 (cons-ctype-car-ctype type1)
				      (cons-ctype-car-ctype type2)))
	(cdr-int2 (type-intersection2 (cons-ctype-cdr-ctype type1)
				      (cons-ctype-cdr-ctype type2))))
    (cond ((and car-int2 cdr-int2)
	   (make-cons-ctype car-int2 cdr-int2))
	  (car-int2
	   (make-cons-ctype car-int2
			    (type-intersection (cons-ctype-cdr-ctype type1)
					       (cons-ctype-cdr-ctype type2))))
	  (cdr-int2
	   (make-cons-ctype (type-intersection (cons-ctype-car-ctype type1)
					       (cons-ctype-car-ctype type2))
			    cdr-int2)))))


;;; An UNKNOWN-TYPE is a type not known to the type system (not yet defined).
;;; We make this distinction since we don't want to complain about types that
;;; are hairy but defined.
;;;

(defun make-unknown-ctype (&key specifier (enumerable t))
  (%istruct 'unknown-ctype
            (type-class-or-lose 'hairy)
            enumerable
            specifier))

(defun unknown-ctype-p (x)
  (istruct-typep x 'unknown-ctype))

(setf (type-predicate 'unknown-ctype) 'unknown-ctype-p)





;;;; foreign-type types


(defun %make-foreign-ctype (foreign-type)
  (%istruct 'foreign-ctype
            (type-class-or-lose 'foreign)
            nil
            foreign-type))

(defun foreign-ctype-p (x) (istruct-typep x 'foreign-ctype))
(setf (type-predicate 'foreign-ctype) 'foreign-ctype-p)

(define-type-method (foreign :unparse) (type)
  `(foreign ,(unparse-foreign-type (foreign-ctype-foreign-type type))))

(define-type-method (foreign :simple-subtypep) (type1 type2)
  (values (foreign-subtype-p (foreign-ctype-foreign-type type1)
			           (foreign-ctype-foreign-type type2))
	    t))

;(define-superclasses foreign (foreign-value))

(define-type-method (foreign :simple-=) (type1 type2)
  (let ((foreign-type-1 (foreign-ctype-foreign-type type1))
	  (foreign-type-2 (foreign-ctype-foreign-type type2)))
    (values (or (eq foreign-type-1 foreign-type-2)
		    (foreign-type-= foreign-type-1 foreign-type-2))
	      t)))

(def-type-translator foreign (&optional (foreign-type nil))
  (typecase foreign-type
    (null
     (make-foreign-ctype))
    (foreign-type
     (make-foreign-ctype foreign-type))
    (t
     (make-foreign-ctype (parse-foreign-type foreign-type)))))

(defun make-foreign-ctype (&optional foreign-type)
  (if foreign-type
      (let ((lisp-rep-type (compute-lisp-rep-type foreign-type)))
	(if lisp-rep-type
	    (specifier-type lisp-rep-type)
	    (%make-foreign-ctype foreign-type)))
      *universal-type*))


;;; CLASS-CTYPES are supposed to help integrate CLOS and the CMU type system.
;;; They mostly just contain a backpointer to the CLOS class; the CPL is then
;;;  used to resolve type relationships.

(defun class-ctype-p (x) (istruct-typep x 'class-ctype))
(setf (type-predicate 'class-ctype) 'class-ctype-p)

(defun args-ctype-p (x) (and (eql (typecode x) target::subtag-istruct)
                             (member (istruct-type-name x)
                                     '(args-ctype values-ctype function-ctype))))

(setf (type-predicate 'args-ctype) 'args-ctype-p
      (type-predicate 'function-ctype) 'function-ctype-p
      (type-predicate 'values-ctype) 'values-ctype-p)


;;; Simple methods for TYPE= and SUBTYPEP should never be called when the two
;;; classes are equal, since there are EQ checks in those operations.
;;;
(define-type-method (class :simple-=) (type1 type2)
  (assert (not (eq type1 type2)))
  (values nil t))

(define-type-method (class :simple-subtypep) (type1 type2)
  (assert (not (eq type1 type2)))
  (let* ((class1 (if (class-ctype-p type1) (class-ctype-class type1)))
         (class2 (if (class-ctype-p type2) (class-ctype-class type2))))
    (if (and class1 class2)
      (let* ((ordinal2 (%class-ordinal class2))
             (wrapper1 (%class.own-wrapper class1))
             (bits1 (if wrapper1 (%wrapper-cpl-bits wrapper1))))
        (if bits1
          (locally (declare (simple-bit-vector bits1)
                            (optimize (speed 3) (safety 0)))
            (values (if (< ordinal2 (length bits1))
                      (not (eql 0 (sbit bits1 ordinal2))))
                    t))
          (if (%standard-instance-p class1)
            (if (memq class2 (%class.local-supers class1))
              (values t t)
              (if (eq (%class-of-instance class1)
                      *forward-referenced-class-class*)
                (values nil nil)
                ;; %INITED-CLASS-CPL will return NIL if class1 can't
                ;; be finalized; in that case, we don't know the answer.
                (let ((supers (%inited-class-cpl class1)))
                  (if (memq class2 supers)
                    (values t t)
                    (values nil (not (null supers)))))))
            (values nil t))))
      (values nil t))))

(defun find-class-intersection (c1 c2)
  (labels ((walk-subclasses (class f)
	     (dolist (sub (class-direct-subclasses class))
	       (walk-subclasses sub f))
	     (funcall f class)))
    (let* ((intersection nil))
      (walk-subclasses c1 #'(lambda (c)
			      (when (subclassp c c2)
				(pushnew (%class.ctype c) intersection))))
      (when intersection
	(%type-union intersection)))))

(define-type-method (class :simple-intersection) (type1 type2)
  (assert (not (eq type1 type2)))
  (let* ((class1 (if (class-ctype-p type1) (class-ctype-class type1)))
         (class2 (if (class-ctype-p type2) (class-ctype-class type2))))
    (if (and class1
             (not (typep class1 'compile-time-class))
             class2
             (not (typep class2 'compile-time-class)))
      (cond ((subclassp class1 class2)
             type1)
            ((subclassp class2 class1)
             type2)
	    ;;; In the STANDARD-CLASS case where neither's
	    ;;; a subclass of the other, there may be
	    ;;; one or mor classes that're a subclass of both.  We
	    ;;; -could- try to find all such classes, but
	    ;;; punt instead.
            (t (or (find-class-intersection class1 class2)
		 *empty-type*)))
      nil)))

(define-type-method (class :complex-subtypep-arg2) (type1 class2)
  (if (and (intersection-ctype-p type1)
	   (> (count-if #'class-ctype-p (intersection-ctype-types type1)) 1))
      (values nil nil)
      (if (function-ctype-p type1)
	(csubtypep (specifier-type 'function) class2)
	(invoke-complex-subtypep-arg1-method type1 class2 nil t))))

(define-type-method (class :complex-subtypep-arg1) (type1 type2)
  (if (and (function-ctype-p type2)
	   (eq type1 (specifier-type 'function))
	   (function-ctype-wild-args type2)
	   (eq *wild-type* (function-ctype-returns type2)))
      (values t t)
      (values nil t)))

(define-type-method (class :unparse) (type)
  (class-name (class-ctype-class type)))


;;; TYPE-DIFFERENCE  --  Interface
;;;
;;;    Return the type that describes all objects that are in X but not in Y.
;;; If we can't determine this type, then return NIL.
;;;
;;;    For now, we only are clever dealing with union and member types.  If
;;; either type is not a union type, then we pretend that it is a union of just
;;; one type.  What we do is remove from X all the types that are a subtype any
;;; type in Y.  If any type in X intersects with a type in Y but is not a
;;; subtype, then we give up.
;;;
;;;    We must also special-case any member type that appears in the union.  We
;;; remove from X's members all objects that are TYPEP to Y.  If Y has any
;;; members, we must be careful that none of those members are CTYPEP to any
;;; of Y's non-member types.  We give up in this case, since to compute that
;;; difference we would have to break the type from X into some collection of
;;; types that represents the type without that particular element.  This seems
;;; too hairy to be worthwhile, given its low utility.
;;;
(defun type-difference (x y)
  (let ((x-types (if (union-ctype-p x) (union-ctype-types x) (list x)))
	(y-types (if (union-ctype-p y) (union-ctype-types y) (list y))))
    (collect ((res))
      (dolist (x-type x-types)
	(if (member-ctype-p x-type)
	    (collect ((members))
	      (dolist (mem (member-ctype-members x-type))
		(multiple-value-bind (val win) (ctypep mem y)
		  (unless win (return-from type-difference nil))
		  (unless val
		    (members mem))))
	      (when (members)
		(res (make-member-ctype :members (members)))))
	    (dolist (y-type y-types (res x-type))
	      (multiple-value-bind (val win) (csubtypep x-type y-type)
		(unless win (return-from type-difference nil))
		(when val (return))
		(when (types-intersect x-type y-type)
		  (return-from type-difference nil))))))
      (let ((y-mem (find-if #'member-ctype-p y-types)))
	(when y-mem
	  (let ((members (member-ctype-members y-mem)))
	    (dolist (x-type x-types)
	      (unless (member-ctype-p x-type)
		(dolist (member members)
		  (multiple-value-bind (val win) (ctypep member x-type)
		    (when (or (not win) val)
		      (return-from type-difference nil)))))))))
      (apply #'type-union (res)))))

;;; CTypep  --  Interface
;;;
;;;    If Type is a type that we can do a compile-time test on, then return the
;;; whether the object is of that type as the first value and second value
;;; true.  Otherwise return NIL, NIL.
;;;
;;; We give up on unknown types, pick off FUNCTION and UNION types.  For
;;; structure types, we require that the type be defined in both the current
;;; and compiler environments, and that the INCLUDES be the same.
;;;
(defun ctypep (obj type)
  (declare (type ctype type))
  (etypecase type
    ((or numeric-ctype named-ctype member-ctype array-ctype cons-ctype)
     (values (%typep obj type) t))
    (class-ctype
     (values (not (null (class-typep  obj (class-ctype-class type)))) t)
)
    (union-ctype
     (any/type #'ctypep obj (union-ctype-types type)))
    (intersection-ctype
     (every/type #'ctypep obj (intersection-ctype-types type)))
    (function-ctype
     (values (functionp obj) t))
    (unknown-ctype
     (values nil nil))
    (foreign-ctype
     (values (foreign-typep obj (foreign-ctype-foreign-type type)) t))
    (negation-ctype
     (multiple-value-bind (res win)
	 (ctypep obj (negation-ctype-type type))
       (if win
	   (values (not res) t)
	   (values nil nil))))
    (hairy-ctype
     ;; Now the tricky stuff.
     (let* ((hairy-spec (hairy-ctype-specifier type))
	    (symbol (if (consp hairy-spec) (car hairy-spec) hairy-spec)))
       (ecase symbol
	 (and				; how would this get there ?
	  (if (atom hairy-spec)
	    (values t t)
	    (dolist (spec (cdr hairy-spec) (values t t))
	      (multiple-value-bind (res win)
		  (ctypep obj (specifier-type spec))
		(unless win (return (values nil nil)))
		(unless res (return (values nil t)))))))
	   (not				; how would this get there ?
	    (multiple-value-bind
	      (res win)
		(ctypep obj (specifier-type (cadr hairy-spec)))
	      (if win
		(values (not res) t)
		(values nil nil))))
	   (satisfies
	    (let ((fun (second hairy-spec)))
	      (cond ((and (symbolp fun) (fboundp fun))
                     ;; Binding *BREAK-ON-SIGNALS* here is a modularity
                     ;; violation intended to improve the signal-to-noise
                     ;; ratio on a mailing list.
		     (values (not (null (let* ((*break-on-signals* nil))
                                          (ignore-errors (funcall fun obj))))) t))
		    (t
		     (values nil nil))))))))))

;;; %TYPEP -- internal.
;;;
;;; The actual typep engine.  The compiler only generates calls to this
;;; function when it can't figure out anything more intelligent to do.
;;;
; lose 1 function call -MAYBE
(defun %typep (object specifier)
  (%%typep object
           (if (typep specifier 'ctype)
	     specifier
	     (specifier-type specifier))))

(eval-when (:compile-toplevel)
  (declaim (inline numeric-%%typep
                   array-%%typep
                   member-%%typep
                   cons-%%typep)))

(defun numeric-%%typep (object type)
  (let ((pred (numeric-ctype-predicate type)))
    (if pred
      (funcall pred object)
      (and (numberp object)
           (let ((num (if (complexp object) (realpart object) object)))
             (ecase (numeric-ctype-class type)
               (integer (integerp num))
               (rational (rationalp num))
               (float
                (ecase (numeric-ctype-format type)
                  (single-float (typep num 'single-float))
                  (double-float (typep num 'double-float))
                  ((nil) (floatp num))))
               ((nil) t)))
           (flet ((bound-test (val)
                    (let ((low (numeric-ctype-low type))
                          (high (numeric-ctype-high type)))
                      (and (cond ((null low) t)
                                 ((listp low) (> val (car low)))
                                 (t (>= val low)))
                           (cond ((null high) t)
                                 ((listp high) (< val (car high)))
                                 (t (<= val high)))))))
             (ecase (numeric-ctype-complexp type)
               ((nil) t)
               (:complex
                (and (complexp object)
                     (bound-test (realpart object))
                     (bound-test (imagpart object))))
               (:real
                (and (not (complexp object))
                     (bound-test object)))))))))

(defun array-%%typep (object type)
  (let* ((typecode (typecode object)))
    (declare (type (unsigned-byte 8) typecode))
    (and (array-typecode-p typecode)
         (ecase (array-ctype-complexp type)
           ((t) (not (simple-array-p object)))
           ((nil) (simple-array-p object))
           ((* :maybe) t))
         (let* ((ctype-dimensions (array-ctype-dimensions type)))
           (or (eq ctype-dimensions '*)
	       (if (eql typecode target::subtag-arrayH)
		   (let* ((rank (%svref object target::arrayH.rank-cell)))
		     (declare (fixnum rank))
		     (and (eql rank (length ctype-dimensions))
			  (do* ((i 0 (1+ i))
				(dim target::arrayH.dim0-cell (1+ dim))
				(want (array-ctype-dimensions type) (cdr want))
				(got (%svref object dim) (%svref object dim)))
			       ((eql i rank) t)
			    (unless (or (eq (car want) '*)
					(eql (%car want) (the fixnum got)))
			      (return nil)))))
		   (and (null (cdr ctype-dimensions))
			(or (eq (%car ctype-dimensions) '*)
			    (eql (%car ctype-dimensions)
                                 (if (eql typecode target::subtag-vectorH)
                                   (%svref object target::vectorH.physsize-cell)
                                   (uvsize object))))))))
	 (or (eq (array-ctype-element-type type) *wild-type*)
	     (eql (array-ctype-typecode type)
		  (if (> typecode target::subtag-vectorH)
                      typecode
                      (ldb target::arrayH.flags-cell-subtag-byte (the fixnum (%svref object target::arrayH.flags-cell)))))
	     (type= (array-ctype-specialized-element-type type)
		    (specifier-type (array-element-type object)))))))


(defun member-%%typep (object type)
  (not (null (member object (member-ctype-members type)))))

(defun cons-%%typep (object type) 
  (and (consp object)
       (%%typep (car object) (cons-ctype-car-ctype type))
       (%%typep (cdr object) (cons-ctype-cdr-ctype type)))) 


(defun %%typep (object type)
  ;(if (not (typep type 'ctype))(setq type (specifier-type type)))
  (locally (declare (type ctype type))
    (etypecase type
      (named-ctype
       (ecase (named-ctype-name type)
         ((* t) t)
         ((nil) nil)))
      (numeric-ctype
       (numeric-%%typep object type))
      (array-ctype
       (array-%%typep object type))
      (member-ctype
       (member-%%typep object type))
      (class-ctype
       (not (null (class-typep object (class-ctype-class type)))))
      (union-ctype
       (dolist (type (union-ctype-types type))
         (when (%%typep object type)
           (return t))))
      (intersection-ctype
       (dolist (type (intersection-ctype-types type) t)
         (unless (%%typep object type) (return nil))))
      (cons-ctype
       (cons-%%typep object type))
      (unknown-ctype
       ;; Parse it again to make sure it's really undefined.
       (let ((reparse (specifier-type (unknown-ctype-specifier type))))
         (if (typep reparse 'unknown-ctype)
           (error "Unknown type specifier: ~S"
                  (unknown-ctype-specifier reparse))
           (%%typep object reparse))))
      (negation-ctype
       (not (%%typep object (negation-ctype-type type))))
      (hairy-ctype
       ;; Now the tricky stuff.
       (let* ((hairy-spec (hairy-ctype-specifier type))
              (symbol (if (consp hairy-spec) (car hairy-spec) hairy-spec)))
         (ecase symbol
           (and
            (or (atom hairy-spec)
                (dolist (spec (cdr hairy-spec) t)
                  (unless (%%typep object (specifier-type spec))
                    (return nil)))))
           (not
            (unless (and (listp hairy-spec) (= (length hairy-spec) 2))
              (error "Invalid type specifier: ~S" hairy-spec))
            (not (%%typep object (specifier-type (cadr hairy-spec)))))
           (satisfies
            (unless (and (listp hairy-spec) (= (length hairy-spec) 2))
              (error "Invalid type specifier: ~S" hairy-spec))
            (let ((fn (cadr hairy-spec)))
              (if (funcall (typecase fn
                             (function fn)
                             (symbol (symbol-function fn))
                             (t
                              (coerce fn 'function)))
                           object)
                t
                nil))))))
      #|
    (foreign-ctype
     (foreign-typep object (foreign-ctype-foreign-type type)))
|#
      (function-ctype
       (error "Function types are not a legal argument to TYPEP:~%  ~S"
              (type-specifier type))))))


;;; Ctype-Of  --  Interface
;;;
;;;    Like Type-Of, only returns a Type structure instead of a type
;;; specifier.  We try to return the type most useful for type checking, rather
;;; than trying to come up with the one that the user might find most
;;; informative.
;;;

(defun float-format-name (x)
  (declare (float x))
  (etypecase x
    (single-float "SINGLE-FLOAT")
    (double-float "DOUBLE-FLOAT")))

(defun ctype-of-number (x)
  (let ((num (if (complexp x) (realpart x) x)))
    (multiple-value-bind (complexp low high)
	(if (complexp x)
	    (let ((imag (imagpart x)))
	      (values :complex (min num imag) (max num imag)))
	    (values :real num num))
      (make-numeric-ctype :class (etypecase num
				   (integer (if (complexp x)
                                                (if (integerp (imagpart x))
                                                    'integer
                                                    'rational)
                                                'integer))
				   (rational 'rational)
				   (float 'float))
			  :format (and (floatp num)
				       (if (typep num 'double-float)
					 'double-float
					 'single-float))
			  :complexp complexp
			  :low low
			  :high high))))

(defun ctype-of (x)
  (typecase x
    (function (specifier-type 'function)) ; GFs ..
    (symbol
     (make-member-ctype :members (list x)))
    (number (ctype-of-number x))
    (array
     (let ((etype (specifier-type (array-element-type x))))
       (make-array-ctype :dimensions (array-dimensions x)
			 :complexp (not (typep x 'simple-array))
			 :element-type etype
			 :specialized-element-type etype)))
    (t
     (%class.ctype (class-of x)))))

(defvar *ctype-of-double-float-0* (ctype-of 0.0d0))
(defvar *ctype-of-single-float-0* (ctype-of 0.0f0))




; These DEFTYPES should only happen while initializing.

(progn
(let-globally ((*type-system-initialized* nil))


(deftype bit () '(integer 0 1))

(deftype eql (val) `(member ,val))

(deftype signed-byte (&optional s)
  (cond ((eq s '*) 'integer)
	  ((and (integerp s) (> s 0))
	   (let ((bound (ash 1 (1- s))))
	     `(integer ,(- bound) ,(1- bound))))
	  (t
	   (signal-program-error "Bad size specified for SIGNED-BYTE type specifier: ~S." s))))
  
(deftype unsigned-byte (&optional s)
  (cond ((eq s '*) '(integer 0))
	((and (integerp s) (> s 0))
	 `(integer 0 ,(1- (ash 1 s))))
	(t
	 (error "Bad size specified for UNSIGNED-BYTE type specifier: ~S." s))))

(deftype vector (&optional element-type size)
  `(array ,element-type (,size)))

(deftype simple-vector (&optional size)
  `(simple-array t (,size)))

(deftype base-string (&optional size)
  `(array base-char (,size)))
(deftype simple-base-string (&optional size)
  `(simple-array base-char (,size)))



(deftype string (&optional size)
  `(array character (,size)))

(deftype simple-string (&optional size)
  `(simple-array character (,size)))

(deftype bit-vector (&optional size)
  `(array bit (,size)))

(deftype simple-bit-vector (&optional size)
  `(simple-array bit (,size)))

; TYPE-OF sometimes returns random symbols that aren't really type specifiers.

(deftype simple-unsigned-word-vector (&optional size)
  `(simple-array (unsigned-byte 16) (,size)))

(deftype simple-unsigned-byte-vector (&optional size)
  `(simple-array (unsigned-byte 8) (,size)))

(deftype simple-unsigned-long-vector (&optional size)
  `(simple-array (unsigned-byte 32) (,size)))

(deftype simple-signed-word-vector (&optional size)
  `(simple-array (signed-byte 16) (,size)))

(deftype simple-signed-byte-vector (&optional size)
  `(simple-array (signed-byte 8) (,size)))

(deftype simple-signed-long-vector (&optional size)
  `(simple-array (signed-byte 32) (,size)))



(deftype simple-short-float-vector (&optional size)
  `(simple-array short-float (,size)))

(deftype unsigned-word-vector (&optional size)
  `(vector (unsigned-byte 16) ,size))

(deftype single-float-vector (&optional size)
  `(vector short-float ,size))

(deftype unsigned-byte-vector (&optional size)
  `(vector (unsigned-byte 8) ,size))

(deftype unsigned-long-vector (&optional size)
  `(vector (unsigned-byte 32) ,size))

(deftype long-float-vector (&optional size)
  `(vector double-float ,size))

(deftype long-vector (&optional size)
  `(vector (signed-byte 32) ,size))

(deftype double-float-vector (&optional size)
  `(vector double-float ,size))

(deftype byte-vector (&optional size)
  `(vector (signed-byte 8) ,size))

(deftype general-vector (&optional size)
  `(vector t ,size))

(deftype word-vector (&optional size)
  `(vector (signed-byte 16) ,size))

(deftype short-float-vector (&optional size)
  `(vector single-float ,size))

(deftype simple-1d-array (&optional size)
  `(simple-array * (,size)))

(deftype simple-long-vector (&optional size)
  `(simple-array (signed-byte 32) (,size)))

(deftype simple-word-vector (&optional size)
  `(simple-array (signed-byte 16) (,size)))

(deftype simple-short-float-vector (&optional size)
  `(simple-array single-float (,size)))

(deftype simple-byte-vector (&optional size)
  `(simple-array (signed-byte 8) (,size)))

(deftype simple-double-float-vector (&optional size)
  `(simple-array double-float (,size)))

(deftype simple-single-float-vector (&optional size)
  `(simple-array single-float (,size)))

(deftype simple-long-float-vector (&optional size)
  `(simple-array double-float (,size)))

(deftype simple-fixnum-vector (&optional size)
  `(simple-array fixnum (,size)))

(deftype fixnum-vector (&optional size)
  `(array fixnum (,size)))

#+64-bit-target
(deftype simple-doubleword-vector (&optional size)
  `(simple-array (signed-byte 64) (,size)))

#+64-bit-target
(deftype simple-unsigned-doubleword-vector (&optional size)
  `(simple-array (unsigned-byte 64) (,size)))


(deftype short-float (&optional low high)
  `(single-float ,low ,high))

(deftype long-float (&optional low high)
  `(double-float ,low ,high))

#||
;;; As empty a type as you're likely to find ...
(deftype extended-char ()
  "Type of CHARACTERs that aren't BASE-CHARs."
  nil)
||#

(deftype natural ()
  `(unsigned-byte ,target::nbits-in-word))

(deftype signed-natural ()
  `(signed-byte ,target::nbits-in-word))
)



(let* ((builtin-translations 
        `((array . array)
          (simple-array . simple-array)
          (cons . cons)
          (vector . vector)
          (null . (member nil))
          (list . (or cons null))
          (sequence . (or list vector))
          (simple-vector . simple-vector)
          (bit-vector . bit-vector)
          (simple-bit-vector . simple-bit-vector)
          (simple-string . simple-string)
          (simple-base-string . simple-base-string)
          (string . string)
          (base-string . base-string)
          (real . real)
          (complex . complex)
          (float . float)
          (double-float . double-float)
          (long-float . double-float)
          (single-float . single-float)
	  (short-float . single-float)

          (rational . rational)
          (integer . integer)
          (ratio . (and rational (not integer)))
          (fixnum . (integer ,target::target-most-negative-fixnum
                     ,target::target-most-positive-fixnum))
          (bignum . (or (integer * (,target::target-most-negative-fixnum))
                         (integer (,target::target-most-positive-fixnum) *)))
          
          )))
  (dolist (spec builtin-translations)
    (setf (info-type-kind (car spec)) :primitive
          (info-type-builtin (car spec)) (specifier-type (cdr spec)))))





       

(precompute-types '((mod 2) (mod 4) (mod 16) (mod #x100) (mod #x10000)
                    #-cross-compiling
		    (mod #x100000000)
		    (unsigned-byte 1) 
		    (unsigned-byte 8) (unsigned-byte 16) (unsigned-byte 32)
                    (unsigned-byte 64)
		    (signed-byte 8) (signed-byte 16) (signed-byte 32)
                    (signed-byte 64)
                    (or function symbol)
                    (complex single-float)
                    (complex double-float)
                    ))


(precompute-types *cl-types*)

;;; Treat CHARACTER and BASE-CHAR as equivalent.
(setf (info-type-builtin 'character) (info-type-builtin 'base-char))
;;; And EXTENDED-CHAR as empty.
(setf (info-type-builtin 'extended-char) *empty-type*)

(defparameter *null-type* (specifier-type 'null))


(flet ((set-builtin-class-type-translation (thing)
         (let* ((class-name (if (atom thing) thing (car thing)))
                (spec (if (atom thing) thing (cadr thing)))
                (spectype (specifier-type spec)))
           (setf (class-ctype-translation
                  (%class.ctype (find-class class-name))) spectype))))
  (mapc #'set-builtin-class-type-translation
        '(
          ;; Root Of All Evil
          t
          ;; Numbers:
          number real ratio complex (complex-single-float (complex single-float))
          (complex-double-float (complex double-float))
          rational fixnum
          ;;  Integers:
          signed-byte  unsigned-byte bit bignum integer
          ;;  Floats
           float  double-float single-float
          ;; Arrays
          array
          ;;  Simple Arrays
          simple-array
          ;;  Vectors
          vector string base-string bit-vector
          unsigned-byte-vector unsigned-word-vector unsigned-long-vector
          byte-vector word-vector long-vector
          single-float-vector double-float-vector
          general-vector
          fixnum-vector
          #+64-bit-target
          doubleword-vector
          #+64-bit-target
          unsigned-doubleword-vector
          ;;   Simple 1-Dimensional Arrays
          simple-1d-array  simple-string simple-base-string simple-bit-vector
          simple-unsigned-byte-vector
          simple-unsigned-long-vector
          simple-unsigned-word-vector
          simple-byte-vector
          simple-word-vector
          simple-long-vector 
          simple-single-float-vector 
          simple-double-float-vector
          simple-vector
          simple-fixnum-vector
          #+64-bit-target
          simple-doubleword-vector
          #+64-bit-target
          simple-unsigned-doubleword-vector
          ;; Sequence types
          sequence list  cons null
          
           )
                                                         
        )))

(setq specialized-array-element-types
      (append specialized-array-element-types
              '((complex short-float) (complex double-float))))
;(setq *type-system-initialized* t)




; These deftypes help the CMUCL compiler; the type system doesn't depend on them.

;;; Since Clozure CL's DEFTYPE tries to globally define the type
;;; at compile-time as well as load- and execute time, hide
;;; the definition of these "built-in" types.  (It'd be cleaner
;;; to make DEFTYPE do something saner at compile-time.)
(let* ()                                ; make the following be non-toplevel
(deftype boolean () '(member t nil))

(deftype atom () '(not cons))
;;;
;;; A type specifier.
(deftype type-specifier () '(or list symbol class))
;;;
;;; An index into an array.   Also used for sequence index. 
(deftype index () `(integer 0 (,array-dimension-limit)))
;;;
;;; Array rank, total size...
(deftype array-rank () `(integer 0 (,array-rank-limit)))
(deftype array-total-size () `(integer 0 (,array-total-size-limit)))
;;;
;;; Some thing legal in an evaluated context.
(deftype form () t)
;;;
;;; Maclisp compatibility...
(deftype stringlike () '(or string symbol))
(deftype stringable () '(or string symbol character))
;;;
;;; Save a little typing...
(deftype truth () '(member t))
;;;
;;; A thing legal in places where we want the name of a file.
(deftype filename () '(or string pathname))
;;;
;;; A legal arg to pathname functions.
(deftype pathnamelike () '(or string pathname stream))
;;;
;;; A thing returned by the irrational functions.  We assume that they never
;;; compute a rational result.
(deftype irrational () '(or float (complex float)))
;;;
;;; Character components:
(deftype char-code () `(integer 0 (,char-code-limit)))
;;;
;;; A consed sequence result.  If a vector, is a simple array.
(deftype consed-sequence () '(or list (simple-array * (*))))
;;;
;;; The :end arg to a sequence...
(deftype sequence-end () '(or null index))
;;;
;;; A valid argument to a stream function...
(deftype streamlike () '(or stream (member nil t)))
;;;
;;; A thing that can be passed to funcall & friends.
(deftype callable () '(or function symbol))

;;; Until we decide if and how to wedge this into the type system, make it
;;; equivalent to t.
;;;
(deftype void () t)
;;;
;;; An index into an integer.
(deftype bit-index () `(integer 0 ,target::target-most-positive-fixnum))
;;;
;;; Offset argument to Ash (a signed bit index).
(deftype ash-index () 'fixnum)

;;; Not sure how to do this without SATISFIES.
(deftype setf-function-name () `(satisfies setf-function-name-p))

;;; Better than nothing, arguably.
(deftype function-name () `(or symbol setf-function-name))

(deftype valid-char-code () `(satisfies valid-char-code-p))

)                                       ; end of LET* sleaze

(defun array-or-union-ctype-element-type (ctype)
  (if (typep ctype 'array-ctype)
    (type-specifier (array-ctype-element-type ctype))
    (if (typep ctype 'union-ctype)
      `(or ,@(mapcar #'array-or-union-ctype-element-type 
                     (union-ctype-types ctype))))))


(defvar *simple-predicate-function-prototype*
  #'(lambda (thing)
      (%%typep thing #.(specifier-type t))))

(defun make-simple-type-predicate (function datum)
  #+ppc-target
  (gvector :function
           (uvref *simple-predicate-function-prototype* 0)
           datum
           function
           nil
           (dpb 1 $lfbits-numreq 0))
  #+arm-target
  (%fix-fn-entrypoint
   (gvector :function
           0
           (uvref *simple-predicate-function-prototype* 1)
           datum
           function
           nil
           (dpb 1 $lfbits-numreq 0)))
  #+x86-target
  (%clone-x86-function
   *simple-predicate-function-prototype*
   datum
   function
   nil
   (dpb 1 $lfbits-numreq 0)))

(defun check-ctypep (thing ctype)
  (multiple-value-bind (win sure) (ctypep thing ctype)
    (or win (not sure))))


(defun generate-predicate-for-ctype (ctype)
  (typecase ctype
    (numeric-ctype
     (or (numeric-ctype-predicate ctype)
         (make-simple-type-predicate 'numeric-%%typep ctype)))
    (array-ctype
     (make-simple-type-predicate 'array-%%typep ctype))
    (member-ctype
     (make-simple-type-predicate 'member-%%typep ctype))
    (named-ctype
     (case (named-ctype-name ctype)
       ((* t) #'true)
       (t #'false)))
    (cons-ctype
     (make-simple-type-predicate 'cons-%%typep ctype))
    (function-ctype
     #'functionp)
    (class-ctype
     (make-simple-type-predicate 'class-cell-typep (find-class-cell (class-name (class-ctype-class ctype)) t)))
    (t
     (make-simple-type-predicate 'check-ctypep ctype))))
    
        

   

;;; Ensure that standard EFFECTIVE-SLOT-DEFINITIONs have a meaningful
;;; type predicate, if we can.
(defmethod shared-initialize :after ((spec effective-slot-definition)
				     slot-names
				     &key 
				     &allow-other-keys)
  (declare (ignore slot-names))
  (let* ((type (slot-definition-type spec)))
    (setf (slot-value spec 'type-predicate)
	  (or (and (typep type 'symbol)
                   (not (eq type 't))
		   (type-predicate type))
              (handler-case
                  (let* ((ctype (specifier-type type)))
                    (unless (eq ctype *universal-type*)
                      (generate-predicate-for-ctype ctype)))
                (program-error ()
                  (warn "Invalid type specifier ~s in slot definition for ~s in class ~s." type (slot-definition-name spec) (slot-definition-class spec))
                  (lambda (v)
                    (cerror "Allow the assignment or initialization."
                            "Can't determine whether or not the value ~s should be used to initialize or assign to the slot ~&named ~s in an instance of ~s, because the slot is declared ~&to be of the invalid type ~s."
                            v (slot-definition-name spec) (slot-definition-class spec) (slot-definition-type spec))
                    ;; Suppress further checking, at least for things that use this effective slotd.
                    ;; (It's hard to avoid this, and more trouble than it's worth to do better.)
                    (setf (slot-value spec 'type-predicate) nil)
                    t))
                (parse-unknown-type (c)
                   (declare (ignore c))
                   #'(lambda (value)
                       ;; If the type's now known, install a new predicate.
                       (let* ((nowctype (specifier-type type)))
                         (unless (typep nowctype 'unknown-ctype)
                           (setf (slot-value spec 'type-predicate)
                                 (generate-predicate-for-ctype nowctype)))
                         (multiple-value-bind (win sure)
                             (ctypep value nowctype)
                           (or (not sure) win))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-typesys.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/ppc-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Support for PPC traps, this includes the event-poll trap
;;; and all the trxxx traps for type checks & arg count checks.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
  (require "NUMBER-MACROS")

  
  (defparameter *ppc-instruction-fields*
    `((:opcode . ,(byte 6 26))
      (:rt . ,(byte 5 21))
      (:to . ,(byte 5 21))
      (:ra . ,(byte 5 16))
      (:rb . ,(byte 5 11))
      (:d . ,(byte 16 0))
      (:ds . ,(byte 14 2))
      (:ds-xo . ,(byte 2 0))
      (:sh . ,(byte 5 11))
      (:mb . ,(byte 5 6))
      (:me . ,(byte 5 1))
      (:mb6 . ,(byte 6 5))
      (:me6 . ,(byte 6 5))
      (:sh6 . ,(byte 1 1))
      (:x-minor . ,(byte 10 1))
      (:fulltag32 . ,(byte ppc32::ntagbits 0))
      (:lisptag32 . ,(byte ppc32::nlisptagbits 0))
      (:fulltag64 . ,(byte ppc64::ntagbits 0))
      (:lisptag64 . ,(byte ppc64::nlisptagbits 0))
      (:lowtag64 . ,(byte ppc64::nlowtagbits 0))))
  
  (defun ppc-instruction-field (field-name)
    (or (cdr (assoc field-name *ppc-instruction-fields*))
	(error "Unknown PPC instruction field: ~s" field-name)))
  
  (defun ppc-instruction-field-mask (field-spec)
    (let* ((name (if (atom field-spec) field-spec (car field-spec)))
	   (value (if (atom field-spec) -1 (cadr field-spec))))
      (dpb value (ppc-instruction-field name) 0)))

  #+darwinppc-target
  (progn
    (def-foreign-type nil
        (:struct :darwin-ppc-float-state
                 (:fpregs (:array :double 32))
                 (:fpscr-pad (:unsigned 32))
                 (:fpscr (:unsigned 32))))
    (def-foreign-type nil
        (:struct :darwin-ppc-vector-state
                 (:save-vr (:array (:array (:unsigned 32) 4) 32))
                 (:save-vscr (:array (:unsigned 32) 4))
                 (:save-pad5 (:array (:unsigned 32) 4))
                 (:save-vrvalid (:unsigned 32))
                 (:save-pad6 (:array (:unsigned 32) 7))))
    #+ppc64-target
    (progn
      (def-foreign-type nil
          (:struct :darwin-ppc-exception-state64
                   (:dar (:unsigned 64))
                   (:dsisr (:unsigned 32))
                   (:exception (:unsigned 32))
                   (:pad1 (:array (:unsigned 32) 4))))
      (def-foreign-type nil
          ;; The real record type is defined with
          ;; #pragma pack(4) in effect.
          ;; The :struct parser should really accept
          ;; some option to deal with that, but Apple
          ;; should also stop mis-aligning things.
          (:struct :darwin-ppc-thread-state64
                   (:srr0 (:unsigned 64))
                   (:srr1 (:unsigned 64))
                   (:r0  (:unsigned 64))
                   (:r1  (:unsigned 64))
                   (:r2  (:unsigned 64))
                   (:r3  (:unsigned 64))
                   (:r4  (:unsigned 64))
                   (:r5  (:unsigned 64))
                   (:r6  (:unsigned 64))
                   (:r7  (:unsigned 64))
                   (:r8  (:unsigned 64))
                   (:r9  (:unsigned 64))
                   (:r10  (:unsigned 64))
                   (:r11  (:unsigned 64))
                   (:r12 (:unsigned 64))
                   (:r13  (:unsigned 64))
                   (:r14  (:unsigned 64))
                   (:r15  (:unsigned 64))
                   (:r16  (:unsigned 64))
                   (:r17  (:unsigned 64))
                   (:r18  (:unsigned 64))
                   (:r19  (:unsigned 64))
                   (:r20  (:unsigned 64))
                   (:r21  (:unsigned 64))
                   (:r22  (:unsigned 64))
                   (:r23  (:unsigned 64))
                   (:r24  (:unsigned 64))
                   (:r25  (:unsigned 64))
                   (:r26  (:unsigned 64))
                   (:r27  (:unsigned 64))
                   (:r28  (:unsigned 64))
                   (:r29  (:unsigned 64))
                   (:r30  (:unsigned 64))
                   (:r31  (:unsigned 64))
                   (:cr   (:unsigned 32))
                   (:xer  (:unsigned 32))
                   (:xer-low (:unsigned 32))
                   (:lr   (:unsigned 32))
                   (:lr-low (:unsigned 32))
                   (:ctr  (:unsigned 32))
                   (:ctr-low (:unsigned 32))
                   (:vrsave (:unsigned 32))))
      (def-foreign-type nil
          (:struct :darwin-sigaltstack64
                   (:ss-sp (:* :void))
                   (:ss-size (:unsigned 64))
                   (:ss-flags (:unsigned 32))))
      (def-foreign-type nil
          (:struct :darwin-mcontext64
                   (:es (:struct :darwin-ppc-exception-state64))
                   (:ss (:struct :darwin-ppc-thread-state64))
                   (:fs (:struct :darwin-ppc-float-state))
                   (:vs (:struct :darwin-ppc-vector-state))))
      (def-foreign-type nil
          (:struct :darwin-ucontext64
                   (:uc-onstack (:signed 32))
                   (:uc-sigmask (:signed 32))
                   (:uc-stack (:struct :darwin-sigaltstack64))
                   (:uc-link (:* (:struct :darwin-ucontext64)))
                   (:uc-mcsize (:signed 64))
                   (:uc-mcontext64 (:* (:struct :darwin-mcontext64)))))
      )
    #+ppc32-target
    (progn
      (def-foreign-type nil
          (:struct :darwin-ppc-exception-state32
                   (:dar (:unsigned 32))
                   (:dsisr (:unsigned 32))
                   (:exception (:unsigned 32))
                   (:pad0 (:unsigned 32))
                   (:pad1 (:array (:unsigned 32) 4))))
      (def-foreign-type nil
          (:struct :darwin-ppc-thread-state32
                   (:srr0 (:unsigned 32))
                   (:srr1 (:unsigned 32))
                   (:r0  (:unsigned 32))
                   (:r1  (:unsigned 32))
                   (:r2  (:unsigned 32))
                   (:r3  (:unsigned 32))
                   (:r4  (:unsigned 32))
                   (:r5  (:unsigned 32))
                   (:r6  (:unsigned 32))
                   (:r7  (:unsigned 32))
                   (:r8  (:unsigned 32))
                   (:r9  (:unsigned 32))
                   (:r10  (:unsigned 32))
                   (:r11  (:unsigned 32))
                   (:r12 (:unsigned 32))
                   (:r13  (:unsigned 32))
                   (:r14  (:unsigned 32))
                   (:r15  (:unsigned 32))
                   (:r16  (:unsigned 32))
                   (:r17  (:unsigned 32))
                   (:r18  (:unsigned 32))
                   (:r19  (:unsigned 32))
                   (:r20  (:unsigned 32))
                   (:r21  (:unsigned 32))
                   (:r22  (:unsigned 32))
                   (:r23  (:unsigned 32))
                   (:r24  (:unsigned 32))
                   (:r25  (:unsigned 32))
                   (:r26  (:unsigned 32))
                   (:r27  (:unsigned 32))
                   (:r28  (:unsigned 32))
                   (:r29  (:unsigned 32))
                   (:r30  (:unsigned 32))
                   (:r31  (:unsigned 32))
                   (:cr   (:unsigned 32))
                   (:xer  (:unsigned 32))
                   (:lr   (:unsigned 32))
                   (:ctr  (:unsigned 32))
                   (:mq (:unsigned 32)) ; ppc 601!
                   (:vrsave (:unsigned 32))))
      (def-foreign-type nil
          (:struct :darwin-sigaltstack32
                   (:ss-sp (:* :void))
                   (:ss-size (:unsigned 32))
                   (:ss-flags (:unsigned 32))))
      (def-foreign-type nil
          (:struct :darwin-mcontext32
                   (:es (:struct :darwin-ppc-exception-state32))
                   (:ss (:struct :darwin-ppc-thread-state32))
                   (:fs (:struct :darwin-ppc-float-state))
                   (:vs (:struct :darwin-ppc-vector-state))))
      (def-foreign-type nil
          (:struct :darwin-ucontext32
                   (:uc-onstack (:signed 32))
                   (:uc-sigmask (:signed 32))
                   (:uc-stack (:struct :darwin-sigaltstack32))
                   (:uc-link (:* (:struct :darwin-ucontext32)))
                   (:uc-mcsize (:signed 32))
                   (:uc-mcontext32 (:* (:struct :darwin-mcontext32)))))
      )
    )
      
                   
            

  (defmacro with-xp-registers-and-gpr-offset ((xp register-number) (registers offset) &body body)
    (let* ((regform  #+linuxppc-target
                     `(pref ,xp :ucontext.uc_mcontext.regs)
                     #+darwinppc-target
                     (target-arch-case
                      ;; Gak.  Apple gratuitously renamed things
                      ;; for Leopard.  Hey, it's not as if anyone
                      ;; has better things to do than to deal with
                      ;; this crap ...
                      (:ppc32 `(pref ,xp :darwin-ucontext32.uc-mcontext32.ss))
                      (:ppc64 `(pref ,xp :darwin-ucontext64.uc-mcontext64.ss)))))
    `(with-macptrs ((,registers ,regform))
      (let ((,offset (xp-gpr-offset ,register-number)))
	,@body))))

  (defmacro RA-field (instr)
    `(ldb (byte 5 16) ,instr))

  (defmacro RB-field (instr)
    `(ldb (byte 5 11) ,instr))

  (defmacro D-field (instr)
    `(ldb (byte 16 0) ,instr))

  (defmacro RS-field (instr)
    `(ldb (byte 5 21) ,instr))
  
  (defmacro lisp-reg-p (reg)
    `(>= ,reg ppc::fn))
  
  (defmacro ppc-lap-word (instruction-form)
    (uvref (uvref (compile nil
                           `(lambda (&lap 0)
			     (ppc-lap-function () ((?? 0))
			      ,instruction-form)))
		  
                  0) #+ppc32-host 0 #+ppc64-host 1))
  
  (defmacro ppc-instruction-mask (&rest fields)
    `(logior ,@(mapcar #'ppc-instruction-field-mask (cons :opcode fields))))
  
  )  



(defun xp-gpr-offset (register-number)
  (unless (and (fixnump register-number)
               (<= -2 (the fixnum register-number))
               (< (the fixnum register-number) 48))
    (setq register-number (require-type register-number '(integer -2 48))))
  (the fixnum 
    (* (the fixnum #+linuxppc-target register-number
	           #+darwinppc-target (+ register-number 2))
       target::node-size)))



(defun xp-gpr-lisp (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-object registers offset))))

(defun (setf xp-gpr-lisp) (value xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (%set-object registers offset value)))

(defun xp-gpr-signed-long (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-signed-long registers offset))))

(defun xp-gpr-signed-doubleword (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%%get-signed-longlong registers offset))))
  

(defun xp-gpr-macptr (xp register-number)
  (with-xp-registers-and-gpr-offset (xp register-number) (registers offset)
    (values (%get-ptr registers offset))))

(defun xp-argument-list (xp)
  (let ((nargs (xp-gpr-lisp xp ppc::nargs))     ; tagged as a fixnum (how convenient)
        (arg-x (xp-gpr-lisp xp ppc::arg_x))
        (arg-y (xp-gpr-lisp xp ppc::arg_y))
        (arg-z (xp-gpr-lisp xp ppc::arg_z)))
    (cond ((eql nargs 0) nil)
          ((eql nargs 1) (list arg-z))
          ((eql nargs 2) (list arg-y arg-z))
          (t (let ((args (list arg-x arg-y arg-z)))
               (if (eql nargs 3)
                 args
                 (let ((vsp (xp-gpr-macptr xp ppc::vsp)))
                   (dotimes (i (- nargs 3))
                     (push (%get-object vsp (* i target::node-size)) args))
                   args)))))))
    
(defun xp-fpscr-info (xp)
  (let* ((fpscr #+(and linuxppc-target 32-bit-target) (%get-unsigned-long (pref xp :ucontext.uc_mcontext.regs) (ash #$PT_FPSCR 2))
                #+(and linuxppc-target 64-bit-target)
                (%get-unsigned-long (pref xp :ucontext.uc_mcontext.fp_regs) (ash 65 2))
		#+(and darwinppc-target ppc32-target)
                (pref xp :darwin-ucontext32.uc-mcontext32.fs.fpscr)
                #+(and darwinppc-target ppc64-target)
                (pref xp :darwin-ucontext64.uc-mcontext64.fs.fpscr)))
    (values (ldb (byte 24 8) fpscr) (ldb (byte 8 0) fpscr))))

#+linuxppc-target
(defun xp-double-float (xp fpr)
  #+32-bit-target
  (%get-double-float (pref xp :ucontext.uc_mcontext.regs) (+ (ash #$PT_FPR0 2)  (ash fpr 3)))
  #+64-bit-target
  (%get-double-float (pref xp :ucontext.uc_mcontext.fp_regs) (ash fpr 3))
  )

#+darwinppc-target
(defun xp-double-float (xp fpr)
  (%get-double-float
     #+ppc32-target (pref xp :darwin-ucontext32.uc-mcontext32.fs)
     #+ppc64-target (pref xp :darwin-ucontext64.uc-mcontext64.fs)
     (ash fpr 3)))


(defparameter *trap-lookup-tries* 5)



(defun %scan-for-instr (mask opcode fn pc-index tries)
  (let ((code-vector (and fn (uvref fn 0)))
        (offset 0))
    (declare (fixnum offset))
    (flet ((get-instr ()
             (if code-vector
               (let ((index (+ pc-index offset)))
                 (when (< index 0) (return-from %scan-for-instr nil))
                 (uvref code-vector index))
               (%get-long pc-index (the fixnum (* 4 offset))))))
      (declare (dynamic-extent #'get-instr))
      (dotimes (i tries)
        (decf offset)
        (let ((instr (get-instr)))
          (when (match-instr instr mask opcode)
            (return instr))
          (when (codevec-header-p instr)
            (return nil)))))))






(defun return-address-offset (xp fn machine-state-offset)
  (with-macptrs ((regs (pref xp #+linuxppc-target :ucontext.uc_mcontext.regs
			        #+(and darwinppc-target ppc32-target)
                                :darwin-ucontext32.uc-mcontext32
                                #+(and darwinppc-target ppc64-target)
                                :darwin-ucontext64.uc-mcontext64)))
    (if (functionp fn)
      (or (%code-vector-pc (uvref fn 0) (%inc-ptr regs machine-state-offset))
           (%get-ptr regs machine-state-offset))
      (%get-ptr regs machine-state-offset))))

(defconstant lr-offset-in-register-context
  #+linuxppc-target (ash #$PT_LNK target::word-shift)
  #+(and darwinppc-target ppc32-target)
  (+ (get-field-offset :darwin-mcontext32.ss)
     (get-field-offset :darwin-ppc-thread-state32.lr))
  #+(and darwinppc-target ppc64-target)
  (+ (get-field-offset :darwin-mcontext64.ss)
     (get-field-offset :darwin-ppc-thread-state64.lr)))

(defconstant pc-offset-in-register-context
  #+linuxppc-target (ash #$PT_NIP target::word-shift)
  #+(and darwinppc-target ppc32-target)
  (+ (get-field-offset :darwin-mcontext32.ss)
     (get-field-offset :darwin-ppc-thread-state32.srr0))
  #+(and darwinppc-target ppc64-target)
  (+ (get-field-offset :darwin-mcontext64.ss)
     (get-field-offset :darwin-ppc-thread-state64.srr0)))

;;; When a trap happens, we may have not yet created control
;;; stack frames for the functions containing PC & LR.
;;; If that is the case, we add fake-stack-frame's to *fake-stack-frames*
;;; There are 4 cases:
;;;
;;; PC in FN
;;;   Push 1 stack frame: PC/FN
;;;   This might miss one recursive call, but it won't miss any variables
;;; PC in NFN
;;;   Push 2 stack frames:
;;;   1) PC/NFN/VSP
;;;   2) LR/FN/VSP
;;;   This might think some of NFN's variables are part of FN's stack frame,
;;;   but that's the best we can do.
;;; LR in FN
;;;   Push 1 stack frame: LR/FN
;;; None of the above
;;;   Push no new stack frames
;;;
;;; The backtrace support functions in "ccl:l1;l1-lisp-threads.lisp" know how
;;; to find the fake stack frames and handle them as arguments.
(defun funcall-with-xp-stack-frames (xp trap-function thunk)
  (cond ((null trap-function)
         ; Maybe inside a subprim from a lisp function
         (let* ((fn (xp-gpr-lisp xp ppc::fn))
                (lr (return-address-offset
                     xp fn lr-offset-in-register-context)))
           (if (fixnump lr)
             (let* ((sp (xp-gpr-lisp xp ppc::sp))
                    (vsp (xp-gpr-lisp xp ppc::vsp))
                    (frame (%cons-fake-stack-frame sp sp fn lr vsp xp *fake-stack-frames*))
                    (*fake-stack-frames* frame))
               (declare (dynamic-extent frame))
               (funcall thunk frame))
             (funcall thunk (xp-gpr-lisp xp ppc::sp)))))
        ((eq trap-function (xp-gpr-lisp xp ppc::fn))
         (let* ((sp (xp-gpr-lisp xp ppc::sp))
                (fn trap-function)
                (lr (return-address-offset
                     xp fn pc-offset-in-register-context))
                (vsp (xp-gpr-lisp xp ppc::vsp))
                (frame (%cons-fake-stack-frame sp sp fn lr vsp xp *fake-stack-frames*))
                (*fake-stack-frames* frame))
           (declare (dynamic-extent frame))
           (funcall thunk frame)))
        ((eq trap-function (xp-gpr-lisp xp ppc::nfn))
         (let* ((sp (xp-gpr-lisp xp ppc::sp))
                (fn (xp-gpr-lisp xp ppc::fn))
                (lr (return-address-offset
                     xp fn lr-offset-in-register-context))
                (vsp (xp-gpr-lisp xp ppc::vsp))
                (lr-frame (%cons-fake-stack-frame sp sp fn lr vsp xp))
                (pc-fn trap-function)
                (pc-lr (return-address-offset
                        xp pc-fn pc-offset-in-register-context))
                (pc-frame (%cons-fake-stack-frame sp lr-frame pc-fn pc-lr vsp xp *fake-stack-frames*))
                (*fake-stack-frames* pc-frame))
           (declare (dynamic-extent lr-frame pc-frame))
           (funcall thunk pc-frame)))
        (t (funcall thunk (xp-gpr-lisp xp ppc::sp)))))



;;; Enter here from handle-trap in "lisp-exceptions.c".
;;; xp is a pointer to an ExceptionInformationPowerPC record.
;;; the-trap is the trap instruction that got us here.
;;; fn-reg is either fn, nfn or 0. If it is fn or nfn, then
;;; the trap occcurred in that register's code vector.
;;; If it is 0, then the trap occurred somewhere else.
;;; pc-index is either the index in fn-reg's code vector
;;; or, if fn-reg is 0, the address of the PC at the trap instruction.
;;; This code parallels the trap decoding code in
;;; "lisp-exceptions.c" that runs if (symbol-value 'cmain)
;;; is not a macptr.
;;; Some of these could probably call %err-disp instead of error,
;;; but I was too lazy to look them up.

#+ppc32-target
(defcallback xcmain (:without-interrupts t
					:address xp 
					:unsigned-fullword fn-reg 
					:address pc-or-index 
					:unsigned-fullword the-trap
					:signed-fullword  arg-0
					:signed-fullword arg-1)
  ;; twgti nargs,0
  ;; time for event polling.
  ;; This used to happen a lot so we test for it first.
  (let ((fn (unless (eql fn-reg 0) (xp-gpr-lisp xp fn-reg))))
    (with-xp-stack-frames (xp fn frame-ptr)
      (if (eql the-trap (ppc-lap-word (twgti nargs 0)))
        (cmain)
        (with-error-reentry-detection
          (let ((pc-index (if (eql fn-reg 0) pc-or-index (%ptr-to-int pc-or-index)))
                instr ra temp rs condition)
            (cond
              ((= the-trap #$SIGBUS)
               (%error (make-condition 'invalid-memory-access
                                       :address arg-0
                                       :write-p (not (zerop arg-1)))
                       ()
                       frame-ptr))              
             ;; tweqi RA nil-value - resolve-eep, or resolve-foreign-variable
	      ((and (match-instr the-trap
				 (ppc-instruction-mask  :opcode :to :d)
				 (ppc-lap-word (tweqi ?? (target-nil-value))))
		    (setq instr (scan-for-instr
				 (ppc-instruction-mask :opcode :d)
				 (ppc-lap-word (lwz ??
						    (+ 4 ppc32::misc-data-offset)
						    ??))
                                               fn pc-index)))
	       (let* ((eep-or-fv (xp-gpr-lisp xp (RA-field instr))))
                 (etypecase eep-or-fv
                   (external-entry-point
                    (resolve-eep eep-or-fv)
                    (setf (xp-gpr-lisp xp (RA-field the-trap))
                          (eep.address eep-or-fv)))
                   (foreign-variable
                    (resolve-foreign-variable eep-or-fv)
                    (setf (xp-gpr-lisp xp (RA-field the-trap))
                          (fv.addr eep-or-fv))))))
             ;; twnei RA,N; RA = nargs
             ;; nargs check, no optional or rest involved
	      ((match-instr the-trap
                           (ppc-instruction-mask :opcode :to :ra)
                           (ppc-lap-word (twnei nargs ??)))
              (%error (if (< (xp-GPR-signed-long xp ppc::nargs) (D-field the-trap))
                        'too-few-arguments
                        'too-many-arguments )
                      (list :nargs (ash (xp-GPR-signed-long xp ppc::nargs)
					(- ppc32::fixnumshift))
			    :fn  fn)
                      frame-ptr))
             
             ;; twnei RA,N; RA != nargs, N = fulltag_node/immheader
             ;; type check; look for "lbz rt-imm,-3(ra-node)"
             ((and (or (match-instr the-trap
                                    (ppc-instruction-mask :opcode :to :fulltag32)
                                    (ppc-lap-word (twnei ?? ppc32::fulltag-nodeheader)))
                       (match-instr the-trap
                                    (ppc-instruction-mask :opcode :to :fulltag32)
                                    (ppc-lap-word (twnei ?? ppc32::fulltag-immheader))))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :d)
                                               (ppc-lap-word (lbz ?? ppc32::misc-subtag-offset ??))
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (let* ((typecode (D-field the-trap))
                     (type-tag (logand typecode ppc32::fulltagmask))
                     (type-name (svref (if (eql type-tag ppc32::fulltag-nodeheader)
                                         *nodeheader-types*
                                         *immheader-types*)
                                       (ldb (byte (- ppc32::num-subtag-bits ppc32::ntagbits) ppc32::ntagbits) typecode))))
                (%error (make-condition 'type-error
                                        :format-control (%rsc-string $XWRONGTYPE)
                                        :datum (xp-GPR-lisp xp ra)
                                        :expected-type type-name)
                        nil
                        frame-ptr)))

             ;; twnei RA,N; RA != nargs, N = subtag_character
             ;; type check; look for "clrlwi rs-node,ra-imm,24" = "rlwinm rs,ra,0,24,31"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)
                                (ppc-lap-word (twnei ?? ppc32::subtag-character)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :rb :mb :me)
                                               (ppc-lap-word (rlwinm ?? ?? 0 24 31))
                                               fn pc-index))
                   (lisp-reg-p (setq rs (RS-field instr))))
              (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'character)
                        nil
                        frame-ptr))

             ;; twnei RA,N; RA != nargs, N != fulltag_node/immheader
             ;; (since that case was handled above.)
             ;; type check; look for "clrlwi rs-node,ra-imm,29/30" = "rlwinm rs,ra,0,29/30,31"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to) 
                                (ppc-lap-word (twnei ?? ??)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :rb (:mb 28) :me)
                                               (ppc-lap-word (rlwinm ?? ?? 0 28 31))                                               
                                               fn pc-index))
                   (or (eql (- 32 ppc32::ntagbits) (setq temp (ldb #.(ppc-instruction-field :mb) instr)))
                       (eql (- 32 ppc32::nlisptagbits) temp))
                   (lisp-reg-p (setq rs (RS-field instr))))
              (let* ((tag (logand the-trap ppc32::tagmask))
                     (type-name 
                      (case tag
                        (#.ppc32::tag-fixnum 'fixnum)
                        (#.ppc32::tag-list (if (eql temp (- 32 ppc32::ntagbits)) 'cons 'list))
                        (#.ppc32::tag-misc 'uvector)
                        (#.ppc32::tag-imm 'immediate))))                                      
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type type-name)
                        nil
                        frame-ptr)))
             
             ;; twlgti RA,N; RA = nargs (xy = 01)
             ;; twllti RA,N; RA = nargs (xy = 10)
             ;; nargs check, optional or rest involved
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode (:to #x1c) :ra)
                                (ppc-lap-word (twi ?? ppc::nargs ??)))
                   (or (eql #b01 (setq temp (ldb #.(ppc-instruction-field :to) the-trap)))
	               (eql #b10 temp)))
              (%error (if (eql temp #b10)
                        'too-few-arguments
                        'too-many-arguments)
                      (list :nargs (ash (xp-GPR-signed-long xp ppc::nargs)
					(- ppc32::fixnumshift))
			    :fn  fn)
                      frame-ptr))
             
             ;; tweqi RA,N; N = unbound
             ;; symeval boundp check; look for "lwz RA,symbol.vcell(nodereg)"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)                                
                                (ppc-lap-word (tweqi ?? ppc32::unbound-marker)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :d)
                                               (ppc-lap-word (lwz ?? ppc32::symbol.vcell ??))                                               
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (setf (xp-GPR-lisp xp (RA-field the-trap))
                    (%kernel-restart-internal $xvunbnd (list (xp-GPR-lisp xp ra)) frame-ptr)))
	     ;; tweqi RA,N: n = (%slot-unbound-marker)
	     ;; slot-unbound trap.  Look for preceding "lwzx RA,rx,ry".
	     ;; rx = slots-vector, ry = scaled index in slots vector.
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to :d)
				(ppc-lap-word (tweqi ?? ppc32::slot-unbound-marker)))
		   (setq instr (scan-for-instr (ppc-instruction-mask
						:opcode :rt  :x-minor)
					       (dpb
						(RA-field the-trap)
						(byte 5 21)
						(ppc-lap-word
						 (lwzx ?? ?? ??)))
					       fn pc-index)))
              (setq *error-reentry-count* 0)  ; succesfully reported error

              ;; %SLOT-UNBOUND-TRAP will decode the arguments further,
              ;; then call the generic function SLOT-UNBOUND.  That
              ;; might return a value; if so, set the value of the
              ;; register that caused the trap to that value.
              (setf (xp-gpr-lisp xp (ra-field the-trap))
                    (%slot-unbound-trap (xp-gpr-lisp xp (RA-field instr))
                                        (ash (- (xp-gpr-signed-long xp (RB-field instr))
                                                ppc32::misc-data-offset)
                                             (- ppc32::word-shift))
                                        frame-ptr)))
             ;; twlge RA,RB
             ;; vector bounds check; look for "lwz immreg, misc_header_offset(nodereg)"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :x-minor)                                
                                (ppc-lap-word (twlge 0 0)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode #|:d|#)
                                               (ppc-lap-word (lwz ?? ?? #|ppc32::misc-header-offset|# ??))
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (%error (%rsc-string $xarroob)
                      (list (xp-GPR-lisp xp (RA-field the-trap))
                            (xp-GPR-lisp xp ra))
                      frame-ptr))
             ;; twi 27 ra d - array header rank check
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to)
				(ppc-lap-word (twi 27 ?? ??)))
		   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :d)
                                               (ppc-lap-word (lwz ?? ppc32::arrayH.rank ??))
                                               fn pc-index))
		   (lisp-reg-p (setq ra (RA-field instr))))
	      (%error (%rsc-string $xndims)
		      (list (xp-gpr-lisp xp ra)
			    (ash (ldb (byte 16 0) the-trap) (- ppc32::fixnumshift)))
		      frame-ptr))
	     ;; tw 27 ra rb - array flags check
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to :x-minor)
				(ppc-lap-word (tw 27 ?? ??)))
		   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :d)
                                               (ppc-lap-word (lwz ?? ppc32::arrayH.flags ??))
                                               fn pc-index))
		   (lisp-reg-p (setq ra (RA-field instr)))
		   (let* ((expected (xp-gpr-lisp xp (RB-field the-trap)))
			  (expected-subtype (ldb
					     ppc32::arrayH.flags-cell-subtag-byte
					     expected))
			  (expect-simple (=
					  (ldb ppc32::arrayH.flags-cell-bits-byte
					       expected)
					  (ash 1 $arh_simple_bit)))
			  (type-name
			   (case expected-subtype
			     (#.ppc32::subtag-double-float-vector 'double-float))))

		     (and type-name expect-simple
			  (setq condition
				(make-condition 'type-error
						:datum (xp-gpr-lisp xp ra)
						:expected-type
						`(simple-array ,type-name))))))
	      (%error condition nil frame-ptr))
			       
             ;; Unknown trap
             (t (%error "Unknown trap: #x~x~%xp: ~s, fn: ~s, pc: #x~x"
                        (list the-trap xp fn (ash pc-index ppc32::fixnumshift))
                        frame-ptr)))))))))

#+ppc64-target
(defcallback xcmain (:without-interrupts t
					:address xp 
					:unsigned-fullword fn-reg 
					:address pc-or-index 
					:unsigned-fullword the-trap
					:signed-doubleword  arg0
					:signed-doubleword arg1)
  ;; tdgti nargs,0
  ;; time for event polling.
  ;; This used to happen a lot so we test for it first.
  (let ((fn (unless (eql fn-reg 0) (xp-gpr-lisp xp fn-reg))))
    (with-xp-stack-frames (xp fn frame-ptr)
      (if (eql the-trap (ppc-lap-word (tdgti nargs 0)))
        (cmain)
        (with-error-reentry-detection
          (let ((pc-index (if (eql fn-reg 0) pc-or-index (%ptr-to-int pc-or-index)))
                instr ra temp rs condition)
            (cond
              ;; tdeqi RA nil-value - resolve-eep, or resolve-foreign-variable
	      ((and (match-instr the-trap
				 (ppc-instruction-mask  :opcode :to :d)
				 (ppc-lap-word (tdeqi ?? (target-nil-value))))
		    (setq instr (scan-for-instr
				 (ppc-instruction-mask :opcode :ds :ds-xo)
				 (ppc-lap-word (ld ??
						    (+ 8 ppc64::misc-data-offset)
						    ??))
                                               fn pc-index)))
	       (let* ((eep-or-fv (xp-gpr-lisp xp (RA-field instr))))
                 (etypecase eep-or-fv
                   (external-entry-point
                    (resolve-eep eep-or-fv)
                    (setf (xp-gpr-lisp xp (RA-field the-trap))
                          (eep.address eep-or-fv)))
                   (foreign-variable
                    (resolve-foreign-variable eep-or-fv)
                    (setf (xp-gpr-lisp xp (RA-field the-trap))
                          (fv.addr eep-or-fv))))))
              ((= the-trap #$SIGBUS)
               (%error (make-condition 'invalid-memory-access
                                       :address arg0
                                       :write-p (not (zerop arg1)))
                       ()
                       frame-ptr))
              ;; tdnei RA,N; RA = nargs
              ;; nargs check, no optional or rest involved
	      ((match-instr the-trap
                           (ppc-instruction-mask :opcode :to :ra)
                           (ppc-lap-word (tdnei nargs ??)))
              (%error (if (< (xp-GPR-signed-doubleword xp ppc::nargs) (D-field the-trap))
                        'too-few-arguments
                        'too-many-arguments )
                      (list :nargs (ash (xp-GPR-signed-doubleword xp ppc::nargs)
					(- ppc64::fixnumshift))
			    :fn  fn)
                      frame-ptr))
             
             ;; tdnei RA,N; RA != nargs, N = lowtag_node/immheader
             ;; type check; look for "lbz rt-imm,-5(ra-node)"
             ((and (or (match-instr the-trap
                                    (ppc-instruction-mask :opcode :to :lowtag64)
                                    (ppc-lap-word (tdnei ?? ppc64::lowtag-nodeheader)))
                       (match-instr the-trap
                                    (ppc-instruction-mask :opcode :rt :lowtag64)
                                    (ppc-lap-word (tdnei ?? ppc64::lowtag-immheader))))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :d)
                                               (ppc-lap-word (lbz ?? ppc64::misc-subtag-offset ??))
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (let* ((typecode (D-field the-trap))
                     (type-tag (logand typecode ppc64::lowtagmask))
                     (type-name (svref (if (eql type-tag ppc64::lowtag-nodeheader)
                                         *nodeheader-types*
                                         *immheader-types*)
                                       (ash typecode (- ppc64::nlowtagbits)))))
                (%error (make-condition 'type-error
                                        :format-control (%rsc-string $XWRONGTYPE)
                                        :datum (xp-GPR-lisp xp ra)
                                        :expected-type type-name)
                        nil
                        frame-ptr)))
             ;; tdnei RA,N; RA != nargs, N = subtag_character type
             ;; check; look for "clrldi rs-node,ra-imm,56" = "rldicl
             ;; rs,ra,0,55"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :rt :d)
                                (ppc-lap-word (tdnei ?? ppc64::subtag-character)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 56))
                                               fn pc-index))
                   (lisp-reg-p (setq rs (RS-field instr))))
              (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'character)
                        nil
                        frame-ptr))

             ;; tdnei RA,N; RA != nargs, N = ppc64::tag-fixnum.  type
             ;; check; look for "clrldi rs-node,ra-imm,61" = "rldicl
             ;; rs,ra,61"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :rt)
                                (ppc-lap-word (tdnei ?? ppc64::tag-fixnum)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 61))                                               
                                               fn pc-index))

                   (lisp-reg-p (setq rs (RS-field instr))))
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'fixnum)
                        nil
                        frame-ptr))
             ;; tdi 3,RA,ppc64::fulltag-cons; RA != nargs type check;
             ;; look for "clrldi rs-node,ra-imm,60" = "rldicl
             ;; rs,ra,60"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)
                                (ppc-lap-word (tdi 3 ?? ppc64::fulltag-cons)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 60))                                               
                                               fn pc-index))

                   (lisp-reg-p (setq rs (RS-field instr))))
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'list)
                        nil
                        frame-ptr))             
             ;; tdnei RA,ppc64::fulltag-cons; RA != nargs type check;
             ;; look for "clrldi rs-node,ra-imm,60" = "rldicl
             ;; rs,ra,60"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)
                                (ppc-lap-word (tdnei ?? ppc64::fulltag-cons)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 60))                                               
                                               fn pc-index))

                   (lisp-reg-p (setq rs (RS-field instr))))
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'cons)
                        nil
                        frame-ptr))
             ;; tdnei RA,ppc64::subtag-single-float; RA != nargs type check;
             ;; look for "clrldi rs-node,ra-imm,60" = "rldicl
             ;; rs,ra,60"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)
                                (ppc-lap-word (tdnei ?? ppc64::subtag-single-float)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 60))                                               
                                               fn pc-index))

                   (lisp-reg-p (setq rs (RS-field instr))))
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'short-float)
                        nil
                        frame-ptr))
             ;; tdnei RA,ppc64::fulltag-misc; RA != nargs type check;
             ;; look for "clrldi rs-node,ra-imm,60" = "rldicl
             ;; rs,ra,60"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d)
                                (ppc-lap-word (tdnei ?? ppc64::fulltag-misc)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :sh :mb6 :sh6)
                                               (ppc-lap-word (rldicl ?? ?? 0 60))                                               
                                               fn pc-index))

                   (lisp-reg-p (setq rs (RS-field instr))))
                (%error (make-condition 'type-error
                                        :datum (xp-GPR-lisp xp rs)
                                        :expected-type 'uvector)
                        nil
                        frame-ptr))
             ;; tdlgti RA,N; RA = nargs (xy = 01)
             ;; tdllti RA,N; RA = nargs (xy = 10)
             ;; nargs check, optional or rest involved
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode (:to #x1c) :ra)
                                (ppc-lap-word (tdi ?? ppc::nargs ??)))
                   (or (eql #b01 (setq temp (ldb #.(ppc-instruction-field :to) the-trap)))
	               (eql #b10 temp)))
              (%error (if (eql temp #b10)
                        'too-few-arguments
                        'too-many-arguments)
                      (list :nargs (ash (xp-GPR-signed-doubleword xp ppc::nargs)
					(- ppc64::fixnumshift))
			    :fn  fn)
                      frame-ptr))
             
             ;; tdeqi RA,N; N = unbound
             ;; symeval boundp check; look for "ld RA,symbol.vcell(nodereg)"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :d) 
                                (ppc-lap-word (tdeqi ?? ppc64::unbound-marker)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :ds :ds-xo)
                                               (ppc-lap-word (ld ?? ppc64::symbol.vcell ??))                                               
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (setf (xp-GPR-lisp xp (RA-field the-trap))
                    (%kernel-restart-internal $xvunbnd (list (xp-GPR-lisp xp ra)) frame-ptr)))
	     ;; tdeqi RA,N: n = (%slot-unbound-marker)
	     ;; slot-unbound trap.  Look for preceding "ldx RA,rx,ry".
	     ;; rx = slots-vector, ry = scaled index in slots vector.
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to :d)
				(ppc-lap-word (tdeqi ?? ppc64::slot-unbound-marker)))
		   (setq instr (scan-for-instr (ppc-instruction-mask
						:opcode :rt  :x-minor)
					       (dpb
						(RA-field the-trap)
						(byte 5 21)
						(ppc-lap-word
						 (ldx ?? ?? ??)))
					       fn pc-index)))
              (setq *error-reentry-count* 0)  ; succesfully reported error
              ;; %SLOT-UNBOUND-TRAP will decode the arguments further,
              ;; then call the generic function SLOT-UNBOUND.  That
              ;; might return a value; if so, set the value of the
              ;; register that caused the trap to that value.
              (setf (xp-gpr-lisp xp (ra-field the-trap))
                    (%slot-unbound-trap (xp-gpr-lisp xp (RA-field instr))
                                        (ash (- (xp-gpr-signed-doubleword xp (RB-field instr))
                                                ppc64::misc-data-offset)
                                             (- ppc64::word-shift))
                                        frame-ptr)))
             ;; tdlge RA,RB
             ;; vector bounds check; look for "ld immreg, misc_header_offset(nodereg)"
             ((and (match-instr the-trap
                                (ppc-instruction-mask :opcode :to :x-minor)
                                (ppc-lap-word (tdlge ?? ??)))
                   (setq instr (scan-for-instr (ppc-instruction-mask :opcode #|:d|# :ds-xo)
                                               (ppc-lap-word (ld ?? ?? #|ppc32::misc-header-offset|# ??))
                                               fn pc-index))
                   (lisp-reg-p (setq ra (RA-field instr))))
              (%error (%rsc-string $xarroob)
                      (list (xp-GPR-lisp xp (RA-field the-trap))
                            (xp-GPR-lisp xp ra))
                      frame-ptr))
             ;; tdi 27 ra d - array header rank check
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to)
				(ppc-lap-word (tdi 27 ?? ??)))
		   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :ds :ds-xo)
                                               (ppc-lap-word (ld ?? ppc64::arrayH.rank ??))
                                               fn pc-index))
		   (lisp-reg-p (setq ra (RA-field instr))))
	      (%error (%rsc-string $xndims)
		      (list (xp-gpr-lisp xp ra)
			    (ash (ldb (byte 16 0) the-trap) (- ppc64::fixnumshift)))
		      frame-ptr))
	     ;; td 27 ra rb - array flags check
	     ((and (match-instr the-trap
				(ppc-instruction-mask :opcode :to :x-minor)
				(ppc-lap-word (td 27 ?? ??)))
		   (setq instr (scan-for-instr (ppc-instruction-mask :opcode :ds :ds-xo)
                                               (ppc-lap-word (ld ?? ppc64::arrayH.flags ??))
                                               fn pc-index))
		   (lisp-reg-p (setq ra (RA-field instr)))
		   (let* ((expected (xp-gpr-lisp xp (RB-field the-trap)))
			  (expected-subtype (ldb
					     ppc64::arrayH.flags-cell-subtag-byte
					     expected))
			  (expect-simple (=
					  (ldb ppc64::arrayH.flags-cell-bits-byte
					       expected)
					  (ash 1 $arh_simple_bit)))
			  (type-name
			   (case expected-subtype
			     (#.ppc64::subtag-double-float-vector 'double-float))))

		     (and type-name expect-simple
			  (setq condition
				(make-condition 'type-error
						:datum (xp-gpr-lisp xp ra)
						:expected-type
						`(simple-array ,type-name))))))
	      (%error condition nil frame-ptr))
			       
             ;; Unknown trap
             (t (%error "Unknown trap: #x~x~%xp: ~s, fn: ~s, pc: #x~x"
                        (list the-trap xp fn (ash pc-index ppc64::fixnumshift))
                        frame-ptr)))))))))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/ppc-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/ppc-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; ppc-callback-support.lisp
;;;
;;; Support for PPC callbacks

(in-package "CCL")



;;; This is machine-dependent (it conses up a piece of "trampoline" code
;;; which calls a subprim in the lisp kernel.)
#-(and linuxppc-target poweropen-target)
(defun make-callback-trampoline (index &optional info)
  (declare (ignorable info))
  (macrolet ((ppc-lap-word (instruction-form)
               (uvref (uvref (compile nil `(lambda (&lap 0) (ppc-lap-function () ((?? 0)) ,instruction-form))) 0) #+ppc32-host 0 #+ppc64-host 1)))
    (let* ((subprim
	    #+eabi-target
	     #.(subprim-name->offset '.SPeabi-callback)
	     #-eabi-target
             #.(subprim-name->offset '.SPpoweropen-callback))
           (p (%allocate-callback-pointer 12)))
      (setf (%get-long p 0) (logior (ldb (byte 8 16) index)
                                    (ppc-lap-word (lis 11 ??)))   ; unboxed index
            (%get-long p 4) (logior (ldb (byte 16 0) index)
                                    (ppc-lap-word (ori 11 11 ??)))
                                   
	    (%get-long p 8) (logior subprim
                                    (ppc-lap-word (ba ??))))
      (ff-call (%kernel-import #.target::kernel-import-makedataexecutable) 
               :address p 
               :unsigned-fullword 12
               :void)
      p)))

;;; In the 64-bit LinuxPPC ABI, functions are "transfer vectors":
;;; two-word vectors that contain the entry point in the first word
;;; and a pointer to the global variables ("table of contents", or
;;; TOC) the function references in the second word.  We can use the
;;; TOC word in the transfer vector to store the callback index.
#+(and linuxppc-target poweropen-target)
(defun make-callback-trampoline (index &optional info)
  (declare (ignorable info))
  (let* ((p (%allocate-callback-pointer 16)))
    (setf (%%get-unsigned-longlong p 0) #.(subprim-name->offset '.SPpoweropen-callback)
          (%%get-unsigned-longlong p 8) index)
    p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/ppc-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-io.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;; -*- Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; L1-io.lisp

(in-package "CCL")

(setf (fdefinition '%new-ptr) (fdefinition '%new-gcable-ptr))


;;;; ======================================================================
;;;; Standard CL IO frobs


(declaim (inline %real-print-stream))
(defun %real-print-stream (&optional (stream nil))
  (cond ((null stream)
         *standard-output*)
        ((eq stream t)
         *terminal-io*)
        (t stream)))

;;; OK, EOFP isn't CL ...
(defun eofp (&optional (stream *standard-input*))
  (stream-eofp stream))

(defun force-output (&optional stream)
  (stream-force-output (%real-print-stream stream))
  nil)

(defun listen (&optional (stream *standard-input*))
  (let* ((stream (designated-input-stream stream)))
    (stream-listen stream)))

(defun fresh-line (&optional (output-stream *standard-output*))
  "Output #\Newline only if the OUTPUT-STREAM is not already at the
start of a line.  Return T if #\Newline needed."
  (stream-fresh-line (%real-print-stream output-stream)))

(defun column (&optional stream)
  (let* ((stream (%real-print-stream stream)))
    (stream-line-column stream)))

(defun clear-input (&optional input-stream)
  "Clear any available input from INPUT-STREAM."
  (stream-clear-input (designated-input-stream input-stream))
  nil)

(defun write-char (char &optional (output-stream nil))
  "Output CHAR to OUTPUT-STREAM."
  (let* ((stream (%real-print-stream output-stream)))
    (if (typep stream 'basic-stream)
      (let* ((ioblock (basic-stream-ioblock stream)))
        (funcall (ioblock-write-char-function ioblock) ioblock char))
      (stream-write-char stream char))
    char))

(defun write-string (string &optional output-stream &key (start 0 start-p)
			    (end nil end-p))
  "Write the characters of the subsequence of STRING bounded by START
and END to OUTPUT-STREAM."
  (let* ((stream (%real-print-stream output-stream)))
    (if (typep stream 'basic-stream)
      (let* ((ioblock (basic-stream-ioblock stream)))
        (with-ioblock-output-locked (ioblock) 
          (if (and (typep string 'simple-string)
                   (not start-p) (not end-p))
            (funcall (ioblock-write-simple-string-function ioblock)
                     ioblock string 0 (length string))
            (progn
              (setq end (check-sequence-bounds string start end))
              (locally (declare (fixnum start end))
                (multiple-value-bind (arr offset)
                    (if (typep string 'simple-string)
                      (values string 0)
                      (array-data-and-offset (require-type string 'string)))
                  (unless (eql 0 offset)
                    (incf start offset)
                    (incf end offset))
                  (funcall (ioblock-write-simple-string-function ioblock)
                           ioblock arr start (the fixnum (- end start)))))))))
      (if (and (not start-p) (not end-p))
        (stream-write-string stream string)
        (stream-write-string stream string start end)))
  string))

(defun write-simple-string (string output-stream start end)
  "Write the characters of the subsequence of simple-string STRING bounded by START
and END to OUTPUT-STREAM."
  (let* ((stream (%real-print-stream output-stream))
         (string (the simple-string string))) ;; typecheck at high safety.
    (if (typep stream 'basic-stream)
      (let* ((ioblock (basic-stream-ioblock stream))
             (start (or start 0)))
        (with-ioblock-output-locked (ioblock) 
          (if (and (eq start 0) (null end))
            (funcall (ioblock-write-simple-string-function ioblock)
                     ioblock string 0 (length string))
            (let* ((end (check-sequence-bounds string start end)))
              (funcall (ioblock-write-simple-string-function ioblock)
                       ioblock string start  (%i- end start))))))
      (if (and (not start) (not end))
        (stream-write-string stream string)
        (stream-write-string stream string start (or end (length string)))))
    string))

(defun write-line (string &optional output-stream
                          &key (start 0) (end (length string)))
  "Write the characters of the subsequence of STRING bounded by START
and END to OUTPUT-STREAM then output a #\Newline at end."
  (write-string string output-stream :start start :end end)
  (terpri output-stream)
  string)

(defun terpri (&optional (stream *standard-output*))
  (let* ((stream (%real-print-stream stream)))
    (if (typep stream 'basic-stream)
      (let* ((ioblock (basic-stream-ioblock stream)))
        (funcall (ioblock-write-char-function ioblock) ioblock #\newline))
      (stream-write-char stream #\newline))
    nil))

;;;; ----------------------------------------------------------------------



;;;; ======================================================================
;;;; The Lisp Printer


;; coral extensions
(def-standard-initial-binding *print-abbreviate-quote* t
  "Non-NIL means that the normal lisp printer --
not just the pretty-printer -- should print
lists whose first element is QUOTE or FUNCTION specially.
This variable is not part of standard Common Lisp.")

(def-standard-initial-binding *print-structure* t
  "Non-NIL means that lisp structures should be printed using
\"#S(...)\" syntax.  if nil, structures are printed using \"#<...>\".
This variable is not part of standard Common Lisp.")

;; things Richard Mlynarik likes.
(def-standard-initial-binding *print-simple-vector* nil
  "Non-NIL means that simple-vectors whose length is less than
the value of this variable are printed even if *PRINT-ARRAY* is false.
this variable is not part of standard Common Lisp.")

(def-standard-initial-binding *print-simple-bit-vector* nil
  "Non-NIL means that simple-bit-vectors whose length is less than
the value of this variable are printed even if *PRINT-ARRAY* is false.
This variable is not part of standard Common Lisp.")

(def-standard-initial-binding *print-string-length* nil
  "Non-NIL means that strings longer than this are printed
using abbreviated #<string ...> syntax.
This variable is not part of standard Common Lisp.")

(def-standard-initial-binding *print-escape* t
  "Non-NIL means that the lisp printer should -attempt- to output
expressions `readably.'  When NIL the attempts to produce output
which is a little more human-readable (for example, pathnames
are represented by the characters of their namestring.)")

(def-standard-initial-binding *print-pretty* nil
  "Non-NIL means that the lisp printer should insert extra
indentation and newlines to make output more readable and `prettier.'")

(def-standard-initial-binding *print-base* 10.
  "The output base for integers and rationals.
Must be an integer between 2 and 36.")

(def-standard-initial-binding *print-radix* nil
  "Non-NIL means that the lisp printer will explicitly indicate
the output radix (see *PRINT-BASE*) which is used to print
integers and rational numbers.")

(def-standard-initial-binding *print-level* nil
  "Specifies the depth at which printing of lisp expressions
should be truncated.  NIL means that no such truncation should occur.
Truncation is indicated by printing \"#\" instead of the
representation of the too-deeply-nested structure.
See also *PRINT-LENGTH*")

(def-standard-initial-binding *print-length* nil
  "Specifies the length at which printing of lisp expressions
should be truncated.  NIL means that no such truncation should occur.
truncation is indicated by printing \"...\" instead of the
rest of the overly-long list or vector.
See also *PRINT-LEVEL*")

(def-standard-initial-binding *print-circle* nil
  "Non-NIL means that the lisp printer should attempt to detect
circular structures, indicating them by using \"#n=\" and \"#n#\" syntax.
If this variable is false then an attempt to
output circular structure may cause unbounded output.")

(def-standard-initial-binding *print-case* ':upcase
  "Specifies the alphabetic case in which symbols should
be printed.  Possible values include :UPCASE, :DOWNCASE and :CAPITALIZE") ; and :StuDLy

(def-standard-initial-binding *print-array* t
  "Non-NIL means that arrays should be printed using \"#(...)\" or
\"=#nA(...)\" syntax to show their contents.
If NIL, arrays other than strings are printed using \"#<...>\".
See also the (non-Common Lisp) variables *PRINT-SIMPLE-VECTOR*
and *PRINT-SIMPLE-BIT-VECTOR*")

(def-standard-initial-binding *print-gensym* t
  "Non-NIL means that symbols with no home package should be
printed using \"#:\" syntax.  NIL means no prefix is printed.")

(def-standard-initial-binding *print-readably* nil
  "Non-NIL means that attempts to print unreadable objects
   signal PRINT-NOT-READABLE errors.  NIL doesn't.")

(def-standard-initial-binding *PRINT-RIGHT-MARGIN* nil
  "+#/NIL the right margin for pretty printing")

(def-standard-initial-binding *PRINT-MISER-WIDTH* 40.
  "+#/NIL miser format starts when there is less than this width left")

(def-standard-initial-binding *PRINT-LINES* nil
  "+#/NIL truncates printing after # lines")

(def-standard-initial-binding *DEFAULT-RIGHT-MARGIN* 70
  "Controls default line length;  Must be a non-negative integer")


(defvar *xp-current-object* nil)  ; from xp

(defvar *circularity-hash-table* nil) ; ditto

(defvar *current-level* nil)

(defvar *current-length* nil) ; must be nil at top level

(defvar *print-catch-errors* nil)

(defun default-print-level (val)
  (if (eq val :default) *print-level* val))

(defun default-print-length (val)
  (if (eq val :default) *print-length* val))

(defun default-print-string-length (val)
  (if (eq val :default) *print-string-length* val))

;;;; ======================================================================

(defclass xp-stream (output-stream)
   (xp-structure))

(defun %write-string (string stream)
  (if (characterp string)
    (stream-write-char stream string)
    (stream-write-entire-string stream string)))


;; *print-simple-vector*
;; *print-simple-bit-vector*
;; *print-string-length*
;; for things like *print-level* which must [no longer] be integers > 0
(defun get-*print-frob* (symbol
                         &optional (nil-means target::target-most-positive-fixnum)
                         (t-means nil))
  (declare (type symbol symbol))
  (let ((value (symbol-value symbol)))
    (when *print-readably*
      (case symbol
        ((*print-length* *print-level* *print-lines* *print-string-length*)
         (setq value nil))
        ((*print-escape* *print-gensym* *print-array* *print-simple-vector*
                         *print-simple-bit-vector*)
         (setq value t))
        (t nil)))
    (cond ((null value)
           nil-means)
          ((and (integerp value)) ; (> value 0))
           (min (max value -1) value target::target-most-positive-fixnum))
          ((and t-means (eq value 't))
           t-means)
          (t
           (setf (symbol-value symbol) nil)
           (error "~s had illegal value ~s.  reset to ~s"
                  symbol value 'nil)))))


(defun pp-newline (stream kind)
  (case kind
    ((:newline)
     (fresh-line stream))
    ((:unconditional :mandatory)
     (stream-write-char stream #\Newline))
    (t nil)))


(defun pp-space (stream &optional (newline-kind ':fill))
  (stream-write-char stream #\space)
  (pp-newline stream newline-kind))

(defun pp-start-block (stream &optional prefix)
  (cond ((null prefix))
        ((characterp prefix)
         (stream-write-char stream prefix))
        ((stringp prefix)
         (%write-string prefix stream))
        (t (report-bad-arg prefix '(or character string (eql nil))))))


(defun pp-end-block (stream &optional suffix)
  (cond ((null suffix))
        ((characterp suffix)
         (stream-write-char stream suffix))
        ((stringp suffix)
         (%write-string suffix stream))
        (t (report-bad-arg suffix '(or character string (eql nil))))))


#|
(defmethod pp-set-indentation ((stream stream) kind n)
  (declare (ignore kind n))
  nil)
|#


;;;; ======================================================================
;; list-kludge is so that we can simultaneously detect shared list tails
;;   and avoid printing lists as (foo . (bar . (baz . nil)))
;; if non-nil, it is the remaining *print-length* and object is
;;   a list tail



(defmethod write-internal-1 ((stream t) object level list-kludge)
  (declare (type fixnum level) (type (or null fixnum) list-kludge))
  ;;>> Anybody passing in list-kludge had better be internal to the lisp printer.
  ;(if list-kludge (error "Internal printer error"))
    (let ((circle *print-circle*)
          (pretty *print-pretty*))
      (cond ((or pretty circle)
             ; what about this level stuff??
             ; most peculiar
             (maybe-initiate-xp-printing
              #'(lambda (s o) (write+ o s)) stream object))
            ((not list-kludge)
             (write-a-frob object stream level list-kludge))
            ((null object))
            (t
             (stream-write-char stream #\space)
             (when (not (consp object))
               (stream-write-char stream #\.)
               (stream-write-char stream #\space))
             (write-a-frob object stream level list-kludge)))))



(defmethod write-internal-1 ((stream xp-stream) object level list-kludge)
  (when level
    (setq *current-level* (if (and *print-level* (not *print-readably*))
                            (- *print-level* level)
                            0)))
  (write+ object (slot-value stream 'xp-structure) list-kludge))


(defvar *inside-printer-error* nil)

(defvar *signal-printing-errors* nil)
(queue-fixup (setq *signal-printing-errors* t))

(defun write-internal (stream object level list-kludge)
  (if (bogus-thing-p object)
    (print-unreadable-object
      (object stream)
      (princ (%str-cat "BOGUS object @ #x" (%integer-to-string (%address-of object) 16.)) 
             stream))
    (progn
      (flet ((handler (condition)
               (declare (ignore condition))
               (unless *signal-printing-errors*
                 (return-from write-internal
                   (let ((*print-pretty* nil)
                         (*print-circle* nil))
                     (if *inside-printer-error*
                       (when (eql 1 (incf *inside-printer-error*))
                         (%write-string "#<Recursive printing error " stream)
			 (stream-write-char stream #\space)
                         (%write-address (%address-of object) stream)
                         (stream-write-char stream #\>))
                       (let ((*inside-printer-error* 0))
                         ; using format here considered harmful.
                         (%write-string "#<error printing " stream)
                         (write-internal stream (type-of object) (max level 2) nil)
                         (stream-write-char stream #\space)
                         (%write-address (%address-of object) stream)
                         (stream-write-char stream #\>))))))))
        (declare (dynamic-extent #'handler))
        (handler-bind
          ((error #'handler))
          (write-internal-1 stream object level list-kludge)))
      object)))


;;;; ======================================================================
;;;; internals of write-internal

;; bd common-lisp (and lisp machine) printer depth counts
;;  count from 0 upto *print-level* instead of from
;;  *print-level* down to 0 (which this printer sensibly does.)
(defun backtranslate-level (level)
  (let ((print-level (get-*print-frob* '*print-level*)))
    (if (not (and level print-level))
      target::target-most-positive-fixnum
      (if (> level print-level)
        ;; wtf!
        1
        (- print-level level)))))

; so we can print-circle for print-object methods.
(defvar %current-write-level% nil)
(defvar %current-write-stream% nil)
(defun %current-write-level% (stream &optional decrement?)
  (if (eq stream %current-write-stream%)
    (if decrement? (1- %current-write-level%) %current-write-level%)
    (get-*print-frob* '*print-level*)))
      
;;>> Some notes:
;;>> CL defining print-object to be a multmethod dispatching on
;;>>  both the object and the stream just can't work
;;>> There are a couple of reasons:
;;>>  - CL wants *print-circle* structure to be automatically detected
;;>>    This means that there must be a printing pre-pass to some stream
;;>>    other than the one specified by the user, which means that any
;;>>    print-object method which specialises on its second argument is
;;>>    going to lose big.

;;>>  - CL wants *print-level* truncation to happen automatically
;;>>    and doesn't pass a level argument to print-object (as it should)
;;>>    This means that the current level must be associated with the
;;>>    stream in some fashion.  The quicky kludge Bill uses here
;;>>    (binding a special variable) loses for
;;>>    + Entering a break loop whilst printing to a stream
;;>>      (Should start level from (get-*print-level*) again)
;;>>    + Performing output to more than one stream in an interleaved fashion
;;>>      (Say a print-object method which writes to *trace-output*)
;;>>    The solution, again, is to actually call the print-object methods
;;>>    on a write-aux-stream, where that stream is responsible for
;;>>    doing *print-level* truncation.
;;>>  - BTW The select-method-order should be (stream object) to even have
;;>>    a chance of winning.  Not that it could win in any case, for the above reasons.
;;>> It isn't that much work to change the printer to always use an
;;>> automatically-level-truncating write-aux-stream
;;>> It is a pity that CL is so BD.
;;>>

(defun write-a-frob (object stream level list-kludge)
  (declare (type stream stream) (type fixnum level)
           (type (or null fixnum) list-kludge))
  (cond ((not list-kludge)
         (let ((%current-write-stream% stream)   ;>> SIGH
               (%current-write-level% level))
           (print-object object stream)))
        ((%i< list-kludge 1)
         ;; *print-length* truncation
         (stream-write-entire-string stream "..."))
        ((not (consp object))
         (write-a-frob object stream level nil))
        (t
         (write-internal stream (%car object) level nil)
         ;;>> must do a tail-call!!
         (write-internal-1 stream (%cdr object) level (if (consp (%cdr object))
                                                          (%i- list-kludge 1)
                                                          list-kludge)))))

(defmethod print-object :around ((object t) stream)
  (if *print-catch-errors*
    (handler-case (call-next-method)
      (error () (write-string "#<error printing object>" stream)))
    (call-next-method)))

(defmethod print-object ((object t) stream)
  (let ((level (%current-write-level% stream))   ; what an abortion.  This should be an ARGUMENT!
        (%type (%type-of object)))
    (declare (type symbol %type)
             (type fixnum level))
    (flet ((depth (stream v)
             (declare (type fixnum v) (type stream stream))
             (when (%i<= v 0)
               ;; *print-level* truncation
               (stream-write-entire-string stream "#")
               t)))
      (cond
        ((eq %type 'cons)
         (unless (depth stream level)
           (write-a-cons object stream level)))
        ;; Don't do *print-level* truncation for anything between
        ;; here and the (depth ...) case.
        ((or (eq %type 'symbol)
             (null object))
         (write-a-symbol object stream))
        ((or (stringp object)
             (bit-vector-p object))
         (cond ((or (not (stringp object))
                    (%i> (length (the string object))
                         (get-*print-frob* '*print-string-length*)))
                (write-an-array object stream level))
               ((or *print-escape* *print-readably*)
                (write-escaped-string object stream))
               (t
                (%write-string object stream))))
        ((and (eq %type 'structure)
              (not (null (ccl::struct-def object)))
              (null (cdr (sd-slots (ccl::struct-def object)))))
         ;; else fall through to write-a-uvector
         (write-a-structure object stream level))
        ((depth stream level))
        ((eq %type 'package)
         (write-a-package object stream))
        ((eq %type 'macptr)
         (write-a-macptr object stream))
        ((eq %type 'dead-macptr)
         (write-a-dead-macptr object stream))
        ((eq %type 'internal-structure)
         (write-an-istruct object stream level))        
        ((and (eq %type 'structure)
              (not (null (ccl::struct-def object))))
         ;; else fall through to write-a-uvector
         (if (and *print-pretty* *print-structure*)
           (let ((*current-level* (if (and *print-level* (not *print-readably*))
                                    (- *print-level* level)
                                    0)))
             (pretty-structure stream object)) 
           (write-a-structure object stream level)))
        ((functionp object)
         (write-a-function object stream level))
        ((arrayp object)
         (cond ((or (not (stringp object))
                    (%i> (length (the string object))
                         (get-*print-frob* '*print-string-length*)))
                (write-an-array object stream level))
               ((or *print-escape* *print-readably*)
                (write-escaped-string object stream))
               (t
                (%write-string object stream))))

 ; whazzat        
        ((uvectorp object)  
         (write-a-uvector object stream level))
        (t
         (print-unreadable-object (object stream)
           (let* ((address (%address-of object)))
             (cond ((eq object (%unbound-marker-8))
                    (%write-string "Unbound" stream))
                   ((eq object (%slot-unbound-marker))
                    (%write-string "Slot-Unbound" stream))
                   (t
                    (cond
                     (t
                      (%write-string "Unprintable " stream)
                      (write-a-symbol %type stream)
                      (%write-string " : " stream)))
                    (%write-address address stream))))))))
    nil))

(defun write-a-dead-macptr (macptr stream)
  (print-unreadable-object (macptr stream)
    (%write-string "A Dead Mac Pointer" stream)))


;;;; ======================================================================
;;;; Powerful, wonderful tools for printing unreadable objects.

(defun print-not-readable-error (object stream)
  (error (make-condition 'print-not-readable :object object :stream stream)))

; Start writing an unreadable OBJECT on STREAM, error out if *PRINT-READABLY* is true.
(defun write-unreadable-start (object stream)
  (if *print-readably* 
    (print-not-readable-error object stream)
    (pp-start-block stream "#<")))

(defun %print-unreadable-object (object stream type id thunk)
  (cond ((null stream) (setq stream *standard-output*))
        ((eq stream t) (setq stream *terminal-io*)))
  (write-unreadable-start object stream)
  (when type
    (princ (type-of object) stream))
  (when thunk 
    (when type (stream-write-char stream #\space))
    (funcall thunk))
  (if id
    (%write-address object stream #\>)
    (pp-end-block stream ">"))
  nil)

;;;; ======================================================================
;;;; internals of internals of write-internal

(defmethod print-object ((char character) stream &aux name)
  (cond ((or *print-escape* *print-readably*) ;print #\ for read-ability
         (stream-write-char stream #\#)
         (stream-write-char stream #\\)
         (if (and (or (eql char #\newline)
                      (not (standard-char-p char)))
                  (setq name (char-name char)))
           (%write-string name stream)
           (stream-write-char stream char)))
        (t
         (stream-write-char stream char))))

(defun get-*print-base* ()
  (let ((base *print-base*))
    (unless (and (fixnump base)
                 (%i< 1 base) (%i< base 37.))
      (setq *print-base* 10.)
      (error "~S had illegal value ~S.  Reset to ~S"
             '*print-base* base 10))
    base))

(defun write-radix (base stream)
  (stream-write-char stream #\#)
  (case base
    (2 (stream-write-char stream #\b))
    (8 (stream-write-char stream #\o))
    (16 (stream-write-char stream #\x))
    (t (%pr-integer base 10. stream)
       (stream-write-char stream #\r))))

(defun write-an-integer (num stream
                         &optional (base (get-*print-base*))
                                   (print-radix *print-radix*))
  (when (and print-radix (not (eq base 10)))
    (write-radix base stream))
  (%pr-integer num base stream)
  (when (and print-radix (eq base 10))
    (stream-write-char stream #\.)))

(defmethod print-object ((num integer) stream)
  (write-an-integer num stream))

(defun %write-address (object stream &optional foo)
  (if foo (pp-space stream))
  (write-an-integer (if (integerp object) object (%address-of object)) stream 16. t)
  (if foo (pp-end-block stream foo)))

(defmethod print-object ((num ratio) stream)
  (let ((base (get-*print-base*)))
    (when *print-radix*
      (write-radix base stream))
    (%pr-integer (numerator num) base stream)
    (stream-write-char stream #\/)
    (%pr-integer (denominator num) base stream)))

;;>> Doesn't do *print-level* truncation
(defmethod print-object ((c complex) stream)
  (pp-start-block stream "#C(")
  (print-object (realpart c) stream)
  (pp-space stream)
  (print-object (imagpart c) stream)
  (pp-end-block stream #\)))

(defmethod print-object ((float float) stream)
  (print-a-float float stream))

(defun float-exponent-char (float)
  (if (case *read-default-float-format*
        (single-float (typep float 'single-float))
        (double-float (typep float 'double-float))
        (t (typep float *read-default-float-format*)))
    #\E  
    (if (typep float 'double-float)
      #\D
      #\S)))

(defun default-float-p (float)
  (case *read-default-float-format*
        (single-float (typep float 'single-float))
        (double-float (typep float 'double-float))
        (t (typep float *read-default-float-format*))))


(defun print-a-nan (float stream)
  (if (infinity-p float)
      (output-float-infinity float stream)
      (output-float-nan float stream)))

(defun output-float-infinity (x stream)
  (declare (float x) (stream stream))
  (format stream "~:[-~;~]1~c++0"
	  (plusp x)
	  (if (typep x *read-default-float-format*)
	      #\E
	      (typecase x
		(double-float #\D)
		(single-float #\S)))))

(defun output-float-nan (x stream)
  (declare (float x) (stream stream))
  (format stream "1~c+-0 #| not-a-number |#"
	  (if (typep x *read-default-float-format*)
	      #\E
	      (etypecase x
		(double-float #\D)
		(single-float #\S)))))

(defun print-float-free-form-1 (string before-pt stream)
  (declare (fixnum before-pt))
  (let ((strlen (length string)))
    (declare (fixnum strlen))
    (cond ((zerop strlen)
	   (stream-write-entire-string stream "0.0"))
	  ((> before-pt 0)
	   (cond ((> strlen before-pt)
		  (write-string string stream :start 0 :end before-pt)
		  (stream-write-char stream #\.)
		  (write-string string stream :start before-pt :end strlen))
		 (t ; 0's after
		  (stream-write-entire-string stream string)
		  (dotimes (i (- before-pt strlen))
		    (stream-write-char stream #\0))
		  (stream-write-entire-string stream ".0"))))
	  (t
	   (stream-write-entire-string stream "0.")
	   (dotimes (i (- before-pt))
	     (stream-write-char stream #\0))
	   (stream-write-entire-string stream string)))))

(defun print-float-free-form (float stream)
  (setq stream (%real-print-stream stream))
  (if (nan-or-infinity-p float)
    (print-a-nan float stream)
    (multiple-value-bind (string before-pt)
	(flonum-to-string float)
      (when (minusp (float-sign float))
	(stream-write-char stream #\-))
      (print-float-free-form-1 string before-pt stream))))

;; nanning => recursive from print-a-nan - don't check again
(defun print-a-float (float stream &optional exp-p nanning)
  (let ((strlen 0)
	(exponent-char (float-exponent-char float)))
    (declare (fixnum strlen))
    (setq stream (%real-print-stream stream))
    (if (and (not nanning)(nan-or-infinity-p float))
      (print-a-nan float stream)
      (multiple-value-bind (string before-pt)
                           (flonum-to-string float)
        (declare (fixnum before-pt))
        (setq strlen (length string))
        (when (minusp (float-sign float))
          (stream-write-char stream #\-))
        (cond
	 ((and (not exp-p)
	       (> before-pt -3)
	       (<= before-pt 7))
	  (print-float-free-form-1 string before-pt stream))
         (t
          (setq exp-p t)
          (stream-write-char stream (if (> strlen 0)(char string 0) #\0))
          (stream-write-char stream #\.)
          (if (> strlen 1)
            (write-string string stream :start  1 :end strlen)
            (stream-write-char stream #\0))
          (stream-write-char stream exponent-char)
          (when (and exp-p (not (minusp (1- before-pt))))
            (stream-write-char stream #\+))
          (let ((*print-base* 10)
                (*print-radix* nil))
            (princ (1- before-pt) stream))))
        (when (and (not exp-p)
                   (not (default-float-p float)))
          (stream-write-char stream exponent-char)
          (stream-write-char stream #\0))))))

;;>> Doesn't do *print-level* truncation
(defmethod print-object ((class class) stream)
  (print-unreadable-object (class stream)
    (print-object (class-name (class-of class)) stream)
    (pp-space stream)
    (print-object (class-name class) stream)))


(defmethod print-object ((value-cell value-cell) stream)
  (print-unreadable-object (value-cell stream :type t :identity t)
    (prin1 (uvref value-cell target::value-cell.value-cell) stream)))

;(defun symbol-begins-with-vowel-p (sym)
;  (and (symbolp sym)
;       (not (%izerop (%str-length (setq sym (symbol-name sym)))))
;       (%str-member (schar sym 0) "AEIOU")))

;;;; ----------------------------------------------------------------------
;;;; CLOSsage

(defmethod print-object ((instance standard-object) stream)
  (if (%i<= %current-write-level% 0)    ; *print-level* truncation
      (stream-write-entire-string stream "#")
      (print-unreadable-object (instance stream :identity t)
        (let* ((class (class-of instance))
               (class-name (class-name class)))
          (cond ((not (and (symbolp class-name)
                           (eq class (find-class class-name nil))))
                 (%write-string "An instance of" stream)
                 (pp-space stream)
                 (print-object class stream))
                (t
                 (write-a-symbol class-name stream)))))))

(defmethod print-object ((method standard-method) stream)
  (print-method method stream (%class.name (class-of method))))

(defmethod print-object ((method-function method-function) stream)
  (let ((method (%method-function-method method-function)))
    (if (typep method 'standard-method)
      (print-method (%method-function-method method-function)
                    stream
                    (%class.name (class-of method-function)))
      (call-next-method))))



(defun print-method (method stream type-string)
  (print-unreadable-object (method stream)
    (let ((name (%method-name method))
          (qualifiers (%method-qualifiers method))
          (specializers (mapcar #'(lambda (specializer)
                                    (if (typep specializer 'eql-specializer)
				      (list 'eql
					    (eql-specializer-object specializer))
				      (or (class-name specializer)
					  specializer)))
                                (%method-specializers method)))
          (level-1 (%i- %current-write-level% 1)))
      (cond
       ((< level-1 0)
        ;; *print-level* truncation
        (stream-write-entire-string stream "#"))
       (t 
        (prin1 type-string stream)
        (pp-space stream)
        (write-internal stream name level-1 nil)
        (pp-space stream)
        (when qualifiers
          (write-internal stream (if (cdr qualifiers) qualifiers (car qualifiers))
                          level-1 nil)
          (pp-space stream))
        (write-internal stream specializers level-1 nil))))))

;; Need this stub or we'll get the standard-object method
(defmethod print-object ((gf standard-generic-function) stream)
  (write-a-function gf stream (%current-write-level% stream)))

;; This shouldn't ever happen, but if it does, don't want the standard-object method
(defmethod print-object ((mo metaobject) stream)
  (print-unreadable-object (mo stream :type t :identity t)))

(defmethod print-object ((cm combined-method) stream)
  (print-unreadable-object (cm stream :identity t)
    (%write-string "Combined-Method" stream)
    (pp-space stream)
    (let ((name (function-name cm)))
      (if (and (functionp name) (function-is-current-definition? name))
        (setq name (function-name name)))
      (write-internal stream name (%current-write-level% stream) nil))))

(defun print-specializer-names (specializers stream)
  (flet ((print-specializer (spec stream)
           (write-1 (if (typep spec 'class) (%class.name spec) spec) stream)))
    (pp-start-block stream #\()
    (if (atom specializers)
        (print-specializer specializers stream)
      (progn (print-specializer (car specializers) stream)
             (dolist (spec (cdr specializers))
               (pp-space stream)
               (print-specializer spec stream))))
    (pp-end-block stream #\))))


;;;; ----------------------------------------------------------------------
            
(defun write-a-cons (cons stream level)
  (declare (type cons cons) (type stream stream) (type fixnum level))
  (let ((print-length (get-*print-frob* '*print-length*))
        (level-1 (%i- level 1))
        (head (%car cons))
        (tail (%cdr cons)))
    (declare (type fixnum print-length) (type fixnum level-1))
    (unless (and *print-abbreviate-quote*
                 (write-abbreviate-quote head tail stream level-1))
        (progn
          (pp-start-block stream #\()
          (if (= print-length 0)
              (%write-string "..." stream)
              (progn
                (write-internal stream head level-1 nil)
                (write-internal stream tail level-1
                                (if (atom tail)
                                  print-length
                                  (%i- print-length 1)))))
          (pp-end-block stream #\))))))

;;;; hack for quote and backquote

;; for debugging
;(setq *backquote-expand* nil)

(defvar *backquote-hack* (list '*backquote-hack*)) ;uid
(defun write-abbreviate-quote (head tail stream level-1)
  (declare (type stream stream) (type fixnum level-1))
  (when (symbolp head)
    (cond ((or (eq head 'quote) (eq head 'function))
           (when (and (consp tail)
                      (null (%cdr tail)))
             (%write-string (if (eq head 'function) "#'" "'") stream)
             (write-internal stream (%car tail) level-1 nil)
             t))
          ((eq head 'backquote-expander)
           (when (and (consp tail)
		      (consp (cdr tail))
		      (consp (cddr tail))
		      (consp (cdddr tail))
		      (null (cddddr tail)))
             (let ((tail tail))
               (set (%car tail)
                    *backquote-hack*)  ;,
               (set (%car (setq tail (%cdr tail)))
                    *backquote-hack*)  ;,.
               (set (%car (setq tail (%cdr tail)))
                    *backquote-hack*)  ;,@
               (stream-write-char stream #\`)
               (write-internal stream (%cadr tail) level-1 nil)
               t)))
          ((and (boundp head)
                (eq (symbol-value head) *backquote-hack*))
           ;;",foo" = (#:|,| . foo)
           (stream-write-char stream #\,)
           (let* ((n (symbol-name head))
                  (l (length n)))
             (declare (type simple-string n) (type fixnum l))
             ;; possibilities are #:|`,| #:|,.| and #:|,@|
             (if (eql l 3)
               (stream-write-char stream (schar n 2)))
             (write-internal stream tail level-1 nil)
             t))
          (t nil))))

(eval-when (compile eval)
(defmacro %char-needs-escape-p (char escape &rest losers)
  (setq losers (remove-duplicates (cons escape losers)))
  (setq char (require-type char 'symbol))
  (dolist (c losers)
    (unless (or (characterp c) (symbolp c)) (report-bad-arg c '(or character symbol))))
  (cond ((null (cdr losers))
         `(eq ,char ,escape))
        ((and (every #'characterp losers)
              ;(every #'string-char-p losers)
              (%i> (length losers) 2))
         `(%str-member ,char ,(concatenate 'string losers)))
        (t
         `(or ,@(mapcar #'(lambda (e) `(eq ,char ,e))
                        losers)))))

(defmacro %write-escaped-char (stream char escape &rest losers)
  `(progn
     (when (%char-needs-escape-p ,char ,escape ,@losers)
       (stream-write-char ,stream ,escape))
     (stream-write-char ,stream ,char)))
)

(defun write-escaped-string (string stream &optional (delim #\"))
  (declare (type string string) (type character delim)
           (type stream stream))
  (write-char delim stream)
  (do* ((limit (length string))
        (i 0 (1+ i)))
       ((= i limit))
    (declare (type fixnum limit) (type fixnum i))
    (let* ((char (char string i))
           (needs-escape? (%char-needs-escape-p char #\\ delim)))
      (if needs-escape?
          (write-char #\\ stream))
      (write-char char stream)))
  (write-char delim stream))


;;;; ----------------------------------------------------------------------
;;;; printing symbols

(defun get-*print-case* ()
  (let ((case *print-case*))
    (unless (or (eq case ':upcase) (eq case ':downcase) 
                (eq case ':capitalize) (eq case ':studly))
      (setq *print-case* ':upcase)
      (error "~S had illegal value ~S.  Reset to ~S"
             '*print-case* case ':upcase))
    case))

(defun write-a-symbol (symbol stream)
  (declare (type symbol symbol) (type stream stream))
  (let ((case (get-*print-case*))
        (name (symbol-name symbol))
        (package (symbol-package symbol)))
    (declare (type simple-string name))
    (when (or *print-readably* *print-escape*)
      (cond ((keywordp symbol)
             (stream-write-char stream #\:))
            ((null package)
             (when (or *print-readably* *print-gensym*)
               (stream-write-char stream #\#)
               (stream-write-char stream #\:)))
            (t
             (multiple-value-bind (s flag)
                                  (find-symbol name *package*)
               (unless (and flag (eq s symbol))
                 (multiple-value-setq (s flag)
                                      (find-symbol name package))
                 (unless (and flag (eq s symbol))
                   (%write-string "#|symbol not found in home package!!|#"
                                  stream))
                 (write-pname (package-name package) case stream)
                 (stream-write-char stream #\:)
                 (unless (eq flag ':external)
                   (stream-write-char stream #\:)))))))
    (write-pname name case stream)))



(defun write-pname (name case stream)
  (declare (type simple-string name) (stream stream)
           (optimize (speed 3)(safety 0)))
  (let* ((readtable *readtable*)
         (syntax-readtable (if *print-readably*
                             %initial-readtable%
                             readtable))
         (readcase (readtable-case syntax-readtable))
         (attrtab (rdtab.ttab syntax-readtable))
         (escape? (or *print-readably* *print-escape*))
         (needs-escape nil))
    (flet ((slashify? (char)
             (declare (type character char))
             (and escape?                  
                  (or (and (eq readcase :upcase) (lower-case-p char))
                      (and (eq readcase :downcase) (upper-case-p char))
                      (eql char #\:)
                      (not (eql $cht_cnst (%character-attribute char attrtab))))))
             (single-case-p (name)
                            (let ((sofar nil))
                              (dotimes (i (length name) sofar)
                                (declare (type fixnum i))
                                (declare (type simple-string name))
                                (let* ((c (schar name i))
                                       (c-case (if (upper-case-p c)
                                                 :upcase
                                                 (if (lower-case-p c)
                                                   :downcase))))
                                  (when c-case
                                    (if sofar 
                                      (if (neq sofar c-case)
                                        (return nil))
                                      (setq sofar c-case))))))))
           (declare (dynamic-extent #'slashify? #'single-case-p))
           (block alice
             (let ((len (length name))
                   (slash-count 0)
                   (last-slash-pos 0))
               (declare (type fixnum len)
                        (type fixnum slash-count last-slash-pos))                
               (when escape?
                 (when (or (%izerop len)
                           ;; if more than a few \, just use |...|
                           (and;;(not (memq readcase '(:invert :preserve))) ; these never slashify alpha-p
                            (let ((m (max (floor len 4) 2)))
                              (dotimes (i (the fixnum len) nil)
                                (declare (type fixnum i)) 
                                (when (slashify? (schar name i))
                                  (setq slash-count (%i+ slash-count 1)
                                        needs-escape t)
                                  (when (or (eql slash-count m)
                                            (eq i (1+ last-slash-pos)))
                                    (return t))
                                  (setq last-slash-pos i)))))
                           ;; or could be read as a number
                           (handler-case (%parse-number-token name 0 len *print-base*)
                             (arithmetic-error (c)
                                               (declare (ignore c))))
                           ;; or symbol consisting entirely of .'s
                           (dotimes (i len (setq needs-escape t))
                             (declare (fixnum i))
                             (unless (eql (schar name i) #\.)
                               (return nil))))
                   (return-from alice
                     (write-escaped-string name stream #\|))))
               (case readcase
                 (:preserve (return-from alice
                              (if needs-escape
                                (write-escaped-string name stream #\|)
                                (write-string name stream :start  0 :end len))))
                           
                 (:invert (return-from alice
                            (cond ((single-case-p name)
                                   (write-perverted-string name stream len :invert (if needs-escape #\|)))
                                  (t (if needs-escape
                                       (write-escaped-string name stream #\|)
                                       (write-string name stream :start  0 :end len))))))
                 (t 
                  (when (eql slash-count 0)
                    (return-from alice
                      (cond ((eq readcase case)
                             (write-string name stream :start  0 :end len))
                            (t (write-perverted-string name stream len case)))))))
               (let* ((outbuf-len (+ len len))
                      (outbuf-ptr -1)
                      (outbuf (make-string outbuf-len)))
                 (declare (fixnum outbuf-ptr outbuf-len)
                          (dynamic-extent outbuf)
                          (simple-string outbuf))
                 (dotimes (pos (the fixnum len))
                   (declare (type fixnum pos))
                   (let* ((char (schar name pos))
                          (slashify? (cond ((eql slash-count 0)
                                            nil)
                                           ((eql slash-count 1)
                                            (eql pos last-slash-pos))
                                           (t
                                            (slashify? char)))))
                     (declare (type character char))
                     (when slashify?
                       (setq slash-count (%i- slash-count 1))
                       (setf (schar outbuf (incf outbuf-ptr)) #\\))
                     (setf (schar outbuf (incf outbuf-ptr)) char)))
                 (write-string outbuf stream :start  0 :end (1+ outbuf-ptr))))))))

#|
(defun write-studly-string (string stream)
  (declare (type string string) (stream stream))
  (let* ((offset 0)
         (end (length string))
         (pool *pname-buffer*)
         (outbuf-ptr -1)
         (outbuf (pool.data pool)))
    (declare (fixnum offset end outbuf-ptr))
    (setf (pool.data pool) nil)
    (unless (and outbuf (>= (length outbuf) end))
      (setq outbuf (make-array end :element-type 'character)))
    (do ((i 0 (%i+ i 1)))
        ((%i>= i end))
      (declare (type fixnum i))
      (setq offset (%i+ offset (char-int (char string i)))))
    (do ((i 0 (%i+ i 1)))
        ((%i>= i end))
      (declare (type fixnum i))
      (let ((c (char string i)))
        (declare (type character c))
        (cond ((not (and (%i< (%ilogand2
                                     (%i+ (char-int c) offset)
                                     15.)
                                   6.)
                         (alpha-char-p c))))
              ((upper-case-p c)
               (setq c (char-downcase c)))
              (t
               (setq c (char-upcase c))))
        (setf (schar outbuf (incf outbuf-ptr)) c)))
    (write-string outbuf stream :start  0 :end end)
    (setf (pool.data pool) outbuf)))
|#

(defun write-perverted-string (string stream end type &optional escape)
  ;; type :invert :upcase :downcase :capitalize or :studly
  (declare (fixnum end))
  (let* ((readtable *readtable*)
         (readcase (readtable-case readtable))
         (outbuf-ptr -1)
         (outbuf (make-string (+ end
				 (if escape 2 0)
				 (count-if (lambda (c)
					     (or (eql c escape)
						 (eql c #\\)))
					   string :end end))))
         (word-start t)
         (offset 0))
    (declare (fixnum offset outbuf-ptr)
             (dynamic-extent outbuf))
    (when (eq type :studly)
      (do ((i 0 (%i+ i 1)))
          ((%i>= i end))
        (declare (type fixnum i))
        (setq offset (%i+ offset (char-int (char string i))))))
    (when escape
      (setf (schar outbuf (incf outbuf-ptr)) escape))
    (do ((i 0 (%i+ i 1)))
        ((%i>= i end))
      (declare (type fixnum i))
      (let ((c (char string i)))
        (declare (type character c))        
        (cond ((alpha-char-p c)
               (case type
                 (:studly
                  (cond ((not (%i< (%ilogand2
                                    (%i+ (char-int c) offset)
                                    15.)
                                   6.)))
                        ((upper-case-p c)
                         (setq c (char-downcase c)))
                        (t
                         (setq c (char-upcase c)))))
                 (:invert
                  (setq c (if (upper-case-p c)(char-downcase c)(char-upcase c))))
                 (:upcase
                  (setq c (char-upcase c)))
                 (:downcase
                  (setq c (char-downcase c)))
                 (:capitalize (setq c (cond (word-start
                                             (setq word-start nil)
                                             (if (eq readcase :upcase)
                                                 c
                                                 (char-upcase c)))
                                            (t
                                             (if (eq readcase :upcase)
                                                 (char-downcase c)
                                                 c)))))))
              ((or (eql c escape) (eql c #\\))
               (setf (schar outbuf (incf outbuf-ptr)) #\\))
              ((digit-char-p c)(setq word-start nil))
              (t (setq word-start t)))
        (setf (schar outbuf (incf outbuf-ptr)) c)))
    (when escape
      (setf (schar outbuf (incf outbuf-ptr)) escape))
    (write-string outbuf stream :start  0 :end (1+ outbuf-ptr))))


;;;; ----------------------------------------------------------------------
;;;; printing arrays

;; *print-array*
;; *print-simple-vector*
;; *print-simple-bit-vector*
;; *print-string-length*

(defun array-readably-printable-p (array)
  (let ((dims (array-dimensions array)))
    (and (eq (array-element-type array) t)
         (let ((zero (position 0 dims))
               (number (position 0 dims
                                 :test (complement #'eql)
                                 :from-end t)))
           (or (null zero) (null number) (> zero number))))))

(defun write-an-array (array stream level)
  (declare (type array array) (type stream stream) (type fixnum level))
  (let* ((rank (array-rank array))
         (vector? (eql rank 1))
         (simple? (simple-array-p array))
         (simple-vector? (simple-vector-p array))
         ;; non-*print-string-length*-truncated strings are printed by
         ;;  write-a-frob
         (string? (stringp array))
         (bit-vector? (bit-vector-p array))
         (fill-pointer? (array-has-fill-pointer-p array))
         (adjustable? (adjustable-array-p array))
         (displaced? (displaced-array-p array))
         (total-size (array-total-size array))
         (length (and vector? (length array)))
         (print-length (get-*print-frob* '*print-length*))
         (print-array (get-*print-frob* '*print-array* nil t)))
    (declare (type fixnum rank) (type fixnum total-size)
             (type fixnum print-length))
    (unless
      (cond (string?
             nil)
            ((and bit-vector? print-array)
             (stream-write-char stream #\#) (stream-write-char stream #\*)
             (do ((i 0 (%i+ i 1))
                  (l print-length (%i- l 1)))
                 (nil)
               (declare (type fixnum i) (type fixnum l))
               (cond ((eql i length)
                      (return))
                     (t
                      (stream-write-char stream (if (eql (bit array i) 0) #\0 #\1)))))
             t)
            ((and *print-readably*
                  (not (array-readably-printable-p array)))
             nil)
            ((and *print-pretty* print-array)
             (let ((*current-level* (if (and *print-level* (not *print-readably*))
                                      (- *print-level* level)
                                      0)))
               (pretty-array stream array))
             t)
            (vector?
             (when (or print-array
                       (and simple-vector?
                            (%i<= length (get-*print-frob* 
                                          '*print-simple-vector*
                                          0
                                          target::target-most-positive-fixnum))))
               (pp-start-block stream "#(")
               (do ((i 0 (%i+ i 1))
                    (l print-length (%i- l 1)))
                   (nil)
                 (declare (type fixnum i) (type fixnum l))
                 (cond ((eql i length)
                        (return))
                       ((eql l 0)
                        ;; can't use write-abbreviation since there is
                        ;;  no `object' for the abbreviation to represent
                        (unless (eql i 0) (pp-space stream))
                        (%write-string "..." stream)
                        (return))
                       (t (unless (eql i 0) (pp-space stream))
                          (write-internal stream (aref array i) (%i- level 1) nil))))
               (pp-end-block stream #\))
               t))
            ((and print-array (not fill-pointer?))
             (let ((rank (array-rank array)))
               (stream-write-char stream #\#)
               (%pr-integer rank 10. stream)
               (stream-write-char stream #\A)
               (if (eql rank 0)
                 (write-internal stream (aref array) (%i- level 1) nil)
                 (multiple-value-bind (array-data offset)
                                      (array-data-and-offset array)
                   (write-array-elements-1 
                     stream level
                     array-data offset
                     (array-dimensions array)))))
             t)
            (t 
             ;; fall through -- print randomly
             nil))
      ;; print array using #<...>
      (print-unreadable-object (array stream)
        (if vector?
          (progn
            (write-a-symbol (cond (simple-vector?
                                   'simple-vector)
                                  (string?
                                   (if simple? 'simple-string 'string))
                                  (bit-vector?
                                   (if simple? 'simple-bit-vector 'bit-vector))
                                  (t 'vector))
                            stream)
            (pp-space stream)
            (%pr-integer total-size 10. stream)
            (when fill-pointer?
              (let ((fill-pointer (fill-pointer array)))
                (declare (fixnum fill-pointer))
                (pp-space stream)
                (%write-string "fill-pointer" stream)
                (unless (eql fill-pointer total-size)
                  (stream-write-char stream #\space)
                  (%pr-integer fill-pointer 10. stream)))))
          (progn
            (write-a-symbol 'array stream)
            (pp-space stream)
            (if (eql rank 0) (%write-string "0-dimensional" stream))
            (dotimes (i (the fixnum rank))
              (unless (eql i 0) (stream-write-char stream #\x))
              (%pr-integer (array-dimension array i) 10. stream))))
        (let ((type (array-element-type array)))
          (unless (or simple-vector? string? bit-vector?   ; already written "#<string" or whatever
                      (eq type 't))
            (pp-space stream)
            (%write-string "type " stream)
            (write-internal stream type
                            ;; yes, I mean level, not (1- level)
                            ;; otherwise we end up printing things
                            ;; like "#<array 4 type #>"
                            level nil)))
        (cond (simple?
               (unless (or simple-vector? string? bit-vector?)
                 ;; already written "#<simple-xxx"
                 (stream-write-char stream #\,)
                 (pp-space stream)
                 (%write-string "simple" stream)))
              (adjustable?
               (stream-write-char stream #\,)
               (pp-space stream)
               (%write-string "adjustable" stream))
              (displaced?
               ;; all multidimensional (and adjustable) arrays in ccl are
               ;;  displaced, even when they are simple-array-p
               (stream-write-char stream #\,)
               (pp-space stream)
               (%write-string "displaced" stream)))
        ;; (when stack-allocated? ...) etc, etc
        (when (and string? (%i> length 20))
          (flet ((foo (stream string start end)
                      (declare (type fixnum start) (type fixnum end)
                               (type string string))
                      (do ((i start (%i+ i 1)))
                          ((%i>= i end))
                        (let ((c (char string i)))
                          (declare (type character c))
                          (if (not (graphic-char-p c))
                            (return)
                            (%write-escaped-char stream c #\\ #\"))))))
            #|(%write-string " \"" stream)|# (pp-space stream)
            (foo stream array 0 12)
            (%write-string "..." stream)
            (foo stream array (%i- length 6) length)
              #|(stream-write-char stream #\")|#))))))

(defun write-array-elements-1 (stream level
                               array-data offset
                               dimensions)
  (declare (type stream stream) (type fixnum level) 
           (type vector array-data) (type fixnum offset)
           (type list dimensions))
  (block written
    (let ((tail (%cdr dimensions))
          (print-length (get-*print-frob* '*print-length*))
          (level-1 (%i- level 1))
          (limit (%car dimensions))
          (step 1))
      (when (and (null tail)
                 (%i> level-1 0)
                 (or (bit-vector-p array-data)
                     (and (stringp array-data)
                          (%i<= limit print-length))))
        (return-from written
          ;;>> cons cons.  I was lazy.
          ;;>>  Should code a loop to write the elements instead
          (write-an-array (%make-displaced-array
                            ;; dimensions displaced-to
                            limit array-data 
                            ;; fill-pointer adjustable
                            nil nil
                            ;; displaced-index-offset
                            offset)
                          stream level-1)))
      (pp-start-block stream #\()
      (dolist (e tail) (setq step (%i* e step)))
      (do* ((o offset (%i+ o step))
            (i 0 (1+ i)))
           (nil)
        (declare (type fixnum o) (type fixnum i) (type fixnum limit)
                 (type fixnum step) (type fixnum print-length) 
                 (type fixnum level-1))
        (cond ((eql i print-length)
               (%write-string " ..." stream)
               (return))
              ((eql i limit)
               (return))
              ((= i 0))
              (t
               (pp-space stream (if (null tail) ':fill ':linear))))
        (cond ((null tail)
               (write-internal stream (aref array-data o) level-1 nil))
              ((eql level-1 0)
               ;; can't use write-abbreviation since this doesn't really
               ;;  abbreviate a single object
               (stream-write-char stream #\#))
              (t
               (write-array-elements-1 stream level-1
                                       array-data o tail))))
      (pp-end-block stream #\)))))
    
;;;; ----------------------------------------------------------------------

; A "0" in the sd-print-function => inherit from superclass.
(defun structure-print-function (class)
  (let* ((pf (ccl::sd-print-function class))
         (supers (cdr (sd-superclasses class))))
    (do* ()
         ((neq pf 0) pf)
      (if supers 
        (setq pf (sd-print-function (gethash (pop supers) %defstructs%)))
        (return)))))

(defun write-a-structure (object stream level)
  (declare (type stream stream) (type fixnum level))
  (let* ((class (ccl::struct-def object)) ;;guaranteed non-NIL if this function is called
         (pf (structure-print-function class)))
    (cond (pf
	   (if (consp pf)
	     (funcall (%car pf) object stream)
	     (funcall pf 
		      object stream (backtranslate-level level))))
          ((and (not *print-structure*) (not *print-readably*))
           (print-unreadable-object (object stream :identity t)
            (write-a-symbol (ccl::sd-name class) stream)))
          (t
           (let ((level-1 (ccl::%i- level 1))
                 (slots (cdr (ccl::sd-slots class)))
                 (print-length (get-*print-frob* '*print-length*)))
             (declare (type fixnum level-1) (type list slots))
             (%write-string "#S(" stream)
             (if (%i> print-length 0)
                 (write-a-symbol (ccl::sd-name class) stream)
                 (progn (%write-string "...)" stream)
                        (return-from write-a-structure)))
             (when (and slots (%i> print-length 1))
               (pp-start-block stream #\Space))
             (do ((l (%i- print-length 1) (%i- l 2))
                  (first? t)
                  (print-case (get-*print-case*)))
                 (nil)
               (declare (type fixnum l))
               (cond ((null slots)
                      (return))
                     ((%i< l 1)
                      ;; Note write-abbreviation since it isn't abbreviating an object
                      (%write-string " ..." stream)
                      (return)))
               (let* ((slot (prog1 (%car slots)
                              (setq slots (%cdr slots))))
                      (symbol (ccl::ssd-name slot)))
                 (when (symbolp symbol)
                   (if first?
                       (setq first? nil)
                       (pp-space stream ':linear))
                   (stream-write-char stream #\:)
                   (write-pname (symbol-name symbol) print-case stream)
                   (cond ((%i> l 1)
                          (pp-space stream)
                          (write-internal stream (uvref object (ccl::ssd-offset slot))
                                            level-1 nil))
                         (t (%write-string " ..." stream)
                            (return)))))))
           (pp-end-block stream #\))))))

(%fhave 'encapsulated-function-name ;(fn) ;Redefined in encapsulate
        (qlfun bootstrapping-encapsulated-function-name (fn)
          (declare (ignore fn))
          nil))


(%fhave '%traced-p ;(fn) ;Redefined in encapsulate
        (qlfun bootstrapping-%traced-p (fn)
          (declare (ignore fn))
          nil))

(%fhave '%advised-p ;(fn) ;Redefined in encapsulate
        (qlfun bootstrapping-%advised-p (fn)
          (declare (ignore fn))
          nil))



(defun write-a-function (lfun stream level)  ; screwed up
  (print-unreadable-object (lfun stream :identity t)
    (let* ((name (function-name lfun))
           ; actually combined-method has its oun print-object method and doesn't get here.
           ; standard-generic-function has a print-object method that just calls this.
           (gf-or-cm (or (standard-generic-function-p lfun) (combined-method-p lfun))))
      (cond ((and (not (compiled-function-p lfun))
                  (not gf-or-cm))
             ; i.e. closures
             (write-internal stream (%type-of lfun) level nil)
             (when name
               (pp-space stream)
               (write-internal stream name (%i- level 1) nil)))
            ((not name)
             (%lfun-name-string lfun stream t))
            (t
             (if gf-or-cm
               (write-internal stream (class-name (class-of lfun)) level nil)
               (%write-string (cond ((typep lfun 'method-function)
                                     "Compiled Method-function")
                                    (t "Compiled-function"))
                            stream))
             (stream-write-char stream #\space)
             (write-internal stream name (%i- level 1) nil)
             (cond ((and (symbolp name) (eq lfun (macro-function name)))
                    (%write-string " Macroexpander" stream)) ;What better?                 
                   ((not (function-is-current-definition? lfun))
                    ;;>> Nice if it could print (Traced), (Internal), (Superseded), etc
                    (cond ((%traced-p name)
                           (%write-string " (Traced Original) " stream))
                          ((%advised-p name)
                           (%write-string " (Advised Original) " stream))
                          (t (%write-string " (Non-Global) " stream))))))))))


(defun function-is-current-definition? (function)
  (let ((name (function-name function)))
    (and name
         (valid-function-name-p name)
         (eq function (fboundp name)))))

;; outputs to stream or returns a string.  Barf!
;; Making not matters not worse ...
(defun %lfun-name-string (lfun &optional stream suppress-address)
  (unless (functionp lfun) (report-bad-arg lfun 'function))
  (if (null stream)
    (with-output-to-string (s) (%lfun-name-string lfun s))
    (let ((name (function-name lfun)))
      (if name
	(prin1 name stream)
	(let* ((fnaddr (%address-of lfun)))
	  (%write-string "Anonymous " stream)
	  (if (standard-generic-function-p lfun)
	    (prin1 (class-name (class-of lfun)) stream)
	    (%write-string "Function" stream))
	  (unless suppress-address
	    (stream-write-char stream #\ )
	    (write-an-integer  fnaddr
			       stream 16. t)))))))


;;;; ----------------------------------------------------------------------

(defun write-a-package (pkg stream)
  (print-unreadable-object (pkg stream)
    (if (null (pkg.names pkg))
      (%write-string "Deleted Package" stream)
      (progn
        (%write-string "Package " stream)
        (write-escaped-string (package-name pkg) stream)))))



(defun write-a-macptr (macptr stream)
  (let* ((null (%null-ptr-p macptr)))
    (print-unreadable-object (macptr stream)
      (if null
	(progn
	  (%write-string "A Null Foreign Pointer" stream))
	(progn
	  (pp-start-block stream "A Foreign Pointer")
	  (%write-macptr-allocation-info macptr stream)
	  (stream-write-char stream #\ )
          (%write-macptr-type-info macptr stream)
	  (write-an-integer (%ptr-to-int macptr) stream 16. t))))))

(defun %macptr-allocation-string (macptr)
  (if (or (on-any-csp-stack macptr)
          #-arm-target
          (on-any-tsp-stack macptr))
    "[stack-allocated]"
    (if (eql (uvsize macptr) target::xmacptr.element-count)
      "[gcable]")))

(defun %write-macptr-allocation-info (macptr stream)
  (let* ((s (%macptr-allocation-string macptr)))
    (if s (format stream " ~a" s))))

(defun %write-macptr-type-info (macptr stream)
  (let* ((ordinal (%macptr-type macptr)))
    (unless (eql 0 ordinal)
      (let* ((type (gethash ordinal (ftd-ordinal-types *target-ftd*)))
             (form
              (if (typep type 'foreign-record-type)
                `(:* (,(foreign-record-type-kind type)
                        ,(foreign-record-type-name type)))
                `(:* ,(unparse-foreign-type type)))))
        (when form (format stream "~s " form))))))
          


; This special-casing for wrappers is cheaper than consing a class
(defun write-an-istruct (istruct stream level)
  (let* ((type (istruct-cell-name (uvref istruct 0)))
         (wrapper-p  (eq type 'class-wrapper)))
    (print-unreadable-object (istruct stream :identity t)
      (write-internal stream type (%i- level 1) nil)
      (when wrapper-p
        (pp-space stream)
        (print-object (class-name (%wrapper-class istruct)) stream)))))

(defun write-a-uvector (uvec stream level)
  (declare (ignore level))
  (print-unreadable-object (uvec stream :identity t :type t)))
  

(defmethod print-object ((slotdef slot-definition) stream)
  (print-unreadable-object (slotdef stream :identity t :type t)
    (format stream "for ~a slot ~s"
            (string-downcase (slot-definition-allocation slotdef))
            (standard-slot-definition.name slotdef))))

(defmethod print-object ((spec eql-specializer) stream)
  (print-unreadable-object (spec stream :identity t :type t)
    (format stream "~s" (if (slot-boundp spec 'object)
			  (eql-specializer-object spec)
			  "<unbound>"))))


(defmethod print-object ((slot-id slot-id) stream)
  (print-unreadable-object (slot-id stream :identity t :type t)
    (format stream "for ~s/~d"
            (slot-id.name  slot-id)
            (slot-id.index  slot-id))))

#+x86-target
(defmethod print-object ((tra tagged-return-address) stream)
  (print-unreadable-object (tra stream :identity t :type t)
    (let* ((f (%return-address-function tra))
           (offset (if f (%return-address-offset tra))))
      (when offset
        (format stream "in function ")
        (%lfun-name-string f stream)
        (format stream " (+~d)" offset)))))

#+x8664-target
(defmethod print-object ((sv symbol-vector) stream)
  (print-unreadable-object (sv stream :identity t :type t)
    (format stream "for ~s" (%symptr->symbol (%symvector->symptr sv)))))

#+x8664-target
(defmethod print-object ((fv function-vector) stream)
  (print-unreadable-object (fv stream :identity t :type t)
    (format stream "for ")
    (%lfun-name-string (%function-vector-to-function fv) stream)))

(defmethod print-object ((c class-cell) stream)
  (print-unreadable-object (c stream :type t :identity t)
    (format stream "for ~s" (class-cell-name c))))
  
            

;;; ======================================================================


(defun real-print-stream (&optional (stream nil))
  (cond ((null stream)
         *standard-output*)
        ((eq stream t)
         *terminal-io*)
        ((streamp stream)
         stream)
        ;; This never gets called because streamp is true for xp-structure...
        ((istruct-typep stream 'xp-structure)
         (get-xp-stream stream))
        (t
         (report-bad-arg stream '(or stream (member nil t))))))

(defun write-1 (object stream &optional levels-left)
  (setq stream (%real-print-stream stream))
  (when (not levels-left)
    (setq levels-left
          (if *current-level* 
            (if *print-level*
              (- *print-level* *current-level*)
              target::target-most-positive-fixnum)
            (%current-write-level% stream t))))
  (cond 
   ((< levels-left 0)
    ;; *print-level* truncation
    (stream-write-entire-string stream "#"))
   (t (write-internal stream
                      object 
                      (min levels-left target::target-most-positive-fixnum)
                      nil)))
  object)

;;;; ----------------------------------------------------------------------
;;;; User-level interface to the printer


(defun write (object
              &key (stream *standard-output*)
                   (escape *print-escape*)
                   (radix *print-radix*)
                   (base *print-base*)
                   (circle *print-circle*)
                   (pretty *print-pretty*)
                   (level *print-level*)
                   (length *print-length*)
                   (case *print-case*)
                   (gensym *print-gensym*)
                   (array *print-array*)
                   (readably *print-readably*)
                   (right-margin *print-right-margin*)
                   (miser-width *print-miser-width*)
                   (lines *print-lines*)
                   (pprint-dispatch *print-pprint-dispatch*)
                   ;;>> Do I really want to add these to WRITE??
                   (structure *print-structure*)
                   (simple-vector *print-simple-vector*)
                   (simple-bit-vector *print-simple-bit-vector*)
                   (string-length *print-string-length*))
  "Output OBJECT to the specified stream, defaulting to *STANDARD-OUTPUT*"
  (let ((*print-escape* escape)
        (*print-radix* radix)
        (*print-base* base)
        (*print-circle* circle)
        (*print-pretty* pretty)
        (*print-level* level)
        (*print-length* length)
        (*print-case* case)
        (*print-gensym* gensym)
        (*print-array* array)
        (*print-readably* readably)
        (*print-right-margin* right-margin)
        (*print-miser-width* miser-width)
        (*print-lines* lines)
        (*print-pprint-dispatch* pprint-dispatch)
        ;;>> Do I really want to add these to WRITE??
        (*print-structure* structure)
        (*print-simple-vector* simple-vector)
        (*print-simple-bit-vector* simple-bit-vector)
        (*print-string-length* string-length))
    (write-1 object stream)))

(defun write-to-string (object
                        &key (escape *print-escape*)
                             (radix *print-radix*)
                             (base *print-base*)
                             (circle *print-circle*)
                             (pretty *print-pretty*)
                             (level *print-level*)
                             (length *print-length*)
                             (case *print-case*)
                             (gensym *print-gensym*)
                             (array *print-array*)
                             (readably *print-readably*)
                             (right-margin *print-right-margin*)
                             (miser-width *print-miser-width*)
                             (lines *print-lines*)
                             (pprint-dispatch *print-pprint-dispatch*)
                             ;;>> Do I really want to add these to WRITE??
                             (structure *print-structure*)
                             (simple-vector *print-simple-vector*)
                             (simple-bit-vector *print-simple-bit-vector*)
                             (string-length *print-string-length*))
  "Return the printed representation of OBJECT as a string."
    (let ((*print-escape* escape)
          (*print-radix* radix)
          (*print-base* base)
          (*print-circle* circle)
          (*print-pretty* pretty)
          (*print-level* level)
          (*print-length* length)
          (*print-case* case)
          (*print-gensym* gensym)
          (*print-array* array)
          ;; I didn't really wan't to add these, but I had to.
          (*print-readably* readably)
          (*print-right-margin* right-margin)
          (*print-miser-width* miser-width)
          (*print-lines* lines)
          (*print-pprint-dispatch* pprint-dispatch)
          ;;>> Do I really want to add these to WRITE??
          (*print-structure* structure)
          (*print-simple-vector* simple-vector)
          (*print-simple-bit-vector* simple-bit-vector)
          (*print-string-length* string-length))
      (with-output-to-string (stream)
        (write-1 object stream))))

(defun prin1-to-string (object)
  "Return the printed representation of OBJECT as a string with
   slashification on."
  (with-output-to-string (s)
    (prin1 object s)))

(defun princ-to-string (object)
  "Return the printed representation of OBJECT as a string with
  slashification off."
  (with-output-to-string (s)
    (princ object s)))

(defun prin1 (object &optional stream)
  "Output a mostly READable printed representation of OBJECT on the specified
  STREAM."
  (let ((*print-escape* t))
    (write-1 object stream)))

(defun princ (object &optional stream)
  "Output an aesthetic but not necessarily READable printed representation
  of OBJECT on the specified STREAM."
  (let ((*print-escape* nil)
        (*print-readably* nil))
    (write-1 object stream)))

(defun print (object &optional stream)
  "Output a newline, the mostly READable printed representation of OBJECT, and
  space to the specified STREAM."
  (terpri stream)
  (let ((*print-escape* t))
    (write-1 object stream))
  (write-char #\Space stream)
  object)

; redefined by pprint module if loaded
(defun pprint (object &optional stream)
  (print object stream)
  nil)                                  ; pprint returns nil


(defun read-sequence (seq stream &key (start 0) end)
  "Destructively modify SEQ by reading elements from STREAM.
  That part of SEQ bounded by START and END is destructively modified by
  copying successive elements into it from STREAM. If the end of file
  for STREAM is reached before copying all elements of the subsequence,
  then the extra elements near the end of sequence are not updated, and
  the index of the next element is returned."
  (setq end (check-sequence-bounds seq start end))
  (locally (declare (fixnum start end))
    (if (= start end)
      start
      (seq-dispatch
       seq
       (+ start (the fixnum (stream-read-list
			     stream
			     (nthcdr start seq)
			     (the fixnum (- end start)))))
       (multiple-value-bind (vector offset) (array-data-and-offset seq)
	 (declare (fixnum offset))
	 (-
	  (stream-read-vector
	   stream
	   vector
	   (the fixnum (+ offset start))
	   (the fixnum (+ offset end)))
	  offset))))))



(defun write-sequence (seq stream &key (start 0) end)
  "Write the elements of SEQ bounded by START and END to STREAM."
  (setq end (check-sequence-bounds seq start end))
  (locally (declare (fixnum start end))
    (seq-dispatch
     seq
     (stream-write-list stream (nthcdr start seq) (the fixnum (- end start)))
     (multiple-value-bind (vector offset) (array-data-and-offset seq)
       (stream-write-vector
	stream
	vector
	(the fixnum (+ offset start))
	(the fixnum (+ offset end))))))
  seq)

(defpackage "GRAY"
  (:use)
  (:import-from "CCL"
                "FUNDAMENTAL-STREAM"
                "FUNDAMENTAL-INPUT-STREAM"
                "FUNDAMENTAL-OUTPUT-STREAM"
                "FUNDAMENTAL-CHARACTER-STREAM"
                "FUNDAMENTAL-CHARACTER-INPUT-STREAM"
                "FUNDAMENTAL-CHARACTER-OUTPUT-STREAM"
                "FUNDAMENTAL-BINARY-STREAM"
                "FUNDAMENTAL-BINARY-INPUT-STREAM"
                "FUNDAMENTAL-BINARY-OUTPUT-STREAM"

                "STREAM-READ-CHAR"
                "STREAM-UNREAD-CHAR"
                "STREAM-READ-CHAR-NO-HANG"
                "STREAM-PEEK-CHAR"
                "STREAM-LISTEN"
                "STREAM-READ-LINE"
                "STREAM-CLEAR-INPUT"

                "STREAM-WRITE-CHAR"
                "STREAM-LINE-COLUMN"
                "STREAM-START-LINE-P"
                "STREAM-WRITE-STRING"
                "STREAM-TERPRI"
                "STREAM-FRESH-LINE"
                "STREAM-FORCE-OUTPUT"
                "STREAM-FINISH-OUTPUT"
                "STREAM-CLEAR-OUTPUT"
                "STREAM-ADVANCE-TO-COLUMN"

                "STREAM-READ-BYTE"
                "STREAM-WRITE-BYTE"
                )
  (:export
   "FUNDAMENTAL-STREAM"
   "FUNDAMENTAL-INPUT-STREAM"
   "FUNDAMENTAL-OUTPUT-STREAM"
   "FUNDAMENTAL-CHARACTER-STREAM"
   "FUNDAMENTAL-CHARACTER-INPUT-STREAM"
   "FUNDAMENTAL-CHARACTER-OUTPUT-STREAM"
   "FUNDAMENTAL-BINARY-STREAM"
   "FUNDAMENTAL-BINARY-INPUT-STREAM"
   "FUNDAMENTAL-BINARY-OUTPUT-STREAM"

   "STREAM-READ-CHAR"
   "STREAM-UNREAD-CHAR"
   "STREAM-READ-CHAR-NO-HANG"
   "STREAM-PEEK-CHAR"
   "STREAM-LISTEN"
   "STREAM-READ-LINE"
   "STREAM-CLEAR-INPUT"

   "STREAM-WRITE-CHAR"
   "STREAM-LINE-COLUMN"
   "STREAM-START-LINE-P"
   "STREAM-WRITE-STRING"
   "STREAM-TERPRI"
   "STREAM-FRESH-LINE"
   "STREAM-FORCE-OUTPUT"
   "STREAM-FINISH-OUTPUT"
   "STREAM-CLEAR-OUTPUT"
   "STREAM-ADVANCE-TO-COLUMN"

   "STREAM-READ-BYTE"
   "STREAM-WRITE-BYTE"
))
                
                
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-io.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-unicode.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2006-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


;;; Unicode translation stuff, mostly in support of I/O.

(in-package "CCL")


(defvar *character-encodings* (make-hash-table :test #'eq))

(defun lookup-character-encoding (name)
  (gethash name *character-encodings*))

(defun get-character-encoding (name)
  (or (lookup-character-encoding name)
      (error "Unknown character encoding: ~s." name)))

(defun (setf get-character-encoding) (new name)
  (setf (gethash name *character-encodings*) new))

(defun ensure-character-encoding (thing)
  (if (typep thing 'character-encoding)
    thing
    (or (lookup-character-encoding thing)
        (error "~s is not a character-encoding or the name of a character-encoding."
               thing))))


(defun character-encoded-in-single-octet (c)
  (declare (ignore c))
  1)

(defstruct character-encoding
  (name ())                             ;canonical name
  (code-unit-size 8)                    ;in bits: 8, 16, 32
  (native-endianness t)                 ;if nil, need to swap 16,32-bit units
  (max-units-per-char 1)                ;usually 1-4

  ;; Writes CHAR (or a replacement character if CHAR can't be encoded)
  ;; to STREAM and returns the number of code-units written.
  stream-encode-function                ;(CHAR WRITE-FUNCTION STREAM)
  
  ;; Returns a charcter (possibly #\Replacement_Character) or :EOF.
  stream-decode-function                ;(1ST-UNIT NEXT-UNIT STREAM)

  ;; Sets 1 or more units in a vector argument and returns a value 1
  ;; greater than the index of the last octet written to the vector
  vector-encode-function                ;(STRING VECTOR INDEX START END)
  
  ;; Returns a value 1 greater than the last octet index consumed from
  ;; the vector argument.
  vector-decode-function                ;(VECTOR INDEX NOCTETS STRING)
  
  ;; Sets one or more units in memory at the address denoted by
  ;; the pointer and index arguments and returns (+ idx number of
  ;; units written to memory), else returns NIL if any character
  ;; can't be encoded.
  memory-encode-function                ;(STRING POINTER INDEX START END)

  
  ;; Returns (as multiple values) the  string encoded in memory
  ;; at the address denoted by the address and index args and the
  ;; sum of the index arg and the number of octets consumed.
  memory-decode-function                ;(POINTER NOCTETS INDEX STRING)
  
  ;; Returns the number of octets needed to encode STRING between START and END
  octets-in-string-function              ;(STRING START END)

  ;; Returns the number of (full) characters encoded in VECTOR, and
  ;; the index of the first octet not used to encode
  ;; them. (The second value may be less than END.
  length-of-vector-encoding-function    ;(VECTOR START END) 

  ;; Returns the number of (full) characters encoded in memory at (+ POINTER START)
  ;; and the number of octets used to encode them.  (The second value may be less
  ;; than NOCTETS.)
  length-of-memory-encoding-function    ;(POINTER NOCTETS START)

  ;; Code units less than this value map to themselves on input.
  (decode-literal-code-unit-limit 0)

  ;; Does a byte-order-mark determine the endianness of input ?
  ;; Should we prepend a BOM to output ?
  ;; If non-nil, the value should be the name of the an encoding
  ;; that implements this encoding with swapped byte order.
  (use-byte-order-mark nil)
  ;; What alternate line-termination conventions can be encoded ?  (This basically
  ;; means "can #\Line_Separator be encoded?", since :CR and :CRLF can always
  ;; be encoded.)
  (alternate-line-termination-conventions '(:cr :crlf))
  ;; By what other MIME names is this encoding known ?
  (aliases nil)
  (documentation nil)
  ;; What does a native byte-order-mark look like (as a sequence of octets)
  ;; in this encoding ? (NIL if a BOM can't be encoded.)
  (bom-encoding nil)
  ;; How is #\NUL encoded, as a sequence of octets ?  (Typically, as a minimal-
  ;; length sequenve of 0s, but there are exceptions.)
  (nul-encoding #(0))
  ;; Char-codes less than  this value map to themselves on output.
  (encode-literal-char-code-limit 0)
  (character-size-in-octets-function 'character-encoded-in-single-octet)
  )

(defconstant byte-order-mark #\u+feff)
(defconstant byte-order-mark-char-code (char-code byte-order-mark))
(defconstant swapped-byte-order-mark-char-code #xfffe)

;;; Map 30-bit integers to 30-bit integers, using binary search.
;;; This is mostly to avoid using hash tables with integer key/value
;;; pairs and to avoid the GC impact of using such hash tables.
(defstruct pv-map
  keys
  values)



(defun %pv-map-lookup (code keys values)
  (declare (type (signed-byte 30) code)
           (type (simple-array (signed-byte 30) (*)) keys values)
           (optimize (speed 3) (safety 0)))
  (let* ((right (length keys))
         (left 0)
         (mid (ash right -1)))
    (declare (fixnum left right mid))
    (loop
      (if (>= left right)
        (return)
        (let* ((val (aref keys mid)))
          (declare (type (signed-byte 30) val))
          (if (= val code)
            (return (aref values mid))
            (progn
              (if (< val code)
                (setq left (1+ mid))
                (setq right mid))
              (setq mid (+ left (the fixnum (ash (the fixnum (- right left)) -1)))))))))))

(defun pv-map-lookup (code map)
  (%pv-map-lookup code (pv-map-keys map) (pv-map-values map)))


(defun pv-map-vectors (alist reverse-mapping)
  #-cross-compiling
  (dolist (pair alist)
    (unless (and (consp pair)
                 (typep (car pair) '(signed-byte 30))
                 (typep (cdr pair) '(signed-byte 30)))
      (error "Alist element ~s is not a CONS of two 30-bit integers" pair)))
  (let* ((n (length alist))
         (cars (make-array n :element-type '(signed-byte 30)))
         (cdrs (make-array n :element-type '(signed-byte 30)))
         (i 0))
    (declare (fixnum i n))
    (dolist (pair (sort-list  (copy-list alist) #'<  (if reverse-mapping (lambda (x) (cdr x)) (lambda (x) (car x)))))
      (setf (aref cars i) (car pair)
            (aref cdrs i) (cdr pair))
      (incf i))
    (if reverse-mapping
      (values cdrs cars)
      (values cars cdrs))))

(defun init-pv-map (alist &key reverse-mapping)
  (multiple-value-bind (keys values) (pv-map-vectors alist reverse-mapping)
    (make-pv-map :keys keys :values values)))


(defmethod default-character-encoding ((domain t))
  (character-encoding-name (get-character-encoding nil)))

(defun decode-character-encoded-vector (encoding vector start-index noctets string)
  (setq encoding (ensure-character-encoding encoding))
  (unless (= (the (unsigned-byte 8) (typecode vector))
             target::subtag-u8-vector)
    (report-bad-arg vector '(simple-array (unsigned-byte 8) (*))))
  (unless (= (the (unsigned-byte 8) (typecode string))
             target::subtag-simple-base-string)
    (report-bad-arg vector 'simple-string))
  (let* ((len (length vector)))
    (declare (type index len))
    (unless (and (typep start-index 'fixnum)
                 (>= (the fixnum start-index) 0)
                 (< (the fixnum start-index) len))
      (error "~s is an invalid start index for ~s" start-index vector))
    (unless (and (typep noctets 'fixnum)
                 (>= (the fixnum noctets) 0)
                 (<= (+ (the fixnum start-index) (the fixnum noctets)) len))
      (error "~S is an invalid octet count for ~s at ~s" noctets vector start-index))
    (funcall (character-encoding-vector-decode-function encoding)
             vector
             start-index
             noctets
             string)))


(defmethod print-object ((ce character-encoding) stream)
  (print-unreadable-object (ce stream :type t :identity t)
    (format stream "~a" (character-encoding-name ce))))

(defun note-stream-decoding-problem (stream)
  (let* ((source (if (typep stream 'ioblock)
                   (ioblock-stream stream)
                   stream))
         (position (stream-position source))
         (encoding-name
          (character-encoding-name
           (lookup-character-encoding (external-format-character-encoding (stream-external-format source))))))
    (signal (make-condition 'decoding-problem
                            :source source
                            :position position
                            :encoding-name encoding-name))
    #\Replacement_Character))

(defun note-vector-decoding-problem (vector index encoding)
  (signal (make-condition 'decoding-problem
                          :source vector
                          :position index
                          :encoding-name (let* ((enc (if (typep encoding 'character-encoding)
                                                       encoding
                                                       (lookup-character-encoding encoding))))
                                           (if enc (character-encoding-name enc) encoding))))
  #\Replacement_Character)

(defun note-encoding-problem (char destination encoding code)
  (signal (make-condition 'encoding-problem
                          :character char
                          :destination (if (typep destination 'ioblock)
                                         (ioblock-stream destination)
                                         destination)
                          :encoding-name (let* ((enc (if (typep encoding 'character-encoding)
                                                       encoding
                                                       (lookup-character-encoding encoding))))
                                           (if enc (character-encoding-name enc) encoding))))
  code)


(defun remove-character-encoding-alias (alias)
  "(REMOVE-CHARACTER-ENCODING-ALIAS alias)
alias - a keyword which is an alias for a defined character encoding.
Makes the keyword cease to be an alias for that encoding and returns T."
  (let* ((encoding (get-character-encoding alias))
         (aliases (character-encoding-aliases encoding)))
    (if (not (member alias aliases))
      (error "~S is not an alias for ~s." alias encoding)
      (progn
        (setf (character-encoding-aliases encoding)
              (remove alias aliases))
        (remhash alias *character-encodings*)
        t))))
              
  
(defun define-character-encoding-alias (alias existing)
  "(DEFINE-CHARACTER-ENCODING-ALIAS alias existing)
alias - a keyword
existing - a defined character encoding or a keyword that names one.
Tries to make alias an alias for the existing encoding and returns
that encoding."
  (check-type alias keyword)
  (let* ((canonical-encoding (ensure-character-encoding existing))
         (current (lookup-character-encoding alias)))
    (unless (eq current canonical-encoding)
      (if (and current
               (eq alias (character-encoding-name current)))
        (error "Can't make ~s an alias for ~s, since it already names ~s."
               alias existing current)
        (progn
          (when current
            (setf (character-encoding-aliases current)
                  (remove alias (character-encoding-aliases current))))
          (pushnew alias (character-encoding-aliases canonical-encoding))
          (setf (get-character-encoding alias) canonical-encoding))))
    canonical-encoding))

                          
;;; N.B.  (ccl:nfunction <name> (lambda (...) ...)) is just  like
;;;       (cl:function (lambda (...) ...)), except that the resulting
;;; function will have "name" <name> (this is often helpful when debugging.)

(defmacro define-character-encoding (name doc &rest args &key &allow-other-keys)
  (setq name (intern (string name) "KEYWORD"))
  (let* ((encoding (gensym))
         (alias (gensym)))
  `(let* ((,encoding (make-character-encoding :name ,name :documentation ,doc ,@args)))
    (setf (get-character-encoding ,name) ,encoding)
    (dolist (,alias (character-encoding-aliases ,encoding))
      (setf (get-character-encoding ,alias) ,encoding))
    ',name)))

(defun encoding-name (encoding)
  (character-encoding-name (or encoding (get-character-encoding nil))))

;;; ISO-8859-1 is trivial, though of course it can't really encode characters
;;; whose CHAR-CODE is >= 256

(defun 8-bit-fixed-width-octets-in-string (string start end)
  (declare (ignore string))
  (if (>= end start)
    (- end start)
    0))

(defun 8-bit-fixed-width-length-of-vector-encoding (vector start end)
  (declare (ignore vector))
  (if (>= end start)
    (values (- end start) end)
    (values 0 start)))

(defun 8-bit-fixed-width-length-of-memory-encoding (pointer noctets start)
  (declare (ignore pointer start))
  (values noctets noctets))

(define-character-encoding :iso-8859-1
  "An 8-bit, fixed-width character encoding in which all character
codes map to their Unicode equivalents. Intended to support most
characters used in most Western European languages."

  ;; The NIL alias is used internally to mean that ISO-8859-1 is
  ;; the "null" 8-bit encoding
  :aliases '(nil :iso_8859-1 :latin1 :l1 :ibm819 :cp819 :csISOLatin1)
  :stream-encode-function
  (nfunction
   iso-8859-1-stream-encode
   (lambda (char write-function stream)
     (let* ((code (char-code char)))
       (declare (type (mod #x110000) code))
       (if (>= code 256)
         (setq code (note-encoding-problem char stream :iso-8859-1 (char-code #\Sub))))
       (funcall write-function stream code)
       1)))
  :stream-decode-function
  (nfunction
   iso-8859-1-stream-decode
   (lambda (1st-unit next-unit-function stream)
     (declare (ignore next-unit-function stream)
              (type (unsigned-byte 8) 1st-unit))
     (code-char 1st-unit)))
  :vector-encode-function
  (nfunction
   iso-8859-1-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (if (>= code 256)
           (setq code (note-encoding-problem char vector :iso-8859-1 (char-code #\Sub))))
         (progn
           (setf (aref vector idx) code)
           (incf idx))))))
  :vector-decode-function
  (nfunction
   iso-8859-1-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector))
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
       (setf (schar string i) (code-char (the (unsigned-byte 8)
                                             (aref vector index)))))))
  :memory-encode-function
  (nfunction
   iso-8859-1-memory-encode
   (lambda (string pointer idx start end)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (if (>= code 256)
           (setq code (note-encoding-problem char pointer :iso-8859-1 (char-code #\Sub))))
         (setf (%get-unsigned-byte pointer idx) code)
         (incf idx)))))
  :memory-decode-function
  (nfunction
   iso-8859-1-memory-decode
   (lambda (pointer noctets idx string)
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
         (setf (schar string i) (code-char (the (unsigned-byte 8)
                                             (%get-unsigned-byte pointer index)))))))
  :octets-in-string-function
  #'8-bit-fixed-width-octets-in-string
  :length-of-vector-encoding-function
  #'8-bit-fixed-width-length-of-vector-encoding
  :length-of-memory-encoding-function 
  #'8-bit-fixed-width-length-of-memory-encoding
  :decode-literal-code-unit-limit 256
  :encode-literal-char-code-limit 256

  )

(define-character-encoding :us-ascii
  "A 7-bit, fixed-width character encoding in which all character
codes map to their Unicode equivalents."

  :aliases '(:csASCII :cp637 :IBM637 :us :ISO646-US :ascii :ISO-ir-6)
  :stream-encode-function
  (nfunction
   ascii-stream-encode
   (lambda (char write-function stream)
     (let* ((code (char-code char)))
       (declare (type (mod #x110000) code))
       (when (>= code 128)
         (setq code (note-encoding-problem char stream :us-ascii (char-code #\Sub))))
       (funcall write-function stream code)
       1)))
  :stream-decode-function
  (nfunction
   ascii-stream-decode
   (lambda (1st-unit next-unit-function stream)
     (declare (ignore next-unit-function)
              (type (unsigned-byte 8) 1st-unit))
     (if (< 1st-unit 128)
       (code-char 1st-unit)
       (note-stream-decoding-problem stream))))
  :vector-encode-function
  (nfunction
   ascii-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (if (>= code 128)
           (setq code (note-encoding-problem char vector :us-ascii (char-code #\Sub))))
         (setf (aref vector idx) code)
         (incf idx)))))
  :vector-decode-function
  (nfunction
   ascii-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector))
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
       (let* ((code (aref vector index)))
         (declare (type (unsigned-byte 8) code))
         (setf (schar string i) (if (< code 128)
                                  (code-char code)
                                  (note-vector-decoding-problem vector index :us-ascii)))))))
  :memory-encode-function
  (nfunction
   ascii-memory-encode
   (lambda (string pointer idx start end)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (if (>= code 128)
           (setq code (note-encoding-problem char pointer :us-ascii (char-code #\Sub))))
         (setf (%get-unsigned-byte pointer idx) code)
         (incf idx)))))
  :memory-decode-function
  (nfunction
   ascii-memory-decode
   (lambda (pointer noctets idx string)
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
       (let* ((code (%get-unsigned-byte pointer index)))
         (declare (type (unsigned-byte 8) code))
         (if (>= code 128)
           (setf (schar string i) (note-vector-decoding-problem pointer index :us-ascii))
           (setf (schar string i) (code-char code)))))))
  :octets-in-string-function
  #'8-bit-fixed-width-octets-in-string
  :length-of-vector-encoding-function
  #'8-bit-fixed-width-length-of-vector-encoding
  :length-of-memory-encoding-function 
  #'8-bit-fixed-width-length-of-memory-encoding
  :decode-literal-code-unit-limit 128
  :encode-literal-char-code-limit 128
  )



;;; Other 1-byte, fixed-width encodings.  Typically, codes in the range
;;; #x00-#x9f maps straight through, while codes #xa0-#xff select arbitrary
;;; Unicode characters that are commonly used in some locale.  (Sometimes
;;; the break is at #x80 or #xd0 instead of #xa0).

(defmacro define-8-bit-fixed-width-encoding (name doc aliases encode-map decode-string mapping &optional (literal-limit #xa0))
  (unless (= (length mapping) (- 256 literal-limit))
    (error "Mapping data for encoding ~s should contain exactly ~d elements, not ~d" name (- 256 literal-limit) (length mapping)))
  `(progn
    (defstatic ,encode-map (init-pv-map ',(loop
                                             for i from literal-limit to 256
                                             for code across mapping
                                             unless (eql code (char-code #\replacement_character))
                                             collect (cons i code))
                                          :reverse-mapping t))
    (defstatic ,decode-string ,(map 'string #'code-char mapping))
    (define-character-encoding ,name
        ,doc
      :aliases ',aliases
      :stream-encode-function
      (nfunction ,(intern (concatenate 'string (string name) "-STREAM-ENCODE"))
       (lambda (char write-function stream)
         (let* ((code (char-code char))
                (c2 (if (< code ,literal-limit)
                      code
                      (pv-map-lookup code ,encode-map))))
           (declare (type (mod #x110000) code))
           (funcall write-function stream (or c2 (note-encoding-problem char stream ,name (char-code #\Sub))))
           1)))
      :stream-decode-function
      (nfunction
       ,(intern (concatenate 'string (string name) "-STREAM-DECODE"))
       (lambda (1st-unit next-unit-function stream)
         (declare (ignore next-unit-function)
                  (type (unsigned-byte 8) 1st-unit))
         (if (< 1st-unit ,literal-limit)
           (code-char 1st-unit)
           (let* ((char (schar ,decode-string (- 1st-unit ,literal-limit))))
             (when (eql char #\replacement_character)
               (note-stream-decoding-problem stream))
             char))))
      :vector-encode-function
      (nfunction
       ,(intern (concatenate 'string (string name) "-VECTOR-ENCODE"))
       (lambda (string vector idx start end)
         (declare (type (simple-array (unsigned-byte 8) (*)) vector)
                  (fixnum idx))
         (do* ((i start (1+ i)))
              ((>= i end) idx)
           (let* ((char (schar string i))
                  (code (char-code char))
                  (c2 (if (< code ,literal-limit)
                        code
                        (pv-map-lookup code ,encode-map))))
             (declare (type (mod #x110000) code))
             (setf (aref vector idx) (or c2 (note-encoding-problem char vector ,name (char-code #\Sub))))
             (incf idx)))))
      :vector-decode-function
      (nfunction
       ,(intern (concatenate 'string (string name) "-VECTOR-DECODE"))
       (lambda (vector idx noctets string)
         (declare (type (simple-array (unsigned-byte 8) (*)) vector))
         (do* ((i 0 (1+ i))
               (index idx (1+ index)))
              ((>= i noctets) index)
           (let* ((1st-unit (aref vector index)))
             (declare (type (unsigned-byte 8) 1st-unit))
             (setf (schar string i)
                   (if (< 1st-unit ,literal-limit)
                     (code-char 1st-unit)
                     (let* ((char (schar ,decode-string (the fixnum (- 1st-unit ,literal-limit)))))
                       (when (eql char #\replacement_character)
                         (note-vector-decoding-problem vector i ,name ))
                       char)))))))
      :memory-encode-function
      (nfunction
       ,(intern (concatenate 'string (string name) "-MEMORY-ENCODE"))
       (lambda (string pointer idx start end)
         (do* ((i start (1+ i)))
              ((>= i end) idx)
           (let* ((char (schar string i))
                  (code (char-code char))
                  (c2 (if (< code ,literal-limit)
                        code
                        (pv-map-lookup code ,encode-map))))
             (declare (type (mod #x110000) code))
             (setf (%get-unsigned-byte pointer idx) (or c2 (note-encoding-problem char pointer ,name (char-code #\Sub))))
             (incf idx)))))
      :memory-decode-function
      (nfunction
       ,(intern (concatenate 'string (string name) "-MEMORY-DECODE"))
       (lambda (pointer noctets idx string)
         (do* ((i 0 (1+ i))
               (index idx (1+ index)))
              ((>= i noctets) index)
           (let* ((1st-unit (%get-unsigned-byte pointer index)))
             (declare (type (unsigned-byte 8) 1st-unit))
             (setf (schar string i)
                   (if (< 1st-unit ,literal-limit)
                     (code-char 1st-unit)
                     (let* ((char (schar ,decode-string (the fixnum (- 1st-unit ,literal-limit)))))
                       (when (eql char #\replacement_character)
                         (note-vector-decoding-problem pointer index ,name ))
                       char)))))))
      :octets-in-string-function
      #'8-bit-fixed-width-octets-in-string
      :length-of-vector-encoding-function
      #'8-bit-fixed-width-length-of-vector-encoding
      :length-of-memory-encoding-function 
      #'8-bit-fixed-width-length-of-memory-encoding
      :decode-literal-code-unit-limit ,literal-limit
      :encode-literal-char-code-limit ,literal-limit)))

(define-8-bit-fixed-width-encoding :iso-8859-2
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in most
languages used in Central/Eastern Europe."
  (:iso_8859-2 :latin2 :l2 :csISOLatin2)
  *unicode-to-iso-8859-2-map*
  *iso-to-8859-2-to-unicode-string*
  #(#xA0 #x104 #x2D8 #x141 #xA4 #x13D #x15A #xA7 #xA8 #x160 #x15E #x164
    #x179 #xAD #x17D #x17B #xB0 #x105 #x2DB #x142 #xB4 #x13E #x15B #x2C7
    #xB8 #x161 #x15F #x165 #x17A #x2DD #x17E #x17C #x154 #xC1 #xC2 #x102
    #xC4 #x139 #x106 #xC7 #x10C #xC9 #x118 #xCB #x11A #xCD #xCE #x10E
    #x110 #x143 #x147 #xD3 #xD4 #x150 #xD6 #xD7 #x158 #x16E #xDA #x170
    #xDC #xDD #x162 #xDF #x155 #xE1 #xE2 #x103 #xE4 #x13A #x107 #xE7
    #x10D #xE9 #x119 #xEB #x11B #xED #xEE #x10F #x111 #x144 #x148 #xF3
    #xF4 #x151 #xF6 #xF7 #x159 #x16F #xFA #x171 #xFC #xFD #x163 #x2D9))

(define-8-bit-fixed-width-encoding :iso-8859-3
  "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in most
languages used in Southern Europe."
  (:iso_8859-3 :latin3 :l3 :csisolatin3)
  *unicode-to-iso-8859-3-map*
  *iso-to-8859-3-to-unicode-string*
  #(
    ;; #xa0 
    #x00a0 #x0126 #x02d8 #x00a3 #x00a4 #xfffd #x0124 #x00a7
    #x00a8 #x0130 #x015e #x011e #x0134 #x00ad #xfffd #x017b
    ;; #xb0 
    #x00b0 #x0127 #x00b2 #x00b3 #x00b4 #x00b5 #x0125 #x00b7
    #x00b8 #x0131 #x015f #x011f #x0135 #x00bd #xfffd #x017c
    ;; #xc0 
    #x00c0 #x00c1 #x00c2 #xfffd #x00c4 #x010a #x0108 #x00c7
    #x00c8 #x00c9 #x00ca #x00cb #x00cc #x00cd #x00ce #x00cf
    ;; #xd0 
    #xfffd #x00d1 #x00d2 #x00d3 #x00d4 #x0120 #x00d6 #x00d7
    #x011c #x00d9 #x00da #x00db #x00dc #x016c #x015c #x00df
    ;; #xe0 
    #x00e0 #x00e1 #x00e2 #xfffd #x00e4 #x010b #x0109 #x00e7
    #x00e8 #x00e9 #x00ea #x00eb #x00ec #x00ed #x00ee #x00ef
    ;; #xf0 
    #xfffd #x00f1 #x00f2 #x00f3 #x00f4 #x0121 #x00f6 #x00f7
    #x011d #x00f9 #x00fa #x00fb #x00fc #x016d #x015d #x02d9
    ))

(define-8-bit-fixed-width-encoding :iso-8859-4
  "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in most
languages used in Northern Europe."
  (:iso_8859-4 :latin4 :l4 :csisolatin4)
  *unicode-to-iso-8859-4-map*
  *iso-to-8859-4-to-unicode-string*
  #(
    ;; #xa0 
    #x00a0 #x0104 #x0138 #x0156 #x00a4 #x0128 #x013b #x00a7
    #x00a8 #x0160 #x0112 #x0122 #x0166 #x00ad #x017d #x00af
    ;; #xb0 
    #x00b0 #x0105 #x02db #x0157 #x00b4 #x0129 #x013c #x02c7
    #x00b8 #x0161 #x0113 #x0123 #x0167 #x014a #x017e #x014b
    ;; #xc0 
    #x0100 #x00c1 #x00c2 #x00c3 #x00c4 #x00c5 #x00c6 #x012e
    #x010c #x00c9 #x0118 #x00cb #x0116 #x00cd #x00ce #x012a
    ;; #xd0 
    #x0110 #x0145 #x014c #x0136 #x00d4 #x00d5 #x00d6 #x00d7
    #x00d8 #x0172 #x00da #x00db #x00dc #x0168 #x016a #x00df
    ;; #xe0 
    #x0101 #x00e1 #x00e2 #x00e3 #x00e4 #x00e5 #x00e6 #x012f
    #x010d #x00e9 #x0119 #x00eb #x0117 #x00ed #x00ee #x012b
    ;; #xf0 
    #x0111 #x0146 #x014d #x0137 #x00f4 #x00f5 #x00f6 #x00f7
    #x00f8 #x0173 #x00fa #x00fb #x00fc #x0169 #x016b #x02d9
    ))

(define-8-bit-fixed-width-encoding :iso-8859-5
  "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in the
Cyrillic alphabet."
  (:iso_8859-5 :cyrillic :csISOLatinCyrillic :iso-ir-144)
  *unicode-to-iso-8859-5-map*
  *iso-to-8859-5-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x0401 #x0402 #x0403 #x0404 #x0405 #x0406 #x0407
    #x0408 #x0409 #x040a #x040b #x040c #x00ad #x040e #x040f
    ;; #xb0
    #x0410 #x0411 #x0412 #x0413 #x0414 #x0415 #x0416 #x0417
    #x0418 #x0419 #x041a #x041b #x041c #x041d #x041e #x041f
    ;; #xc0
    #x0420 #x0421 #x0422 #x0423 #x0424 #x0425 #x0426 #x0427
    #x0428 #x0429 #x042a #x042b #x042c #x042d #x042e #x042f
    ;; #xd0
    #x0430 #x0431 #x0432 #x0433 #x0434 #x0435 #x0436 #x0437
    #x0438 #x0439 #x043a #x043b #x043c #x043d #x043e #x043f
    ;; #xe0
    #x0440 #x0441 #x0442 #x0443 #x0444 #x0445 #x0446 #x0447
    #x0448 #x0449 #x044a #x044b #x044c #x044d #x044e #x044f
    ;; #xf0
    #x2116 #x0451 #x0452 #x0453 #x0454 #x0455 #x0456 #x0457
    #x0458 #x0459 #x045a #x045b #x045c #x00a7 #x045e #x045f
    ))

(define-8-bit-fixed-width-encoding :iso-8859-6
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in the
Arabic alphabet."
  (:iso_8859-6 :arabic :csISOLatinArabic :iso-ir-127)
  *unicode-to-iso-8859-6-map*
  *iso-to-8859-6-to-unicode-string*
  #(
    ;; #xa0 
    #x00a0 #xfffd #xfffd #xfffd #x00a4 #xfffd #xfffd #xfffd
    #xfffd #xfffd #xfffd #xfffd #x060c #x00ad #xfffd #xfffd
    ;; #xb0 
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd
    #xfffd #xfffd #xfffd #x061b #xfffd #xfffd #xfffd #x061f
    ;; #xc0 
    #xfffd #x0621 #x0622 #x0623 #x0624 #x0625 #x0626 #x0627
    #x0628 #x0629 #x062a #x062b #x062c #x062d #x062e #x062f
    ;; #xd0 
    #x0630 #x0631 #x0632 #x0633 #x0634 #x0635 #x0636 #x0637
    #x0638 #x0639 #x063a #xfffd #xfffd #xfffd #xfffd #xfffd
    ;; #xe0 
    #x0640 #x0641 #x0642 #x0643 #x0644 #x0645 #x0646 #x0647
    #x0648 #x0649 #x064a #x064b #x064c #x064d #x064e #x064f
    ;; #xf0 
    #x0650 #x0651 #x0652 #xfffd #xfffd #xfffd #xfffd #xfffd
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd
    ))

(define-8-bit-fixed-width-encoding :iso-8859-7
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in the
Greek alphabet."
  (:iso_8859-7 :greek  :greek8 :csISOLatinGreek :iso-ir-126 :ELOT_928 :ecma-118)
  *unicode-to-iso-8859-7-map*
  *iso-to-8859-7-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x2018 #x2019 #x00a3 #x20ac #x20af #x00a6 #x00a7
    #x00a8 #x00a9 #x037a #x00ab #x00ac #x00ad #xfffd #x2015
    ;; #xb0
    #x00b0 #x00b1 #x00b2 #x00b3 #x0384 #x0385 #x0386 #x00b7
    #x0388 #x0389 #x038a #x00bb #x038c #x00bd #x038e #x038f
    ;; #xc0
    #x0390 #x0391 #x0392 #x0393 #x0394 #x0395 #x0396 #x0397
    #x0398 #x0399 #x039a #x039b #x039c #x039d #x039e #x039f
    ;; #xd0
    #x03a0 #x03a1 #xfffd #x03a3 #x03a4 #x03a5 #x03a6 #x03a7
    #x03a8 #x03a9 #x03aa #x03ab #x03ac #x03ad #x03ae #x03af
    ;; #xe0
    #x03b0 #x03b1 #x03b2 #x03b3 #x03b4 #x03b5 #x03b6 #x03b7
    #x03b8 #x03b9 #x03ba #x03bb #x03bc #x03bd #x03be #x03bf
    ;; #xf0
    #x03c0 #x03c1 #x03c2 #x03c3 #x03c4 #x03c5 #x03c6 #x03c7
    #x03c8 #x03c9 #x03ca #x03cb #x03cc #x03cd #x03ce #xfffd
    ))

(define-8-bit-fixed-width-encoding :iso-8859-8
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in the
Hebrew alphabet."
  (:iso_8859-8 :hebrew :csISOLatinHebrew :iso-ir-138)
  *unicode-to-iso-8859-8-map*
  *iso-to-8859-8-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #xfffd #x00a2 #x00a3 #x00a4 #x00a5 #x00a6 #x00a7
    #x00a8 #x00a9 #x00d7 #x00ab #x00ac #x00ad #x00ae #x00af
    ;; #xb0
    #x00b0 #x00b1 #x00b2 #x00b3 #x00b4 #x00b5 #x00b6 #x00b7
    #x00b8 #x00b9 #x00f7 #x00bb #x00bc #x00bd #x00be #xfffd
    ;; #xc0
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd
    ;; #xd0
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd
    #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #xfffd #x2017
    ;; #xe0
    #x05d0 #x05d1 #x05d2 #x05d3 #x05d4 #x05d5 #x05d6 #x05d7
    #x05d8 #x05d9 #x05da #x05db #x05dc #x05dd #x05de #x05df
    ;; #xf0
    #x05e0 #x05e1 #x05e2 #x05e3 #x05e4 #x05e5 #x05e6 #x05e7
    #x05e8 #x05e9 #x05ea #xfffd #xfffd #x200e #x200f #xfffd
    ))

(define-8-bit-fixed-width-encoding :iso-8859-9
    "An 8-bit, fixed-width character encoding in which codes #x00-#xcf
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in the
Turkish alphabet."
  (:iso_8859-9 :latin5 :csISOLatin5 :iso-ir-148)
  *unicode-to-iso-8859-9-map*
  *iso-to-8859-9-to-unicode-string*
  #(
    ;; #xd0
    #x011e #x00d1 #x00d2 #x00d3 #x00d4 #x00d5 #x00d6 #x00d7
    #x00d8 #x00d9 #x00da #x00db #x00dc #x0130 #x015e #x00df
    ;; #xe0
    #x00e0 #x00e1 #x00e2 #x00e3 #x00e4 #x00e5 #x00e6 #x00e7
    #x00e8 #x00e9 #x00ea #x00eb #x00ec #x00ed #x00ee #x00ef
    ;; #xf0
    #x011f #x00f1 #x00f2 #x00f3 #x00f4 #x00f5 #x00f6 #x00f7
    #x00f8 #x00f9 #x00fa #x00fb #x00fc #x0131 #x015f #x00ff
    )
  #xd0)

(define-8-bit-fixed-width-encoding :iso-8859-10
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in Nordic
alphabets."
  (:iso_8859-10 :latin6 :csISOLatin6 :iso-ir-157)
  *unicode-to-iso-8859-10-map*
  *iso-to-8859-10-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x0104 #x0112 #x0122 #x012a #x0128 #x0136 #x00a7
    #x013b #x0110 #x0160 #x0166 #x017d #x00ad #x016a #x014a
    ;; #xb0
    #x00b0 #x0105 #x0113 #x0123 #x012b #x0129 #x0137 #x00b7
    #x013c #x0111 #x0161 #x0167 #x017e #x2015 #x016b #x014b
    ;; #xc0
    #x0100 #x00c1 #x00c2 #x00c3 #x00c4 #x00c5 #x00c6 #x012e
    #x010c #x00c9 #x0118 #x00cb #x0116 #x00cd #x00ce #x00cf
    ;; #xd0
    #x00d0 #x0145 #x014c #x00d3 #x00d4 #x00d5 #x00d6 #x0168
    #x00d8 #x0172 #x00da #x00db #x00dc #x00dd #x00de #x00df
    ;; #xe0
    #x0101 #x00e1 #x00e2 #x00e3 #x00e4 #x00e5 #x00e6 #x012f
    #x010d #x00e9 #x0119 #x00eb #x0117 #x00ed #x00ee #x00ef
    ;; #xf0
    #x00f0 #x0146 #x014d #x00f3 #x00f4 #x00f5 #x00f6 #x0169
    #x00f8 #x0173 #x00fa #x00fb #x00fc #x00fd #x00fe #x0138
    ))

(define-character-encoding :iso-8859-11
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found the  Thai
alphabet."
  :aliases '()
  :stream-encode-function
  (nfunction
   iso-8859-11-stream-encode
   (lambda (char write-function stream)
     (let* ((code (char-code char))
            (c2 (cond ((< code #xa1) code)
                      ((and (<= code #xfb)
                            (not (and (>= code #xdb) (<= code #xde))))
                       (+ code #x0d60)))))
       (declare (type (mod #x110000) code))
       (funcall write-function stream (or c2 (note-encoding-problem char stream :iso-8859-11 (char-code #\Sub))))
       1)))
  :stream-decode-function
  (nfunction
   iso-8859-11-stream-decode
   (lambda (1st-unit next-unit-function stream)
     (declare (ignore next-unit-function)
              (type (unsigned-byte 8) 1st-unit))
     (if (< 1st-unit #xa1)
       (code-char 1st-unit)
       (if (and (>= 1st-unit #xe01)
                (<= 1st-unit #xe5b)
                (not (and (>= 1st-unit #xe3b)
                          (<= 1st-unit #xe3e))))
         (code-char (- 1st-unit #xd60))
         (note-stream-decoding-problem stream)))))
  :vector-encode-function
  (nfunction
   iso-8859-11-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char))
              (c2 (cond ((< code #xa1) code)
                      ((and (<= code #xfb)
                            (not (and (>= code #xdb) (<= code #xde))))
                       (+ code #x0d60)))))
         (declare (type (mod #x110000) code))
         (setf (aref vector idx) (or c2 (note-encoding-problem char vector :iso-8859-11 (char-code #\Sub))))
         (incf idx)))))
  :vector-decode-function
  (nfunction
   iso-8859-11-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector))
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
       (let* ((1st-unit (aref vector index)))
         (declare (type (unsigned-byte 8) 1st-unit))
         (setf (schar string i)
               (if (< 1st-unit #xa1)
                 (code-char 1st-unit)
                 (if (and (>= 1st-unit #xe01)
                          (<= 1st-unit #xe5b)
                          (not (and (>= 1st-unit #xe3b)
                                    (<= 1st-unit #xe3e))))
                   (code-char (- 1st-unit #xd60))
                   (note-vector-decoding-problem vector index :iso-8859-11))))))))
  :memory-encode-function
  (nfunction
   iso-8859-11-memory-encode
   (lambda (string pointer idx start end)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char))
              (c2 (cond ((< code #xa1) code)
                      ((and (<= code #xfb)
                            (not (and (>= code #xdb) (<= code #xde))))
                       (+ code #x0d60)))))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-byte pointer idx) (or c2 (note-encoding-problem char pointer :iso-8859-11 (char-code #\Sub))))
         (incf idx)))))
  :memory-decode-function
  (nfunction
   iso-8859-11-memory-decode
   (lambda (pointer noctets idx string)
     (do* ((i 0 (1+ i))
           (index idx (1+ index)))
          ((>= i noctets) index)
       (let* ((1st-unit (%get-unsigned-byte pointer index)))
         (declare (type (unsigned-byte 8) 1st-unit))
         (setf (schar string i)
               (if (< 1st-unit #xa1)
                 (code-char 1st-unit)
                 (if (and (>= 1st-unit #xe01)
                          (<= 1st-unit #xe5b)
                          (not (and (>= 1st-unit #xe3b)
                                    (<= 1st-unit #xe3e))))
                   (code-char (- 1st-unit #xd60))
                   (note-vector-decoding-problem pointer index :iso-8859-11))))))))
  :octets-in-string-function
  #'8-bit-fixed-width-octets-in-string
  :length-of-vector-encoding-function
  #'8-bit-fixed-width-length-of-vector-encoding
  :length-of-memory-encoding-function 
  #'8-bit-fixed-width-length-of-memory-encoding
  :decode-literal-code-unit-limit #xa0
  :encode-literal-char-code-limit #xa0  
  )

;;; There is no iso-8859-12 encoding.

(define-8-bit-fixed-width-encoding :iso-8859-13
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in Baltic
alphabets."
  () 
  *unicode-to-iso-8859-13-map*
  *iso-to-8859-13-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x201d #x00a2 #x00a3 #x00a4 #x201e #x00a6 #x00a7
    #x00d8 #x00a9 #x0156 #x00ab #x00ac #x00ad #x00ae #x00c6
    ;; #xb0
    #x00b0 #x00b1 #x00b2 #x00b3 #x201c #x00b5 #x00b6 #x00b7
    #x00f8 #x00b9 #x0157 #x00bb #x00bc #x00bd #x00be #x00e6
    ;; #xc0
    #x0104 #x012e #x0100 #x0106 #x00c4 #x00c5 #x0118 #x0112
    #x010c #x00c9 #x0179 #x0116 #x0122 #x0136 #x012a #x013b
    ;; #xd0
    #x0160 #x0143 #x0145 #x00d3 #x014c #x00d5 #x00d6 #x00d7
    #x0172 #x0141 #x015a #x016a #x00dc #x017b #x017d #x00df
    ;; #xe0
    #x0105 #x012f #x0101 #x0107 #x00e4 #x00e5 #x0119 #x0113
    #x010d #x00e9 #x017a #x0117 #x0123 #x0137 #x012b #x013c
    ;; #xf0
    #x0161 #x0144 #x0146 #x00f3 #x014d #x00f5 #x00f6 #x00f7
    #x0173 #x0142 #x015b #x016b #x00fc #x017c #x017e #x2019
    ))

(define-8-bit-fixed-width-encoding :iso-8859-14
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in Celtic
languages."
  (:iso_8859-14 :iso-ir-199 :latin8 :l8 :iso-celtic)
  *unicode-to-iso-8859-14-map*
  *iso-to-8859-14-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x1e02 #x1e03 #x00a3 #x010a #x010b #x1e0a #x00a7
    #x1e80 #x00a9 #x1e82 #x1e0b #x1ef2 #x00ad #x00ae #x0178
    ;; #xb0
    #x1e1e #x1e1f #x0120 #x0121 #x1e40 #x1e41 #x00b6 #x1e56
    #x1e81 #x1e57 #x1e83 #x1e60 #x1ef3 #x1e84 #x1e85 #x1e61
    ;; #xc0
    #x00c0 #x00c1 #x00c2 #x00c3 #x00c4 #x00c5 #x00c6 #x00c7
    #x00c8 #x00c9 #x00ca #x00cb #x00cc #x00cd #x00ce #x00cf
    ;; #xd0
    #x0174 #x00d1 #x00d2 #x00d3 #x00d4 #x00d5 #x00d6 #x1e6a
    #x00d8 #x00d9 #x00da #x00db #x00dc #x00dd #x0176 #x00df
    ;; #xe0
    #x00e0 #x00e1 #x00e2 #x00e3 #x00e4 #x00e5 #x00e6 #x00e7
    #x00e8 #x00e9 #x00ea #x00eb #x00ec #x00ed #x00ee #x00ef
    ;; #xf0
    #x0175 #x00f1 #x00f2 #x00f3 #x00f4 #x00f5 #x00f6 #x1e6b
    #x00f8 #x00f9 #x00fa #x00fb #x00fc #x00fd #x0177 #x00ff
    ))

(define-8-bit-fixed-width-encoding :iso-8859-15
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in
Western European languages (including the Euro sign and some other
characters missing from ISO-8859-1.)"
  (:iso_8859-15 :latin9)
  *unicode-to-iso-8859-15-map*
  *iso-to-8859-15-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x00a1 #x00a2 #x00a3 #x20ac #x00a5 #x0160 #x00a7
    #x0161 #x00a9 #x00aa #x00ab #x00ac #x00ad #x00ae #x00af
    ;; #xb0
    #x00b0 #x00b1 #x00b2 #x00b3 #x017d #x00b5 #x00b6 #x00b7
    #x017e #x00b9 #x00ba #x00bb #x0152 #x0153 #x0178 #x00bf
    ;; #xc0
    #x00c0 #x00c1 #x00c2 #x00c3 #x00c4 #x00c5 #x00c6 #x00c7 
    ;; #xc8
    #x00c8 #x00c9 #x00ca #x00cb #x00cc #x00cd #x00ce #x00cf 
    ;; #xd0
    #x00d0 #x00d1 #x00d2 #x00d3 #x00d4 #x00d5 #x00d6 #x00d7 
    ;; #xd8
    #x00d8 #x00d9 #x00da #x00db #x00dc #x00dd #x00de #x00df 
    ;; #xe0
    #x00e0 #x00e1 #x00e2 #x00e3 #x00e4 #x00e5 #x00e6 #x00e7 
    ;; #xe8
    #x00e8 #x00e9 #x00ea #x00eb #x00ec #x00ed #x00ee #x00ef 
    ;; #xf0
    #x00f0 #x00f1 #x00f2 #x00f3 #x00f4 #x00f5 #x00f6 #x00f7 
    ;; #xf8
    #x00f8 #x00f9 #x00fa #x00fb #x00fc #x00fd #x00fe #x00ff 
    ))

(define-8-bit-fixed-width-encoding :iso-8859-16
    "An 8-bit, fixed-width character encoding in which codes #x00-#x9f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Intended to provide most characters found in Southeast
European languages."
  (:iso_8859-16 :latin10 :l1 :iso-ir-226)
  *unicode-to-iso-8859-16-map*
  *iso-to-8859-16-to-unicode-string*
  #(
    ;; #xa0
    #x00a0 #x0104 #x0105 #x0141 #x20ac #x201e #x0160 #x00a7
    #x0161 #x00a9 #x0218 #x00ab #x0179 #x00ad #x017a #x017b
    ;; #xb0
    #x00b0 #x00b1 #x010c #x0142 #x017d #x201d #x00b6 #x00b7
    #x017e #x010d #x0219 #x00bb #x0152 #x0153 #x0178 #x017c
    ;; #xc0
    #x00c0 #x00c1 #x00c2 #x0102 #x00c4 #x0106 #x00c6 #x00c7
    #x00c8 #x00c9 #x00ca #x00cb #x00cc #x00cd #x00ce #x00cf
    ;; #xd0
    #x0110 #x0143 #x00d2 #x00d3 #x00d4 #x0150 #x00d6 #x015a
    #x0170 #x00d9 #x00da #x00db #x00dc #x0118 #x021a #x00df
    ;; #xe0
    #x00e0 #x00e1 #x00e2 #x0103 #x00e4 #x0107 #x00e6 #x00e7
    #x00e8 #x00e9 #x00ea #x00eb #x00ec #x00ed #x00ee #x00ef
    ;; #xf0
    #x0111 #x0144 #x00f2 #x00f3 #x00f4 #x0151 #x00f6 #x015b
    #x0171 #x00f9 #x00fa #x00fb #x00fc #x0119 #x021b #x00ff
    ))

(define-8-bit-fixed-width-encoding :macintosh
    "An 8-bit, fixed-width character encoding in which codes #x00-#x7f
map to their Unicode equivalents and other codes map to other Unicode
character values.  Traditionally used on Classic MacOS to encode characters
used in western languages."
  (:macos-roman :macosroman :mac-roman :macroman)
  *unicode-to-macintosh-map*
  *macintosh-to-unicode-string*
  #(
    ;; #x80 
    #x00c4 #x00c5 #x00c7 #x00c9 #x00d1 #x00d6 #x00dc #x00e1
    #x00e0 #x00e2 #x00e4 #x00e3 #x00e5 #x00e7 #x00e9 #x00e8
    ;; #x90 
    #x00ea #x00eb #x00ed #x00ec #x00ee #x00ef #x00f1 #x00f3
    #x00f2 #x00f4 #x00f6 #x00f5 #x00fa #x00f9 #x00fb #x00fc
    ;; #xa0 
    #x2020 #x00b0 #x00a2 #x00a3 #x00a7 #x2022 #x00b6 #x00df
    #x00ae #x00a9 #x2122 #x00b4 #x00a8 #x2260 #x00c6 #x00d8
    ;; #xb0 
    #x221e #x00b1 #x2264 #x2265 #x00a5 #x00b5 #x2202 #x2211
    #x220f #x03c0 #x222b #x00aa #x00ba #x2126 #x00e6 #x00f8
    ;; #xc0 
    #x00bf #x00a1 #x00ac #x221a #x0192 #x2248 #x2206 #x00ab
    #x00bb #x2026 #x00a0 #x00c0 #x00c3 #x00d5 #x0152 #x0153
    ;; #xd0 
    #x2013 #x2014 #x201c #x201d #x2018 #x2019 #x00f7 #x25ca
    #x00ff #x0178 #x2044 #x00a4 #x2039 #x203a #xfb01 #xfb02
    ;; #xe0 
    #x2021 #x00b7 #x201a #x201e #x2030 #x00c2 #x00ca #x00c1
    #x00cb #x00c8 #x00cd #x00ce #x00cf #x00cc #x00d3 #x00d4
    ;; #xf0 
    #xf8ff #x00d2 #x00da #x00db #x00d9 #x0131 #x02c6 #x02dc
    #x00af #x02d8 #x02d9 #x02da #x00b8 #x02dd #x02db #x02c7
    )
  #x80)



;;; UTF-8.  Decoding checks for malformed sequences; it might be faster (and
;;; would certainly be simpler) if it didn't.
(define-character-encoding :utf-8
    "An 8-bit, variable-length character encoding in which characters
with CHAR-CODEs in the range #x00-#x7f can be encoded in a single
octet; characters with larger code values can be encoded in 2 to 4
bytes."
    :max-units-per-char 4
    :stream-encode-function
    (nfunction
     utf-8-stream-encode
     (lambda (char write-function stream)
       (let* ((code (char-code char)))
         (declare (type (mod #x110000) code))
         (cond ((< code #x80)
                (funcall write-function stream code)
                1)
               ((< code #x800)
                (let* ((y (ldb (byte 5 6) code))
                       (z (ldb (byte 6 0) code)))
                  (declare (fixnum y z))
                  (funcall write-function stream (logior #xc0 y))
                  (funcall write-function stream (logior #x80 z))
                  2))
               ((< code #x10000)
                (let* ((x (ldb (byte 4 12) code))
                       (y (ldb (byte 6 6) code))
                       (z (ldb (byte 6 0) code)))
                  (declare (fixnum x y z))
                  (funcall write-function stream (logior #xe0 x))
                  (funcall write-function stream (logior #x80 y))
                  (funcall write-function stream (logior #x80 z))
                  3))
               (t
                (let* ((w (ldb (byte 3 18) code))
                       (x (ldb (byte 6 12) code))
                       (y (ldb (byte 6 6) code))
                       (z (ldb (byte 6 0) code)))
                  (declare (fixnum w x y z))
                  (funcall write-function stream (logior #xf0 w))
                  (funcall write-function stream (logior #x80 x))
                  (funcall write-function stream (logior #x80 y))
                  (funcall write-function stream (logior #x80 z))
                  4))))))
    :stream-decode-function
    (nfunction
     utf-8-stream-decode
     (lambda (1st-unit next-unit-function stream)
       (declare (type (unsigned-byte 8) 1st-unit))
       (if (< 1st-unit #x80)
         (code-char 1st-unit)
         (if (>= 1st-unit #xc2)
           (let* ((s1 (funcall next-unit-function stream)))
             (if (eq s1 :eof)
               s1
               (locally
                   (declare (type (unsigned-byte 8) s1))
                 (if (< 1st-unit #xe0)
                   (if (< (the fixnum (logxor s1 #x80)) #x40)
                     (code-char
                      (logior
                       (the fixnum (ash (the fixnum (logand #x1f 1st-unit)) 6))
                       (the fixnum (logxor s1 #x80))))
                     (note-stream-decoding-problem stream))
                   (let* ((s2 (funcall next-unit-function stream)))
                     (if (eq s2 :eof)
                       s2
                       (locally
                           (declare (type (unsigned-byte 8) s2))
                         (if (< 1st-unit #xf0)
                           (if (and (< (the fixnum (logxor s1 #x80)) #x40)
                                    (< (the fixnum (logxor s2 #x80)) #x40)
                                    (or (>= 1st-unit #xe1)
                                        (>= s1 #xa0)))
                             (or (code-char (the fixnum
                                          (logior (the fixnum
                                                    (ash (the fixnum (logand 1st-unit #xf))
                                                         12))
                                                  (the fixnum
                                                    (logior
                                                     (the fixnum
                                                       (ash (the fixnum (logand s1 #x3f))
                                                            6))
                                                     (the fixnum (logand s2 #x3f)))))))
                                 (note-stream-decoding-problem stream))
                             (note-stream-decoding-problem stream))
                           (if (< 1st-unit #xf8)
                             (let* ((s3 (funcall next-unit-function stream)))
                               (if (eq s3 :eof)
                                 s3
                                 (locally
                                     (declare (type (unsigned-byte 8) s3))
                                   (if (and (< (the fixnum (logxor s1 #x80)) #x40)
                                            (< (the fixnum (logxor s2 #x80)) #x40)
                                            (< (the fixnum (logxor s3 #x80)) #x40)
                                            (or (>= 1st-unit #xf1)
                                                (>= s1 #x90)))
                                     (code-char
                                      (logior
                                       (the fixnum
                                         (logior
                                          (the fixnum
                                            (ash (the fixnum (logand 1st-unit 7)) 18))
                                          (the fixnum
                                            (ash (the fixnum (logxor s1 #x80)) 12))))
                                       (the fixnum
                                         (logior
                                          (the fixnum
                                            (ash (the fixnum (logxor s2 #x80)) 6))
                                          (the fixnum (logxor s3 #x80))))))


                                     (note-stream-decoding-problem stream)))))
                             (note-stream-decoding-problem stream))))))))))
           (note-stream-decoding-problem stream)))))
    :vector-encode-function
    (nfunction
     utf-8-vector-encode
     (lambda (string vector idx start end)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector)
                (fixnum idx))
       (do* ((i start (1+ i)))
            ((>= i end) idx)
         (let* ((char (schar string i))
                (code (char-code char)))
           (declare (type (mod #x110000) code))
           (cond ((< code #x80)
                  (setf (aref vector idx) code)
                  (incf idx))
                 ((< code #x800)
                  (setf (aref vector idx)
                        (logior #xc0 (the fixnum (ash code -6))))
                  (setf (aref vector (the fixnum (1+ idx)))
                        (logior #x80 (the fixnum (logand code #x3f))))
                  (incf idx 2))
                 ((< code #x10000)
                  (setf (aref vector idx)
                        (logior #xe0 (the fixnum (ash code -12))))
                  (setf (aref vector (the fixnum (1+ idx)))
                        (logior #x80 (the fixnum (logand #x3f (the fixnum (ash code -6))))))
                  (setf (aref vector (the fixnum (+ idx 2)))
                        (logior #x80 (the fixnum (logand code #x3f))))
                  (incf idx 3))
                 (t
                   (setf (aref vector idx)
                         (logior #xf0
                                 (the fixnum (logand #x7 (the fixnum (ash code -18))))))
                   (setf (aref vector (the fixnum (1+ idx)))
                         (logior #x80 (the fixnum (logand #x3f (the fixnum (ash code -12))))))
                   (setf (aref vector (the fixnum (+ idx 2)))
                         (logior #x80 (the fixnum (logand #x3f (the fixnum (ash code -6))))))
                   (setf (aref vector (the fixnum (+ idx 3)))
                         (logior #x80 (logand #x3f code)))
                   (incf idx 4)))))))
    :vector-decode-function
    (nfunction
     utf-8-vector-decode
     (lambda (vector idx noctets string)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector)
                (type index idx))
       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx (1+ index)))
            ((= index end) index)
           (let* ((1st-unit (aref vector index)))
             (declare (type (unsigned-byte 8) 1st-unit))
             (let* ((char 
                     (if (< 1st-unit #x80)
                       (code-char 1st-unit)
                       (if (>= 1st-unit #xc2)
                           (let* ((2nd-unit (aref vector (incf index))))
                             (declare (type (unsigned-byte 8) 2nd-unit))
                             (if (< 1st-unit #xe0)
                               (if (< (the fixnum (logxor 2nd-unit #x80)) #x40)
                                 (code-char
                                  (logior
                                   (the fixnum (ash (the fixnum (logand #x1f 1st-unit)) 6))
                                   (the fixnum (logxor 2nd-unit #x80)))))
                               (let* ((3rd-unit (aref vector (incf index))))
                                 (declare (type (unsigned-byte 8) 3rd-unit))
                                 (if (< 1st-unit #xf0)
                                   (if (and (< (the fixnum (logxor 2nd-unit #x80)) #x40)
                                            (< (the fixnum (logxor 3rd-unit #x80)) #x40)
                                            (or (>= 1st-unit #xe1)
                                                (>= 2nd-unit #xa0)))
                                     (code-char (the fixnum
                                                  (logior (the fixnum
                                                            (ash (the fixnum (logand 1st-unit #xf))
                                                                 12))
                                                          (the fixnum
                                                            (logior
                                                             (the fixnum
                                                               (ash (the fixnum (logand 2nd-unit #x3f))
                                                                    6))
                                                             (the fixnum (logand 3rd-unit #x3f))))))))
                                   (let* ((4th-unit (aref vector (incf index))))
                                     (declare (type (unsigned-byte 8) 4th-unit))
                                     (if (and (< (the fixnum (logxor 2nd-unit #x80)) #x40)
                                              (< (the fixnum (logxor 3rd-unit #x80)) #x40)
                                              (< (the fixnum (logxor 4th-unit #x80)) #x40)
                                              (or (>= 1st-unit #xf1)
                                                  (>= 2nd-unit #x90)))
                                       (code-char
                                        (logior
                                         (the fixnum
                                           (logior
                                            (the fixnum
                                              (ash (the fixnum (logand 1st-unit 7)) 18))
                                            (the fixnum
                                              (ash (the fixnum (logxor 2nd-unit #x80)) 12))))
                                         (the fixnum
                                           (logior
                                            (the fixnum
                                              (ash (the fixnum (logxor 3rd-unit #x80)) 6))
                                            (the fixnum (logxor 4th-unit #x80))))))))))))))))
               (setf (schar string i) (or char (note-vector-decoding-problem vector index :utf-8))))))))
    :memory-encode-function
    #'utf-8-memory-encode
    :memory-decode-function
    #'utf-8-memory-decode
    :octets-in-string-function
    #'utf-8-octets-in-string
    :length-of-vector-encoding-function
    (nfunction
     utf-8-length-of-vector-encoding
     (lambda (vector start end)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector))
       (do* ((i start)
             (nchars 0))
            ((>= i end)
             (values nchars i))
         (declare (fixnum i))
         (let* ((code (aref vector i))
                (nexti (+ i (cond ((< code #xc2) 1)
                                  ((< code #xe0) 2)
                                  ((< code #xf0) 3)
                                  ((< code #xf8) 4)
                                  (t 1)))))
           (declare (type (unsigned-byte 8) code))
           (if (> nexti end)
             (return (values nchars i))
             (setq nchars (1+ nchars) i nexti))))))
    :length-of-memory-encoding-function
    #'utf-8-length-of-memory-encoding
    :decode-literal-code-unit-limit #x80
    :encode-literal-char-code-limit #x80    
    :bom-encoding #(#xef #xbb #xbf)
    :character-size-in-octets-function  (lambda (c)
                                          (let* ((code (char-code c)))
                                            (declare (type (mod #x110000) code))
                                            (if (< code #x80)
                                              1
                                              (if (< code #x800)
                                                2
                                                (if (< code #x10000)
                                                  3
                                                  4)))))
      
    )


;;; For a code-unit-size greater than 8: the stream-encode function's write-function
;;; accepts a code-unit in native byte order and swaps it if necessary and the
;;; stream-decode function receives a first-unit in native byte order and its
;;; next-unit-function returns a unit in native byte order.  The memory/vector
;;; functions have to do their own byte swapping.


(defmacro utf-16-combine-surrogate-pairs (a b)
  `(code-char
    (the (unsigned-byte 21)
      (+ #x10000
         (the (unsigned-byte 20)
           (logior
            (the (unsigned-byte 20) (ash (the (unsigned-byte 10)
                                           (- ,a #xd800))
                                         10))
            (the (unsigned-byte 10) (- ,b #xdc00))))))))
    
(defun utf-16-stream-encode (char write-function stream)
  (let* ((code (char-code char))
         (highbits (- code #x10000)))
    (declare (type (mod #x110000) code)
             (fixnum highbits))
    (if (< highbits 0)
      (progn
        (funcall write-function stream code)
        1)
      (progn
        (funcall write-function stream (logior #xd800 (the fixnum (ash highbits -10))))
        (funcall write-function stream (logior #xdc00 (the fixnum (logand highbits #x3ff))))
        2))))

(defun utf-16-stream-decode (1st-unit next-unit-function stream)
  (declare (type (unsigned-byte 16) 1st-unit))
  (if (or (< 1st-unit #xd800)
          (>= 1st-unit #xe000))
    (code-char 1st-unit)
    (if (< 1st-unit #xdc00)
      (let* ((2nd-unit (funcall next-unit-function stream)))
        (if (eq 2nd-unit :eof)
          2nd-unit
          (locally (declare (type (unsigned-byte 16) 2nd-unit))
            (if (and (>= 2nd-unit #xdc00)
                     (< 2nd-unit #xe000))
              (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)
              (note-stream-decoding-problem stream)))))
      (note-stream-decoding-problem stream))))



(declaim (inline %big-endian-u8-ref-u16 %little-endian-u8-ref-u16))
(defun %big-endian-u8-ref-u16 (u8-vector idx)
  (declare (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (logior (the (unsigned-byte 16) (ash (the (unsigned-byte 8) (aref u8-vector idx)) 8))
          (the (unsigned-byte 8) (aref u8-vector (the fixnum (1+ idx))))))

(defun %little-endian-u8-ref-u16 (u8-vector idx)
  (declare (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (logior (the (unsigned-byte 16) (ash (the (unsigned-byte 8)
                                         (aref u8-vector (the fixnum (1+ idx)))) 8))
          (the (unsigned-byte 8) (aref u8-vector idx))))

#+big-endian-target
(progn
(defmacro %native-u8-ref-u16 (vector idx)
  `(%big-endian-u8-ref-u16 ,vector ,idx))

(defmacro %reversed-u8-ref-u16 (vector idx)
  `(%little-endian-u8-ref-u16 ,vector ,idx))
)

#+little-endian-target
(progn
(defmacro %native-u8-ref-u16 (vector idx)
  `(%little-endian-u8-ref-u16 ,vector ,idx))

(defmacro %reversed-u8-ref-u16 (vector idx)
  `(%big-endian-u8-ref-u16 ,vector ,idx))
)


(declaim (inline (setf %big-endian-u8-ref-u16) (setf %little-endian-u8-ref-u16)))
(defun (setf %big-endian-u8-ref-u16) (val u8-vector idx)
  (declare (type (unsigned-byte 16) val)
           (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (setf (aref u8-vector idx) (ldb (byte 8 8) val)
        (aref u8-vector (the fixnum (1+ idx))) (ldb (byte 8 0) val))
  val)

(defun (setf %little-endian-u8-ref-u16) (val u8-vector idx)
  (declare (type (unsigned-byte 16) val)
           (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (setf (aref u8-vector idx) (ldb (byte 8 0) val)
        (aref u8-vector (the fixnum (1+ idx))) (ldb (byte 8 8) val))
  val)

(defun utf-16-character-size-in-octets (c)
  (let* ((code (char-code c)))
    (declare (type (mod #x110000) code))
    (if (< code #x10000)
      2
      4)))

;;; utf-16, native byte order.
(define-character-encoding #+big-endian-target :utf-16be #-big-endian-target :utf-16le
    #+big-endian-target
    "A 16-bit, variable-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
big-endian word and characters with larger codes can be encoded in a
pair of 16-bit big-endian words.  The endianness of the encoded data
is implicit in the encoding; byte-order-mark characters are not
interpreted on input or prepended to output."
    #+little-endian-target
    "A 16-bit, variable-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
little-endian word and characters with larger codes can be encoded in
a pair of 16-bit little-endian words.  The endianness of the encoded
data is implicit in the encoding; byte-order-mark characters are not
interpreted on input or prepended to output."
    :max-units-per-char 2
    :code-unit-size 16
    :native-endianness t
    :stream-encode-function
    #'utf-16-stream-encode
    :stream-decode-function
    #'utf-16-stream-decode
    :vector-encode-function
    (nfunction
     native-utf-16-vector-encode
     (lambda (string vector idx start end)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector)
                (fixnum idx start end))
       (do* ((i start (1+ i)))
            ((>= i end) idx)
         (declare (fixnum i))
         (let* ((char (schar string i))
                (code (char-code char))
                (highbits (- code #x10000)))
           (declare (type (mod #x110000) code)
                    (fixnum highbits))
           (cond ((< highbits 0)
                  (setf (%native-u8-ref-u16 vector idx) code)
                  (incf idx 2))
                 (t
                  (let* ((firstword (logior #xd800 (the fixnum (ash highbits -10))))
                         (secondword (logior #xdc00 (the fixnum (logand highbits #x3ff)))))
                    (declare (type (unsigned-byte 16) firstword secondword))
                    (setf (%native-u8-ref-u16 vector idx) firstword
                          (%native-u8-ref-u16 vector (the fixnum (+ idx 2))) secondword)
                    (incf idx 4))))))))
    :vector-decode-function
    (nfunction
     native-utf-16-vector-decode
     (lambda (vector idx noctets string)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector)
                (type index idx))
       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx))
            ((= index end) index)
         (declare (fixnum i end index))
         (let* ((1st-unit (%native-u8-ref-u16 vector index)))
           (declare (type (unsigned-byte 16) 1st-unit))
           (incf index 2)
           (let* ((char
                   (if (or (< 1st-unit #xd800)
                           (>= 1st-unit #xe000))
                     (code-char 1st-unit)
                     (if (< 1st-unit #xdc00)
                       (let* ((2nd-unit (%native-u8-ref-u16 vector index)))
                         (declare (type (unsigned-byte 16) 2nd-unit))
                         (incf index 2)
                         (if (and (>= 2nd-unit #xdc00)
                                  (< 2nd-unit #xe000))
                           (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
             (setf (schar string i) (or char (note-vector-decoding-problem vector index #+big-endian-target :utf-16be #-big-endian-target :utf-16le))))))))
    :memory-encode-function
    (nfunction
     native-utf-16-memory-encode
     (lambda (string pointer idx start end)
       (declare (fixnum idx))
       (do* ((i start (1+ i)))
            ((>= i end) idx)
         (let* ((code (char-code (schar string i)))
                (highbits (- code #x10000)))
           (declare (type (mod #x110000) code)
                  (fixnum  highbits))
         (cond ((< highbits 0)
                (setf (%get-unsigned-word pointer idx) code)
                (incf idx 2))
               (t
                (setf (%get-unsigned-word pointer idx) (logior #xd800 (the fixnum (ash highbits -10))))
                (incf idx 2)
                (setf (%get-unsigned-word pointer idx) (logior #xdc00 (the fixnum (logand highbits #x3ff))))
                (incf idx 2)))))))
    :memory-decode-function
    (nfunction
     native-utf-16-memory-decode
     (lambda (pointer noctets idx string)
       (declare (fixnum noctets idx))
       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx))
            ((>= index end) index)
         (declare (fixnum i index end))
         (let* ((1st-unit (%get-unsigned-word pointer index)))
           (declare (type (unsigned-byte 16) 1st-unit))
           (incf index 2)
           (let* ((char
                   (if (or (< 1st-unit #xd800)
                           (>= 1st-unit #xe000))
                     (code-char 1st-unit)
                     (if (< 1st-unit #xdc00)
                       (let* ((2nd-unit (%get-unsigned-word pointer index)))
                           (declare (type (unsigned-byte 16) 2nd-unit))
                           (incf index)
                           (if (and (>= 2nd-unit #xdc00)
                                    (< 2nd-unit #xe000))
                             (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
            (setf (schar string i) (or char (note-vector-decoding-problem pointer index #+big-endian-target :utf-16be #-big-endian-target :utf-16le))))))))
    :octets-in-string-function
    #'utf-16-octets-in-string
    :length-of-vector-encoding-function
    (nfunction
     native-utf-16-length-of-vector-encoding
     (lambda (vector start end)
       (declare (type (simple-array (unsigned-byte 8) (*)) vector))
       (declare (fixnum start end))
       (do* ((i start)
             (j (+ 2 i) (+ 2 i))
             (nchars 0))
            ((> j end) (values nchars i))
         (declare (fixnum i j nchars))
         (let* ((code (%native-u8-ref-u16 vector i))
                (nexti (+ i (if (or (< code #xd800)
                                    (>= code #xdc00))
                              2
                              4))))
           (declare (type (unsigned-byte 16) code)
                    (fixnum nexti))
           (if (> nexti end)
             (return (values nchars i))
             (setq i nexti nchars (1+ nchars)))))))
    :length-of-memory-encoding-function
    (nfunction
     native-utf-16-length-of-memory-encoding
     (lambda (pointer noctets start)
       (do* ((i start)
             (j (+ i 2) (+ i 2))
             (end (+ start noctets))
             (nchars 0))
            ((> j end) (values nchars i))
         (let* ((code (%get-unsigned-word pointer i))
                (nexti (+ i (if (or (< code #xd800)
                                    (>= code #xdc00))
                              2
                              4))))
           (declare (type (unsigned-byte 16) code)
                    (fixnum nexti))
           (if (> nexti end)
             (return (values nchars i))
             (setq i nexti nchars (1+ nchars)))))))
    :decode-literal-code-unit-limit #xd800  
    :encode-literal-char-code-limit #x10000
    :nul-encoding #(0 0)
    :character-size-in-octets-function 'utf-16-character-size-in-octets
    )

;;; utf-16, reversed byte order
(define-character-encoding #+big-endian-target :utf-16le #-big-endian-target :utf-16be
   #+little-endian-target
   "A 16-bit, variable-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
big-endian word and characters with larger codes can be encoded in a
pair of 16-bit big-endian words.  The endianness of the encoded data
is implicit in the encoding; byte-order-mark characters are not
interpreted on input or prepended to output."
  #+big-endian-target
  "A 16-bit, variable-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
little-endian word and characters with larger codes can be encoded in
a pair of 16-bit little-endian words.  The endianness of the encoded
data is implicit in the encoding; byte-order-mark characters are not
interpreted on input or prepended to output."
  :max-units-per-char 2
  :code-unit-size 16
  :native-endianness nil
  :stream-encode-function
  #'utf-16-stream-encode
  :stream-decode-function
  #'utf-16-stream-decode
  :vector-encode-function
  (nfunction
   reversed-utf-16-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx start end))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (declare (fixnum i))
       (let* ((char (schar string i))
              (code (char-code char))
              (highbits (- code #x10000)))
         (declare (type (mod #x110000) code)
                  (fixnum highbits))
         (cond ((< highbits 0)
                (setf (%reversed-u8-ref-u16 vector idx) code)
                (incf idx 2))
               (t
                (let* ((firstword (logior #xd800 (the fixnum (ash highbits -10))))
                       (secondword (logior #xdc00 (the fixnum (logand highbits #x3ff)))))
                  (declare (type (unsigned-byte 16) firstword secondword))
                  (setf (%reversed-u8-ref-u16 vector idx) firstword
                        (%reversed-u8-ref-u16 vector (the fixnum (+ idx 2))) secondword)
                  (incf idx 4))))))))
  :vector-decode-function
  (nfunction
   reversed-utf-16-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx))
          ((= index end) index)
       (declare (fixnum i end index))
       (let* ((1st-unit (%reversed-u8-ref-u16 vector index)))
         (declare (type (unsigned-byte 16) 1st-unit))
         (incf index 2)
         (let* ((char
                 (if (or (< 1st-unit #xd800)
                         (>= 1st-unit #xe000))
                   (code-char 1st-unit)
                   (if (< 1st-unit #xdc00)
                     (let* ((2nd-unit (%reversed-u8-ref-u16 vector index)))
                       (declare (type (unsigned-byte 16) 2nd-unit))
                       (incf index 2)
                       (if (and (>= 2nd-unit #xdc00)
                                (< 2nd-unit #xe000))
                         (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
           (setf (schar string i) (or char (note-vector-decoding-problem vector index #+big-endian-target :utf-16le #-big-endian-target :utf-16be))))))))
  :memory-encode-function
  (nfunction
   reversed-utf-16-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((code (char-code (schar string i)))
              (highbits (- code #x10000)))
         (declare (type (mod #x110000) code)
                  (fixnum  highbits))
         (cond ((< highbits 0)
                (setf (%get-unsigned-word pointer idx) (%swap-u16 code))
                (incf idx 2))
               (t
                (setf (%get-unsigned-word pointer idx) (%swap-u16 (logior #xd800 (the fixnum (ash highbits -10)))))
                (incf idx 2)
                (setf (%get-unsigned-word pointer idx) (%swap-u16 (logior #xdc00 (the fixnum (logand highbits #x3ff)))))
                (incf idx 2)))))))
  :memory-decode-function
  (nfunction
   reversed-utf-16-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx))
          ((>= index end) index)
       (declare (fixnum i index end))
       (let* ((1st-unit (%swap-u16 (%get-unsigned-word pointer index))))
         (declare (type (unsigned-byte 16) 1st-unit))
         (incf index 2)
         (let* ((char
                 (if (or (< 1st-unit #xd800)
                         (>= 1st-unit #xe000))
                   (code-char 1st-unit)
                   (if (< 1st-unit #xdc00)
                     (let* ((2nd-unit (%swap-u16 (%get-unsigned-word pointer index))))
                       (declare (type (unsigned-byte 16) 2nd-unit))
                       (incf index)
                       (if (and (>= 2nd-unit #xdc00)
                                (< 2nd-unit #xe000))
                         (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
           (setf (schar string i) (or char (note-vector-decoding-problem pointer index #+big-endian-target :utf-16le #-big-endian-target :utf-16be))))))))
  :octets-in-string-function
  #'utf-16-octets-in-string
  :length-of-vector-encoding-function
  (nfunction
   reversed-utf-16-length-of-vector-encoding
   (lambda (vector start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector))
     (declare (fixnum start end))
     (do* ((i start)
           (j (+ 2 i) (+ 2 i))
           (nchars 0))
          ((> j end) (values nchars i))
       (declare (fixnum i j nchars))
       (let* ((code (%reversed-u8-ref-u16 vector i))
              (nexti (+ i (if (or (< code #xd800)
                                  (>= code #xdc00))
                            2
                            4))))
         (declare (type (unsigned-byte 16) code)
                  (fixnum nexti))
         (if (> nexti end)
           (return (values nchars i))
           (setq i nexti nchars (1+ nchars)))))))
  :length-of-memory-encoding-function
  (nfunction
   reversed-utf-16-length-of-memory-encoding
   (lambda (pointer noctets start)
     (do* ((i start)
           (j (+ i 2) (+ i 2))
           (end (+ start noctets))
           (nchars 0))
          ((> j end) (values nchars i))
       (let* ((code (%swap-u16 (%get-unsigned-word pointer i)))
              (nexti (+ i (if (or (< code #xd800)
                                  (>= code #xdc00))
                            2
                            4))))
         (declare (type (unsigned-byte 16) code)
                  (fixnum nexti))
         (if (> nexti end)
           (return (values nchars i))
           (setq i nexti nchars (1+ nchars)))))))
  :decode-literal-code-unit-limit #xd800
  :encode-literal-char-code-limit #x10000
  :nul-encoding #(0 0)
  :character-size-in-octets-function 'utf-16-character-size-in-octets
  )

;;; UTF-16.  Memory and vector functions determine endianness of
;;; input by the presence of a byte-order mark (or swapped BOM)
;;; at the beginning of input, and assume big-endian order
;;; if this mark is missing; on output, a BOM is prepended and
;;; things are written in native byte order.
;;; The endianness of stream-io operations is determined by
;;; stream content; new output streams are written in native
;;; endianness with a BOM character prepended.  Input streams
;;; are read in native byte order if the initial character is
;;; a BOM, in reversed byte order if the initial character is
;;; a swapped BOM, and in big-endian order (per RFC 2781) if
;;; there is no BOM.

(define-character-encoding :utf-16
    "A 16-bit, variable-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
word and characters with larger codes can be encoded in a
pair of 16-bit words.  The endianness of the encoded data is
indicated by the endianness of a byte-order-mark character (#\u+feff)
prepended to the data; in the absence of such a character on input,
the data is assumed to be in big-endian order. Output is written
in native byte-order with a leading byte-order mark."    
  :max-units-per-char 2
  :code-unit-size 16
  :native-endianness t                  ;not necessarily true.
  :stream-encode-function
  #'utf-16-stream-encode
  :stream-decode-function
  #'utf-16-stream-decode
  :vector-encode-function
  (nfunction
   utf-16-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (setf (%native-u8-ref-u16 vector idx) byte-order-mark-char-code)
     (incf idx 2)
     (do* ((i start (1+ i)))
            ((>= i end) idx)
         (declare (fixnum i))
         (let* ((char (schar string i))
                (code (char-code char))
                (highbits (- code #x10000)))
           (declare (type (mod #x110000) code)
                    (fixnum highbits))
           (cond ((< highbits 0)
                  (setf (%native-u8-ref-u16 vector idx) code)
                  (incf idx 2))
                 (t
                  (let* ((firstword (logior #xd800 (the fixnum (ash highbits -10))))
                         (secondword (logior #xdc00 (the fixnum (logand highbits #x3ff)))))
                    (declare (type (unsigned-byte 16) firstword secondword))
                    (setf (%native-u8-ref-u16 vector idx) firstword
                          (%native-u8-ref-u16 vector (the fixnum (+ idx 2))) secondword)
                    (incf idx 4))))))))
  :vector-decode-function
  (nfunction
   utf-16-vector-decode 
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 16) (*)) vector)
              (type index idx))
     (let* ((origin idx)
            (swap (if (>= noctets 2)
                    (case (%native-u8-ref-u16 vector idx)
                      (#.byte-order-mark-char-code
                       (incf idx 2) nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 2) t)
                      (t #+little-endian-target t)))))
       (do* ((i 0 (1+ i))
             (end (+ origin noctets))
             (index idx))
            ((= index end) index)
         (declare (fixnum i end index))
         (let* ((1st-unit (if swap
                            (%reversed-u8-ref-u16 vector index)
                            (%native-u8-ref-u16 vector index))))
           (declare (type (unsigned-byte 16) 1st-unit))
           (incf index 2)
           (let* ((char
                   (if (or (< 1st-unit #xd800)
                           (>= 1st-unit #xe000))
                     (code-char 1st-unit)
                     (if (< 1st-unit #xdc00)
                       (let* ((2nd-unit (if swap
                                          (%reversed-u8-ref-u16 vector index)
                                          (%native-u8-ref-u16 vector index))))
                         (declare (type (unsigned-byte 16) 2nd-unit))
                         (incf index 2)
                         (if (and (>= 2nd-unit #xdc00)
                                  (< 2nd-unit #xe000))
                           (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
             (setf (schar string i) (or char (note-vector-decoding-problem vector index :utf-16)))))))))
  :memory-encode-function
  (nfunction
   utf-16-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     ;; Output a BOM.
     (setf (%get-unsigned-word pointer idx) byte-order-mark-char-code)
     (incf idx 2)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((code (char-code (schar string i)))
              (highbits (- code #x10000)))
         (declare (type (mod #x110000) code)
                  (fixnum highbits))
         (cond ((< highbits 0)
                (setf (%get-unsigned-word pointer idx) code)
                (incf idx 2))
               (t
                (setf (%get-unsigned-word pointer idx) (logior #xd800 (the fixnum (ash highbits -10))))
                (setf (%get-unsigned-word pointer (the fixnum (+ idx 2)))
                      (logior #xdc00 (the fixnum (logand highbits #x3ff))))
                (incf idx 4)))))))
  :memory-decode-function
  (nfunction
   utf-16-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (let* ((swap (when (> noctets 1)
                    (case (%get-unsigned-word pointer idx)
                      (#.byte-order-mark-char-code
                       (incf idx 2)
                       (decf noctets 2)
                       nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 2)
                       (decf noctets 2)
                       t)
                      (t #+little-endian-target t)))))
       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx ))
            ((>= index end) index)
         (declare (fixnum i index end))
         (let* ((1st-unit (%get-unsigned-word pointer index)))
           (declare (type (unsigned-byte 16) 1st-unit))
           (incf index 2)
           (if swap (setq 1st-unit (%swap-u16 1st-unit)))
           (let* ((char
                   (if (or (< 1st-unit #xd800)
                           (>= 1st-unit #xe000))
                     (code-char 1st-unit)
                     (if (< 1st-unit #xdc00)
                       (let* ((2nd-unit (%get-unsigned-byte pointer index)))
                         (declare (type (unsigned-byte 16) 2nd-unit))
                         (if swap (setq 2nd-unit (%swap-u16 2nd-unit)))
                         (incf index 2)
                         (if (and (>= 2nd-unit #xdc00)
                                  (< 2nd-unit #xe000))
                           (utf-16-combine-surrogate-pairs 1st-unit 2nd-unit)))))))
             (setf (schar string i) (or char (note-vector-decoding-problem pointer index :utf-16)))))))))
  :octets-in-string-function
  (nfunction
   utf-16-bom-octets-in-string
   (lambda (string start end)
     (+ 2 (utf-16-octets-in-string string start end))))
  :length-of-vector-encoding-function
  (nfunction
   utf-16-length-of-vector-encoding
   (lambda (vector start end)
     (declare (type (simple-array (unsigned-byte 16) (*)) vector))
     (let* ((swap (when (>= end (+ start 2))
                    (case (%native-u8-ref-u16 vector start)
                      (#.byte-order-mark-char-code
                       (incf start 2)
                       nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf start 2)
                       t)
                      (t #+little-endian-target t)))))
       (do* ((i start)
             (j (+ 2 i) (+ 2 j))
             (nchars 0))
            ((> j end)
             (values nchars i))
         (let* ((code (if swap
                        (%reversed-u8-ref-u16 vector i)
                        (%native-u8-ref-u16 vector i)))
                (nexti (+ i (if (or (< code #xd800)
                                    (>= code #xdc00))
                              2
                              4))))
           (declare (type (unsigned-byte 16) code)
                    (fixnum nexti))
           (if (> nexti end)
             (return (values nchars i))
             (setq i nexti nchars (1+ nchars))))))))
  :length-of-memory-encoding-function
  (nfunction
   utf-16-length-of-memory-encoding
   (lambda (pointer noctets start)
     (declare (fixnum noctets start))
     (when (oddp noctets)
       (setq noctets (1- noctets)))
     (let* ((origin start)
            (swap (when (>= noctets 2)
                    (case (%get-unsigned-word pointer (+ start start))
                      (#.byte-order-mark-char-code
                       (incf start 2)
                       nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf start 2)
                       t)
                      (t #+little-endian-target t)))))
       (declare (fixnum origin))
       (do* ((i start)
             (j (+ i 2) (+ i 2))
             (end (+ origin noctets))
             (nchars 0 (1+ nchars)))
            ((> j end) (values nchars (- i origin)))
         (declare (fixnum i j end nchars))
         (let* ((code (%get-unsigned-word pointer i)))
           (declare (type (unsigned-byte 16) code))
           (if swap (setq code (%swap-u16 code)))
           (let* ((nexti (+ i (if (or (< code #xd800)
                                      (>= code #xdc00))
                                2
                                4))))
             (declare (fixnum nexti))
             (if (> nexti end)
               (return (values nchars (- i origin)))
               (setq i nexti))))))))
  :decode-literal-code-unit-limit #xd800
  :encode-literal-char-code-limit #x10000  
  :use-byte-order-mark
  #+big-endian-target :utf-16le
  #+little-endian-target :utf-16be
  :bom-encoding #+big-endian-target #(#xfe #xff) #+little-endian-target #(#xff #xfe)
  :nul-encoding #(0 0)
  :character-size-in-octets-function 'utf-16-character-size-in-octets  
  )


(defun two-octets-per-character (c)
  (declare (ignore c))
  2)

(defun ucs-2-stream-encode (char write-function stream)
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (if (>= code #x10000)
      (setq code (note-encoding-problem char stream :ucs-2 (char-code #\Replacement_Character))))
    (funcall write-function stream code)
    1))

(defun ucs-2-stream-decode (1st-unit next-unit-function stream)
  (declare (type (unsigned-byte 16) 1st-unit)
           (ignore next-unit-function))
  ;; CODE-CHAR returns NIL on either half of a surrogate pair.
  (or (code-char 1st-unit)
      (note-stream-decoding-problem stream)))


(defun ucs-2-octets-in-string (string start end)
  (declare (ignore string))
  (if (>= end start)
    (* 2 (- end start))
    0))

(defun ucs-2-length-of-vector-encoding (vector start end)
  (declare (ignore vector))
  (let* ((noctets (max (- end start) 0)))
    (values (ash noctets -1) (+ start (logandc2 noctets 1)))))

(defun ucs-2-length-of-memory-encoding (pointer noctets start)
  (declare (ignore pointer start))
  (values (ash noctets -1) (logandc2 noctets 1)))



;;; UCS-2, native byte order
(define-character-encoding #+big-endian-target :ucs-2be #-big-endian-target :ucs-2le
  #+big-endian-target
  "A 16-bit, fixed-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
big-endian word. The encoded data is implicitly big-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  #+little-endian-target
  "A 16-bit, fixed-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
little-endian word. The encoded data is implicitly little-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  :max-units-per-char 1
  :code-unit-size 16
  :native-endianness t
  :stream-encode-function
  #'ucs-2-stream-encode
  :stream-decode-function
  #'ucs-2-stream-decode
  :vector-encode-function
  (nfunction
   native-ucs-2-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (when (>= code #x10000)
           (setq code (note-encoding-problem char vector #+big-endian-target :ucs-2be #-big-endian-target :ucs-2le (char-code #\Replacement_Character))))
         (setf (%native-u8-ref-u16 vector idx) code)
         (incf idx 2)))))
  :vector-decode-function
  (nfunction
   native-ucs-2-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx (+ 2 index)))
          ((>= index end) index)
       (declare (fixnum i end index))
       (setf (schar string i)
             (or (code-char (%native-u8-ref-u16 vector index))
                 (note-vector-decoding-problem vector index  #+big-endian-target :ucs-2be #-big-endian-target :ucs-2le))))))
  :memory-encode-function
  (nfunction
   native-ucs-2-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-word pointer idx)
                      (if (>= code #x10000)
                        (note-encoding-problem char pointer #+big-endian-target :ucs-2be #-big-endian-target :ucs-2le (char-code #\Replacement_Character))
                        code))
         (incf idx 2)))))
  :memory-decode-function
  (nfunction
   native-ucs-2-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (do* ((i 0 (1+ i))
           (index idx (+ index 2)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%get-unsigned-word pointer index)))
         (declare (type (unsigned-byte 16) 1st-unit))
         (setf (schar string i) (or (char-code 1st-unit) (note-vector-decoding-problem pointer index  #+big-endian-target :ucs-2be #-big-endian-target :ucs-2le)))))))
  :octets-in-string-function
  #'ucs-2-octets-in-string
  :length-of-vector-encoding-function
  #'ucs-2-length-of-vector-encoding
  :length-of-memory-encoding-function
  #'ucs-2-length-of-memory-encoding
  :decode-literal-code-unit-limit #x10000
  :encode-literal-char-code-limit #x10000  
  :nul-encoding #(0 0)
  :character-size-in-octets-function 'two-octets-per-character
  )

;;; UCS-2, reversed byte order
(define-character-encoding #+big-endian-target :ucs-2le #-big-endian-target :ucs-2be
  #+little-endian-target
  "A 16-bit, fixed-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit
big-endian word. The encoded data is implicitly big-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  #+big-endian-target
  "A 16-bit, fixed-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit

little-endian word. The encoded data is implicitly little-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  :max-units-per-char 1
  :code-unit-size 16
  :native-endianness nil
  :stream-encode-function
  #'ucs-2-stream-encode
  :stream-decode-function
  #'ucs-2-stream-decode
  :vector-encode-function
  (nfunction
   reversed-ucs-2-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (when (>= code #x10000)
           (setq code (note-encoding-problem char vector #+big-endian-target :ucs-2le #-big-endian-target :ucs-2be (char-code #\Replacement_Character))))
         (setf (%reversed-u8-ref-u16 vector idx) code)
         (incf idx 2)))))
  :vector-decode-function
  (nfunction
   reversed-ucs-2-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx (+ 2 index)))
          ((>= index end) index)
       (declare (fixnum i end index))
       (setf (schar string i)
             (or (code-char (%reversed-u8-ref-u16 vector index))
                 (note-vector-decoding-problem vector index #+big-endian-target :ucs-2le #-big-endian-target :ucs-2be))))))
  :memory-encode-function
  (nfunction
   reversed-ucs-2-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-word pointer idx)
               (if (>= code #x10000)
                 (%swap-u16 (note-encoding-problem char pointer #+big-endian-target :ucs-2le #-big-endian-target :ucs-2be (char-code #\Replacement_Character)))
                 (%swap-u16 code)))
         (incf idx 2)))))
  :memory-decode-function
  (nfunction
   reversed-ucs-2-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (do* ((i 0 (1+ i))
           (index idx (+ index 2)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%swap-u16 (%get-unsigned-word pointer index))))
         (declare (type (unsigned-byte 16) 1st-unit))
         (setf (schar string i) (or (code-char 1st-unit) (note-vector-decoding-problem pointer index #+big-endian-target :ucs-2le #-big-endian-target :ucs-2be)))))))
  :octets-in-string-function
  #'ucs-2-octets-in-string
  :length-of-vector-encoding-function
  #'ucs-2-length-of-vector-encoding
  :length-of-memory-encoding-function
  #'ucs-2-length-of-memory-encoding
  :decode-literal-code-unit-limit #x10000
  :encode-literal-char-code-limit #x10000
  :nul-encoding #(0 0)
  :character-size-in-octets-function 'two-octets-per-character
  )

(define-character-encoding :ucs-2
    "A 16-bit, fixed-length encoding in which characters with
CHAR-CODEs less than #x10000 can be encoded in a single 16-bit word.
The endianness of the encoded data is indicated by the endianness of a
byte-order-mark character (#\u+feff) prepended to the data; in the
absence of such a character on input, the data is assumed to be in
big-endian order."
  :max-units-per-char 1
  :code-unit-size 16
  :native-endianness t                  ;not necessarily true.
  :stream-encode-function
  #'ucs-2-stream-encode
  :stream-decode-function
  #'ucs-2-stream-decode
  :vector-encode-function
  (nfunction
   ucs-2-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (setf (%native-u8-ref-u16 vector idx) byte-order-mark-char-code)
     (incf idx 2)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (when (>= code #x10000)
           (setq code (note-encoding-problem char vector :ucs-2 (char-code #\Replacement_Character))))
         (setf (%native-u8-ref-u16 vector idx) code)
         (incf idx 2)))))
  :vector-decode-function
  (nfunction
   ucs-2-vector-decode 
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx)
              (fixnum noctets))
     (let* ((swap (if (> noctets 1)
                    (case (%native-u8-ref-u16 vector idx)
                      (#.byte-order-mark-char-code
                       (incf idx 2) (decf noctets 2) nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 2) (decf noctets 2) t)
                       (t #+little-endian-target t)))))

       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx (1+ index)))
            ((>= index end) index)
         (declare (fixnum i end index))
         (let* ((1st-unit (if swap
                            (%reversed-u8-ref-u16 vector index)
                            (%native-u8-ref-u16 vector index))))
             (declare (type (unsigned-byte 16) 1st-unit))
             (setf (schar string i) (or (code-char 1st-unit)
                                        (note-vector-decoding-problem vector index :ucs-2))))))))
  :memory-encode-function
  (nfunction
   ucs-2-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (setf (%get-unsigned-word pointer idx) byte-order-mark-char-code)
     (incf idx 2)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-word pointer idx)
                      (if (>= code #x10000)
                        (note-encoding-problem char pointer :ucs-2 (char-code #\Replacement_Character))
                        code))
         (incf idx 2)))))
  :memory-decode-function
  (nfunction
   ucs-2-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (let* ((swap (when (> noctets 1)
                    (case (%get-unsigned-word pointer idx)
                      (#.byte-order-mark-char-code
                       (incf idx 2)
                       (decf noctets 2)
                       nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 2)
                       (decf noctets 2)
                       t)
                      (t #+little-endian-target t)))))
       (do* ((i 0 (1+ i))
           (index idx (+ index 2)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%get-unsigned-word pointer index)))
         (declare (type (unsigned-byte 16) 1st-unit))
         (if swap (setq 1st-unit (%swap-u16 1st-unit)))
         (setf (schar string i) (or (code-char 1st-unit)
                                    (note-vector-decoding-problem pointer index :ucs-2))))))))
  :octets-in-string-function
  (nfunction
   ucs-2-bom-octets-in-string
   (lambda (string start end)
     (+ 2 (ucs-2-octets-in-string string start end))))
  :length-of-vector-encoding-function
  (nfunction
   ucs-2-length-of-vector-encoding
   (lambda (vector start end)
     (declare (fixnum start end))
     (when (>= end (+ start 2))
       (let* ((maybe-bom (%native-u8-ref-u16 vector start)))
         (declare (type (unsigned-byte 16) maybe-bom))
         (when (or (= maybe-bom byte-order-mark-char-code)
                   (= maybe-bom swapped-byte-order-mark-char-code))
           (incf start 2))))
     (do* ((i start j)
           (j (+ i 2) (+ j 2))
           (nchars 0 (1+ nchars)))
          ((> j end) (values nchars i)))))
  :length-of-memory-encoding-function
  (nfunction
   ucs-2-length-of-memory-encoding
   (lambda (pointer noctets start)
     (let* ((skip 
             (when (> noctets 1)
               (case (%get-unsigned-word pointer start)
                 (#.byte-order-mark-char-code
                  2)
                 (#.swapped-byte-order-mark-char-code
                  2)))))
     (values (ash (- noctets skip) -1) (logandc2 noctets 1)))))
  :decode-literal-code-unit-limit #x10000
  :encode-literal-char-code-limit #x10000  
  :use-byte-order-mark
  #+big-endian-target :ucs-2le
  #+little-endian-target :ucs-2be
  :nul-encoding #(0 0)
  :character-size-in-octets-function 'two-octets-per-character
  )


(defun four-octets-per-character (c)
  (declare (ignore c))
  4)

(defun ucs-4-stream-encode (char write-function stream)
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (funcall write-function stream code)
    1))

(defun ucs-4-stream-decode (1st-unit next-unit-function stream)
  (declare (type (unsigned-byte 16) 1st-unit)
           (ignore next-unit-function stream))
  (code-char 1st-unit))


(defun ucs-4-octets-in-string (string start end)
  (declare (ignore string))
  (if (>= end start)
    (* 4 (- end start))
    0))


(declaim (inline %big-endian-u8-ref-u32 %little-endian-u8-ref-u32))
(defun %big-endian-u8-ref-u32 (u8-vector idx)
  (declare (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (logior (the (unsigned-byte 32) (ash (the (unsigned-byte 8) (aref u8-vector idx)) 24))
          (the (unsigned-byte 24)
            (logior
             (ash (the (unsigned-byte 8) (aref u8-vector (the fixnum (1+ idx)))) 16)
             (the (unsigned-byte 16)
               (logior
                (ash (the (unsigned-byte 8) (aref u8-vector (the fixnum (+ idx 2)))) 8)
                (the (unsigned-byte 8) (aref u8-vector (the fixnum (+ idx 3))))))))))

(defun %little-endian-u8-ref-u32 (u8-vector idx)
  (declare (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (logior (the (unsigned-byte 32) (ash (the (unsigned-byte 8) (aref u8-vector (the fixnum (+ idx 3)))) 24))
          (the (unsigned-byte 24)
            (logior
             (ash (the (unsigned-byte 8) (aref u8-vector (the fixnum (+ idx 2)))) 16)
             (the (unsigned-byte 16)
               (logior
                (ash (the (unsigned-byte 8) (aref u8-vector (the fixnum (1+ idx)))) 8)
                (the (unsigned-byte 8) (aref u8-vector (the fixnum idx)))))))))

#+big-endian-target
(progn
(defmacro %native-u8-ref-u32 (vector idx)
  `(%big-endian-u8-ref-u32 ,vector ,idx))

(defmacro %reversed-u8-ref-u32 (vector idx)
  `(%little-endian-u8-ref-u32 ,vector ,idx))
)

#+little-endian-target
(progn
(defmacro %native-u8-ref-u32 (vector idx)
  `(%little-endian-u8-ref-u32 ,vector ,idx))

(defmacro %reversed-u8-ref-u32 (vector idx)
  `(%big-endian-u8-ref-u32 ,vector ,idx))
)


(declaim (inline (setf %big-endian-u8-ref-32) (setf %little-endian-u8-ref-u32)))
(defun (setf %big-endian-u8-ref-u32) (val u8-vector idx)
  (declare (type (unsigned-byte 32) val)
           (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (setf (aref u8-vector idx) (ldb (byte 8 24) val)
        (aref u8-vector (the fixnum (1+ idx))) (ldb (byte 8 16) val)
        (aref u8-vector (the fixnum (+ idx 2))) (ldb (byte 8 8) val)
        (aref u8-vector (the fixnum (+ idx 3))) (ldb (byte 8 0) val))
  val)

(defun (setf %little-endian-u8-ref-u32) (val u8-vector idx)
  (declare (type (unsigned-byte 32) val)
           (type (simple-array (unsigned-byte 8) (*)) u8-vector)
           (fixnum idx))
  (setf (aref u8-vector idx) (ldb (byte 8 0) val)
        (aref u8-vector (the fixnum (1+ idx))) (ldb (byte 8 8) val)
        (aref u8-vector (the fixnum (+ idx 2))) (ldb (byte 8 16) val)
        (aref u8-vector (the fixnum (+ idx 3))) (ldb (byte 8 24) val))
  val)


;;; UTF-32/UCS-4, native byte order
(define-character-encoding #+big-endian-target :utf-32be #-big-endian-target :utf-32le
  #+big-endian-target
  "A 32-bit, fixed-length encoding in which all Unicode characters
encoded in a single 32-bit word. The encoded data is implicitly big-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  #+little-endian-target
  "A 32-bit, fixed-length encoding in which all Unicode characters can
encoded in a single 32-bit word. The encoded data is implicitly
little-endian; byte-order-mark characters are not interpreted on input
or prepended to output."
  :aliases #+big-endian-target '(:ucs-4be) #+little-endian-target '(:ucs-4le)
  :max-units-per-char 1
  :code-unit-size 32
  :native-endianness t
  :stream-encode-function
  #'ucs-4-stream-encode
  :Stream-decode-function
  #'ucs-4-stream-decode
  :vector-encode-function
  (nfunction
   native-ucs-4-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%native-u8-ref-u32 vector idx) code)
         (incf idx 4)))))
  :vector-decode-function
  (nfunction
   native-ucs-4-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx (+ 4 index)))
          ((>= index end) index)
       (declare (fixnum i end index))
       (let* ((code (%native-u8-ref-u32 vector index)))
         (declare (type (unsigned-byte 32) code))
         (setf (schar string i)
               (or (if (< code char-code-limit)
                      (code-char code))
                   (note-vector-decoding-problem vector index #+big-endian-target :utf-32be #-big-endian-target :utf-32le)))))))
  :memory-encode-function
  (nfunction
   native-ucs-4-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((code (char-code (schar string i))))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-long pointer idx) code)
         (incf idx 4)))))
  :memory-decode-function
  (nfunction
   native-ucs-4-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (do* ((i 0 (1+ i))
           (index idx (+ index 4)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%get-unsigned-long pointer index)))
         (declare (type (unsigned-byte 32) 1st-unit))
         (setf (schar string i) (or (if (< 1st-unit char-code-limit)
                                      (code-char 1st-unit))
                                    (note-vector-decoding-problem
                                     pointer index #+big-endian-target :utf-32be #-big-endian-target :utf-32le)))))))
  :octets-in-string-function
  #'ucs-4-octets-in-string
  :length-of-vector-encoding-function
  (nfunction
   native-ucs-4-length-of-vector-encoding
   (lambda (vector start end)
     (declare (ignore vector))
     (do* ((i start j)
           (j (+ i 4) (+ j 4))
           (nchars 0 (1+ nchars)))
          ((> j end) (values nchars i)))))
  :length-of-memory-encoding-function
  (nfunction
   native-ucs-4-length-of-memory-encoding
   (lambda (pointer noctets start)
     (declare (ignore pointer))
     (values (ash noctets -2) (+ start (logandc2 noctets 3)))))
  :decode-literal-code-unit-limit #x110000
  :encode-literal-char-code-limit #x110000
  :nul-encoding #(0 0 0 0)
  :character-size-in-octets-function 'four-octets-per-character
  )

;;; UTF-32/UCS-4, reversed byte order
(define-character-encoding #+big-endian-target :utf-32le #-big-endian-target :utf-32be
  #+little-endian-target
  "A 32-bit, fixed-length encoding in which all Unicode characters
encoded in a single 32-bit word. The encoded data is implicitly big-endian;
byte-order-mark characters are not interpreted on input or prepended
to output."
  #+big-endian-target
  "A 32-bit, fixed-length encoding in which all Unicode characters can
encoded in a single 32-bit word. The encoded data is implicitly
little-endian; byte-order-mark characters are not interpreted on input
or prepended to output."
  :aliases #+big-endian-target '(:ucs-4le) #+little-endian-target '(:ucs-4be)
  :max-units-per-char 1
  :code-unit-size 32
  :native-endianness nil
  :stream-encode-function
  #'ucs-4-stream-encode
  :Stream-decode-function
  #'ucs-4-stream-decode
  :vector-encode-function
  (nfunction
   native-ucs-4-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%reversed-u8-ref-u32 vector idx) code)
         (incf idx 4)))))
  :vector-decode-function
  (nfunction
   native-ucs-4-vector-decode
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx))
     (do* ((i 0 (1+ i))
           (end (+ idx noctets))
           (index idx (+ 4 index)))
          ((>= index end) index)
       (declare (fixnum i end index))
       (let* ((code (%reversed-u8-ref-u32 vector index)))
         (declare (type (unsigned-byte 32) code))
         (setf (schar string i)
               (or (if (< code char-code-limit)
                     (code-char code))
                   (note-vector-decoding-problem vector index #+big-endian-target :utf-32le #-big-endian-target :utf-32be)))))))
  :memory-encode-function
  (nfunction
   native-ucs-4-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((code (char-code (schar string i))))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-long pointer idx) (%swap-u32 code))
         (incf idx 4)))))
  :memory-decode-function
  (nfunction
   reversed-ucs-4-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (do* ((i 0 (1+ i))
           (index idx (+ index 4)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%swap-u32 (%get-unsigned-long pointer index))))
         (declare (type (unsigned-byte 32) 1st-unit))
         (setf (schar string i) (or (if (< 1st-unit char-code-limit)
                                      (code-char 1st-unit))
                                    (note-vector-decoding-problem pointer index #+big-endian-target :utf-32le #-big-endian-target :utf-32be)))))))

  :octets-in-string-function
  #'ucs-4-octets-in-string
  :length-of-vector-encoding-function
  (nfunction
   reversed-ucs-4-length-of-vector-encoding
   (lambda (vector start end)
     (declare (ignore vector))
     (do* ((i start j)
           (j (+ i 4) (+ j 4))
           (nchars 0 (1+ nchars)))
          ((> j end) (values nchars i)))))
  :length-of-memory-encoding-function
  (nfunction
   reversed-ucs-4-length-of-memory-encoding
   (lambda (pointer noctets start)
     (declare (ignore pointer))
     (values (ash noctets -2) (+ start (logandc2 noctets 3)))))
  :decode-literal-code-unit-limit #x110000
  :encode-literal-char-code-limit #x110000
  :nul-encoding #(0 0 0 0)  
  :character-size-in-octets-function 'four-octets-per-character
  )

(define-character-encoding :utf-32
    "A 32-bit, fixed-length encoding in which all Unicode characters
can be encoded in a single 32-bit word.  The endianness of the encoded
data is indicated by the endianness of a byte-order-mark
character (#\u+feff) prepended to the data; in the absence of such a
character on input, input data is assumed to be in big-endian order.
Output is written in native byte order with a leading byte-order
mark."
    
  :aliases '(:ucs-4)
  :max-units-per-char 1
  :code-unit-size 32
  :native-endianness t                  ;not necessarily true.
  :stream-encode-function
  #'ucs-4-stream-encode
  :stream-decode-function
  #'ucs-4-stream-decode
  :vector-encode-function
  (nfunction
   utf-32-vector-encode
   (lambda (string vector idx start end)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (fixnum idx))
     (setf (%native-u8-ref-u32 vector idx) byte-order-mark-char-code)
     (incf idx 4)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((char (schar string i))
              (code (char-code char)))
         (declare (type (mod #x110000) code))
         (setf (%native-u8-ref-u32 vector idx) code)
         (incf idx 4)))))
  :vector-decode-function
  (nfunction
   utf-32-vector-decode 
   (lambda (vector idx noctets string)
     (declare (type (simple-array (unsigned-byte 8) (*)) vector)
              (type index idx)
              (fixnum noctets))
     (let* ((swap (if (> noctets 3)
                    (case (%native-u8-ref-u32 vector idx)
                      (#.byte-order-mark-char-code
                       (incf idx 4) (decf noctets 4) nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 4) (decf noctets 4) t)
                       (t #+little-endian-target t)))))

       (do* ((i 0 (1+ i))
             (end (+ idx noctets))
             (index idx (1+ index)))
            ((>= index end) index)
         (declare (fixnum i end index))
         (let* ((1st-unit (if swap
                            (%reversed-u8-ref-u32 vector index)
                            (%native-u8-ref-u32 vector index))))
             (declare (type (unsigned-byte 32) 1st-unit))
             (setf (schar string i) (or (if (< 1st-unit char-code-limit)
                                          (code-char 1st-unit))
                                        (note-vector-decoding-problem
                                         vector index :utf-32))))))))
  :memory-encode-function
  (nfunction
   utf-32-memory-encode
   (lambda (string pointer idx start end)
     (declare (fixnum idx))
     (setf (%get-unsigned-long pointer idx) byte-order-mark-char-code)
     (incf idx 4)
     (do* ((i start (1+ i)))
          ((>= i end) idx)
       (let* ((code (char-code (schar string i))))
         (declare (type (mod #x110000) code))
         (setf (%get-unsigned-long pointer idx) code)
         (incf idx 4)))))
  :memory-decode-function
  (nfunction
   utf-32-memory-decode
   (lambda (pointer noctets idx string)
     (declare (fixnum noctets idx))
     (let* ((swap (when (> noctets 3)
                    (case (%get-unsigned-long pointer idx)
                      (#.byte-order-mark-char-code
                       (incf idx 4)
                       (decf noctets 4)
                       nil)
                      (#.swapped-byte-order-mark-char-code
                       (incf idx 4)
                       (decf noctets 4)
                       t)
                      (t #+little-endian-target t)))))
       (do* ((i 0 (1+ i))
           (index idx (+ index 2)))
          ((>= i noctets) index)
       (declare (fixnum i index))
       (let* ((1st-unit (%get-unsigned-long pointer index)))
         (declare (type (unsigned-byte 32) 1st-unit))
         (if swap (setq 1st-unit (%swap-u32 1st-unit)))
         (setf (schar string i) (or (if (< 1st-unit char-code-limit)
                                      (code-char 1st-unit))
                                    (note-vector-decoding-problem
                                     pointer index :utf-32))))))))
  :octets-in-string-function
  (nfunction
   utf-32-bom-octets-in-string
   (lambda (string start end)
     (+ 4 (ucs-4-octets-in-string string start end))))
  :length-of-vector-encoding-function
  (nfunction
   utf-32-length-of-vector-encoding
   (lambda (vector start end)
     (when (>= end (+ start 4))
       (let* ((maybe-bom (%native-u8-ref-u32 vector start)))
         (declare (type (unsigned-byte 32) maybe-bom))
         (when (or (= maybe-bom byte-order-mark-char-code)
                   (= maybe-bom swapped-byte-order-mark-char-code))
           (incf start 4))))
     (do* ((i start j)
           (j (+ i 4) (+ J 4))
           (nchars 0 (1+ nchars)))
          ((> j end) (values nchars i)))))
  :length-of-memory-encoding-function
  (nfunction
   utf-32-length-of-memory-encoding
   (lambda (pointer noctets start)
     (when (> noctets 3)
       (case (%get-unsigned-long pointer )
         (#.byte-order-mark-char-code
          (incf start 4)
          (decf noctets 4))
         (#.swapped-byte-order-mark-char-code
          (incf start 4)
          (decf noctets 4))))
     (values (ash noctets -2) (+ start (logandc2 noctets 3)))))
  :decode-literal-code-unit-limit #x110000
  :encode-literal-char-code-limit #x110000  
  :use-byte-order-mark
  #+big-endian-target :utf-32le
  #+little-endian-target :utf-32be
  :bom-encoding #+big-endian-target #(#x00 #x00 #xfe #xff) #+little-endian-target #(#xff #xfe #x00 #x00)
  :nul-encoding #(0 0 0 0)  
  :character-size-in-octets-function 'four-octets-per-character
  )

(defun list-character-encodings (&key include-aliases)
  "Return a list of the names of supported character encodings."
  (let ((names nil))
    (maphash #'(lambda (name enc)
		 (if (eq name (character-encoding-name enc))
		   (push name names)
		   (when include-aliases
		     (push name names))))
	     *character-encodings*)
    names))

(defun describe-character-encoding (name)
  (let* ((enc (lookup-character-encoding name)))
    (when enc
      (let* ((name (character-encoding-name enc))
             (doc (character-encoding-documentation enc))
             (aliases (character-encoding-aliases enc)))
        (format t "~&~s" name)
        (when (null (car aliases))
          (pop aliases))
        (when aliases
          (format t " [Aliases:~{ ~s~}]" aliases))
        (format t "~&~a~%~%"  doc)
        (values)))))
      
(defun describe-character-encodings ()
  (let* ((names (list-character-encodings)))
    (dolist (name (sort names #'string<) (values))
      (describe-character-encoding name))))

(defmethod make-load-form ((c character-encoding) &optional environment)
  (declare (ignore environment))
  `(get-character-encoding ,(character-encoding-name c)))

(defvar *native-newline-string* (make-string 1 :initial-element #\Newline))
(defvar *unicode-newline-string* (make-string 1 :initial-element #\Line_Separator))
(defvar *cr-newline-string* (make-string 1 :initial-element #\Return))
(defvar *crlf-newline-string* (make-array 2 :element-type 'character :initial-contents '(#\Return #\Linefeed)))
(defvar *nul-string* (make-string 1 :initial-element #\Nul))

(defun string-size-in-octets (string &key
                                     (start 0)
                                     end
                                     (external-format :default)
                                     use-byte-order-mark)
  (setq end (check-sequence-bounds string start end))
  (let* ((ef (normalize-external-format t external-format)))
    (%string-size-in-octets string
                            start
                            end
                            (get-character-encoding
                             (external-format-character-encoding ef))
                            (cdr (assoc (external-format-line-termination ef)
                                        *canonical-line-termination-conventions*))
                            use-byte-order-mark)))
  

(defun %string-size-in-octets (string start end encoding line-termination use-byte-order-mark)  
    (declare (fixnum start end))
    (multiple-value-bind (simple-string offset)
        (array-data-and-offset string)
      (declare (fixnum offset) (simple-string simple-string))
      (incf start offset)
      (incf end offset)
      (let* ((n (if use-byte-order-mark
                  (length (character-encoding-bom-encoding encoding))
                  0))
             (f (character-encoding-octets-in-string-function encoding))
             (nlpos (if line-termination
                      (position #\Newline simple-string :start start :end end))))
        (if (not nlpos)
          (+ n (funcall f simple-string start end))
          (let* ((nlstring (case line-termination
                             (:cr *cr-newline-string*)
                             (:crlf *crlf-newline-string*)
                             (:unicode *unicode-newline-string*)))
                 (nlstring-length (if (eq line-termination :crlf) 2 1)))
            (do* ()
                 ((null nlpos) (+ n (funcall f simple-string start end)))
              (unless (eql nlpos start)
                (incf n (funcall f simple-string start nlpos)))
              (incf n (funcall f nlstring 0 nlstring-length))
              (setq start (1+ nlpos)
                    nlpos (position #\Newline simple-string :start start :end end))))))))

(defun encode-string-to-octets (string &key
                                       (start 0)
                                       end
                                       (external-format :default)
                                       use-byte-order-mark
                                       (vector nil vector-p)
                                       (vector-offset 0))
  (setq end (check-sequence-bounds string start end))
  (let* ((ef (normalize-external-format t external-format)) 
         (encoding (get-character-encoding
                    (external-format-character-encoding ef)))
         (line-termination (cdr (assoc (external-format-line-termination ef)
                                       *canonical-line-termination-conventions*)))
         (n (%string-size-in-octets string start end encoding line-termination use-byte-order-mark)))
    (declare (fixnum start end n))
    (unless (and (typep vector-offset 'fixnum)
                 (or (not vector-p)
                     (< vector-offset (length vector))))
      (error "Invalid vector offset ~s" vector-offset))
    (if (not vector-p)
      (setq vector (make-array (+ n vector-offset)
                               :element-type '(unsigned-byte 8)))
      (progn
        (unless (= (typecode vector) target::subtag-u8-vector)
          (report-bad-arg vector '(simple-array (unsigned-byte 8) (*))))
        (unless (>= (length vector) (+ vector-offset n))
          (error "Can't encode ~s into supplied vector ~s; ~&~d octets are needed, but only ~d are available" string vector n (- (length vector) vector-offset)))))
    (when use-byte-order-mark
      (let* ((bom (character-encoding-bom-encoding encoding)))
        (dotimes (i (length bom))
          (setf (aref vector vector-offset)
                (aref bom i))
          (incf vector-offset))))
    (multiple-value-bind (simple-string offset) (array-data-and-offset string)
      (incf start offset)
      (incf end offset)
      (let* ((f (character-encoding-vector-encode-function encoding))
             (nlpos (if line-termination
                      (position #\Newline simple-string :start start :end end))))
        (if (null nlpos)
          (setq vector-offset
                (funcall f simple-string vector vector-offset start end))
          (let* ((nlstring (case line-termination
                             (:cr *cr-newline-string*)
                             (:crlf *crlf-newline-string*)
                             (:unicode *unicode-newline-string*)))
                 (nlstring-length (if (eq line-termination :crlf) 2 1)))
            (do* ()
                 ((null nlpos)
                  (setq vector-offset
                        (funcall f simple-string vector vector-offset start end)))
              (unless (eql nlpos start)
                (setq vector-offset (funcall f simple-string vector vector-offset start nlpos)))
              (setq vector-offset (funcall f nlstring vector vector-offset 0 nlstring-length))
              (setq start (1+ nlpos)
                    nlpos (position #\Newline simple-string :start start :end end)))))
        (values vector vector-offset)))))



(defun count-characters-in-octet-vector (vector &key
                                                (start 0)
                                                end
                                                (external-format :default))
  (setq end (check-sequence-bounds vector start end))
  (%count-characters-in-octet-vector
   vector
   start
   end
   (get-character-encoding (external-format-character-encoding (normalize-external-format t external-format)))))

(defun %count-characters-in-octet-vector (vector start end encoding)
  (unless (= (typecode vector) target::subtag-u8-vector)
    (report-bad-arg vector '(simple-array (unsigned-byte 8) (*))))
  (funcall (character-encoding-length-of-vector-encoding-function encoding)
           vector
           start
           end))
                                         

(defun decode-string-from-octets (vector &key
                                         (start 0)
                                         end
                                         (external-format :default)
                                         (string nil string-p))
  (setq end (check-sequence-bounds vector start end))
  (unless (= (typecode vector) target::subtag-u8-vector)
    (multiple-value-bind (array offset)
        (array-data-and-offset vector)
      (unless (= (typecode array) target::subtag-u8-vector)
        (report-bad-arg vector '(array (unsigned-byte 8) (*))))
      (setq vector array
            start (+ start offset)
            end (+ end offset))))
  (let* ((encoding (get-character-encoding
                    (external-format-character-encoding
                     (normalize-external-format t external-format)))))
    (multiple-value-bind (nchars last-octet)
        (%count-characters-in-octet-vector vector start end encoding)
      (if (not string-p)
        (setq string (make-string nchars))
        (progn
          (unless (= (typecode string) target::subtag-simple-base-string)
            (report-bad-arg string 'simple-string))
          (unless (>= (length string) nchars)
            (error "String ~s is too small; ~d characters are needed."
                   string nchars))))
      (funcall (character-encoding-vector-decode-function encoding)
               vector
               start
               (- last-octet start)
               string)
      (values string last-octet))))
      
                              
(defun string-encoded-length-in-bytes (encoding string start end)
  (if (typep string 'simple-base-string)
    (funcall (character-encoding-octets-in-string-function encoding)
             string
             (or start 0)
             (or end (length string)))
    (let* ((s (string string)))
      (multiple-value-bind (data offset) (array-data-and-offset s)
        (funcall (character-encoding-octets-in-string-function encoding)
                 data
                 (+ offset (or start 0))
                 (+ offset (or end (length s))))))))

;;; Same as above, but add the length of a trailing 0 code-unit.
(defun cstring-encoded-length-in-bytes (encoding string start end)
  (+ (ash (character-encoding-code-unit-size encoding) -3) ; NUL terminator
     (string-encoded-length-in-bytes encoding string start end)))

                   

(defun encode-string-to-memory (encoding pointer offset string start end)
  (if (typep string 'simple-base-string)
    (funcall (character-encoding-memory-encode-function encoding)
             string pointer offset (or start 0) (or end (length string)))
    (let* ((s (string string)))
      (multiple-value-bind (data data-offset)
          (array-data-and-offset s)
        (funcall (character-encoding-memory-encode-function encoding)
                 data pointer offset (+ data-offset (or start 0)) (+ data-offset (or end (length s))))))))

(defun get-encoded-string (encoding-name pointer noctets)
  (let* ((encoding (ensure-character-encoding encoding-name)))
    (multiple-value-bind (nchars nused)
        (funcall (character-encoding-length-of-memory-encoding-function encoding)
                 pointer
                 noctets
                 0)
      (let* ((string (make-string nchars)))
        (funcall (character-encoding-memory-decode-function encoding)
                 pointer
                 nused
                 0
                 string)
        string))))


(defun get-encoded-cstring (encoding-name pointer)
  (let* ((encoding (ensure-character-encoding encoding-name)))
    (get-encoded-string
     encoding
     pointer
     (ecase (character-encoding-code-unit-size encoding)
       (8 (%cstrlen pointer))
       (16 (do* ((i 0 (+ i 2)))
                ((= 0 (%get-unsigned-word pointer i))
                 (return i))
             (declare (fixnum i))))
       (32 (do* ((i 0 (+ i 4)))
                ((= 0 (%get-unsigned-long pointer i))
                 (return i))
             (declare (fixnum i))))))))
    

      




;;; This is an array of 256 integers, that (sparsely) encodes 64K bits.
;;; (There might be as many as 256 significant bits in some of entries
;;; in this table.)
(defstatic *bmp-combining-bitmap*
    #(
	#x00
        #x00
        #x00
        #xFFFF0000FFFFFFFFFFFFFFFFFFFF
        #x37800000000000000000000000000000000
        #x16BBFFFFFBFFFE000000000000000000000000000000000000
        #x3D9FFFC00000000000000000000000010000003FF8000000000000000000
        #x1FFC00000000000000000000007FFFFFF000000020000
        
	#x00
        #xC0080399FD00000000000000E0000000C001E3FFFD00000000000000E
        #x3BBFD00000000000000E0003000000003987D000000000000004
        #x803DC7C0000000000000040000000000C0398FD00000000000000E
        #x603DDFC00000000000000C0000000000603DDFC00000000000000E
        #xC0000FF5F8400000000000000000C0000000000803DCFC00000000000000C
        #x3F001BF20000000000000000000000007F8007F2000000000000
        #x401FFFFFFFFEFF00DFFFFE000000000000C2A0000003000000
        
        #x3C0000003C7F00000000000
        #x7FFFFFF0000000000003FFFFE000000000000000000000000
        #x00
        #x00
        #x00
        #x00
        #x00
        #xFFFFFFFF0000000000000000C0000000C0000001C0000001C0000        
        
        #x2000000000000000000000000000000000000003800
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
        #x7FFFFFF0000000000000000000000000000000000000000000000000000
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
        #x600000000000000000000000000FC0000000000
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        #x00
        
	#x00
        #x00
        #x00
        #x40000000
        #x00
        #x00
        #xF0000FFFF
        #x00))

(defun is-combinable (char)
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    (when (< code #x1000)
      (logbitp (ldb (byte 8 0) code)
               (svref *bmp-combining-bitmap* (ldb (byte 8 8) code))))))

(defstatic *bmp-combining-chars*
  #(#\Combining_Grave_Accent 
    #\Combining_Acute_Accent 
    #\Combining_Circumflex_Accent 
    #\Combining_Tilde 
    #\Combining_Macron 
    #\Combining_Breve 
    #\Combining_Dot_Above 
    #\Combining_Diaeresis 
    #\Combining_Hook_Above 
    #\Combining_Ring_Above 
    #\Combining_Double_Acute_Accent 
    #\Combining_Caron 
    #\Combining_Double_Grave_Accent 
    #\Combining_Inverted_Breve 
    #\Combining_Comma_Above 
    #\Combining_Reversed_Comma_Above 
    #\Combining_Horn 
    #\Combining_Dot_Below 
    #\Combining_Diaeresis_Below 
    #\Combining_Ring_Below 
    #\Combining_Comma_Below 
    #\Combining_Cedilla 
    #\Combining_Ogonek 
    #\Combining_Circumflex_Accent_Below 
    #\Combining_Breve_Below 
    #\Combining_Tilde_Below 
    #\Combining_Macron_Below 
    #\Combining_Long_Solidus_Overlay 
    #\Combining_Greek_Perispomeni 
    #\Combining_Greek_Ypogegrammeni 
    #\Arabic_Maddah_Above 
    #\Arabic_Hamza_Above 
    #\Arabic_Hamza_Below 
    #\U+093C 
    #\U+09BE 
    #\U+09D7 
    #\U+0B3E 
    #\U+0B56 
    #\U+0B57 
    #\U+0BBE 
    #\U+0BD7 
    #\U+0C56 
    #\U+0CC2 
    #\U+0CD5 
    #\U+0CD6 
    #\U+0D3E 
    #\U+0D57 
    #\U+0DCA 
    #\U+0DCF 
    #\U+0DDF 
    #\U+102E 
    #\U+3099 
    #\U+309A))

(defstatic *bmp-combining-base-chars*
  #(
    ;; #\Combining_Grave_Accent

    #(#\A #\E #\I #\N #\O #\U #\W #\Y #\a #\e #\i #\n #\o #\u #\w #\y
      #\Diaeresis #\Latin_Capital_Letter_A_With_Circumflex
      #\Latin_Capital_Letter_E_With_Circumflex
      #\Latin_Capital_Letter_O_With_Circumflex
      #\Latin_Capital_Letter_U_With_Diaeresis
      #\Latin_Small_Letter_A_With_Circumflex
      #\Latin_Small_Letter_E_With_Circumflex
      #\Latin_Small_Letter_O_With_Circumflex
      #\Latin_Small_Letter_U_With_Diaeresis
      #\Latin_Capital_Letter_A_With_Breve #\Latin_Small_Letter_A_With_Breve
      #\Latin_Capital_Letter_E_With_Macron
      #\Latin_Small_Letter_E_With_Macron
      #\Latin_Capital_Letter_O_With_Macron
      #\Latin_Small_Letter_O_With_Macron #\Latin_Capital_Letter_O_With_Horn
      #\Latin_Small_Letter_O_With_Horn #\Latin_Capital_Letter_U_With_Horn
      #\Latin_Small_Letter_U_With_Horn #\Greek_Capital_Letter_Alpha
      #\Greek_Capital_Letter_Epsilon #\Greek_Capital_Letter_Eta
      #\Greek_Capital_Letter_Iota #\Greek_Capital_Letter_Omicron
      #\Greek_Capital_Letter_Upsilon #\Greek_Capital_Letter_Omega
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Epsilon
      #\Greek_Small_Letter_Eta #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Omicron #\Greek_Small_Letter_Upsilon
      #\Greek_Small_Letter_Omega #\Greek_Small_Letter_Iota_With_Dialytika
      #\Greek_Small_Letter_Upsilon_With_Dialytika
      #\Cyrillic_Capital_Letter_Ie #\Cyrillic_Capital_Letter_I
      #\Cyrillic_Small_Letter_Ie #\Cyrillic_Small_Letter_I #\U+1F00 #\U+1F01
      #\U+1F08 #\U+1F09 #\U+1F10 #\U+1F11 #\U+1F18 #\U+1F19 #\U+1F20
      #\U+1F21 #\U+1F28 #\U+1F29 #\U+1F30 #\U+1F31 #\U+1F38 #\U+1F39
      #\U+1F40 #\U+1F41 #\U+1F48 #\U+1F49 #\U+1F50 #\U+1F51 #\U+1F59
      #\U+1F60 #\U+1F61 #\U+1F68 #\U+1F69 #\U+1FBF #\U+1FFE)


    ;; #\Combining_Acute_Accent

    #(#\A #\C #\E #\G #\I #\K #\L #\M #\N #\O #\P #\R #\S #\U #\W #\Y #\Z
      #\a #\c #\e #\g #\i #\k #\l #\m #\n #\o #\p #\r #\s #\u #\w #\y #\z
      #\Diaeresis #\Latin_Capital_Letter_A_With_Circumflex
      #\Latin_Capital_Letter_A_With_Ring_Above #\Latin_Capital_Letter_Ae
      #\Latin_Capital_Letter_C_With_Cedilla
      #\Latin_Capital_Letter_E_With_Circumflex
      #\Latin_Capital_Letter_I_With_Diaeresis
      #\Latin_Capital_Letter_O_With_Circumflex
      #\Latin_Capital_Letter_O_With_Tilde
      #\Latin_Capital_Letter_O_With_Stroke
      #\Latin_Capital_Letter_U_With_Diaeresis
      #\Latin_Small_Letter_A_With_Circumflex
      #\Latin_Small_Letter_A_With_Ring_Above #\Latin_Small_Letter_Ae
      #\Latin_Small_Letter_C_With_Cedilla
      #\Latin_Small_Letter_E_With_Circumflex
      #\Latin_Small_Letter_I_With_Diaeresis
      #\Latin_Small_Letter_O_With_Circumflex
      #\Latin_Small_Letter_O_With_Tilde #\Latin_Small_Letter_O_With_Stroke
      #\Latin_Small_Letter_U_With_Diaeresis
      #\Latin_Capital_Letter_A_With_Breve #\Latin_Small_Letter_A_With_Breve
      #\Latin_Capital_Letter_E_With_Macron
      #\Latin_Small_Letter_E_With_Macron
      #\Latin_Capital_Letter_O_With_Macron
      #\Latin_Small_Letter_O_With_Macron #\Latin_Capital_Letter_U_With_Tilde
      #\Latin_Small_Letter_U_With_Tilde #\Latin_Capital_Letter_O_With_Horn
      #\Latin_Small_Letter_O_With_Horn #\Latin_Capital_Letter_U_With_Horn
      #\Latin_Small_Letter_U_With_Horn #\Greek_Capital_Letter_Alpha
      #\Greek_Capital_Letter_Epsilon #\Greek_Capital_Letter_Eta
      #\Greek_Capital_Letter_Iota #\Greek_Capital_Letter_Omicron
      #\Greek_Capital_Letter_Upsilon #\Greek_Capital_Letter_Omega
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Epsilon
      #\Greek_Small_Letter_Eta #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Omicron #\Greek_Small_Letter_Upsilon
      #\Greek_Small_Letter_Omega #\Greek_Small_Letter_Iota_With_Dialytika
      #\Greek_Small_Letter_Upsilon_With_Dialytika
      #\Greek_Upsilon_With_Hook_Symbol #\Cyrillic_Capital_Letter_Ghe
      #\Cyrillic_Capital_Letter_Ka #\Cyrillic_Small_Letter_Ghe
      #\Cyrillic_Small_Letter_Ka #\U+1F00 #\U+1F01 #\U+1F08 #\U+1F09
      #\U+1F10 #\U+1F11 #\U+1F18 #\U+1F19 #\U+1F20 #\U+1F21 #\U+1F28
      #\U+1F29 #\U+1F30 #\U+1F31 #\U+1F38 #\U+1F39 #\U+1F40 #\U+1F41
      #\U+1F48 #\U+1F49 #\U+1F50 #\U+1F51 #\U+1F59 #\U+1F60 #\U+1F61
      #\U+1F68 #\U+1F69 #\U+1FBF #\U+1FFE)


    ;; #\Combining_Circumflex_Accent

    #(#\A #\C #\E #\G #\H #\I #\J #\O #\S #\U #\W #\Y #\Z #\a #\c #\e #\g
      #\h #\i #\j #\o #\s #\u #\w #\y #\z #\U+1EA0 #\U+1EA1 #\U+1EB8
      #\U+1EB9 #\U+1ECC #\U+1ECD)


    ;; #\Combining_Tilde

    #(#\A #\E #\I #\N #\O #\U #\V #\Y #\a #\e #\i #\n #\o #\u #\v #\y
      #\Latin_Capital_Letter_A_With_Circumflex
      #\Latin_Capital_Letter_E_With_Circumflex
      #\Latin_Capital_Letter_O_With_Circumflex
      #\Latin_Small_Letter_A_With_Circumflex
      #\Latin_Small_Letter_E_With_Circumflex
      #\Latin_Small_Letter_O_With_Circumflex
      #\Latin_Capital_Letter_A_With_Breve #\Latin_Small_Letter_A_With_Breve
      #\Latin_Capital_Letter_O_With_Horn #\Latin_Small_Letter_O_With_Horn
      #\Latin_Capital_Letter_U_With_Horn #\Latin_Small_Letter_U_With_Horn)


    ;; #\Combining_Macron

    #(#\A #\E #\G #\I #\O #\U #\Y #\a #\e #\g #\i #\o #\u #\y
      #\Latin_Capital_Letter_A_With_Diaeresis #\Latin_Capital_Letter_Ae
      #\Latin_Capital_Letter_O_With_Tilde
      #\Latin_Capital_Letter_O_With_Diaeresis
      #\Latin_Capital_Letter_U_With_Diaeresis
      #\Latin_Small_Letter_A_With_Diaeresis #\Latin_Small_Letter_Ae
      #\Latin_Small_Letter_O_With_Tilde
      #\Latin_Small_Letter_O_With_Diaeresis
      #\Latin_Small_Letter_U_With_Diaeresis
      #\Latin_Capital_Letter_O_With_Ogonek
      #\Latin_Small_Letter_O_With_Ogonek
      #\Latin_Capital_Letter_A_With_Dot_Above
      #\Latin_Small_Letter_A_With_Dot_Above
      #\Latin_Capital_Letter_O_With_Dot_Above
      #\Latin_Small_Letter_O_With_Dot_Above #\Greek_Capital_Letter_Alpha
      #\Greek_Capital_Letter_Iota #\Greek_Capital_Letter_Upsilon
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Upsilon #\Cyrillic_Capital_Letter_I
      #\Cyrillic_Capital_Letter_U #\Cyrillic_Small_Letter_I
      #\Cyrillic_Small_Letter_U #\U+1E36 #\U+1E37 #\U+1E5A #\U+1E5B)


    ;; #\Combining_Breve

    #(#\A #\E #\G #\I #\O #\U #\a #\e #\g #\i #\o #\u
      #\Latin_Capital_Letter_E_With_Cedilla
      #\Latin_Small_Letter_E_With_Cedilla #\Greek_Capital_Letter_Alpha
      #\Greek_Capital_Letter_Iota #\Greek_Capital_Letter_Upsilon
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Upsilon #\Cyrillic_Capital_Letter_A
      #\Cyrillic_Capital_Letter_Ie #\Cyrillic_Capital_Letter_Zhe
      #\Cyrillic_Capital_Letter_I #\Cyrillic_Capital_Letter_U
      #\Cyrillic_Small_Letter_A #\Cyrillic_Small_Letter_Ie
      #\Cyrillic_Small_Letter_Zhe #\Cyrillic_Small_Letter_I
      #\Cyrillic_Small_Letter_U #\U+1EA0 #\U+1EA1)


    ;; #\Combining_Dot_Above

    #(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\M #\N #\O #\P #\R #\S #\T #\W
      #\X #\Y #\Z #\a #\b #\c #\d #\e #\f #\g #\h #\m #\n #\o #\p #\r #\s
      #\t #\w #\x #\y #\z #\Latin_Capital_Letter_S_With_Acute
      #\Latin_Small_Letter_S_With_Acute #\Latin_Capital_Letter_S_With_Caron
      #\Latin_Small_Letter_S_With_Caron #\Latin_Small_Letter_Long_S #\U+1E62
      #\U+1E63)


    ;; #\Combining_Diaeresis

    #(#\A #\E #\H #\I #\O #\U #\W #\X #\Y #\a #\e #\h #\i #\o #\t #\u #\w
      #\x #\y #\Latin_Capital_Letter_O_With_Tilde
      #\Latin_Small_Letter_O_With_Tilde #\Latin_Capital_Letter_U_With_Macron
      #\Latin_Small_Letter_U_With_Macron #\Greek_Capital_Letter_Iota
      #\Greek_Capital_Letter_Upsilon #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Upsilon #\Greek_Upsilon_With_Hook_Symbol
      #\Cyrillic_Capital_Letter_Byelorussian-Ukrainian_I
      #\Cyrillic_Capital_Letter_A #\Cyrillic_Capital_Letter_Ie
      #\Cyrillic_Capital_Letter_Zhe #\Cyrillic_Capital_Letter_Ze
      #\Cyrillic_Capital_Letter_I #\Cyrillic_Capital_Letter_O
      #\Cyrillic_Capital_Letter_U #\Cyrillic_Capital_Letter_Che
      #\Cyrillic_Capital_Letter_Yeru #\Cyrillic_Capital_Letter_E
      #\Cyrillic_Small_Letter_A #\Cyrillic_Small_Letter_Ie
      #\Cyrillic_Small_Letter_Zhe #\Cyrillic_Small_Letter_Ze
      #\Cyrillic_Small_Letter_I #\Cyrillic_Small_Letter_O
      #\Cyrillic_Small_Letter_U #\Cyrillic_Small_Letter_Che
      #\Cyrillic_Small_Letter_Yeru #\Cyrillic_Small_Letter_E
      #\Cyrillic_Small_Letter_Byelorussian-Ukrainian_I
      #\Cyrillic_Capital_Letter_Schwa #\Cyrillic_Small_Letter_Schwa
      #\Cyrillic_Capital_Letter_Barred_O #\Cyrillic_Small_Letter_Barred_O)


    ;; #\Combining_Hook_Above

    #(#\A #\E #\I #\O #\U #\Y #\a #\e #\i #\o #\u #\y
      #\Latin_Capital_Letter_A_With_Circumflex
      #\Latin_Capital_Letter_E_With_Circumflex
      #\Latin_Capital_Letter_O_With_Circumflex
      #\Latin_Small_Letter_A_With_Circumflex
      #\Latin_Small_Letter_E_With_Circumflex
      #\Latin_Small_Letter_O_With_Circumflex
      #\Latin_Capital_Letter_A_With_Breve #\Latin_Small_Letter_A_With_Breve
      #\Latin_Capital_Letter_O_With_Horn #\Latin_Small_Letter_O_With_Horn
      #\Latin_Capital_Letter_U_With_Horn #\Latin_Small_Letter_U_With_Horn)


    ;; #\Combining_Ring_Above

    #(#\A #\U #\a #\u #\w #\y)


    ;; #\Combining_Double_Acute_Accent

    #(#\O #\U #\o #\u #\Cyrillic_Capital_Letter_U
      #\Cyrillic_Small_Letter_U)


    ;; #\Combining_Caron

    #(#\A #\C #\D #\E #\G #\H #\I #\K #\L #\N #\O #\R #\S #\T #\U #\Z #\a
      #\c #\d #\e #\g #\h #\i #\j #\k #\l #\n #\o #\r #\s #\t #\u #\z
      #\Latin_Capital_Letter_U_With_Diaeresis
      #\Latin_Small_Letter_U_With_Diaeresis #\Latin_Capital_Letter_Ezh
      #\Latin_Small_Letter_Ezh)


    ;; #\Combining_Double_Grave_Accent

    #(#\A #\E #\I #\O #\R #\U #\a #\e #\i #\o #\r #\u
      #\Cyrillic_Capital_Letter_Izhitsa #\Cyrillic_Small_Letter_Izhitsa)


    ;; #\Combining_Inverted_Breve

    #(#\A #\E #\I #\O #\R #\U #\a #\e #\i #\o #\r #\u)


    ;; #\Combining_Comma_Above

    #(#\Greek_Capital_Letter_Alpha #\Greek_Capital_Letter_Epsilon
      #\Greek_Capital_Letter_Eta #\Greek_Capital_Letter_Iota
      #\Greek_Capital_Letter_Omicron #\Greek_Capital_Letter_Omega
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Epsilon
      #\Greek_Small_Letter_Eta #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Omicron #\Greek_Small_Letter_Rho
      #\Greek_Small_Letter_Upsilon #\Greek_Small_Letter_Omega)


    ;; #\Combining_Reversed_Comma_Above

    #(#\Greek_Capital_Letter_Alpha #\Greek_Capital_Letter_Epsilon
      #\Greek_Capital_Letter_Eta #\Greek_Capital_Letter_Iota
      #\Greek_Capital_Letter_Omicron #\Greek_Capital_Letter_Rho
      #\Greek_Capital_Letter_Upsilon #\Greek_Capital_Letter_Omega
      #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Epsilon
      #\Greek_Small_Letter_Eta #\Greek_Small_Letter_Iota
      #\Greek_Small_Letter_Omicron #\Greek_Small_Letter_Rho
      #\Greek_Small_Letter_Upsilon #\Greek_Small_Letter_Omega)


    ;; #\Combining_Horn

    #(#\O #\U #\o #\u)


    ;; #\Combining_Dot_Below

    #(#\A #\B #\D #\E #\H #\I #\K #\L #\M #\N #\O #\R #\S #\T #\U #\V #\W
      #\Y #\Z #\a #\b #\d #\e #\h #\i #\k #\l #\m #\n #\o #\r #\s #\t #\u
      #\v #\w #\y #\z #\Latin_Capital_Letter_O_With_Horn
      #\Latin_Small_Letter_O_With_Horn #\Latin_Capital_Letter_U_With_Horn
      #\Latin_Small_Letter_U_With_Horn)


    ;; #\Combining_Diaeresis_Below

    #(#\U #\u)


    ;; #\Combining_Ring_Below

    #(#\A #\a)


    ;; #\Combining_Comma_Below

    #(#\S #\T #\s #\t)


    ;; #\Combining_Cedilla

    #(#\C #\D #\E #\G #\H #\K #\L #\N #\R #\S #\T #\c #\d #\e #\g #\h #\k
      #\l #\n #\r #\s #\t)


    ;; #\Combining_Ogonek

    #(#\A #\E #\I #\O #\U #\a #\e #\i #\o #\u)


    ;; #\Combining_Circumflex_Accent_Below

    #(#\D #\E #\L #\N #\T #\U #\d #\e #\l #\n #\t #\u)


    ;; #\Combining_Breve_Below

    #(#\H #\h)


    ;; #\Combining_Tilde_Below

    #(#\E #\I #\U #\e #\i #\u)


    ;; #\Combining_Macron_Below

    #(#\B #\D #\K #\L #\N #\R #\T #\Z #\b #\d #\h #\k #\l #\n #\r #\t #\z)


    ;; #\Combining_Long_Solidus_Overlay

    #(#\< #\= #\> #\U+2190 #\U+2192 #\U+2194 #\U+21D0 #\U+21D2 #\U+21D4
      #\U+2203 #\U+2208 #\U+220B #\U+2223 #\U+2225 #\U+223C #\U+2243
      #\U+2245 #\U+2248 #\U+224D #\U+2261 #\U+2264 #\U+2265 #\U+2272
      #\U+2273 #\U+2276 #\U+2277 #\U+227A #\U+227B #\U+227C #\U+227D
      #\U+2282 #\U+2283 #\U+2286 #\U+2287 #\U+2291 #\U+2292 #\U+22A2
      #\U+22A8 #\U+22A9 #\U+22AB #\U+22B2 #\U+22B3 #\U+22B4 #\U+22B5)


    ;; #\Combining_Greek_Perispomeni

    #(#\Diaeresis #\Greek_Small_Letter_Alpha #\Greek_Small_Letter_Eta
      #\Greek_Small_Letter_Iota #\Greek_Small_Letter_Upsilon
      #\Greek_Small_Letter_Omega #\Greek_Small_Letter_Iota_With_Dialytika
      #\Greek_Small_Letter_Upsilon_With_Dialytika #\U+1F00 #\U+1F01 #\U+1F08
      #\U+1F09 #\U+1F20 #\U+1F21 #\U+1F28 #\U+1F29 #\U+1F30 #\U+1F31
      #\U+1F38 #\U+1F39 #\U+1F50 #\U+1F51 #\U+1F59 #\U+1F60 #\U+1F61
      #\U+1F68 #\U+1F69 #\U+1FBF #\U+1FFE)


    ;; #\Combining_Greek_Ypogegrammeni

    #(#\Greek_Capital_Letter_Alpha #\Greek_Capital_Letter_Eta
      #\Greek_Capital_Letter_Omega #\Greek_Small_Letter_Alpha_With_Tonos
      #\Greek_Small_Letter_Eta_With_Tonos #\Greek_Small_Letter_Alpha
      #\Greek_Small_Letter_Eta #\Greek_Small_Letter_Omega
      #\Greek_Small_Letter_Omega_With_Tonos #\U+1F00 #\U+1F01 #\U+1F02
      #\U+1F03 #\U+1F04 #\U+1F05 #\U+1F06 #\U+1F07 #\U+1F08 #\U+1F09
      #\U+1F0A #\U+1F0B #\U+1F0C #\U+1F0D #\U+1F0E #\U+1F0F #\U+1F20
      #\U+1F21 #\U+1F22 #\U+1F23 #\U+1F24 #\U+1F25 #\U+1F26 #\U+1F27
      #\U+1F28 #\U+1F29 #\U+1F2A #\U+1F2B #\U+1F2C #\U+1F2D #\U+1F2E
      #\U+1F2F #\U+1F60 #\U+1F61 #\U+1F62 #\U+1F63 #\U+1F64 #\U+1F65
      #\U+1F66 #\U+1F67 #\U+1F68 #\U+1F69 #\U+1F6A #\U+1F6B #\U+1F6C
      #\U+1F6D #\U+1F6E #\U+1F6F #\U+1F70 #\U+1F74 #\U+1F7C #\U+1FB6
      #\U+1FC6 #\U+1FF6)


    ;; #\Arabic_Maddah_Above

    #(#\Arabic_Letter_Alef)


    ;; #\Arabic_Hamza_Above

    #(#\Arabic_Letter_Alef #\Arabic_Letter_Waw #\Arabic_Letter_Yeh
      #\Arabic_Letter_Heh_Goal #\Arabic_Letter_Yeh_Barree
      #\Arabic_Letter_Ae)


    ;; #\Arabic_Hamza_Below

    #(#\Arabic_Letter_Alef)


    ;; #\U+093C

    #(#\U+0928 #\U+0930 #\U+0933)


    ;; #\U+09BE

    #(#\U+09C7)


    ;; #\U+09D7

    #(#\U+09C7)


    ;; #\U+0B3E

    #(#\U+0B47)


    ;; #\U+0B56

    #(#\U+0B47)


    ;; #\U+0B57

    #(#\U+0B47)


    ;; #\U+0BBE

    #(#\U+0BC6 #\U+0BC7)


    ;; #\U+0BD7

    #(#\U+0B92 #\U+0BC6)


    ;; #\U+0C56

    #(#\U+0C46)


    ;; #\U+0CC2

    #(#\U+0CC6)


    ;; #\U+0CD5

    #(#\U+0CBF #\U+0CC6 #\U+0CCA)


    ;; #\U+0CD6

    #(#\U+0CC6)


    ;; #\U+0D3E

    #(#\U+0D46 #\U+0D47)


    ;; #\U+0D57

    #(#\U+0D46)


    ;; #\U+0DCA

    #(#\U+0DD9 #\U+0DDC)


    ;; #\U+0DCF

    #(#\U+0DD9)


    ;; #\U+0DDF

    #(#\U+0DD9)


    ;; #\U+102E

    #(#\U+1025)


    ;; #\U+3099

    #(#\U+3046 #\U+304B #\U+304D #\U+304F #\U+3051 #\U+3053 #\U+3055
      #\U+3057 #\U+3059 #\U+305B #\U+305D #\U+305F #\U+3061 #\U+3064
      #\U+3066 #\U+3068 #\U+306F #\U+3072 #\U+3075 #\U+3078 #\U+307B
      #\U+309D #\U+30A6 #\U+30AB #\U+30AD #\U+30AF #\U+30B1 #\U+30B3
      #\U+30B5 #\U+30B7 #\U+30B9 #\U+30BB #\U+30BD #\U+30BF #\U+30C1
      #\U+30C4 #\U+30C6 #\U+30C8 #\U+30CF #\U+30D2 #\U+30D5 #\U+30D8
      #\U+30DB #\U+30EF #\U+30F0 #\U+30F1 #\U+30F2 #\U+30FD)


    ;; #\U+309A

    #(#\U+306F #\U+3072 #\U+3075 #\U+3078 #\U+307B #\U+30CF #\U+30D2
      #\U+30D5 #\U+30D8 #\U+30DB)
    ))

(defstatic *bmp-precombined-chars*
  #(

    ;; #\Combining_Grave_Accent

    #(#\Latin_Capital_Letter_A_With_Grave
      #\Latin_Capital_Letter_E_With_Grave
      #\Latin_Capital_Letter_I_With_Grave
      #\Latin_Capital_Letter_N_With_Grave
      #\Latin_Capital_Letter_O_With_Grave
      #\Latin_Capital_Letter_U_With_Grave #\U+1E80 #\U+1EF2
      #\Latin_Small_Letter_A_With_Grave #\Latin_Small_Letter_E_With_Grave
      #\Latin_Small_Letter_I_With_Grave #\Latin_Small_Letter_N_With_Grave
      #\Latin_Small_Letter_O_With_Grave #\Latin_Small_Letter_U_With_Grave
      #\U+1E81 #\U+1EF3 #\U+1FED #\U+1EA6 #\U+1EC0 #\U+1ED2
      #\Latin_Capital_Letter_U_With_Diaeresis_And_Grave #\U+1EA7 #\U+1EC1
      #\U+1ED3 #\Latin_Small_Letter_U_With_Diaeresis_And_Grave #\U+1EB0
      #\U+1EB1 #\U+1E14 #\U+1E15 #\U+1E50 #\U+1E51 #\U+1EDC #\U+1EDD
      #\U+1EEA #\U+1EEB #\U+1FBA #\U+1FC8 #\U+1FCA #\U+1FDA #\U+1FF8
      #\U+1FEA #\U+1FFA #\U+1F70 #\U+1F72 #\U+1F74 #\U+1F76 #\U+1F78
      #\U+1F7A #\U+1F7C #\U+1FD2 #\U+1FE2
      #\Cyrillic_Capital_Letter_Ie_With_Grave
      #\Cyrillic_Capital_Letter_I_With_Grave
      #\Cyrillic_Small_Letter_Ie_With_Grave
      #\Cyrillic_Small_Letter_I_With_Grave #\U+1F02 #\U+1F03 #\U+1F0A
      #\U+1F0B #\U+1F12 #\U+1F13 #\U+1F1A #\U+1F1B #\U+1F22 #\U+1F23
      #\U+1F2A #\U+1F2B #\U+1F32 #\U+1F33 #\U+1F3A #\U+1F3B #\U+1F42
      #\U+1F43 #\U+1F4A #\U+1F4B #\U+1F52 #\U+1F53 #\U+1F5B #\U+1F62
      #\U+1F63 #\U+1F6A #\U+1F6B #\U+1FCD #\U+1FDD)


    ;; #\Combining_Acute_Accent

    #(#\Latin_Capital_Letter_A_With_Acute
      #\Latin_Capital_Letter_C_With_Acute
      #\Latin_Capital_Letter_E_With_Acute
      #\Latin_Capital_Letter_G_With_Acute
      #\Latin_Capital_Letter_I_With_Acute #\U+1E30
      #\Latin_Capital_Letter_L_With_Acute #\U+1E3E
      #\Latin_Capital_Letter_N_With_Acute
      #\Latin_Capital_Letter_O_With_Acute #\U+1E54
      #\Latin_Capital_Letter_R_With_Acute
      #\Latin_Capital_Letter_S_With_Acute
      #\Latin_Capital_Letter_U_With_Acute #\U+1E82
      #\Latin_Capital_Letter_Y_With_Acute
      #\Latin_Capital_Letter_Z_With_Acute #\Latin_Small_Letter_A_With_Acute
      #\Latin_Small_Letter_C_With_Acute #\Latin_Small_Letter_E_With_Acute
      #\Latin_Small_Letter_G_With_Acute #\Latin_Small_Letter_I_With_Acute
      #\U+1E31 #\Latin_Small_Letter_L_With_Acute #\U+1E3F
      #\Latin_Small_Letter_N_With_Acute #\Latin_Small_Letter_O_With_Acute
      #\U+1E55 #\Latin_Small_Letter_R_With_Acute
      #\Latin_Small_Letter_S_With_Acute #\Latin_Small_Letter_U_With_Acute
      #\U+1E83 #\Latin_Small_Letter_Y_With_Acute
      #\Latin_Small_Letter_Z_With_Acute #\Greek_Dialytika_Tonos #\U+1EA4
      #\Latin_Capital_Letter_A_With_Ring_Above_And_Acute
      #\Latin_Capital_Letter_Ae_With_Acute #\U+1E08 #\U+1EBE #\U+1E2E
      #\U+1ED0 #\U+1E4C #\Latin_Capital_Letter_O_With_Stroke_And_Acute
      #\Latin_Capital_Letter_U_With_Diaeresis_And_Acute #\U+1EA5
      #\Latin_Small_Letter_A_With_Ring_Above_And_Acute
      #\Latin_Small_Letter_Ae_With_Acute #\U+1E09 #\U+1EBF #\U+1E2F #\U+1ED1
      #\U+1E4D #\Latin_Small_Letter_O_With_Stroke_And_Acute
      #\Latin_Small_Letter_U_With_Diaeresis_And_Acute #\U+1EAE #\U+1EAF
      #\U+1E16 #\U+1E17 #\U+1E52 #\U+1E53 #\U+1E78 #\U+1E79 #\U+1EDA
      #\U+1EDB #\U+1EE8 #\U+1EE9 #\Greek_Capital_Letter_Alpha_With_Tonos
      #\Greek_Capital_Letter_Epsilon_With_Tonos
      #\Greek_Capital_Letter_Eta_With_Tonos
      #\Greek_Capital_Letter_Iota_With_Tonos
      #\Greek_Capital_Letter_Omicron_With_Tonos
      #\Greek_Capital_Letter_Upsilon_With_Tonos
      #\Greek_Capital_Letter_Omega_With_Tonos
      #\Greek_Small_Letter_Alpha_With_Tonos
      #\Greek_Small_Letter_Epsilon_With_Tonos
      #\Greek_Small_Letter_Eta_With_Tonos
      #\Greek_Small_Letter_Iota_With_Tonos
      #\Greek_Small_Letter_Omicron_With_Tonos
      #\Greek_Small_Letter_Upsilon_With_Tonos
      #\Greek_Small_Letter_Omega_With_Tonos
      #\Greek_Small_Letter_Iota_With_Dialytika_And_Tonos
      #\Greek_Small_Letter_Upsilon_With_Dialytika_And_Tonos
      #\Greek_Upsilon_With_Acute_And_Hook_Symbol
      #\Cyrillic_Capital_Letter_Gje #\Cyrillic_Capital_Letter_Kje
      #\Cyrillic_Small_Letter_Gje #\Cyrillic_Small_Letter_Kje #\U+1F04
      #\U+1F05 #\U+1F0C #\U+1F0D #\U+1F14 #\U+1F15 #\U+1F1C #\U+1F1D
      #\U+1F24 #\U+1F25 #\U+1F2C #\U+1F2D #\U+1F34 #\U+1F35 #\U+1F3C
      #\U+1F3D #\U+1F44 #\U+1F45 #\U+1F4C #\U+1F4D #\U+1F54 #\U+1F55
      #\U+1F5D #\U+1F64 #\U+1F65 #\U+1F6C #\U+1F6D #\U+1FCE #\U+1FDE)


    ;; #\Combining_Circumflex_Accent

    #(#\Latin_Capital_Letter_A_With_Circumflex
      #\Latin_Capital_Letter_C_With_Circumflex
      #\Latin_Capital_Letter_E_With_Circumflex
      #\Latin_Capital_Letter_G_With_Circumflex
      #\Latin_Capital_Letter_H_With_Circumflex
      #\Latin_Capital_Letter_I_With_Circumflex
      #\Latin_Capital_Letter_J_With_Circumflex
      #\Latin_Capital_Letter_O_With_Circumflex
      #\Latin_Capital_Letter_S_With_Circumflex
      #\Latin_Capital_Letter_U_With_Circumflex
      #\Latin_Capital_Letter_W_With_Circumflex
      #\Latin_Capital_Letter_Y_With_Circumflex #\U+1E90
      #\Latin_Small_Letter_A_With_Circumflex
      #\Latin_Small_Letter_C_With_Circumflex
      #\Latin_Small_Letter_E_With_Circumflex
      #\Latin_Small_Letter_G_With_Circumflex
      #\Latin_Small_Letter_H_With_Circumflex
      #\Latin_Small_Letter_I_With_Circumflex
      #\Latin_Small_Letter_J_With_Circumflex
      #\Latin_Small_Letter_O_With_Circumflex
      #\Latin_Small_Letter_S_With_Circumflex
      #\Latin_Small_Letter_U_With_Circumflex
      #\Latin_Small_Letter_W_With_Circumflex
      #\Latin_Small_Letter_Y_With_Circumflex #\U+1E91 #\U+1EAC #\U+1EAD
      #\U+1EC6 #\U+1EC7 #\U+1ED8 #\U+1ED9)


    ;; #\Combining_Tilde

    #(#\Latin_Capital_Letter_A_With_Tilde #\U+1EBC
      #\Latin_Capital_Letter_I_With_Tilde
      #\Latin_Capital_Letter_N_With_Tilde
      #\Latin_Capital_Letter_O_With_Tilde
      #\Latin_Capital_Letter_U_With_Tilde #\U+1E7C #\U+1EF8
      #\Latin_Small_Letter_A_With_Tilde #\U+1EBD
      #\Latin_Small_Letter_I_With_Tilde #\Latin_Small_Letter_N_With_Tilde
      #\Latin_Small_Letter_O_With_Tilde #\Latin_Small_Letter_U_With_Tilde
      #\U+1E7D #\U+1EF9 #\U+1EAA #\U+1EC4 #\U+1ED6 #\U+1EAB #\U+1EC5
      #\U+1ED7 #\U+1EB4 #\U+1EB5 #\U+1EE0 #\U+1EE1 #\U+1EEE #\U+1EEF)


    ;; #\Combining_Macron

    #(#\Latin_Capital_Letter_A_With_Macron
      #\Latin_Capital_Letter_E_With_Macron #\U+1E20
      #\Latin_Capital_Letter_I_With_Macron
      #\Latin_Capital_Letter_O_With_Macron
      #\Latin_Capital_Letter_U_With_Macron
      #\Latin_Capital_Letter_Y_With_Macron
      #\Latin_Small_Letter_A_With_Macron #\Latin_Small_Letter_E_With_Macron
      #\U+1E21 #\Latin_Small_Letter_I_With_Macron
      #\Latin_Small_Letter_O_With_Macron #\Latin_Small_Letter_U_With_Macron
      #\Latin_Small_Letter_Y_With_Macron
      #\Latin_Capital_Letter_A_With_Diaeresis_And_Macron
      #\Latin_Capital_Letter_Ae_With_Macron
      #\Latin_Capital_Letter_O_With_Tilde_And_Macron
      #\Latin_Capital_Letter_O_With_Diaeresis_And_Macron
      #\Latin_Capital_Letter_U_With_Diaeresis_And_Macron
      #\Latin_Small_Letter_A_With_Diaeresis_And_Macron
      #\Latin_Small_Letter_Ae_With_Macron
      #\Latin_Small_Letter_O_With_Tilde_And_Macron
      #\Latin_Small_Letter_O_With_Diaeresis_And_Macron
      #\Latin_Small_Letter_U_With_Diaeresis_And_Macron
      #\Latin_Capital_Letter_O_With_Ogonek_And_Macron
      #\Latin_Small_Letter_O_With_Ogonek_And_Macron
      #\Latin_Capital_Letter_A_With_Dot_Above_And_Macron
      #\Latin_Small_Letter_A_With_Dot_Above_And_Macron
      #\Latin_Capital_Letter_O_With_Dot_Above_And_Macron
      #\Latin_Small_Letter_O_With_Dot_Above_And_Macron #\U+1FB9 #\U+1FD9
      #\U+1FE9 #\U+1FB1 #\U+1FD1 #\U+1FE1
      #\Cyrillic_Capital_Letter_I_With_Macron
      #\Cyrillic_Capital_Letter_U_With_Macron
      #\Cyrillic_Small_Letter_I_With_Macron
      #\Cyrillic_Small_Letter_U_With_Macron #\U+1E38 #\U+1E39 #\U+1E5C
      #\U+1E5D)


    ;; #\Combining_Breve

    #(#\Latin_Capital_Letter_A_With_Breve
      #\Latin_Capital_Letter_E_With_Breve
      #\Latin_Capital_Letter_G_With_Breve
      #\Latin_Capital_Letter_I_With_Breve
      #\Latin_Capital_Letter_O_With_Breve
      #\Latin_Capital_Letter_U_With_Breve #\Latin_Small_Letter_A_With_Breve
      #\Latin_Small_Letter_E_With_Breve #\Latin_Small_Letter_G_With_Breve
      #\Latin_Small_Letter_I_With_Breve #\Latin_Small_Letter_O_With_Breve
      #\Latin_Small_Letter_U_With_Breve #\U+1E1C #\U+1E1D #\U+1FB8 #\U+1FD8
      #\U+1FE8 #\U+1FB0 #\U+1FD0 #\U+1FE0
      #\Cyrillic_Capital_Letter_A_With_Breve
      #\Cyrillic_Capital_Letter_Ie_With_Breve
      #\Cyrillic_Capital_Letter_Zhe_With_Breve
      #\Cyrillic_Capital_Letter_Short_I #\Cyrillic_Capital_Letter_Short_U
      #\Cyrillic_Small_Letter_A_With_Breve
      #\Cyrillic_Small_Letter_Ie_With_Breve
      #\Cyrillic_Small_Letter_Zhe_With_Breve #\Cyrillic_Small_Letter_Short_I
      #\Cyrillic_Small_Letter_Short_U #\U+1EB6 #\U+1EB7)


    ;; #\Combining_Dot_Above

    #(#\Latin_Capital_Letter_A_With_Dot_Above #\U+1E02
      #\Latin_Capital_Letter_C_With_Dot_Above #\U+1E0A
      #\Latin_Capital_Letter_E_With_Dot_Above #\U+1E1E
      #\Latin_Capital_Letter_G_With_Dot_Above #\U+1E22
      #\Latin_Capital_Letter_I_With_Dot_Above #\U+1E40 #\U+1E44
      #\Latin_Capital_Letter_O_With_Dot_Above #\U+1E56 #\U+1E58 #\U+1E60
      #\U+1E6A #\U+1E86 #\U+1E8A #\U+1E8E
      #\Latin_Capital_Letter_Z_With_Dot_Above
      #\Latin_Small_Letter_A_With_Dot_Above #\U+1E03
      #\Latin_Small_Letter_C_With_Dot_Above #\U+1E0B
      #\Latin_Small_Letter_E_With_Dot_Above #\U+1E1F
      #\Latin_Small_Letter_G_With_Dot_Above #\U+1E23 #\U+1E41 #\U+1E45
      #\Latin_Small_Letter_O_With_Dot_Above #\U+1E57 #\U+1E59 #\U+1E61
      #\U+1E6B #\U+1E87 #\U+1E8B #\U+1E8F
      #\Latin_Small_Letter_Z_With_Dot_Above #\U+1E64 #\U+1E65 #\U+1E66
      #\U+1E67 #\U+1E9B #\U+1E68 #\U+1E69)


    ;; #\Combining_Diaeresis

    #(#\Latin_Capital_Letter_A_With_Diaeresis
      #\Latin_Capital_Letter_E_With_Diaeresis #\U+1E26
      #\Latin_Capital_Letter_I_With_Diaeresis
      #\Latin_Capital_Letter_O_With_Diaeresis
      #\Latin_Capital_Letter_U_With_Diaeresis #\U+1E84 #\U+1E8C
      #\Latin_Capital_Letter_Y_With_Diaeresis
      #\Latin_Small_Letter_A_With_Diaeresis
      #\Latin_Small_Letter_E_With_Diaeresis #\U+1E27
      #\Latin_Small_Letter_I_With_Diaeresis
      #\Latin_Small_Letter_O_With_Diaeresis #\U+1E97
      #\Latin_Small_Letter_U_With_Diaeresis #\U+1E85 #\U+1E8D
      #\Latin_Small_Letter_Y_With_Diaeresis #\U+1E4E #\U+1E4F #\U+1E7A
      #\U+1E7B #\Greek_Capital_Letter_Iota_With_Dialytika
      #\Greek_Capital_Letter_Upsilon_With_Dialytika
      #\Greek_Small_Letter_Iota_With_Dialytika
      #\Greek_Small_Letter_Upsilon_With_Dialytika
      #\Greek_Upsilon_With_Diaeresis_And_Hook_Symbol
      #\Cyrillic_Capital_Letter_Yi
      #\Cyrillic_Capital_Letter_A_With_Diaeresis
      #\Cyrillic_Capital_Letter_Io
      #\Cyrillic_Capital_Letter_Zhe_With_Diaeresis
      #\Cyrillic_Capital_Letter_Ze_With_Diaeresis
      #\Cyrillic_Capital_Letter_I_With_Diaeresis
      #\Cyrillic_Capital_Letter_O_With_Diaeresis
      #\Cyrillic_Capital_Letter_U_With_Diaeresis
      #\Cyrillic_Capital_Letter_Che_With_Diaeresis
      #\Cyrillic_Capital_Letter_Yeru_With_Diaeresis
      #\Cyrillic_Capital_Letter_E_With_Diaeresis
      #\Cyrillic_Small_Letter_A_With_Diaeresis #\Cyrillic_Small_Letter_Io
      #\Cyrillic_Small_Letter_Zhe_With_Diaeresis
      #\Cyrillic_Small_Letter_Ze_With_Diaeresis
      #\Cyrillic_Small_Letter_I_With_Diaeresis
      #\Cyrillic_Small_Letter_O_With_Diaeresis
      #\Cyrillic_Small_Letter_U_With_Diaeresis
      #\Cyrillic_Small_Letter_Che_With_Diaeresis
      #\Cyrillic_Small_Letter_Yeru_With_Diaeresis
      #\Cyrillic_Small_Letter_E_With_Diaeresis #\Cyrillic_Small_Letter_Yi
      #\Cyrillic_Capital_Letter_Schwa_With_Diaeresis
      #\Cyrillic_Small_Letter_Schwa_With_Diaeresis
      #\Cyrillic_Capital_Letter_Barred_O_With_Diaeresis
      #\Cyrillic_Small_Letter_Barred_O_With_Diaeresis)


    ;; #\Combining_Hook_Above

    #(#\U+1EA2 #\U+1EBA #\U+1EC8 #\U+1ECE #\U+1EE6 #\U+1EF6 #\U+1EA3
      #\U+1EBB #\U+1EC9 #\U+1ECF #\U+1EE7 #\U+1EF7 #\U+1EA8 #\U+1EC2
      #\U+1ED4 #\U+1EA9 #\U+1EC3 #\U+1ED5 #\U+1EB2 #\U+1EB3 #\U+1EDE
      #\U+1EDF #\U+1EEC #\U+1EED)


    ;; #\Combining_Ring_Above

    #(#\Latin_Capital_Letter_A_With_Ring_Above
      #\Latin_Capital_Letter_U_With_Ring_Above
      #\Latin_Small_Letter_A_With_Ring_Above
      #\Latin_Small_Letter_U_With_Ring_Above #\U+1E98 #\U+1E99)


    ;; #\Combining_Double_Acute_Accent

    #(#\Latin_Capital_Letter_O_With_Double_Acute
      #\Latin_Capital_Letter_U_With_Double_Acute
      #\Latin_Small_Letter_O_With_Double_Acute
      #\Latin_Small_Letter_U_With_Double_Acute
      #\Cyrillic_Capital_Letter_U_With_Double_Acute
      #\Cyrillic_Small_Letter_U_With_Double_Acute)


    ;; #\Combining_Caron

    #(#\Latin_Capital_Letter_A_With_Caron
      #\Latin_Capital_Letter_C_With_Caron
      #\Latin_Capital_Letter_D_With_Caron
      #\Latin_Capital_Letter_E_With_Caron
      #\Latin_Capital_Letter_G_With_Caron
      #\Latin_Capital_Letter_H_With_Caron
      #\Latin_Capital_Letter_I_With_Caron
      #\Latin_Capital_Letter_K_With_Caron
      #\Latin_Capital_Letter_L_With_Caron
      #\Latin_Capital_Letter_N_With_Caron
      #\Latin_Capital_Letter_O_With_Caron
      #\Latin_Capital_Letter_R_With_Caron
      #\Latin_Capital_Letter_S_With_Caron
      #\Latin_Capital_Letter_T_With_Caron
      #\Latin_Capital_Letter_U_With_Caron
      #\Latin_Capital_Letter_Z_With_Caron #\Latin_Small_Letter_A_With_Caron
      #\Latin_Small_Letter_C_With_Caron #\Latin_Small_Letter_D_With_Caron
      #\Latin_Small_Letter_E_With_Caron #\Latin_Small_Letter_G_With_Caron
      #\Latin_Small_Letter_H_With_Caron #\Latin_Small_Letter_I_With_Caron
      #\Latin_Small_Letter_J_With_Caron #\Latin_Small_Letter_K_With_Caron
      #\Latin_Small_Letter_L_With_Caron #\Latin_Small_Letter_N_With_Caron
      #\Latin_Small_Letter_O_With_Caron #\Latin_Small_Letter_R_With_Caron
      #\Latin_Small_Letter_S_With_Caron #\Latin_Small_Letter_T_With_Caron
      #\Latin_Small_Letter_U_With_Caron #\Latin_Small_Letter_Z_With_Caron
      #\Latin_Capital_Letter_U_With_Diaeresis_And_Caron
      #\Latin_Small_Letter_U_With_Diaeresis_And_Caron
      #\Latin_Capital_Letter_Ezh_With_Caron
      #\Latin_Small_Letter_Ezh_With_Caron)


    ;; #\Combining_Double_Grave_Accent

    #(#\Latin_Capital_Letter_A_With_Double_Grave
      #\Latin_Capital_Letter_E_With_Double_Grave
      #\Latin_Capital_Letter_I_With_Double_Grave
      #\Latin_Capital_Letter_O_With_Double_Grave
      #\Latin_Capital_Letter_R_With_Double_Grave
      #\Latin_Capital_Letter_U_With_Double_Grave
      #\Latin_Small_Letter_A_With_Double_Grave
      #\Latin_Small_Letter_E_With_Double_Grave
      #\Latin_Small_Letter_I_With_Double_Grave
      #\Latin_Small_Letter_O_With_Double_Grave
      #\Latin_Small_Letter_R_With_Double_Grave
      #\Latin_Small_Letter_U_With_Double_Grave
      #\Cyrillic_Capital_Letter_Izhitsa_With_Double_Grave_Accent
      #\Cyrillic_Small_Letter_Izhitsa_With_Double_Grave_Accent)


    ;; #\Combining_Inverted_Breve

    #(#\Latin_Capital_Letter_A_With_Inverted_Breve
      #\Latin_Capital_Letter_E_With_Inverted_Breve
      #\Latin_Capital_Letter_I_With_Inverted_Breve
      #\Latin_Capital_Letter_O_With_Inverted_Breve
      #\Latin_Capital_Letter_R_With_Inverted_Breve
      #\Latin_Capital_Letter_U_With_Inverted_Breve
      #\Latin_Small_Letter_A_With_Inverted_Breve
      #\Latin_Small_Letter_E_With_Inverted_Breve
      #\Latin_Small_Letter_I_With_Inverted_Breve
      #\Latin_Small_Letter_O_With_Inverted_Breve
      #\Latin_Small_Letter_R_With_Inverted_Breve
      #\Latin_Small_Letter_U_With_Inverted_Breve)


    ;; #\Combining_Comma_Above

    #(#\U+1F08 #\U+1F18 #\U+1F28 #\U+1F38 #\U+1F48 #\U+1F68 #\U+1F00
      #\U+1F10 #\U+1F20 #\U+1F30 #\U+1F40 #\U+1FE4 #\U+1F50 #\U+1F60)


    ;; #\Combining_Reversed_Comma_Above

    #(#\U+1F09 #\U+1F19 #\U+1F29 #\U+1F39 #\U+1F49 #\U+1FEC #\U+1F59
      #\U+1F69 #\U+1F01 #\U+1F11 #\U+1F21 #\U+1F31 #\U+1F41 #\U+1FE5
      #\U+1F51 #\U+1F61)


    ;; #\Combining_Horn

    #(#\Latin_Capital_Letter_O_With_Horn
      #\Latin_Capital_Letter_U_With_Horn #\Latin_Small_Letter_O_With_Horn
      #\Latin_Small_Letter_U_With_Horn)


    ;; #\Combining_Dot_Below

    #(#\U+1EA0 #\U+1E04 #\U+1E0C #\U+1EB8 #\U+1E24 #\U+1ECA #\U+1E32
      #\U+1E36 #\U+1E42 #\U+1E46 #\U+1ECC #\U+1E5A #\U+1E62 #\U+1E6C
      #\U+1EE4 #\U+1E7E #\U+1E88 #\U+1EF4 #\U+1E92 #\U+1EA1 #\U+1E05
      #\U+1E0D #\U+1EB9 #\U+1E25 #\U+1ECB #\U+1E33 #\U+1E37 #\U+1E43
      #\U+1E47 #\U+1ECD #\U+1E5B #\U+1E63 #\U+1E6D #\U+1EE5 #\U+1E7F
      #\U+1E89 #\U+1EF5 #\U+1E93 #\U+1EE2 #\U+1EE3 #\U+1EF0 #\U+1EF1)


    ;; #\Combining_Diaeresis_Below

    #(#\U+1E72 #\U+1E73)


    ;; #\Combining_Ring_Below

    #(#\U+1E00 #\U+1E01)


    ;; #\Combining_Comma_Below

    #(#\Latin_Capital_Letter_S_With_Comma_Below
      #\Latin_Capital_Letter_T_With_Comma_Below
      #\Latin_Small_Letter_S_With_Comma_Below
      #\Latin_Small_Letter_T_With_Comma_Below)


    ;; #\Combining_Cedilla

    #(#\Latin_Capital_Letter_C_With_Cedilla #\U+1E10
      #\Latin_Capital_Letter_E_With_Cedilla
      #\Latin_Capital_Letter_G_With_Cedilla #\U+1E28
      #\Latin_Capital_Letter_K_With_Cedilla
      #\Latin_Capital_Letter_L_With_Cedilla
      #\Latin_Capital_Letter_N_With_Cedilla
      #\Latin_Capital_Letter_R_With_Cedilla
      #\Latin_Capital_Letter_S_With_Cedilla
      #\Latin_Capital_Letter_T_With_Cedilla
      #\Latin_Small_Letter_C_With_Cedilla #\U+1E11
      #\Latin_Small_Letter_E_With_Cedilla
      #\Latin_Small_Letter_G_With_Cedilla #\U+1E29
      #\Latin_Small_Letter_K_With_Cedilla
      #\Latin_Small_Letter_L_With_Cedilla
      #\Latin_Small_Letter_N_With_Cedilla
      #\Latin_Small_Letter_R_With_Cedilla
      #\Latin_Small_Letter_S_With_Cedilla
      #\Latin_Small_Letter_T_With_Cedilla)


    ;; #\Combining_Ogonek

    #(#\Latin_Capital_Letter_A_With_Ogonek
      #\Latin_Capital_Letter_E_With_Ogonek
      #\Latin_Capital_Letter_I_With_Ogonek
      #\Latin_Capital_Letter_O_With_Ogonek
      #\Latin_Capital_Letter_U_With_Ogonek
      #\Latin_Small_Letter_A_With_Ogonek #\Latin_Small_Letter_E_With_Ogonek
      #\Latin_Small_Letter_I_With_Ogonek #\Latin_Small_Letter_O_With_Ogonek
      #\Latin_Small_Letter_U_With_Ogonek)


    ;; #\Combining_Circumflex_Accent_Below

    #(#\U+1E12 #\U+1E18 #\U+1E3C #\U+1E4A #\U+1E70 #\U+1E76 #\U+1E13
      #\U+1E19 #\U+1E3D #\U+1E4B #\U+1E71 #\U+1E77)


    ;; #\Combining_Breve_Below

    #(#\U+1E2A #\U+1E2B)


    ;; #\Combining_Tilde_Below

    #(#\U+1E1A #\U+1E2C #\U+1E74 #\U+1E1B #\U+1E2D #\U+1E75)


    ;; #\Combining_Macron_Below

    #(#\U+1E06 #\U+1E0E #\U+1E34 #\U+1E3A #\U+1E48 #\U+1E5E #\U+1E6E
      #\U+1E94 #\U+1E07 #\U+1E0F #\U+1E96 #\U+1E35 #\U+1E3B #\U+1E49
      #\U+1E5F #\U+1E6F #\U+1E95)


    ;; #\Combining_Long_Solidus_Overlay

    #(#\U+226E #\U+2260 #\U+226F #\U+219A #\U+219B #\U+21AE #\U+21CD
      #\U+21CF #\U+21CE #\U+2204 #\U+2209 #\U+220C #\U+2224 #\U+2226
      #\U+2241 #\U+2244 #\U+2247 #\U+2249 #\U+226D #\U+2262 #\U+2270
      #\U+2271 #\U+2274 #\U+2275 #\U+2278 #\U+2279 #\U+2280 #\U+2281
      #\U+22E0 #\U+22E1 #\U+2284 #\U+2285 #\U+2288 #\U+2289 #\U+22E2
      #\U+22E3 #\U+22AC #\U+22AD #\U+22AE #\U+22AF #\U+22EA #\U+22EB
      #\U+22EC #\U+22ED)


    ;; #\Combining_Greek_Perispomeni

    #(#\U+1FC1 #\U+1FB6 #\U+1FC6 #\U+1FD6 #\U+1FE6 #\U+1FF6 #\U+1FD7
      #\U+1FE7 #\U+1F06 #\U+1F07 #\U+1F0E #\U+1F0F #\U+1F26 #\U+1F27
      #\U+1F2E #\U+1F2F #\U+1F36 #\U+1F37 #\U+1F3E #\U+1F3F #\U+1F56
      #\U+1F57 #\U+1F5F #\U+1F66 #\U+1F67 #\U+1F6E #\U+1F6F #\U+1FCF
      #\U+1FDF)


    ;; #\Combining_Greek_Ypogegrammeni

    #(#\U+1FBC #\U+1FCC #\U+1FFC #\U+1FB4 #\U+1FC4 #\U+1FB3 #\U+1FC3
      #\U+1FF3 #\U+1FF4 #\U+1F80 #\U+1F81 #\U+1F82 #\U+1F83 #\U+1F84
      #\U+1F85 #\U+1F86 #\U+1F87 #\U+1F88 #\U+1F89 #\U+1F8A #\U+1F8B
      #\U+1F8C #\U+1F8D #\U+1F8E #\U+1F8F #\U+1F90 #\U+1F91 #\U+1F92
      #\U+1F93 #\U+1F94 #\U+1F95 #\U+1F96 #\U+1F97 #\U+1F98 #\U+1F99
      #\U+1F9A #\U+1F9B #\U+1F9C #\U+1F9D #\U+1F9E #\U+1F9F #\U+1FA0
      #\U+1FA1 #\U+1FA2 #\U+1FA3 #\U+1FA4 #\U+1FA5 #\U+1FA6 #\U+1FA7
      #\U+1FA8 #\U+1FA9 #\U+1FAA #\U+1FAB #\U+1FAC #\U+1FAD #\U+1FAE
      #\U+1FAF #\U+1FB2 #\U+1FC2 #\U+1FF2 #\U+1FB7 #\U+1FC7 #\U+1FF7)


    ;; #\Arabic_Maddah_Above

    #(#\Arabic_Letter_Alef_With_Madda_Above)


    ;; #\Arabic_Hamza_Above

    #(#\Arabic_Letter_Alef_With_Hamza_Above
      #\Arabic_Letter_Waw_With_Hamza_Above
      #\Arabic_Letter_Yeh_With_Hamza_Above
      #\Arabic_Letter_Heh_Goal_With_Hamza_Above
      #\Arabic_Letter_Yeh_Barree_With_Hamza_Above
      #\Arabic_Letter_Heh_With_Yeh_Above)


    ;; #\Arabic_Hamza_Below

    #(#\Arabic_Letter_Alef_With_Hamza_Below)


    ;; #\U+093C

    #(#\U+0929 #\U+0931 #\U+0934)


    ;; #\U+09BE

    #(#\U+09CB)


    ;; #\U+09D7

    #(#\U+09CC)


    ;; #\U+0B3E

    #(#\U+0B4B)


    ;; #\U+0B56

    #(#\U+0B48)


    ;; #\U+0B57

    #(#\U+0B4C)


    ;; #\U+0BBE

    #(#\U+0BCA #\U+0BCB)


    ;; #\U+0BD7

    #(#\U+0B94 #\U+0BCC)


    ;; #\U+0C56

    #(#\U+0C48)


    ;; #\U+0CC2

    #(#\U+0CCA)


    ;; #\U+0CD5

    #(#\U+0CC0 #\U+0CC7 #\U+0CCB)


    ;; #\U+0CD6

    #(#\U+0CC8)


    ;; #\U+0D3E

    #(#\U+0D4A #\U+0D4B)


    ;; #\U+0D57

    #(#\U+0D4C)


    ;; #\U+0DCA

    #(#\U+0DDA #\U+0DDD)


    ;; #\U+0DCF

    #(#\U+0DDC)


    ;; #\U+0DDF

    #(#\U+0DDE)


    ;; #\U+102E

    #(#\U+1026)


    ;; #\U+3099

    #(#\U+3094 #\U+304C #\U+304E #\U+3050 #\U+3052 #\U+3054 #\U+3056
      #\U+3058 #\U+305A #\U+305C #\U+305E #\U+3060 #\U+3062 #\U+3065
      #\U+3067 #\U+3069 #\U+3070 #\U+3073 #\U+3076 #\U+3079 #\U+307C
      #\U+309E #\U+30F4 #\U+30AC #\U+30AE #\U+30B0 #\U+30B2 #\U+30B4
      #\U+30B6 #\U+30B8 #\U+30BA #\U+30BC #\U+30BE #\U+30C0 #\U+30C2
      #\U+30C5 #\U+30C7 #\U+30C9 #\U+30D0 #\U+30D3 #\U+30D6 #\U+30D9
      #\U+30DC #\U+30F7 #\U+30F8 #\U+30F9 #\U+30FA #\U+30FE)


    ;; #\U+309A

    #(#\U+3071 #\U+3074 #\U+3077 #\U+307A #\U+307D #\U+30D1 #\U+30D4
      #\U+30D7 #\U+30DA #\U+30DD)
    ))

(defun search-char-vector (vector char)
  ;; vector is a SIMPLE-VECTOR of chars sorted by char-code.
  ;; return the index of char in vector or NIL if not found
  (let* ((left 0)
         (right (1- (length vector))))
    (declare (fixnum left right))
    (if (and (char>= char (svref vector left))
             (char<= char (svref vector right)))
      (do* ()
           ((> left right))
        (let* ((mid (ash (the fixnum (+ left right)) -1))
               (midch (svref vector mid)))
          (declare (fixnum mid))
          (if (eql char midch)
            (return mid)
            (if (char< char midch)
              (setq right (1- mid))
              (setq left (1+ mid)))))))))


(defconstant HANGUL-SBASE #xAC00)
(defconstant HANGUL-LBASE #x1100)
(defconstant HANGUL-VBASE #x1161)
(defconstant HANGUL-TBASE #x11A7)

(defconstant HANGUL-SCOUNT 11172)
(defconstant HANGUL-LCOUNT 19)
(defconstant HANGUL-VCOUNT 21)
(defconstant HANGUL-TCOUNT 28)
(defconstant HANGUL-NCOUNT (* HANGUL-VCOUNT HANGUL-TCOUNT))

(defun combine-bmp-chars (base combiner)
  (if (and (char>= combiner (code-char hangul-vbase))
           (char< combiner (code-char (+ hangul-tbase hangul-tcount))))
    (if (and (char< combiner (code-char (+ hangul-vbase hangul-vcount)))
             (char>= base (code-char hangul-lbase))
             (char< base (code-char (+ hangul-lbase hangul-lcount))))
      (return-from combine-bmp-chars
        (code-char (+ hangul-lbase
                      (* hangul-ncount (- (char-code base) hangul-lbase))
                      (* hangul-tcount (- (char-code combiner) hangul-vbase))))))
    (if (and (char> combiner (code-char hangul-tbase))
             (char>= base (code-char hangul-sbase))
             (char< base (code-char (+ hangul-sbase hangul-scount))))
      (if (not (zerop (the fixnum (mod (- (char-code base) hangul-sbase) hangul-tcount))))
        (return-from combine-bmp-chars nil)
        (return-from combine-bmp-chars
          (code-char (+ (char-code base) (- (char-code combiner) hangul-tbase)))))))
    
  (let* ((idx (search-char-vector *bmp-combining-chars* combiner))
         (base-table (if idx (svref *bmp-combining-base-chars* idx))))
    (if base-table
      (let* ((combined-idx (search-char-vector base-table base)))
        (if combined-idx
          (svref (svref *bmp-precombined-chars* idx) combined-idx))))))

(defun precompose-simple-string (s)
  (let* ((n (length s)))
    (or (dotimes (i n s)
          (when (is-combinable (schar s i))
            (return nil)))
        (let* ((new (make-string n)))
          (declare (dynamic-extent new))
          (do* ((i 0 (1+ i))
                (nout -1)
                (lastch nil))
               ((= i n) (subseq new 0 (1+ nout)))
            (declare (fixnum nout i))
            (let* ((ch (schar s i)))
              (if (or (not lastch)
                      (not (is-combinable ch)))
                (setf lastch ch
                      (schar new (incf nout)) ch)
                (let* ((combined (combine-bmp-chars lastch ch)))
                  (if combined
                    (setf (schar new nout) (setq lastch combined))
                    (setf lastch ch
                      (schar new (incf nout)) ch))))))))))

;;; Parse the string LINE (an Emacs-style file-attributes line)
;;; into a plist with Emacs variable names as keywords and values
;;; as strings (or list of strings).  Quietly return NIL on error.
(defun parse-file-options-line (line)
  (let* ((start (search "-*-" line))
         (start+3 (when start (+ start 3)))
         (end (and start+3 (search "-*-" line :start2 start+3))))
    (when end
      (setq line (subseq line start+3 end))
      (let* ((plist ()))
        (loop
          ;; The line between -*- pairs should be of the form
          ;; {varname: value;}*.  Emacs and Hemlock both seem
          ;; able to deal with the case where the last pair is
          ;; missing a trailing semicolon.
          (let* ((colon (position #\: line))
                 (semi (and colon (position #\; line :start (1+ colon)))))
            (unless colon
              (return plist))
            (let* ((key (intern (nstring-upcase (string-trim " 	" (subseq line 0 colon))) "KEYWORD"))
                   (val (string-trim '(#\space #\tab) (subseq line (1+ colon) (or semi (length line))))))
              (setq line (if semi (subseq line (1+ semi)) ""))
              (unless (eq key :eval)
                (let* ((already (getf plist key)))
                  (if already
                    (setf (getf plist key) (nconc (if (atom already)
                                                    (list already)
                                                    already)
                                                  (list val)))
                    (setq plist (nconc plist (list key val)))))))))))))

(defun process-file-coding-option (emacs-name line-termination)
  (when emacs-name
      (let* ((len (length emacs-name)))
        (cond ((and (> len 5) (string-equal "-unix" emacs-name :start2 (- len 5)))
               (setq emacs-name (subseq emacs-name 0 (- len 5))))
              ((and (> len 4) (or
                               (when (string-equal "-dos" emacs-name :start2 (- len 4))
                                 (setq line-termination :crlf))
                               (when (string-equal "-mac" emacs-name :start2 (- len 4))
                                 (setq line-termination :cr))))
                               
               (setq emacs-name (subseq emacs-name 0 (- len 4))))))
        (let* ((key (intern (string-upcase emacs-name) "KEYWORD"))
               (encoding (lookup-character-encoding key)))
          (if encoding
            (make-external-format :character-encoding (character-encoding-name encoding)
                                  :line-termination line-termination)
            (warn "file CODING option ~s isn't recognized as the name of a character encoding.~&Consider using ~S to define ~S as an alias for a supported encoding." key 'define-character-encoding-alias key)))))
  
(defun external-format-from-file-options (line)
  (process-file-coding-option (getf (parse-file-options-line line) :coding)
                              :unix))

(defun external-format-from-octet-buffer (buf count)
  (declare (fixnum count))
  (dotimes (i count)
    (let* ((octet (%get-unsigned-byte buf i)))
      (cond ((or (eql octet (char-code #\linefeed))
                 (eql octet (char-code #\return)))
             (return (external-format-from-file-options (%str-from-ptr buf i))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-unicode.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/x86-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 2005-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


(in-package "CCL")


(defun %frame-backlink (p &optional context)
  (declare (ignore context))
  (cond ((fixnump p) (%%frame-backlink p))
        (t (error "~s is not a valid stack frame" p))))

(defun bottom-of-stack-p (p context)
  (and (fixnump p)
       (locally (declare (fixnum p))
	 (let* ((tcr (if context (bt.tcr context) (%current-tcr)))
                (vs-area (%fixnum-ref tcr (- target::tcr.vs-area
					     target::tcr-bias))))
	   (not (%ptr-in-area-p p vs-area))))))


(defun lisp-frame-p (p context)
  (declare (fixnum p))
  (let ((next-frame (%frame-backlink p context)))
    (declare (fixnum next-frame))
    (if (bottom-of-stack-p next-frame context)
        (values nil t)
        (values t nil))))


(defun catch-frame-sp (catch)
  (uvref catch
	 #+x8632-target x8632::catch-frame.ebp-cell
	 #+x8664-target x8664::catch-frame.rbp-cell))

;;; Sure would be nice to have &optional in defppclapfunction arglists
;;; Sure would be nice not to do this at runtime.

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref)))))

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref-natural
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref-natural)))))


;;; Sure would be nice to have &optional in defppclapfunction arglists
;;; Sure would be nice not to do this at runtime.

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref)))))

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref-natural
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref-natural)))))

(let ((bits (lfun-bits #'(lambda (x y &optional z) (declare (ignore x y z))))))
  (lfun-bits #'%fixnum-set
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-set)))))

(let ((bits (lfun-bits #'(lambda (x y &optional z) (declare (ignore x y z))))))
  (lfun-bits #'%fixnum-set-natural
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-set-natural)))))


#+x8632-target
(defun valid-subtag-p (subtag)
  (declare (fixnum subtag))
  (let* ((tagval (ldb (byte (- x8632::num-subtag-bits x8632::ntagbits) x8632::ntagbits) subtag)))
    (declare (fixnum tagval))
    (case (logand subtag x8632::fulltagmask)
      (#. x8632::fulltag-immheader (not (eq (%svref *immheader-types* tagval) 'bogus)))
      (#. x8632::fulltag-nodeheader (not (eq (%svref *nodeheader-types* tagval) 'bogus)))
      (t nil))))

#+x8664-target
(defun valid-subtag-p (subtag)
  (declare (fixnum subtag))
  (let* ((tagval (logand x8664::fulltagmask subtag))
         (high4 (ash subtag (- x8664::ntagbits))))
    (declare (fixnum tagval high4))
    (not (eq 'bogus
             (case tagval
               (#.x8664::fulltag-immheader-0
                (%svref *immheader-0-types* high4))
               (#.x8664::fulltag-immheader-1
                (%svref *immheader-1-types* high4))
               (#.x8664::fulltag-immheader-2
                (%svref *immheader-2-types* high4))
               (#.x8664::fulltag-nodeheader-0
                (%svref *nodeheader-0-types* high4))
               (#.x8664::fulltag-nodeheader-1
                (%svref *nodeheader-1-types* high4))
               (t 'bogus))))))

#+x8632-target
(defun valid-header-p (thing)
  (let* ((fulltag (fulltag thing)))
    (declare (fixnum fulltag))
    (case fulltag
      (#.x8632::fulltag-misc (valid-subtag-p (typecode thing)))
      ((#.x8632::fulltag-immheader #.x8632::fulltag-nodeheader) nil)
      (t t))))

#+x8664-target
(defun valid-header-p (thing)
  (let* ((fulltag (fulltag thing)))
    (declare (fixnum fulltag))
    (case fulltag
      ((#.x8664::fulltag-even-fixnum
        #.x8664::fulltag-odd-fixnum
        #.x8664::fulltag-imm-0
        #.x8664::fulltag-imm-1)
       t)
      (#.x8664::fulltag-function
       (= x8664::subtag-function (typecode (%function-to-function-vector thing))))
      (#.x8664::fulltag-symbol
       (= x8664::subtag-symbol (typecode (%symptr->symvector thing))))
      (#.x8664::fulltag-misc
       (valid-subtag-p (typecode thing)))
      ((#.x8664::fulltag-tra-0
        #.x8664::fulltag-tra-1)
       (let* ((disp (%return-address-offset thing)))
         (and disp
              (let* ((f (%return-address-function thing)))
                (and (typep f 'function) (valid-header-p f))))))
      (#.x8664::fulltag-cons t)
      (#.x8664::fulltag-nil (null thing))
      (t nil))))
             
#+x8632-target
(defun bogus-thing-p (x)
  (when x
    (or (not (valid-header-p x))
        (let ((tag (lisptag x))
	      (fulltag (fulltag x)))
          (unless (or (eql tag x8632::tag-fixnum)
                      (eql tag x8632::tag-imm)
                      (in-any-consing-area-p x)
		      (temporary-cons-p x)
		      (and (or (typep x 'function)
			       (typep x 'gvector))
			   (on-any-tsp-stack x))
		      (and (eql fulltag x8632::fulltag-tra)
			   (%return-address-offset x))
		      (and (typep x 'ivector)
			   (on-any-csp-stack x))
		      (%heap-ivector-p x))
	    t)))))

#+x8664-target
(defun bogus-thing-p (x)
  (when x
    (or (not (valid-header-p x))
        (let* ((tag (lisptag x)))
          (unless (or (eql tag x8664::tag-fixnum)
                      (eql tag x8664::tag-imm-0)
                      (eql tag x8664::tag-imm-1)
                      (in-any-consing-area-p x)
                      (temporary-cons-p x)
                      (and (or (typep x 'function)
                               (typep x 'gvector))
                           (on-any-tsp-stack x))
                      (and (eql tag x8664::tag-tra)
                           (eql 0 (%return-address-offset x)))
                      (and (typep x 'ivector)
                           (on-any-csp-stack x))
                      (%heap-ivector-p x))
            t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/x86-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/arm-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2010 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defun make-callback-trampoline (index &optional info)
  (declare (ignore info))
  (let* ((p (%allocate-callback-pointer 16)))
    (macrolet ((arm-lap-word (instruction-form)
                 (uvref (uvref (compile nil `(lambda (&lap 0) (arm-lap-function () ((?? 0)) ,instruction-form))) 1) 0)))
      (setf (%get-unsigned-long p 0)
            (dpb (ldb (byte 8 0) index)
                 (byte 8 0)
                 (arm-lap-word (mov r12 (:$ ??))))
            (%get-unsigned-long p 4)
            (dpb (ldb (byte 8 8) index)
                 (byte 8 0)
                 (dpb 12 (byte 4 8)
                      (arm-lap-word (orr r12 r12  (:$ ??)))))
            (%get-unsigned-long p 8)
            (arm-lap-word (ldr pc (:@ pc (:$ -4))))
            (%get-unsigned-long p 12)
            (%lookup-subprim-address #.(subprim-name->offset '.SPeabi-callback)))
      (ff-call (%kernel-import #.arm::kernel-import-makedataexecutable) 
               :address p 
               :unsigned-fullword 16
               :void)
      p)))
                    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/arm-callback-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-boot-3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; l1-boot-3.lisp
;;; Third part of l1-boot

(in-package "CCL")

;;; Register Emacs-friendly aliases for some character encodings.
;;; This could go on forever; try to recognize at least some common
;;; cases.  (The precise set of encoding/coding-system names supported
;;; by Emacs likely depends on Emacs version, loaded Emacs packages, etc.)

(dotimes (i 16)
  (let* ((key (find-symbol (format nil "LATIN~d" i) :keyword))
         (existing (and key (lookup-character-encoding key))))
    (when existing
      (define-character-encoding-alias (intern (format nil "LATIN-~d" i) :keyword) existing)
      (define-character-encoding-alias (intern (format nil "ISO-LATIN-~d" i) :keyword) existing))))

(define-character-encoding-alias :mule-utf-8 :utf-8)

(set-pathname-encoding-name :utf-8)

(catch :toplevel
    (or (find-package "COMMON-LISP-USER")
        (make-package "COMMON-LISP-USER" :use '("COMMON-LISP" "CCL") :NICKNAMES '("CL-USER")))
)

(set-periodic-task-interval .33)
(setq cmain xcmain)
(setq %err-disp %xerr-disp)

;;;end of l1-boot-3.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-boot-3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-sort.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Low-level list sorting routines.  Used by CLOS and SORT.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)

(defmacro apply-key (key value)
  `(if ,key
     (funcall ,key ,value)
     ,value))

)

;; A macro to make predicate & key into lfuns, or maybe NIL.
(defmacro canonicalize-pred-and-key (&optional (pred 'pred) (key 'key))
  `(progn (setq ,pred (coerce-to-function ,pred))
          (unless (null ,key)
            (setq ,key (coerce-to-function ,key))
            (if (eq ,key #'identity) (setq ,key nil)))))


(defun final-cons (p)
  (do* ((drag p lead)
        (lead (cdr p) (cdr lead)))
       ((null lead)
        drag)))

;;; 		   modified to return a pointer to the end of the result
;;; 		      and to not cons header each time its called.
;;; It destructively merges list-1 with list-2.  In the resulting
;;; list, elements of list-2 are guaranteed to come after equal elements
;;; of list-1.
(defun merge-lists* (list-1 list-2 pred key)
  (declare (optimize (speed 3) (safety 0)))
  (if (null key)
    (merge-lists*-no-key list-1 list-2 pred) 
    (cond ((null list-1)
           (values list-2 (final-cons list-2)))
          ((null list-2)
           (values list-1 (final-cons list-1)))
          (t (let* ((result (cons nil nil))
                    (P result)                  ; P points to last cell of result
                    (key-1 (apply-key key (car list-1)))
                    (key-2 (apply-key key (car list-2))))
               (declare (dynamic-extent result))
               (declare (type list p))
               (loop
                 (cond ((funcall pred key-2 key-1)
                        (rplacd P list-2)       ; append the lesser list to last cell of
                        (setq P (cdr P))        ;   result.  Note: test must bo done for
                        (pop list-2)            ;   list-2 < list-1 so merge will be
                        (unless list-2          ;   stable for list-1
                          (rplacd P list-1)
                          (return (values (cdr result) (final-cons p))))
                        (setq key-2 (apply-key key (car list-2))))
                       (T (rplacd P list-1)         
                          (setq P (cdr P))
                          (pop list-1)
                          (unless list-1
                            (rplacd P list-2)
                            (return (values (cdr result) (final-cons p))))
                          (setq key-1 (apply-key key (car list-1)))))))))))

(defun merge-lists*-no-key (list-1 list-2 pred)
  (declare (optimize (speed 3) (safety 0)))
  (cond ((null list-1)
         (values list-2 (final-cons list-2)))
        ((null list-2)
         (values list-1 (final-cons list-1)))
        (t (let* ((result (cons nil nil))
                  (P result)                  ; P points to last cell of result
                  (key-1 (car list-1))
                  (key-2 (car list-2)))
             (declare (dynamic-extent result))
             (declare (type list p))
             (loop
               (cond ((funcall pred key-2 key-1)
                      (rplacd P list-2)        ; append the lesser list to last cell of
                      (setq P (cdr P))         ;   result.  Note: test must bo done for
                      (pop list-2)             ;   list-2 < list-1 so merge will be
                      (unless list-2           ;   stable for list-1
                        (rplacd P list-1)
                        (return (values (cdr result) (final-cons p))))
                      (setq key-2 (car list-2)))
                     (T (rplacd P list-1)
                        (setq P (cdr P))
                        (pop list-1)
                        (unless list-1
                          (rplacd P list-2)
                          (return (values (cdr result) (final-cons p))))
                        (setq key-1 (car list-1)))))))))

(defun sort-list (list pred key)
  (canonicalize-pred-and-key pred key)
  (let ((head (cons nil list))          ; head holds on to everything
	  (n 1)                                ; bottom-up size of lists to be merged
	  unsorted                             ; unsorted is the remaining list to be
                                        ;   broken into n size lists and merged
	  list-1                               ; list-1 is one length n list to be merged
	  last)                                ; last points to the last visited cell
    (declare (fixnum n))
    (declare (dynamic-extent head))
    (loop
      ;; start collecting runs of n at the first element
      (setf unsorted (cdr head))
      ;; tack on the first merge of two n-runs to the head holder
      (setf last head)
      (let ((n-1 (1- n)))
        (declare (fixnum n-1))
        (loop
	    (setf list-1 unsorted)
	    (let ((temp (nthcdr n-1 list-1))
	          list-2)
	      (cond (temp
		       ;; there are enough elements for a second run
		       (setf list-2 (cdr temp))
		       (setf (cdr temp) nil)
		       (setf temp (nthcdr n-1 list-2))
		       (cond (temp
			        (setf unsorted (cdr temp))
			        (setf (cdr temp) nil))
		             ;; the second run goes off the end of the list
		             (t (setf unsorted nil)))
		       (multiple-value-bind (merged-head merged-last)
                                            (merge-lists* list-1 list-2 pred key)
		         (setf (cdr last) merged-head)
		         (setf last merged-last))
		       (if (null unsorted) (return)))
		      ;; if there is only one run, then tack it on to the end
		      (t (setf (cdr last) list-1)
		         (return)))))
        (setf n (ash n 1)) ; (+ n n)
        ;; If the inner loop only executed once, then there were only enough
        ;; elements for two runs given n, so all the elements have been merged
        ;; into one list.  This may waste one outer iteration to realize.
        (if (eq list-1 (cdr head))
	    (return list-1))))))


;; The no-key version of %sort-list
;; list had better be a list.
;; pred had better be functionp.
(defun %sort-list-no-key (list pred)
  (sort-list list pred nil))

(defun sort-list-error ()
  (error "List arg to SORT not a proper list"))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-sort.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-aprims.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; L1-aprims.lisp


(in-package "CCL")


(let* ((standard-initial-bindings ())
       (standard-initial-bindings-lock (make-read-write-lock)))

  (defun standard-initial-bindings ()
    (with-read-lock (standard-initial-bindings-lock)
      (copy-list standard-initial-bindings)))

  (defun define-standard-initial-binding (symbol initform)
    (setq symbol (require-type symbol 'symbol))
    (%proclaim-special symbol)
    (unless (boundp symbol)
      (set symbol (funcall initform)))
    (with-write-lock (standard-initial-bindings-lock)
      (let* ((pair (assoc symbol standard-initial-bindings)))
	(if pair
	  (setf (cdr pair) initform)
	  (push (cons symbol initform) standard-initial-bindings))))
    (record-source-file symbol 'variable)
    symbol))

(defstatic *kernel-tcr-area-lock* (%make-lock (%null-ptr) "Kernel tcr-area-lock"))

(defstatic *kernel-exception-lock* (%make-lock (%null-ptr) "Kernel exception-lock"))
  
(def-ccl-pointers kernel-locks ()
  (let* ((p (recursive-lock-ptr *kernel-tcr-area-lock*))
         (q (recursive-lock-ptr *kernel-exception-lock*)))
    (%revive-macptr p)
    (%revive-macptr q)
    (%get-kernel-global-ptr area-lock p)
    (%get-kernel-global-ptr exception-lock q)))

(def-standard-initial-binding *package*)
(def-standard-initial-binding *random-state* (initial-random-state))
(def-standard-initial-binding *error-print-length* 20)
(def-standard-initial-binding *error-print-level* 8)
(def-standard-initial-binding *error-print-string-length* :default)

(defun %badarg (arg type)
  (%err-disp $XWRONGTYPE arg type))

(defun atom (arg)
  "Return true if OBJECT is an ATOM, and NIL otherwise."
  (not (consp arg)))

(defun list (&rest args)
  "Return constructs and returns a list of its arguments."
  args)

(%fhave '%temp-list #'list)

(defun list* (arg &rest others)
  "Return a list of the arguments with last cons a dotted pair"
  (cond ((null others) arg)
	((null (cdr others)) (cons arg (car others)))
	(t (do ((x others (cdr x)))
	       ((null (cddr x)) (rplacd x (cadr x))))
	   (cons arg others))))



(defun funcall (fn &rest args)
  "Call FUNCTION with the given ARGUMENTS."
  (declare (dynamic-extent args))
  (apply fn args))


(defun apply (function arg &rest args)
  "Apply FUNCTION to a list of arguments produced by evaluating ARGUMENTS in
   the manner of LIST*. That is, a list is made of the values of all but the
   last argument, appended to the value of the last argument, which must be a
   list."
  (declare (dynamic-extent args))
  (cond ((null args)
	 (apply function arg))
	((null (cdr args))
	 (apply function arg (car args)))
	(t (do* ((a1 args a2)
		 (a2 (cdr args) (cdr a2)))
		((atom (cdr a2))
		 (rplacd a1 (car a2))
		 (apply function arg args))))))


;;; This is not fast, but it gets the functionality that
;;; Wood and possibly other code depend on.
(defun applyv (function arg &rest other-args)
  (declare (dynamic-extent other-args))
  (let* ((other-args (cons arg other-args))
	 (last-arg (car (last other-args)))
	 (last-arg-length (length last-arg))
	 (butlast-args (nbutlast other-args))
	 (rest-args (make-list last-arg-length))
	 (rest-args-tail rest-args))
    (declare (dynamic-extent other-args rest-args))
    (dotimes (i last-arg-length)
      (setf (car rest-args-tail) (aref last-arg i))
      (pop rest-args-tail))
    (apply function (nconc butlast-args rest-args))))

;;; This is slow, and since %apply-lexpr isn't documented either,
;;; nothing in the world should depend on it.  This is just being
;;; anal retentive.  VERY anal retentive.

(defun %apply-lexpr (function arg &rest args)
  (cond ((null args) (%apply-lexpr function arg))
        (t (apply function arg (nconc (nbutlast args)
                                      (collect-lexpr-args (car (last args)) 0))))))


(defun values-list (arg)
  "Return all of the elements of LIST, in order, as values."
  (apply #'values arg))






; copy-list

(defun copy-list (list)
  "Return a new list which is EQUAL to LIST."
  (if list
    (let ((result (cons (car list) '()) ))
      (do ((x (cdr list) (cdr x))
           (i 0 (1+ i))
           (len)
           (splice result
                   (%cdr (%rplacd splice (cons (%car x) '() ))) ))
          ((atom x)
           (unless (null x)
             (%rplacd splice x))
           result)
        (declare (fixnum i))
        ;; If the argument is "moderately long", check to see if it's
        ;; "very long"; if so, it may be much faster to replace the
        ;; elements of a list allocated in a single operation than it
        ;; is to repeatedly CONS (since the latter tends to fight with
        ;; the EGC.)
        ;; The definitions of "moderately long" and "very long" are
        ;; both somewhat arbitrary.
        (when (and (= i 1024)
                   (> (setq len (alt-list-length x)) (ash 1 16)))
          (do* ((tail (setf (%cdr splice) (%allocate-list 0 len)))
                (x x (cdr x)))
               ((atom x)
                (unless (null x)
                  (%rplacd tail x))
                (return-from copy-list result))
            (%rplaca tail (%car x))
            (unless (atom (%cdr x))
              (setq tail (cdr tail)))))))))
          

(defun alt-list-length (l)
  "Detect (and complain about) cirucular lists; allow any atom to
terminate the list"
  (do* ((n 0 (1+ n))
        (fast l)
        (slow l))
       ((atom fast) n)
    (declare (fixnum n))
    (setq fast (cdr fast))
    (if (logbitp 0 n)
      (if (eq (setq slow (cdr slow)) fast)
	(%err-disp $XIMPROPERLIST l)))))


(defun last (list &optional (n 1))
  "Return the last N conses (not the last element!) of a list."
  (if (and (typep n 'fixnum)
	   (>= (the fixnum n) 0))
    (locally (declare (fixnum n))
      (do* ((checked-list list (cdr checked-list))
	    (returned-list list)
	    (index 0 (1+ index)))
	   ((atom checked-list) returned-list)
	(declare (type fixnum index))
	(if (>= index n)
	  (pop returned-list))))
    (if (and (typep n 'bignum)
	     (> n 0))
      (require-type list 'list)
      (report-bad-arg  n 'unsigned-byte))))





(defun nthcdr (index list)
  "Performs the cdr function n times on a list."
  (setq list (require-type list 'list))
  (if (and (typep index 'fixnum)
	   (>= (the fixnum index) 0))
      (locally (declare (fixnum index))
	(dotimes (i index list)
	  (when (null (setq list (cdr list))) (return))))
      (progn
	(unless (typep index 'unsigned-byte)
	  (report-bad-arg index 'unsigned-byte))
	(do* ((n index (- n target::target-most-positive-fixnum)))
	     ((typep n 'fixnum) (nthcdr n list))
	  (unless (setq list (nthcdr target::target-most-positive-fixnum list))
	    (return))))))


(defun nth (index list)
  "Return the nth object in a list where the car is the zero-th element."
  (car (nthcdr index list)))


(defun nconc (&rest lists)
  (declare (dynamic-extent lists))
  "Concatenates the lists given as arguments (by changing them)"
  (do* ((top lists (cdr top)))
       ((null top) nil)
    (let* ((top-of-top (car top)))
      (cond
       ((consp top-of-top)
        (let* ((result top-of-top)
               (splice result))
          (do* ((elements (cdr top) (cdr elements)))
	         ((endp elements))
            (let ((ele (car elements)))
              (typecase ele
                (cons (rplacd (last splice) ele)
                      (setf splice ele))
                (null (rplacd (last splice) nil))
                (atom (if (cdr elements)
                        (report-bad-arg ele 'list)
                        (rplacd (last splice) ele)))
                (t (report-bad-arg ele 'list)))))
          (return result)))
       ((null top-of-top) nil)
       (t
        (if (cdr top)
          (report-bad-arg top-of-top 'list)
          (return top-of-top)))))))


(defvar %setf-function-names% (make-hash-table :weak t :test 'eq))
(defvar %setf-function-name-inverses% (make-hash-table :weak t :test 'eq))

(defvar *setf-names-lock* (make-lock))
(defun setf-function-name (sym)
  "Returns the uninterned symbol that holds the binding of (SETF sym)"
   (or (gethash sym %setf-function-names%)
       (with-lock-grabbed (*setf-names-lock*)
         (or (gethash sym %setf-function-names%)
             (let* ((setf-function-symbol (construct-setf-function-name sym)))
               (setf (gethash setf-function-symbol %setf-function-name-inverses%) sym
                     (gethash sym %setf-function-names%) setf-function-symbol))))))

(defun existing-setf-function-name (sym)
  (gethash sym %setf-function-names%))

(defun maybe-setf-name (sym)
  (let* ((other (gethash sym %setf-function-name-inverses%)))
    (if other
      `(setf ,other)
      sym)))

                     



(defun construct-setf-function-name (sym)
  (make-symbol (%str-cat "(setf " (symbol-name sym) ")")))

(defun setf-function-name-p (name)
  (and (consp name)
             (consp (%cdr name))
             (null (%cddr name))
             (symbolp (%cadr name))
             (eq (car name) 'setf)))

(defun valid-function-name-p (name)
  (if (symbolp name)                    ; Nil is a valid function name.  I guess.
    (values t name)
    (if (setf-function-name-p name)
      (values t (setf-function-name (%cadr name)))
      ; What other kinds of function names do we care to support ?
      (values nil nil))))

;;; Why isn't this somewhere else ?
(defun ensure-valid-function-name (name)
  (multiple-value-bind (valid-p nm) (valid-function-name-p name)
    (if valid-p nm (error "Invalid function name ~s." name))))


(defun maybe-setf-function-name (name)
  (if (setf-function-name-p name)
    (setf-function-name (cadr name))
    name))


;;; Returns index if char appears in string, else nil.

(defun %str-member (char string &optional start end)
  (let* ((base-string-p (typep string 'simple-base-string)))
    (unless base-string-p
      (setq string (require-type string 'simple-string)))
    (unless (characterp char)
      (setq char (require-type char 'character)))
    (do* ((i (or start 0) (1+ i))
            (n (or end (uvsize string))))
           ((= i n))
        (declare (fixnum i n) (optimize (speed 3) (safety 0)))
        (if (eq (schar (the simple-base-string string) i) char)
          (return i)))))



;;; Returns index of elt in vector, or nil if it's not there.
(defun %vector-member (elt vector)
  (unless (typep vector 'simple-vector)
    (report-bad-arg vector 'simple-vector))
  (dotimes (i (the fixnum (length vector)))
    (when (eq elt (%svref vector i)) (return i))))

(defun logical-pathname-p (thing) (istruct-typep thing 'logical-pathname))

;;; It's back ...
(defun list-nreverse (list)
  (nreconc list nil))

;;; We probably want to make this smarter so that less boxing
;;; (and bignum/double-float consing!) takes place.

(defun vector-nreverse (v)
  (let* ((len (length v))
         (middle (ash (the fixnum len) -1)))
    (declare (fixnum middle len))
    (do* ((left 0 (1+ left))
          (right (1- len) (1- right)))
         ((= left middle) v)
      (declare (fixnum left right))
      (rotatef (aref v left) (aref v right)))))
    
(defun nreverse (seq)
  "Return a sequence of the same elements in reverse order; the argument
   is destroyed."
  (when seq
    (seq-dispatch seq
                  (list-nreverse seq)
                  (vector-nreverse seq))))

(defun nreconc (x y)
  "Return (NCONC (NREVERSE X) Y)."
  (do ((1st (cdr x) (if (endp 1st) 1st (cdr 1st)))
       (2nd x 1st)		;2nd follows first down the list.
       (3rd y 2nd))		;3rd follows 2nd down the list.
      ((atom 2nd) 3rd)
    (rplacd 2nd 3rd)))

;;; The two-arg case is maybe a bit faster.  We -don't- want to
;;; do the two-arg case repeatedly to implement the N-arg case.
(defun append (&rest lists)
  (declare (dynamic-extent lists))
  "Construct a new list by concatenating the list arguments"
  (if lists
    (let* ((head (cons nil nil))
           (tail head))
      (declare (dynamic-extent head)
               (cons head tail))
      (do* ()
           ((null lists) (cdr head))
        (let* ((list (pop lists)))
          (if (null lists)
            (rplacd tail list)
            (dolist (element list)
                (setq tail (cdr (rplacd tail (cons element nil)))))))))))

(defun list-reverse (l)
  (do* ((new ()))
       ((null l) new)
    (push (pop l) new)))

; Again, it's worth putting more work into this when the dust settles.
(defun vector-reverse (v)
  (let* ((len (length v))
         (new (make-array (the fixnum len) :element-type (array-element-type v))))   ; a LOT more work ...
    (declare (fixnum len))
    (do* ((left 0 (1+ left))
          (right (1- len) (1- right)))
         ((= left len) new)
      (declare (fixnum left right))
      (setf (uvref new left)
            (aref v right)))))

(defun reverse (seq)
  "Return a new sequence containing the same elements but in reverse order."
  (seq-dispatch seq (list-reverse seq) (vector-reverse seq)))

(defun check-sequence-bounds (seq start end &optional (length (length seq)))
  (declare (fixnum length))
  (flet ((bad-sequence-interval (seq start end)
           (unless (typep start 'unsigned-byte)
             (report-bad-arg start 'unsigned-byte))
           (if (and end (not (typep end 'unsigned-byte)))
             (report-bad-arg end '(or null unsigned-byte)))
           (error "Bad interval for sequence operation on ~s : start = ~s, end = ~s" seq start end)))
    (if (and (typep start 'fixnum)
             (<= 0 (the fixnum start))
             (if (null end)
               (<= (the fixnum start) (the fixnum (setq end length)))
               (and (typep end 'fixnum)
                    (<= (the fixnum start) (the fixnum end))
                    (<= (the fixnum end) (the fixnum length)))))

      end
      (bad-sequence-interval seq start end))))

  

(defun byte-length (string &optional  (start 0) end)
  (setq end (check-sequence-bounds string start end))
  (- end start))



(defun make-cstring (string)
  (let* ((len (length string)))
    (declare (fixnum len))
    (let* ((s (malloc (the fixnum (1+ len)))))
      (setf (%get-byte s len) 0)
      (multiple-value-bind (data offset) (array-data-and-offset string)
        (dotimes (i len s)
          (setf (%get-unsigned-byte s i) (%scharcode data (+ offset i))))
	s))))

(defun move-string-bytes (source dest off1 off2 n)
  (declare (fixnum off1 off2 n)
           (simple-base-string source dest)
           (optimize (speed 3) (safety 0)))
  (dotimes (i n dest)
    (setf (schar dest off2) (schar source off1))
    (incf off1)
    (incf off2)))


(defun %str-cat (s1 s2 &rest more)
  (declare (dynamic-extent more))
  (require-type s1 'simple-string)
  (require-type s2 'simple-string)
  (let* ((len1 (length s1))
         (len2 (length s2))
         (len (%i+ len2 len1)))
    (declare (optimize (speed 3)(safety 0)))
    (dolist (s more)
      (require-type s 'simple-string)
      (setq len (+ len (length s))))
    (let ((new-string (make-string len :element-type 'base-char)))
      (move-string-bytes s1 new-string 0 0 len1)
      (move-string-bytes s2 new-string 0 len1 len2)
      (dolist (s more)
        (setq len2 (%i+ len1 len2))
        (move-string-bytes s new-string 0 len2 (setq len1 (length s))))
      new-string)))


(defun %substr (str start end)
  (require-type start 'fixnum)
  (require-type end 'fixnum)
  (require-type str 'string)
  (let ((len (length str)))
    (multiple-value-bind (str strb)(array-data-and-offset str)
      (let ((newlen (%i- end start)))
        (when (%i> end len)(error "End ~S exceeds length ~S." end len))
        (when (%i< start 0)(error "Negative start"))
        (let ((new (make-string newlen)))
          (do* ((i 0 (1+ i))
                (pos (%i+ start strb) (1+ pos)))
               ((= i newlen) new)
            (declare (fixnum i pos))
            (setf (schar new i) (schar str pos))))))))



;;; 3 callers
(defun %list-to-uvector (subtype list)   ; subtype may be nil (meaning simple-vector
  (let* ((n (length list))
         (new (%alloc-misc n (or subtype target::subtag-simple-vector))))  ; yech
    (dotimes (i n)
      (declare (fixnum i))
      (uvset new i (%car list))
      (setq list (%cdr list)))
    new))


; appears to be unused
(defun upgraded-array-element-type (type &optional env)
  "Return the element type that will actually be used to implement an array
   with the specifier :ELEMENT-TYPE Spec."
  (declare (ignore env))
  (element-subtype-type (element-type-subtype type)))

(defun upgraded-complex-part-type (type &optional env)
  (let* ((specifier (standardized-type-specifier type env)))
    (when specifier
      (let* ((cspec (if (atom specifier) specifier (car specifier))))
        (if (or (eq cspec 'single-float)
                (eq cspec 'double-float))
          cspec
          'real))))) ; Ok, ok.  So (upgraded-complex-part-type 'bogus) is 'REAL. So ?


#+ppc32-target
(progn
  (defparameter array-element-subtypes
    #(single-float 
      (unsigned-byte 32)
      (signed-byte 32)
      fixnum
      base-char                         ;ucs4
      (unsigned-byte 8)
      (signed-byte 8)
      (unsigned-byte 16)
      (signed-byte 16)
      double-float
      (complex single-float)
      (complex double-float)
      bit))
  
  ;; given uvector subtype - what is the corresponding element-type
  (defun element-subtype-type (subtype)
    (declare (fixnum subtype))
    (if  (= subtype ppc32::subtag-simple-vector) t
        (svref array-element-subtypes 
               (ash (- subtype ppc32::min-cl-ivector-subtag) (- ppc32::ntagbits)))))
  )

#+x8632-target
(progn
  (defparameter array-element-subtypes
    #(single-float 
      (unsigned-byte 32)
      (signed-byte 32)
      fixnum
      base-char                         ;ucs4
      (unsigned-byte 8)
      (signed-byte 8)
      (unsigned-byte 16)
      (signed-byte 16)
      double-float
      (complex single-float)
      (complex double-float)
      bit))
  
  ;; given uvector subtype - what is the corresponding element-type
  (defun element-subtype-type (subtype)
    (declare (fixnum subtype))
    (if  (= subtype x8632::subtag-simple-vector) t
        (svref array-element-subtypes 
               (ash (- subtype x8632::min-cl-ivector-subtag) (- x8632::ntagbits)))))
  )

#+ppc64-target
(progn

(defparameter array-element-subtypes
  #(bogus
    bogus
    bogus
    bogus
    (signed-byte 8)
    (signed-byte 16)
    (signed-byte 32)
    (signed-byte 64)
    (unsigned-byte 8)
    (unsigned-byte 16)
    (unsigned-byte 32)
    (unsigned-byte 64)
    bogus
    (complex double-float)
    single-float
    fixnum
    bogus
    bogus
    bogus
    double-float
    bogus
    bogus
    base-char
    (complex single-float)
    bogus
    bogus
    bogus
    bogus
    bogus
    bit
    bogus
    bogus))  

  
  ;;; given uvector subtype - what is the corresponding element-type
  (defun element-subtype-type (subtype)
    (declare (fixnum subtype))
    (if  (= subtype ppc64::subtag-simple-vector)
      t
      (svref array-element-subtypes 
             (ash (- subtype 128) -2))))
  )

#+x8664-target
(progn

  ;;; other element types
  (defparameter *immheader-0-array-element-types*
    #(bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      (complex double-float)
      (signed-byte 16)
      (unsigned-byte 16)
      bogus
      (signed-byte 8)
      (unsigned-byte 8)
      bit))

  ;;; 32-bit element types
  (defparameter *immheader-1-array-element-types*
    #(bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      base-char
      (signed-byte 32)
      (unsigned-byte 32)
      single-float))

  ;;; 64-bit element types
  (defparameter *immheader-2-array-element-types*
    #(bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      bogus
      (complex single-float)
      fixnum
      (signed-byte 64)
      (unsigned-byte 64)
      double-float))  
      
  
  (defun element-subtype-type (subtype)
    (declare (type (unsigned-byte 8) subtype))
    (if (= subtype x8664::subtag-simple-vector)
      t
      (let* ((class (ash subtype (- x8664::ntagbits)))
             (tag (logand subtype x8664::fulltagmask)))
        (declare (type (unsigned-byte 4) class tag))
        (cond ((= tag x8664::fulltag-immheader-0)
               (%svref *immheader-0-array-element-types* class))
              ((= tag x8664::fulltag-immheader-1)
               (%svref *immheader-1-array-element-types* class))
              ((= tag x8664::fulltag-immheader-2)
               (%svref *immheader-2-array-element-types* class))
              (t 'bogus)))))
  )

#+arm-target
(progn
  (defparameter array-element-subtypes
    #(single-float 
      (unsigned-byte 32)
      (signed-byte 32)
      fixnum
      base-char                         ;ucs4
      (unsigned-byte 8)
      (signed-byte 8)
      (unsigned-byte 16)
      (signed-byte 16)
      double-float
      (complex single-float)
      (complex double-float)
      bit))
  
  ;; given uvector subtype - what is the corresponding element-type
  (defun element-subtype-type (subtype)
    (declare (fixnum subtype))
    (if  (= subtype arm::subtag-simple-vector) t
        (svref array-element-subtypes 
               (ash (- subtype arm::min-cl-ivector-subtag) (- arm::ntagbits)))))
  )


;;; %make-displaced-array assumes the following

(eval-when (:compile-toplevel)
  (assert (eql target::arrayH.flags-cell target::vectorH.flags-cell))
  (assert (eql target::arrayH.displacement-cell target::vectorH.displacement-cell))
  (assert (eql target::arrayH.data-vector-cell target::vectorH.data-vector-cell)))


(defun %make-displaced-array (dimensions displaced-to
                                         &optional fill adjustable
					 offset explicitp)
  (if offset 
    (unless (and (fixnump offset) (>= (the fixnum offset) 0))
      (setq offset (require-type offset '(and fixnum (integer 0 *)))))
    (setq offset 0))
  (locally (declare (fixnum offset))
    (let* ((disp-size (array-total-size displaced-to))
           (rank (if (listp dimensions)(length dimensions) 1))
           (new-size (if (fixnump dimensions)
                       dimensions
                       (if (listp dimensions)
                         (if (eql rank 1)
                           (car dimensions)
                           (if (eql rank 0) 1 ; why not 0?
                           (apply #'* dimensions))))))
           (vect-subtype (typecode displaced-to))
           (target displaced-to)
           (real-offset offset)
           (flags 0))
      (declare (fixnum disp-size rank flags vect-subtype real-offset))
      (when explicitp
	(setq flags (bitset $arh_exp_disp_bit flags)))
      (if (not (fixnump new-size))(error "Bad array dimensions ~s." dimensions)) 
      (locally (declare (fixnum new-size))
        ; (when (> (+ offset new-size) disp-size) ...), but don't cons bignums
        (when (or (> new-size disp-size)
                  (let ((max-offset (- disp-size new-size)))
                    (declare (fixnum max-offset))
                    (> offset max-offset)))
          (%err-disp $err-disp-size displaced-to))
        (if adjustable  (setq flags (bitset $arh_adjp_bit flags)))
        (when fill
          (if (eq fill t)
            (setq fill new-size)
            (unless (and (eql rank 1)
                         (fixnump fill)
                         (locally (declare (fixnum fill))
                           (and (>= fill 0) (<= fill new-size))))
              (error "Bad fill pointer ~s" fill)))
          (setq flags (bitset $arh_fill_bit flags))))
      ; If displaced-to is an array or vector header and is either
      ; adjustable or its target is a header, then we need to set the
      ; $arh_disp_bit. If displaced-to is not adjustable, then our
      ; target can be its target instead of itself.
      (when (or (eql vect-subtype target::subtag-arrayH)
                (eql vect-subtype target::subtag-vectorH))
        (let ((dflags (%svref displaced-to target::arrayH.flags-cell)))
          (declare (fixnum dflags))
          (when (or (logbitp $arh_adjp_bit dflags)
		    t
                    (progn
		      #+nope
                      (setq target (%svref displaced-to target::arrayH.data-vector-cell)
                            real-offset (+ offset (%svref displaced-to target::arrayH.displacement-cell)))
                      (logbitp $arh_disp_bit dflags)
		      #-nope t))
            (setq flags (bitset $arh_disp_bit flags))))
        (setq vect-subtype (%array-header-subtype displaced-to)))
      ; assumes flags is low byte
      (setq flags (dpb vect-subtype target::arrayH.flags-cell-subtag-byte flags))
      (if (eq rank 1)
        (%gvector target::subtag-vectorH 
                      (if (fixnump fill) fill new-size)
                      new-size
                      target
                      real-offset
                      flags)
        (let ((val (%alloc-misc (+ target::arrayh.dim0-cell rank) target::subtag-arrayH)))
          (setf (%svref val target::arrayH.rank-cell) rank)
          (setf (%svref val target::arrayH.physsize-cell) new-size)
          (setf (%svref val target::arrayH.data-vector-cell) target)
          (setf (%svref val target::arrayH.displacement-cell) real-offset)
          (setf (%svref val target::arrayH.flags-cell) flags)
          (do* ((dims dimensions (cdr dims))
                (i 0 (1+ i)))              
               ((null dims))
            (declare (fixnum i)(list dims))
            (setf (%svref val (%i+ target::arrayH.dim0-cell i)) (car dims)))
          val)))))

(defun make-array (dims &key (element-type t element-type-p)
                        displaced-to
                        displaced-index-offset
                        adjustable
                        fill-pointer
                        (initial-element nil initial-element-p)
                        (initial-contents nil initial-contents-p))
  (when (and initial-element-p initial-contents-p)
        (error "Cannot specify both ~S and ~S" :initial-element-p :initial-contents-p))
  (make-array-1 dims element-type element-type-p
                displaced-to
                displaced-index-offset
                adjustable
                fill-pointer
                initial-element initial-element-p
                initial-contents initial-contents-p
                nil))





(defun vector-pop (vector)
  "Decrease the fill pointer by 1 and return the element pointed to by the
  new fill pointer."
  (let* ((fill (fill-pointer vector)))
    (declare (fixnum fill))
    (if (zerop fill)
      (error "Fill pointer of ~S is 0 ." vector)
      (progn
        (decf fill)
        (%set-fill-pointer vector fill)
        (aref vector fill)))))




(defun elt (sequence idx)
  "Return the element of SEQUENCE specified by INDEX."
  (seq-dispatch
   sequence
   (let* ((cell (nthcdr idx sequence)))
     (if (consp cell)
       (car (the cons cell))
       (if cell
         (report-bad-arg sequence '(satisfies proper-list-p))
         (%err-disp $XACCESSNTH idx sequence))))
       
   (progn
     (unless (and (typep idx 'fixnum) (>= (the fixnum idx) 0))
       (report-bad-arg idx 'unsigned-byte))
     (locally 
       (if (>= idx (length sequence))
         (%err-disp $XACCESSNTH idx sequence)
         (aref sequence idx))))))




(defun set-elt (sequence idx value)
  (seq-dispatch
   sequence
   (let* ((cell (nthcdr idx sequence)))
     (if (consp cell)
       (setf (car (the cons cell)) value)
       (if cell
         (report-bad-arg sequence '(satisfies proper-list-p))
         (%err-disp $XACCESSNTH idx sequence))))
   (progn
     (unless (and (typep idx 'fixnum) (>= (the fixnum idx) 0))
       (report-bad-arg idx 'unsigned-byte))
     (locally 
       (declare (fixnum idx))
       (if (>= idx (length sequence))
         (%err-disp $XACCESSNTH idx sequence)
         (setf (aref sequence idx) value))))))




(%fhave 'equalp #'equal)                ; bootstrapping

(defun copy-tree (tree)
  "Recursively copy trees of conses."
  (if (atom tree)
    tree
    (locally (declare (type cons tree))
      (do* ((tail (cdr tree) (cdr tail))
            (result (cons (copy-tree (car tree)) nil))
            (ptr result (cdr ptr)))
           ((atom tail)
            (setf (cdr ptr) tail)
            result)
        (declare (type cons ptr result))
        (locally 
          (declare (type cons tail))
          (setf (cdr ptr) (cons (copy-tree (car tail)) nil)))))))




(defvar *periodic-task-interval* 0.3)
(defvar *periodic-task-seconds* 0)
(defvar *periodic-task-nanoseconds* 300000000)

(defun set-periodic-task-interval (n)
  (multiple-value-setq (*periodic-task-seconds* *periodic-task-nanoseconds*)
    (nanoseconds n))
  (setq *periodic-task-interval* n))

(defun periodic-task-interval ()
  *periodic-task-interval*)



(defun char-downcase (c)
  "Return CHAR converted to lower-case if that is possible."
  (declare (optimize (speed 3))) ; open-code the %CHAR-CODE-DOWNCASE here.
  (code-char (the valid-char-code (%char-code-downcase (char-code c)))))



(defun digit-char-p (char &optional radix)
  "If char is a digit in the specified radix, returns the fixnum for
  which that digit stands, else returns NIL."
  (let* ((code (char-code char))
         (r (if radix (if (and (typep radix 'fixnum)
                               (%i>= radix 2)
                               (%i<= radix 36))
                        radix
                        (%validate-radix radix)) 10))
         (weight (if (and (<= code (char-code #\9))
                          (>= code (char-code #\0)))
                   (the fixnum (- code (char-code #\0)))
                   (if (and (<= code (char-code #\Z))
                            (>= code (char-code #\A)))
                     (the fixnum (+ 10 (the fixnum (- code (char-code #\A)))))
                   (if (and (<= code (char-code #\z))
                            (>= code (char-code #\a)))
                     (the fixnum (+ 10 (the fixnum (- code (char-code #\a))))))))))
    (declare (fixnum code r))
    (and weight (< (the fixnum weight) r) weight)))







(defun string-start-end (string start end)
  (setq string (string string))
  (let ((len (length (the string string))))
    (flet ((are (a i)(error "Array index ~S out of bounds for ~S." i a)))    
      (if (and end (> end len))(are string end))
      (if (and start (or (< start 0)(> start len)))(are string start))
      (setq start (or start 0) end (or end len))
      (if (%i> start end)
        (error "Start ~S exceeds end ~S." start end))
      (if (typep string 'simple-string)
        (values string start end)
        (multiple-value-bind (str off)(array-data-and-offset string)
          (values str (%i+ off start)(%i+ off end)))))))

(defun get-properties (place indicator-list)
  "Like GETF, except that INDICATOR-LIST is a list of indicators which will
  be looked for in the property list stored in PLACE. Three values are
  returned, see manual for details."
  (do ((plist place (cddr plist)))
      ((null plist) (values nil nil nil))
    (cond ((atom (cdr plist))
	   (report-bad-arg place '(satisfies proper-list-p)))
	  ((memq (car plist) indicator-list) ;memq defined in kernel
	   (return (values (car plist) (cadr plist) plist))))))

(defun string= (string1 string2 &key start1 end1 start2 end2)
  "Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char=)."
    (locally (declare (optimize (speed 3)(safety 0)))
      (if (and (simple-string-p string1)(null start1)(null end1))
        (setq start1 0 end1 (length string1))
        (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))
      (if (and (simple-string-p string2)(null start2)(null end2))
        (setq start2 0 end2 (length string2))
        (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))    
      (%simple-string= string1 string2 start1 start2 end1 end2)))


(defun lfun-keyvect (lfun)
  (let ((bits (lfun-bits lfun)))
    (declare (fixnum bits))
    (and (logbitp $lfbits-keys-bit bits)
         (or (logbitp $lfbits-method-bit bits)
             (and (not (logbitp $lfbits-gfn-bit bits))
                  (not (logbitp $lfbits-cm-bit bits))))
	 (nth-immediate lfun 1))))


(defun function-entry-code-note (fn)
  (let ((bits (lfun-bits (setq fn (require-type fn 'function)))))
    (declare (fixnum bits))
    (and (logbitp $lfbits-code-coverage-bit bits)
	 (loop for i upfrom 1 as imm = (nth-immediate fn i)
	       when (code-note-p imm) do (return imm)))))


(defun function-lambda-expression (fn)
  "Return (VALUES DEFINING-LAMBDA-EXPRESSION CLOSURE-P NAME), where
  DEFINING-LAMBDA-EXPRESSION is NIL if unknown, or a suitable argument
  to COMPILE otherwise, CLOSURE-P is non-NIL if the function's definition
  might have been enclosed in some non-null lexical environment, and
  NAME is some name (for debugging only) or NIL if there is no name."
  ;(declare (values def env-p name))
  (let* ((bits (lfun-bits (setq fn (require-type fn 'function)))))
    (declare (fixnum bits))
    (if (logbitp $lfbits-trampoline-bit bits)
      (function-lambda-expression (nth-immediate fn 1))
      (values (uncompile-function fn)
              (logbitp $lfbits-nonnullenv-bit bits)
              (function-name fn)))))

; env must be a lexical-environment or NIL.
; If env contains function or variable bindings or SPECIAL declarations, return t.
; Else return nil
(defun %non-empty-environment-p (env)
  (loop
    (when (or (null env) (istruct-typep env 'definition-environment))
      (return nil))
    (when (or (consp (lexenv.variables env))
              (consp (lexenv.functions env))
              (dolist (vdecl (lexenv.vdecls env))
                (when (eq (cadr vdecl) 'special)
                  (return t))))
      (return t))
    (setq env (lexenv.parent-env env))))

;(coerce object 'compiled-function)
(defun coerce-to-compiled-function (object)
  (setq object (coerce-to-function object))
  (unless (typep object 'compiled-function)
    (multiple-value-bind (def envp) (function-lambda-expression object)
      (when (or envp (null def))
        (%err-disp $xcoerce object 'compiled-function))
      (setq object (compile-user-function def nil))))
  object)



(defun %set-toplevel (&optional (fun nil fun-p))
  ;(setq fun (require-type fun '(or symbol function)))
  (let* ((tcr (%current-tcr)))
    (prog1 (%tcr-toplevel-function tcr)
      (when fun-p
	(%set-tcr-toplevel-function tcr fun)))))


(defun gccounts ()
  (let* ((total (%get-gc-count))
         (full (full-gccount))
         (g2-count 0)
         (g1-count 0)
         (g0-count 0))
    (when (egc-enabled-p)
      (let* ((a (%active-dynamic-area)))
        (setq g0-count (%fixnum-ref a target::area.gc-count) a (%fixnum-ref a target::area.older))
        (setq g1-count (%fixnum-ref a target::area.gc-count) a (%fixnum-ref a target::area.older))
        (setq g2-count (%fixnum-ref a target::area.gc-count))))
    (values total full g2-count g1-count g0-count)))

      



(defstatic %pascal-functions%
    #(NIL NIL NIL NIL NIL NIL NIL NIL
      NIL NIL NIL NIL NIL NIL NIL NIL
      NIL NIL NIL NIL NIL NIL NIL NIL
      NIL NIL NIL NIL NIL NIL NIL NIL))


(defun gc-retain-pages (arg)
  "Try to influence the GC to retain/recycle the pages allocated between
GCs if arg is true, and to release them otherwise. This is generally a
gtradeoff between paging and other VM considerations."
  (setq *gc-event-status-bits*
        (if arg
          (bitset $gc-retain-pages-bit *gc-event-status-bits*)
          (bitclr $gc-retain-pages-bit *gc-event-status-bits*)))
  (not (null arg)))

(defun gc-retaining-pages ()
  "Return T if the GC tries to retain pages between full GCs and NIL if
it's trying to release them to improve VM paging performance."
  (logbitp $gc-retain-pages-bit *gc-event-status-bits*))  


(defun gc-verbose (on-full-gc &optional (egc-too on-full-gc))
  "If the first (required) argument is non-NIL, configures the GC to print
informational messages on entry and exit to each full GC; if the first argument
is NIL, suppresses those messages.  The second (optional) argument controls printing of messages on entry and exit to an ephemeral GC.  Returns values as per GC-VERBOSE-P."
  (let* ((bits *gc-event-status-bits*))
    (if on-full-gc
      (bitsetf $gc-verbose-bit bits)
      (bitclrf $gc-verbose-bit bits))
    (if egc-too
      (bitsetf $egc-verbose-bit bits)
      (bitclrf $egc-verbose-bit bits))
    (setq *gc-event-status-bits* bits)
    (values on-full-gc egc-too)))


(defun gc-verbose-p ()
  "Returns two values: the first is true if the GC is configured to
print messages on each full GC; the second is true if the GC is configured
to print messages on each ephemeral GC."
  (let* ((bits *gc-event-status-bits*))
    (values (logbitp $gc-verbose-bit bits)
            (logbitp $egc-verbose-bit bits))))

(defun egc-active-p ()
  "Return T if the EGC was active at the time of the call, NIL otherwise.
Since this is generally a volatile piece of information, it's not clear
whether this function serves a useful purpose when native threads are
involved."
  (and (egc-enabled-p)
       (not (eql 0 (%get-kernel-global 'oldest-ephemeral)))))

; this IS effectively a passive way of inquiring about enabled status.
(defun egc-enabled-p ()
  "Return T if the EGC was enabled at the time of the call, NIL otherwise."
  (not (eql 0 (%fixnum-ref (%active-dynamic-area) target::area.older))))

(defun egc-configuration ()
  "Return as multiple values the sizes in kilobytes of the thresholds
associated with the youngest ephemeral generation, the middle ephemeral
generation, and the oldest ephemeral generation."
  (let* ((ta (%get-kernel-global 'tenured-area))
         (g2 (%fixnum-ref ta target::area.younger))
         (g1 (%fixnum-ref g2 target::area.younger))
         (g0 (%fixnum-ref g1 target::area.younger)))
    (values (ash (the fixnum (%fixnum-ref g0 target::area.threshold)) (- (- 10 target::fixnum-shift)))
            (ash (the fixnum (%fixnum-ref g1 target::area.threshold)) (- (- 10 target::fixnum-shift)))
            (ash (the fixnum (%fixnum-ref g2 target::area.threshold)) (- (- 10 target::fixnum-shift))))))


(defun configure-egc (e0size e1size e2size)
  "If the EGC is currently disabled, put the indicated threshold sizes in
effect and returns T, otherwise, returns NIL.  The provided threshold sizes
are rounded up to a multiple of 64Kbytes."
  (let* ((was-enabled (egc-active-p))
         (e2size (require-type e2size '(unsigned-byte 18)))
         (e1size (require-type e1size '(unsigned-byte 18)))
         (e0size (require-type e0size '(integer 1 #.(ash 1 18)))))
    (unless (<= e0size e1size e2size)
      (error "Generation ~s threshold cannot be smaller than generation ~s threshold"
             (if (> e0size e1size) 1 2) (if (> e0size e1size) 0 1)))
    (unwind-protect
         (progn
           (egc nil)
           (setq e2size (logand (lognot #xffff) (+ #xffff (ash e2size 10)))
                 e1size (logand (lognot #xffff) (+ #xffff (ash e1size 10)))
                 e0size (logand (lognot #xffff) (+ #xffff (ash e0size 10))))
           (%configure-egc e0size e1size e2size))
      (egc was-enabled))))



(defun macptr-flags (macptr)
  (if (eql (uvsize (setq macptr (require-type macptr 'macptr))) 1)
    0
    (uvref macptr TARGET::XMACPTR.FLAGS-CELL)))


; This doesn't really make the macptr be gcable (now has to be
; on linked list), but we might have other reasons for setting
; other flag bits.
(defun set-macptr-flags (macptr value) 
  (unless (eql (uvsize (setq macptr (require-type macptr 'macptr))) 1)
    (setf (%svref macptr TARGET::XMACPTR.FLAGS-CELL) value)
    value))

(defun %new-gcable-ptr (size &optional clear-p)
  (let ((p (make-gcable-macptr $flags_DisposPtr)))
    (%setf-macptr p (malloc size))
    (if clear-p
      (#_memset p 0 size))
    p))

(defun %gcable-ptr-p (p)
  (and (typep p 'macptr)
       (= (uvsize p) target::xmacptr.element-count)))

(defstatic *upper-to-lower* nil)
(defstatic *lower-to-upper*  nil)

;;; "address" should be the address (as returned by FOREIGN-SYMBOL-ADDRESS)
;;; of a foreign function that accepts a pointer as an argument and does
;;; whatever's needed to dispose of it.  That function can be called from
;;; the GC, so it shouldn't call back into lisp.
(defun register-xmacptr-dispose-function (address)
  (ff-call (%kernel-import target::kernel-import-register-xmacptr-dispose-function)
           :address address
           :int))


;;; This alist is automatically (and not too cleverly ...) generated.
;;;
;;; NB: it was generated from Unicode 5.0 character tables, check to
;;; see if anything's changed in 5.1 or later versions.
;;;
;;; The (upper . lower) pairs have the property that UPPER is the
;;; value "simple uppercase equivalent" entry for LOWER in the
;;; UnicodeData.txt file and LOWER is the corresponding entry for
;;; UPPER,
(let* ((mapping
        '((#\Latin_Capital_Letter_A_With_Grave . #\Latin_Small_Letter_A_With_Grave)
          (#\Latin_Capital_Letter_A_With_Acute . #\Latin_Small_Letter_A_With_Acute)
          (#\Latin_Capital_Letter_A_With_Circumflex
           . #\Latin_Small_Letter_A_With_Circumflex)
          (#\Latin_Capital_Letter_A_With_Tilde . #\Latin_Small_Letter_A_With_Tilde)
          (#\Latin_Capital_Letter_A_With_Diaeresis
           . #\Latin_Small_Letter_A_With_Diaeresis)
          (#\Latin_Capital_Letter_A_With_Ring_Above
           . #\Latin_Small_Letter_A_With_Ring_Above)
          
          (#\Latin_Capital_Letter_Ae . #\Latin_Small_Letter_Ae)
          
          (#\Latin_Capital_Letter_C_With_Cedilla . #\Latin_Small_Letter_C_With_Cedilla)
          
          (#\Latin_Capital_Letter_E_With_Grave . #\Latin_Small_Letter_E_With_Grave)
          
          (#\Latin_Capital_Letter_E_With_Acute . #\Latin_Small_Letter_E_With_Acute)
          
          (#\Latin_Capital_Letter_E_With_Circumflex
           . #\Latin_Small_Letter_E_With_Circumflex)
          
          (#\Latin_Capital_Letter_E_With_Diaeresis
           . #\Latin_Small_Letter_E_With_Diaeresis)
          
          (#\Latin_Capital_Letter_I_With_Grave . #\Latin_Small_Letter_I_With_Grave)
          
          (#\Latin_Capital_Letter_I_With_Acute . #\Latin_Small_Letter_I_With_Acute)
          
          (#\Latin_Capital_Letter_I_With_Circumflex
           . #\Latin_Small_Letter_I_With_Circumflex)
          
          (#\Latin_Capital_Letter_I_With_Diaeresis
           . #\Latin_Small_Letter_I_With_Diaeresis)
          
          (#\Latin_Capital_Letter_Eth . #\Latin_Small_Letter_Eth)
          
          (#\Latin_Capital_Letter_N_With_Tilde . #\Latin_Small_Letter_N_With_Tilde)
          
          (#\Latin_Capital_Letter_O_With_Grave . #\Latin_Small_Letter_O_With_Grave)
          
          (#\Latin_Capital_Letter_O_With_Acute . #\Latin_Small_Letter_O_With_Acute)
          
          (#\Latin_Capital_Letter_O_With_Circumflex
           . #\Latin_Small_Letter_O_With_Circumflex)
          
          (#\Latin_Capital_Letter_O_With_Tilde . #\Latin_Small_Letter_O_With_Tilde)
          
          (#\Latin_Capital_Letter_O_With_Diaeresis
           . #\Latin_Small_Letter_O_With_Diaeresis)
          
          (#\Latin_Capital_Letter_O_With_Stroke . #\Latin_Small_Letter_O_With_Stroke)
          
          (#\Latin_Capital_Letter_U_With_Grave . #\Latin_Small_Letter_U_With_Grave)
          
          (#\Latin_Capital_Letter_U_With_Acute . #\Latin_Small_Letter_U_With_Acute)
          
          (#\Latin_Capital_Letter_U_With_Circumflex
           . #\Latin_Small_Letter_U_With_Circumflex)
          
          (#\Latin_Capital_Letter_U_With_Diaeresis
           . #\Latin_Small_Letter_U_With_Diaeresis)
          
          (#\Latin_Capital_Letter_Y_With_Acute . #\Latin_Small_Letter_Y_With_Acute)
          
          (#\Latin_Capital_Letter_Thorn . #\Latin_Small_Letter_Thorn)
          
          (#\Latin_Capital_Letter_A_With_Macron . #\Latin_Small_Letter_A_With_Macron)
          
          (#\Latin_Capital_Letter_A_With_Breve . #\Latin_Small_Letter_A_With_Breve)
          
          (#\Latin_Capital_Letter_A_With_Ogonek . #\Latin_Small_Letter_A_With_Ogonek)
          
          (#\Latin_Capital_Letter_C_With_Acute . #\Latin_Small_Letter_C_With_Acute)
          
          (#\Latin_Capital_Letter_C_With_Circumflex
           . #\Latin_Small_Letter_C_With_Circumflex)
          
          (#\Latin_Capital_Letter_C_With_Dot_Above
           . #\Latin_Small_Letter_C_With_Dot_Above)
          
          (#\Latin_Capital_Letter_C_With_Caron . #\Latin_Small_Letter_C_With_Caron)
          
          (#\Latin_Capital_Letter_D_With_Caron . #\Latin_Small_Letter_D_With_Caron)
          
          (#\Latin_Capital_Letter_D_With_Stroke . #\Latin_Small_Letter_D_With_Stroke)
          
          (#\Latin_Capital_Letter_E_With_Macron . #\Latin_Small_Letter_E_With_Macron)
          
          (#\Latin_Capital_Letter_E_With_Breve . #\Latin_Small_Letter_E_With_Breve)
          
          (#\Latin_Capital_Letter_E_With_Dot_Above
           . #\Latin_Small_Letter_E_With_Dot_Above)
          
          (#\Latin_Capital_Letter_E_With_Ogonek . #\Latin_Small_Letter_E_With_Ogonek)
          
          (#\Latin_Capital_Letter_E_With_Caron . #\Latin_Small_Letter_E_With_Caron)
          
          (#\Latin_Capital_Letter_G_With_Circumflex
           . #\Latin_Small_Letter_G_With_Circumflex)
          
          (#\Latin_Capital_Letter_G_With_Breve . #\Latin_Small_Letter_G_With_Breve)
          
          (#\Latin_Capital_Letter_G_With_Dot_Above
           . #\Latin_Small_Letter_G_With_Dot_Above)
          
          (#\Latin_Capital_Letter_G_With_Cedilla . #\Latin_Small_Letter_G_With_Cedilla)
          
          (#\Latin_Capital_Letter_H_With_Circumflex
           . #\Latin_Small_Letter_H_With_Circumflex)
          
          (#\Latin_Capital_Letter_H_With_Stroke . #\Latin_Small_Letter_H_With_Stroke)
          
          (#\Latin_Capital_Letter_I_With_Tilde . #\Latin_Small_Letter_I_With_Tilde)
          
          (#\Latin_Capital_Letter_I_With_Macron . #\Latin_Small_Letter_I_With_Macron)
          
          (#\Latin_Capital_Letter_I_With_Breve . #\Latin_Small_Letter_I_With_Breve)
          
          (#\Latin_Capital_Letter_I_With_Ogonek . #\Latin_Small_Letter_I_With_Ogonek)
          
          (#\Latin_Capital_Ligature_Ij . #\Latin_Small_Ligature_Ij)
          
          (#\Latin_Capital_Letter_J_With_Circumflex
           . #\Latin_Small_Letter_J_With_Circumflex)
          
          (#\Latin_Capital_Letter_K_With_Cedilla . #\Latin_Small_Letter_K_With_Cedilla)
          
          (#\Latin_Capital_Letter_L_With_Acute . #\Latin_Small_Letter_L_With_Acute)
          
          (#\Latin_Capital_Letter_L_With_Cedilla . #\Latin_Small_Letter_L_With_Cedilla)
          
          (#\Latin_Capital_Letter_L_With_Caron . #\Latin_Small_Letter_L_With_Caron)
          
          (#\Latin_Capital_Letter_L_With_Middle_Dot
           . #\Latin_Small_Letter_L_With_Middle_Dot)
          
          (#\Latin_Capital_Letter_L_With_Stroke . #\Latin_Small_Letter_L_With_Stroke)
          
          (#\Latin_Capital_Letter_N_With_Acute . #\Latin_Small_Letter_N_With_Acute)
          
          (#\Latin_Capital_Letter_N_With_Cedilla . #\Latin_Small_Letter_N_With_Cedilla)
          
          (#\Latin_Capital_Letter_N_With_Caron . #\Latin_Small_Letter_N_With_Caron)
          
          (#\Latin_Capital_Letter_Eng . #\Latin_Small_Letter_Eng)
          
          (#\Latin_Capital_Letter_O_With_Macron . #\Latin_Small_Letter_O_With_Macron)
          
          (#\Latin_Capital_Letter_O_With_Breve . #\Latin_Small_Letter_O_With_Breve)
          
          (#\Latin_Capital_Letter_O_With_Double_Acute
           . #\Latin_Small_Letter_O_With_Double_Acute)
          
          (#\Latin_Capital_Ligature_Oe . #\Latin_Small_Ligature_Oe)
          
          (#\Latin_Capital_Letter_R_With_Acute . #\Latin_Small_Letter_R_With_Acute)
          
          (#\Latin_Capital_Letter_R_With_Cedilla . #\Latin_Small_Letter_R_With_Cedilla)
          
          (#\Latin_Capital_Letter_R_With_Caron . #\Latin_Small_Letter_R_With_Caron)
          
          (#\Latin_Capital_Letter_S_With_Acute . #\Latin_Small_Letter_S_With_Acute)
          
          (#\Latin_Capital_Letter_S_With_Circumflex
           . #\Latin_Small_Letter_S_With_Circumflex)
          
          (#\Latin_Capital_Letter_S_With_Cedilla . #\Latin_Small_Letter_S_With_Cedilla)
          
          (#\Latin_Capital_Letter_S_With_Caron . #\Latin_Small_Letter_S_With_Caron)
          
          (#\Latin_Capital_Letter_T_With_Cedilla . #\Latin_Small_Letter_T_With_Cedilla)
          
          (#\Latin_Capital_Letter_T_With_Caron . #\Latin_Small_Letter_T_With_Caron)
          
          (#\Latin_Capital_Letter_T_With_Stroke . #\Latin_Small_Letter_T_With_Stroke)
          
          (#\Latin_Capital_Letter_U_With_Tilde . #\Latin_Small_Letter_U_With_Tilde)
          
          (#\Latin_Capital_Letter_U_With_Macron . #\Latin_Small_Letter_U_With_Macron)
          
          (#\Latin_Capital_Letter_U_With_Breve . #\Latin_Small_Letter_U_With_Breve)
          
          (#\Latin_Capital_Letter_U_With_Ring_Above
           . #\Latin_Small_Letter_U_With_Ring_Above)
          
          (#\Latin_Capital_Letter_U_With_Double_Acute
           . #\Latin_Small_Letter_U_With_Double_Acute)
          
          (#\Latin_Capital_Letter_U_With_Ogonek . #\Latin_Small_Letter_U_With_Ogonek)
          
          (#\Latin_Capital_Letter_W_With_Circumflex
           . #\Latin_Small_Letter_W_With_Circumflex)
          
          (#\Latin_Capital_Letter_Y_With_Circumflex
           . #\Latin_Small_Letter_Y_With_Circumflex)
          
          (#\Latin_Capital_Letter_Y_With_Diaeresis
           . #\Latin_Small_Letter_Y_With_Diaeresis)
          
          (#\Latin_Capital_Letter_Z_With_Acute . #\Latin_Small_Letter_Z_With_Acute)
          
          (#\Latin_Capital_Letter_Z_With_Dot_Above
           . #\Latin_Small_Letter_Z_With_Dot_Above)
          
          (#\Latin_Capital_Letter_Z_With_Caron . #\Latin_Small_Letter_Z_With_Caron)
          
          (#\Latin_Capital_Letter_B_With_Hook . #\Latin_Small_Letter_B_With_Hook)
          
          (#\Latin_Capital_Letter_B_With_Topbar . #\Latin_Small_Letter_B_With_Topbar)
          
          (#\Latin_Capital_Letter_Tone_Six . #\Latin_Small_Letter_Tone_Six)
          
          (#\Latin_Capital_Letter_Open_O . #\Latin_Small_Letter_Open_O)
          
          (#\Latin_Capital_Letter_C_With_Hook . #\Latin_Small_Letter_C_With_Hook)
          
          (#\Latin_Capital_Letter_African_D . #\Latin_Small_Letter_D_With_Tail)
          
          (#\Latin_Capital_Letter_D_With_Hook . #\Latin_Small_Letter_D_With_Hook)
          
          (#\Latin_Capital_Letter_D_With_Topbar . #\Latin_Small_Letter_D_With_Topbar)
          
          (#\Latin_Capital_Letter_Reversed_E . #\Latin_Small_Letter_Turned_E)
          
          (#\Latin_Capital_Letter_Schwa . #\Latin_Small_Letter_Schwa)
          
          (#\Latin_Capital_Letter_Open_E . #\Latin_Small_Letter_Open_E)
          
          (#\Latin_Capital_Letter_F_With_Hook . #\Latin_Small_Letter_F_With_Hook)
          
          (#\Latin_Capital_Letter_G_With_Hook . #\Latin_Small_Letter_G_With_Hook)
          
          (#\Latin_Capital_Letter_Gamma . #\Latin_Small_Letter_Gamma)
          
          (#\Latin_Capital_Letter_Iota . #\Latin_Small_Letter_Iota)
          
          (#\Latin_Capital_Letter_I_With_Stroke . #\Latin_Small_Letter_I_With_Stroke)
          
          (#\Latin_Capital_Letter_K_With_Hook . #\Latin_Small_Letter_K_With_Hook)
          
          (#\Latin_Capital_Letter_Turned_M . #\Latin_Small_Letter_Turned_M)
          
          (#\Latin_Capital_Letter_N_With_Left_Hook
           . #\Latin_Small_Letter_N_With_Left_Hook)
          
          (#\Latin_Capital_Letter_O_With_Middle_Tilde . #\Latin_Small_Letter_Barred_O)
          
          (#\Latin_Capital_Letter_O_With_Horn . #\Latin_Small_Letter_O_With_Horn)
          
          (#\Latin_Capital_Letter_Oi . #\Latin_Small_Letter_Oi)
          
          (#\Latin_Capital_Letter_P_With_Hook . #\Latin_Small_Letter_P_With_Hook)
          
          (#\Latin_Letter_Yr . #\Latin_Letter_Small_Capital_R)
          
          (#\Latin_Capital_Letter_Tone_Two . #\Latin_Small_Letter_Tone_Two)
          
          (#\Latin_Capital_Letter_Esh . #\Latin_Small_Letter_Esh)
          
          (#\Latin_Capital_Letter_T_With_Hook . #\Latin_Small_Letter_T_With_Hook)
          
          (#\Latin_Capital_Letter_T_With_Retroflex_Hook
           . #\Latin_Small_Letter_T_With_Retroflex_Hook)
          
          (#\Latin_Capital_Letter_U_With_Horn . #\Latin_Small_Letter_U_With_Horn)
          
          (#\Latin_Capital_Letter_Upsilon . #\Latin_Small_Letter_Upsilon)
          
          (#\Latin_Capital_Letter_V_With_Hook . #\Latin_Small_Letter_V_With_Hook)
          
          (#\Latin_Capital_Letter_Y_With_Hook . #\Latin_Small_Letter_Y_With_Hook)
          
          (#\Latin_Capital_Letter_Z_With_Stroke . #\Latin_Small_Letter_Z_With_Stroke)
          
          (#\Latin_Capital_Letter_Ezh . #\Latin_Small_Letter_Ezh)
          
          (#\Latin_Capital_Letter_Ezh_Reversed . #\Latin_Small_Letter_Ezh_Reversed)
          
          (#\Latin_Capital_Letter_Tone_Five . #\Latin_Small_Letter_Tone_Five)
          
          (#\Latin_Capital_Letter_Dz_With_Caron . #\Latin_Small_Letter_Dz_With_Caron)
          
          (#\Latin_Capital_Letter_Lj . #\Latin_Small_Letter_Lj)
          
          (#\Latin_Capital_Letter_Nj . #\Latin_Small_Letter_Nj)
          
          (#\Latin_Capital_Letter_A_With_Caron . #\Latin_Small_Letter_A_With_Caron)
          
          (#\Latin_Capital_Letter_I_With_Caron . #\Latin_Small_Letter_I_With_Caron)
          
          (#\Latin_Capital_Letter_O_With_Caron . #\Latin_Small_Letter_O_With_Caron)
          
          (#\Latin_Capital_Letter_U_With_Caron . #\Latin_Small_Letter_U_With_Caron)
          
          (#\Latin_Capital_Letter_U_With_Diaeresis_And_Macron
           . #\Latin_Small_Letter_U_With_Diaeresis_And_Macron)
          
          (#\Latin_Capital_Letter_U_With_Diaeresis_And_Acute
           . #\Latin_Small_Letter_U_With_Diaeresis_And_Acute)
          
          (#\Latin_Capital_Letter_U_With_Diaeresis_And_Caron
           . #\Latin_Small_Letter_U_With_Diaeresis_And_Caron)
          
          (#\Latin_Capital_Letter_U_With_Diaeresis_And_Grave
           . #\Latin_Small_Letter_U_With_Diaeresis_And_Grave)
          
          (#\Latin_Capital_Letter_A_With_Diaeresis_And_Macron
           . #\Latin_Small_Letter_A_With_Diaeresis_And_Macron)
          
          (#\Latin_Capital_Letter_A_With_Dot_Above_And_Macron
           . #\Latin_Small_Letter_A_With_Dot_Above_And_Macron)
          
          (#\Latin_Capital_Letter_Ae_With_Macron . #\Latin_Small_Letter_Ae_With_Macron)
          
          (#\Latin_Capital_Letter_G_With_Stroke . #\Latin_Small_Letter_G_With_Stroke)
          
          (#\Latin_Capital_Letter_G_With_Caron . #\Latin_Small_Letter_G_With_Caron)
          
          (#\Latin_Capital_Letter_K_With_Caron . #\Latin_Small_Letter_K_With_Caron)
          
          (#\Latin_Capital_Letter_O_With_Ogonek . #\Latin_Small_Letter_O_With_Ogonek)
          
          (#\Latin_Capital_Letter_O_With_Ogonek_And_Macron
           . #\Latin_Small_Letter_O_With_Ogonek_And_Macron)
          
          (#\Latin_Capital_Letter_Ezh_With_Caron . #\Latin_Small_Letter_Ezh_With_Caron)
          
          (#\Latin_Capital_Letter_Dz . #\Latin_Small_Letter_Dz)
          
          (#\Latin_Capital_Letter_G_With_Acute . #\Latin_Small_Letter_G_With_Acute)
          
          (#\Latin_Capital_Letter_Hwair . #\Latin_Small_Letter_Hv)
          
          (#\Latin_Capital_Letter_Wynn . #\Latin_Letter_Wynn)
          
          (#\Latin_Capital_Letter_N_With_Grave . #\Latin_Small_Letter_N_With_Grave)
          
          (#\Latin_Capital_Letter_A_With_Ring_Above_And_Acute
           . #\Latin_Small_Letter_A_With_Ring_Above_And_Acute)
          
          (#\Latin_Capital_Letter_Ae_With_Acute . #\Latin_Small_Letter_Ae_With_Acute)
          
          (#\Latin_Capital_Letter_O_With_Stroke_And_Acute
           . #\Latin_Small_Letter_O_With_Stroke_And_Acute)
          
          (#\Latin_Capital_Letter_A_With_Double_Grave
           . #\Latin_Small_Letter_A_With_Double_Grave)
          
          (#\Latin_Capital_Letter_A_With_Inverted_Breve
           . #\Latin_Small_Letter_A_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_E_With_Double_Grave
           . #\Latin_Small_Letter_E_With_Double_Grave)
          
          (#\Latin_Capital_Letter_E_With_Inverted_Breve
           . #\Latin_Small_Letter_E_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_I_With_Double_Grave
           . #\Latin_Small_Letter_I_With_Double_Grave)
          
          (#\Latin_Capital_Letter_I_With_Inverted_Breve
           . #\Latin_Small_Letter_I_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_O_With_Double_Grave
           . #\Latin_Small_Letter_O_With_Double_Grave)
          
          (#\Latin_Capital_Letter_O_With_Inverted_Breve
           . #\Latin_Small_Letter_O_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_R_With_Double_Grave
           . #\Latin_Small_Letter_R_With_Double_Grave)
          
          (#\Latin_Capital_Letter_R_With_Inverted_Breve
           . #\Latin_Small_Letter_R_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_U_With_Double_Grave
           . #\Latin_Small_Letter_U_With_Double_Grave)
          
          (#\Latin_Capital_Letter_U_With_Inverted_Breve
           . #\Latin_Small_Letter_U_With_Inverted_Breve)
          
          (#\Latin_Capital_Letter_S_With_Comma_Below
           . #\Latin_Small_Letter_S_With_Comma_Below)
          
          (#\Latin_Capital_Letter_T_With_Comma_Below
           . #\Latin_Small_Letter_T_With_Comma_Below)
          
          (#\Latin_Capital_Letter_Yogh . #\Latin_Small_Letter_Yogh)
          
          (#\Latin_Capital_Letter_H_With_Caron . #\Latin_Small_Letter_H_With_Caron)
          
          (#\Latin_Capital_Letter_N_With_Long_Right_Leg
           . #\Latin_Small_Letter_N_With_Long_Right_Leg)
          
          (#\Latin_Capital_Letter_Ou . #\Latin_Small_Letter_Ou)
          
          (#\Latin_Capital_Letter_Z_With_Hook . #\Latin_Small_Letter_Z_With_Hook)
          
          (#\Latin_Capital_Letter_A_With_Dot_Above
           . #\Latin_Small_Letter_A_With_Dot_Above)
          
          (#\Latin_Capital_Letter_E_With_Cedilla . #\Latin_Small_Letter_E_With_Cedilla)
          
          (#\Latin_Capital_Letter_O_With_Diaeresis_And_Macron
           . #\Latin_Small_Letter_O_With_Diaeresis_And_Macron)
          
          (#\Latin_Capital_Letter_O_With_Tilde_And_Macron
           . #\Latin_Small_Letter_O_With_Tilde_And_Macron)
          
          (#\Latin_Capital_Letter_O_With_Dot_Above
           . #\Latin_Small_Letter_O_With_Dot_Above)
          
          (#\Latin_Capital_Letter_O_With_Dot_Above_And_Macron
           . #\Latin_Small_Letter_O_With_Dot_Above_And_Macron)
          
          (#\Latin_Capital_Letter_Y_With_Macron . #\Latin_Small_Letter_Y_With_Macron)
          
          (#\Latin_Capital_Letter_A_With_Stroke . #\U+2C65)
          
          (#\Latin_Capital_Letter_C_With_Stroke . #\Latin_Small_Letter_C_With_Stroke)
          
          (#\Latin_Capital_Letter_L_With_Bar . #\Latin_Small_Letter_L_With_Bar)
          
          (#\Latin_Capital_Letter_T_With_Diagonal_Stroke . #\U+2C66)
          
          (#\Latin_Capital_Letter_Glottal_Stop . #\Latin_Small_Letter_Glottal_Stop)
          
          (#\Latin_Capital_Letter_B_With_Stroke . #\Latin_Small_Letter_B_With_Stroke)
          
          (#\Latin_Capital_Letter_U_Bar . #\Latin_Small_Letter_U_Bar)
          
          (#\Latin_Capital_Letter_Turned_V . #\Latin_Small_Letter_Turned_V)
          
          (#\Latin_Capital_Letter_E_With_Stroke . #\Latin_Small_Letter_E_With_Stroke)
          
          (#\Latin_Capital_Letter_J_With_Stroke . #\Latin_Small_Letter_J_With_Stroke)
          
          (#\Latin_Capital_Letter_Small_Q_With_Hook_Tail
           . #\Latin_Small_Letter_Q_With_Hook_Tail)
          
          (#\Latin_Capital_Letter_R_With_Stroke . #\Latin_Small_Letter_R_With_Stroke)
          
          (#\Latin_Capital_Letter_Y_With_Stroke . #\Latin_Small_Letter_Y_With_Stroke)
          
          (#\Greek_Capital_Letter_Alpha_With_Tonos
           . #\Greek_Small_Letter_Alpha_With_Tonos)
          
          (#\Greek_Capital_Letter_Epsilon_With_Tonos
           . #\Greek_Small_Letter_Epsilon_With_Tonos)
          
          (#\Greek_Capital_Letter_Eta_With_Tonos . #\Greek_Small_Letter_Eta_With_Tonos)
          
          (#\Greek_Capital_Letter_Iota_With_Tonos
           . #\Greek_Small_Letter_Iota_With_Tonos)
          
          (#\Greek_Capital_Letter_Omicron_With_Tonos
           . #\Greek_Small_Letter_Omicron_With_Tonos)
          
          (#\Greek_Capital_Letter_Upsilon_With_Tonos
           . #\Greek_Small_Letter_Upsilon_With_Tonos)
          
          (#\Greek_Capital_Letter_Omega_With_Tonos
           . #\Greek_Small_Letter_Omega_With_Tonos)
          
          (#\Greek_Capital_Letter_Alpha . #\Greek_Small_Letter_Alpha)
          
          (#\Greek_Capital_Letter_Beta . #\Greek_Small_Letter_Beta)
          
          (#\Greek_Capital_Letter_Gamma . #\Greek_Small_Letter_Gamma)
          
          (#\Greek_Capital_Letter_Delta . #\Greek_Small_Letter_Delta)
          
          (#\Greek_Capital_Letter_Epsilon . #\Greek_Small_Letter_Epsilon)
          
          (#\Greek_Capital_Letter_Zeta . #\Greek_Small_Letter_Zeta)
          
          (#\Greek_Capital_Letter_Eta . #\Greek_Small_Letter_Eta)
          
          (#\Greek_Capital_Letter_Theta . #\Greek_Small_Letter_Theta)
          
          (#\Greek_Capital_Letter_Iota . #\Greek_Small_Letter_Iota)
          
          (#\Greek_Capital_Letter_Kappa . #\Greek_Small_Letter_Kappa)
          
          (#\Greek_Capital_Letter_Lamda . #\Greek_Small_Letter_Lamda)
          
          (#\Greek_Capital_Letter_Mu . #\Greek_Small_Letter_Mu)
          
          (#\Greek_Capital_Letter_Nu . #\Greek_Small_Letter_Nu)
          
          (#\Greek_Capital_Letter_Xi . #\Greek_Small_Letter_Xi)
          
          (#\Greek_Capital_Letter_Omicron . #\Greek_Small_Letter_Omicron)
          
          (#\Greek_Capital_Letter_Pi . #\Greek_Small_Letter_Pi)
          
          (#\Greek_Capital_Letter_Rho . #\Greek_Small_Letter_Rho)
          
          (#\Greek_Capital_Letter_Sigma . #\Greek_Small_Letter_Sigma)
          
          (#\Greek_Capital_Letter_Tau . #\Greek_Small_Letter_Tau)
          
          (#\Greek_Capital_Letter_Upsilon . #\Greek_Small_Letter_Upsilon)
          
          (#\Greek_Capital_Letter_Phi . #\Greek_Small_Letter_Phi)
          
          (#\Greek_Capital_Letter_Chi . #\Greek_Small_Letter_Chi)
          
          (#\Greek_Capital_Letter_Psi . #\Greek_Small_Letter_Psi)
          
          (#\Greek_Capital_Letter_Omega . #\Greek_Small_Letter_Omega)
          
          (#\Greek_Capital_Letter_Iota_With_Dialytika
           . #\Greek_Small_Letter_Iota_With_Dialytika)
          
          (#\Greek_Capital_Letter_Upsilon_With_Dialytika
           . #\Greek_Small_Letter_Upsilon_With_Dialytika)
          
          (#\Greek_Letter_Archaic_Koppa . #\Greek_Small_Letter_Archaic_Koppa)
          
          (#\Greek_Letter_Stigma . #\Greek_Small_Letter_Stigma)
          
          (#\Greek_Letter_Digamma . #\Greek_Small_Letter_Digamma)
          
          (#\Greek_Letter_Koppa . #\Greek_Small_Letter_Koppa)
          
          (#\Greek_Letter_Sampi . #\Greek_Small_Letter_Sampi)
          
          (#\Coptic_Capital_Letter_Shei . #\Coptic_Small_Letter_Shei)
          
          (#\Coptic_Capital_Letter_Fei . #\Coptic_Small_Letter_Fei)
          
          (#\Coptic_Capital_Letter_Khei . #\Coptic_Small_Letter_Khei)
          
          (#\Coptic_Capital_Letter_Hori . #\Coptic_Small_Letter_Hori)
          
          (#\Coptic_Capital_Letter_Gangia . #\Coptic_Small_Letter_Gangia)
          
          (#\Coptic_Capital_Letter_Shima . #\Coptic_Small_Letter_Shima)
          
          (#\Coptic_Capital_Letter_Dei . #\Coptic_Small_Letter_Dei)
          
          (#\Greek_Capital_Letter_Sho . #\Greek_Small_Letter_Sho)
          
          (#\Greek_Capital_Lunate_Sigma_Symbol . #\Greek_Lunate_Sigma_Symbol)
          
          (#\Greek_Capital_Letter_San . #\Greek_Small_Letter_San)
          
          (#\Greek_Capital_Reversed_Lunate_Sigma_Symbol
           . #\Greek_Small_Reversed_Lunate_Sigma_Symbol)
          
          (#\Greek_Capital_Dotted_Lunate_Sigma_Symbol
           . #\Greek_Small_Dotted_Lunate_Sigma_Symbol)
          
          (#\Greek_Capital_Reversed_Dotted_Lunate_Sigma_Symbol
           . #\Greek_Small_Reversed_Dotted_Lunate_Sigma_Symbol)
          
          (#\Cyrillic_Capital_Letter_Ie_With_Grave
           . #\Cyrillic_Small_Letter_Ie_With_Grave)
          
          (#\Cyrillic_Capital_Letter_Io . #\Cyrillic_Small_Letter_Io)
          
          (#\Cyrillic_Capital_Letter_Dje . #\Cyrillic_Small_Letter_Dje)
          
          (#\Cyrillic_Capital_Letter_Gje . #\Cyrillic_Small_Letter_Gje)
          
          (#\Cyrillic_Capital_Letter_Ukrainian_Ie
           . #\Cyrillic_Small_Letter_Ukrainian_Ie)
          
          (#\Cyrillic_Capital_Letter_Dze . #\Cyrillic_Small_Letter_Dze)
          
          (#\Cyrillic_Capital_Letter_Byelorussian-Ukrainian_I
           . #\Cyrillic_Small_Letter_Byelorussian-Ukrainian_I)
          
          (#\Cyrillic_Capital_Letter_Yi . #\Cyrillic_Small_Letter_Yi)
          
          (#\Cyrillic_Capital_Letter_Je . #\Cyrillic_Small_Letter_Je)
          
          (#\Cyrillic_Capital_Letter_Lje . #\Cyrillic_Small_Letter_Lje)
          
          (#\Cyrillic_Capital_Letter_Nje . #\Cyrillic_Small_Letter_Nje)
          
          (#\Cyrillic_Capital_Letter_Tshe . #\Cyrillic_Small_Letter_Tshe)
          
          (#\Cyrillic_Capital_Letter_Kje . #\Cyrillic_Small_Letter_Kje)
          
          (#\Cyrillic_Capital_Letter_I_With_Grave
           . #\Cyrillic_Small_Letter_I_With_Grave)
          
          (#\Cyrillic_Capital_Letter_Short_U . #\Cyrillic_Small_Letter_Short_U)
          
          (#\Cyrillic_Capital_Letter_Dzhe . #\Cyrillic_Small_Letter_Dzhe)
          
          (#\Cyrillic_Capital_Letter_A . #\Cyrillic_Small_Letter_A)
          
          (#\Cyrillic_Capital_Letter_Be . #\Cyrillic_Small_Letter_Be)
          
          (#\Cyrillic_Capital_Letter_Ve . #\Cyrillic_Small_Letter_Ve)
          
          (#\Cyrillic_Capital_Letter_Ghe . #\Cyrillic_Small_Letter_Ghe)
          
          (#\Cyrillic_Capital_Letter_De . #\Cyrillic_Small_Letter_De)
          
          (#\Cyrillic_Capital_Letter_Ie . #\Cyrillic_Small_Letter_Ie)
          
          (#\Cyrillic_Capital_Letter_Zhe . #\Cyrillic_Small_Letter_Zhe)
          
          (#\Cyrillic_Capital_Letter_Ze . #\Cyrillic_Small_Letter_Ze)
          
          (#\Cyrillic_Capital_Letter_I . #\Cyrillic_Small_Letter_I)
          
          (#\Cyrillic_Capital_Letter_Short_I . #\Cyrillic_Small_Letter_Short_I)
          
          (#\Cyrillic_Capital_Letter_Ka . #\Cyrillic_Small_Letter_Ka)
          
          (#\Cyrillic_Capital_Letter_El . #\Cyrillic_Small_Letter_El)
          
          (#\Cyrillic_Capital_Letter_Em . #\Cyrillic_Small_Letter_Em)
          
          (#\Cyrillic_Capital_Letter_En . #\Cyrillic_Small_Letter_En)
          
          (#\Cyrillic_Capital_Letter_O . #\Cyrillic_Small_Letter_O)
          
          (#\Cyrillic_Capital_Letter_Pe . #\Cyrillic_Small_Letter_Pe)
          
          (#\Cyrillic_Capital_Letter_Er . #\Cyrillic_Small_Letter_Er)
          
          (#\Cyrillic_Capital_Letter_Es . #\Cyrillic_Small_Letter_Es)
          
          (#\Cyrillic_Capital_Letter_Te . #\Cyrillic_Small_Letter_Te)
          
          (#\Cyrillic_Capital_Letter_U . #\Cyrillic_Small_Letter_U)
          
          (#\Cyrillic_Capital_Letter_Ef . #\Cyrillic_Small_Letter_Ef)
          
          (#\Cyrillic_Capital_Letter_Ha . #\Cyrillic_Small_Letter_Ha)
          
          (#\Cyrillic_Capital_Letter_Tse . #\Cyrillic_Small_Letter_Tse)
          
          (#\Cyrillic_Capital_Letter_Che . #\Cyrillic_Small_Letter_Che)
          
          (#\Cyrillic_Capital_Letter_Sha . #\Cyrillic_Small_Letter_Sha)
          
          (#\Cyrillic_Capital_Letter_Shcha . #\Cyrillic_Small_Letter_Shcha)
          
          (#\Cyrillic_Capital_Letter_Hard_Sign . #\Cyrillic_Small_Letter_Hard_Sign)
          
          (#\Cyrillic_Capital_Letter_Yeru . #\Cyrillic_Small_Letter_Yeru)
          
          (#\Cyrillic_Capital_Letter_Soft_Sign . #\Cyrillic_Small_Letter_Soft_Sign)
          
          (#\Cyrillic_Capital_Letter_E . #\Cyrillic_Small_Letter_E)
          
          (#\Cyrillic_Capital_Letter_Yu . #\Cyrillic_Small_Letter_Yu)
          
          (#\Cyrillic_Capital_Letter_Ya . #\Cyrillic_Small_Letter_Ya)
          
          (#\Cyrillic_Capital_Letter_Omega . #\Cyrillic_Small_Letter_Omega)
          
          (#\Cyrillic_Capital_Letter_Yat . #\Cyrillic_Small_Letter_Yat)
          
          (#\Cyrillic_Capital_Letter_Iotified_E . #\Cyrillic_Small_Letter_Iotified_E)
          
          (#\Cyrillic_Capital_Letter_Little_Yus . #\Cyrillic_Small_Letter_Little_Yus)
          
          (#\Cyrillic_Capital_Letter_Iotified_Little_Yus
           . #\Cyrillic_Small_Letter_Iotified_Little_Yus)
          
          (#\Cyrillic_Capital_Letter_Big_Yus . #\Cyrillic_Small_Letter_Big_Yus)
          
          (#\Cyrillic_Capital_Letter_Iotified_Big_Yus
           . #\Cyrillic_Small_Letter_Iotified_Big_Yus)
          
          (#\Cyrillic_Capital_Letter_Ksi . #\Cyrillic_Small_Letter_Ksi)
          
          (#\Cyrillic_Capital_Letter_Psi . #\Cyrillic_Small_Letter_Psi)
          
          (#\Cyrillic_Capital_Letter_Fita . #\Cyrillic_Small_Letter_Fita)
          
          (#\Cyrillic_Capital_Letter_Izhitsa . #\Cyrillic_Small_Letter_Izhitsa)
          
          (#\Cyrillic_Capital_Letter_Izhitsa_With_Double_Grave_Accent
           . #\Cyrillic_Small_Letter_Izhitsa_With_Double_Grave_Accent)
          
          (#\Cyrillic_Capital_Letter_Uk . #\Cyrillic_Small_Letter_Uk)
          
          (#\Cyrillic_Capital_Letter_Round_Omega . #\Cyrillic_Small_Letter_Round_Omega)
          
          (#\Cyrillic_Capital_Letter_Omega_With_Titlo
           . #\Cyrillic_Small_Letter_Omega_With_Titlo)
          
          (#\Cyrillic_Capital_Letter_Ot . #\Cyrillic_Small_Letter_Ot)
          
          (#\Cyrillic_Capital_Letter_Koppa . #\Cyrillic_Small_Letter_Koppa)
          
          (#\Cyrillic_Capital_Letter_Short_I_With_Tail
           . #\Cyrillic_Small_Letter_Short_I_With_Tail)
          
          (#\Cyrillic_Capital_Letter_Semisoft_Sign
           . #\Cyrillic_Small_Letter_Semisoft_Sign)
          
          (#\Cyrillic_Capital_Letter_Er_With_Tick
           . #\Cyrillic_Small_Letter_Er_With_Tick)
          
          (#\Cyrillic_Capital_Letter_Ghe_With_Upturn
           . #\Cyrillic_Small_Letter_Ghe_With_Upturn)
          
          (#\Cyrillic_Capital_Letter_Ghe_With_Stroke
           . #\Cyrillic_Small_Letter_Ghe_With_Stroke)
          
          (#\Cyrillic_Capital_Letter_Ghe_With_Middle_Hook
           . #\Cyrillic_Small_Letter_Ghe_With_Middle_Hook)
          
          (#\Cyrillic_Capital_Letter_Zhe_With_Descender
           . #\Cyrillic_Small_Letter_Zhe_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Ze_With_Descender
           . #\Cyrillic_Small_Letter_Ze_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Ka_With_Descender
           . #\Cyrillic_Small_Letter_Ka_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Ka_With_Vertical_Stroke
           . #\Cyrillic_Small_Letter_Ka_With_Vertical_Stroke)
          
          (#\Cyrillic_Capital_Letter_Ka_With_Stroke
           . #\Cyrillic_Small_Letter_Ka_With_Stroke)
          
          (#\Cyrillic_Capital_Letter_Bashkir_Ka . #\Cyrillic_Small_Letter_Bashkir_Ka)
          
          (#\Cyrillic_Capital_Letter_En_With_Descender
           . #\Cyrillic_Small_Letter_En_With_Descender)
          
          (#\Cyrillic_Capital_Ligature_En_Ghe . #\Cyrillic_Small_Ligature_En_Ghe)
          
          (#\Cyrillic_Capital_Letter_Pe_With_Middle_Hook
           . #\Cyrillic_Small_Letter_Pe_With_Middle_Hook)
          
          (#\Cyrillic_Capital_Letter_Abkhasian_Ha
           . #\Cyrillic_Small_Letter_Abkhasian_Ha)
          
          (#\Cyrillic_Capital_Letter_Es_With_Descender
           . #\Cyrillic_Small_Letter_Es_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Te_With_Descender
           . #\Cyrillic_Small_Letter_Te_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Straight_U . #\Cyrillic_Small_Letter_Straight_U)
          
          (#\Cyrillic_Capital_Letter_Straight_U_With_Stroke
           . #\Cyrillic_Small_Letter_Straight_U_With_Stroke)
          
          (#\Cyrillic_Capital_Letter_Ha_With_Descender
           . #\Cyrillic_Small_Letter_Ha_With_Descender)
          
          (#\Cyrillic_Capital_Ligature_Te_Tse . #\Cyrillic_Small_Ligature_Te_Tse)
          
          (#\Cyrillic_Capital_Letter_Che_With_Descender
           . #\Cyrillic_Small_Letter_Che_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Che_With_Vertical_Stroke
           . #\Cyrillic_Small_Letter_Che_With_Vertical_Stroke)
          
          (#\Cyrillic_Capital_Letter_Shha . #\Cyrillic_Small_Letter_Shha)
          
          (#\Cyrillic_Capital_Letter_Abkhasian_Che
           . #\Cyrillic_Small_Letter_Abkhasian_Che)
          
          (#\Cyrillic_Capital_Letter_Abkhasian_Che_With_Descender
           . #\Cyrillic_Small_Letter_Abkhasian_Che_With_Descender)
          
          (#\Cyrillic_Letter_Palochka . #\Cyrillic_Small_Letter_Palochka)
          
          (#\Cyrillic_Capital_Letter_Zhe_With_Breve
           . #\Cyrillic_Small_Letter_Zhe_With_Breve)
          
          (#\Cyrillic_Capital_Letter_Ka_With_Hook
           . #\Cyrillic_Small_Letter_Ka_With_Hook)
          
          (#\Cyrillic_Capital_Letter_El_With_Tail
           . #\Cyrillic_Small_Letter_El_With_Tail)
          
          (#\Cyrillic_Capital_Letter_En_With_Hook
           . #\Cyrillic_Small_Letter_En_With_Hook)
          
          (#\Cyrillic_Capital_Letter_En_With_Tail
           . #\Cyrillic_Small_Letter_En_With_Tail)
          
          (#\Cyrillic_Capital_Letter_Khakassian_Che
           . #\Cyrillic_Small_Letter_Khakassian_Che)
          
          (#\Cyrillic_Capital_Letter_Em_With_Tail
           . #\Cyrillic_Small_Letter_Em_With_Tail)
          
          (#\Cyrillic_Capital_Letter_A_With_Breve
           . #\Cyrillic_Small_Letter_A_With_Breve)
          
          (#\Cyrillic_Capital_Letter_A_With_Diaeresis
           . #\Cyrillic_Small_Letter_A_With_Diaeresis)
          
          (#\Cyrillic_Capital_Ligature_A_Ie . #\Cyrillic_Small_Ligature_A_Ie)
          
          (#\Cyrillic_Capital_Letter_Ie_With_Breve
           . #\Cyrillic_Small_Letter_Ie_With_Breve)
          
          (#\Cyrillic_Capital_Letter_Schwa . #\Cyrillic_Small_Letter_Schwa)
          
          (#\Cyrillic_Capital_Letter_Schwa_With_Diaeresis
           . #\Cyrillic_Small_Letter_Schwa_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Zhe_With_Diaeresis
           . #\Cyrillic_Small_Letter_Zhe_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Ze_With_Diaeresis
           . #\Cyrillic_Small_Letter_Ze_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Abkhasian_Dze
           . #\Cyrillic_Small_Letter_Abkhasian_Dze)
          
          (#\Cyrillic_Capital_Letter_I_With_Macron
           . #\Cyrillic_Small_Letter_I_With_Macron)
          
          (#\Cyrillic_Capital_Letter_I_With_Diaeresis
           . #\Cyrillic_Small_Letter_I_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_O_With_Diaeresis
           . #\Cyrillic_Small_Letter_O_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Barred_O . #\Cyrillic_Small_Letter_Barred_O)
          
          (#\Cyrillic_Capital_Letter_Barred_O_With_Diaeresis
           . #\Cyrillic_Small_Letter_Barred_O_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_E_With_Diaeresis
           . #\Cyrillic_Small_Letter_E_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_U_With_Macron
           . #\Cyrillic_Small_Letter_U_With_Macron)
          
          (#\Cyrillic_Capital_Letter_U_With_Diaeresis
           . #\Cyrillic_Small_Letter_U_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_U_With_Double_Acute
           . #\Cyrillic_Small_Letter_U_With_Double_Acute)
          
          (#\Cyrillic_Capital_Letter_Che_With_Diaeresis
           . #\Cyrillic_Small_Letter_Che_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Ghe_With_Descender
           . #\Cyrillic_Small_Letter_Ghe_With_Descender)
          
          (#\Cyrillic_Capital_Letter_Yeru_With_Diaeresis
           . #\Cyrillic_Small_Letter_Yeru_With_Diaeresis)
          
          (#\Cyrillic_Capital_Letter_Ghe_With_Stroke_And_Hook
           . #\Cyrillic_Small_Letter_Ghe_With_Stroke_And_Hook)
          
          (#\Cyrillic_Capital_Letter_Ha_With_Hook
           . #\Cyrillic_Small_Letter_Ha_With_Hook)
          
          (#\Cyrillic_Capital_Letter_Ha_With_Stroke
           . #\Cyrillic_Small_Letter_Ha_With_Stroke)
          
          (#\Cyrillic_Capital_Letter_Komi_De . #\Cyrillic_Small_Letter_Komi_De)
          
          (#\Cyrillic_Capital_Letter_Komi_Dje . #\Cyrillic_Small_Letter_Komi_Dje)
          
          (#\Cyrillic_Capital_Letter_Komi_Zje . #\Cyrillic_Small_Letter_Komi_Zje)
          
          (#\Cyrillic_Capital_Letter_Komi_Dzje . #\Cyrillic_Small_Letter_Komi_Dzje)
          
          (#\Cyrillic_Capital_Letter_Komi_Lje . #\Cyrillic_Small_Letter_Komi_Lje)
          
          (#\Cyrillic_Capital_Letter_Komi_Nje . #\Cyrillic_Small_Letter_Komi_Nje)
          
          (#\Cyrillic_Capital_Letter_Komi_Sje . #\Cyrillic_Small_Letter_Komi_Sje)
          
          (#\Cyrillic_Capital_Letter_Komi_Tje . #\Cyrillic_Small_Letter_Komi_Tje)
          
          (#\Cyrillic_Capital_Letter_Reversed_Ze . #\Cyrillic_Small_Letter_Reversed_Ze)
          
          (#\Cyrillic_Capital_Letter_El_With_Hook
           . #\Cyrillic_Small_Letter_El_With_Hook)
          
          (#\Armenian_Capital_Letter_Ayb . #\Armenian_Small_Letter_Ayb)
          
          (#\Armenian_Capital_Letter_Ben . #\Armenian_Small_Letter_Ben)
          
          (#\Armenian_Capital_Letter_Gim . #\Armenian_Small_Letter_Gim)
          
          (#\Armenian_Capital_Letter_Da . #\Armenian_Small_Letter_Da)
          
          (#\Armenian_Capital_Letter_Ech . #\Armenian_Small_Letter_Ech)
          
          (#\Armenian_Capital_Letter_Za . #\Armenian_Small_Letter_Za)
          
          (#\Armenian_Capital_Letter_Eh . #\Armenian_Small_Letter_Eh)
          
          (#\Armenian_Capital_Letter_Et . #\Armenian_Small_Letter_Et)
          
          (#\Armenian_Capital_Letter_To . #\Armenian_Small_Letter_To)
          
          (#\Armenian_Capital_Letter_Zhe . #\Armenian_Small_Letter_Zhe)
          
          (#\Armenian_Capital_Letter_Ini . #\Armenian_Small_Letter_Ini)
          
          (#\Armenian_Capital_Letter_Liwn . #\Armenian_Small_Letter_Liwn)
          
          (#\Armenian_Capital_Letter_Xeh . #\Armenian_Small_Letter_Xeh)
          
          (#\Armenian_Capital_Letter_Ca . #\Armenian_Small_Letter_Ca)
          
          (#\Armenian_Capital_Letter_Ken . #\Armenian_Small_Letter_Ken)
          
          (#\Armenian_Capital_Letter_Ho . #\Armenian_Small_Letter_Ho)
          
          (#\Armenian_Capital_Letter_Ja . #\Armenian_Small_Letter_Ja)
          
          (#\Armenian_Capital_Letter_Ghad . #\Armenian_Small_Letter_Ghad)
          
          (#\Armenian_Capital_Letter_Cheh . #\Armenian_Small_Letter_Cheh)
          
          (#\Armenian_Capital_Letter_Men . #\Armenian_Small_Letter_Men)
          
          (#\Armenian_Capital_Letter_Yi . #\Armenian_Small_Letter_Yi)
          
          (#\Armenian_Capital_Letter_Now . #\Armenian_Small_Letter_Now)
          
          (#\Armenian_Capital_Letter_Sha . #\Armenian_Small_Letter_Sha)
          
          (#\Armenian_Capital_Letter_Vo . #\Armenian_Small_Letter_Vo)
          
          (#\Armenian_Capital_Letter_Cha . #\Armenian_Small_Letter_Cha)
          
          (#\Armenian_Capital_Letter_Peh . #\Armenian_Small_Letter_Peh)
          
          (#\Armenian_Capital_Letter_Jheh . #\Armenian_Small_Letter_Jheh)
          
          (#\Armenian_Capital_Letter_Ra . #\Armenian_Small_Letter_Ra)
          
          (#\Armenian_Capital_Letter_Seh . #\Armenian_Small_Letter_Seh)
          
          (#\Armenian_Capital_Letter_Vew . #\Armenian_Small_Letter_Vew)
          
          (#\Armenian_Capital_Letter_Tiwn . #\Armenian_Small_Letter_Tiwn)
          
          (#\Armenian_Capital_Letter_Reh . #\Armenian_Small_Letter_Reh)
          
          (#\Armenian_Capital_Letter_Co . #\Armenian_Small_Letter_Co)
          
          (#\Armenian_Capital_Letter_Yiwn . #\Armenian_Small_Letter_Yiwn)
          
          (#\Armenian_Capital_Letter_Piwr . #\Armenian_Small_Letter_Piwr)
          
          (#\Armenian_Capital_Letter_Keh . #\Armenian_Small_Letter_Keh)
          
          (#\Armenian_Capital_Letter_Oh . #\Armenian_Small_Letter_Oh)
          
          (#\Armenian_Capital_Letter_Feh . #\Armenian_Small_Letter_Feh)
          
          (#\U+10A0 . #\U+2D00)
          (#\U+10A1 . #\U+2D01)
          (#\U+10A2 . #\U+2D02)
          
          (#\U+10A3 . #\U+2D03)
          (#\U+10A4 . #\U+2D04)
          (#\U+10A5 . #\U+2D05)
          
          (#\U+10A6 . #\U+2D06)
          (#\U+10A7 . #\U+2D07)
          (#\U+10A8 . #\U+2D08)
          
          (#\U+10A9 . #\U+2D09)
          (#\U+10AA . #\U+2D0A)
          (#\U+10AB . #\U+2D0B)
          
          (#\U+10AC . #\U+2D0C)
          (#\U+10AD . #\U+2D0D)
          (#\U+10AE . #\U+2D0E)
          
          (#\U+10AF . #\U+2D0F)
          (#\U+10B0 . #\U+2D10)
          (#\U+10B1 . #\U+2D11)
          
          (#\U+10B2 . #\U+2D12)
          (#\U+10B3 . #\U+2D13)
          (#\U+10B4 . #\U+2D14)
          
          (#\U+10B5 . #\U+2D15)
          (#\U+10B6 . #\U+2D16)
          (#\U+10B7 . #\U+2D17)
          
          (#\U+10B8 . #\U+2D18)
          (#\U+10B9 . #\U+2D19)
          (#\U+10BA . #\U+2D1A)
          
          (#\U+10BB . #\U+2D1B)
          (#\U+10BC . #\U+2D1C)
          (#\U+10BD . #\U+2D1D)
          
          (#\U+10BE . #\U+2D1E)
          (#\U+10BF . #\U+2D1F)
          (#\U+10C0 . #\U+2D20)
          
          (#\U+10C1 . #\U+2D21)
          (#\U+10C2 . #\U+2D22)
          (#\U+10C3 . #\U+2D23)
          
          (#\U+10C4 . #\U+2D24)
          (#\U+10C5 . #\U+2D25)
          (#\U+1E00 . #\U+1E01)
          
          (#\U+1E02 . #\U+1E03)
          (#\U+1E04 . #\U+1E05)
          (#\U+1E06 . #\U+1E07)
          
          (#\U+1E08 . #\U+1E09)
          (#\U+1E0A . #\U+1E0B)
          (#\U+1E0C . #\U+1E0D)
          
          (#\U+1E0E . #\U+1E0F)
          (#\U+1E10 . #\U+1E11)
          (#\U+1E12 . #\U+1E13)
          
          (#\U+1E14 . #\U+1E15)
          (#\U+1E16 . #\U+1E17)
          (#\U+1E18 . #\U+1E19)
          
          (#\U+1E1A . #\U+1E1B)
          (#\U+1E1C . #\U+1E1D)
          (#\U+1E1E . #\U+1E1F)
          
          (#\U+1E20 . #\U+1E21)
          (#\U+1E22 . #\U+1E23)
          (#\U+1E24 . #\U+1E25)
          
          (#\U+1E26 . #\U+1E27)
          (#\U+1E28 . #\U+1E29)
          (#\U+1E2A . #\U+1E2B)
          
          (#\U+1E2C . #\U+1E2D)
          (#\U+1E2E . #\U+1E2F)
          (#\U+1E30 . #\U+1E31)
          
          (#\U+1E32 . #\U+1E33)
          (#\U+1E34 . #\U+1E35)
          (#\U+1E36 . #\U+1E37)
          
          (#\U+1E38 . #\U+1E39)
          (#\U+1E3A . #\U+1E3B)
          (#\U+1E3C . #\U+1E3D)
          
          (#\U+1E3E . #\U+1E3F)
          (#\U+1E40 . #\U+1E41)
          (#\U+1E42 . #\U+1E43)
          
          (#\U+1E44 . #\U+1E45)
          (#\U+1E46 . #\U+1E47)
          (#\U+1E48 . #\U+1E49)
          
          (#\U+1E4A . #\U+1E4B)
          (#\U+1E4C . #\U+1E4D)
          (#\U+1E4E . #\U+1E4F)
          
          (#\U+1E50 . #\U+1E51)
          (#\U+1E52 . #\U+1E53)
          (#\U+1E54 . #\U+1E55)
          
          (#\U+1E56 . #\U+1E57)
          (#\U+1E58 . #\U+1E59)
          (#\U+1E5A . #\U+1E5B)
          
          (#\U+1E5C . #\U+1E5D)
          (#\U+1E5E . #\U+1E5F)
          (#\U+1E60 . #\U+1E61)
          
          (#\U+1E62 . #\U+1E63)
          (#\U+1E64 . #\U+1E65)
          (#\U+1E66 . #\U+1E67)
          
          (#\U+1E68 . #\U+1E69)
          (#\U+1E6A . #\U+1E6B)
          (#\U+1E6C . #\U+1E6D)
          
          (#\U+1E6E . #\U+1E6F)
          (#\U+1E70 . #\U+1E71)
          (#\U+1E72 . #\U+1E73)
          
          (#\U+1E74 . #\U+1E75)
          (#\U+1E76 . #\U+1E77)
          (#\U+1E78 . #\U+1E79)
          
          (#\U+1E7A . #\U+1E7B)
          (#\U+1E7C . #\U+1E7D)
          (#\U+1E7E . #\U+1E7F)
          
          (#\U+1E80 . #\U+1E81)
          (#\U+1E82 . #\U+1E83)
          (#\U+1E84 . #\U+1E85)
          
          (#\U+1E86 . #\U+1E87)
          (#\U+1E88 . #\U+1E89)
          (#\U+1E8A . #\U+1E8B)
          
          (#\U+1E8C . #\U+1E8D)
          (#\U+1E8E . #\U+1E8F)
          (#\U+1E90 . #\U+1E91)
          
          (#\U+1E92 . #\U+1E93)
          (#\U+1E94 . #\U+1E95)
          (#\U+1EA0 . #\U+1EA1)
          
          (#\U+1EA2 . #\U+1EA3)
          (#\U+1EA4 . #\U+1EA5)
          (#\U+1EA6 . #\U+1EA7)
          
          (#\U+1EA8 . #\U+1EA9)
          (#\U+1EAA . #\U+1EAB)
          (#\U+1EAC . #\U+1EAD)
          
          (#\U+1EAE . #\U+1EAF)
          (#\U+1EB0 . #\U+1EB1)
          (#\U+1EB2 . #\U+1EB3)
          
          (#\U+1EB4 . #\U+1EB5)
          (#\U+1EB6 . #\U+1EB7)
          (#\U+1EB8 . #\U+1EB9)
          
          (#\U+1EBA . #\U+1EBB)
          (#\U+1EBC . #\U+1EBD)
          (#\U+1EBE . #\U+1EBF)
          
          (#\U+1EC0 . #\U+1EC1)
          (#\U+1EC2 . #\U+1EC3)
          (#\U+1EC4 . #\U+1EC5)
          
          (#\U+1EC6 . #\U+1EC7)
          (#\U+1EC8 . #\U+1EC9)
          (#\U+1ECA . #\U+1ECB)
          
          (#\U+1ECC . #\U+1ECD)
          (#\U+1ECE . #\U+1ECF)
          (#\U+1ED0 . #\U+1ED1)
          
          (#\U+1ED2 . #\U+1ED3)
          (#\U+1ED4 . #\U+1ED5)
          (#\U+1ED6 . #\U+1ED7)
          
          (#\U+1ED8 . #\U+1ED9)
          (#\U+1EDA . #\U+1EDB)
          (#\U+1EDC . #\U+1EDD)
          
          (#\U+1EDE . #\U+1EDF)
          (#\U+1EE0 . #\U+1EE1)
          (#\U+1EE2 . #\U+1EE3)
          
          (#\U+1EE4 . #\U+1EE5)
          (#\U+1EE6 . #\U+1EE7)
          (#\U+1EE8 . #\U+1EE9)
          
          (#\U+1EEA . #\U+1EEB)
          (#\U+1EEC . #\U+1EED)
          (#\U+1EEE . #\U+1EEF)
          
          (#\U+1EF0 . #\U+1EF1)
          (#\U+1EF2 . #\U+1EF3)
          (#\U+1EF4 . #\U+1EF5)
          
          (#\U+1EF6 . #\U+1EF7)
          (#\U+1EF8 . #\U+1EF9)
          (#\U+1F08 . #\U+1F00)
          
          (#\U+1F09 . #\U+1F01)
          (#\U+1F0A . #\U+1F02)
          (#\U+1F0B . #\U+1F03)
          
          (#\U+1F0C . #\U+1F04)
          (#\U+1F0D . #\U+1F05)
          (#\U+1F0E . #\U+1F06)
          
          (#\U+1F0F . #\U+1F07)
          (#\U+1F18 . #\U+1F10)
          (#\U+1F19 . #\U+1F11)
          
          (#\U+1F1A . #\U+1F12)
          (#\U+1F1B . #\U+1F13)
          (#\U+1F1C . #\U+1F14)
          
          (#\U+1F1D . #\U+1F15)
          (#\U+1F28 . #\U+1F20)
          (#\U+1F29 . #\U+1F21)
          
          (#\U+1F2A . #\U+1F22)
          (#\U+1F2B . #\U+1F23)
          (#\U+1F2C . #\U+1F24)
          
          (#\U+1F2D . #\U+1F25)
          (#\U+1F2E . #\U+1F26)
          (#\U+1F2F . #\U+1F27)
          
          (#\U+1F38 . #\U+1F30)
          (#\U+1F39 . #\U+1F31)
          (#\U+1F3A . #\U+1F32)
          
          (#\U+1F3B . #\U+1F33)
          (#\U+1F3C . #\U+1F34)
          (#\U+1F3D . #\U+1F35)
          
          (#\U+1F3E . #\U+1F36)
          (#\U+1F3F . #\U+1F37)
          (#\U+1F48 . #\U+1F40)
          
          (#\U+1F49 . #\U+1F41)
          (#\U+1F4A . #\U+1F42)
          (#\U+1F4B . #\U+1F43)
          
          (#\U+1F4C . #\U+1F44)
          (#\U+1F4D . #\U+1F45)
          (#\U+1F59 . #\U+1F51)
          
          (#\U+1F5B . #\U+1F53)
          (#\U+1F5D . #\U+1F55)
          (#\U+1F5F . #\U+1F57)
          
          (#\U+1F68 . #\U+1F60)
          (#\U+1F69 . #\U+1F61)
          (#\U+1F6A . #\U+1F62)
          
          (#\U+1F6B . #\U+1F63)
          (#\U+1F6C . #\U+1F64)
          (#\U+1F6D . #\U+1F65)
          
          (#\U+1F6E . #\U+1F66)
          (#\U+1F6F . #\U+1F67)
          (#\U+1F88 . #\U+1F80)
          
          (#\U+1F89 . #\U+1F81)
          (#\U+1F8A . #\U+1F82)
          (#\U+1F8B . #\U+1F83)
          
          (#\U+1F8C . #\U+1F84)
          (#\U+1F8D . #\U+1F85)
          (#\U+1F8E . #\U+1F86)
          
          (#\U+1F8F . #\U+1F87)
          (#\U+1F98 . #\U+1F90)
          (#\U+1F99 . #\U+1F91)
          
          (#\U+1F9A . #\U+1F92)
          (#\U+1F9B . #\U+1F93)
          (#\U+1F9C . #\U+1F94)
          
          (#\U+1F9D . #\U+1F95)
          (#\U+1F9E . #\U+1F96)
          (#\U+1F9F . #\U+1F97)
          
          (#\U+1FA8 . #\U+1FA0)
          (#\U+1FA9 . #\U+1FA1)
          (#\U+1FAA . #\U+1FA2)
          
          (#\U+1FAB . #\U+1FA3)
          (#\U+1FAC . #\U+1FA4)
          (#\U+1FAD . #\U+1FA5)
          
          (#\U+1FAE . #\U+1FA6)
          (#\U+1FAF . #\U+1FA7)
          (#\U+1FB8 . #\U+1FB0)
          
          (#\U+1FB9 . #\U+1FB1)
          (#\U+1FBA . #\U+1F70)
          (#\U+1FBB . #\U+1F71)
          
          (#\U+1FBC . #\U+1FB3)
          (#\U+1FC8 . #\U+1F72)
          (#\U+1FC9 . #\U+1F73)
          
          (#\U+1FCA . #\U+1F74)
          (#\U+1FCB . #\U+1F75)
          (#\U+1FCC . #\U+1FC3)
          
          (#\U+1FD8 . #\U+1FD0)
          (#\U+1FD9 . #\U+1FD1)
          (#\U+1FDA . #\U+1F76)
          
          (#\U+1FDB . #\U+1F77)
          (#\U+1FE8 . #\U+1FE0)
          (#\U+1FE9 . #\U+1FE1)
          
          (#\U+1FEA . #\U+1F7A)
          (#\U+1FEB . #\U+1F7B)
          (#\U+1FEC . #\U+1FE5)
          
          (#\U+1FF8 . #\U+1F78)
          (#\U+1FF9 . #\U+1F79)
          (#\U+1FFA . #\U+1F7C)
          
          (#\U+1FFB . #\U+1F7D)
          (#\U+1FFC . #\U+1FF3)
          (#\U+2132 . #\U+214E)
          
          (#\U+2160 . #\U+2170)
          (#\U+2161 . #\U+2171)
          (#\U+2162 . #\U+2172)
          
          (#\U+2163 . #\U+2173)
          (#\U+2164 . #\U+2174)
          (#\U+2165 . #\U+2175)
          
          (#\U+2166 . #\U+2176)
          (#\U+2167 . #\U+2177)
          (#\U+2168 . #\U+2178)
          
          (#\U+2169 . #\U+2179)
          (#\U+216A . #\U+217A)
          (#\U+216B . #\U+217B)
          
          (#\U+216C . #\U+217C)
          (#\U+216D . #\U+217D)
          (#\U+216E . #\U+217E)
          
          (#\U+216F . #\U+217F)
          (#\U+2183 . #\U+2184)
          (#\U+24B6 . #\U+24D0)
          
          (#\U+24B7 . #\U+24D1)
          (#\U+24B8 . #\U+24D2)
          (#\U+24B9 . #\U+24D3)
          
          (#\U+24BA . #\U+24D4)
          (#\U+24BB . #\U+24D5)
          (#\U+24BC . #\U+24D6)
          
          (#\U+24BD . #\U+24D7)
          (#\U+24BE . #\U+24D8)
          (#\U+24BF . #\U+24D9)
          
          (#\U+24C0 . #\U+24DA)
          (#\U+24C1 . #\U+24DB)
          (#\U+24C2 . #\U+24DC)
          
          (#\U+24C3 . #\U+24DD)
          (#\U+24C4 . #\U+24DE)
          (#\U+24C5 . #\U+24DF)
          
          (#\U+24C6 . #\U+24E0)
          (#\U+24C7 . #\U+24E1)
          (#\U+24C8 . #\U+24E2)
          
          (#\U+24C9 . #\U+24E3)
          (#\U+24CA . #\U+24E4)
          (#\U+24CB . #\U+24E5)
          
          (#\U+24CC . #\U+24E6)
          (#\U+24CD . #\U+24E7)
          (#\U+24CE . #\U+24E8)
          
          (#\U+24CF . #\U+24E9)
          (#\U+2C00 . #\U+2C30)
          (#\U+2C01 . #\U+2C31)
          
          (#\U+2C02 . #\U+2C32)
          (#\U+2C03 . #\U+2C33)
          (#\U+2C04 . #\U+2C34)
          
          (#\U+2C05 . #\U+2C35)
          (#\U+2C06 . #\U+2C36)
          (#\U+2C07 . #\U+2C37)
          
          (#\U+2C08 . #\U+2C38)
          (#\U+2C09 . #\U+2C39)
          (#\U+2C0A . #\U+2C3A)
          
          (#\U+2C0B . #\U+2C3B)
          (#\U+2C0C . #\U+2C3C)
          (#\U+2C0D . #\U+2C3D)
          
          (#\U+2C0E . #\U+2C3E)
          (#\U+2C0F . #\U+2C3F)
          (#\U+2C10 . #\U+2C40)
          
          (#\U+2C11 . #\U+2C41)
          (#\U+2C12 . #\U+2C42)
          (#\U+2C13 . #\U+2C43)
          
          (#\U+2C14 . #\U+2C44)
          (#\U+2C15 . #\U+2C45)
          (#\U+2C16 . #\U+2C46)
          
          (#\U+2C17 . #\U+2C47)
          (#\U+2C18 . #\U+2C48)
          (#\U+2C19 . #\U+2C49)
          
          (#\U+2C1A . #\U+2C4A)
          (#\U+2C1B . #\U+2C4B)
          (#\U+2C1C . #\U+2C4C)
          
          (#\U+2C1D . #\U+2C4D)
          (#\U+2C1E . #\U+2C4E)
          (#\U+2C1F . #\U+2C4F)
          
          (#\U+2C20 . #\U+2C50)
          (#\U+2C21 . #\U+2C51)
          (#\U+2C22 . #\U+2C52)
          
          (#\U+2C23 . #\U+2C53)
          (#\U+2C24 . #\U+2C54)
          (#\U+2C25 . #\U+2C55)
          
          (#\U+2C26 . #\U+2C56)
          (#\U+2C27 . #\U+2C57)
          (#\U+2C28 . #\U+2C58)
          
          (#\U+2C29 . #\U+2C59)
          (#\U+2C2A . #\U+2C5A)
          (#\U+2C2B . #\U+2C5B)
          
          (#\U+2C2C . #\U+2C5C)
          (#\U+2C2D . #\U+2C5D)
          (#\U+2C2E . #\U+2C5E)
          
          (#\U+2C60 . #\U+2C61)
          (#\U+2C62 . #\Latin_Small_Letter_L_With_Middle_Tilde)
          
          (#\U+2C63 . #\U+1D7D)
          (#\U+2C64 . #\Latin_Small_Letter_R_With_Tail)
          
          (#\U+2C67 . #\U+2C68)
          (#\U+2C69 . #\U+2C6A)
          (#\U+2C6B . #\U+2C6C)
          
          (#\U+2C75 . #\U+2C76)
          (#\U+2C80 . #\U+2C81)
          (#\U+2C82 . #\U+2C83)
          
          (#\U+2C84 . #\U+2C85)
          (#\U+2C86 . #\U+2C87)
          (#\U+2C88 . #\U+2C89)
          
          (#\U+2C8A . #\U+2C8B)
          (#\U+2C8C . #\U+2C8D)
          (#\U+2C8E . #\U+2C8F)
          
          (#\U+2C90 . #\U+2C91)
          (#\U+2C92 . #\U+2C93)
          (#\U+2C94 . #\U+2C95)
          
          (#\U+2C96 . #\U+2C97)
          (#\U+2C98 . #\U+2C99)
          (#\U+2C9A . #\U+2C9B)
          
          (#\U+2C9C . #\U+2C9D)
          (#\U+2C9E . #\U+2C9F)
          (#\U+2CA0 . #\U+2CA1)
          
          (#\U+2CA2 . #\U+2CA3)
          (#\U+2CA4 . #\U+2CA5)
          (#\U+2CA6 . #\U+2CA7)
          
          (#\U+2CA8 . #\U+2CA9)
          (#\U+2CAA . #\U+2CAB)
          (#\U+2CAC . #\U+2CAD)
          
          (#\U+2CAE . #\U+2CAF)
          (#\U+2CB0 . #\U+2CB1)
          (#\U+2CB2 . #\U+2CB3)
          
          (#\U+2CB4 . #\U+2CB5)
          (#\U+2CB6 . #\U+2CB7)
          (#\U+2CB8 . #\U+2CB9)
          
          (#\U+2CBA . #\U+2CBB)
          (#\U+2CBC . #\U+2CBD)
          (#\U+2CBE . #\U+2CBF)
          
          (#\U+2CC0 . #\U+2CC1)
          (#\U+2CC2 . #\U+2CC3)
          (#\U+2CC4 . #\U+2CC5)
          
          (#\U+2CC6 . #\U+2CC7)
          (#\U+2CC8 . #\U+2CC9)
          (#\U+2CCA . #\U+2CCB)
          
          (#\U+2CCC . #\U+2CCD)
          (#\U+2CCE . #\U+2CCF)
          (#\U+2CD0 . #\U+2CD1)
          
          (#\U+2CD2 . #\U+2CD3)
          (#\U+2CD4 . #\U+2CD5)
          (#\U+2CD6 . #\U+2CD7)
          
          (#\U+2CD8 . #\U+2CD9)
          (#\U+2CDA . #\U+2CDB)
          (#\U+2CDC . #\U+2CDD)
          
          (#\U+2CDE . #\U+2CDF)
          (#\U+2CE0 . #\U+2CE1)
          (#\U+2CE2 . #\U+2CE3)
          
          (#\U+FF21 . #\U+FF41)
          (#\U+FF22 . #\U+FF42)
          (#\U+FF23 . #\U+FF43)
          
          (#\U+FF24 . #\U+FF44)
          (#\U+FF25 . #\U+FF45)
          (#\U+FF26 . #\U+FF46)
          
          (#\U+FF27 . #\U+FF47)
          (#\U+FF28 . #\U+FF48)
          (#\U+FF29 . #\U+FF49)
          
          (#\U+FF2A . #\U+FF4A)
          (#\U+FF2B . #\U+FF4B)
          (#\U+FF2C . #\U+FF4C)
          
          (#\U+FF2D . #\U+FF4D)
          (#\U+FF2E . #\U+FF4E)
          (#\U+FF2F . #\U+FF4F)
          
          (#\U+FF30 . #\U+FF50)
          (#\U+FF31 . #\U+FF51)
          (#\U+FF32 . #\U+FF52)
          
          (#\U+FF33 . #\U+FF53)
          (#\U+FF34 . #\U+FF54)
          (#\U+FF35 . #\U+FF55)
          
          (#\U+FF36 . #\U+FF56)
          (#\U+FF37 . #\U+FF57)
          (#\U+FF38 . #\U+FF58)
          
          (#\U+FF39 . #\U+FF59)
          (#\U+FF3A . #\U+FF5A)
          (#\U+10400 . #\U+10428)
          
          (#\U+10401 . #\U+10429)
          (#\U+10402 . #\U+1042A)
          (#\U+10403 . #\U+1042B)
          
          (#\U+10404 . #\U+1042C)
          (#\U+10405 . #\U+1042D)
          (#\U+10406 . #\U+1042E)
          
          (#\U+10407 . #\U+1042F)
          (#\U+10408 . #\U+10430)
          (#\U+10409 . #\U+10431)
          
          (#\U+1040A . #\U+10432)
          (#\U+1040B . #\U+10433)
          (#\U+1040C . #\U+10434)
          
          (#\U+1040D . #\U+10435)
          (#\U+1040E . #\U+10436)
          (#\U+1040F . #\U+10437)
          
          (#\U+10410 . #\U+10438)
          (#\U+10411 . #\U+10439)
          (#\U+10412 . #\U+1043A)
          
          (#\U+10413 . #\U+1043B)
          (#\U+10414 . #\U+1043C)
          (#\U+10415 . #\U+1043D)
          
          (#\U+10416 . #\U+1043E)
          (#\U+10417 . #\U+1043F)
          (#\U+10418 . #\U+10440)
          
          (#\U+10419 . #\U+10441)
          (#\U+1041A . #\U+10442)
          (#\U+1041B . #\U+10443)
          
          (#\U+1041C . #\U+10444)
          (#\U+1041D . #\U+10445)
          (#\U+1041E . #\U+10446)
          
          (#\U+1041F . #\U+10447)
          (#\U+10420 . #\U+10448)
          (#\U+10421 . #\U+10449)
          
          (#\U+10422 . #\U+1044A)
          (#\U+10423 . #\U+1044B)
          (#\U+10424 . #\U+1044C)
          
          (#\U+10425 . #\U+1044D)
          (#\U+10426 . #\U+1044E)
          (#\U+10427 . #\U+1044F)
          ))
       (max-upper #\u+0000)
       (max-lower #\u+0000))
  (declare (optimize speed)) ;; make sure everything gets inlined that needs to be.
  (dolist (pair mapping)
    (destructuring-bind (upper . lower) pair
      (when (char> upper max-upper)
        (setq max-upper upper))
      (when (char> lower max-lower)
        (setq max-lower lower))))
  (let* ((upper-to-lower (make-array (the fixnum (1+ (the fixnum (char-code max-upper)))) :element-type '(signed-byte 16)))
         (lower-to-upper (make-array (the fixnum (1+ (the fixnum (char-code max-lower)))) :element-type '(signed-byte 16))))
    (dolist (pair mapping)
      (destructuring-bind (upper . lower) pair
        (let* ((upper-code (char-code upper))
               (lower-code (char-code lower))
               (diff (- lower-code upper-code)))
          (declare (type (mod #x110000) upper-code lower-code)
                   (type (signed-byte 16) diff))
          (setf (aref upper-to-lower upper-code) diff
                (aref lower-to-upper lower-code) (the fixnum (- diff))))))
    (do* ((upper (char-code #\A) (1+ upper))
          (lower (char-code #\a) (1+ lower)))
         ((> upper (char-code #\Z)))
      (setf (aref upper-to-lower upper) (- lower upper)
            (aref lower-to-upper lower) (- upper lower)))
    (setq *lower-to-upper* lower-to-upper
          *upper-to-lower* upper-to-lower)
    nil))

(eval-when (:compile-toplevel)
  (declaim (inline %char-code-case-fold)))

(defun %char-code-case-fold (code table)
  (declare (type (mod #x110000) code)
           (type (simple-array (signed-byte 16) (*)) table))
  (if (>= code (length table))
    code
    (locally (declare (optimize (speed 3) (safety 0)))
      (the fixnum (+ code (the (signed-byte 16) (aref table code)))))))

(defun %char-code-upcase (code)
  (%char-code-case-fold code *lower-to-upper*))

(defun char-upcase (c)
  "Return CHAR converted to upper-case if that is possible.  Don't convert
   lowercase eszet (U+DF)."
  (declare (optimize speed))            ; so that %char-code-case-fold inlines
  (code-char (the valid-char-code (%char-code-case-fold (char-code c) *lower-to-upper*))))




(defun %char-code-downcase (code)
  (declare (type (mod #x110000) code))
  (let* ((table *upper-to-lower*))
    (declare (type (simple-array (signed-byte 16) (*)) table))
    (if (>= code (length table))
      code
      (locally (declare (optimize (speed 3) (safety 0)))
        (the fixnum (+ code (the (signed-byte 16) (aref table code))))))))


;;;True for a-z, and maybe other things.
(defun lower-case-p (c)
  "The argument must be a character object; LOWER-CASE-P returns T if the
   argument is a lower-case character, NIL otherwise."
  (let* ((code (char-code c))
         (table *lower-to-upper*))
    (declare (type (mod #x110000) code)
             (type (simple-array (signed-byte 16) (*)) table))
    (if (< code (length table))
      (not (eql 0 (the (signed-byte 16) (aref table code)))))))



(defstatic *alpha-char-bits*
  (let* ((bits (make-array #x2fa1e :element-type 'bit)))
    (declare (optimize speed)) ;; make sure everything gets inlined that needs to be.
    (dolist (range '((#x0041 . #x005A)
                     (#x0061 . #x007A)
                     #x00AA
                     #x00B5
                     #x00BA
                     (#x00C0 . #x00D6)
                     (#x00D8 . #x00F6)
                     (#x00F8 . #x01BA)
                     #x01BB
                     (#x01BC . #x01BF)
                     (#x01C0 . #x01C3)
                     (#x01C4 . #x0293)
                     #x0294
                     (#x0295 . #x02AF)
                     (#x02B0 . #x02C1)
                     (#x02C6 . #x02D1)
                     (#x02E0 . #x02E4)
                     #x02EC
                     #x02EE
                     #x0345
                     (#x0370 . #x0373)
                     #x0374
                     (#x0376 . #x0377)
                     #x037A
                     (#x037B . #x037D)
                     #x0386
                     (#x0388 . #x038A)
                     #x038C
                     (#x038E . #x03A1)
                     (#x03A3 . #x03F5)
                     (#x03F7 . #x0481)
                     (#x048A . #x0523)
                     (#x0531 . #x0556)
                     #x0559
                     (#x0561 . #x0587)
                     (#x05B0 . #x05BD)
                     #x05BF
                     (#x05C1 . #x05C2)
                     (#x05C4 . #x05C5)
                     #x05C7
                     (#x05D0 . #x05EA)
                     (#x05F0 . #x05F2)
                     (#x0610 . #x061A)
                     (#x0621 . #x063F)
                     #x0640
                     (#x0641 . #x064A)
                     (#x064B . #x0657)
                     (#x0659 . #x065E)
                     (#x066E . #x066F)
                     #x0670
                     (#x0671 . #x06D3)
                     #x06D5
                     (#x06D6 . #x06DC)
                     (#x06E1 . #x06E4)
                     (#x06E5 . #x06E6)
                     (#x06E7 . #x06E8)
                     #x06ED
                     (#x06EE . #x06EF)
                     (#x06FA . #x06FC)
                     #x06FF
                     #x0710
                     #x0711
                     (#x0712 . #x072F)
                     (#x0730 . #x073F)
                     (#x074D . #x07A5)
                     (#x07A6 . #x07B0)
                     #x07B1
                     (#x07CA . #x07EA)
                     (#x07F4 . #x07F5)
                     #x07FA
                     (#x0901 . #x0902)
                     #x0903
                     (#x0904 . #x0939)
                     #x093D
                     (#x093E . #x0940)
                     (#x0941 . #x0948)
                     (#x0949 . #x094C)
                     #x0950
                     (#x0958 . #x0961)
                     (#x0962 . #x0963)
                     #x0971
                     #x0972
                     (#x097B . #x097F)
                     #x0981
                     (#x0982 . #x0983)
                     (#x0985 . #x098C)
                     (#x098F . #x0990)
                     (#x0993 . #x09A8)
                     (#x09AA . #x09B0)
                     #x09B2
                     (#x09B6 . #x09B9)
                     #x09BD
                     (#x09BE . #x09C0)
                     (#x09C1 . #x09C4)
                     (#x09C7 . #x09C8)
                     (#x09CB . #x09CC)
                     #x09CE
                     #x09D7
                     (#x09DC . #x09DD)
                     (#x09DF . #x09E1)
                     (#x09E2 . #x09E3)
                     (#x09F0 . #x09F1)
                     (#x0A01 . #x0A02)
                     #x0A03
                     (#x0A05 . #x0A0A)
                     (#x0A0F . #x0A10)
                     (#x0A13 . #x0A28)
                     (#x0A2A . #x0A30)
                     (#x0A32 . #x0A33)
                     (#x0A35 . #x0A36)
                     (#x0A38 . #x0A39)
                     (#x0A3E . #x0A40)
                     (#x0A41 . #x0A42)
                     (#x0A47 . #x0A48)
                     (#x0A4B . #x0A4C)
                     #x0A51
                     (#x0A59 . #x0A5C)
                     #x0A5E
                     (#x0A70 . #x0A71)
                     (#x0A72 . #x0A74)
                     #x0A75
                     (#x0A81 . #x0A82)
                     #x0A83
                     (#x0A85 . #x0A8D)
                     (#x0A8F . #x0A91)
                     (#x0A93 . #x0AA8)
                     (#x0AAA . #x0AB0)
                     (#x0AB2 . #x0AB3)
                     (#x0AB5 . #x0AB9)
                     #x0ABD
                     (#x0ABE . #x0AC0)
                     (#x0AC1 . #x0AC5)
                     (#x0AC7 . #x0AC8)
                     #x0AC9
                     (#x0ACB . #x0ACC)
                     #x0AD0
                     (#x0AE0 . #x0AE1)
                     (#x0AE2 . #x0AE3)
                     #x0B01
                     (#x0B02 . #x0B03)
                     (#x0B05 . #x0B0C)
                     (#x0B0F . #x0B10)
                     (#x0B13 . #x0B28)
                     (#x0B2A . #x0B30)
                     (#x0B32 . #x0B33)
                     (#x0B35 . #x0B39)
                     #x0B3D
                     #x0B3E
                     #x0B3F
                     #x0B40
                     (#x0B41 . #x0B44)
                     (#x0B47 . #x0B48)
                     (#x0B4B . #x0B4C)
                     #x0B56
                     #x0B57
                     (#x0B5C . #x0B5D)
                     (#x0B5F . #x0B61)
                     (#x0B62 . #x0B63)
                     #x0B71
                     #x0B82
                     #x0B83
                     (#x0B85 . #x0B8A)
                     (#x0B8E . #x0B90)
                     (#x0B92 . #x0B95)
                     (#x0B99 . #x0B9A)
                     #x0B9C
                     (#x0B9E . #x0B9F)
                     (#x0BA3 . #x0BA4)
                     (#x0BA8 . #x0BAA)
                     (#x0BAE . #x0BB9)
                     (#x0BBE . #x0BBF)
                     #x0BC0
                     (#x0BC1 . #x0BC2)
                     (#x0BC6 . #x0BC8)
                     (#x0BCA . #x0BCC)
                     #x0BD0
                     #x0BD7
                     (#x0C01 . #x0C03)
                     (#x0C05 . #x0C0C)
                     (#x0C0E . #x0C10)
                     (#x0C12 . #x0C28)
                     (#x0C2A . #x0C33)
                     (#x0C35 . #x0C39)
                     #x0C3D
                     (#x0C3E . #x0C40)
                     (#x0C41 . #x0C44)
                     (#x0C46 . #x0C48)
                     (#x0C4A . #x0C4C)
                     (#x0C55 . #x0C56)
                     (#x0C58 . #x0C59)
                     (#x0C60 . #x0C61)
                     (#x0C62 . #x0C63)
                     (#x0C82 . #x0C83)
                     (#x0C85 . #x0C8C)
                     (#x0C8E . #x0C90)
                     (#x0C92 . #x0CA8)
                     (#x0CAA . #x0CB3)
                     (#x0CB5 . #x0CB9)
                     #x0CBD
                     #x0CBE
                     #x0CBF
                     (#x0CC0 . #x0CC4)
                     #x0CC6
                     (#x0CC7 . #x0CC8)
                     (#x0CCA . #x0CCB)
                     #x0CCC
                     (#x0CD5 . #x0CD6)
                     #x0CDE
                     (#x0CE0 . #x0CE1)
                     (#x0CE2 . #x0CE3)
                     (#x0D02 . #x0D03)
                     (#x0D05 . #x0D0C)
                     (#x0D0E . #x0D10)
                     (#x0D12 . #x0D28)
                     (#x0D2A . #x0D39)
                     #x0D3D
                     (#x0D3E . #x0D40)
                     (#x0D41 . #x0D44)
                     (#x0D46 . #x0D48)
                     (#x0D4A . #x0D4C)
                     #x0D57
                     (#x0D60 . #x0D61)
                     (#x0D62 . #x0D63)
                     (#x0D7A . #x0D7F)
                     (#x0D82 . #x0D83)
                     (#x0D85 . #x0D96)
                     (#x0D9A . #x0DB1)
                     (#x0DB3 . #x0DBB)
                     #x0DBD
                     (#x0DC0 . #x0DC6)
                     (#x0DCF . #x0DD1)
                     (#x0DD2 . #x0DD4)
                     #x0DD6
                     (#x0DD8 . #x0DDF)
                     (#x0DF2 . #x0DF3)
                     (#x0E01 . #x0E30)
                     #x0E31
                     (#x0E32 . #x0E33)
                     (#x0E34 . #x0E3A)
                     (#x0E40 . #x0E45)
                     #x0E46
                     #x0E4D
                     (#x0E81 . #x0E82)
                     #x0E84
                     (#x0E87 . #x0E88)
                     #x0E8A
                     #x0E8D
                     (#x0E94 . #x0E97)
                     (#x0E99 . #x0E9F)
                     (#x0EA1 . #x0EA3)
                     #x0EA5
                     #x0EA7
                     (#x0EAA . #x0EAB)
                     (#x0EAD . #x0EB0)
                     #x0EB1
                     (#x0EB2 . #x0EB3)
                     (#x0EB4 . #x0EB9)
                     (#x0EBB . #x0EBC)
                     #x0EBD
                     (#x0EC0 . #x0EC4)
                     #x0EC6
                     #x0ECD
                     (#x0EDC . #x0EDD)
                     #x0F00
                     (#x0F40 . #x0F47)
                     (#x0F49 . #x0F6C)
                     (#x0F71 . #x0F7E)
                     #x0F7F
                     (#x0F80 . #x0F81)
                     (#x0F88 . #x0F8B)
                     (#x0F90 . #x0F97)
                     (#x0F99 . #x0FBC)
                     (#x1000 . #x102A)
                     (#x102B . #x102C)
                     (#x102D . #x1030)
                     #x1031
                     (#x1032 . #x1036)
                     #x1038
                     (#x103B . #x103C)
                     (#x103D . #x103E)
                     #x103F
                     (#x1050 . #x1055)
                     (#x1056 . #x1057)
                     (#x1058 . #x1059)
                     (#x105A . #x105D)
                     (#x105E . #x1060)
                     #x1061
                     #x1062
                     (#x1065 . #x1066)
                     (#x1067 . #x1068)
                     (#x106E . #x1070)
                     (#x1071 . #x1074)
                     (#x1075 . #x1081)
                     #x1082
                     (#x1083 . #x1084)
                     (#x1085 . #x1086)
                     #x108E
                     (#x10A0 . #x10C5)
                     (#x10D0 . #x10FA)
                     #x10FC
                     (#x1100 . #x1159)
                     (#x115F . #x11A2)
                     (#x11A8 . #x11F9)
                     (#x1200 . #x1248)
                     (#x124A . #x124D)
                     (#x1250 . #x1256)
                     #x1258
                     (#x125A . #x125D)
                     (#x1260 . #x1288)
                     (#x128A . #x128D)
                     (#x1290 . #x12B0)
                     (#x12B2 . #x12B5)
                     (#x12B8 . #x12BE)
                     #x12C0
                     (#x12C2 . #x12C5)
                     (#x12C8 . #x12D6)
                     (#x12D8 . #x1310)
                     (#x1312 . #x1315)
                     (#x1318 . #x135A)
                     #x135F
                     (#x1380 . #x138F)
                     (#x13A0 . #x13F4)
                     (#x1401 . #x166C)
                     (#x166F . #x1676)
                     (#x1681 . #x169A)
                     (#x16A0 . #x16EA)
                     (#x16EE . #x16F0)
                     (#x1700 . #x170C)
                     (#x170E . #x1711)
                     (#x1712 . #x1713)
                     (#x1720 . #x1731)
                     (#x1732 . #x1733)
                     (#x1740 . #x1751)
                     (#x1752 . #x1753)
                     (#x1760 . #x176C)
                     (#x176E . #x1770)
                     (#x1772 . #x1773)
                     (#x1780 . #x17B3)
                     #x17B6
                     (#x17B7 . #x17BD)
                     (#x17BE . #x17C5)
                     #x17C6
                     (#x17C7 . #x17C8)
                     #x17D7
                     #x17DC
                     (#x1820 . #x1842)
                     #x1843
                     (#x1844 . #x1877)
                     (#x1880 . #x18A8)
                     #x18A9
                     #x18AA
                     (#x1900 . #x191C)
                     (#x1920 . #x1922)
                     (#x1923 . #x1926)
                     (#x1927 . #x1928)
                     (#x1929 . #x192B)
                     (#x1930 . #x1931)
                     #x1932
                     (#x1933 . #x1938)
                     (#x1950 . #x196D)
                     (#x1970 . #x1974)
                     (#x1980 . #x19A9)
                     (#x19B0 . #x19C0)
                     (#x19C1 . #x19C7)
                     (#x19C8 . #x19C9)
                     (#x1A00 . #x1A16)
                     (#x1A17 . #x1A18)
                     (#x1A19 . #x1A1B)
                     (#x1B00 . #x1B03)
                     #x1B04
                     (#x1B05 . #x1B33)
                     #x1B35
                     (#x1B36 . #x1B3A)
                     #x1B3B
                     #x1B3C
                     (#x1B3D . #x1B41)
                     #x1B42
                     #x1B43
                     (#x1B45 . #x1B4B)
                     (#x1B80 . #x1B81)
                     #x1B82
                     (#x1B83 . #x1BA0)
                     #x1BA1
                     (#x1BA2 . #x1BA5)
                     (#x1BA6 . #x1BA7)
                     (#x1BA8 . #x1BA9)
                     (#x1BAE . #x1BAF)
                     (#x1C00 . #x1C23)
                     (#x1C24 . #x1C2B)
                     (#x1C2C . #x1C33)
                     (#x1C34 . #x1C35)
                     (#x1C4D . #x1C4F)
                     (#x1C5A . #x1C77)
                     (#x1C78 . #x1C7D)
                     (#x1D00 . #x1D2B)
                     (#x1D2C . #x1D61)
                     (#x1D62 . #x1D77)
                     #x1D78
                     (#x1D79 . #x1D9A)
                     (#x1D9B . #x1DBF)
                     (#x1E00 . #x1F15)
                     (#x1F18 . #x1F1D)
                     (#x1F20 . #x1F45)
                     (#x1F48 . #x1F4D)
                     (#x1F50 . #x1F57)
                     #x1F59
                     #x1F5B
                     #x1F5D
                     (#x1F5F . #x1F7D)
                     (#x1F80 . #x1FB4)
                     (#x1FB6 . #x1FBC)
                     #x1FBE
                     (#x1FC2 . #x1FC4)
                     (#x1FC6 . #x1FCC)
                     (#x1FD0 . #x1FD3)
                     (#x1FD6 . #x1FDB)
                     (#x1FE0 . #x1FEC)
                     (#x1FF2 . #x1FF4)
                     (#x1FF6 . #x1FFC)
                     #x2071
                     #x207F
                     (#x2090 . #x2094)
                     #x2102
                     #x2107
                     (#x210A . #x2113)
                     #x2115
                     (#x2119 . #x211D)
                     #x2124
                     #x2126
                     #x2128
                     (#x212A . #x212D)
                     (#x212F . #x2134)
                     (#x2135 . #x2138)
                     #x2139
                     (#x213C . #x213F)
                     (#x2145 . #x2149)
                     #x214E
                     (#x2160 . #x2182)
                     (#x2183 . #x2184)
                     (#x2185 . #x2188)
                     (#x24B6 . #x24E9)
                     (#x2C00 . #x2C2E)
                     (#x2C30 . #x2C5E)
                     (#x2C60 . #x2C6F)
                     (#x2C71 . #x2C7C)
                     #x2C7D
                     (#x2C80 . #x2CE4)
                     (#x2D00 . #x2D25)
                     (#x2D30 . #x2D65)
                     #x2D6F
                     (#x2D80 . #x2D96)
                     (#x2DA0 . #x2DA6)
                     (#x2DA8 . #x2DAE)
                     (#x2DB0 . #x2DB6)
                     (#x2DB8 . #x2DBE)
                     (#x2DC0 . #x2DC6)
                     (#x2DC8 . #x2DCE)
                     (#x2DD0 . #x2DD6)
                     (#x2DD8 . #x2DDE)
                     (#x2DE0 . #x2DFF)
                     #x2E2F
                     #x3005
                     #x3006
                     #x3007
                     (#x3021 . #x3029)
                     (#x3031 . #x3035)
                     (#x3038 . #x303A)
                     #x303B
                     #x303C
                     (#x3041 . #x3096)
                     (#x309D . #x309E)
                     #x309F
                     (#x30A1 . #x30FA)
                     (#x30FC . #x30FE)
                     #x30FF
                     (#x3105 . #x312D)
                     (#x3131 . #x318E)
                     (#x31A0 . #x31B7)
                     (#x31F0 . #x31FF)
                     (#x3400 . #x4DB5)
                     (#x4E00 . #x9FC3)
                     (#xA000 . #xA014)
                     #xA015
                     (#xA016 . #xA48C)
                     (#xA500 . #xA60B)
                     #xA60C
                     (#xA610 . #xA61F)
                     (#xA62A . #xA62B)
                     (#xA640 . #xA65F)
                     (#xA662 . #xA66D)
                     #xA66E
                     #xA67F
                     (#xA680 . #xA697)
                     (#xA717 . #xA71F)
                     (#xA722 . #xA76F)
                     #xA770
                     (#xA771 . #xA787)
                     #xA788
                     (#xA78B . #xA78C)
                     (#xA7FB . #xA801)
                     (#xA803 . #xA805)
                     (#xA807 . #xA80A)
                     (#xA80C . #xA822)
                     (#xA823 . #xA824)
                     (#xA825 . #xA826)
                     #xA827
                     (#xA840 . #xA873)
                     (#xA880 . #xA881)
                     (#xA882 . #xA8B3)
                     (#xA8B4 . #xA8C3)
                     (#xA90A . #xA925)
                     (#xA926 . #xA92A)
                     (#xA930 . #xA946)
                     (#xA947 . #xA951)
                     #xA952
                     (#xAA00 . #xAA28)
                     (#xAA29 . #xAA2E)
                     (#xAA2F . #xAA30)
                     (#xAA31 . #xAA32)
                     (#xAA33 . #xAA34)
                     (#xAA35 . #xAA36)
                     (#xAA40 . #xAA42)
                     #xAA43
                     (#xAA44 . #xAA4B)
                     #xAA4C
                     #xAA4D
                     (#xAC00 . #xD7A3)
                     (#xF900 . #xFA2D)
                     (#xFA30 . #xFA6A)
                     (#xFA70 . #xFAD9)
                     (#xFB00 . #xFB06)
                     (#xFB13 . #xFB17)
                     #xFB1D
                     #xFB1E
                     (#xFB1F . #xFB28)
                     (#xFB2A . #xFB36)
                     (#xFB38 . #xFB3C)
                     #xFB3E
                     (#xFB40 . #xFB41)
                     (#xFB43 . #xFB44)
                     (#xFB46 . #xFBB1)
                     (#xFBD3 . #xFD3D)
                     (#xFD50 . #xFD8F)
                     (#xFD92 . #xFDC7)
                     (#xFDF0 . #xFDFB)
                     (#xFE70 . #xFE74)
                     (#xFE76 . #xFEFC)
                     (#xFF21 . #xFF3A)
                     (#xFF41 . #xFF5A)
                     (#xFF66 . #xFF6F)
                     #xFF70
                     (#xFF71 . #xFF9D)
                     (#xFF9E . #xFF9F)
                     (#xFFA0 . #xFFBE)
                     (#xFFC2 . #xFFC7)
                     (#xFFCA . #xFFCF)
                     (#xFFD2 . #xFFD7)
                     (#xFFDA . #xFFDC)
                     (#x10000 . #x1000B)
                     (#x1000D . #x10026)
                     (#x10028 . #x1003A)
                     (#x1003C . #x1003D)
                     (#x1003F . #x1004D)
                     (#x10050 . #x1005D)
                     (#x10080 . #x100FA)
                     (#x10140 . #x10174)
                     (#x10280 . #x1029C)
                     (#x102A0 . #x102D0)
                     (#x10300 . #x1031E)
                     (#x10330 . #x10340)
                     #x10341
                     (#x10342 . #x10349)
                     #x1034A
                     (#x10380 . #x1039D)
                     (#x103A0 . #x103C3)
                     (#x103C8 . #x103CF)
                     (#x103D1 . #x103D5)
                     (#x10400 . #x1044F)
                     (#x10450 . #x1049D)
                     (#x10800 . #x10805)
                     #x10808
                     (#x1080A . #x10835)
                     (#x10837 . #x10838)
                     #x1083C
                     #x1083F
                     (#x10900 . #x10915)
                     (#x10920 . #x10939)
                     #x10A00
                     (#x10A01 . #x10A03)
                     (#x10A05 . #x10A06)
                     (#x10A0C . #x10A0F)
                     (#x10A10 . #x10A13)
                     (#x10A15 . #x10A17)
                     (#x10A19 . #x10A33)
                     (#x12000 . #x1236E)
                     (#x12400 . #x12462)
                     (#x1D400 . #x1D454)
                     (#x1D456 . #x1D49C)
                     (#x1D49E . #x1D49F)
                     #x1D4A2
                     (#x1D4A5 . #x1D4A6)
                     (#x1D4A9 . #x1D4AC)
                     (#x1D4AE . #x1D4B9)
                     #x1D4BB
                     (#x1D4BD . #x1D4C3)
                     (#x1D4C5 . #x1D505)
                     (#x1D507 . #x1D50A)
                     (#x1D50D . #x1D514)
                     (#x1D516 . #x1D51C)
                     (#x1D51E . #x1D539)
                     (#x1D53B . #x1D53E)
                     (#x1D540 . #x1D544)
                     #x1D546
                     (#x1D54A . #x1D550)
                     (#x1D552 . #x1D6A5)
                     (#x1D6A8 . #x1D6C0)
                     (#x1D6C2 . #x1D6DA)
                     (#x1D6DC . #x1D6FA)
                     (#x1D6FC . #x1D714)
                     (#x1D716 . #x1D734)
                     (#x1D736 . #x1D74E)
                     (#x1D750 . #x1D76E)
                     (#x1D770 . #x1D788)
                     (#x1D78A . #x1D7A8)
                     (#x1D7AA . #x1D7C2)
                     (#x1D7C4 . #x1D7CB)
                     (#x20000 . #x2A6D6)
                     (#x2F800 . #x2FA1D))
             bits)
      (let* ((low (if (atom range) range (car range)))
             (high (1+ (if (atom range) range (cdr range)))))
        (do* ((i low (1+ i)))
             ((= i high))
          (setf (sbit bits i) 1))))))


(defun alpha-char-p (c)
  "The argument must be a character object. ALPHA-CHAR-P returns T if the
   argument is an alphabetic character; otherwise NIL."
  (let* ((code (char-code c))
         (bits *alpha-char-bits*))
    (declare (type (mod #x110000) code)
             (simple-bit-vector bits))
    (and (< code (length bits))
         (not (eql 0 (sbit bits code))))))


;;; def-accessors type-tracking stuff.  Used by inspector
(defvar *def-accessor-types* nil)

(defun add-accessor-types (types names)
  (dolist (type types)
    (let ((cell (or (assq type *def-accessor-types*)
                    (car (push (cons type nil) *def-accessor-types*)))))
      (setf (cdr cell) (if (vectorp names) names (%list-to-uvector nil names))))))


;;; Some simple explicit storage management for cons cells

(def-standard-initial-binding *cons-pool* (%cons-pool nil))

(defun cheap-cons (car cdr)
  (let* ((pool *cons-pool*)
         (cons (pool.data pool)))
    (if cons
      (locally (declare (type cons cons))
        (setf (pool.data pool) (cdr cons)
              (car cons) car
              (cdr cons) cdr)
        cons)
      (cons car cdr))))

(defun free-cons (cons)
  (when (consp cons)
    (locally (declare (type cons cons))
      (setf (car cons) nil
            (cdr cons) nil)
      (let* ((pool *cons-pool*)
             (freelist (pool.data pool)))
        (setf (pool.data pool) cons
              (cdr cons) freelist)))))

(defun cheap-copy-list (list)
  (let ((l list)
        res)
    (loop
      (when (atom l)
        (return (nreconc res l)))
      (setq res (cheap-cons (pop l) res)))))

(defun cheap-list (&rest args)
  (declare (dynamic-extent args))
  (cheap-copy-list args))

;;; Works for dotted lists
(defun cheap-free-list (list)
  (let ((l list)
        next-l)
    (loop
      (setq next-l (cdr l))
      (free-cons l)
      (when (atom (setq l next-l))
        (return)))))

(defmacro pop-and-free (place)
  (setq place (require-type place 'symbol))     ; all I need for now.
  (let ((list (gensym))
        (cdr (gensym)))
    `(let* ((,list ,place)
            (,cdr (cdr ,list)))
       (prog1
         (car ,list)
         (setf ,place ,cdr)
         (free-cons ,list)))))

;;; Support for defresource & using-resource macros
(defun make-resource (constructor &key destructor initializer)
  (%cons-resource constructor destructor initializer))

(defun allocate-resource (resource)
  (setq resource (require-type resource 'resource))
  (with-lock-grabbed ((resource.lock resource))
    (let ((pool (resource.pool resource))
          res)
      (let ((data (pool.data pool)))
        (when data
          (setf res (car data)
                (pool.data pool) (cdr (the cons data)))
          (free-cons data)))
      (if res
        (let ((initializer (resource.initializer resource)))
          (when initializer
            (funcall initializer res)))
        (setq res (funcall (resource.constructor resource))))
      res)))

(defun free-resource (resource instance)
  (setq resource (require-type resource 'resource))
  (with-lock-grabbed ((resource.lock resource))
    (let ((pool (resource.pool resource))
          (destructor (resource.destructor resource)))
      (when destructor
        (funcall destructor instance))
      (setf (pool.data pool)
            (cheap-cons instance (pool.data pool)))))
  resource)

(defun valid-char-code-p (code)
  (and (typep code 'fixnum)
       (locally (declare (fixnum code))
         (and 
          (>= code 0)
          (< code #x110000)
          (or (< code #xfffe)
              (> code #xffff))
          (or (< code #xd800)
              (> code #xdfff))))))


(defpackage #.(ftd-interface-package-name
               (backend-target-foreign-type-data *target-backend*))
  (:nicknames "OS")
  (:use "COMMON-LISP"))






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-aprims.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-sysio.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defstruct (file-ioblock (:include ioblock))
  (octet-pos 0 )                       ; current io position in octets
  (fileeof 0 )                          ; file length in elements
  )




;;; The file-ioblock-octet-pos field is the (octet) position
;;; at which the next I/O operation will begin (e.g., where the
;;; input came from and/or where the output's going.)  There are
;;; cases (e.g., after a STREAM-CLEAR-INPUT) when this can't be
;;; determined (based on its previous value and the logical size
;;; of the buffer) so we'll have to ask the OS.

(defun file-octet-filepos (file-ioblock)
  (fd-tell (file-ioblock-device file-ioblock)))

(defun synch-file-octet-filepos (file-ioblock)
  (setf (file-ioblock-octet-pos file-ioblock)
	(file-octet-filepos file-ioblock)))

(defun infer-character-encoding (file-ioblock)
  (let* ((inbuf (file-ioblock-inbuf file-ioblock))
         (bufptr (io-buffer-bufptr inbuf))
         (n (io-buffer-count inbuf)))
    (when (zerop n)
      (setq n (or (fd-stream-advance (file-ioblock-stream file-ioblock)
                                     file-ioblock
                                     t)
                  0)))
    (setf (stream-external-format (file-ioblock-stream file-ioblock))
          (or (external-format-from-octet-buffer bufptr n)
              (normalize-external-format :file (file-ioblock-line-termination file-ioblock))))))
    

(defun infer-line-termination (file-ioblock)
  (let* ((encoding (or (file-ioblock-encoding file-ioblock)
                       (get-character-encoding nil)))
         (inbuf (file-ioblock-inbuf file-ioblock))
         (buffer (io-buffer-buffer inbuf))
         (n (io-buffer-count inbuf)))
    (when (zerop n)
      (setq n (or (fd-stream-advance (file-ioblock-stream file-ioblock)
                                     file-ioblock
                                     t)
                  0)))
    (multiple-value-bind (nchars last)
        (funcall (character-encoding-length-of-vector-encoding-function encoding)
                 buffer
                 0
                 n)
      (declare (fixnum nchars last))
      (let* ((string (make-string nchars)))
        (declare (dynamic-extent string))
        (decode-character-encoded-vector encoding buffer 0 last string)
        (let* ((line-termination
                (do* ((i 0 (1+ i))
                      (last-was-cr nil))
                     ((= i nchars) (if last-was-cr :cr))
                  (declare (fixnum i))
                  (let* ((char (schar string i)))
                    (if last-was-cr
                      (if (eq char #\Linefeed)
                        (return :crlf)
                        (return :cr))
                      (case char
                        (#\Newline (return nil))
                        (#\Line_Separator (return :unicode))
                        (#\Return (setq last-was-cr t))))))))
          (when line-termination
            (install-ioblock-input-line-termination file-ioblock line-termination)
            (when (file-ioblock-outbuf file-ioblock)
              (install-ioblock-output-line-termination file-ioblock line-termination))))))
    (when (eq (ioblock-owner file-ioblock) *current-process*)
      (setf (ioblock-owner file-ioblock) 0))))



(defvar *default-external-format* :unix)

(defvar *default-file-character-encoding* :utf-8)

(defmethod default-character-encoding ((domain (eql :file)))
  *default-file-character-encoding*)

(defvar *default-line-termination* :unix
  "The value of this variable is used when :EXTERNAL-FORMAT is
unspecified or specified as :DEFAULT. It can meaningfully be given any
of the values :UNIX, :MACOS, :MSDOS, :UNICODE or :INFERRED, each of which is
interpreted as described in the documentation.

Because there's some risk that unsolicited newline translation could have
undesirable consequences, the initial value of this variable in Clozure CL
is :UNIX.")

(defstruct (external-format (:constructor %make-external-format)
                            (:copier nil))
  (character-encoding :default :read-only t)
  (line-termination :default :read-only t))

(defmethod print-object ((ef external-format) stream)
  (print-unreadable-object (ef stream :type t :identity t)
    (format stream "~s/~s" (external-format-character-encoding ef) (external-format-line-termination ef))))



(defvar *external-formats* (make-hash-table :test #'equal))

(defun make-external-format (&key (domain t)
                                  (character-encoding :default)
                                  (line-termination :default))
  (if (eq line-termination :default)
    (setq line-termination *default-line-termination*))
  (unless (assq line-termination *canonical-line-termination-conventions*)
    (error "~S is not a known line-termination format." line-termination))

  (if (eq character-encoding :default)
    (setq character-encoding
          (default-character-encoding domain)))
  (unless (or (lookup-character-encoding character-encoding)
              (and (eq domain :file) (eq character-encoding :inferred)))
    (error "~S is not the name of a known character encoding."
           character-encoding))
  (let* ((pair (cons character-encoding line-termination)))
    (declare (dynamic-extent pair))    
    (or (gethash pair *external-formats*)
        (setf (gethash (cons character-encoding line-termination) *external-formats*)
              (%make-external-format :character-encoding character-encoding
                                     :line-termination line-termination)))))



(defun normalize-external-format (domain external-format)
  (cond ((listp external-format)
         (unless (plistp external-format)
           (error "External-format ~s is not a property list." external-format))
         (normalize-external-format domain (apply #'make-external-format :domain domain  external-format)))
        ((typep external-format 'external-format)
         external-format)
        ((eq external-format :inferred)
         (make-external-format :domain domain :character-encoding :inferred :line-termination :inferred))
        ((eq external-format :default)
         (normalize-external-format domain *default-external-format*))
        ((lookup-character-encoding external-format)
         (normalize-external-format domain `(:character-encoding ,external-format)))
        ((assq external-format *canonical-line-termination-conventions*)
         (normalize-external-format domain `(:line-termination ,external-format)))
        (t
         (error "Invalid external-format: ~s" external-format))))
               
           
    




;;; Establish a new position for the specified file-stream.
(defun file-ioblock-seek (file-ioblock newoctetpos)
  (let* ((result (fd-lseek
		  (file-ioblock-device file-ioblock) newoctetpos #$SEEK_SET)))
    (if (< result 0)
      (error 'simple-stream-error
	     :stream (file-ioblock-stream file-ioblock)
	     :format-control (format nil "Can't set file position to ~d: ~a"
				     newoctetpos (%strerror result)))
      newoctetpos)))

;;; For input streams, getting/setting the position is fairly simple.
;;; Getting the position is a simple matter of adding the buffer
;;; origin to the current position within the buffer.
;;; Setting the position involves either adjusting the buffer index
;;; (if the new position is within the current buffer) or seeking
;;; to a new position.

(defun %ioblock-input-file-position (file-ioblock newpos)
  (let* ((octet-base (file-ioblock-octet-pos file-ioblock))
	 (element-base (ioblock-octets-to-elements file-ioblock octet-base))
	 (inbuf (file-ioblock-inbuf file-ioblock))
	 (curpos (+ element-base (io-buffer-idx inbuf))))
    (if (null newpos)
      curpos
      (progn
	(if (and (>= newpos element-base)
		 (< newpos (+ element-base (io-buffer-count inbuf))))
	  (setf (io-buffer-idx inbuf) (- newpos element-base))
	  (file-ioblock-seek-and-reset file-ioblock
				       (ioblock-elements-to-octets
					file-ioblock
					newpos)))
	newpos))))

;;; For (pure) output streams, it's a little more complicated.  If we
;;; have to seek to a new origin, we may need to flush the buffer
;;; first.

(defun %ioblock-output-file-position (file-ioblock newpos)
  (let* ((octet-base (file-ioblock-octet-pos file-ioblock))
	 (element-base (ioblock-octets-to-elements file-ioblock octet-base))
	 (outbuf (file-ioblock-outbuf file-ioblock))
	 (curpos (+ element-base (io-buffer-idx outbuf)))
	 (maxpos (+ element-base (io-buffer-count outbuf))))
    (if (null newpos)
      curpos
      (progn
        (unless (= newpos 0)
          (setf (ioblock-pending-byte-order-mark file-ioblock) nil))
	(if (and (>= newpos element-base)
		 (<= newpos maxpos))
	  ;; Backing up is easy.  Skipping forward (without flushing
	  ;; and seeking) would be hard, 'cause we can't tell what
	  ;; we're skipping over.
	  (let* ((newidx (- newpos element-base)))
	    (setf (io-buffer-idx outbuf) newidx))
	  (progn
	    (when (file-ioblock-dirty file-ioblock)
	      (fd-stream-force-output (file-ioblock-stream file-ioblock)
                                      file-ioblock
                                      (io-buffer-count outbuf)
                                      nil)
	      ;; May have just extended the file; may need to update
	      ;; fileeof.
	      (when (> maxpos (file-ioblock-fileeof file-ioblock))
		(setf (file-ioblock-fileeof file-ioblock) maxpos)))
	    (file-ioblock-seek-and-reset file-ioblock
					 (ioblock-elements-to-octets
					  file-ioblock
					  newpos))))
	newpos))))

;;; For I/O file streams, there's an additional complication: if we
;;; back up within the (shared) buffer and the old position was beyond
;;; the buffer's input count, we have to set the input count to the
;;; old position.  (Consider the case of writing a single element at
;;; the end-of-file, backing up one element, then reading the element
;;; we wrote.)  We -can- skip forward over stuff that's been read;
;;; if the buffer's dirty, we'll eventually write it back out.

(defun %ioblock-io-file-position (file-ioblock newpos)
  (let* ((octet-base (file-ioblock-octet-pos file-ioblock))
	 (element-base (ioblock-octets-to-elements file-ioblock octet-base))
	 (outbuf (file-ioblock-outbuf file-ioblock)) ; outbuf = inbuf
	 (curidx (io-buffer-idx outbuf))
	 (curpos (+ element-base curidx)))
    (if (null newpos)
      curpos
      (let* ((incount (io-buffer-count outbuf)))
        (unless (= newpos 0)
          (setf (ioblock-pending-byte-order-mark file-ioblock) nil))        
	(cond 
	  ((and (>= newpos element-base)
		(<= newpos curpos))
	   ;; If we've read less than we've written, make what's
	   ;; been written available for subsequent input.
	   (when (> curidx incount)
	     (setf (io-buffer-count outbuf) curidx))
	   (setf (io-buffer-idx outbuf) (- newpos element-base)))
	  ((and (>= newpos element-base)
		(< newpos (+ element-base incount)))
	   (setf (io-buffer-idx outbuf) (- newpos element-base)))
	  (t
	   (let* ((maxpos (+ element-base (io-buffer-count outbuf))))
	     (when (> maxpos (file-ioblock-fileeof file-ioblock))
	       (setf (file-ioblock-fileeof file-ioblock) maxpos)))
	   (when (file-ioblock-dirty file-ioblock)
	     (file-ioblock-seek file-ioblock octet-base)
	     (fd-stream-force-output (file-ioblock-stream file-ioblock)
                                     file-ioblock
                                     (io-buffer-count outbuf)
                                     nil))
	   (file-ioblock-seek-and-reset file-ioblock
					(ioblock-elements-to-octets
					 file-ioblock newpos))))
	newpos))))

;;; Again, it's simplest to define this in terms of the stream's direction.
;;; Note that we can't change the size of file descriptors open for input
;;; only.

(defun %ioblock-input-file-length (file-ioblock newlen)
  (unless newlen
    (file-ioblock-fileeof file-ioblock)))
 
(defun %ioblock-output-file-length (file-ioblock newlen)
  (let* ((octet-base (file-ioblock-octet-pos file-ioblock))
	 (element-base (ioblock-octets-to-elements file-ioblock octet-base))
	 (outbuf (file-ioblock-outbuf file-ioblock)) 
	 (curidx (io-buffer-idx outbuf))
	 (maxpos (+ element-base (io-buffer-count outbuf)))
	 (curlen (file-ioblock-fileeof file-ioblock)))
    (if (> maxpos curlen)
      (setf (file-ioblock-fileeof file-ioblock) (setq curlen maxpos)))
    (if (null newlen)
      curlen
      (let* ((fd (file-ioblock-device file-ioblock))
	     (new-octet-eof (ioblock-elements-to-octets file-ioblock newlen))
	     (cur-octet-pos (fd-tell fd)))
	(cond ((> newlen curlen)
	       ;; Extend the file; maintain the current position.
	       ;; ftruncate isn't guaranteed to extend a file past
	       ;; its current EOF.  Seeking to the new EOF, then
	       ;; writing, is guaranteed to do so.  Seek to the
	       ;; new EOF, write a random byte, truncate to the
	       ;; specified length, then seek back to where we
	       ;; were and pretend that nothing happened.
	       (file-ioblock-seek file-ioblock new-octet-eof)
	       (%stack-block ((buf 1))
			     (fd-write fd buf 1))
	       (fd-ftruncate fd new-octet-eof)
	       (file-ioblock-seek file-ioblock cur-octet-pos))
	      ((> newlen maxpos)
	       ;; Make the file shorter.  Doesn't affect
	       ;; our position or anything that we have buffered.
	       (fd-ftruncate fd new-octet-eof))
	      ((< newlen element-base)
	       ;; Discard any buffered output.  Truncate the
	       ;; file, then seek to the new EOF.
	       (fd-ftruncate fd new-octet-eof)
	       (file-ioblock-seek-and-reset file-ioblock new-octet-eof))
	      (t
	       (fd-ftruncate fd new-octet-eof)
	       (let* ((newidx (- newlen element-base)))
		 (when (> maxpos newlen)
		   (setf (io-buffer-count outbuf) newidx))
		 (when (> curidx newidx)
		   (setf (io-buffer-idx outbuf) newidx)))))
	(setf (file-ioblock-fileeof file-ioblock) newlen)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass fundamental-file-stream (fd-stream file-stream)
    ((filename :initform nil :initarg :filename :accessor file-stream-filename)
     (actual-filename :initform nil :initarg :actual-filename)
     (external-format :initform :default :initarg :external-format
		      :accessor file-stream-external-format)))

  

(defmethod stream-filename ((s fundamental-file-stream))
  (file-stream-filename s))

(defmethod stream-actual-filename ((s file-stream))
  (slot-value s 'actual-filename))

(defmethod (setf stream-filename) (new (s fundamental-file-stream))
  (setf (file-stream-filename s) new))

(defmethod (setf stream-actual-filename) (new (s fundamental-file-stream))
  (setf (slot-value s 'actual-filename) new))

(defun print-file-stream (s out)
  (print-unreadable-object (s out :type t :identity t)
    (let* ((file-ioblock (stream-ioblock s nil)))
      (format out "(~s/" (stream-filename s))
      (if file-ioblock
	(format out "~d ~a)" (file-ioblock-device file-ioblock) (encoding-name (ioblock-encoding file-ioblock)))
	(format out ":closed")))))
    
(defmethod print-object ((s fundamental-file-stream) out)
  (print-file-stream s out))

(make-built-in-class 'basic-file-stream 'file-stream 'basic-stream)

(defmethod stream-filename ((s basic-file-stream))
  (basic-file-stream.filename s))

(defmethod stream-actual-filename ((s basic-file-stream))
  (basic-file-stream.actual-filename s))

(defmethod (setf stream-filename) (new (s basic-file-stream))
  (setf (basic-file-stream.filename s) new))

(defmethod (setf stream-actual-filename) (new (s basic-file-stream))
  (setf (basic-file-stream.actual-filename s) new))

(defmethod print-object ((s basic-file-stream) out)
  (print-file-stream s out))


(defmethod initialize-basic-stream ((s basic-file-stream) &key element-type external-format &allow-other-keys)
  (setf (getf (basic-stream.info s) :element-type) element-type)
  (setf (basic-file-stream.external-format s) external-format))

(defmethod stream-create-ioblock ((stream fundamental-file-stream) &rest args &key)
  (declare (dynamic-extent args))
  (apply #'make-file-ioblock :stream stream args))

(defmethod stream-create-ioblock ((stream basic-file-stream) &rest args &key)
  (declare (dynamic-extent args))
  (apply #'make-file-ioblock :stream stream args))

(defclass fundamental-file-input-stream (fundamental-file-stream fd-input-stream)
    ())

(make-built-in-class 'basic-file-input-stream 'basic-file-stream 'basic-input-stream)


(defclass fundamental-file-output-stream (fundamental-file-stream fd-output-stream)
    ())

(make-built-in-class 'basic-file-output-stream 'basic-file-stream 'basic-output-stream)

(defclass fundamental-file-io-stream (fundamental-file-stream fd-io-stream)
    ())

(make-built-in-class 'basic-file-io-stream 'basic-file-stream 'basic-io-stream)


(defclass fundamental-file-character-input-stream (fundamental-file-input-stream
					  fd-character-input-stream)
    ())

(make-built-in-class 'basic-file-character-input-stream 'basic-file-input-stream 'basic-character-input-stream)


(defclass fundamental-file-character-output-stream (fundamental-file-output-stream
                                                    fd-character-output-stream)
    ())

(make-built-in-class 'basic-file-character-output-stream 'basic-file-output-stream 'basic-character-output-stream)

(defclass fundamental-file-character-io-stream (fundamental-file-io-stream
				       fd-character-io-stream)
    ())

(make-built-in-class 'basic-file-character-io-stream 'basic-file-io-stream 'basic-character-io-stream)

(defclass fundamental-file-binary-input-stream (fundamental-file-input-stream
                                                fd-binary-input-stream)
    ())

(make-built-in-class 'basic-file-binary-input-stream 'basic-file-input-stream 'basic-binary-input-stream)

(defclass fundamental-file-binary-output-stream (fundamental-file-output-stream
                                                 fd-binary-output-stream)
    ())

(make-built-in-class 'basic-file-binary-output-stream 'basic-file-output-stream 'basic-binary-output-stream)

(defclass fundamental-file-binary-io-stream (fundamental-file-io-stream fd-binary-io-stream)
    ())

(make-built-in-class 'basic-file-binary-io-stream 'basic-file-io-stream 'basic-binary-io-stream)




;;; This stuff is a lot simpler if we restrict the hair to the
;;; case of file streams opened in :io mode (which have to worry
;;; about flushing the shared buffer before filling it, and things
;;; like that.)

(defmethod stream-clear-input ((f fundamental-file-input-stream))
  (with-stream-ioblock-input (file-ioblock f :speedy t)
    (call-next-method)
    (synch-file-octet-filepos file-ioblock)
    nil))


(defmethod stream-clear-input ((f basic-file-input-stream))
  (let* ((file-ioblock (basic-stream-ioblock f)))
    (with-ioblock-input-locked (file-ioblock)
      (call-next-method)
      (synch-file-octet-filepos file-ioblock)
      nil)))

    
(defmethod stream-clear-input ((f fundamental-file-io-stream))
  (with-stream-ioblock-input (file-ioblock f :speedy t)
    (stream-force-output f)		
    (call-next-method)
    (synch-file-octet-filepos file-ioblock)
    nil))

(defmethod stream-clear-input ((f basic-file-io-stream))
  (let* ((file-ioblock (basic-stream-ioblock f)))
    (with-ioblock-input-locked (file-ioblock)
      (call-next-method)
      (synch-file-octet-filepos file-ioblock)
      nil)))

(defmethod stream-clear-output ((f fundamental-file-output-stream))
  (with-stream-ioblock-output (file-ioblock f :speedy t)
    (call-next-method)
    (synch-file-octet-filepos file-ioblock)
    nil))

(defmethod stream-clear-output ((f basic-file-output-stream))
  (let* ((file-ioblock (basic-stream-ioblock f)))
    (with-ioblock-input-locked (file-ioblock)
      (call-next-method)
      (synch-file-octet-filepos file-ioblock)
      nil)))


  
;;; If we've been reading, the file position where we're going
;;; to read this time is (+ where-it-was-last-time what-we-read-last-time.)
(defun input-file-ioblock-advance (stream file-ioblock read-p)
  (let* ((newpos (+ (file-ioblock-octet-pos file-ioblock)
		    (io-buffer-count (file-ioblock-inbuf file-ioblock)))))
    (setf (file-ioblock-octet-pos file-ioblock) newpos)
    (fd-stream-advance stream file-ioblock read-p)))

;;; If the buffer's dirty, we have to back up and rewrite it before
;;; reading in a new buffer.
(defun io-file-ioblock-advance (stream file-ioblock read-p)
  (let* ((curpos (file-ioblock-octet-pos file-ioblock))
	 (count (io-buffer-count (file-ioblock-inbuf file-ioblock)))
	 (newpos (+ curpos 
		    (ioblock-elements-to-octets file-ioblock count))))
    (when (ioblock-dirty file-ioblock)
      (file-ioblock-seek file-ioblock curpos)
      (fd-stream-force-output stream file-ioblock count nil))
    (unless (eql newpos (file-octet-filepos file-ioblock))
      (error "Expected newpos to be ~d, fd is at ~d"
	     newpos (file-octet-filepos file-ioblock)))
    (setf (file-ioblock-octet-pos file-ioblock) newpos)
    (fd-stream-advance stream file-ioblock read-p)))

		    
(defun output-file-force-output (stream file-ioblock count finish-p)
  (let* ((pos (%ioblock-output-file-position file-ioblock nil))
         (n (fd-stream-force-output stream file-ioblock count finish-p)))
    (incf (file-ioblock-octet-pos file-ioblock) (or n 0))
    (%ioblock-output-file-position file-ioblock pos)
    n))

;;; Can't be sure where the underlying fd is positioned, so seek first.
(defun io-file-force-output (stream file-ioblock count finish-p)
  (let* ((pos (%ioblock-io-file-position file-ioblock nil)))
    (file-ioblock-seek file-ioblock (file-ioblock-octet-pos file-ioblock))
    (let* ((n (fd-stream-force-output stream file-ioblock count finish-p)))
      (incf (file-ioblock-octet-pos file-ioblock) (or n 0))
      (%ioblock-io-file-position file-ioblock pos)
      n)))


;;; Invalidate both buffers and seek to the new position.  The output
;;; buffer's been flushed already if it needed to be.

(defun file-ioblock-seek-and-reset (file-ioblock newoctetpos)
  (let* ((inbuf (file-ioblock-inbuf file-ioblock))
	 (outbuf (file-ioblock-outbuf file-ioblock)))
    (setf (file-ioblock-dirty file-ioblock) nil)
    (when inbuf
      (setf (io-buffer-count inbuf) 0
	    (io-buffer-idx inbuf) 0))
    (when outbuf
      (setf (io-buffer-count outbuf) 0
	    (io-buffer-idx outbuf) 0))
    (setf (file-ioblock-octet-pos file-ioblock) newoctetpos)
    (file-ioblock-seek file-ioblock newoctetpos)))

(defmethod stream-position ((stream fundamental-file-input-stream) &optional newpos)
  (with-stream-ioblock-input (file-ioblock stream :speedy t)
    (%ioblock-input-file-position file-ioblock newpos)))


(defmethod stream-position ((stream basic-file-input-stream) &optional newpos)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (file-ioblock)
      (%ioblock-input-file-position file-ioblock newpos))))

(defmethod stream-position ((stream fundamental-file-output-stream) &optional newpos)
  (with-stream-ioblock-output (file-ioblock stream :speedy t)
    (%ioblock-output-file-position file-ioblock newpos)))

(defmethod stream-position ((stream basic-file-output-stream) &optional newpos)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (file-ioblock)
      (%ioblock-output-file-position file-ioblock newpos))))


(defmethod stream-position ((stream fundamental-file-io-stream) &optional newpos)
  (with-stream-ioblock-input (file-ioblock stream :speedy t)
    (%ioblock-io-file-position file-ioblock newpos)))

(defmethod stream-position ((stream basic-file-io-stream) &optional newpos)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (file-ioblock)
      (%ioblock-io-file-position file-ioblock newpos))))


(defmethod stream-length ((stream fundamental-file-input-stream) &optional newlen)
  (with-stream-ioblock-input (file-ioblock stream :speedy t)
    (let* ((res (%ioblock-input-file-length file-ioblock newlen)))
      (and res (>= res 0) res))))


(defmethod stream-length ((stream basic-file-input-stream) &optional newlen)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (file-ioblock)
      (let* ((res (%ioblock-input-file-length file-ioblock newlen)))
        (and res (>= res 0) res)))))


(defmethod stream-length ((s fundamental-file-output-stream) &optional newlen)
  (with-stream-ioblock-output (file-ioblock s :speedy t)
    (let* ((res (%ioblock-output-file-length file-ioblock newlen)))
      (and res (>= res 0) res))))


(defmethod stream-length ((stream basic-file-output-stream) &optional newlen)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-output-locked (file-ioblock)
      (let* ((res (%ioblock-output-file-length file-ioblock newlen)))
        (and res (>= res 0) res)))))

(defmethod stream-length ((s fundamental-file-io-stream) &optional newlen)
  (with-stream-ioblock-input (file-ioblock s :speedy t)
    (let* ((res (%ioblock-output-file-length file-ioblock newlen)))
      (and res (>= res 0) res))))

(defmethod stream-length ((stream basic-file-io-stream) &optional newlen)
  (let* ((file-ioblock (basic-stream-ioblock stream)))
    (with-ioblock-input-locked (file-ioblock)
      (let* ((res (%ioblock-output-file-length file-ioblock newlen)))
        (and res (>= res 0) res)))))

(defun close-file-stream (s abort)
  (when (open-stream-p s)
    (let* ((ioblock (stream-ioblock s t))
	   (filename (stream-filename s))
	   (actual-filename (stream-actual-filename s)))
      (when actual-filename ; t => created when opened
	(if abort
	  (progn
	    (setf (ioblock-dirty ioblock) nil)
	    (fd-stream-close s ioblock)
            (if (eq actual-filename t)
              (delete-file filename)
              (unix-rename (namestring actual-filename) (probe-file-x filename))))
	  (unless (eq actual-filename t)
            (delete-file actual-filename))))
      (remove-open-file-stream s))))


(defmethod close ((s fundamental-file-stream) &key abort)
  (close-file-stream s abort)
  (call-next-method))

(defmethod close ((s basic-file-stream) &key abort)
  (close-file-stream s abort)
  (call-next-method))

(defmethod select-stream-class ((class fundamental-file-stream) in-p out-p char-p)
  (if char-p
    (if (and in-p out-p)
      'fundamental-file-character-io-stream
      (if in-p
	'fundamental-file-character-input-stream
	(if out-p
	  'fundamental-file-character-output-stream
	  'fundamental-file-stream)))
    (if (and in-p out-p)
      'fundamental-file-binary-io-stream
      (if in-p
	'fundamental-file-binary-input-stream
	(if out-p
	  'fundamental-file-binary-output-stream
	  'fundamental-file-stream)))))

(defmethod select-stream-class ((class file-stream) in-p out-p char-p)
  (if char-p
    (if (and in-p out-p)
      'fundamental-file-character-io-stream
      (if in-p
	'fundamental-file-character-input-stream
	(if out-p
	  'fundamental-file-character-output-stream
	  'fundamental-file-stream)))
    (if (and in-p out-p)
      'fundamental-file-binary-io-stream
      (if in-p
	'fundamental-file-binary-input-stream
	(if out-p
	  'fundamental-file-binary-output-stream
	  'fundamental-file-stream)))))

(defmethod map-to-basic-stream-class-name ((name (eql 'fundamental-file-stream)))
  'basic-file-stream)

(defmethod map-to-basic-stream-class-name ((name (eql 'file-stream)))
  'basic-file-stream)

(defmethod select-stream-class ((class (eql 'basic-file-stream)) in-p out-p char-p)
  (if char-p
    (if (and in-p out-p)
      'basic-file-character-io-stream
      (if in-p
	'basic-file-character-input-stream
	(if out-p
	  'basic-file-character-output-stream
	  'basic-file-stream)))
    (if (and in-p out-p)
      'basic-file-binary-io-stream
      (if in-p
	'basic-file-binary-input-stream
	(if out-p
	  'basic-file-binary-output-stream
	  'basic-file-stream)))))


(defmethod select-stream-advance-function ((s file-stream) direction)
  (ecase direction
    (:io 'io-file-ioblock-advance)
    (:input 'input-file-ioblock-advance)))

(defmethod select-stream-force-output-function ((s file-stream) direction)
  (ecase direction
    (:io 'io-file-force-output)
    (:output 'output-file-force-output)))

(defmethod select-stream-untyi-function ((s file-stream) (direction t))
  '%file-ioblock-untyi)

;;; Conceptually, decrement the stream's position by the number of octets
;;; needed to encode CHAR.
;;; Since we don't use IOBLOCK-UNTYI-CHAR, it's hard to detect the error
;;; of calling UNREAD-CHAR twice in a row.
(defun %file-ioblock-untyi (ioblock char)
  (let* ((inbuf (ioblock-inbuf ioblock))
         (idx (io-buffer-idx inbuf))
         (encoding (ioblock-encoding ioblock))
         (noctets (if encoding
                    (funcall (character-encoding-character-size-in-octets-function encoding) char)
                    1)))
    (declare (fixnum idx noctets))
    (if (>= idx noctets)
      (setf (io-buffer-idx inbuf) (the fixnum (- idx noctets)))
      (let* ((stream (ioblock-stream ioblock))
             (pos (stream-position stream))
             (newpos (- pos noctets)))
        (if (< newpos 0)
          (error "Invalid attempt to unread ~s on ~s." char (ioblock-stream ioblock))
          (stream-position stream newpos))))
    char))



(defun make-file-stream (filename
			 direction
			 element-type
			 if-exists
			 if-does-not-exist
			 class
			 external-format
                         sharing
                         basic)
  (let* ((temp-name nil)
         (created nil)
         (dir (pathname-directory filename))
         (filename (if (eq (car dir) :relative)
                     (full-pathname filename)
                     filename))
         (pathname (pathname filename))) 
    (block open
      (if (or (memq element-type '(:default character base-char))
	      (subtypep element-type 'character))
	(if (eq element-type :default) (setq element-type 'character))
	(progn
	  (setq element-type (type-expand element-type))
	  (cond ((equal element-type '#.(type-expand 'signed-byte))
		 (setq element-type '(signed-byte 8)))
		((equal element-type '#.(type-expand 'unsigned-byte))
		 (setq element-type '(unsigned-byte 8))))))
      (case direction
	(:probe (setq if-exists :ignored))
	(:input (setq if-exists :ignored))
	((:io :output) nil)
	(t (report-bad-arg direction '(member :input :output :io :probe))))
      (check-pathname-not-wild filename) ; probe-file-x misses wild versions....
      (multiple-value-bind (native-truename kind) (probe-file-x filename)
	(tagbody retry
	   (if native-truename
	     (if (eq kind :directory)
	       (if (eq direction :probe)
		 (return-from open nil)
		 (signal-file-error (- #$EISDIR)  filename))
	       (if (setq filename (if-exists if-exists filename "Open ..."))
		 (progn
		   (multiple-value-setq (native-truename kind) (probe-file-x filename))
		   (cond 
		     ((not native-truename)
		      (setq native-truename (%create-file filename)
			    created t))
		     ((memq direction '(:output :io))
		      (when (eq if-exists :supersede)
			(let ((truename (native-to-pathname native-truename)))
			  (setq temp-name (gen-file-name truename))
			  (unix-rename native-truename (native-translated-namestring temp-name))
			  (%create-file truename))))))
		 (return-from open nil)))
	     (if (setq filename (if-does-not-exist if-does-not-exist filename))
	       (progn
		 (unless (setq native-truename (%create-file filename :if-exists (case if-exists
										   ;; Let %create file handle these cases
										   ((:error :overwrite) if-exists)
										   (t nil))))
		   ;; Somebody else created the file while we're trying to create it.
		   (when (null if-exists) (return-from open nil))
		   (multiple-value-setq (native-truename kind) (probe-file-x filename))
		   (unless native-truename ; huh?  Perhaps it disappeared again?
		     (error "Attempt to create ~s failed unexpectedly" filename))
		   (go retry))
		 (setq created t))
	       (return-from open nil))))
	(let* ((fd (fd-open native-truename (case direction
					      ((:probe :input) #$O_RDONLY)
					      (:output #$O_WRONLY)
					      (:io #$O_RDWR)))))
	  (when (< fd 0)
            (if (and (eql fd (- #$ENOENT))
                     (null if-does-not-exist))
              (return-from open nil)
              (signal-file-error fd filename)))
	  (let* ((pos (fd-lseek fd 0 #$SEEK_CUR)))
	    (if (not (>= pos 0))
	      (make-fd-stream fd :direction direction
			      :element-type element-type
			      :sharing sharing
			      :basic basic)
	      (progn
		(when basic
		  (setq class (map-to-basic-stream-class-name class))
		  (setq basic (subtypep (find-class class) 'basic-stream)))
                (let* ((in-p (member direction '(:io :input)))
                       (out-p (member direction '(:io :output)))
                       (io-p (eq direction :io))
                       (char-p (or (eq element-type 'character)
                                   (subtypep element-type 'character)))
                       (elements-per-buffer (optimal-buffer-size fd (if char-p '(unsigned-byte 8) element-type)))
                       (real-external-format
                        (if char-p
                          (normalize-external-format :file external-format)
                          ))
                       (line-termination (if char-p (external-format-line-termination real-external-format)))
                       (encoding (if char-p (external-format-character-encoding real-external-format)))
                       (class-name (select-stream-class class in-p out-p char-p))
                       (class (find-class class-name))
                       (fstream (make-ioblock-stream
                                 class
                                 :insize (if in-p elements-per-buffer)
                                 :outsize (if (and out-p (not io-p))
                                            elements-per-buffer)
                                 :share-buffers-p io-p
                                 :interactive nil
                                 :direction direction
                                 :element-type element-type
                                 :direction direction
                                 :listen-function 'fd-stream-listen
                                 :close-function 'fd-stream-close
                                 :eofp-function 'fd-stream-eofp
                                 :advance-function
                                 (if in-p (select-stream-advance-function class direction))
                                 :force-output-function
                                 (if out-p (select-stream-force-output-function
					    class direction))
                                 :device fd
                                 :encoding encoding
                                 :external-format (or real-external-format :binary)
                                 :sharing sharing
                                 :line-termination line-termination
                                 :character-p (or (eq element-type 'character)
                                                  (subtypep element-type 'character))))
                       (ioblock (stream-ioblock fstream t)))
                  (setf (stream-filename fstream) (namestring pathname)
                        (stream-actual-filename fstream) (or temp-name created))
                  (setf (file-ioblock-fileeof ioblock)
                        (ioblock-octets-to-elements ioblock (fd-size fd)))
                  (when (and in-p (eq encoding :inferred))
                    (infer-character-encoding ioblock))
                  (when (and in-p (eq line-termination :inferred))
                    (infer-line-termination ioblock))
                  (cond ((eq if-exists :append)
                         (file-position fstream :end))
                        ((and (memq direction '(:io :output))
                              (neq if-exists :overwrite))
                         (stream-length fstream 0)))
                  (if (eq direction :probe)
                    (close fstream)
                    (note-open-file-stream fstream))
                  fstream)))))))))






(defmethod stream-external-format ((s broadcast-stream))
  (let* ((last (last-broadcast-stream s)))
    (if last
        (stream-external-format s)
        :default)))

;;; Under the circumstances, this is a very slow way of saying
;;; "we don't support EXTENDED-CHARs".
(defun file-string-length (stream object)
  "Return the delta in STREAM's FILE-POSITION that would be caused by writing
   OBJECT to STREAM. Non-trivial only in implementations that support
   international character sets."
  (if (typep stream 'broadcast-stream)
    (let* ((last (last-broadcast-stream stream)))
      (if last
	(file-string-length last object)
	1))
    (progn
      (unless (and (typep stream 'file-stream)
		   (let* ((eltype (stream-element-type stream)))
		     (or (eq 'character eltype)
			 (eq 'base-char eltype)
			 (subtypep eltype 'character))))
	(error "~S is not a file stream capable of character output" stream))
      (if (typep object 'character)
        (setq object (make-string 1 :initial-element object))
        (progn
          (require-type object 'string)))
      (let* ((start 0)
             (end (length object)))
        (multiple-value-bind (data offset) (array-data-and-offset object)
          (unless (eq data object)
            (setq object data)
            (incf start offset)
            (incf end offset)))
        (let* ((external-format (stream-external-format stream))
               (encoding (get-character-encoding (external-format-character-encoding external-format)))
               (line-termination (external-format-line-termination external-format)))
          (-
           (+ (funcall (character-encoding-octets-in-string-function encoding)
                       object
                       start
                       end)
              (if (eq line-termination :crlf)
                (* (count #\Newline object :start start :end end)
                   (file-string-length stream #\Return))
                0))
           (if (and (eql (file-position stream) 0)
                    (character-encoding-use-byte-order-mark encoding))
             (length (character-encoding-bom-encoding encoding))
             0)))))))
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-sysio.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/ppc-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")



;;; callback here from C exception handler

(defcallback 
    %xerr-disp 
    (:address xp :unsigned-fullword fn-reg :unsigned-fullword pc-or-index :signed-fullword errnum :unsigned-fullword rb :signed-fullword continuable)
  (block %err-disp
    (let ((fn (unless (eql fn-reg 0) (xp-gpr-lisp xp fn-reg)))
	  (err-fn (if (eql continuable 0) '%err-disp-internal '%kernel-restart-internal)))
      (if (eql errnum arch::error-stack-overflow)
	(handle-stack-overflow xp fn rb)
	(with-xp-stack-frames (xp fn frame-ptr)	; execute body with dummy stack frame(s)
	  (with-error-reentry-detection
	      (let* ((rb-value (xp-gpr-lisp xp rb))
		     (res
		      (cond ((< errnum 0)
			     (%err-disp-internal errnum nil frame-ptr))
			    ((logtest errnum arch::error-type-error)
			     (funcall err-fn 
				      #.(car (rassoc 'type-error *kernel-simple-error-classes*))
				      (list rb-value (logandc2 errnum arch::error-type-error))
				      frame-ptr))
			    ((eql errnum arch::error-udf)
			     (funcall err-fn $xfunbnd (list rb-value) frame-ptr))
			    ((eql errnum arch::error-throw-tag-missing)
			     (%error (make-condition 'cant-throw-error
						     :tag rb-value)
				     nil frame-ptr))
			    ((eql errnum arch::error-cant-call)
			     (%error (make-condition 'type-error
						     :datum  rb-value
						     :expected-type '(or symbol function)
						     :format-control
						     "~S is not of type ~S, and can't be FUNCALLed or APPLYed")
				     nil frame-ptr))
			    ((eql errnum arch::error-udf-call)
			     (return-from %err-disp
			       (handle-udf-call xp frame-ptr)))
			    ((eql errnum arch::error-alloc-failed)
			     (%error (make-condition 
				      'simple-storage-condition
				      :format-control (%rsc-string $xmemfull))
				     nil frame-ptr))
			    ((eql errnum arch::error-memory-full)
			     (%error (make-condition 
				      'simple-storage-condition
				      :format-control (%rsc-string $xnomem))
				     nil frame-ptr))
			    ((or (eql errnum arch::error-fpu-exception-double) 
				 (eql errnum arch::error-fpu-exception-single))
			     (let* ((code-vector (and fn  (uvref fn 0)))
				    (instr (if code-vector 
					     (uvref code-vector pc-or-index)
					     (%get-long (%int-to-ptr pc-or-index)))))
			       (let* ((minor (ldb (byte 5 1) instr))
				      (fra (ldb (byte 5 16) instr))
				      (frb (ldb (byte 5 11) instr))
				      (frc (ldb (byte 5 6) instr)))
				 (declare (fixnum minor fra frb frc))
				 (if (= minor 12) ; FRSP
				   (%err-disp-internal $xcoerce (list (xp-double-float xp frc) 'short-float) frame-ptr)
				   (flet ((coerce-to-op-type (double-arg)
					    (if (eql errnum arch::error-fpu-exception-double)
					      double-arg
					      (handler-case (coerce double-arg 'short-float)
						(error (c) (declare (ignore c)) double-arg)))))
				     (multiple-value-bind (status control) (xp-fpscr-info xp)
				       (%error (make-condition (fp-condition-from-fpscr status control)
							       :operation (fp-minor-opcode-operation minor)
							       :operands
                                                               (if (= minor 22)
                                                                 (list (coerce-to-op-type (xp-double-float xp frb)))
                                                                 (list (coerce-to-op-type 
                                                                        (xp-double-float xp fra))
                                                                       (if (= minor 25)
                                                                         (coerce-to-op-type 
                                                                          (xp-double-float xp frc))
                                                                         (coerce-to-op-type 
                                                                          (xp-double-float xp frb))))))
					       nil
					       frame-ptr)))))))
			    ((eql errnum arch::error-excised-function-call)
			     (%error "~s: code has been excised." (list (xp-gpr-lisp xp ppc::nfn)) frame-ptr))
			    ((eql errnum arch::error-too-many-values)
			     (%err-disp-internal $xtoomanyvalues (list rb-value) frame-ptr))
			    (t (%error "Unknown error #~d with arg: ~d" (list errnum rb-value) frame-ptr)))))
		(setf (xp-gpr-lisp xp rb) res) ; munge register for continuation
		)))))))



(defun handle-udf-call (xp frame-ptr)
  (let* ((args (xp-argument-list xp))
         (values (multiple-value-list
                  (%kernel-restart-internal
                   $xudfcall
                   (list (maybe-setf-name (xp-gpr-lisp xp ppc::fname)) args)
                   frame-ptr)))
         (stack-argcnt (max 0 (- (length args) 3)))
         (vsp (%i+ (xp-gpr-lisp xp ppc::vsp) stack-argcnt))
         (f #'(lambda (values) (apply #'values values))))
    (setf (xp-gpr-lisp xp ppc::vsp) vsp
          (xp-gpr-lisp xp ppc::nargs) 1
          (xp-gpr-lisp xp ppc::arg_z) values
          (xp-gpr-lisp xp ppc::nfn) f)
    ;; handle_uuo() (in the lisp kernel) will not bump the PC here.
    (setf (xp-gpr-lisp xp #+linuxppc-target #$PT_NIP #+darwinppc-target -2)
	  (uvref f 0))))






;;; rb is the register number of the stack that overflowed.
;;; xp & fn are passed so that we can establish error context.
(defun handle-stack-overflow (xp fn rb)
  (unwind-protect
       (with-xp-stack-frames (xp fn frame-ptr) ; execute body with dummy stack frame(s)
	 (%error
	  (make-condition
	   'stack-overflow-condition 
	   :format-control "Stack overflow on ~a stack."
	   :format-arguments (list
			      (if (eql rb ppc::sp)
				"control"
				(if (eql rb ppc::vsp)
				  "value"
				  (if (eql rb ppc::tsp)
				    "temp"
				    "unknown")))))
	  nil frame-ptr))
    (ff-call (%kernel-import target::kernel-import-restore-soft-stack-limit)
	     :unsigned-fullword rb
	     :void)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/ppc-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-lisp-threads.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;; -*- Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; l1-lisp-threads.lisp

(in-package "CCL")

(defvar *bind-io-control-vars-per-process* nil
  "If true, bind I/O control variables per process")


	     
(defun lisp-thread-p (thing)
  (istruct-typep thing 'lisp-thread))

(setf (type-predicate 'lisp-thread) 'lisp-thread-p)

(defloadvar *ticks-per-second*
    #+windows-target 1000
    #-windows-target
    (max 1000 (#_sysconf #$_SC_CLK_TCK)))

(defloadvar *ns-per-tick*
    (floor 1000000000 *ticks-per-second*))

#-windows-target
(defun %nanosleep (seconds nanoseconds)
  #+(and darwin-target 64-bit-target)
  (when (> seconds #x3fffffff)          ;over 30 years in seconds
    (setq seconds #x3fffffff))
  (with-process-whostate ("Sleep")
    (rlet ((a :timespec)
           (b :timespec))
      (setf (pref a :timespec.tv_sec) seconds
            (pref a :timespec.tv_nsec) nanoseconds)
      (let* ((aptr a)
             (bptr b))
        (loop
          (let* ((result (#_nanosleep aptr bptr)))
            (declare (type (signed-byte 32) result))
            (if (and (< result 0)
                     (eql (%get-errno) (- #$EINTR)))
              (progn
                ;; Some versions of OSX have a bug: if the call to #_nanosleep
                ;; is interrupted near the time when the timeout would
                ;; have occurred, the "remaining time" is computed as
                ;; a negative value and, on 64-bit platforms, zero-extended.
                #+(and darwin-target 64-bit-target)
                (when (>= (pref bptr :timespec.tv_sec) #x80000000)
                  (return))
                (psetq aptr bptr bptr aptr))
              (return))))))))


(defun timeval->ticks (tv)
  (+ (* *ticks-per-second* (pref tv :timeval.tv_sec))
     (round (pref tv :timeval.tv_usec) (floor 1000000 *ticks-per-second*))))


(defun gettimeofday (ptimeval &optional ptz)
  (int-errno-ffcall (%kernel-import target::kernel-import-lisp-gettimeofday)
                    :address ptimeval
                    :address (or ptz (%null-ptr))
                    :int))

(defloadvar *lisp-start-timeval*
    (progn
      (let* ((r (make-record :timeval)))
        (gettimeofday r)
        r)))


(defloadvar *internal-real-time-session-seconds* nil)


(defun get-internal-real-time ()
  "Return the real time in the internal time format. (See
  INTERNAL-TIME-UNITS-PER-SECOND.) This is useful for finding elapsed time."
  (rlet ((tv :timeval))
    (gettimeofday tv)
    (let* ((units (truncate (the fixnum (pref tv :timeval.tv_usec)) (/ 1000000 internal-time-units-per-second)))
           (initial *internal-real-time-session-seconds*))
      (if initial
        (locally
            (declare (type (unsigned-byte 32) initial))
          (+ (* internal-time-units-per-second
                (the (unsigned-byte 32)
                  (- (the (unsigned-byte 32) (pref tv :timeval.tv_sec))
                     initial)))
             units))
        (progn
          (setq *internal-real-time-session-seconds*
                (pref tv :timeval.tv_sec))
          units)))))

(defun get-tick-count ()
  (values (floor (get-internal-real-time)
                 (floor internal-time-units-per-second
                        *ticks-per-second*))))




(defun %kernel-global-offset (name-or-offset)
  (if (fixnump name-or-offset)
    name-or-offset
    (target::%kernel-global name-or-offset)))


(defun %kernel-global-offset-form (name-or-offset-form)
  (cond ((quoted-form-p name-or-offset-form)
         `(%target-kernel-global ,name-or-offset-form))
        ((fixnump name-or-offset-form)
         name-or-offset-form)
        (t `(%target-kernel-global ',name-or-offset-form))))



(defmacro %set-kernel-global (name-or-offset new-value)
  `(%set-kernel-global-from-offset
    ,(%kernel-global-offset-form name-or-offset)
    ,new-value))



; The number of bytes in a consing (or stack) area
(defun %area-size (area)
  (ash (- (%fixnum-ref area target::area.high)
          (%fixnum-ref area target::area.low))
       target::fixnumshift))

(defun %stack-area-usable-size (area)
  (ash (- (%fixnum-ref area target::area.high)
	  (%fixnum-ref area target::area.softlimit))
       target::fixnum-shift))

(defun %cons-lisp-thread (name &optional tcr)
  (%istruct 'lisp-thread
	    tcr
	    name
	    0
	    0
	    0
	    nil
	    nil
            (make-lock)
	    nil
	    :reset
	    (make-lock)))

(defvar *current-lisp-thread*
  (%cons-lisp-thread "Initial" (%current-tcr)))

(defstatic *initial-lisp-thread* *current-lisp-thread*)

(defun thread-change-state (thread oldstate newstate)
  (with-lock-grabbed ((lisp-thread.state-change-lock thread))
    (when (eq (lisp-thread.state thread) oldstate)
      (setf (lisp-thread.state thread) newstate))))

(thread-change-state *initial-lisp-thread* :reset :run)

(defun thread-state (thread)
  (with-lock-grabbed ((lisp-thread.state-change-lock thread))
    (lisp-thread.state thread)))
  
(defun thread-make-startup-function (thread tcr)
  #'(lambda ()
      (thread-change-state thread :reset :run)
      (let* ((*current-lisp-thread* thread)
	     (initial-function (lisp-thread.initial-function.args thread)))
	(tcr-clear-preset-state tcr)
	(%set-tcr-toplevel-function tcr nil)
        (apply (car initial-function) (cdr initial-function))
	(cleanup-thread-tcr thread tcr))))

(defun init-thread-from-tcr (tcr thread)
  (let* ((cs-area nil)
         (vs-area (%fixnum-ref tcr (- target::tcr.vs-area target::tcr-bias)))
         #-arm-target
         (ts-area (%fixnum-ref tcr (- target::tcr.ts-area target::tcr-bias))))
    #+(and windows-target x8632-target)
    (let ((aux (%fixnum-ref tcr (- target::tcr.aux target::tcr-bias))))
      (setq cs-area (%fixnum-ref aux target::tcr-aux.cs-area)))
    #-(and windows-target x8632-target)
    (setq cs-area (%fixnum-ref tcr target::tcr.cs-area))
    (when (or (zerop cs-area)
              (zerop vs-area)
              #-arm-target
              (zerop ts-area))
      (error "Can't allocate new thread"))
    (setf (lisp-thread.tcr thread) tcr
          (lisp-thread.cs-size thread)
          (%stack-area-usable-size cs-area)
          (lisp-thread.vs-size thread)
          (%stack-area-usable-size vs-area)
          (lisp-thread.ts-size thread)
          #+arm-target 0
          #-arm-target
          (%stack-area-usable-size ts-area)
          (lisp-thread.startup-function thread)
          (thread-make-startup-function thread tcr)))
  (thread-change-state thread :exit :reset)
  thread)

(defun default-allocation-quantum ()
  (ash 1 (%get-kernel-global 'default-allocation-quantum)))

(defun new-lisp-thread-from-tcr (tcr name)
  (let* ((thread (%cons-lisp-thread name tcr)))    
    (init-thread-from-tcr tcr thread)
    (push thread (population-data *lisp-thread-population*))
    thread))

(def-ccl-pointers initial-thread ()
  (init-thread-from-tcr (%current-tcr) *initial-lisp-thread*))

(defmethod print-object ((thread lisp-thread) stream)
  (print-unreadable-object (thread stream :type t :identity t)
    (format stream "~a" (lisp-thread.name thread))
    (let* ((tcr (lisp-thread.tcr thread)))
      (if (and tcr (not (eql 0 tcr)))
	(format stream " [tcr @ #x~x]" (ash tcr target::fixnumshift))))))


(defvar *lisp-thread-population*
  (%cons-population (list *initial-lisp-thread*) $population_weak-list nil))





(defparameter *default-control-stack-size*
  #+32-bit-target (ash 1 20)
  #+64-bit-target (ash 2 20))
(defparameter *default-value-stack-size*
  #+32-bit-target (ash 1 20)
  #+64-bit-target (ash 2 20))
(defparameter *default-temp-stack-size*
  #+32-bit-target (ash 1 19)
  #+64-bit-target (ash 2 19))


(defstatic *initial-listener-default-control-stack-size* *default-control-stack-size*)
(defstatic *initial-listener-default-value-stack-size* *default-value-stack-size*)
(defstatic *initial-listener-default-temp-stack-size* *default-temp-stack-size*)


(def-ccl-pointers listener-stack-sizes ()
  (let* ((size (%get-kernel-global 'stack-size))) ; set by --thread-stack-size
    (declare (fixnum size))
    (when (> size 0)
      (setq *initial-listener-default-control-stack-size* size
            *initial-listener-default-value-stack-size* size
            *initial-listener-default-temp-stack-size* (floor size 2)))))


(defmacro with-area-macptr ((var area) &body body)
  `(with-macptrs (,var)
     (%setf-macptr-to-object ,var ,area)
     ,@body))


(defun gc-area.return-sp (area)
  (%fixnum-ref area target::area.gc-count))


(defun (setf gc-area.return-sp) (return-sp area)
  (setf (%fixnum-ref area target::area.gc-count) return-sp))



(defun shutdown-lisp-threads ()
  )

(defun %current-xp ()
  (let ((xframe (%fixnum-ref (%current-tcr) (- target::tcr.xframe
					       target::tcr-bias))))
    (when (eql xframe 0)
      (error "No current exception frame"))
    (%fixnum-ref xframe
                 (get-field-offset :xframe-list.this))))

(defun new-tcr (cs-size vs-size ts-size)
  (let* ((tcr (macptr->fixnum
               (ff-call
                (%kernel-import target::kernel-import-newthread)
                #+64-bit-target :unsigned-doubleword
                #+32-bit-target :unsigned-fullword cs-size
                #+64-bit-target :unsigned-doubleword
                #+32-bit-target :unsigned-fullword vs-size
                #+64-bit-target :unsigned-doubleword
                #+32-bit-target :unsigned-fullword ts-size
                :address))))
    (declare (fixnum tcr))
    (if (zerop tcr)
      (error "Can't create thread")
      tcr)))

(defun new-thread (name cstack-size vstack-size tstack-size)
  (new-lisp-thread-from-tcr (new-tcr cstack-size vstack-size tstack-size) name))

(defun new-tcr-for-thread (thread)
  (let* ((tcr (new-tcr
	       (lisp-thread.cs-size thread)
	       (lisp-thread.vs-size thread)
	       (lisp-thread.ts-size thread))))
    (setf (lisp-thread.tcr thread) tcr
	  (lisp-thread.startup-function thread)
	  (thread-make-startup-function thread tcr))
    (thread-change-state thread :exit :reset)
    tcr))
  
	 



(defconstant cstack-hardprot (ash 100 10))
(defconstant cstack-softprot (ash 100 10))



(defun tcr-flags (tcr)
  (%fixnum-ref tcr (- target::tcr.flags target::tcr-bias)))



(defun %tcr-frame-ptr (tcr)
  (with-macptrs (p)
    (%setf-macptr-to-object p tcr)
    (%fixnum-from-macptr
     (ff-call (%kernel-import target::kernel-import-tcr-frame-ptr)
              :address p
              :address))))
 
(defun thread-exhausted-p (thread)
  (or (null thread)
      (null (lisp-thread.tcr thread))))

(defun thread-total-run-time (thread)
  (unless (thread-exhausted-p thread)
    nil))

(defun %tcr-interrupt (tcr)
  ;; The other thread's interrupt-pending flag might get cleared
  ;; right after we look and see it set, but since this is called
  ;; with the lock on the thread's interrupt queue held, the
  ;; pending interrupt won't have been taken yet.
  ;; When a thread dies, it should try to clear its interrupt-pending
  ;; flag.
  (if (eql 0 (%fixnum-ref tcr (- target::tcr.interrupt-pending
				 target::tcr-bias)))
    (%%tcr-interrupt tcr)
    0))



     
     

(defun thread-interrupt (thread process function &rest args)
  (with-lock-grabbed ((lisp-thread.state-change-lock thread))
    (case (lisp-thread.state thread)
      (:run 
       (with-lock-grabbed ((lisp-thread.interrupt-lock thread))
         (let ((tcr (lisp-thread.tcr thread)))
	   (when tcr
	     (push (cons function args)
		   (lisp-thread.interrupt-functions thread))
	     (eql 0 (%tcr-interrupt tcr))))))
      (:reset
       ;; Preset the thread with a function that'll return to the :reset
       ;; state
       (let* ((pif (process-initial-form process))
	      (pif-f (car pif))
	      (pif-args (cdr pif)))
	 (process-preset process #'(lambda ()
				     (%rplaca pif pif-f)
				     (%rplacd pif pif-args)
				     (apply function args)
				     ;; If function returns normally,
				     ;; return to the reset state
				     (%process-reset nil)))
	 (thread-enable thread (process-termination-semaphore process) (1- (integer-length (process-allocation-quantum process))) 0)
         t)))))

(defun thread-handle-interrupts ()
  (let* ((thread *current-lisp-thread*))
    (with-process-whostate ("Active")
      (loop
        (let* ((f (with-lock-grabbed ((lisp-thread.interrupt-lock thread))
                    (pop (lisp-thread.interrupt-functions thread)))))
          (if f
            (apply (car f) (cdr f))
            (return)))))))


	
(defun  thread-preset (thread function &rest args)
  (setf (lisp-thread.initial-function.args thread)
	(cons function args)))

(defun thread-enable (thread termination-semaphore allocation-quantum &optional (timeout (* 60 60 24)))
  (let* ((tcr (or (lisp-thread.tcr thread) (new-tcr-for-thread thread))))
    (with-macptrs (s)
      #+(and windows-target x8632-target)
      (let ((aux (%fixnum-ref tcr (- target::tcr.aux target::tcr-bias))))
	(%setf-macptr-to-object s (%fixnum-ref aux target::tcr-aux.reset-completion)))
      #-(and windows-target x8632-target)
      (%setf-macptr-to-object s (%fixnum-ref tcr target::tcr.reset-completion))
      (when (%timed-wait-on-semaphore-ptr s timeout nil)
        (%set-tcr-toplevel-function
         tcr
         (lisp-thread.startup-function thread))
        (%activate-tcr tcr termination-semaphore allocation-quantum)
        thread))))
			      

(defun cleanup-thread-tcr (thread tcr)
  (let* ((flags (%fixnum-ref tcr (- target::tcr.flags
				    target::tcr-bias))))
    (declare (fixnum flags))
    (if (logbitp arch::tcr-flag-bit-awaiting-preset flags)
      (thread-change-state thread :run :reset)
      (with-lock-grabbed ((lisp-thread.state-change-lock thread))
	(thread-change-state thread :run :exit)
	(setf (lisp-thread.tcr thread) nil)))))

(defun kill-lisp-thread (thread)
  (unless (eq thread *initial-lisp-thread*)
    (let* ((tcr (lisp-thread.tcr thread)))
      (when tcr
        (setf (lisp-thread.tcr thread) nil
              (lisp-thread.state thread) :exit)
	(%kill-tcr tcr)))))

;;; This returns the underlying pthread, whatever that is, as an
;;; unsigned integer.
(defun lisp-thread-os-thread (thread)
  (with-macptrs (tcrp)
    (%setf-macptr-to-object tcrp (lisp-thread.tcr thread))
    (unless (%null-ptr-p tcrp)
      
      (let* ((natural #+(and windows-target x8632-target)
		      (%get-natural (%get-ptr tcrp (- target::tcr.aux
						      target::tcr-bias))
				    target::tcr-aux.osid)
		      #-(and windows-target x8632-target)
		      (%get-natural tcrp target::tcr.osid)))
        (unless (zerop natural) natural)))))


                         
;;; This returns something lower-level than the pthread, if that
;;; concept makes sense.  On current versions of Linux, it returns
;;; the pid of the clone()d process; on Darwin, it returns a Mach
;;; thread.  On some (near)future version of Linux, the concept
;;; may not apply.
;;; The future is here: on Linux systems using NPTL, this returns
;;; exactly the same thing that (getpid) does.
;;; This should probably be retired; even if it does something
;;; interesting, is the value it returns useful ?

(defun lisp-thread-native-thread (thread)
  (with-macptrs (tcrp)
    (%setf-macptr-to-object tcrp (lisp-thread.tcr thread))
    (unless (%null-ptr-p tcrp)
      #+(and windows-target x8632-target)
      (let ((aux (%get-ptr tcrp (- target::tcr.aux target::tcr-bias))))
	(%get-unsigned-long aux target::tcr-aux.native-thread-id))
      #-(and windows-target x8632-target)
      (#+32-bit-target %get-unsigned-long
       #+64-bit-target %%get-unsigned-longlong tcrp target::tcr.native-thread-id))))

(defun lisp-thread-suspend-count (thread)
  (with-lock-grabbed ((lisp-thread.state-change-lock thread))
    (let* ((tcr (lisp-thread.tcr thread)))
      (if (null tcr)
        0
        (with-macptrs (tcrp)
          (%setf-macptr-to-object tcrp tcr)
          #+(and windows-target x8632-target)
          (let ((aux (%get-ptr tcrp (- target::tcr.aux target::tcr-bias))))
            (%get-unsigned-long aux target::tcr-aux.suspend-count))
          #-(and windows-target x8632-target)
          (#+32-bit-target %get-unsigned-long
                             #+64-bit-target %%get-unsigned-longlong tcrp target::tcr.suspend-count))))))

(defun tcr-clear-preset-state (tcr)
  (let* ((flags (%fixnum-ref tcr (- target::tcr.flags target::tcr-bias))))
    (declare (fixnum flags))
    (setf (%fixnum-ref tcr (- target::tcr.flags target::tcr-bias))
	  (bitclr arch::tcr-flag-bit-awaiting-preset flags))))

(defun tcr-set-preset-state (tcr)
  (let* ((flags (%fixnum-ref tcr (- target::tcr.flags target::tcr-bias))))
    (declare (fixnum flags))
    (setf (%fixnum-ref tcr (- target::tcr.flags target::tcr-bias))
	  (bitset arch::tcr-flag-bit-awaiting-preset flags))))  

;;; This doesn't quite activate the thread; see PROCESS-TCR-ENABLE.
(defun %activate-tcr (tcr termination-semaphore allocation-quantum)
  (declare (ignore termination-semaphore))
  (if (and tcr (not (eql 0 tcr)))
    (with-macptrs (tcrp)
      (%setf-macptr-to-object tcrp tcr)
      #+(and windows-target x8632-target)
      (let ((aux (%get-ptr tcrp (- target::tcr.aux target::tcr-bias))))
	(setf (%get-unsigned-long aux target::tcr-aux.log2-allocation-quantum)
	      (or allocation-quantum (default-allocation-quantum))))
      #-(and windows-target x8632-target)
      (setf (%get-natural tcrp target::tcr.log2-allocation-quantum)
            (or allocation-quantum (default-allocation-quantum)))
      t)))
                         
(defvar *canonical-error-value*
  '(*canonical-error-value*))


(defun symbol-value-in-tcr (sym tcr)
  (if (eq tcr (%current-tcr))
    (%sym-value sym)
    (unwind-protect
         (progn
           (%suspend-tcr tcr)
           (let* ((loc (%tcr-binding-location tcr sym)))
             (if loc
               (%fixnum-ref loc)
               (%sym-global-value sym))))
      (%resume-tcr tcr))))

(defun (setf symbol-value-in-tcr) (value sym tcr)
  (if (eq tcr (%current-tcr))
    (%set-sym-value sym value)
    (unwind-protect
         (progn
           (%suspend-tcr tcr)
           (let* ((loc (%tcr-binding-location tcr sym)))
             (if loc
               (setf (%fixnum-ref loc) value)
               (%set-sym-global-value sym value))))
      (%resume-tcr tcr))))

;;; Backtrace support
;;;



(defmacro do-db-links ((db-link &optional var value) &body body)
  (let ((thunk (gensym))
        (var-var (or var (gensym)))
        (value-var (or value (gensym))))
    `(block nil
       (let ((,thunk #'(lambda (,db-link ,var-var ,value-var)
                         (declare (ignorable ,db-link))
                         ,@(unless var (list `(declare (ignore ,var-var))))
                         ,@(unless value (list `(declare (ignore ,value-var))))
                         ,@body)))
         (declare (dynamic-extent ,thunk))
         (map-db-links ,thunk)))))




(defun map-db-links (f)
  (without-interrupts
   (let ((db-link (%current-db-link)))
     (loop
       (when (eql 0 db-link) (return))
       (funcall f db-link (%fixnum-ref db-link (* 1 target::node-size)) (%fixnum-ref db-link (* 2 target::node-size)))
       (setq db-link (%fixnum-ref db-link))))))

(defun %get-frame-ptr ()
  (%current-frame-ptr))

(defun %current-exception-frame ()
  #+ppc-target *fake-stack-frames*
  #+x86-target (or (let* ((xcf (%current-xcf)))
                     (if xcf
                       (%%frame-backlink xcf)))
                   (%current-frame-ptr))
  #+arm-target (or (current-fake-stack-frame)
                   (%current-frame-ptr)))





(defun next-catch (catch)
  (let ((next-catch (uvref catch target::catch-frame.link-cell)))
    (unless (eql next-catch 0) next-catch)))




; @@@ this needs to load early so errors can work
(defun next-lisp-frame (p context)
  (let ((frame p))
    (loop
      (let ((parent (%frame-backlink frame context)))
        (multiple-value-bind (lisp-frame-p bos-p) (lisp-frame-p parent context)
          (if lisp-frame-p
            (return parent)
            (if bos-p
              (return nil))))
        (setq frame parent)))))

(defun parent-frame (p context)
  (loop
    (let ((parent (next-lisp-frame p context)))
      (when (or (null parent)
                (not (catch-csp-p parent context)))
        (return parent))
      (setq p parent))))





(defun last-frame-ptr (&optional context origin)
  (let* ((current (or origin
                      (if context (bt.current context) (%current-frame-ptr))))
         (last current))
    (loop
      (setq current (parent-frame current context))
      (if current
        (setq last current)
        (return last)))))



(defun child-frame (p context )
  (let* ((current (if context (bt.current context) (%current-frame-ptr)))
         (last nil))
    (loop
      (when (null current)
        (return nil))
      (when (eq current p) (return last))
      (setq last current
            current (parent-frame current context)))))





; This returns the current head of the db-link chain.
(defun db-link (&optional context)
  (if context
    (bt.db-link context)
    (%fixnum-ref (%current-tcr) (- target::tcr.db-link target::tcr-bias))))

(defun previous-db-link (db-link start )
  (declare (fixnum db-link start))
  (let ((prev nil))
    (loop
      (when (or (eql db-link start) (eql 0 start))
        (return prev))
      (setq prev start
            start (%fixnum-ref start 0)))))

(defun count-db-links-in-frame (vsp parent-vsp &optional context)
  (declare (fixnum vsp parent-vsp))
  (let ((db (db-link context))
        (count 0)
        (first nil)
        (last nil))
    (declare (fixnum db count))
    (loop
      (cond ((eql db 0)
             (return (values count (or first 0) (or last 0))))
            ((and (>= db vsp) (< db parent-vsp))
             (unless first (setq first db))
             (setq last db)
             (incf count)))
      (setq db (%fixnum-ref db)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; bogus-thing-p support
;;;

(defun %ptr-in-area-p (ptr area)
  (declare (optimize (speed 3) (safety 0)) (fixnum ptr area))           ; lie, maybe
  (and (<= (the fixnum (%fixnum-ref area target::area.low)) ptr)
       (> (the fixnum (%fixnum-ref area target::area.high)) ptr)))

(defun %active-area (area active)
  (or (do ((a area (%fixnum-ref a target::area.older)))
          ((eql a 0))
        (when (%ptr-in-area-p active a)
          (return a)))
      (do ((a (%fixnum-ref area target::area.younger) (%fixnum-ref a target::area.younger)))
          ((eql a 0))
        (when (%ptr-in-area-p active a)
          (return a)))))

(defun %ptr-to-vstack-p (tcr idx)
  (%ptr-in-area-p idx (%fixnum-ref tcr (- target::tcr.vs-area
					  target::tcr-bias))))

#-arm-target
(defun %on-tsp-stack (tcr object)
  (%ptr-in-area-p object (%fixnum-ref tcr (- target::tcr.ts-area
					     target::tcr-bias))))

(defun %on-csp-stack (tcr object)
  (let ((cs-area #+(and windows-target x8632-target)
		 (%fixnum-ref (%fixnum-ref tcr (- target::tcr.aux
						  target::tcr-bias))
			      target::tcr-aux.cs-area)
		 #-(and windows-target x8632-target)
		 (%fixnum-ref tcr target::tcr.cs-area)))
    (%ptr-in-area-p object cs-area)))

(defparameter *aux-tsp-ranges* ())
(defparameter *aux-vsp-ranges* ())
(defparameter *aux-csp-ranges* ())

(defun object-in-range-p (object range)
  (declare (fixnum object))
  (when range
    (destructuring-bind (active . high) range
      (declare (fixnum active high))
      (and (< active object)
           (< object high)))))

(defun object-in-some-range (object ranges)
  (dolist (r ranges)
    (when (object-in-range-p object r)
      (return t))))

#-arm-target
(defun on-any-tsp-stack (object)
  (or (%on-tsp-stack (%current-tcr) object)
      (object-in-some-range object *aux-tsp-ranges*)))

(defun on-any-vstack (idx)
  (or (%ptr-to-vstack-p (%current-tcr) idx)
      (object-in-some-range idx *aux-vsp-ranges*)))

(defun on-any-csp-stack (object)
  (or (%on-csp-stack (%current-tcr) object)
      (object-in-some-range object *aux-csp-ranges*)))

;;; This MUST return either T or NIL.
(defun temporary-cons-p (x)
  (and (consp x)
       (not (null (or (on-any-vstack x)
                      #-arm-target
                      (on-any-tsp-stack x)
                      #+arm-target
                      (on-any-csp-stack x))))))







(defun %value-cell-header-at-p (cur-vsp)
  (eql target::value-cell-header (%fixnum-address-of (%fixnum-ref cur-vsp))))

(defun count-stack-consed-value-cells-in-frame (vsp parent-vsp)
  (let ((cur-vsp vsp)
        (count 0))
    (declare (fixnum cur-vsp count))
    (loop
      (when (>= cur-vsp parent-vsp) (return))
      (when (and (evenp cur-vsp) (%value-cell-header-at-p cur-vsp))
        (incf count)
        (incf cur-vsp))                 ; don't need to check value after header
      (incf cur-vsp))
    count))

;;; stack consed value cells are one of two forms:
;;; Well, they were of two forms.  When they existed, that is.
;;;
;;; nil             ; n-4
;;; header          ; n = even address (multiple of 8)
;;; value           ; n+4
;;;
;;; header          ; n = even address (multiple of 8)
;;; value           ; n+4
;;; nil             ; n+8

(defun in-stack-consed-value-cell-p (arg-vsp vsp parent-vsp)
  (declare (fixnum arg-vsp vsp parent-vsp))
  (if (evenp arg-vsp)
    (%value-cell-header-at-p arg-vsp)
    (or (and (> arg-vsp vsp)
             (%value-cell-header-at-p (the fixnum (1- arg-vsp))))
        (let ((next-vsp (1+ arg-vsp)))
          (declare (fixnum next-vsp))
          (and (< next-vsp parent-vsp)
               (%value-cell-header-at-p next-vsp))))))



(defun count-values-in-frame (p context &optional child)
  (declare (ignore child))
  (multiple-value-bind (vsp parent-vsp) (vsp-limits p context)
    (values
     (- parent-vsp 
        vsp
        (* 2 (count-db-links-in-frame vsp parent-vsp context))))))

(defun nth-value-in-frame-loc (sp n context lfun pc vsp parent-vsp)
  (declare (fixnum sp))
  (setq n (require-type n 'fixnum))
  (unless (or (null vsp) (fixnump vsp))
    (setq vsp (require-type vsp '(or null fixnum))))
  (unless (or (null parent-vsp) (fixnump parent-vsp))
    (setq parent-vsp (require-type parent-vsp '(or null fixnum))))
  (unless (and vsp parent-vsp)
    (multiple-value-setq (vsp parent-vsp) (vsp-limits sp context)))
  (locally (declare (fixnum n vsp parent-vsp))
    (multiple-value-bind (db-count first-db last-db)
                         (count-db-links-in-frame vsp parent-vsp context)
      (declare (ignore db-count))
      (declare (fixnum first-db last-db))
      (let ((arg-vsp (1- parent-vsp))
            (cnt n)
            (phys-cell 0)
            db-link-p)
        (declare (fixnum arg-vsp cnt phys-cell))
        (loop
          (if (eql (the fixnum (- arg-vsp 2)) last-db)
            (setq db-link-p t
                  arg-vsp last-db
                  last-db (previous-db-link last-db first-db)
                  phys-cell (+ phys-cell 2))
            (setq db-link-p nil))
            (when (< (decf cnt) 0)
              (return
               (if db-link-p
                 (values (+ 2 arg-vsp)
                         :saved-special
                         (binding-index-symbol (%fixnum-ref (1+ arg-vsp))))
                 (multiple-value-bind (type name) (find-local-name phys-cell lfun pc)
                   (values arg-vsp type name)))))
          (incf phys-cell)
          (when (< (decf arg-vsp) vsp)
            (error "~d out of range" n)))))))



(defun nth-value-in-frame (sp n context &optional lfun pc vsp parent-vsp)
  (multiple-value-bind (loc type name)
                       (nth-value-in-frame-loc sp n context lfun pc vsp parent-vsp)
    (let* ((val (%fixnum-ref loc)))
      (when (and (eq type :saved-special)
		 (eq val (%no-thread-local-binding-marker))
		 name)
	(setq val (%sym-global-value name)))
      (values val  type name))))

(defun set-nth-value-in-frame (sp n context new-value &optional vsp parent-vsp)
  (multiple-value-bind (loc type name)
      (nth-value-in-frame-loc sp n context nil nil vsp parent-vsp)
    (let* ((old-value (%fixnum-ref loc)))
      (if (and (eq type :saved-special)
	       (eq old-value (%no-thread-local-binding-marker))
	       name)
	;; Setting the (shallow-bound) value of the outermost
	;; thread-local binding of NAME.  Hmm.
	(%set-sym-global-value name new-value)
	(setf (%fixnum-ref loc) new-value)))))

(defun nth-raw-frame (n start-frame context)
  (declare (fixnum n))
  (do* ((p start-frame (parent-frame p context))
	(i 0 (1+ i))
	(q (last-frame-ptr context)))
       ((or (null p) (eq p q) (%stack< q p context)))
    (declare (fixnum i))
    (if (= i n)
      (return p))))

(defun nth-function-frame (n start-frame context)
  (declare (fixnum n))
  (do* ((p start-frame (parent-frame p context))
	(i -1)
	(q (last-frame-ptr context)))
       ((or (null p) (eq p q) (%stack< q p context)))
    (declare (fixnum i))
    (when (function-frame-p p context)
      (incf i)
      (if (= i n)
        (return p)))))

;;; True if the object is in one of the heap areas
(defun %in-consing-area-p (x area)
  (declare (optimize (speed 3) (safety 0)) (fixnum x))       ; lie
  (let* ((low (%fixnum-ref area target::area.low))
         (high (%fixnum-ref area target::area.high))
)
    (declare (fixnum low high))
    (and (<= low x) (< x high))))



(defun in-any-consing-area-p (x)
  (do-consing-areas (area)
    (when (%in-consing-area-p x area)
      (return t))))









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; terminate-when-unreachable
;;;

#|
Message-Id: <v02130502ad3e6a2f1542@[205.231.144.48]>
Mime-Version: 1.0
Content-Type: text/plain; charset="us-ascii"
Date: Wed, 7 Feb 1996 10:32:55 -0500
To: pmcldev@digitool.com
From: bitCraft@taconic.net (Bill St. Clair)
Subject: terminate-when-unreachable

I propose that we add a general termination mechanism to PPC MCL.
We need it to properly terminate stack groups, it would be
a nicer way to do the termination for macptrs than the current
ad-hoc mechanism (which BTW is not yet part of PPC MCL), and
it is a nice addition to MCL. I don't think it's hard to make
the garbage collector support this, and I volunteer to do the
work unless Gary really wants to.

I see two ways to support termination:

1) Do termination for hash tables. This was our plan for
   2.0, but Gary got confused about how to mark the objects at
   the right time (or so I remember).

2) Resurrect weak alists (they're not part of the PPC garbage
   collector) and add a termination bit to the population type.
   This allows for termination of weak lists and weak alists,
   though the termination mechanism really only needs termination
   for a single weak alist.

I prefer option 2, weak alists, since it avoids the overhead
necessary to grow and rehash a hash table. It also uses less space,
since a finalizeable hash table needs to allocate two cons cells
for each entry so that the finalization code has some place to
put the deleted entry.

I propose the following interface (slightly modified from what
Apple Dylan provides):

terminate-when-unreachable object &optional (function 'terminate)
  When OBJECT becomes unreachable, funcall FUNCTION with OBJECT
  as a single argument. Each call of terminate-when-unreachable
  on a single (EQ) object registers a new termination function.
  All will be called when the object becomes unreachable.

terminate object                                         [generic function]
  The default termination function

terminate (object t)                                     [method]
  The default method. Ignores object. Returns nil.

drain-termination-queue                                  [function]
  Drain the termination queue. I.e. call the termination function
  for every object that has become unreachable.

*enable-automatic-termination*                           [variable]
  If true, the default, drain-termination-queue will be automatically
  called on the first event check after the garbage collector runs.
  If you set this to false, you are responsible for calling
  drain-termination-queue.

cancel-terminate-when-unreachable object &optional function
  Removes the effect of the last call to terminate-when-unreachable
  for OBJECT & FUNCTION (both tested with EQ). Returns true if
  it found a match (which it won't if the object has been moved
  to the termination queue since terminate-when-unreachable was called).
  If FUNCTION is NIL or unspecified, then it will not be used; the
  last call to terminate-when-unreachable with the given OBJECT will
  be undone.

termination-function object
  Return the function passed to the last call of terminate-when-unreachable
  for OBJECT. Will be NIL if the object has been put in the
  termination queue since terminate-when-unreachable was called.

|#


(defstatic *termination-population*
  (%cons-terminatable-alist))

(defstatic *termination-population-lock* (make-lock))


(defvar *enable-automatic-termination* t)

(defstatic  *termination-functions-lock* (make-lock))
(defstatic *termination-functions* (make-hash-table :test #'eq :lock-free nil))

(defun register-termination-function (f)
  (with-lock-grabbed (*termination-functions-lock*)
    (without-interrupts
     (incf (gethash f *termination-functions* 0)))))

(defun deregister-termination-function (f) 
  (with-lock-grabbed (*termination-functions-lock*)
    (without-interrupts
     (let* ((count (gethash f *termination-functions*)))
       (when count
         (if (eql 0 (decf count))
           (remhash f *termination-functions*)
           (setf (gethash f *termination-functions*) count)))))))

(defun terminate-when-unreachable (object &optional (function 'terminate))
  "The termination mechanism is a way to have the garbage collector run a
function right before an object is about to become garbage. It is very
similar to the finalization mechanism which Java has. It is not standard
Common Lisp, although other Lisp implementations have similar features.
It is useful when there is some sort of special cleanup, deallocation,
or releasing of resources which needs to happen when a certain object is
no longer being used."
  (let ((new-cell (cons object function))
        (population *termination-population*))
    (without-interrupts
     (register-termination-function function)
     (with-lock-grabbed (*termination-population-lock*)
       (atomic-push-uvector-cell population population.data new-cell)))
    function))

(defmethod terminate ((object t))
  nil)

(defun drain-termination-queue ()
  (with-lock-grabbed (*termination-population-lock*)
    (let* ((population *termination-population*))
      (loop
        (multiple-value-bind (cell existed)
            (atomic-pop-uvector-cell population population.termination-list)
          (if (not existed)
            (return)
            (let* ((f (cdr cell)))
              (deregister-termination-function f)
              (funcall f (car cell)))))))))

(defun cancel-terminate-when-unreachable (object &optional (function nil function-p))
  (let* ((found nil))
    (with-lock-grabbed (*termination-population-lock*)
      ;; We don't really need to be very paranoid here.  Nothing can
      ;; be added to the termination queue while we hold the lock,
      ;; and the GC can't splice anything out of the list while
      ;; we hold a strong reference to that list.
      (let* ((population *termination-population*)
             (queue (population.data population)))
        (do* ((prev nil spine)
              (spine queue (cdr spine)))
             ((null spine))
          (let* ((entry (car spine)))
            (destructuring-bind (o . f) entry
              (when (and (eq o object)
                         (or (null function-p)
                             (eq function f)))
                (deregister-termination-function f)
                (if prev
                  (setf (cdr prev) (cdr spine))
                  (setf (population.data population) (cdr spine)))
                (setq found t)
                (return)))))
      found))))


(defun termination-function (object)
  (without-interrupts
   (with-lock-grabbed (*termination-population-lock*)
     (cdr (assq object (population-data *termination-population*))))))

(defun do-automatic-termination ()
  (when *enable-automatic-termination*
    (drain-termination-queue)))

(queue-fixup
 (add-gc-hook 'do-automatic-termination :post-gc))

;;; A callback to handle foreign thread preparation, initialization,
;;; and termination.
;;; "preparation" involves telling the kernel to reserve space for
;;; some initial thread-specific special bindings.  The kernel
;;; needs to reserve this space on the foreign thread's vstack;
;;; it needs us to tell it how much space to reserve (enough
;;; for bindings of *current-thread*, *current-process*, and
;;; the default initial bindings of *PACKAGE*, etc.)
;;;
;;; "initialization" involves making those special bindings in
;;; the vstack space reserved by the kernel, and setting the
;;; values of *current-thread* and *current-process* to newly
;;; created values.
;;;
;;; "termination" involves removing the current thread and
;;; current process from the global thread/process lists.
;;; "preparation" and "initialization" happen when the foreign
;;; thread first tries to call lisp code.  "termination" happens
;;; via the pthread thread-local-storage cleanup mechanism.
(defcallback %foreign-thread-control (:without-interrupts t :int param :int)
  (declare (fixnum param))
  (cond ((< param 0) (%foreign-thread-prepare))
	((= param 0) (%foreign-thread-initialize) 0)
	(t (%foreign-thread-terminate) 0)))



(defun %foreign-thread-prepare ()
  (let* ((initial-bindings (standard-initial-bindings)))
    (%save-standard-binding-list initial-bindings)
    (* 3 (+ 2 (length initial-bindings)))))


(defun %foreign-thread-initialize ()
  ;; Recover the initial-bindings alist.
  (let* ((bsp (%saved-bindings-address))
	 (initial-bindings (%fixnum-ref bsp )))
    (declare (fixnum bsp))
    ;; Um, this is a little more complicated now that we use
    ;; thread-local shallow binding
    (flet ((save-binding (new-value sym prev)
             (let* ((idx (symbol-binding-index sym))
                    (byte-idx (ash idx target::fixnum-shift))
                    (binding-vector (%ensure-tlb-index idx))
                    (old-value (%fixnum-ref  binding-vector byte-idx)))
	     (setf (%fixnum-ref binding-vector byte-idx) new-value
                   (%fixnum-ref bsp (ash -1 target::word-shift)) old-value
		   (%fixnum-ref bsp (ash -2 target::word-shift)) idx
		   (%fixnum-ref bsp (ash -3 target::word-shift)) prev
		   bsp (- bsp 3)))))
      (save-binding nil '*current-lisp-thread* 0)
      (save-binding nil '*current-process* bsp)
      (dolist (pair initial-bindings)
	(save-binding (funcall (cdr pair)) (car pair) bsp))
      ;; These may (or may not) be the most recent special bindings.
      ;; If they are, just set the current tcr's db-link to point
      ;; to BSP; if not, "append" them to the end of the current
      ;; linked list.
      (let* ((current-db-link (%fixnum-ref (%current-tcr)
					   (- target::tcr.db-link
					      target::tcr-bias))))
        (declare (fixnum current-db-link))
        (if (zerop current-db-link)
          (setf (%fixnum-ref (%current-tcr) (- target::tcr.db-link
					       target::tcr-bias)) bsp)
          (do* ((binding current-db-link)
                (next (%fixnum-ref binding 0)
                      (%fixnum-ref binding 0)))
               ()
            (if (zerop next)
              (return (setf (%fixnum-ref binding 0) bsp))
              (setq binding next)))))
      ;; Ensure that pending unwind-protects (for WITHOUT-INTERRUPTS
      ;; on the callback) don't try to unwind the binding stack beyond
      ;; where it was just set.
      (do* ((catch (%fixnum-ref (%current-tcr) (- target::tcr.catch-top
						  target::tcr-bias))
                   (%fixnum-ref catch target::catch-frame.link)))
           ((zerop catch))
        (declare (fixnum catch))
        (when (eql 0 (%fixnum-ref catch target::catch-frame.db-link))
          (setf (%fixnum-ref catch target::catch-frame.db-link) bsp)))))
  (let* ((thread (new-lisp-thread-from-tcr (%current-tcr) "foreign")))
    (setf *current-lisp-thread* thread
	  *current-process* (make-process "foreign" :thread thread)
          (car (process-whostate-cell *current-process*)) "Foreign thread callback")))
    
;;; Remove the foreign thread's lisp-thread and lisp process from
;;; the global lists.
(defun %foreign-thread-terminate ()
  (let* ((proc *current-process*))
    (when proc
      (remove-from-all-processes proc)
      (let* ((ts (process-termination-semaphore proc)))
        (when ts (signal-semaphore ts))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-lisp-threads.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-events.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defvar *inhibit-abort* nil)

;;; If any bits in the *periodic-task-mask* are set in the
;;; ptaskstate.flags word of a periodic task, it will not be run
(defvar *periodic-task-mask* 0)

(defmethod print-object ((p periodic-task) stream)
  (print-unreadable-object (p stream :type t :identity t)
    (format stream "~s ~d"
	    (ptask.name p)
	    (ptaskstate.interval (ptask.state p)))))

(defvar *periodic-task-lock* (make-lock))

(defun find-named-periodic-task (name)
  (dolist (task *%periodic-tasks%*)
    (when (eq name (ptask.name task))
      (return task))))

(defun %install-periodic-task (name function interval &optional 
                                    (flags 0)
                                    (privatedata (%null-ptr)))
  (with-lock-grabbed (*periodic-task-lock*)
   (let* ((already (find-named-periodic-task name))
          (state (if already (ptask.state already)
                   (%istruct 'ptaskstate 0 0 0 0)))
          (task (or already (%istruct 'periodic-task state name nil))))
     (setf (ptask.function task) function)
     (setf (ptaskstate.interval state) interval
           (ptaskstate.flags state ) flags
           (ptaskstate.privatedata state) privatedata
           (ptaskstate.nexttick state) (+ (get-tick-count) interval))
     (unless already (push task *%periodic-tasks%*))
     (let* ((interval-in-seconds (/ interval (float *ticks-per-second*))))
       (if (< interval-in-seconds *periodic-task-interval*)
         (set-periodic-task-interval interval-in-seconds)))
     task)))

(defmacro with-periodic-task-mask ((mask) &body body)
  (let ((thunk (gensym)))
    `(let ((,thunk #'(lambda () ,@body)))
       (funcall-with-periodic-task-mask ,mask ,thunk))))

(defvar *periodic-task-masks* nil)

; All this hair is so that multiple processes can vote on the *periodic-task-mask*
(defun funcall-with-periodic-task-mask (mask  thunk)
  (let* ((cell (list mask)))
    (declare (dynamic-extent cell))
    (flet ((logior-list (list)
             (declare (type list list))
             (let ((res 0))
               (declare (fixnum res))
               (loop
                 (when (null list) (return res))
                 (setq res (%ilogior res (pop list)))))))
      (declare (inline logior-list))
      (unwind-protect
        (progn
          (without-interrupts
           (setf (cdr cell) *periodic-task-masks*
                 *periodic-task-masks* cell)
           (setq *periodic-task-mask* (logior-list *periodic-task-masks*))
)
          (funcall thunk))
        (without-interrupts
         (let* ((first *periodic-task-masks*)
                (this first)
                (last nil))
           (declare (type cons first this last))
           (loop
             (when (eq this cell)
               (if last
                 (setf (cdr last) (cdr this))
                 (pop first))
               (return (setq *periodic-task-masks* first)))
             (setq last this
                   this (cdr this))))
         (setq *periodic-task-mask* (logior-list *periodic-task-masks*)))))))

(defparameter *invoke-debugger-hook-on-interrupt* nil)

(define-condition interrupt-signal-condition (condition) ()
  (:report "interrupt signal"))

(defmethod force-break-in-listener ((p process))
  (process-interrupt p
		     #'(lambda ()
                         (multiple-value-bind (vars inits old-vals) (%check-error-globals)
                           (progv vars old-vals
                             (mapcar (lambda (v f) (set v (funcall f))) vars inits)
                             (let ((condition (make-condition 'interrupt-signal-condition))
                                   (*top-error-frame* (%current-exception-frame)))
                               (ignoring-without-interrupts
                                 (when *invoke-debugger-hook-on-interrupt*
                                   (let* ((hook *debugger-hook*)
                                          (*debugger-hook* nil))
                                     (when hook
                                       (funcall hook condition hook))))
                                 (%break-in-frame *top-error-frame* condition)
                                 (clear-input *terminal-io*))))))))

(defglobal *quit-interrupt-hook* nil)

(defun force-async-quit (signum)
  (when *quit-interrupt-hook*
    (multiple-value-bind (req opt restp) (function-args *quit-interrupt-hook*)
      (if (and (= req 0) (= opt 0) (not restp))
        (funcall *quit-interrupt-hook*)
        (funcall *quit-interrupt-hook* signum))))
  ;; Exit by resignalling, as per http://www.cons.org/cracauer/sigint.html
  (quit #'(lambda ()
            (ff-call (%kernel-import target::kernel-import-lisp-sigexit) :signed signum)
            ;; Shouldn't get here
            (#__exit 143))))

(defstatic *running-periodic-tasks* nil)

(defun cmain ()
  (thread-handle-interrupts))


(defvar *select-interactive-process-hook* nil)

(defun select-interactive-abort-process ()
  (flet ((maybe-proc (proc) (and proc (process-active-p proc) proc)))
    (or (maybe-proc (and *select-interactive-process-hook*
                         (funcall *select-interactive-process-hook*)))
        (maybe-proc *interactive-abort-process*)
        (let* ((sr (input-stream-shared-resource *terminal-input*)))
          (when sr
            (or (maybe-proc (shared-resource-current-owner sr))
                (maybe-proc (shared-resource-primary-owner sr))))))))

(defun handle-gc-hooks ()
  (let ((bits *gc-event-status-bits*))
    (declare (fixnum bits))
    (cond ((logbitp $gc-postgc-pending-bit bits)
           (setq *gc-event-status-bits*
                 (logand (lognot (ash 1 $gc-postgc-pending-bit))
                         bits))
           (let ((f *post-gc-hook*))
             (when (functionp f) (funcall f)))))))

(defconstant $user-interrupt-break 1)
(defconstant $user-interrupt-quit 2)

(defun housekeeping ()
  (progn
    (handle-gc-hooks)
    (unless *inhibit-abort*
      (let* ((id (pending-user-interrupt))
             (kind (logand #xFF id)))
        (cond ((eql kind $user-interrupt-quit)
               ;; Try to use a process that has a shot at reporting any problems
               ;; in case of bugs in user hook.
               (let* ((proc (or (select-interactive-abort-process)
                                *initial-process*))
                      (signum (ash id -8)))
                 (process-interrupt proc #'force-async-quit signum)))
              ((eql kind $user-interrupt-break)
               (let* ((proc (select-interactive-abort-process)))
                 (if proc
                   (force-break-in-listener proc)))))))
    (flet ((maybe-run-periodic-task (task)
             (let ((now (get-tick-count))
                   (state (ptask.state task)))
               (when (and (>= (- now (ptaskstate.nexttick state))
                              0)
                          (eql 0 (logand (the fixnum (ptaskstate.flags state))
                                         (the fixnum *periodic-task-mask*))))
                 (setf (ptaskstate.nexttick state)
                       (+ now (ptaskstate.interval state)))
                 (funcall (ptask.function task))))))
      (let ((event-dispatch-task *event-dispatch-task*))
        (maybe-run-periodic-task event-dispatch-task)
        (with-lock-grabbed (*periodic-task-lock*)
          (bitclrf $gc-allow-stack-overflows-bit *gc-event-status-bits*)
          (unless *running-periodic-tasks*
            (let-globally ((*running-periodic-tasks* t))
              (dolist (task *%periodic-tasks%*)
                (unless (eq task event-dispatch-task)
                  (maybe-run-periodic-task task))))))))))


(defun %remove-periodic-task (name)
  (with-lock-grabbed (*periodic-task-lock*)
    (let ((task (find-named-periodic-task name)))
      (when task
        (if (setq *%periodic-tasks%* (delete task *%periodic-tasks%*))
          (let* ((min-ticks target::target-most-positive-fixnum))
            (dolist (other *%periodic-tasks%*
                     (set-periodic-task-interval (/ min-ticks (float *ticks-per-second*))))
              (let* ((other-ticks
                      (ptaskstate.interval (ptask.state other))))
                (if (< other-ticks min-ticks)
                  (setq min-ticks other-ticks)))))
          (set-periodic-task-interval 1)))
      task)))


(defun auto-flush-interactive-streams ()
  (with-lock-grabbed (*auto-flush-streams-lock*)
    (dolist (s *auto-flush-streams*)
      (when (open-stream-p s)
        (if (or (typep s 'basic-stream)
                (typep s 'buffered-io-stream-mixin))
          (if (ioblock-outbuf-lock (stream-ioblock s t))
            (force-output s)))
        (force-output s)))))

(defun add-auto-flush-stream (s)
  (with-lock-grabbed (*auto-flush-streams-lock*)
    (when (typep s 'output-stream)
      (pushnew s *auto-flush-streams*))))
      
(defun remove-auto-flush-stream (s)
  (with-lock-grabbed (*auto-flush-streams-lock*)
    (setq *auto-flush-streams* (delete s *auto-flush-streams*))))

; Is it really necessary to keep this guy in a special variable ?
(defloadvar *event-dispatch-task* 
  (%install-periodic-task 
   'auto-flush-interactive-streams
   'auto-flush-interactive-streams
   (truncate *ticks-per-second* 3)	;run 3 times/sec
   (+ $ptask_draw-flag $ptask_event-dispatch-flag)))


(defun event-ticks ()
  (let ((task *event-dispatch-task*))
    (when task (ptaskstate.interval (ptask.state task)))))

(defun set-event-ticks (n)
  (setq n (require-type n '(integer 0 32767)))   ;  Why this weird limit ?
  (let ((task *event-dispatch-task*))
    (when task (setf (ptaskstate.interval (ptask.state task)) n))))

;; Making the *initial-process* quit will cause an exit(),
;; though it might be nicer if all processes were shut down
;; in an orderly manner first.  This is the not-so-nice way
;; of quitting ...
(defun %quit ()
  (quit))



; end of L1-events.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-events.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-pathnames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2001 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.



;; L1-pathnames.lisp
;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
;ANSI CL logical pathnames

(in-package "CCL")

(defun heap-image-name ()
  (let* ((p (%null-ptr))
         (string (%get-utf-8-cstring (%get-kernel-global-ptr 'image-name p))))
    (declare (dynamic-extent p))
    #+windows-target (nbackslash-to-forward-slash string)
    #+darwin-target (precompose-simple-string string)
    #-(or windows-target darwin-target) string))

(defloadvar *heap-image-name* (heap-image-name))

(defloadvar *command-line-argument-list*
  (let* ((argv (%null-ptr))
	 (res ()))
    (declare (dynamic-extent argv))
    (%get-kernel-global-ptr 'argv argv)
    (do* ((i 0 (+ i target::node-size))
	  (arg (%get-ptr argv i) (%get-ptr argv i)))
	 ((%null-ptr-p arg) (nreverse res))
      (declare (fixnum i))
      (push (%get-utf-8-cstring arg) res))))

;These are used by make-pathname
(defun %verify-logical-component (name type)
  (when (and name (neq name :unspecific))
    (setq name (ensure-simple-string name))
    (when (or (eql 0 (length name))
              (%str-member *pathname-escape-character* name) ;; Hmm, why?
              (%path-mem "/;" name))
      (error "Illegal logical pathname ~A component ~S" type name)))
  name)


(defun verify-logical-host-name (host)
  (or (and host
	   (%verify-logical-component host "host")
	   (%str-assoc host %logical-host-translations%)
	   host)
      (host-error host)))

(defun %logical-version-component (version)
  (if (or (fixnump version)
          (stringp version)
          (memq version '(nil :wild :newest :unspecific)))
    version
    (require-type version '(or fixnum string (member nil :wild :newest :unspecific)))))

(defun logical-pathname-translations (host)
  "Return the (logical) host object argument's list of translations."
  (setq host (verify-logical-host-name host))
  (let ((translations (%str-assoc host %logical-host-translations%)))
    (unless translations (host-error host))
    (%cdr translations)))

(defun logical-host-p (host)
  (%str-assoc host %logical-host-translations%))

(defun host-error (host) ; supposed to be a type-error
  (signal-type-error host  '(satisfies logical-host-p) "~S is not a defined logical host"))

(defun set-logical-pathname-translations (host list)
  (setq host (%verify-logical-component  host "host"))
  (let ((old (%str-assoc host %logical-host-translations%))
	(new (let ((%logical-host-translations% (cons (list host) %logical-host-translations%)))
	       ;; Do this in the context when host is defined, so no errors.
	       (mapcar #'(lambda (trans)
			   (destructuring-bind (from to &rest ignored) trans
			     (declare (ignore ignored))
			     (let ((from-path (parse-namestring from host))
				   (to-path (pathname to)))
			       (list (require-type from-path 'logical-pathname) to-path))))
		       list))))
    (if old
      (progn (%rplaca old host) (%rplacd old new))
      (push (cons host new) %logical-host-translations%)))
  list)

(defsetf logical-pathname-translations set-logical-pathname-translations)

;;; doesnt check if already there - adds at front 
(defun add-logical-pathname-translation (host translation)
  (let ((trans (%str-assoc host  %logical-host-translations%)))
    (if (not trans)
      (set-logical-pathname-translations host (list translation))
      (let ((new (destructuring-bind (from to &rest ignored) translation
		   (declare (ignore ignored))
		   (list (parse-namestring from host) (pathname to)))))
        (rplacd trans (cons new (cdr trans)))
        (cdr trans)))))

(defun %component-match-p (name wild) 
  (if (or (eq name :unspecific)(eq name :wild)(eq name :wild-inferiors)(and (stringp name) (or  (string= name "*")(string= name "**"))))
    (setq name nil))  
  (if (or (eq wild :unspecific)(eq wild :wild)(eq wild :wild-inferiors)(eq wild :newest)(and (stringp wild) (or (string= wild "*")(string= wild "**"))))
    (setq wild nil))
  (cond ((null name) 
         (null wild))
        ((null wild)
         t)
        ((not (and (stringp name) (stringp wild)))
         (eq name wild))
        (t (%path-str*= (namestring-unquote name) wild))))

(defun translate-directory (source from to reversible &optional thost)
  (declare (ignore thost)) ;; leftover from a mac kludge.
  (let* ((result (translate-directory2 (cdr source)(cdr from)(cdr to) reversible))
	 (relative-p (eq (car source) :relative)))
    (cond ((and (not relative-p)(eq result (cdr source))) (or source (list :absolute)))
	  ((and (not relative-p)(eq result (cdr to))) to)
	  (t (cons (car (or to source from)) result)))))



(defun translate-directory2 (source from to reversible)
  ; we already know it matches
  (let (result srest match tfirst trest twild)
    (multiple-value-setq (tfirst trest twild)
			 (%split-ccdirectory to))
    (when (and to (not twild))
      (return-from translate-directory2 to))
    (multiple-value-bind (ffirst frest fwild)
			 (%split-ccdirectory from)
      (setq srest (nthcdr (length ffirst) source))
      (cond ((eq fwild '**)
	     (setq match (nth-value 1 (%pathname-match-dir1 srest frest t)))               
	     (cond ((eq twild '**)
		    (setq result (nconc tfirst match))
		    (setq srest (nthcdr (length match) srest)))
		   (t (return-from translate-directory2
			(translate-directory2 source (nconc ffirst match frest)
					      to reversible)))))
	    ((eq twild '**)
	     (let ((length (length tfirst)))
	       (setq srest (nthcdr length source))
	       (setq frest (nthcdr length from))
	       (setq  match (nth-value 1 (%pathname-match-dir1 srest trest t)))
	       (cond ((null  match)
		      (setq result tfirst))
		     (t (setq srest (nthcdr (setq length (length match)) srest))
			(setq frest (nthcdr length frest))
			(setq result (nconc tfirst match))))))
	    (t
	     (cond ((null fwild)
		    ; to has a wild component e.g. *abc, from is not wild
		    ; by defintion source is also not wild
		    ; which random source component gets plugged in here??
		    (setq srest (nthcdr (length tfirst) source))
		    (setq frest (nthcdr (length tfirst) source))))
	     (let ((part (translate-component
				(car srest) (car frest)(car trest) reversible)))
	       (if (null part)(setq result tfirst)
		   (progn
		     (setq part (list part))
		     (setq result (nconc tfirst part)))))
	     (setq srest (cdr srest) frest (cdr frest) trest (cdr trest))))
      (when trest 
	(let ((foo (translate-directory2 srest frest trest reversible)))
	  (when foo (setq result (nconc result foo))))))
    result))

; cc stands for cdr canonical
; ("abc" "**" "def" => ("abc") ("def")
; ("abc" "*de") => ("abc") ("*de")
(defun %split-ccdirectory (dir)
  (let ((pos 0) (wildp nil)(rest dir))
    (dolist (e dir)
      (case e
        (:wild (setq wildp '*))
        (:wild-inferiors 
         (setq wildp '**)
         (setq rest (cdr rest)))
	(:up nil)
        (t 
         (when (%path-mem "*" e)
           (cond ((string= e "**")
                  (setq rest (cdr rest))
                  (setq wildp '**))
                 ((eql 1 (length (the string e)))
                  (setq wildp '*))
                 (t (setq wildp t))))))
      (when wildp (return))
      (setq rest (cdr rest))
      (setq pos (%i+ 1 pos)))
    (cond ((not wildp)
           (values dir))
          (t (let (first)
               (when rest (setq rest (copy-list rest)))
               (dotimes (i pos)
                 (declare (fixnum i))
                 (push (car dir) first)
                 (setq dir (cdr dir)))
               (values (nreverse first) rest wildp))))))

; could avoid calling component-match-p by checking here maybe
; if "gazonk" "gaz*" "h*" => "honk"
; then "gazonk" "gaz*" "*" => "onk" or is it "gazonk" (per pg 625)
; I believe in symbolics land "gazonk" is a regular translation
; and "onk" is a reversible translation (achieved by not doing pg 625) AHH
; similarly is "a:" "a:**:" "**"  Nil or "a:" 
(defun translate-component (source from to &optional reversible)                   
  (let ((orig-to to))
    (cond 
     ((and (consp source)(consp from)) ; source and from both logical 
      (setq source (cadr source) from (cadr from)))
     ((or (consp source)(consp from)) ;  or neither
      #-bccl (error "Something non-kosher in translate pathname")
      ))
    (when (memq from '(:wild :wild-inferiors)) (setq from "*"))
    (when (memq source '(:wild :wild-inferiors))(setq source "*"))
    (when (memq to '(:wild :wild-inferiors))(setq to "*"))
    (cond ((consp to)(setq to (cadr to))))  ;??
    (cond ((and (stringp to)(not (%path-mem "*" to)))
           to)
          ((and (or (not reversible)(not (stringp source))) ; <<
                (or (null to)
                    (and (stringp to)(or (string= to "**")(string= to "*")))))
           source)
          ((eq to :unspecific) to)  ; here we interpret :unspecific to mean don't want it
          ((not (stringp source)) to)
          (t 
           (let ((slen (length source)) srest match spos result (f2 nil) snextpos)
             (multiple-value-bind (tfirst trest twild)
                                  (%split-component to)
               (cond ((and to (not twild))(return-from translate-component to)))
               (multiple-value-bind (ffirst frest fwild)
                                    (%split-component from)          
                 (cond (fwild
                        (setq spos (if ffirst (length ffirst) 0))       ; start of source hunk
                        (if frest (setq f2 (%split-component frest)))
                        (setq snextpos (if f2 (%path-member f2 source spos) slen))
                        (setq match (%substr source spos snextpos))
                        (if frest (setq srest (%substr source snextpos slen)))
                        (setq result (if tfirst (%str-cat tfirst match) match))
                        (when frest 
                          (let ((foo (translate-component srest frest trest reversible)))
                            (when foo (setq result (%str-cat result foo))))))
                       (t  ; to is wild, from and source are not
                        (setq result (if tfirst (%str-cat tfirst source) source))
                        (when trest (setq result (%str-cat result trest))))))
               (if (consp orig-to)(progn (error "shouldnt")(list :logical result)) result) ; 7/96
               ))))))


(defun %path-member (small big &optional (start 0))
  (let* ((end (length big))
         (s-end (length small))
         (s-start 1)
         (c1 (%schar small 0))
         (pstart start))
    (if (%i> s-end end)(return-from %path-member nil))
    (when (eql c1 *pathname-escape-character*)
      (setq c1 (%schar small 1))
      (setq s-start 2))      
    (while (and (progn (if (eql (%schar big pstart) *pathname-escape-character*)
                         (setq pstart (%i+ pstart 1)))
                       T)
                (%i< pstart end)
                (neq (%schar big pstart) c1))
      (setq pstart (%i+ pstart 1)))
    (if (neq c1 (%schar big pstart))(return-from %path-member nil))
    (setq start (%i+ pstart 1))
    (while (and (progn (if (eql (%schar big start) *pathname-escape-character*)
                         (setq start (%i+ 1 start)))
                       (if (eql (%schar small s-start) *pathname-escape-character*)
                         (setq s-start (%i+ 1 s-start)))
                       T)
                (%i< start end)
                (%i< s-start s-end)
                (eql (%schar big start)(%schar small s-start)))
      (setq start (%i+ start 1) s-start (%i+ s-start 1)))
    (cond ((= (the fixnum s-start) (the fixnum s-end))
            pstart)
          ((%i< start end)
            (%path-member small big (%i+ 1 pstart)))
          (T nil))))

(defun %split-component (thing &aux pos)
  ;"ab*cd*"  ->  "ab" "cd*"  
  (if (or (not (typep thing 'string))(null (setq pos (%path-mem "*" thing))))
    (values thing nil nil)
    (let* ((len (length thing)))
      (declare (fixnum len))
      (values (if (%izerop pos) nil (%substr thing 0 pos))
              (cond ((eql len (%i+ pos 1)) nil)
                    (t 
                     (when (eq (%schar thing (+ pos 1)) #\*)
                       (setq pos (+ pos 1)))
                     (cond ((eql len (%i+ pos 1)) nil)
                           (t (%substr thing (%i+ pos 1) len)))))
              T))))

(defun translate-pathname (source from-wildname to-wildname &key reversible)
  "Use the source pathname to translate the from-wildname's wild and
   unspecified elements into a completed to-pathname based on the to-wildname."
  (when (not (pathnamep source)) (setq source (pathname source)))
  (flet ((translate-pathname-component-mismatch (component-name source from)
	   (error "~S components of source ~S and from-wildname ~S do not match" component-name source from)))
    (let (r-host  r-directory r-name r-type r-version s-host f-host t-host t-device)
      (setq s-host (pathname-host source))
      (setq f-host (pathname-host from-wildname))
      (setq t-host (pathname-host to-wildname))
      (setq t-device (pathname-device to-wildname))
      (if (not (%host-component-match-p s-host f-host)) (translate-pathname-component-mismatch 'pathname-host source from-wildname))
      (setq r-host (translate-component s-host f-host t-host reversible))
      (let ((s-dir (%std-directory-component (pathname-directory source) s-host))
            (f-dir (%std-directory-component (pathname-directory from-wildname) f-host))
            (t-dir (%std-directory-component (pathname-directory to-wildname) t-host)))
        (let ((match (%pathname-match-directory s-dir f-dir)))
          (if (not match)(translate-pathname-component-mismatch 'pathname-directory source from-wildname))
          (setq r-directory  (translate-directory s-dir f-dir t-dir reversible t-host))))
      (let ((s-name (pathname-name source))
            (f-name (pathname-name from-wildname))
            (t-name (pathname-name to-wildname)))
        (if (not (%component-match-p s-name f-name))(translate-pathname-component-mismatch 'pathname-name  source from-wildname))        
        (setq r-name (translate-component s-name f-name t-name reversible)))
      (let ((s-type (pathname-type source))
            (f-type (pathname-type from-wildname))
            (t-type (pathname-type to-wildname)))
        (if (not (%component-match-p s-type f-type))(translate-pathname-component-mismatch 'pathname-component source from-wildname))
        (setq r-type (translate-component s-type f-type t-type reversible)))
      (let ((s-version (pathname-version source))
            (f-version (pathname-version from-wildname))
            (t-version (pathname-version to-wildname)))
        (if (not (%component-match-p s-version f-version)) (translate-pathname-component-mismatch 'pathname-version source from-wildname))
        (setq r-version (translate-component s-version f-version t-version reversible))
        ;(if (eq r-version :unspecific)(setq r-version nil))
        )
      (make-pathname :device t-device :host r-host :directory r-directory
                     :name r-name :type r-type :version r-version :defaults nil)
      )))



(defvar %empty-logical-pathname% (%cons-logical-pathname nil nil nil nil nil))

(defun logical-pathname-namestring-p (string)
  (multiple-value-bind (sstr start end) (get-pathname-sstring string)
    (let ((host (pathname-host-sstr sstr start end t)))
      (and host (not (eq host :unspecific))))))

  
;; This extends CL in that it allows a host-less pathname, like "foo;bar;baz".
(defun logical-pathname (thing &aux (path thing))
  "Converts the pathspec argument to a logical-pathname and returns it."
  (when (typep path 'stream) (setq path (%path-from-stream path)))
  (etypecase path
    (logical-pathname path)
    (pathname (report-bad-arg thing 'logical-pathname))
    (string
     (multiple-value-bind (sstr start end) (get-sstring path)
       ;; Prescan the host, to avoid unknown host errors.
       (let ((host (pathname-host-sstr sstr start end t)))
         (when (or (null host) (eq host :unspecific))
           (report-bad-arg path '(satisfies logical-pathname-namestring-p)))
	 (let ((%logical-host-translations% (cons (list host) %logical-host-translations%)))
	   (declare (special %logical-host-translations%))
	   ;; By calling string-to-pathname with a logical pathname as default, we force
	   ;; parsing as a logical pathname.
	   (string-to-pathname sstr start end nil %empty-logical-pathname%)))))))

(defun %host-component-match-p (path-host wild-host)
  ;; Note that %component-match-p is case sensitive.  Need a
  ;; case-insensitive version for hosts. 
  ;; In addition, host components do not support wildcards.
  (or (null wild-host) (eq wild-host :wild)
      (null path-host) (eq path-host :wild)
      (eq path-host wild-host)
      (and (stringp path-host)
	   (stringp wild-host)
	   (string-equal path-host wild-host))))

(defun pathname-match-p (pathname wildname)
  "Pathname matches the wildname template?"
  (let ((path-host (pathname-host pathname))
        (wild-host (pathname-host wildname)))
    (and
     (%host-component-match-p path-host wild-host)
     (%component-match-p (pathname-device pathname)(pathname-device wildname))
     (%pathname-match-directory
      (%std-directory-component (pathname-directory pathname) path-host)
      (%std-directory-component (pathname-directory wildname) wild-host))
     (%component-match-p (pathname-name pathname)(pathname-name wildname))
     (%component-match-p (pathname-type pathname)(pathname-type wildname))
     (%component-match-p (pathname-version pathname)(pathname-version wildname)))))


; expects canonicalized directory - how bout absolute vs. relative?
(defun %pathname-match-directory (path wild)
  (cond ((equal path wild) t)
	 ; Don't allow matching absolute and relative, so that can have distinct
	 ; absolute and wild translations in logical-pathname-translations for
	 ; a host, and have them match separately.
	((and (consp path)(consp wild)(neq (car path) (car wild)))
	 nil)  ; one absolute & one relative ??
        ((or ;(and (null wild)
             ;     (let ((dir (cadr path)))
             ;       (if (stringp dir)(string= dir "**")(eq dir :wild-inferiors))))
             (and (null (cddr wild))
                  (let ((dir (cadr wild)))
                    (if (stringp dir)(string= dir "**")(eq dir :wild-inferiors))))))
	((null path)
	 ;; Make missing dir match (:absolute) or (:relative) - is that right?
	 (null (cdr wild)))
	((null wild)
	 nil)
        (t (%pathname-match-dir0 (cdr path)(cdr wild)))))

; munch on tails path and wild 
(defun %pathname-match-dir0 (path wild)
  (flet ((only-wild (dir)
                    (when (null (cdr dir))
                      (setq dir (car dir))
                      (when (consp dir) (setq dir (cadr dir)))
                      (if (stringp dir)(string= dir "**")(eq dir :wild-inferiors)))))
    (cond ((eq path wild) t)
          ((only-wild wild)
           t)
          (t (let ((result t))
               (block nil 
                 (while (and path wild)
                   (let ((pathstr (car path))
                         (wildstr (car wild)))                     
                     ; allow logical to match physical today
                     ; because one of these days these logical things will disappear!
                     (when (consp pathstr)(setq pathstr (cadr pathstr)))
                     (when (consp wildstr)(setq wildstr (cadr wildstr)))
                     (case wildstr
                       (:wild (setq wildstr "*"))
                       (:wild-inferiors (setq wildstr "**")))
                     (case pathstr
                       (:wild (setq pathstr "*"))
                       (:wild-inferiors (setq pathstr "**")))
                     (if (or (memq wildstr '(:up :back))(memq pathstr '(:up :back))) ;; ????? <<<<
                       (when (neq pathstr wildstr)(setq result nil) (return-from nil))
                       (when (not 
                              (cond ((string= wildstr "**")
                                     (setq result (%pathname-match-dir1 path (cdr wild)))
                                     (return-from nil))
                                    ((%path-str*= (namestring-unquote pathstr) wildstr))))
                         (setq result nil)
                         (return-from nil)))
                     (setq wild (cdr wild) path (cdr path))))
                 (when (and (or path wild)(not (only-wild wild)))
                   (setq result nil)))
               result)))))



; wild is stuff after a "**" - looking for what matches the **  in (path)
(defun %pathname-match-dir1 (path wild &optional cons-result)
  (let ((match nil) pathstr wildstr)
    (cond ((null wild)
           (values T (if cons-result (mapcar #'(lambda (e)
                                            (if (consp e)(cadr e) e))
                                        path))))
          ((%pathname-match-dir0 path wild))   ; ie ** matches nothing
          (t 
           (prog nil
             AGN
               (setq pathstr (car path) wildstr (car wild))
               (when (consp pathstr)(setq pathstr (cadr pathstr)))
               (when (consp wildstr)(setq wildstr (cadr wildstr)))
               (case wildstr
                 (:wild (setq wildstr "*"))
                 (:wild-inferiors (setq wildstr "**")))
               (case pathstr
                 (:wild (setq pathstr "*"))
                 (:wild-inferiors (setq pathstr "**")))
               (until (or (not (consp path))
                          (%path-str*= (namestring-unquote pathstr) wildstr))
                 (when cons-result (push pathstr match))
                 (setq path (cdr path))
                 (setq pathstr (car path))
                 (when (consp pathstr)(setq pathstr (cadr pathstr))))
               ;; either got a match - w and path both have the thing we looked for
               ;; or path is empty
               (when (null path)(return nil))
               (let ((path1 (cdr path))(wild (cdr wild)))
                 (when (and (null path1)(null wild))
                   (return (values t (when match (nreverse match)))))
                 (cond ((%pathname-match-dir0 path1 wild)  ; is the rest happy too?
                        (return (values t (nreverse match))))
                       (t (when cons-result (push pathstr match)) ; nope, let ** eat more
                          (setq path (cdr path))
                          (go AGN)))))))))

; three times bigger and 3 times slower - does it matter?
;; This assumes pattern is escaped, but pstr is a native string (not escaped)
(defun %path-str*= (native-pstr pattern)
  (multiple-value-bind (string s-start s-end) (get-sstring native-pstr)
    (multiple-value-bind (pattern p-start p-end) (get-sstring pattern)
      (path-str-sub pattern string p-start s-start p-end s-end))))

(defun path-str-sub (pattern str p-start s-start p-end s-end)
  (declare (fixnum p-start s-start p-end s-end)
	   (type simple-base-string pattern str))
  (declare (optimize (speed 3)(safety 0)))
  (let ((p (%scharcode pattern p-start))
        (esc (char-code *pathname-escape-character*)))
    (cond 
     ((eq p (char-code #\*))
      ; starts with a * find what we looking for unless * is last in which case done
      (loop ; lots of *'s same as one
        (when (eq (%i+ 1 p-start)  p-end)
          (return-from path-str-sub t))
        (if (eq (%schar pattern (%i+ 1 p-start)) #\*)
          (setq p-start (1+ p-start))
          (return)))
      (let* ((next* (%path-mem "*" pattern (%i+ 1 p-start)))
             (len (- (or next* p-end) (%i+ 1 p-start))))
        (loop
          (when (> (+ s-start len) s-end)(return nil))
          (let ((res (find-str-pattern pattern str (%i+ 1 p-start) s-start (or next* p-end) s-end))) 
            (if (null res)
              (return nil)
              (if (null next*)
                (if (eq res s-end)
                  (return t))                  
                (return (path-str-sub pattern str next* (+ s-start len) p-end s-end)))))
          (setq s-start (1+ s-start)))))
     (t (when (eq p esc)
          (setq p-start (1+ p-start))
          (setq p (%scharcode pattern p-start)))
        (let* ((next* (%path-mem "*" pattern (if (eq p (char-code #\*))(%i+ 1 p-start) p-start)))
               (this-s-end (if next* (+ s-start (- next* p-start)) s-end)))
          (if (> this-s-end s-end)
            nil
            (if  (path-str-match-p pattern str p-start s-start (or next* p-end) this-s-end)
              (if (null next*)
                t                  
                (path-str-sub pattern str next* this-s-end p-end s-end)))))))))

; find match of pattern between start and end in str 
; rets one past end of pattern in str or nil
(defun find-str-pattern (pattern str p-start s-start p-end s-end)
  (declare (fixnum p-start s-start p-end s-end)
	   (type simple-base-string pattern str))
  (declare (optimize (speed 3)(safety 0)))
  (let* ((first-p (%scharcode pattern p-start))
         (esc (char-code *pathname-escape-character*)))
    (when (and (eq first-p esc) (not (eq (setq p-start (1+ p-start)) p-end)))
      (setq first-p (%scharcode pattern p-start)))
    (do* ((i s-start (1+ i))
          (last-i (%i- s-end (%i- p-end p-start))))
         ((> i last-i) nil)
      (declare (fixnum i last-i))
      (let ((s (%scharcode str i)))
        (when (eq first-p s)
          (do* ((j (1+ i) (1+ j))
                (k (1+ p-start)(1+ k)))
               ((>= k p-end) (return-from find-str-pattern j))
            (declare (fixnum j k))
            (let* ((p (%scharcode pattern k))
                   (s (%scharcode str j)))
              (when (and (eq p esc) (< (setq k (1+ k)) p-end))
                (setq p (%scharcode pattern k)))
              (when (not (eq p s))
                (return)))))))))


(defun path-str-match-p (pattern str p-start s-start p-end s-end)
  (declare (fixnum p-start s-start p-end s-end)
	   (type simple-base-string pattern str))
  (declare (optimize (speed 3)(safety 0)))
  ;; does pattern match str between p-start p-end
  (let ((esc (char-code *pathname-escape-character*)))
    (loop      
      (when (eq p-start p-end)
        (return (eq s-start s-end)))
      (when (eq s-start s-end)
	(return nil))
      (let ((p (%scharcode pattern p-start)))
        (unless *case-sensitive-filesystem*
          (setq p (%char-code-upcase p)))
        (when (eq p esc)
	  (when (eq (setq p-start (1+ p-start)) p-end)
	    (return nil))
          (setq p (%scharcode pattern p-start))
          (unless *case-sensitive-filesystem*
            (setq p (%char-code-upcase p))))
        (let* ((q (%scharcode str s-start)))
          (unless *case-sensitive-filesystem*
            (setq q (%char-code-upcase q)))
          (unless (eq p q)
            (return nil)))
	(setq p-start (1+ p-start))
	(setq s-start (1+ s-start))))))
      
             

(defun ccl-directory ()
  (let* ((dirpath (getenv "CCL_DEFAULT_DIRECTORY")))
    (if (and dirpath (not (zerop (length (namestring dirpath)))))
      (native-to-directory-pathname dirpath)
      (let* ((heap-image-path (%realpath (heap-image-name))))
	(make-pathname :directory (pathname-directory heap-image-path)
		       :device (pathname-device heap-image-path))))))

(defun user-homedir-pathname (&optional host)
  "Return the home directory of the user as a pathname."
  (declare (ignore host))
  (let* ((native (get-user-home-dir (getuid)))
	 (pathname (and native (native-to-directory-pathname native))))
    (if (and pathname (eq :absolute (car (pathname-directory pathname))))
      pathname
      (make-pathname :directory '(:absolute) :defaults nil))))
  




(defun translate-logical-pathname (pathname &key)
  "Translate PATHNAME to a physical pathname, which is returned."
  (setq pathname (pathname pathname))
  (let ((host (pathname-host pathname)))
    (cond ((eq host :unspecific) pathname)
	  ((null host) (%cons-pathname (pathname-directory pathname)
				       (pathname-name pathname)
				       (pathname-type pathname)
                                       (pathname-version pathname)
                                       (pathname-device pathname)))
	  (t
	   (let ((rule (assoc pathname (logical-pathname-translations host)
			      :test #'pathname-match-p)))  ; how can they match if hosts neq??
	     (if rule
	       (translate-logical-pathname
		(translate-pathname pathname (car rule) (cadr rule)))
	       (signal-file-error $xnotranslation pathname)))))))

(defloadvar *user-homedir-pathname* (user-homedir-pathname))


;;; Hide this from COMPILE-FILE, for obscure cross-compilation reasons

(defun setup-initial-translations ()
  (setf (logical-pathname-translations "home")
        `(("**;*.*" ,(merge-pathnames "**/*.*" (user-homedir-pathname)))))

  (setf (logical-pathname-translations "ccl")
        `(("l1;**;*.*" "ccl:level-1;**;*.*")
          ("l1f;**;*.*" "ccl:l1-fasls;**;*.*")
          ("ccl;*.*" ,(merge-pathnames "*.*" (ccl-directory)))
          ("**;*.*" ,(merge-pathnames "**/*.*" (ccl-directory))))))

(setup-initial-translations)


;;; Translate the pathname; if the directory component of the result
;;; is relative, make it absolute (relative to the current directory.)
(defun full-pathname (path &key (no-error t))
  (let* ((path (handler-case (translate-logical-pathname (merge-pathnames path))
                 (error (condition) (if no-error
                                      (return-from full-pathname nil)
                                      (error condition)))))
         (dir (%pathname-directory path))
	 (device #+windows-target
	         (or (pathname-device path)
		     (pathname-device (mac-default-directory)))
		 #-windows-target
		 nil))
    (cons-pathname (if (eq (car dir) :absolute)
		     dir
		     (absolute-directory-list dir))
		   (%pathname-name path)
		   (%pathname-type path)
		   (pathname-host path)
		   (pathname-version path)
		   device)))




(defparameter *module-search-path* (list
                                    (cons-pathname '(:absolute "bin") nil nil "ccl")
                                    (cons-pathname '(:absolute "openmcl" "modules") nil nil "home")
                                    (cons-pathname '(:absolute "lib") nil nil "ccl")
				    (cons-pathname '(:absolute "library") nil nil "ccl")
				    (cons-pathname '(:absolute "examples" :wild-inferiors) nil nil "ccl")
                                    (cons-pathname '(:absolute "contrib" :wild-inferiors) nil nil "ccl")
				    (cons-pathname '(:absolute "tools") nil nil "ccl")
                                    (cons-pathname '(:absolute "objc-bridge") nil nil "ccl")
                                    (cons-pathname '(:absolute "cocoa-ide") nil nil "ccl"))
  "Holds a list of pathnames to search for the file that has same name
   as a module somebody is looking for.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-pathnames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/arm-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2010 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")
(defparameter *arm-xtype-specifiers* (make-array 256 :initial-element nil))

(macrolet ((init-arm-xtype-table (&rest pairs)
             (let* ((table (gensym)))
               (collect ((body))
                 (dolist (pair pairs)
                   (destructuring-bind (code . spec) pair
                     (body `(setf (svref ,table ,code) ',spec))))
                 `(let* ((,table *arm-xtype-specifiers*))
                   ,@(body))))))
  (init-arm-xtype-table
   (arm::tag-fixnum . fixnum)
   (arm::tag-list . list)
   (arm::xtype-integer . integer)
   (arm::xtype-s64 . (signed-byte 64))
   (arm::xtype-u64 . (unsigned-byte 64))
   (arm::xtype-s32 . (signed-byte 32))
   (arm::xtype-u32 . (unsigned-byte 32))
   (arm::xtype-s16 . (signed-byte 16))
   (arm::xtype-u16 . (unsigned-byte 16))
   (arm::xtype-s8  . (signed-byte 8))
   (arm::xtype-u8  . (unsigned-byte 8))
   (arm::xtype-bit . bit)
   (arm::xtype-rational . rational)
   (arm::xtype-real . real)
   (arm::xtype-number . number)
   (arm::xtype-char-code . (mod #x110000))
   (arm::xtype-unsigned-byte-24 . (unsigned-byte 24))
   (arm::xtype-array2d . (array * (* *)))
   (arm::xtype-array3d . (array * (* * *)))
   (arm::subtag-bignum . bignum)
   (arm::subtag-ratio . ratio)
   (arm::subtag-single-float . single-float)
   (arm::subtag-double-float . double-float)
   (arm::subtag-complex . complex)
   (arm::subtag-macptr . macptr)
   (arm::subtag-code-vector . code-vector)
   (arm::subtag-xcode-vector . xcode-vector)
   (arm::subtag-catch-frame . catch-frame)
   (arm::subtag-function . function)
   (arm::subtag-basic-stream . basic-stream)
   (arm::subtag-symbol . symbol)
   (arm::subtag-lock . lock)
   (arm::subtag-hash-vector . hash-vector)
   (arm::subtag-pool . pool)
   (arm::subtag-weak . population)
   (arm::subtag-package . package)
   (arm::subtag-slot-vector . slot-vector)
   (arm::subtag-instance . standard-object)
   (arm::subtag-struct . structure-object)
   (arm::subtag-istruct . istruct)      ;??
   (arm::subtag-value-cell . value-cell)
   (arm::subtag-xfunction . xfunction)
   (arm::subtag-arrayH . array-header)
   (arm::subtag-vectorH . vector-header)
   (arm::subtag-simple-vector . simple-vector)
   (arm::subtag-single-float-vector . (simple-array single-float (*)))
   (arm::subtag-u32-vector . (simple-array (unsigned-byte 32) (*)))
   (arm::subtag-s32-vector . (simple-array (signed-byte 32) (*)))
   (arm::subtag-fixnum-vector . (simple-array fixnum (*)))
   (arm::subtag-simple-base-string . simple-base-string)
   (arm::subtag-u8-vector . (simple-array (unsigned-byte 8) (*)))
   (arm::subtag-s8-vector . (simple-array (signed-byte 8) (*)))   
   (arm::subtag-u16-vector . (simple-array (unsigned-byte 16) (*)))
   (arm::subtag-double-float-vector . (simple-array double-float (*)))
   (arm::subtag-bit-vector . simple-bit-vector)
   (arm::subtag-complex-single-float-vector . (simple-array (complex single-float) (*)))
   (arm::subtag-complex-double-float-vector . (simple-array (complex double-float) (*)))))
  

;;; Return a pointer to the saved VFP info a ucontext's mcontext,
;;; and the FPSCR values in that info as an unsigned 32-bit integer.
;;; Return a null pointer an 0 if this info can't be found.
(defun xp-vfp-info (xp)
  (let* ((p (pref xp :ucontext.uc_regspace)))
    (loop
      (let* ((magic (%get-unsigned-long p)))
        (case magic
          (#x56465001                    ;VFP magic
           (%incf-ptr p 8)
           (return (values p (%get-unsigned-long p (* 32 8)))))
          ((#x12ef842a #x5065cf03)      ;IWMMXT or CRUNCH magic
           (%incf-ptr p (%get-unsigned-long p 4)))
          (otherwise
           (return (values #-cross-compiling +null-ptr+ #+cross-compiling (%null-ptr)  0))))))))

(defun xp-argument-list (xp)
  (let ((nargs (xp-gpr-lisp xp arm::nargs))     ; tagged as a fixnum (how convenient)
        (arg-x (xp-gpr-lisp xp arm::arg_x))
        (arg-y (xp-gpr-lisp xp arm::arg_y))
        (arg-z (xp-gpr-lisp xp arm::arg_z)))
    (cond ((eql nargs 0) nil)
          ((eql nargs 1) (list arg-z))
          ((eql nargs 2) (list arg-y arg-z))
          (t (let ((args (list arg-x arg-y arg-z)))
               (if (eql nargs 3)
                 args
                 (let ((vsp (xp-gpr-macptr xp arm::vsp)))
                   (dotimes (i (- nargs 3))
                     (push (%get-object vsp (* i target::node-size)) args))
                   args)))))))

(defun handle-udf-call (xp frame-ptr)
  (let* ((args (xp-argument-list xp))
         (values (multiple-value-list
                  (%kernel-restart-internal
                   $xudfcall
                   (list (maybe-setf-name (xp-gpr-lisp xp arm::fname)) args)
                   frame-ptr)))
         (stack-argcnt (max 0 (- (length args) 3)))
         (vsp (%i+ (xp-gpr-lisp xp arm::vsp) stack-argcnt))
         (f #'(lambda (values) (apply #'values values))))
    (setf (xp-gpr-lisp xp arm::vsp) vsp
          (xp-gpr-lisp xp arm::nargs) 1
          (xp-gpr-lisp xp arm::arg_z) values
          (xp-gpr-lisp xp arm::nfn) f)
    ;; handle_uuo() (in the lisp kernel) will not bump the PC here.
    (setf (xp-gpr-lisp xp arm::pc) (uvref f 0))))

(defun preceding-fpu-instruction (xp)
  (let* ((f (xp-gpr-lisp xp arm::fn)))
    (when (typep f 'function)
      (let* ((idx
              (loop (let* ((pc (xp-gpr-lisp xp arm::pc))
                           (entry (%svref f 0))
                           (d (- pc entry)))
                      (when (and (eql pc (xp-gpr-lisp xp arm::pc))
                                 (eql entry (%svref f 0)))
                        (return d)))))
             (cv (%svref f 1)))
        (declare (fixnum idx))
        (do* ((i (1- idx) (1- i)))
             ((< i 0))
          (declare (fixnum i))
          (let* ((inst (uvref cv i))
                 (masked (logand inst #x0f000f00)))
            (when (and (or (eql masked #x0e000b00)
                           (eql masked #x0e000a00))
                       ;; Ignore fmxr, fmrx ...
                       (not (eql #x10 (logand inst #xff))))
              (return inst))))))))
             
  
(defcallback %xerr-disp (:address xp
                                  :signed-fullword error-number
                                  :unsigned-fullword arg
                                  :unsigned-fullword fnreg
                                  :unsigned-fullword relative-pc
                                  :int)
  (let* ((fn (unless (eql 0 fnreg) (xp-gpr-lisp xp fnreg)))
         (delta 0))
    (with-xp-stack-frames (xp fn frame-ptr)
      (with-error-reentry-detection
          (cond
            ((eql 0 error-number)       ; Hopefully a UUO.
             (setq delta 4)
             (if (/= (logand arg #x0ff000f0) #x07f000f0)
               (%error "Unknown non-UUO: #x~x" (list arg) frame-ptr)
               (let* ((condition (ldb (byte 4 28) arg))
                      (uuo (ldb (byte 28 0) arg))
                      (format (ldb (byte 4 0) uuo)))
                 (case format
                   ((2 10)              ; uuo-format-[c]error-lisptag
                    (%error (make-condition
                             'type-error
                             :datum (xp-gpr-lisp xp (ldb (byte 4 8) uuo))
                             :expected-type
                             (svref #(fixnum list uvector immediate)
                                    (ldb (byte 2 12) uuo)))
                            nil
                            frame-ptr))
                   ((3 11)
                    (%error (make-condition
                             'type-error
                             :datum (xp-gpr-lisp xp (ldb (byte 4 8) uuo))
                             :expected-type
                             (svref #(fixnum null bogus immediate fixnum cons uvector bogus)
                                    (ldb (byte 3 12) uuo)))
                            nil
                            frame-ptr))
                   ((4 12)
                    (%error (make-condition
                             'type-error
                             :datum (xp-gpr-lisp xp (ldb (byte 4 8) uuo))
                             :expected-type
                             (svref *arm-xtype-specifiers* (ldb (byte 8 12) uuo)))
                            nil
                            frame-ptr))
                   (8                   ;nullary error.  Only one, atm.
                    (case (ldb (byte 12 8) uuo)
                      (1                ;why 1?
                       (let* ((condition-name
                               (cond ((eq condition arm::arm-cond-lo)
                                      'too-few-arguments)
                                     ((eq condition arm::arm-cond-hs)
                                      'too-many-arguments)
                                     (t
                                      ;;(assert condition arm::arm-cond-ne)
                                      (let* ((cpsr (xp-gpr-signed-long xp
                                                                       xp-cpsr-regno)))
                                        (if (logbitp 29 cpsr)
                                          'too-many-arguments
                                          'too-few-arguments))))))
                         (%error condition-name
                                 (list :nargs (xp-gpr-lisp xp arm::nargs)
                                       :fn fn)
                                 frame-ptr)))
                      (t
                       (%error "Unknown nullary UUO code ~d"
                               (list (ldb (byte 12 8) uuo))
                               frame-ptr))))
                   (9                   ;unary error
                    (let* ((code (ldb (byte 8 12) uuo))
                           (regno (ldb (byte 4 8) uuo))
                           (arg (xp-gpr-lisp xp regno)))
                      (case code
                        ((0 1)
                         (setf (xp-gpr-lisp xp regno)
                               (%kernel-restart-internal $xvunbnd
                                                         (list arg)
                                                         frame-ptr)))
                        (2
                         (%error (make-condition 'type-error
                                                 :datum arg
                                                 :expected-type '(or symbol function)
                                                 :format-control
                                                 "~S is not of type ~S, and can't be FUNCALLed or APPLYed")
                                 nil frame-ptr))
                        (4
                         (%error (make-condition 'cant-throw-error
                                                 :tag arg)
                                 nil frame-ptr))
                        (5
                         (setq delta 0)
                         (handle-udf-call xp frame-ptr))
                        (6
                         (%err-disp-internal $xfunbnd (list arg) frame-ptr))
                        (t
                         (error "Unknown unary UUO with code ~d." code)))))
                   (14
                    (let* ((reg-a (ldb (byte 4 8) uuo))
                           (arg-b (xp-gpr-lisp xp (ldb (byte 4 12) uuo)))
                           (arg-c (xp-gpr-lisp xp (ldb (byte 4 16) uuo))))
                      (setq *error-reentry-count* 0)
                      (setf (xp-gpr-lisp xp reg-a)
                            (%slot-unbound-trap arg-b arg-c frame-ptr))))
                   (15
                    (let* ((reg-a (ldb (byte 4 8) uuo))
                           (arga (xp-gpr-lisp xp reg-a))
                           (argb (xp-gpr-lisp xp (ldb (byte 4 12) uuo)))
                           (code (ldb (byte 4 16) uuo)))
                      (case code
                        ((0 1)          ;do we report these the same way?
                         (%error (%rsc-string $xarroob)
                                 (list arga argb)
                                 frame-ptr))
                        (4
                         (let* ((eep-or-fv (xp-gpr-lisp xp (ldb (byte 4 12) uuo)))
                                (dest-reg (ldb (byte 4 8) uuo)))
                           (etypecase eep-or-fv
                             (external-entry-point
                              (resolve-eep eep-or-fv)
                              (setf (xp-gpr-lisp xp dest-reg)
                                    (eep.address eep-or-fv)))
                             (foreign-variable
                              (resolve-foreign-variable eep-or-fv)
                              (setf (xp-gpr-lisp xp dest-reg)
                                    (fv.addr eep-or-fv))))))
                        (5              ;fpu
                         (let* ((vfp-regs (xp-vfp-info xp))
                                (status (xp-gpr-unsigned-long xp (ldb (byte 4 8) uuo)))
                                (instruction (preceding-fpu-instruction xp))
                                (condition-name (fp-condition-name-from-fpscr-status status)))
                           (if (and condition-name instruction)
                             (let* ((template (find-arm-instruction-template instruction))
                                    (operation (if template (arithmetic-error-operation-from-instruction template) 'unknown))
                                    (operands (if template (arithmetic-error-operands-from-instruction template instruction vfp-regs xp))))
                               (%error condition-name `(:operation ,operation :operands ,operands) frame-ptr))
                             (%error "FPU exception, fpscr = ~d" (list status) frame-ptr))
                         ))
                        (6              ;array rank
                         (%err-disp-internal $XNDIMS
                                             (list
                                              argb
                                              arga)
                                             frame-ptr))
                        (7              ;array flags
                         ;; This is currently only used to signal that
                         ;; a (purported) array header doesn't have the
                         ;; flags which denote a simple-array with
                         ;; a particular subtype.  Decode things, then
                         ;; signal a TYPE-ERROR.
                         (let* ((array (xp-gpr-lisp xp (ldb (byte 4 12) uuo)))
                                (flags (xp-gpr-lisp xp (ldb (byte 4 8) uuo)))
                                (subtag (ldb target::arrayH.flags-cell-subtag-byte flags))
                                (element-type
                                 (type-specifier
                                  (array-ctype-element-type
                                   (specifier-type (svref *arm-xtype-specifiers* subtag))))))

                           (%error (make-condition
                                    'type-error
                                    :datum array
                                    :expected-type `(,(if (logbitp $arh_simple_bit flags) 'simple-array 'array) ,element-type))
                                   nil
                                   frame-ptr)))                        
                        (t
                         (error "Unknown code in binary UUO: ~d" code)))))
                   (5
                    (%error "Index value ~s is out of bounds for axis ~s of ~s."
                            (list
                             (xp-gpr-lisp xp (ldb (byte 4 16) uuo))
                             (xp-gpr-lisp xp (ldb (byte 4 12) uuo))
                             (xp-gpr-lisp xp (ldb (byte 4 8) uuo)))
                            frame-ptr))
                   (t
                    (error "Unknown UUO, format ~d" format))))))
            ((eql error-number arch::error-stack-overflow)
             (%error
              (make-condition
               'stack-overflow-condition 
               :format-control "Stack overflow on ~a stack."
               :format-arguments (list (if (eql arg arm::vsp) "value" "control")))
              nil frame-ptr))
            ((eql error-number arch::error-allocation-disabled)
             (restart-case (%error 'allocation-disabled nil frame-ptr)
               (continue ()
                         :report (lambda (stream)
                                   (format stream "retry the heap allocation.")))))
            (t
             (error "%errdisp callback: error-number = ~d, arg = #x~x, fnreg = ~d, rpc = ~d"
                    error-number arg fnreg relative-pc)))))
    delta))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/arm-error-signal.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-symhash.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(declaim (special %all-packages%))
(declaim (list %all-packages%))
(declaim (type package *package*))



(defun dereference-base-string-or-symbol (s)
  (if (symbolp s)
    (dereference-base-string (symbol-name s))
    (dereference-base-string s)))

(defun dereference-base-string-or-symbol-or-char (s)
  (if (typep s 'character)
    (values (make-string 1 :element-type 'base-char :initial-element s) 0 1)
    (dereference-base-string-or-symbol s)))


(defun %string= (string1 string2 start1 end1)
  (declare (optimize (speed 3) (safety 0))
           (fixnum start1 end1))
  (when (eq (length string2) (%i- end1 start1))
    (do* ((i start1 (1+ i))
          (j 0 (1+ j)))
         ((>= i end1))
      (declare (fixnum i j))
      (when (not (eq (%scharcode string1 i)(%scharcode string2 j)))
        (return-from %string= nil)))
    t))




(defun export (sym-or-syms &optional (package *package*))
  "Exports SYMBOLS from PACKAGE, checking that no name conflicts result."
  (setq package (pkg-arg package))
  (if (atom sym-or-syms)
    (let* ((temp (cons sym-or-syms nil)))
      (declare (dynamic-extent temp))
      (export temp package))
    (progn
      (dolist (sym sym-or-syms)
        (unless (symbolp sym) (return (setq sym-or-syms  (mapcar #'(lambda (s) (require-type s 'symbol)) sym-or-syms)))))
      ;; First, see if any packages used by the package being
      ;; "exported from" already contain a distinct non-shadowing
      ;; symbol that conflicts with one of those that we're trying to
      ;; export.
      (let* ((conflicts (check-export-conflicts sym-or-syms package)))
        (if conflicts
          (progn 
            (resolve-export-conflicts conflicts package)
            (export sym-or-syms package))
          (let* ((missing nil) (need-import nil))
            (dolist (s sym-or-syms) 
              (multiple-value-bind (foundsym foundp) (%findsym (symbol-name s) package)
                (if (not (and foundp (eq s foundsym)))
                  (push s missing)
                  (if (eq foundp :inherited)
                    (push s need-import)))))
            (when missing
              (cerror "Import missing symbols before exporting them from ~S."
                      'export-requires-import
                      :package  package
                      :to-be-imported missing)
              (import missing package))
            (if need-import (import need-import package))
            ; Can't lose now: symbols are all directly present in package.
            ; Ensure that they're all external; do so with interrupts disabled
            (without-interrupts
             (let* ((etab (pkg.etab package))
                    (ivec (car (pkg.itab package))))
               (dolist (s sym-or-syms t)
                 (multiple-value-bind (foundsym foundp internal-offset)
                                      (%findsym (symbol-name s) package)
                   (when (eq foundp :internal)
                     (setf (%svref ivec internal-offset) (package-deleted-marker))
                     (let* ((pname (symbol-name foundsym)))
                       (%htab-add-symbol foundsym etab (nth-value 2 (%get-htab-symbol pname (length pname) etab)))))))))))))))

(defun check-export-conflicts (symbols package)
  (let* ((conflicts nil))
    (with-package-lock (package)
      (dolist (user (pkg.used-by package) conflicts)
        (with-package-lock (user)
          (dolist (s symbols)
            (multiple-value-bind (foundsym foundp) (%findsym (symbol-name s) user)
              (if (and foundp (neq foundsym s) (not (memq foundsym (pkg.shadowed user))))
                (push (list (eq foundp :inherited) s user foundsym) conflicts)))))))))
  


(defun keywordp (x)
  "Return true if Object is a symbol in the \"KEYWORD\" package."
  (and (symbolp x) (eq (symbol-package x) *keyword-package*)))

;;;No type/range checking.  For DO-SYMBOLS and friends.
(defun %htab-symbol (array index)
  (let* ((sym (%svref array index)))
    (if (symbolp sym)
      (values (%symptr->symbol sym) t)
      (values nil nil))))

(defun find-all-symbols (name)
  "Return a list of all symbols in the system having the specified name."
  (let* ((syms ())
         (pname (ensure-simple-string (string name)))
         (len (length pname)))
    (with-package-list-read-lock
        (dolist (p %all-packages% syms)
          (with-package-lock (p)
            (multiple-value-bind (sym foundp) (%find-package-symbol pname p len)
              (if foundp (pushnew sym syms :test #'eq))))))))
      

(defun list-all-packages ()
  "Return a list of all existing packages."
  (with-package-list-read-lock (copy-list %all-packages%)))

(defun rename-package (package new-name &optional new-nicknames)
  "Changes the name and nicknames for a package."
  (setq package (pkg-arg package)
        new-name (ensure-simple-string (string new-name)))
  (with-package-lock (package)
    (let* ((names (pkg.names package)))
      (declare (type cons names))
      (dolist (n names)
        (let* ((ref (register-package-ref n)))
          (setf (package-ref.pkg ref) nil)))
      (rplaca names (new-package-name new-name package))
      (let* ((ref (register-package-ref (car names))))
        (setf (package-ref.pkg ref) package))
      (rplacd names nil))
    (%add-nicknames new-nicknames package)))

;;; Someday, this should become LISP:IN-PACKAGE.
(defun old-in-package (name &key 
                        nicknames 
                        (use nil use-p) 
                        (internal-size 60)
                        (external-size 10))
  (let ((pkg (find-package (setq name (string name)))))
    (if pkg
      (progn
        (use-package use pkg)
        (%add-nicknames nicknames pkg))
      (setq pkg
            (make-package name 
                          :nicknames nicknames
                          :use (if use-p use *make-package-use-defaults*)
                          :internal-size internal-size
                          :external-size external-size)))
    (setq *package* pkg)))


(defvar *make-package-use-defaults* '("COMMON-LISP" "CCL"))

;;; On principle, this should get exported here.  Unfortunately, we
;;; can't execute calls to export quite yet.


(defun make-package (name &key
                          nicknames
                          (use *make-package-use-defaults*)
                          (internal-size 60)
                          (external-size 10))
  "Make a new package having the specified NAME, NICKNAMES, and USE
list.  INTERNAL-SIZE and EXTERNAL-SIZE are estimates for the number of
internal and external symbols which will ultimately be present in the
package.  In this implementation, the default for the USE list is the
value of the variable CCL:*MAKE-PACKAGE-USE-DEFAULTS*."
  (setq internal-size (require-type internal-size 'fixnum)
        external-size (require-type external-size 'fixnum))
  (let* ((pkg-name (new-package-name name))
         (pkg (gvector :package 
                       (%new-package-hashtable internal-size)
                       (%new-package-hashtable external-size)
                       nil
                       nil
                       (list pkg-name)
                       nil
                       (make-read-write-lock)
                       nil)))
    (let* ((ref (register-package-ref pkg-name)))
      (setf (package-ref.pkg ref) pkg))
    (use-package use pkg)
    (%add-nicknames nicknames pkg)
    (with-package-list-write-lock
        (push pkg %all-packages%))
    pkg))

(defun new-package-name (name &optional package)
  (do* ((prompt "Enter package name to use instead of ~S ."))
       ((let* ((found (find-package (setq name (ensure-simple-string (string name))))))
          (or (not found)
              (eq package found)))
        name)
    (restart-case (%error "Package name ~S is already in use." (list name) (%get-frame-ptr))
      (new-name (new-name)
                :report (lambda (s) (format s prompt name))
                :interactive 
                (lambda () 
                  (list (block nil (catch-cancel (return (get-string-from-user
                                                          (format nil prompt name))))
                               nil)))
                (if new-name (setq name new-name))))))
       
(defun new-package-nickname (name package)
  (setq name (string name))
  (let* ((other (find-package name))
         (prompt "Enter package name to use instead of ~S ."))
    (if other
      (unless (eq other package)
        (let* ((conflict-with-proper-name (string= (package-name other) name))
               (condition (make-condition 'package-name-conflict-error
                                          :package package
                                          :format-arguments (list name other)
                                          :format-control (%str-cat "~S is already "
                                                                   (if conflict-with-proper-name
                                                                     "the "
                                                                     "a nick")
                                                                   "name of ~S."))))
          (restart-case (%error condition nil (%get-frame-ptr))
            (continue ()
                      :report (lambda (s) (format s "Don't make ~S a nickname for ~S" name package)))
            (new-name (new-name)
                      :report (lambda (s) (format s prompt name))
                      :interactive 
                      (lambda () 
                        (list (block nil (catch-cancel (return (get-string-from-user
                                                                (format nil prompt name))))
                                     nil)))
                      (if new-name (new-package-nickname new-name package)))
            (remove-conflicting-nickname ()
                                         :report (lambda (s)
                                                   (format s "Remove conflicting-nickname ~S from ~S." name other))
                                         :test (lambda (&rest ignore) (declare (ignore ignore)) (not conflict-with-proper-name))
                                         (rplacd (pkg.names other)
                                                 (delete name (cdr (pkg.names other)) :test #'string=))
                                         name))))
      name)))

(defun %add-nicknames (nicknames package)
  (let ((names (pkg.names package)))
    (dolist (name nicknames package)
      (let* ((ok-name (new-package-nickname name package)))
        (when ok-name
          (let* ((ref (register-package-ref ok-name)))
            (setf (package-ref.pkg ref) package)
            (push ok-name (cdr names))))))))

(defun find-symbol (string &optional package)
  "Return the symbol named STRING in PACKAGE. If such a symbol is found
  then the second value is :INTERNAL, :EXTERNAL or :INHERITED to indicate
  how the symbol is accessible. If no symbol is found then both values
  are NIL."
  (multiple-value-bind (sym flag)
      (%findsym (ensure-simple-string string) (pkg-arg (or package *package*)))
    (values sym flag)))

(defun %pkg-ref-find-symbol (string ref)
  (multiple-value-bind (sym flag)
      (%findsym (ensure-simple-string string)
                (or (package-ref.pkg ref)
                    (%kernel-restart $xnopkg (package-ref.name ref))))
    (values sym flag)))
    
;;; Somewhat saner interface to %find-symbol
(defun %findsym (string package)
  (%find-symbol string (length string) package))

(eval-when (:compile-toplevel)
  (declaim (inline %intern)))

(defun %intern (str package)
  (setq str (ensure-simple-string str))
  (with-package-lock (package)
   (multiple-value-bind (symbol where internal-offset external-offset) 
                        (%find-symbol str (length str) package)
     (if where
       (values symbol where)
       (values (%add-symbol str package internal-offset external-offset) nil)))))


(defun intern (str &optional (package *package*))
  "Return a symbol in PACKAGE having the specified NAME, creating it
  if necessary."
  (%intern str (pkg-arg package)))

(defun %pkg-ref-intern (str ref)
  (%intern str (or (package-ref.pkg ref)
                   (%kernel-restart $xnopkg (package-ref.name ref)))))

(defun unintern (symbol &optional (package *package*))
  "Makes SYMBOL no longer present in PACKAGE. If SYMBOL was present
  then T is returned, otherwise NIL. If PACKAGE is SYMBOL's home
  package, then it is made uninterned."
  (setq package (pkg-arg package))
  (setq symbol (require-type symbol 'symbol))
  (multiple-value-bind (foundsym table index) (%find-package-symbol (symbol-name symbol) package)
    (when (and table (eq symbol foundsym))
      (when (memq symbol (pkg.shadowed package))
        ;; A conflict is possible if more than one distinct
        ;; similarly-named external symbols exist in the packages used
        ;; by this one.  Grovel around looking for such conflicts; if
        ;; any are found, signal an error (via %kernel-restart) which
        ;; offers to either shadowing-import one of the conflicting
        ;; symbols into the current package or abandon the attempt to
        ;; unintern in the first place.
        (let* ((first nil)
               (first-p nil)
               (name (symbol-name symbol))
               (len (length name))
               (others nil))
          (declare (dynamic-extent first))
          (with-package-lock (package)
            (dolist (pkg (pkg.used package))
              (with-package-lock (pkg)
                (multiple-value-bind (found conflicting-sym) (%get-htab-symbol name len (pkg.etab pkg))
                  (when found
                    (if first-p
                      (unless (or (eq conflicting-sym first)
                                  (memq conflicting-sym others))
                        (push conflicting-sym others))
                      (setq first-p t first conflicting-sym)))))))
          (when others
            ;;If this returns, it will have somehow fixed things.
            (return-from unintern (%kernel-restart $xunintc symbol package (cons first others)))))
        ;; No conflicts found, but symbol was on shadowing-symbols list.  Remove it atomically.
        (do* ((head (cons nil (pkg.shadowed package)))
              (prev head next)
              (next (cdr prev) (cdr next)))
             ((null next))              ; Should never happen
          (declare (dynamic-extent head) 
                   (list head prev next)
                   (optimize (speed 3) (safety 0)))
          (when (eq (car next) symbol)
            (setf (cdr prev) (cdr next)
                  (pkg.shadowed package) (cdr head))
            (return))))
      ;; Now remove the symbol from package; if package was its home
      ;; package, set its package to NIL.  If we get here, the "table"
      ;; and "index" values returned above are still valid.
      (%svset (car table) index (package-deleted-marker))
      (when (eq (symbol-package symbol) package)
        (%set-symbol-package symbol nil))
      t)))

(defun import-1 (package sym)
  (multiple-value-bind (conflicting-sym type internal-offset external-offset) (%findsym (symbol-name sym) package)
    (if (and type (neq conflicting-sym sym))
      (let* ((external-p (eq type :inherited))
             (condition (make-condition 'import-conflict-error 
                                        :package package
                                        :imported-sym sym
                                        :conflicting-sym conflicting-sym
                                        :conflict-external external-p)))
        (restart-case (error condition)
          (continue ()
                    :report (lambda (s) (format s "Ignore attempt to import ~S to ~S." sym package)))
          (resolve-conflict ()
                            :report (lambda (s)
                                      (let* ((package-name (package-name package)))
                                        (if external-p 
                                          (format s "~A ~s in package ~s ." 'shadowing-import sym package-name)
                                          (format s "~A ~s from package ~s ." 'unintern conflicting-sym package-name))))
                            (if external-p 
                              (shadowing-import-1 package sym)
                              (progn
                                (unintern conflicting-sym package)
                                (import-1 package sym))))))
      (unless (or (eq type :external) (eq type :internal))
        (%insert-symbol sym package internal-offset external-offset)))))


(defun import (sym-or-syms &optional package)
  "Make SYMBOLS accessible as internal symbols in PACKAGE. If a symbol
  is already accessible then it has no effect. If a name conflict
  would result from the importation, then a correctable error is signalled."
  (setq package (pkg-arg (or package *package*)))
  (if (listp sym-or-syms)
    (dolist (sym sym-or-syms)
      (import-1 package sym))
    (import-1 package sym-or-syms))
  t)

(defun shadow-1 (package sym)
  (let* ((pname (ensure-simple-string (string sym)))
         (len (length pname)))
    (without-interrupts
     (multiple-value-bind (symbol where internal-idx external-idx) (%find-symbol pname len package)
       (if (or (eq where :internal) (eq where :external))
         (pushnew symbol (pkg.shadowed package))
         (push (%add-symbol pname package internal-idx external-idx) (pkg.shadowed package)))))
    nil))

(defun shadow (sym-or-symbols-or-string-or-strings &optional package)
  "Make an internal symbol in PACKAGE with the same name as each of
  the specified SYMBOLS. If a symbol with the given name is already
  present in PACKAGE, then the existing symbol is placed in the
  shadowing symbols list if it is not already present."
  (setq package (pkg-arg (or package *package*)))
  (if (listp sym-or-symbols-or-string-or-strings)
    (dolist (s sym-or-symbols-or-string-or-strings)
      (shadow-1 package s))
    (shadow-1 package sym-or-symbols-or-string-or-strings))
  t)

(defun unexport (sym-or-symbols &optional package)
  "Makes SYMBOLS no longer exported from PACKAGE."
  (setq package (pkg-arg (or package *package*)))
  (if (listp sym-or-symbols)
    (dolist (sym sym-or-symbols)
      (unexport-1 package sym))
    (unexport-1 package sym-or-symbols))
  t)

(defun unexport-1 (package sym)
  (when (eq package *keyword-package*)
    (error "Can't unexport ~S from ~S ." sym package))
  (multiple-value-bind (foundsym foundp internal-offset external-offset)
                       (%findsym (symbol-name sym) package)
    (unless foundp
      (error 'symbol-name-not-accessible
             :symbol-name (symbol-name sym)
             :package package))
    (when (eq foundp :external)
      (let* ((evec (car (pkg.etab package)))
             (itab (pkg.itab package))
             (ivec (car itab))
             (icount&limit (cdr itab)))
        (declare (type cons itab icount&limit))
        (setf (svref evec external-offset) (package-deleted-marker))
        (setf (svref ivec internal-offset) (%symbol->symptr foundsym))
        (if (eql (setf (car icount&limit)
                       (the fixnum (1+ (the fixnum (car icount&limit)))))
                 (the fixnum (cdr icount&limit)))
          (%resize-htab itab)))))
  nil)

;;; Both args must be packages.
(defun %use-package-conflict-check (using-package package-to-use)
  (let ((already-used (pkg.used using-package)))
    (unless (or (eq using-package package-to-use)
                (memq package-to-use already-used))
      ;; There are two types of conflict that can potentially occur:
      ;;   1) An external symbol in the package being used conflicts
      ;;        with a symbol present in the using package
      ;;   2) An external symbol in the package being used conflicts
      ;;        with an external symbol in some other package that's
      ;;        already used.
      (let* ((ext-ext-conflicts nil)
             (used-using-conflicts nil)
             (shadowed-in-using (pkg.shadowed using-package))
             (to-use-etab (pkg.etab package-to-use)))
        (without-interrupts
         (dolist (already already-used)
           (let ((user (if (memq package-to-use (pkg.used-by already))
                         package-to-use
                         (if (memq package-to-use (pkg.used already))
                           already))))
             (if user
               (let* ((used (if (eq user package-to-use) already package-to-use))
                      (user-etab (pkg.etab user))
                      (used-etab (pkg.etab used)))
                 (dolist (shadow (pkg.shadowed user))
                   (let ((sname (symbol-name shadow)))
                     (unless (member sname shadowed-in-using :test #'string=)
                       (let ((len (length sname)))
                         (when (%get-htab-symbol sname len user-etab)   ; external in user
                           (multiple-value-bind (external-in-used used-sym) (%get-htab-symbol sname len used-etab)
                             (when (and external-in-used (neq used-sym shadow))
                               (push (list shadow used-sym) ext-ext-conflicts)))))))))
               ;; Remember what we're doing here ?
               ;; Neither of the two packages use the other.  Iterate
               ;; over the external symbols in the package that has
               ;; the fewest external symbols and note conflicts with
               ;; external symbols in the other package.
               (let* ((smaller (if (%i< (%cadr to-use-etab) (%cadr (pkg.etab already)))
                                 package-to-use
                                 already))
                      (larger (if (eq smaller package-to-use) already package-to-use))
                      (larger-etab (pkg.etab larger))
                      (smaller-v (%car (pkg.etab smaller))))
                 (dotimes (i (uvsize smaller-v))
                   (declare (fixnum i))
                   (let ((symptr (%svref smaller-v i)))
                     (when (symbolp symptr)
                       (let* ((sym (%symptr->symbol symptr))
                              (symname (symbol-name sym)))
                         (unless (member symname shadowed-in-using :test #'string=)
                           (multiple-value-bind (found-in-larger sym-in-larger)
                                                (%get-htab-symbol symname (length symname) larger-etab)
                             (when (and found-in-larger (neq sym-in-larger sym))
                               (push (list sym sym-in-larger) ext-ext-conflicts))))))))))))
         ;; Now see if any non-shadowed, directly present symbols in
         ;; the using package conflicts with an external symbol in the
         ;; package being used.  There are two ways of doing this; one
         ;; of them -may- be much faster than the other.
         (let* ((to-use-etab-size (%cadr to-use-etab))
                (present-symbols-size (%i+ (%cadr (pkg.itab using-package)) (%cadr (pkg.etab using-package)))))
           (unless (eql 0 present-symbols-size)
             (if (%i< present-symbols-size to-use-etab-size)
               ;; Faster to look up each present symbol in to-use-etab.
               (let ((htabvs (list (%car (pkg.etab using-package)) (%car (pkg.itab using-package)))))
                 (declare (dynamic-extent htabvs))
                 (dolist (v htabvs)
                   (dotimes (i (the fixnum (uvsize v)))
                     (declare (fixnum i))
                     (let ((symptr (%svref v i)))
                       (when (symbolp symptr)
                         (let* ((sym (%symptr->symbol symptr)))
                           (unless (memq sym shadowed-in-using)
                             (let* ((name (symbol-name symptr)))
                               (multiple-value-bind (found-p to-use-sym) (%get-htab-symbol name (length name) to-use-etab)
                                 (when (and found-p (neq to-use-sym sym))
                                   (push (list sym to-use-sym) used-using-conflicts)))))))))))
               ;; See if any external symbol present in the package
               ;; being used conflicts with any symbol present in the
               ;; using package.
               (let ((v (%car to-use-etab)))
                 (dotimes (i (uvsize v))
                   (declare (fixnum i))
                   (let ((symptr (%svref v i)))
                     (when (symbolp symptr)
                       (let* ((sym (%symptr->symbol symptr)))
                         (multiple-value-bind (using-sym found-p) (%find-package-symbol (symbol-name sym) using-package)
                           (when (and found-p
                                      (neq sym using-sym)
                                      (not (memq using-sym shadowed-in-using)))
                             (push (list using-sym sym) used-using-conflicts))))))))))))
        (values ext-ext-conflicts used-using-conflicts)))))

(defun use-package-1 (using-package package-to-use)
  (if (eq (setq package-to-use (pkg-arg package-to-use))
          *keyword-package*)
    (error "~S can't use ~S." using-package package-to-use))
  (do* ((used-external-conflicts nil)
        (used-using-conflicts nil))
       ((and (null (multiple-value-setq (used-external-conflicts used-using-conflicts)
                     (%use-package-conflict-check using-package package-to-use)))
             (null used-using-conflicts)))
    (if used-external-conflicts
      (%kernel-restart $xusecX package-to-use using-package used-external-conflicts)
      (if used-using-conflicts
        (%kernel-restart $xusec package-to-use using-package used-using-conflicts))))
  (unless (memq using-package (pkg.used-by package-to-use))   ;  Not already used in break loop/restart, etc.
    (push using-package (pkg.used-by package-to-use))
    (push package-to-use (pkg.used using-package))))

(defun use-package (packages-to-use &optional package)
  "Add all the PACKAGES-TO-USE to the use list for PACKAGE so that
  the external symbols of the used packages are accessible as internal
  symbols in PACKAGE."
  (setq package (pkg-arg (or package *package*)))
  (if (listp packages-to-use)
    (dolist (to-use packages-to-use)
      (use-package-1 package to-use))
    (use-package-1 package packages-to-use))
  t)

(defun shadowing-import-1 (package sym)
  (let* ((pname (symbol-name sym))
         (len (length pname))
         (need-add t))
    (without-interrupts
     (multiple-value-bind (othersym htab offset) (%find-package-symbol pname package)
       (if htab
         (if (eq othersym sym)
           (setq need-add nil)
           (progn                       ; Delete conflicting symbol
             (if (eq (symbol-package othersym) package)
               (%set-symbol-package othersym nil))
             (setf (%svref (car htab) offset) (package-deleted-marker))
             (setf (pkg.shadowed package) (delete othersym (pkg.shadowed package) :test #'eq)))))
       (if need-add                   ; No symbols with same pname; intern & shadow
         (multiple-value-bind (xsym foundp internal-offset external-offset) 
                              (%find-symbol pname len package)
           (declare (ignore xsym foundp))
           (%insert-symbol sym package internal-offset external-offset)))
       (pushnew sym (pkg.shadowed package))
       nil))))

(defun shadowing-import (sym-or-syms &optional (package *package*))
  "Import SYMBOLS into package, disregarding any name conflict. If
  a symbol of the same name is present, then it is uninterned."
  (setq package (pkg-arg package))
  (if (listp sym-or-syms)
    (dolist (sym sym-or-syms)
      (shadowing-import-1 package sym))
    (shadowing-import-1 package sym-or-syms))
  t)

(defun unuse-package (packages-to-unuse &optional package)
  "Remove PACKAGES-TO-UNUSE from the USE list for PACKAGE."
  (let ((p (pkg-arg (or package *package*))))
    (flet ((unuse-one-package (unuse)
            (setq unuse (pkg-arg unuse))
            (setf (pkg.used p) (nremove unuse (pkg.used p))
                  (pkg.used-by unuse) (nremove p (pkg.used-by unuse)))))
      (declare (dynamic-extent #'unuse-one-package))
      (if (listp packages-to-unuse)
        (dolist (u packages-to-unuse) (unuse-one-package u))
        (unuse-one-package packages-to-unuse))
      t)))

(defun delete-package (package)
  "Delete the package designated by PACKAGE-DESIGNATOR from the package
  system data structures."
  (unless (packagep package)
    (setq package (or (find-package package)
                      (progn
                        (cerror "Do nothing" 'no-such-package :package package)
                        (return-from delete-package nil)))))
  (with-package-list-read-lock
    (unless (memq package %all-packages%)
      (return-from delete-package nil)))
  (when (pkg.used-by package)
    (cerror "unuse ~S" 'package-is-used-by :package package
            :using-packages (pkg.used-by package)))
  (while (pkg.used-by package)
    (unuse-package package (car (pkg.used-by package))))
  (while (pkg.used package)
    (unuse-package (car (pkg.used package)) package))
  (setf (pkg.shadowed package) nil)
  (with-package-list-write-lock
    (setq %all-packages% (nremove package %all-packages%)))
  (dolist (n (pkg.names package))
    (let* ((ref (register-package-ref n)))
      (setf (package-ref.pkg ref) nil)))
  (setf (pkg.names package) nil)
  (let* ((ivec (car (pkg.itab package)))
         (evec (car (pkg.etab package)))
         (deleted (package-deleted-marker)))
    (dotimes (i (the fixnum (length ivec)))
      (let* ((sym (%svref ivec i)))
        (setf (%svref ivec i) deleted)          ; in case it's in STATIC space
        (when (symbolp sym)
          (if (eq (symbol-package sym) package)
            (%set-symbol-package sym nil)))))
    (dotimes (i (the fixnum (length evec)))
      (let* ((sym (%svref evec i)))
        (setf (%svref evec i) deleted)          ; in case it's in STATIC space
        (when (symbolp sym)
          (if (eq (symbol-package sym) package)
            (%set-symbol-package sym nil))))))
  (let ((itab (pkg.itab package)) (etab (pkg.etab package)) (v '#(nil nil nil)))
    (%rplaca itab v) (%rplaca etab v)
    (%rplaca (%cdr itab) 0) (%rplaca (%cdr etab) 0)
    (%rplacd (%cdr itab) #x4000) (%rplacd (%cdr etab) #x4000))
  t)

(defun %find-package-symbol (string package &optional (len (length string)))
  (let* ((etab (pkg.etab package))
         (itab (pkg.itab package)))
    (multiple-value-bind (foundp sym offset) (%get-htab-symbol string len itab)
      (if foundp
        (values sym itab offset)
        (progn
          (multiple-value-setq (foundp sym offset)
          (%get-htab-symbol string len etab))
          (if foundp
            (values sym etab offset)
            (values nil nil nil)))))))

;;;For the inspector, number of symbols in pkg.
(defun %pkgtab-count (pkgtab)
  (let* ((n 0))
    (declare (fixnum n))
    (dovector (x (pkgtab-table pkgtab) n)
       (when (symbolp x)
         (incf n)))))


(defun %resize-package (pkg)
  (%resize-htab (pkg.itab pkg))
  (%resize-htab (pkg.etab pkg))
  pkg)

;These allow deleted packages, so can't use pkg-arg which doesn't.
;Of course, the wonderful world of optional arguments comes in handy.
(defun pkg-arg-allow-deleted (pkg)
  (pkg-arg pkg t))


(defun package-name (pkg) (%car (pkg.names (pkg-arg-allow-deleted pkg))))
;;>> Shouldn't these copy-list their result so that the user
;;>>  can't cause a crash through evil rplacding?
;Of course that would make rplacding less evil, and then how would they ever learn?
(defun package-nicknames (pkg) (%cdr (pkg.names (pkg-arg-allow-deleted pkg))))
(defun package-use-list (pkg) (pkg.used (pkg-arg-allow-deleted pkg)))
(defun package-used-by-list (pkg) (pkg.used-by (pkg-arg-allow-deleted pkg)))
(defun package-shadowing-symbols (pkg) (pkg.shadowed (pkg-arg-allow-deleted pkg)))

;;; This assumes that all symbol-names and package-names are strings.
(defun %define-package (name size 
                             external-size ; extension (may be nil.)
                             nicknames
                             shadow
                             shadowing-import-from-specs
                             use
                             import-from-specs
                             intern
                             export
			     &optional doc)
  (if (eq use :default) (setq use *make-package-use-defaults*))
  (let* ((pkg (find-package name)))
    (if pkg
      ;; Restarts could offer several ways of fixing this.
      (unless (string= (package-name pkg) name)
        (cerror "Redefine ~*~S"
                "~S is already a nickname for ~S" name pkg))
      (setq pkg (make-package name
                              :use nil
                              :internal-size (or size 60)
                              :external-size (or external-size
                                                 (max (length export) 1)))))
    (record-source-file name 'package)
    (unuse-package (package-use-list pkg) pkg)
    (rename-package pkg name nicknames)
    (flet ((operation-on-all-specs (function speclist)
             (let ((to-do nil))
               (dolist (spec speclist)
                 (let ((from (pop spec)))
                   (dolist (str spec)
                     (multiple-value-bind (sym win) (find-symbol str from)
                       (if win
                         (push sym to-do)
                         ; This should (maybe) be a PACKAGE-ERROR.
                         (cerror "Ignore attempt to ~s ~s from package ~s"
                                 "Cannot ~s ~s from package ~s" function str from))))))
               (when to-do (funcall function to-do pkg)))))
      
      (dolist (sym shadow) (shadow sym pkg))
      (operation-on-all-specs 'shadowing-import shadowing-import-from-specs)
      (use-package use pkg)
      (operation-on-all-specs 'import import-from-specs)
      (dolist (str intern) (intern str pkg))
      (when export
        (let* ((syms nil))
          (dolist (str export)
            (multiple-value-bind (sym found) (find-symbol str pkg)
              (unless found (setq sym (intern str pkg)))
              (push sym syms)))
          (export syms pkg)))
      (when (and doc *save-doc-strings*)
        (set-documentation pkg t doc))
      pkg)))

(defun %setup-pkg-iter-state (pkg-list types)
  (collect ((steps))
    (flet ((cons-pkg-iter-step (package type table &optional shadowed)
             (steps (vector package type table shadowed nil nil))))
      (let* ((pkgs (if (listp pkg-list)
                     (mapcar #'pkg-arg pkg-list)
                     (list (pkg-arg pkg-list)))))
        (dolist (pkg pkgs)
          (dolist (type types)
            (case type
              (:internal (cons-pkg-iter-step pkg type (pkg.itab pkg)))
              (:external (cons-pkg-iter-step pkg type (pkg.etab pkg)))
              (:inherited
               (let* ((shadowed (pkg.shadowed pkg))
                      (used (pkg.used pkg)))
                 (dolist (u used)
                   (cons-pkg-iter-step pkg type (pkg.etab u) shadowed)))))))))
    (vector nil (steps))))

(defun %pkg-iter-next (state)
  (flet ((get-step ()
           (let* ((step (pkg-iter.step state)))
             (loop
               (if (and step (> (pkg-iter-step.index step) 0))
                 (return step))
               (when (setq step (pop (pkg-iter.remaining-steps state)))
                 (setf (pkg-iter.step state) step)
                 (setf (pkg-iter-step.index step)
                       (length (setf (pkg-iter-step.vector step)
                                     (pkgtab-table  (pkg-iter-step.table step))))))
               (unless step
                 (return))))))
    (loop
      (let* ((step (get-step)))
        (when (null step) (return))
        (multiple-value-bind (symbol found)
            (%htab-symbol (pkg-iter-step.vector step)
                          (decf (pkg-iter-step.index step)))
          (when (and found
                     (not (member symbol (pkg-iter-step.shadowed step)
                                  :test #'string=)))
            (return (values t
                            symbol
                            (pkg-iter-step.type step)
                            (pkg-iter-step.pkg step)))))))))


;;; For do-symbols and with-package-iterator
;;; string must be a simple string
;;; package must be a package
;;; Wouldn't it be nice if this distinguished "not found" from "found NIL" ?
(defun %name-present-in-package-p (string package)
  (values (%find-package-symbol string package)))

;;; This is supposed to be (somewhat) like the lisp machine's MAKE-PACKAGE.
;;; Accept and ignore some keyword arguments, accept and process some others.

(defun lispm-make-package (name &key 
                                (use *make-package-use-defaults*)
                                nicknames
                                ;prefix-name
                                ;invisible
                                (shadow nil shadow-p)
                                (export nil export-p)
                                (shadowing-import nil shadowing-import-p)
                                (import nil import-p)
                                (import-from nil import-from-p)
                                ;relative-names
                                ;relative-names-for-me
                                ;size
                                ;hash-inherited-symbols
                                ;external-only
                                ;include
                                ;new-symbol-function
                                ;colon-mode
                                ;prefix-intern-function
                                &allow-other-keys)
  ;  (declare (ignore prefix-name invisible relative-names relative-names-for-me
  ;                   size hash-inherited-symbols external-only include
  ;                   new-symbol-function colon-mode prefix-intern-function))
  (let ((pkg (make-package name :use NIL :nicknames nicknames)))
    (when shadow-p (shadow shadow pkg))
    (when shadowing-import-p (shadowing-import shadowing-import pkg))
    (use-package use pkg)
    (when import-from-p
      (let ((from-pkg (pop import-from)))
        (dolist (name import-from)
          (multiple-value-bind (sym win) (find-symbol (string name) from-pkg)
            (when win (import-1 pkg sym))))))
    (when import-p (import import pkg))
    (when export-p
      (let* ((syms nil))
        (dolist (name export)
          (multiple-value-bind (sym win) (find-symbol (string name) pkg)
            (unless win (setq sym (intern (string name) pkg)))
            (push sym syms)))
        (export syms pkg)))
    pkg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-symhash.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; L1-utils.lisp

(in-package "CCL")

;The following forms (up thru defn of %DEFUN) must come before any DEFUN's.
;Any (non-kernel) functions must be defined before they're used! 
;In fact, ALL functions must be defined before they're used!  How about that ?



(setq %lisp-system-fixups% nil)


;;; Kludge for record-source-file bootstrapping

(%fhave 'full-pathname (qlfun bootstrapping-full-pathname (name) name))


; real one is  in setf.lisp
(%fhave '%setf-method (qlfun bootstripping-setf-fsname (spec)
                                   spec nil))

(fset 'physical-pathname-p (lambda (file)(declare (ignore file)) nil)) ; redefined later

(setq *record-source-file* t)

(fset 'level-1-record-source-file
      (qlfun level-1-record-source-file (name def-type &optional (source (or *loading-toplevel-location*
                                                                             *loading-file-source-file*)))
        ;; Level-0 puts stuff on plist of name.  Once we're in level-1, names can
        ;; be more complicated than just a symbol, so just collect all calls until
        ;; the real record-source-file is loaded.
        (when *record-source-file*
          (unless (listp *record-source-file*)
            (setq *record-source-file* nil))
          (push (list name def-type source) *record-source-file*))))

(fset 'record-source-file #'level-1-record-source-file)

(defun inherit-from-p (ob parent)
  (memq (if (symbolp parent) (find-class parent nil) parent)
        (%inited-class-cpl (class-of ob))))

;;; returns new plist with value spliced in or key, value consed on.
(defun setprop (plist key value &aux loc)
  (if (setq loc (pl-search plist key))
    (progn (%rplaca (%cdr loc) value) plist)
    (cons key (cons value plist))))

(defun getf-test (place indicator test &optional default)
  (loop
    (when (null place)
      (return default))
    (when (funcall test indicator (car place))
      (return (cadr place)))
    (setq place (cddr place))))

(defun setprop-test (plist indicator test value)
  (let ((tail plist))
    (loop
      (when (null tail)
        (return (cons indicator (cons value plist))))
      (when (funcall test indicator (car tail))
        (setf (cadr tail) value)
        (return plist))
      (setq tail (cddr tail)))))

(defun plistp (p &aux len)
  (and (listp p)
       (setq len (list-length p))
       (not (%ilogbitp 0 len))))  ; (evenp p)

(defun %imax (i1 i2)
 (if (%i> i1 i2) i1 i2))

(defun %imin (i1 i2)
  (if (%i< i1 i2) i1 i2))




;|#


(eval-when (:compile-toplevel :execute)
  (require "NUMBER-MACROS"))




(defun loading-file-source-file ()
  *loading-file-source-file*)

(setq *save-local-symbols* t)

(%fhave 'require-type (nfunction bootstrapping-require-type
                                 (lambda (thing type)
                                   (declare (ignore type))
                                   thing)))
(%fhave '%require-type 
        (nfunction bootstrapping-%require-type
                   (lambda (thing predicate)
                     (declare (ignore predicate))
                     thing)))

(setf (type-predicate 'macptr) 'macptrp)

;;; Once we're bootstrapped, we should move the real PREPARE-TO-DESTRUCTURE
;;; here.
(defun %early-prepare-to-destructure (list &rest ignore)
  (declare (ignore ignore))
  list)

(setf (fdefinition 'prepare-to-destructure) #'%early-prepare-to-destructure)







(defun %keyword-present-p (keys keyword)
  (let* ((not-there (cons nil nil)))
    (declare (dynamic-extent not-there))
    (not (eq (getf keys keyword not-there) not-there))))

(defun check-keywords (keys actual allow-others)
  (let* ((len (ignore-errors (list-length actual))))
    (if (null len)
      (signal-simple-program-error "Circular or dotted keyword list: ~s" actual)
      (if (oddp len)
	(signal-simple-program-error "Odd length keyword list: ~s" actual))))
  (setq allow-others (or allow-others (getf actual :allow-other-keys)))
  (do* ((a actual (cddr a))
	(k (car a) (car a)))
       ((null a))
    (unless (typep k 'symbol)
      (signal-simple-program-error
       "Invalid keyword argument ~s in ~s.  ~&Valid keyword arguments are ~s." k actual keys))
    (unless (or allow-others
		(eq k :allow-other-keys)
		(member k keys))
      (signal-simple-program-error "Unknown keyword argument ~s in ~s.  ~&Valid keyword arguments are ~s." k actual keys))))

(%fhave 'set-macro-function #'%macro-have)   ; redefined in sysutils.

;;; Define special forms.
(dolist (sym '(block catch compiler-let eval-when
               flet function go if labels let let* macrolet
               multiple-value-call multiple-value-prog1
               progn progv quote return-from setq tagbody
               the throw unwind-protect locally load-time-value
	       symbol-macrolet
               ;; These are implementation-specific special forms :
	       nfunction
               #+ppc-target
	       ppc-lap-function
               #+arm-target
               arm-lap-function
               #+x86-target
               x86-lap-function
               fbind
               with-c-frame with-variable-c-frame))
  (%macro-have sym sym))


(defun %macro (named-fn &optional doc &aux arglist)
  ;; "doc" is either a string or a list of the form :
  ;; (doc-string-or-nil . (body-pos-or-nil . arglist-or-nil))
  (if (listp doc)
    (setq arglist (cddr doc)
          doc (car doc)))
  (let* ((name (function-name named-fn)))
    (record-source-file name 'function)
    (set-macro-function name named-fn)
    (when (and doc *save-doc-strings*)
      (set-documentation name 'function doc))
    (when arglist
      (record-arglist name arglist))
    (when *fasload-print* (format t "~&~S~%" name))
    name))


(defun %defvar (var &optional doc)
  "Returns boundp"
  (%proclaim-special var)
  (record-source-file var 'variable)
  (when (and doc *save-doc-strings*)
    (set-documentation var 'variable doc))
  (cond ((not (boundp var))
         (when *fasload-print* (format t "~&~S~%" var))
         nil)
        (t t)))

(defun %defparameter (var value &optional doc)
  (%proclaim-special var)
  (record-source-file var 'variable)
  (when (and doc *save-doc-strings*)
    (set-documentation var 'variable doc))
  (when *fasload-print* (format t "~&~S~%" var))
  (set var value)
  var)


(defun %defglobal (var value &optional doc)
  (%symbol-bits var (logior (ash 1 $sym_vbit_global) (the fixnum (%symbol-bits var))))
  (%defparameter var value doc))

;Needed early for member etc.
(defun identity (x)
  "This function simply returns what was passed to it."
  x)

(defun coerce-to-function (arg)
  (if (functionp arg)
    arg
    (if (symbolp arg)
      (%function arg)
      (report-bad-arg arg 'function))))

;;; takes arguments in arg_x, arg_y, arg_z, returns "multiple values" 
;;; Test(-not) arguments are NOT validated beyond what is done
;;; here.
;;; if both :test and :test-not supplied, signal error.
;;; if test provided as #'eq or 'eq, return first value 'eq.
;;; if test defaulted, provided as 'eql, or provided as #'eql, return
;;; first value 'eql.
;;; if test-not provided as 'eql or provided as #'eql, return second
;;; value 'eql.
;;; if key provided as either 'identity or #'identity, return third value nil.
(defun %key-conflict (test-fn test-not-fn key)
  (let* ((eqfn #'eq)
         (eqlfn #'eql)
         (idfn #'identity))
    (if (or (eq key 'identity) (eq key idfn))
      (setq key nil))
    (if test-fn
      (if test-not-fn
        (%err-disp $xkeyconflict ':test test-fn ':test-not test-not-fn)
        (if (eq test-fn eqfn)
          (values 'eq nil key)
          (if (eq test-fn eqlfn)
            (values 'eql nil key)
            (values test-fn nil key))))
      (if test-not-fn
        (if (eq test-not-fn eqfn)
          (values nil 'eq key)
          (if (eq test-not-fn eqlfn)
            (values nil 'eql key)
            (values nil test-not-fn key)))
        (values 'eql nil key)))))




;;; Assoc.

;;; (asseql item list) <=> (assoc item list :test #'eql :key #'identity)



;;; (assoc-test item list test-fn) 
;;;   <=> 
;;;     (assoc item list :test test-fn :key #'identity)
;;; test-fn may not be FUNCTIONP, so we coerce it here.
(defun assoc-test (item list test-fn)
  (dolist (pair list)
    (if pair
      (if (funcall test-fn item (car pair))
	(return pair)))))



; (assoc-test-not item list test-not-fn) 
;   <=> 
;     (assoc item list :test-not test-not-fn :key #'identity)
; test-not-fn may not be FUNCTIONP, so we coerce it here.
(defun assoc-test-not (item list test-not-fn)
  (dolist (pair list)
    (if pair
      (if (not (funcall test-not-fn item (car pair)))
	(return pair)))))

(defun assoc (item list &key test test-not key)
  "Return the cons in ALIST whose car is equal (by a given test or EQL) to
   the ITEM."
  (multiple-value-bind (test test-not key) (%key-conflict test test-not key)
    (if (null key)
      (if (eq test 'eq)
        (assq item list)
        (if (eq test 'eql)
          (asseql item list)
          (if test
            (assoc-test item list test)
            (assoc-test-not item list test-not))))
      (if test
        (dolist (pair list)
          (if pair
            (if (funcall test item (funcall key (car pair)))
              (return pair))))
        (dolist (pair list)
          (if pair
            (unless (funcall test-not item (funcall key (car pair)))
              (return pair))))))))


;;;; Member.

;;; (member-test-not item list test-not-fn) 
;;;   <=> 
;;;     (member item list :test-not test-not-fn :key #'identity)
(defun member-test-not (item list test-not-fn)
  (do* ((l list (cdr l)))
       ((endp l))
    (unless (funcall test-not-fn item (%car l)) (return l))))

(defun member (item list &key test test-not key)
  "Return the tail of LIST beginning with first element satisfying EQLity,
   :TEST, or :TEST-NOT with the given ITEM."
  (multiple-value-bind (test test-not key) (%key-conflict test test-not key)
    (if (null key)
      (if (eq test 'eq)
        (memq item list)
        (if (eq test 'eql)
          (memeql item list)
          (if test
            (member-test item list test)
            (member-test-not item list test-not))))
      (if test
        (do* ((l list (cdr l)))
             ((endp l))
          (if (funcall test item (funcall key (car l)))
              (return l)))
        (do* ((l list (cdr l)))
             ((null l))
          (unless (funcall test-not item (funcall key (car l)))
              (return l)))))))


(defun adjoin (item list &key test test-not key)
  "Add ITEM to LIST unless it is already a member"
  (if (and (not test)(not test-not)(not key))
    (if (not (memeql item list))(cons item list) list)
    (multiple-value-bind (test test-not key) (%key-conflict test test-not key)
      (if
        (if (null key)
          (if (eq test 'eq)
            (memq item list)
            (if (eq test 'eql)
              (memeql item list)
              (if test
                (member-test item list test)
                (member-test-not item list test-not))))
          (if test
            (member (funcall key item) list :test test :key key)
            (member (funcall key item) list :test-not test-not :key key)))
        list
        (cons item list)))))

(defun adjoin-eq (elt list)
  (if (memq elt list)
    list
    (cons elt list)))

(defun adjoin-eql (elt list)
  (if (memeql elt list)
    list
    (cons elt list)))

(defun union-eq (list1 list2)
  (let ((res list2))
    (dolist (elt list1)
      (unless (memq elt res)
        (push elt res)))
    res))

(defun union-eql (list1 list2)
  (let ((res list2))
    (dolist (elt list1)
      (unless (memeql elt res)
        (push elt res)))
    res))

;;; Fix this someday.  Fix EQUALP, while you're at it ...
(defun similar-as-constants-p (x y)
  (or (eq x y)                          ; Redefinition of constants to themselves.
      (if (and (stringp x) (stringp y)) ;The most obvious case where equalp & s-a-c-p need to differ...
        (string= x y)
        (equalp x y))))

(defun undefine-constant (var)
  (%set-sym-global-value var (%unbound-marker-8)))

(defparameter *cerror-on-constant-redefinition* t)

(defun define-constant (var value)
  (block nil
    (if (constant-symbol-p var)
      (let* ((old-value (%sym-global-value var)))
	(unless (eq old-value (%unbound-marker-8))
	  (if (or (eql old-value value)
                  (and (not *strict-checking*) (similar-as-constants-p old-value value)))
	    (return)
	    ;; This should really be a cell error, allow options other than
	    ;; redefining (such as don't redefine and continue)...
            (when *cerror-on-constant-redefinition*
              (cerror "Redefine ~S to have new value ~*~s"
                      "Constant ~S is already defined with a different value (~s)"
                      var old-value value))))))
    (%symbol-bits var 
                  (%ilogior (%ilsl $sym_bit_special 1) (%ilsl $sym_bit_const 1)
                            (%symbol-bits var)))
    (%set-sym-global-value var value))
  var)

(defun %defconstant (var value &optional doc)
  (%proclaim-special var)
  (record-source-file var 'constant)
  (define-constant var value)
  (when (and doc *save-doc-strings*)
    (set-documentation var 'variable doc))
  (when *fasload-print* (format t "~&~S~%" var))
  var)

(defparameter *nx1-compiler-special-forms* ())
(defparameter *nx-proclaimed-types* ())
(defparameter *nx-proclaimed-ftypes* nil)

(defun compiler-special-form-p (sym)
  (or (eq sym 'quote)
      (if (memq sym *nx1-compiler-special-forms*) t)))



(defparameter *nx-known-declarations* ())
(defparameter *nx-proclaimed-inline* ())
(defparameter *nx-proclaimed-ignore* ())
(defparameter *nx-globally-inline* ())



(defconstant *cl-types* '(
array
atom
base-char
bignum
bit
bit-vector 
character
#|
lisp:common
|#
compiled-function 
complex 
cons                    
double-float
extended-char
fixnum
float
function
hash-table
integer
keyword
list 
long-float
nil 
null
number  
package
pathname 
random-state  
ratio
rational
readtable
real
sequence 
short-float
signed-byte 
simple-array
simple-bit-vector
simple-string 
simple-base-string
simple-vector 
single-float
standard-char
stream  
string
#|
lisp:string-char
|#
symbol
t
unsigned-byte 
vector
))

;; Redefined in sysutils.
(%fhave 'specifier-type-if-known
        (qlfun bootstrapping-type-specifier-p (name &optional env &key &allow-other-keys)
          (declare (ignore env))
          (memq name *cl-types*)))



(defun proclaim (spec)
  (case (car spec)
    (special (apply #'proclaim-special (%cdr spec)))
    (notspecial (apply #'proclaim-notspecial (%cdr spec)))
    (optimize (%proclaim-optimize (%cdr spec)))
    (inline (apply #'proclaim-inline t (%cdr spec)))
    (notinline (apply #'proclaim-inline nil (%cdr spec)))
    (declaration (apply #'proclaim-declaration (%cdr spec)))
    (ignore (apply #'proclaim-ignore t (%cdr spec)))
    (unignore (apply #'proclaim-ignore nil (%cdr spec)))
    (type (apply #'proclaim-type (%cdr spec)))
    (ftype (apply #'proclaim-ftype (%cdr spec)))
    (function (apply #'proclaim-type spec))
    (t (unless (memq (%car spec) *nx-known-declarations*)
         ;; Any type name is now (ANSI CL) a valid declaration.
         (if (specifier-type-if-known (%car spec))
           (apply #'proclaim-type spec)
           (signal-program-error "Unknown declaration specifier ~s in ~S" (%car spec) spec))))))

(defun bad-proclaim-spec (spec)
  (signal-program-error "Invalid declaration specifier ~s" spec))


(defun using-linear-scan () *backend-use-linear-scan*)


(defun proclaim-type (type &rest vars)
  (declare (dynamic-extent vars))
  ;; Called too early to use (every #'symbolp vars)
  (unless (loop for v in vars always (symbolp v)) (bad-proclaim-spec `(,type ,@vars)))
  (when *type-system-initialized*
    ;; Check the type.  This will signal program-error's in case of invalid types, let it.
    ;; Do not signal anything about unknown types though -- it should be ok to have forward
    ;; references here, before anybody needs the info.
    (specifier-type type))
  (dolist (var vars)
    (let ((spec (assq var *nx-proclaimed-types*)))
      (if spec
        (rplacd spec type)
        (push (cons var type) *nx-proclaimed-types*)))))

(defun proclaim-ftype (ftype &rest names)
  (declare (dynamic-extent names))
  (unless (every (lambda (v) (or (symbolp v) (setf-function-name-p v))) names)
    (bad-proclaim-spec `(ftype ,ftype ,@names)))
  (unless *nx-proclaimed-ftypes*
    (setq *nx-proclaimed-ftypes* (make-hash-table :test #'eq)))
  ;; Check the type.  This will signal program-error's in case of invalid types, let it.
  ;; Do not signal anything about unknown types though -- it should be ok to have forward
  ;; references here, before anybody needs the info.
  (let* ((ctype (specifier-type ftype)))
    ;; If know enough to complain now, do so.
    (when (types-disjoint-p ctype (specifier-type 'function))
      (bad-proclaim-spec `(ftype ,ftype ,@names))))
  (dolist (name names)
    (setf (gethash (maybe-setf-function-name name) *nx-proclaimed-ftypes*) ftype)))



(defun proclaimed-ftype (name)
  (when *nx-proclaimed-ftypes*
    (gethash (ensure-valid-function-name name) *nx-proclaimed-ftypes*)))


(defun proclaim-special (&rest vars)
  (declare (dynamic-extent vars))
  (unless (every #'symbolp vars) (bad-proclaim-spec `(special ,@vars)))
  (dolist (sym vars) (%proclaim-special sym)))


(defun proclaim-notspecial (&rest vars)
  (declare (dynamic-extent vars))
  (unless (every #'symbolp vars) (bad-proclaim-spec `(special ,@vars)))
  (dolist (sym vars) (%proclaim-notspecial sym)))

(defun proclaim-inline (t-or-nil &rest names)
  (declare (dynamic-extent names))
  ;;This is just to make it more likely to detect forgetting about the
  ;;first arg...
  (unless (or (eq nil t-or-nil) (eq t t-or-nil)) (report-bad-arg t-or-nil '(member t nil)))
  (unless (loop for v in names always (or (symbolp v) (setf-function-name-p v)))
    (bad-proclaim-spec `(,(if t-or-nil 'inline 'notinline) ,@names)))
  (dolist (name names)
    (setq name (maybe-setf-function-name name))
    (if (listp *nx-proclaimed-inline*)
      (setq *nx-proclaimed-inline*
          (alist-adjoin name
                        (or t-or-nil (if (compiler-special-form-p name) t))
                        *nx-proclaimed-inline*))
      (setf (gethash name *nx-proclaimed-inline*)
            (or t-or-nil (if (compiler-special-form-p name) t))))))

(defun proclaim-declaration (&rest syms)
  (declare (dynamic-extent syms))
  (unless (every #'symbolp syms) (bad-proclaim-spec `(declaration ,@syms)))
  (dolist (sym syms)
    (when (type-specifier-p sym)
      (error "Cannot define declaration ~s because it is the name of a type" sym))
    (setq *nx-known-declarations* 
          (adjoin sym *nx-known-declarations* :test 'eq))))

(defun check-declaration-redefinition (name why)
  (when (memq name *nx-known-declarations*)
    (cerror "Undeclare the declaration ~*~s"
	    "Cannot ~a ~s because ~:*~s has been declared as a declaration name" why name)
    (setq *nx-known-declarations* (remove name *nx-known-declarations*))))

(defun proclaim-ignore (t-or-nil &rest syms)
  (declare (dynamic-extent syms))
  ;;This is just to make it more likely to detect forgetting about the
  ;;first arg...
  (unless (or (eq nil t-or-nil) (eq t t-or-nil)) (report-bad-arg t-or-nil '(member t nil)))
  (unless (every #'symbolp syms) (bad-proclaim-spec `(,(if t-or-nil 'ignore 'unignore) ,@syms)))
  (dolist (sym syms)
    (setq *nx-proclaimed-ignore*
          (alist-adjoin sym t-or-nil *nx-proclaimed-ignore*))))


(queue-fixup
 (when (listp *nx-proclaimed-inline*)
  (let ((table (make-hash-table :size 100 :test #'eq)))
    (dolist (x *nx-proclaimed-inline*)
      (let ((name (car x)) (value (cdr x)))
        (when (symbolp name)
          (setf (gethash name table) value))))
    (setq *nx-proclaimed-inline* table))))

(defun proclaimed-special-p (sym)
  (%ilogbitp $sym_vbit_special (%symbol-bits sym)))

(defun proclaimed-inline-p (sym)
  (if (listp *nx-proclaimed-inline*)
    (%cdr (assq sym *nx-proclaimed-inline*))
    (gethash sym *nx-proclaimed-inline*)))

(defun proclaimed-notinline-p (sym)
  (if (listp *nx-proclaimed-inline*)
    (and (setq sym (assq sym *nx-proclaimed-inline*))
         (null (%cdr sym)))
    (null (gethash sym *nx-proclaimed-inline* t))))


(defun self-evaluating-p (form)
  (and (atom form)
       (or (not (non-nil-symbol-p form))
           (eq form t)
           (keywordp form))))

(defun constantp (form &optional env)
  "True of any Lisp object that has a constant value: types that eval to
  themselves, keywords, constants, and list whose car is QUOTE."
   (or (self-evaluating-p form)
       (quoted-form-p form)
       (constant-symbol-p form)
       (and env
	    (symbolp form)
	    (eq :constant (variable-information form env)))))


(defun eval-constant (form)
  (if (quoted-form-p form) (%cadr form)
    (if (constant-symbol-p form) (symbol-value form)
      (if (self-evaluating-p form) form
	(report-bad-arg form '(satisfies constantp))))))

(defvar *lfun-names*)


(defvar %lambda-lists% (make-hash-table :test #'eq :weak t))
(defparameter *save-arglist-info* t)


(defun record-arglist (name args)
  "Used by defmacro & defgeneric"
  (when (or *save-arglist-info* *save-local-symbols*)
    (setf (gethash name %lambda-lists%) args)))


;;;Support the simple case of defsetf.
(%fhave 'store-setf-method
        (qlfun bootstrapping-store-setf-method (name fn &optional doc)
          (declare (ignore doc))
          (put name 'bootstrapping-setf-method (require-type fn 'symbol))))
(%fhave '%setf-method
        (qlfun bootstrapping-%setf-method (name)
          (get name 'bootstrapping-setf-method)))


;;; defmacro uses (setf (assq ...) ...) for &body forms.
(defun adjoin-assq (indicator alist value)
  (let ((cell (assq indicator alist)))
    (if cell 
      (setf (cdr cell) value)
      (push (cons indicator value) alist)))
  alist)

(defmacro setf-assq (indicator place value)
  (let ((res (gensym)))
    `(let (,res)
       (setf ,place (adjoin-assq ,indicator ,place (setq ,res ,value)))
       ,res)))

(defsetf assq setf-assq)
(defsetf %typed-miscref %typed-miscset)

(defun quoted-form-p (form)
   (and (consp form)
        (eq (%car form) 'quote)
        (consp (%cdr form))
        (null (%cdr (%cdr form)))))

(defun lambda-expression-p (form)
  (and (consp form)
       (eq (%car form) 'lambda)
       (consp (%cdr form))
       (listp (%cadr form))))

;;;;;FUNCTION BINDING Functions

(defun fdefinition (name)
  (or (fboundp name) ;Our fboundp returns the binding
      (prog1 (%err-disp $xfunbnd name))))

(defun symbol-function (name)
  "Return the definition of NAME, even if it is a macro or a special form.
   Error if NAME doesn't have a definition."
  (fdefinition (require-type name 'symbol)))


(defun %make-function (name fn env)
  (compile-user-function fn name env))
    
;;;;;;;;; VALUE BINDING Functions

;; Lock used only to make sure calls to GENSYM don't step on each other.  Users who
;; modify *gensym-counter* in multi-threaded apps will need to do their own locking.
(defparameter *gensym-lock* (make-lock))

(defun gensym (&optional (string-or-integer nil string-or-integer-p))
  "Creates a new uninterned symbol whose name is a prefix string (defaults
   to \"G\"), followed by a decimal number. Thing, when supplied, will
   alter the prefix if it is a string, or be used for the decimal number
   if it is a number, of this symbol. The default value of the number is
   the current value of *gensym-counter* which is incremented each time
   it is used."
  (let ((prefix "G")
        (counter nil))
    (when string-or-integer-p
      (etypecase string-or-integer
        (integer (setq counter string-or-integer)) ; & emit-style-warning
        (string (setq prefix (ensure-simple-string string-or-integer)))))
    (unless counter
      (with-lock-grabbed (*gensym-lock*)
        (setq *gensym-counter* (1+ (setq counter *gensym-counter*)))))
    (make-symbol (%str-cat prefix (%integer-to-string counter)))))

(defun make-keyword (name)
  (if (and (symbolp name) (eq (symbol-package name) *keyword-package*))
    name
    (values (intern (string name) *keyword-package*))))




; destructive, removes first match only
(defun remove-from-alist (thing alist)
 (let ((start alist))
  (if (eq thing (%caar alist))
   (%cdr alist)
   (let* ((prev start)
          (this (%cdr prev))
          (next (%cdr this)))
    (while this
     (if (eq thing (%caar this))
      (progn
       (%rplacd prev next)
       (return-from remove-from-alist start))
      (setq prev this
            this next
            next (%cdr next))))
    start))))

;destructive
(defun add-to-alist (thing val alist &aux (pair (assq thing alist)))
  (if pair
    (progn (%rplacd pair thing) alist)
    (cons (cons thing val) alist)))

;non-destructive...
(defun alist-adjoin (thing val alist &aux (pair (assq thing alist)))
  (if (and pair (eq (%cdr pair) val))
    alist
    (cons (cons thing val) alist)))

(defun %str-assoc (str alist)
  (assoc str alist :test #'string-equal))

(defstatic *pathname-escape-character*
  #+windows-target #\>
  #-windows-target #\\
  "Not CL.  A Coral addition for compatibility between CL spec and the shell.")

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))

(defun caaar (x) (car (car (car x))))
(defun caadr (x) (car (car (cdr x))))
(defun cadar (x) (car (cdr (car x))))
(defun caddr (x) (car (cdr (cdr x))))
(defun cdaar (x) (cdr (car (car x))))
(defun cdadr (x) (cdr (car (cdr x))))
(defun cddar (x) (cdr (cdr (car x))))
(defun cdddr (x) (cdr (cdr (cdr x))))

(%fhave 'type-of #'%type-of)



(defun pointerp (thing &optional errorp)
  (if (macptrp thing)
    t
    (if errorp (error "~S is not a pointer" thing) nil)))


;Add an item to a dialog items list handle.  HUH ?
(defun %rsc-string (n)
  (or (cdr (assq n *error-format-strings*))
  (%str-cat "Error #" (%integer-to-string n))))

(defun string-arg (arg)
 (or (string-argp arg) (error "~S is not a string" arg)))

(defun string-argp (arg)
  (cond ((symbolp arg) (symbol-name arg))
        ((typep arg 'character) (string arg))
        ((stringp arg) (ensure-simple-string arg))
        (t nil)))
  
(defun symbol-arg (arg)
  (unless (symbolp arg)
    (report-bad-arg arg 'symbol))
  arg)

(defun %cstrlen (ptr)
  ;;(#_strlen ptr)
  (do* ((i 0 (1+ i)))
       ((zerop (the fixnum (%get-byte ptr i))) i)
    (declare (fixnum i))))


(defun %set-cstring (ptr string)
  (%cstr-pointer string ptr)
  string)

(defsetf %get-cstring %set-cstring)

;;; Deprecated, but used by UFFI.
(defun %put-cstring (ptr str &optional (offset 0))
  (setf (%get-cstring (%inc-ptr ptr offset)) str)
  ;; 0 is the traditional, not-very-useful return value ...
  0)






;;; Returns a simple string and adjusted start and end, such that
;;; 0<= start <= end <= (length simple-string).
(defun get-sstring (str &optional (start 0) (end (length (require-type str 'string))))
  (multiple-value-bind (sstr offset) (array-data-and-offset (string str))
    (setq start (+ start offset) end (+ end offset))
    (when (< (length sstr) end)(setq end (length sstr)))
    (when (< end start) (setq start end))
    (values sstr start end)))

;e.g. (bad-named-arg :key key 'function)
(defun bad-named-arg (name arg &optional (type nil type-p))
  (if type-p
    (%err-disp $err-bad-named-arg-2 name arg type)
    (%err-disp $err-bad-named-arg name arg)))

(defun verify-arg-count (call min &optional max)
  "If call contains less than MIN number of args, or more than MAX
   number of args, error. Otherwise, return call.
   If Max is NIL, the maximum args for the fn are infinity."
 (or (verify-call-count (car call) (%cdr call) min max) call))

(defun verify-call-count (sym args min &optional max &aux argcount)
  (if (%i< (setq argcount  (list-length args)) min)
    (%err-disp $xtoofew (cons sym args))
    (if (if max (%i> argcount max))
      (%err-disp $xtoomany (cons sym args)))))

(defun getf (place key &optional (default ()))
  "Search the property list stored in Place for an indicator EQ to INDICATOR.
  If one is found, return the corresponding value, else return DEFAULT."
  (let ((p (pl-search place key))) (if p (%cadr p) default)))

(defun remprop (symbol key)
  "Look on property list of SYMBOL for property with specified
  INDICATOR. If found, splice this indicator and its value out of
  the plist, and return the tail of the original list starting with
  INDICATOR. If not found, return () with no side effects.

  NOTE: The ANSI specification requires REMPROP to return true (not false)
  or false (the symbol NIL). Portable code should not rely on any other value."
  (do* ((prev nil plist)
        (plist (symbol-plist symbol) tail)
        (tail (cddr plist) (cddr tail)))
       ((null plist))
    (when (eq (car plist) key)
      (if prev
        (rplacd (cdr prev) tail)
        (setf (symbol-plist symbol) tail))
      (return t))))



;;; If this returns non-nil, safe to do %rplaca of %cdr to update.
(defun pl-search (plist key)
  (unless (plistp plist)
    (report-bad-arg plist '(satisfies plistp)))
  (%pl-search plist key))


(defun rassoc (item alist &key (test #'eql test-p) test-not (key #'identity))
  (declare (list alist))
  "Return the cons in ALIST whose CDR is equal (by a given test or EQL) to
   the ITEM."
  (if (or test-p (not test-not))
    (progn
      (if test-not (error "Cannot specify both :TEST and :TEST-NOT."))
      (dolist (pair alist)
        (if (atom pair)
          (if pair (error "Invalid alist containing ~S: ~S" pair alist))
          (when (funcall test item (funcall key (cdr pair))) (return pair)))))
    (progn
      (unless test-not (error "Must specify at least one of :TEST or :TEST-NOT"))
      (dolist (pair alist)
        (if (atom pair)
          (if pair (error "Invalid alist containing ~S: ~S" pair alist))
          (unless (funcall test-not item (funcall key (cdr pair))) (return pair)))))))

(defun *%saved-method-var%* ()
  (declare (special %saved-method-var%))
  %saved-method-var%)

(defun set-*%saved-method-var%* (new-value)
  (declare (special %saved-method-var%))
  (setq %saved-method-var% new-value))

(defsetf *%saved-method-var%* set-*%saved-method-var%*)






(setf (symbol-function 'clear-type-cache) #'false)      ; bootstrapping

(defun make-array-1 (dims element-type element-type-p
                          displaced-to
                          displaced-index-offset
                          adjustable
                          fill-pointer
                          initial-element initial-element-p
                          initial-contents initial-contents-p
                          size)
  (let ((subtype (element-type-subtype element-type)))
    (when (and element-type (null subtype))
      (error "Unknown element-type ~S" element-type))
    (when (null size)
      (cond ((listp dims)
             (setq size 1)
             (dolist (dim dims)
               (when (< dim 0)
                 (report-bad-arg dim '(integer 0 *)))
               (setq size (* size dim))))
            (t (setq size dims)))) ; no need to check vs. array-dimension-limit
    (cond
     (displaced-to
      (when (or initial-element-p initial-contents-p)
        (error "Cannot specify initial values for displaced arrays"))
      (when (and element-type-p
                 (neq (array-element-subtype displaced-to) subtype))
        (error "The ~S array ~S is not of ~S ~S"
               :displaced-to displaced-to :element-type element-type))
      (%make-displaced-array dims displaced-to
                             fill-pointer adjustable displaced-index-offset t))
     (t
      (when displaced-index-offset
        (error "Cannot specify ~S for non-displaced-array" :displaced-index-offset))
      (when (null subtype)
        (error "Cannot make an array of empty type ~S" element-type))
      (make-uarray-1 subtype dims adjustable fill-pointer 
                     initial-element initial-element-p
                     initial-contents initial-contents-p
                     nil size)))))

(defun %make-simple-array (subtype dims)
  (let* ((size (if (listp dims) (apply #'* dims) dims))
         (vector (%alloc-misc size subtype)))
    (if (and (listp dims)
             (not (eql (length dims) 1)))
      (let* ((array (%make-displaced-array dims vector)))
        (%set-simple-array-p array)
        array)
      vector)))

(defun make-uarray-1 (subtype dims adjustable fill-pointer
                              initial-element initial-element-p
                              initial-contents initial-contents-p
                              temporary 
                              size)
  (declare (ignore temporary))
  (when (null size)(setq size (if (listp dims)(apply #'* dims) dims)))
  (let ((vector (%alloc-misc size subtype)))  ; may not get here in that case
    (if initial-element-p
      (cond ((and (eql subtype target::subtag-simple-base-string)
                  (eql initial-element #\Null)))
            ((and (eql subtype target::subtag-double-float-vector)
                  (eql initial-element 0.0d0)))
            ((and (eql subtype target::subtag-single-float-vector)
                  (eql initial-element 0.0s0)))
            (t (or (eql initial-element 0)
                   (%init-misc initial-element vector))))
      (if initial-contents-p
        (if (null dims) (uvset vector 0 initial-contents)
            (init-uvector-contents vector 0 dims initial-contents))))
    (if (and (null fill-pointer)
             (not adjustable)
             dims
             (or (atom dims) (null (%cdr dims))))
      vector
      (let ((array (%make-displaced-array dims vector 
                                          fill-pointer adjustable nil)))
        (when (and (null fill-pointer) (not adjustable))
          (%set-simple-array-p array))
        array))))

(defun init-uvector-contents (vect offset dims contents
                              &aux (len (length contents)))
  "Returns final offset. Assumes dims not ()."
  (unless (eq len (if (atom dims) dims (%car dims)))
    (error "~S doesn't match array dimensions of ~S ."  contents vect))
  (cond ((or (atom dims) (null (%cdr dims)))
         (if (listp contents)
           (let ((contents-tail contents))
             (dotimes (i len)
               (declare (fixnum i))
               (uvset vect offset (pop contents-tail))
               (setq offset (%i+ offset 1))))
           (dotimes (i len)
             (declare (fixnum i))
             (uvset vect offset (elt contents i))
             (setq offset (%i+ offset 1)))))
        (t (setq dims (%cdr dims))
           (if (listp contents)
             (let ((contents-tail contents))
               (dotimes (i len)
                 (declare (fixnum i))
                 (setq offset
                       (init-uvector-contents vect offset dims (pop contents-tail)))))
             (dotimes (i len)
               (declare (fixnum i))
               (setq offset
                     (init-uvector-contents vect offset dims (elt contents i)))))))
  offset)

(defun %get-signed-long-long (ptr &optional (offset 0))
  (%%get-signed-longlong ptr offset))

(defun %set-signed-long-long (ptr arg1
				  &optional
				  (arg2 (prog1 arg1 (setq arg1 0))))
  (%%set-signed-longlong ptr arg1 arg2))
				  
(defun %get-unsigned-long-long (ptr &optional (offset 0))
  (%%get-unsigned-longlong ptr offset))

(defun %set-unsigned-long-long (ptr arg1
				  &optional
				  (arg2 (prog1 arg1 (setq arg1 0))))
  (%%set-unsigned-longlong ptr arg1 arg2))

(defun %composite-pointer-ref (size pointer offset)
  (declare (ignorable size))
  (%inc-ptr pointer offset))

(defun %set-composite-pointer-ref (size pointer offset new)
  (#_memmove (%inc-ptr pointer offset)
             new
             size))


(defsetf %composite-pointer-ref %set-composite-pointer-ref)


(defsetf pathname-encoding-name set-pathname-encoding-name)

;end of L1-utils.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-clos-boot.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.




;;; l1-clos-boot.lisp


(in-package "CCL")


(defstatic *clos-optimizations-active* nil)

(defun disable-clos-optimizations (operation operand)
  (when *clos-optimizations-active*
    (cerror "Peform the requested operation after disabling CLOS optimizations.~&To reenable CLOS optimizations, call ~s."
            (make-condition 'simple-error
                           :format-control "CLOS optimizations are in effect, so it isn't safe to ~a ~s."
                           :format-arguments (list operation operand))
            (cons 'snap-reader-methods (cdr *clos-optimizations-active*)))
    (setq *clos-optimizations-active* nil)
    (pessimize-clos)
    t))

;;; Early accessors.  These functions eventually all get replaced with
;;; generic functions with "real", official names.


(declaim (inline instance-slots %non-standard-instance-slots))
(defun %non-standard-instance-slots (instance typecode)
  (cond ((eql typecode target::subtag-macptr) (foreign-slots-vector instance))
        ((or (typep instance 'standard-generic-function)
             (typep instance 'funcallable-standard-object))
         (gf.slots instance))
        (t  (error "Don't know how to find slots of ~s" instance))))

(defun instance-slots (instance)
  (let* ((typecode (typecode instance)))
    (cond ((eql typecode target::subtag-instance) (instance.slots instance))
          (t (%non-standard-instance-slots instance typecode)))))


;;; True if X is a class but not a foreign-class.
(defun native-class-p (x)
  (if (%standard-instance-p x)
    (< (the fixnum (instance.hash x)) max-class-ordinal)))

(defun %class-name (class)
  (if (native-class-p class)
    (%class.name class)
    (class-name class)))

(defun %class-info (class)
  (if (native-class-p class)
    (%class.info class)
    (class-info class)))
  

(defun %class-kernel-p (class)
  (car (%class-info class)))

(defun (setf %class-kernel-p) (new class)
  (setf (car (%class-info class)) new))

(defun %class-proper-name (class)
  (cdr (%class-info class)))

(defun (setf %class-proper-name) (new class)
  (setf (cdr (%class-info class)) new))


(defun %class-own-wrapper (class)
  (if (native-class-p class)
    (%class.own-wrapper class)
   (class-own-wrapper class)))

(defun (setf %class-own-wrapper) (new class)
  (setf (%class.own-wrapper class) new))

(defun %class-alist (class)
  (%class.alist class))

(defun (setf %class-alist) (new class)
  (if (typep class 'slots-class)
    (setf (%class.alist class) new)
    new))

(defun %class-slots (class)
  (if (native-class-p class)
    (%class.slots class)
    (class-slots class)))

(defun (setf %class-slots) (new class)
  (if (native-class-p class)
    (setf (%class.slots class) new)
    (setf (class-slots class) new)))

(defun %class-direct-slots (class)
  (if (native-class-p class)
    (%class.direct-slots class)
    (class-direct-slots class)))

(defun (setf %class-direct-slots) (new class)
  (if (native-class-p class)
    (setf (%class.direct-slots class) new)
    (setf (class-direct-slots class) new)))






(defun %class-direct-superclasses (class)
  (%class.local-supers class))

(defun (setf %class-direct-superclasses) (new class)
  (setf (%class.local-supers class) new))

(defun %class-direct-subclasses (class)
  (%class.subclasses class))

(defun (setf %class-direct-subclasses) (new class)
  (setf (%class.subclasses class) new))

(defun %class-direct-default-initargs (class)
  (if (typep class 'std-class)
    (%class.local-default-initargs class)))

(defun (setf %class-direct-default-initargs) (new class)
  (if (typep class 'std-class)
    (setf (%class.local-default-initargs class) new)
    new))
  

(defun %class-default-initargs (class)
  (if (typep class 'std-class)
    (%class.default-initargs class)))


(defun (setf %class-default-initargs) (new class)
  (setf (%class.default-initargs class) new))

(defun %slot-definition-name (slotd)
  (standard-slot-definition.name slotd))


(defun %slot-definition-type (slotd)
  (standard-slot-definition.type slotd))

(defun %slot-definition-initargs (slotd)
  (standard-slot-definition.initargs slotd))


(defun %slot-definition-initform (slotd)
  (standard-slot-definition.initform slotd))

(defun %slot-definition-initfunction (slotd)
  (standard-slot-definition.initfunction slotd))

(defun %slot-definition-allocation (slotd)
  (standard-slot-definition.allocation slotd))

(defun %slot-definition-class (slotd)
  (standard-slot-definition.class slotd))

;;; Returns (VALUES BOUNDP VALUE).
(defun %slot-definition-documentation (slotd)
  (let* ((val (%standard-instance-instance-location-access
	       slotd
	       standard-slot-definition.documentation)))
    (if (eq val (%slot-unbound-marker))
      (values nil nil)
      (values t val))))


(defun %slot-definition-location (slotd)
  (standard-effective-slot-definition.location slotd))

(defun (setf %slot-definition-location) (new slotd)
  (setf (standard-effective-slot-definition.location slotd) new))

(defun %slot-definition-readers (slotd)
  (standard-direct-slot-definition.readers slotd))

(defun (setf %slot-definition-readers) (new slotd)
  (setf (standard-direct-slot-definition.readers slotd) new))

(defun %slot-definition-writers (slotd)
  (standard-direct-slot-definition.writers slotd))

(defun (setf %slot-definition-writers) (new slotd)
  (setf (standard-direct-slot-definition.writers slotd) new))

(defun %generic-function-name (gf)
  (sgf.name gf))

(defun %generic-function-method-combination (gf)
  (sgf.method-combination gf))

(defun %generic-function-method-class (gf)
  (sgf.method-class gf))


(defun %method-qualifiers (m)
  (%method.qualifiers m))

(defun %method-specializers (m)
  (%method.specializers m))

(defun %method-function (m)
  (%method.function m))

(defun (setf %method-function) (new m)
  (setf (%method.function m) new))

(defun %method-gf (m)
  (%method.gf m))

(defun (setf %method-gf) (new m)
  (setf (%method.gf m) new))

(defun %method-name (m)
  (%method.name m))

(defun %method-lambda-list (m)
  (%method.lambda-list m))


;;; Map slot-names (symbols) to SLOT-ID objects (which contain unique indices).
(let* ((slot-id-lock (make-lock))
       (next-slot-index 1)              ; 0 is never a valid slot-index
       (slot-id-hash (make-hash-table :test #'eq :weak t)))
  (defun ensure-slot-id (slot-name)
    (setq slot-name (require-type slot-name 'symbol))
    (with-lock-grabbed (slot-id-lock)
      (or (gethash slot-name slot-id-hash)
          (setf (gethash slot-name slot-id-hash)
                (%istruct 'slot-id slot-name (prog1
                                                 next-slot-index
                                               (incf next-slot-index)))))))
  (defun current-slot-index () (with-lock-grabbed (slot-id-lock)
                                 next-slot-index))
  )




(defun %slot-id-lookup-obsolete (instance slot-id)
  (update-obsolete-instance instance)
  (funcall (%wrapper-slot-id->slotd (instance.class-wrapper instance))
           instance slot-id))
(defun slot-id-lookup-no-slots (instance slot-id)
  (declare (ignore instance slot-id)))

(defun %slot-id-ref-obsolete (instance slot-id)
  (update-obsolete-instance instance)
  (funcall (%wrapper-slot-id-value (instance.class-wrapper instance))
           instance slot-id))
(defun %slot-id-ref-missing (instance slot-id)
  (values (slot-missing (class-of instance) instance (slot-id.name slot-id) 'slot-value)))

(defun %slot-id-set-obsolete (instance slot-id new-value)
  (update-obsolete-instance instance)
  (funcall (%wrapper-set-slot-id-value (instance.class-wrapper instance))
           instance slot-id new-value))

(defun %slot-id-set-missing (instance slot-id new-value)
  (slot-missing (class-of instance) instance (slot-id.name slot-id) 'setf new-value)
  new-value
  )



;;; This becomes (apply #'make-instance <method-class> &rest args).
(fset '%make-method-instance
      (nlambda bootstrapping-%make-method-instance (class &key
                                                          qualifiers
                                                          specializers
                                                          function
                                                          name
                                                          lambda-list
                                                          &allow-other-keys)
        (let* ((method
                (%instance-vector (%class-own-wrapper class)
                                  qualifiers
                                  specializers
                                  function
                                  nil
                                  name
                                  lambda-list)))
          (when function
            (let* ((inner (closure-function function)))
              (unless (eq inner function)
                (copy-method-function-bits inner function)))
            (lfun-name function method))
          method)))
  
       
		 
(defun encode-lambda-list (l &optional return-keys?)
  (multiple-value-bind (ok req opttail resttail keytail auxtail)
                       (verify-lambda-list l)
    (when ok
      (let* ((bits 0)
             (temp nil)
             (nreq (length req))
             (num-opt 0)
             (rest nil)
             (lexpr nil)
             (keyp nil)
             (key-list nil)
             (aokp nil)
             (hardopt nil))
        (when (> nreq #.(ldb $lfbits-numreq $lfbits-numreq))
          (return-from encode-lambda-list nil))
        (when (eq (pop opttail) '&optional)
          (until (eq opttail resttail)
            (when (and (consp (setq temp (pop opttail)))
                       (%cadr temp))
              (setq hardopt t))
            (setq num-opt (%i+ num-opt 1))))
        (when (eq (%car resttail) '&rest)
          (setq rest t))
        (when (eq (%car resttail) '&lexpr)
          (setq lexpr t))
        (when (eq (pop keytail) '&key)
          (setq keyp t)
          (labels ((ensure-symbol (x)
                     (if (symbolp x) x (return-from encode-lambda-list nil)))
                   (ensure-keyword (x)
                     (make-keyword (ensure-symbol x))))
            (declare (dynamic-extent #'ensure-symbol #'ensure-keyword))
            (until (eq keytail auxtail)
              (setq temp (pop keytail))
              (if (eq temp '&allow-other-keys)
                (progn
                  (setq aokp t)
                  (unless (eq keytail auxtail)
                    (return-from encode-lambda-list nil)))
                (when return-keys?
                  (push (if (consp temp)
                          (if (consp (setq temp (%car temp))) 
                            (ensure-symbol (%car temp))
                            (ensure-keyword temp))
                          (ensure-keyword temp))
                        key-list))))))
        (when (%i> nreq (ldb $lfbits-numreq -1))
          (setq nreq (ldb $lfbits-numreq -1)))
        (setq bits (dpb nreq $lfbits-numreq bits))
        (when (%i> num-opt (ldb $lfbits-numopt -1))
          (setq num-opt (ldb $lfbits-numopt -1)))
        (setq bits (dpb num-opt $lfbits-numopt bits))
        (when hardopt (setq bits (%ilogior (%ilsl $lfbits-optinit-bit 1) bits)))
        (when rest (setq bits (%ilogior (%ilsl $lfbits-rest-bit 1) bits)))
        (when lexpr (setq bits (%ilogior (%ilsl $lfbits-restv-bit 1) bits)))
        (when keyp (setq bits (%ilogior (%ilsl $lfbits-keys-bit 1) bits)))
        (when aokp (setq bits (%ilogior (%ilsl $lfbits-aok-bit 1) bits)))
        (if return-keys?
          (values bits (and keyp (apply #'vector (nreverse key-list))))
          bits)))))

(defun pair-arg-p (thing &optional lambda-list-ok supplied-p-ok keyword-nesting-ok)
  (or (symbol-arg-p thing lambda-list-ok) ; nil ok in destructuring case
      (and (consp thing)
           (or (null (%cdr thing))
               (and (consp (%cdr thing))
                    (or (null (%cddr thing))
                        (and supplied-p-ok
                             (consp (%cddr thing))
                             (null (%cdddr thing))))))
           (if (not keyword-nesting-ok)
             (req-arg-p (%car thing) lambda-list-ok)
             (or (symbol-arg-p (%car thing) lambda-list-ok)
                 (and (consp (setq thing (%car thing)))
                      (consp (%cdr thing))
                      (null (%cddr thing))
                      (%car thing)
                      (symbolp (%car thing))
                      (req-arg-p (%cadr thing) lambda-list-ok)))))))

(defun req-arg-p (thing &optional lambda-list-ok)
 (or
  (symbol-arg-p thing lambda-list-ok)
  (lambda-list-arg-p thing lambda-list-ok)))

(defun symbol-arg-p (thing nil-ok)
  (and
   (symbolp thing)
   (or thing nil-ok)
   (not (memq thing lambda-list-keywords))))

(defun lambda-list-arg-p (thing lambda-list-ok)
  (and 
   lambda-list-ok
   (listp thing)
   (if (verify-lambda-list thing t t)
     (setq *structured-lambda-list* t))))

(defun opt-arg-p (thing &optional lambda-ok)
  (pair-arg-p thing lambda-ok t nil))

(defun key-arg-p (thing &optional lambda-ok)
  (pair-arg-p thing lambda-ok t t))

(defun proclaimed-ignore-p (sym)
  (cdr (assq sym *nx-proclaimed-ignore*)))

(defun verify-lambda-list (l &optional destructure-p whole-p env-p)
  (let* ((the-keys lambda-list-keywords)
         opttail
         resttail
         keytail
         allowothertail
         auxtail
         safecopy
         whole
         m
         n
         req
         sym
         (*structured-lambda-list* nil))
    (prog ()
       (unless (listp l) (go LOSE))
       (multiple-value-setq (safecopy whole)
         (normalize-lambda-list l whole-p env-p))
       (unless (or destructure-p (eq l safecopy) (go LOSE)))
       (setq l safecopy)
       (unless (dolist (key the-keys t)
                 (when (setq m (cdr (memq key l)))
                   (if (memq key m) (return))))
         (go LOSE))
       (if (null l) (go WIN))
       (setq opttail (memq '&optional l))
       (setq m (or (memq '&rest l)
                   (unless destructure-p (memq '&lexpr l))))
       (setq n (if destructure-p (memq '&body l)))
       (if (and m n) (go LOSE) (setq resttail (or m n)))
       (setq keytail (memq '&key l))
       (if (and (setq allowothertail (memq '&allow-other-keys l))
                (not keytail))
         (go LOSE))
       (if (and (eq (car resttail) '&lexpr)
                (or keytail opttail))
         (go lose))
       (setq auxtail (memq '&aux l))
       (loop
         (when (null l) (go WIN))
         (when (or (eq l opttail)
                   (eq l resttail)
                   (eq l keytail)
                   (eq l allowothertail)
                   (eq l auxtail))
           (return))
         (setq sym (pop l))
         (unless (and (req-arg-p sym destructure-p)
                      (or (proclaimed-ignore-p sym)
                          (and destructure-p (null sym))
                          (not (memq sym req)))) ; duplicate required args
           (go LOSE))
         (push sym req))
       (when (eq l opttail)
         (setq l (%cdr l))
         (loop
           (when (null l) (go WIN))
           (when (or (eq l resttail)
                     (eq l keytail)
                     (eq l allowothertail)
                     (eq l auxtail))
             (return))
           (unless (opt-arg-p (pop l) destructure-p)
             (go LOSE))))
       (when (eq l resttail)
         (setq l (%cdr l))
         (when (or (null l)
                   (eq l opttail)
                   (eq l keytail)
                   (eq l allowothertail)
                   (eq l auxtail))
           (go LOSE))
         (unless (req-arg-p (pop l) destructure-p) (go LOSE)))
       (unless (or (eq l keytail)       ; allowothertail is a sublist of keytail if present
                   (eq l auxtail))
         (go LOSE))
       (when (eq l keytail)
         (pop l)
         (loop
           (when (null l) (go WIN))
           (when (or (eq l opttail)
                     (eq l resttail))
             (go LOSE))
           (when (or (eq l auxtail) (setq n (eq l allowothertail)))
             (if n (setq l (%cdr l)))
             (return))
           (unless (key-arg-p (pop l) destructure-p) (go LOSE))))
       (when (eq l auxtail)
         (setq l (%cdr l))
         (loop
           (when (null l) (go WIN))
           (when (or (eq l opttail)
                     (eq l resttail)
                     (eq l keytail))
             (go LOSE))
           (unless (pair-arg-p (pop l)) (go LOSE))))
       (when l (go LOSE))
       WIN
       (return (values
                t
                (nreverse req)
                (or opttail resttail keytail auxtail)
                (or resttail keytail auxtail)
                (or keytail auxtail)
                auxtail
                safecopy
                whole
                *structured-lambda-list*))
       LOSE
       (return (values nil nil nil nil nil nil nil nil nil nil)))))

(defun normalize-lambda-list (x &optional whole-p env-p)
  (let* ((y x) whole env envtail head)
    (setq
     x
     (loop
       (when (atom y)
         (if (or (null y) (eq x y))  (return x))
         (setq x (copy-list x) y x)
         (return
          (loop
            (when (atom (%cdr y))
              (%rplacd y (list '&rest (%cdr y)))
              (return x))
            (setq y (%cdr y)))))
       (setq y (%cdr y))))
    (when env-p
      ;; Trapped in a world it never made ... 
      (when (setq y (memq '&environment x))
        (setq envtail (%cddr y)
              env (%cadr y))
        (cond ((eq y x)
               (setq x envtail))
              (t
               (dolist (v x)
                 (if (eq v '&environment)
                   (return)
                   (push v head)))
               (setq x (nconc (nreverse head) envtail) y (%car envtail))))))
    (when (and whole-p 
               (eq (%car x) '&whole)
               (%cadr x))
      (setq whole (%cadr x) x (%cddr x)))
    (values x whole env)))




(eval-when (eval compile)
  (require 'defstruct-macros))

(eval-when (:compile-toplevel :execute)
  (defmacro make-instance-vector (wrapper len)
    (let* ((instance (gensym))
	   (slots (gensym)))
      `(let* ((,slots (allocate-typed-vector :slot-vector (1+ ,len) (%slot-unbound-marker)))
	      (,instance (gvector :instance 0 ,wrapper ,slots)))
	(setf (instance.hash ,instance) (strip-tag-to-fixnum ,instance)
	      (slot-vector.instance ,slots) ,instance))))
)

(eval-when (:compile-toplevel :execute)
  (defmacro make-structure-vector (size)
    `(%alloc-misc ,size target::subtag-struct nil))

)
;;;;;;;;;;;;;;;;;;;;;;;;;;; defmethod support ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(%fhave '%move-method-encapsulations-maybe ; Redefined in encapsulate
        (qlfun boot-%move-method-encapsulations-maybe (m1 m2)
          (declare (ignore m1 m2))
          nil))

(%fhave 'find-unencapsulated-definition  ;Redefined in encapsulate
        (qlfun bootstrapping-find-unencapsulated-definition (fn)
	  fn))

(%fhave 'function-encapsulated-p  ;Redefined in encapsulate
        (qlfun bootstrapping-function-encapsulated-p (fn)
	  (declare (ignore fn))
          nil))

(defparameter *uniquify-dcode* #+unique-dcode t #-unique-dcode nil
  "If true, each gf will get its own unique copy of its dcode.  Not recommended for
   real use (for one thing, it's known to break gf tracing), but may be helpful for
   profiling")

(let* ((class-wrapper-random-state (make-random-state))
       (class-wrapper-random-state-lock (make-lock)))

  (defun  new-class-wrapper-hash-index ()
    ;; mustn't be 0
    (with-lock-grabbed (class-wrapper-random-state-lock)
      (the fixnum (1+ (the fixnum (random target::target-most-positive-fixnum class-wrapper-random-state)))))))


(defun %inner-method-function (method)
  (closure-function
   (find-unencapsulated-definition
    (%method-function method))))

(defun copy-method-function-bits (from to)
  (let ((new-bits (logior (logand (logior (lsh 1 $lfbits-method-bit)
                                          (ash 1 $lfbits-nextmeth-bit)
                                          (ash 1 $lfbits-nextmeth-with-args-bit)
                                          $lfbits-args-mask) 
                                  (lfun-bits from))
                          (logand (lognot (logior (lsh 1 $lfbits-method-bit)
                                                  (ash 1 $lfbits-nextmeth-bit)
                                                  (ash 1 $lfbits-nextmeth-with-args-bit)
                                                  $lfbits-args-mask))
                                  (lfun-bits to)))))
    (lfun-bits to new-bits)
    new-bits))

(defun %ensure-generic-function-using-class (gf function-name &rest keys
						&key 
						&allow-other-keys)
  (if gf
    (apply #'%ensure-existing-generic-function-using-class gf function-name keys)
    (apply #'%ensure-new-generic-function-using-class function-name keys)))

(defun ensure-generic-function (function-name &rest keys &key &allow-other-keys)
  (let* ((def (fboundp function-name)))
    (when (and def (not (typep def 'generic-function)))
      (cerror "Try to remove any global non-generic function or macro definition."
	      (make-condition 'simple-program-error :format-control "The function ~s is defined as something other than a generic function." :format-arguments (list function-name)))
      (fmakunbound function-name)
      (setq def nil))
    (apply #'%ensure-generic-function-using-class def function-name keys)))


(defun %ensure-new-generic-function-using-class
    (function-name &rest keys &key
		   (generic-function-class *standard-generic-function-class* gfc-p)
                   &allow-other-keys)
  (declare (dynamic-extent keys))
  (disable-clos-optimizations 'ensure-generic-function function-name)
  (when gfc-p
    (if (symbolp generic-function-class)
      (setq generic-function-class (find-class generic-function-class)))
    (unless (subtypep generic-function-class *standard-generic-function-class*)
      (error "~s is not a subtype of ~s" generic-function-class *generic-function-class*))
    (remf keys :generic-function-class))
  (let* ((gf (apply #'%make-gf-instance generic-function-class keys)))
    (unless (eq (%gf-method-combination gf) *standard-method-combination*)
      (register-gf-method-combination gf (%gf-method-combination gf)))
    (setf (sgf.name gf) (getf keys :name function-name))
    (setf (fdefinition function-name) gf)))

(defun %ensure-existing-generic-function-using-class
    (gf function-name &key
	(generic-function-class *standard-generic-function-class* gfc-p)
	(method-combination *standard-method-combination* mcomb-p)
	(method-class *standard-method-class* mclass-p)
	(argument-precedence-order nil apo-p)
	declarations
	(lambda-list nil ll-p)
	name)
  (disable-clos-optimizations 'ensure-generic-function function-name)
  (when gfc-p
    (if (symbolp generic-function-class)
      (setq generic-function-class (find-class generic-function-class)))
    (unless (subtypep generic-function-class *standard-generic-function-class*)
      (error "~s is not a subtype of ~s" generic-function-class *standard-generic-function-class*)))
  (when mcomb-p
    (unless (typep method-combination 'method-combination)
      (report-bad-arg method-combination 'method-combination)))
  (when mclass-p
    (if (symbolp method-class)
      (setq method-class (find-class method-class)))
    (unless (subtypep method-class *method-class*)
      (error "~s is not a subtype of ~s." method-class *method-class*)))
  (when declarations
    (unless (list-length declarations)
      (error "~s is not a proper list" declarations)))
  ;; Fix APO, lambda-list
  (if apo-p
    (if (not ll-p)
      (error "Cannot specify ~s without specifying ~s" :argument-precedence-order
	     :lambda-list)))
  (let* ((old-mc (sgf.method-combination gf)))
    (unless (eq old-mc method-combination)
      (unless (eq old-mc *standard-method-combination*)
	(unregister-gf-method-combination gf method-combination))))
    (setf (sgf.name gf) (or name function-name)
	  (sgf.decls gf) declarations
	  (sgf.method-class gf) method-class
	  (sgf.method-combination gf) method-combination)
    (unless (eq method-combination *standard-method-combination*)
      (register-gf-method-combination gf method-combination))
    (when ll-p
      (if apo-p
        (set-gf-arg-info gf :lambda-list lambda-list
                         :argument-precedence-order argument-precedence-order)
        (set-gf-arg-info gf :lambda-list lambda-list)))
    (setf (fdefinition function-name) gf))

(defun canonicalize-specializers (specializers &optional (copy t))
  (flet ((canonicalize-specializer (spec)
           (if (specializer-p spec)
             spec
             (if (symbolp spec)
               (find-class spec)
               (if (and (consp spec)
                        (eq (car spec) 'eql)
                        (consp (cdr spec))
                        (null (cddr spec)))
                 (intern-eql-specializer (cadr spec))
                 (error "Unknown specializer form ~s" spec))))))
    (if (and (not copy)
             (dolist (s specializers t)
               (unless (specializer-p s) (return nil))))
      specializers
      (mapcar #'canonicalize-specializer specializers))))

(defparameter *sealed-clos-world* nil "When true, class and method definition -at least - are disallowed.")

(defun ensure-method (name specializers &rest keys &key (documentation nil doc-p) qualifiers
                           &allow-other-keys)
  (declare (dynamic-extent keys))
  (if *sealed-clos-world*
    (error "Method (re)definition is not allowed in this environment.")
    (progn
      (setq specializers (canonicalize-specializers specializers))
      (let* ((gf (ensure-generic-function name))
             (method (apply #'%make-method-instance
                            (%gf-method-class gf)
                            :name name
                            :specializers specializers
                            keys))
             (old-method (when (%gf-methods gf)
                           (ignore-errors
                             (find-method gf qualifiers specializers nil)))))

        (%add-method gf method)
        (when (and doc-p *save-doc-strings*)
          (set-documentation method t documentation))
        (when old-method (%move-method-encapsulations-maybe old-method method))
        method))))


(defun %anonymous-method (function specializers qualifiers  lambda-list &optional documentation
                                   &aux name method-class)
  (let ((inner-function (closure-function function)))
    (unless (%method-function-p inner-function)
      (report-bad-arg inner-function 'method-function))   ; Well, I suppose we'll have to shoot you.
    (unless (eq inner-function function)   ; must be closed over
      (copy-method-function-bits inner-function function))
    (setq name (function-name inner-function))
    (if (typep name 'standard-method)     ; method-function already installed.
      (setq name (%method-name name)))
    (setq method-class *standard-method-class*)
    (unless (memq *standard-method-class* (or (%class.cpl method-class)
                                              (%class.cpl (update-class  method-class t))))
      (%badarg method-class 'standard-method))
    #|
    (unless (member qualifiers '(() (:before) (:after) (:around)) :test #'equal)
    (report-bad-arg qualifiers))
    ||#
    (setq specializers (mapcar #'(lambda (s)
                                   (or (and (consp s)
                                            (eq (%car s) 'eql)
                                            (consp (%cdr s))
                                            (null (%cddr s))
                                            (intern-eql-specializer (%cadr s)))
                                       (and (specializer-p s) s)
                                       (find-class s)))
                               specializers))
    (let ((method (%make-method-instance method-class
                      :name name
		      :lambda-list lambda-list
                      :qualifiers qualifiers
                      :specializers specializers
                      :function function)))
      (lfun-name inner-function method)
      (when documentation
        (set-documentation method t documentation))
      method)))

	   
(defun check-defmethod-congruency (gf method)
  (unless (congruent-lambda-lists-p gf method)
    (cerror (format nil
		    "Remove ~d method~:p from the generic-function and change its lambda list."
		    (length (%gf-methods gf)))
	    "Lambda list of method ~S ~%~
is incompatible with that of the generic function ~S.~%~
Method's lambda-list : ~s~%~
Generic-function's   : ~s~%" method (or (generic-function-name gf) gf) (flatten-method-lambda-list (%method-lambda-list method)) (generic-function-lambda-list gf))
    (loop
      (let ((methods (%gf-methods gf)))
        (if methods
          (remove-method gf (car methods))
          (return))))
    (%set-defgeneric-keys gf nil)
    (inner-lfun-bits gf (%ilogior (%ilsl $lfbits-gfn-bit 1)
                                  (%ilogand $lfbits-args-mask
                                            (lfun-bits (%method-function method))))))
  gf)



(defun %method-function-method (method-function)
  (setq method-function
        (closure-function
         (find-unencapsulated-definition method-function)))
  (setq method-function (require-type method-function 'method-function))
  (lfun-name method-function))

(defstatic %defgeneric-methods% (make-hash-table :test 'eq :weak t))

(defun %defgeneric-methods (gf)
   (gethash gf %defgeneric-methods%))

(defun %set-defgeneric-methods (gf &rest methods)
   (if methods
     (setf (gethash gf %defgeneric-methods%) methods)
     (remhash gf %defgeneric-methods%)))

(defun %defgeneric-keys (gf)
  (%gf-dispatch-table-keyvect (%gf-dispatch-table gf)))

(defun %set-defgeneric-keys (gf keyvect)
  (setf (%gf-dispatch-table-keyvect (%gf-dispatch-table gf)) keyvect))

(defun congruent-lfbits-p (gbits mbits)
  (and (eq (ldb $lfbits-numreq gbits) (ldb $lfbits-numreq mbits))
       (eq (ldb $lfbits-numopt gbits) (ldb $lfbits-numopt mbits))
       (eq (or (logbitp $lfbits-rest-bit gbits)
               (logbitp $lfbits-restv-bit gbits)
               (logbitp $lfbits-keys-bit gbits))
           (or (logbitp $lfbits-rest-bit mbits)
               (logbitp $lfbits-restv-bit mbits)
               (logbitp $lfbits-keys-bit mbits)))))

(defun congruent-lambda-lists-p (gf method &optional
                                    error-p gbits mbits gkeys)
  (unless gbits (setq gbits (inner-lfun-bits gf)))
  (unless mbits (setq mbits (encode-lambda-list (%method-lambda-list method))))
  (and (congruent-lfbits-p gbits mbits)
       (or (and (or (logbitp $lfbits-rest-bit mbits)
                    (logbitp $lfbits-restv-bit mbits))
                (not (logbitp $lfbits-keys-bit mbits)))
           (logbitp $lfbits-aok-bit mbits)
           (logbitp $lfbits-aok-bit gbits)
           (progn
             (unless gkeys (setq gkeys (%defgeneric-keys gf)))
             (or (null gkeys)
                 (eql 0 (length gkeys))
                 (let ((mkeys (lfun-keyvect
                               (%inner-method-function method))))
                   (dovector (key gkeys t)
                     (unless (find key mkeys :test 'eq)
                       (if error-p
                         (error "~s does not specify keys: ~s" method gkeys))
                       (return nil)))))))))

(defun %add-method (gf method)
  (%add-standard-method-to-standard-gf gf method))



(defun %add-standard-method-to-standard-gf (gfn method)
  (when (%method-gf method)
    (error "~s is already a method of ~s." method (%method-gf method)))
  (set-gf-arg-info gfn :new-method method)
  (let* ((dt (%gf-dispatch-table gfn))
	 (methods (sgf.methods gfn))
	 (specializers (%method-specializers method))
	 (qualifiers (%method-qualifiers method)))
    (remove-obsoleted-combined-methods method dt specializers)
    (apply #'invalidate-initargs-vector-for-gf gfn specializers)
    (dolist (m methods)
      (when (and (equal specializers (%method-specializers m))
		 (equal qualifiers (%method-qualifiers m)))
	(remove-method gfn m)
	;; There can be at most one match
	(return)))
    (push method (sgf.methods gfn))
    (setf (%gf-dispatch-table-methods dt) (sgf.methods gfn))
    (setf (%method-gf method) gfn)
    (%add-direct-methods method)
    (compute-dcode gfn dt)
    (when (sgf.dependents gfn)
      (map-dependents gfn #'(lambda (d)
			      (update-dependent gfn d 'add-method method)))))
  gfn)

(defstatic *standard-kernel-method-class* nil)

(defun methods-congruent-p (m1 m2)
  (when (and (standard-method-p m1)(standard-method-p m2))
    (when (equal (%method-qualifiers m1) (%method-qualifiers m2))
      (let ((specs (%method-specializers m1)))
        (dolist (msp (%method-specializers m2) t)
          (let ((spec (%pop specs)))
            (unless (eq msp spec)
              (return nil))))))))

(defvar *maintain-class-direct-methods* nil)



;;; CAR is an EQL hash table for objects whose identity is not used by EQL
;;; (numbers and macptrs)
;;; CDR is a weak EQ hash table for other objects.
(defvar *eql-methods-hashes* (cons (make-hash-table :test 'eql)
                                   (make-hash-table :test 'eq :weak :key)))

(defun eql-methods-cell (object &optional addp)
  (let ((hashes *eql-methods-hashes*))
    (without-interrupts
     (let* ((hash (cond
                   ((or (typep object 'number)
                        (typep object 'macptr))
                    (car hashes))
                   (t (cdr hashes))))
            (cell (gethash object hash)))
       (when (and (null cell) addp)
         (setf (gethash object hash) (setq cell (cons nil nil))))
       cell))))




(defun map-classes (function)
  (with-hash-table-iterator (m %find-classes%)
    (loop
      (multiple-value-bind (found name cell) (m)
        (declare (optimize speed) (type class-cell cell))
        (unless found (return))
        (when cell
          (funcall function name (class-cell-class cell)))))))



(defun %class-primary-slot-accessor-info (class accessor-or-slot-name &optional create?)
  (let ((info-list (%class-get class '%class-primary-slot-accessor-info)))
    (or (car (member accessor-or-slot-name info-list
                     :key #'(lambda (x) (%slot-accessor-info.accessor x))))
        (and create?
             (let ((info (%cons-slot-accessor-info class accessor-or-slot-name)))
               (setf (%class-get class '%class-primary-slot-accessor-info)
                     (cons info info-list))
               info)))))

;;; Clear the %class.primary-slot-accessor-info for an added or
;;; removed method's specializers
(defun clear-accessor-method-offsets (gf method)
  (when (or (typep method 'standard-accessor-method)
            (member 'standard-accessor-method
                    (%gf-methods gf)
                    :test #'(lambda (sam meth)
                             (declare (ignore sam))
                             (typep meth 'standard-accessor-method))))
    (labels ((clear-class (class)
               (when (typep class 'standard-class)
                 (let ((info (%class-primary-slot-accessor-info class gf)))
                   (when info
                     (setf (%slot-accessor-info.offset info) nil)))
                 (mapc #'clear-class (%class.subclasses class)))))
      (declare (dynamic-extent #'clear-class))
      (mapc #'clear-class (%method-specializers method)))))

;;; Remove methods which specialize on a sub-class of method's
;;; specializers from the generic-function dispatch-table dt.
(defun remove-obsoleted-combined-methods (method &optional dt
                                                 (specializers (%method-specializers method)))
  (without-interrupts
   (unless dt
     (let ((gf (%method-gf method)))
       (when gf (setq dt (%gf-dispatch-table gf)))))
   (when dt
     (if specializers
       (let* ((argnum (%gf-dispatch-table-argnum dt)))
         (when (>= argnum 0)
           (let ((class (nth argnum specializers))
                 (size (%gf-dispatch-table-size dt))
                 (index 0))
             (clear-accessor-method-offsets (%gf-dispatch-table-gf dt) method)
             (if (typep class 'eql-specializer)
                 (setq class (class-of (eql-specializer-object class))))
             (while (%i< index size)
               (let* ((wrapper (%gf-dispatch-table-ref dt index))
                      hash-index-0?
                      (cpl (and wrapper
                                (not (setq hash-index-0?
                                           (eql 0 (%wrapper-hash-index wrapper))))
                                (%inited-class-cpl
                                 (require-type (%wrapper-class wrapper) 'class)))))
                 (when (or hash-index-0? (and cpl (cpl-index class cpl)))
                   (setf (%gf-dispatch-table-ref dt index) *obsolete-wrapper*
                         (%gf-dispatch-table-ref dt (%i+ index 1)) *gf-dispatch-bug*))
                 (setq index (%i+ index 2)))))))
       (setf (%gf-dispatch-table-ref dt 1) nil)))))   ; clear 0-arg gf cm

;;; SETQ'd below after the GF's exist.
(defvar *initialization-invalidation-alist* nil)

;;; Called by %add-method, %remove-method
(defun invalidate-initargs-vector-for-gf (gf &optional first-specializer &rest other-specializers)
  (declare (ignore other-specializers))
  (when (and first-specializer (typep first-specializer 'class)) ; no eql methods or gfs with no specializers need apply
    (let ((indices (cdr (assq gf *initialization-invalidation-alist*))))
      (when indices
        (labels ((invalidate (class indices)
                   (when (std-class-p class) ; catch the class named T
                     (dolist (index indices)
                       (setf (standard-instance-instance-location-access class index) nil)))
                   (dolist (subclass (%class.subclasses class))
                     (invalidate subclass indices))))
          (invalidate first-specializer indices))))))

;;; Return two values:
;;; 1) the index of the first non-T specializer of method, or NIL if
;;;    all the specializers are T or only the first one is T
;;; 2) the index of the first non-T specializer
(defun multi-method-index (method &aux (i 0) index)
  (dolist (s (%method.specializers method) (values nil index))
    (unless (eq s *t-class*)
      (unless index (setq index i))
      (unless (eql i 0) (return (values index index))))
    (incf i)))

(defun %remove-standard-method-from-containing-gf (method)
  (setq method (require-type method 'standard-method))
  (let ((gf (%method-gf method)))
    (when gf
      (let* ((dt (%gf-dispatch-table gf))
	     (methods (sgf.methods gf)))
        (setf (%method-gf method) nil)
	(setq methods (nremove method methods))
        (setf (%gf-dispatch-table-methods dt) methods
	      (sgf.methods gf) methods)
        (%remove-direct-methods method)
        (remove-obsoleted-combined-methods method dt)
        (apply #'invalidate-initargs-vector-for-gf gf (%method-specializers method))
        (compute-dcode gf dt)
	(when (sgf.dependents gf)
	  (map-dependents
	   gf
	   #'(lambda (d)
	       (update-dependent gf d 'remove-method method)))))))
  method)


(defvar *reader-method-function-proto*
  #'(lambda (instance)
      (slot-value instance 'x)))


(defvar *writer-method-function-proto*
  #'(lambda (new instance)
      (set-slot-value instance 'x new)))

(defun dcode-for-gf (gf dcode)
  (if *uniquify-dcode*
    (let ((new-dcode (%copy-function dcode)))
      (lfun-name new-dcode (list (lfun-name dcode) (lfun-name gf)))
      new-dcode)
    dcode))

(defstatic *non-dt-dcode-functions* () "List of functions which return a dcode function for the GF which is their argument.  The dcode functions will be caled with all of the incoming arguments.")

(defun non-dt-dcode-function (gf)
  (dolist (f *non-dt-dcode-functions*)
    (let* ((dcode (funcall f gf)))
      (when dcode (return dcode)))))

(defun compute-dcode (gf &optional dt)
  (setq gf (require-type gf 'standard-generic-function))
  (unless dt (setq dt (%gf-dispatch-table gf)))
  (let* ((methods (%gf-dispatch-table-methods dt))
         (bits (inner-lfun-bits gf))
         (nreq (ldb $lfbits-numreq bits))
         (0-args? (eql 0 nreq))
         (other-args? (or (not (eql 0 (ldb $lfbits-numopt bits)))
                          (logbitp $lfbits-rest-bit bits)
                          (logbitp $lfbits-restv-bit bits)
                          (logbitp $lfbits-keys-bit bits)
                          (logbitp $lfbits-aok-bit bits)))
         multi-method-index 
	 min-index)
    (when methods
      (unless 0-args?
        (dolist (m methods)
          (multiple-value-bind (mm-index index) (multi-method-index m)
            (when mm-index
              (if (or (null multi-method-index) (< mm-index multi-method-index))
                (setq multi-method-index mm-index)))
            (when index
              (if (or (null min-index) (< index min-index))
                (setq min-index index))))))
      (let* ((non-dt (non-dt-dcode-function gf))
             (dcode (or non-dt
                        (if 0-args?
                          #'%%0-arg-dcode
                          (or (if multi-method-index
                                #'%%nth-arg-dcode)
                              (if (null other-args?)
                                (if (eql nreq 1)
                                  #'%%one-arg-dcode
                                  (if (eql nreq 2)
                                    #'%%1st-two-arg-dcode
                                    #'%%1st-arg-dcode))
                                #'%%1st-arg-dcode))))))
        (setq multi-method-index
              (if multi-method-index
                (if min-index
                  (min multi-method-index min-index)
                  multi-method-index)
                0))
        (let* ((old-dcode (%gf-dcode (find-unencapsulated-definition gf))))
          (when (or non-dt
		    (neq dcode old-dcode)
                    (neq multi-method-index (%gf-dispatch-table-argnum dt)))
            (clear-gf-dispatch-table dt)
            (setf (%gf-dispatch-table-argnum dt) multi-method-index)
            (if (function-encapsulated-p gf)
	      (%set-encapsulated-gf-dcode gf dcode)
	      (setf (%gf-dcode gf) dcode))))
        (values dcode multi-method-index)))))

(defun inherits-from-standard-generic-function-p (class)
  (memq *standard-generic-function-class*
        (%inited-class-cpl (require-type class 'class))))

;;;;;;;;;;; The type system needs to get wedged into CLOS fairly early ;;;;;;;


;;; Could check for duplicates, but not really worth it.  They're all
;;; allocated here
(defun new-type-class (name)
  (let* ((class (%istruct 
                 'type-class 
                 name
                 #'missing-type-method
                 nil
                 nil
                 #'(lambda (x y) (hierarchical-union2 x y))
                 nil
                 #'(lambda (x y) (hierarchical-intersection2 x y))
                 nil
                 #'missing-type-method
                 nil
                 #'missing-type-method)))
    (push (cons name class) *type-classes*)
    class))

;; There are ultimately about a dozen entries on this alist.
(defvar *type-classes* nil)
(declaim (special *wild-type* *empty-type* *universal-type*))
(defvar *type-kind-info* (make-hash-table :test #'equal))

(defun info-type-kind (name)
  (gethash name *type-kind-info*))

(defun (setf info-type-kind) (val name)
  (if val
    (setf (gethash name *type-kind-info*) val)
    (remhash name *type-kind-info*)))

(defun missing-type-method (&rest foo)
  (error "Missing type method for ~S" foo))
          
(new-type-class 'values)
(new-type-class 'function)
(new-type-class 'constant)
(new-type-class 'wild)
(new-type-class 'bottom)
(new-type-class 'named)
(new-type-class 'hairy)
(new-type-class 'unknown)
(new-type-class 'number)
(new-type-class 'array)
(new-type-class 'member)
(new-type-class 'union)
(new-type-class 'foreign)
(new-type-class 'cons)
(new-type-class 'intersection)
(new-type-class 'negation)
(defparameter *class-type-class* (new-type-class 'class))




                        
;;;;;;;;;;;;;;;;;;;;;;;;  Instances and classes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declaim (inline non-standard-instance-class-wrapper))

(defun non-standard-instance-class-wrapper (instance)
  (let* ((typecode (typecode instance)))
    (declare (type (unsigned-byte 8) typecode))
    (cond ((eql typecode target::subtag-struct)
           (%class.own-wrapper
            (class-cell-class (car (%svref instance 0)))))
          ((eql typecode target::subtag-istruct)
           (istruct-cell-info (%svref instance 0)))
          ((eql typecode target::subtag-basic-stream)
           (basic-stream.wrapper instance))
          ((typep instance 'funcallable-standard-object)
           (gf.instance.class-wrapper instance))
          ((eql typecode target::subtag-macptr) (foreign-instance-class-wrapper instance))
          (t (%class.own-wrapper (class-of instance))))))

(defun instance-class-wrapper (instance)
  (if (= (typecode instance)  target::subtag-instance)
    (instance.class-wrapper instance)
    (non-standard-instance-class-wrapper instance)))


(defun class-cell-typep (form class-cell)
  (let* ((typecode (typecode form))
         (wrapper (cond ((= typecode target::subtag-instance)
                         (instance.class-wrapper form))
                        ((= typecode target::subtag-basic-stream)
                         (basic-stream.wrapper form))
                        (t (non-standard-instance-class-wrapper form)))))
    (declare (type (unsigned-byte 8) typecode))
    (loop
        (let ((class (class-cell-class class-cell)))
          (if class
            (let* ((ordinal (%class-ordinal class))
                   (bits (or (%wrapper-cpl-bits wrapper)
                             (make-cpl-bits (%inited-class-cpl (%wrapper-class wrapper))))))
              (declare (fixnum ordinal))
              (return
                (if bits
                  (locally (declare (simple-bit-vector bits)
                                    (optimize (speed 3) (safety 0)))
                    (if (< ordinal (length bits))
                      (not (eql 0 (sbit bits ordinal))))))))
            (let* ((name (class-cell-name class-cell))
                   (new-cell (find-class-cell name nil)))
              (unless
                  (if (and new-cell (not (eq class-cell new-cell)))
                    (setq class-cell new-cell class (class-cell-class class-cell))
                    (return (typep form name))))))))))


(%fhave 'std-instance-class-cell-typep #'class-cell-typep)



(defun %require-type-class-cell (arg class-cell)
  (if (class-cell-typep arg class-cell)
    arg
    (%kernel-restart $xwrongtype arg (class-cell-class class-cell))))




(defun find-class (name &optional (errorp t) environment)
  (declare (optimize speed))
  (let* ((cell (find-class-cell name nil)))
    (declare (type class-cell cell))
    (or (and cell (class-cell-class cell))
        (let ((defenv (and environment (definition-environment environment))))
          (when defenv
            (dolist (class (defenv.classes defenv))
              (when (eq name (%class.name class))
                (return class)))))
        (when (or errorp (not (symbolp name)))
          (cerror "Try finding the class again"
                  "Class named ~S not found." name)
          (find-class name errorp environment)))))

(fset 'pessimize-make-instance-for-class-name ;; redefined later
      (qlfun bootstrapping-pessimize-make-instance-for-class-name (name) name))

(defun update-class-proper-names (name old-class new-class)
  (when name
    (pessimize-make-instance-for-class-name name))
  (when (and old-class
             (not (eq old-class new-class))
             (eq (%class-proper-name old-class) name))
    (setf (%class-proper-name old-class) nil))
  (when (and new-class (eq (%class-name new-class) name))
    (setf (%class-proper-name new-class) name)))


(fset 'set-find-class (nfunction bootstrapping-set-find-class ; redefined below
                                 (lambda (name class)
                                   (clear-type-cache)
                                   (let* ((cell (find-class-cell name t))
                                          (old-class (class-cell-class cell)))
                                     (when class
                                       (if (eq name (%class.name class))
                                         (setf (info-type-kind name) :instance)))
                                     (setf (class-cell-class cell) class)
                                     (update-class-proper-names name old-class class)
                                     class))))


;;; bootstrapping definition. real one is in "sysutils.lisp"
(fset 'built-in-type-p (nfunction boostrapping-built-in-typep-p
                                  (lambda (name)
                                    (or (type-predicate name)
                                        (memq name '(signed-byte unsigned-byte mod 
                                                     values satisfies member and or not))
                                        (typep (find-class name nil) 'built-in-class)))))



(defun %compile-time-defclass (name environment)
  (note-type-info name 'class environment)
  (unless (find-class name nil environment)
    (let ((defenv (definition-environment environment)))
      (when defenv
        (push (make-instance 'compile-time-class :name name)
              (defenv.classes defenv)))))
  name)

(eval-when (:compile-toplevel :execute)
(declaim (inline standard-instance-p))
)




(defun standard-instance-p (i)
  (eq (typecode i) target::subtag-instance))

(defun check-setf-find-class-protected-class (old-class new-class name)
  (when (and (standard-instance-p old-class)
	     (%class-kernel-p old-class)
	     *warn-if-redefine-kernel*
	     ;; EQL might be necessary on foreign classes
	     (not (eq new-class old-class)))
    (cerror "Setf (FIND-CLASS ~s) to the new class."
	    "The class name ~s currently denotes the class ~s that
marked as being a critical part of the system; an attempt is being made
to replace that class with ~s" name old-class new-class)
    (setf (%class-kernel-p old-class) nil)))


(queue-fixup
 (defun set-find-class (name class)
   (setq name (require-type name 'symbol))
   (let* ((cell (find-class-cell name t))
          (old-class (class-cell-class cell)))
     (declare (type class-cell cell))
     (when old-class
       (when (eq (%class.name old-class) name)
         (setf (info-type-kind name) nil)
         (clear-type-cache))
       (when *warn-if-redefine-kernel*
         (check-setf-find-class-protected-class old-class class name)))
     (when (null class)
       (when cell
         (setf (class-cell-class cell) nil))
       (update-class-proper-names name old-class class)
       (return-from set-find-class nil))
     (setq class (require-type class 'class))
     (when (built-in-type-p name)
       (unless (eq (class-cell-class cell) class)
         (error "Cannot redefine built-in type name ~S" name)))
     (when (eq (%class.name class) name)
       (when (%deftype-expander name)
         (cerror "set ~S anyway, removing the ~*~S definition"
                 "Cannot set ~S because type ~S is already defined by ~S"
                 `(find-class ',name) name 'deftype)
         (%deftype name nil nil))
       (setf (info-type-kind name) :instance))
     (update-class-proper-names name old-class class)
     (setf (class-cell-class cell) class)))
 )                                      ; end of queue-fixup



#||
; This tended to cluster entries in gf dispatch tables too much.
(defvar *class-wrapper-hash-index* 0)
(defun new-class-wrapper-hash-index ()
  (let ((index *class-wrapper-hash-index*))
    (setq *class-wrapper-hash-index*
        (if (< index (- most-positive-fixnum 2))
          ; Increment by two longwords.  This is important!
          ; The dispatch code will break if you change this.
          (%i+ index 3)                 ; '3 = 24 bytes = 6 longwords in lap.
          1))))
||#

(defglobal *next-class-ordinal* 0)

(defun %next-class-ordinal ()
  (%atomic-incf-node 1 '*next-class-ordinal* target::symbol.vcell))

;;; Initialized after built-in-class is made
(defvar *built-in-class-wrapper* nil)

(defun make-class-ctype (class)
  (%istruct 'class-ctype *class-type-class* nil class nil))

(defun %class-ordinal (class &optional no-error)
  (if (standard-instance-p class)
    (instance.hash class)
    (if (typep class 'macptr)
      (foreign-class-ordinal class)
      (unless no-error
        (error "Can't determine ordinal of ~s" class)))))

(defun (setf %class-ordinal) (new class &optional no-error)
  (if (standard-instance-p class)
    (setf (instance.hash class) new)
    (if (typep class 'macptr)
      (setf (foreign-class-ordinal class) new)
      (unless no-error
        (error "Can't set ordinal of class ~s to ~s" class new)))))


(defvar *t-class* (let* ((class (%cons-built-in-class 't)))
                    (setf (instance.hash class) 0)
                    (let* ((cpl (list class))
                           (wrapper (%cons-wrapper class (new-class-wrapper-hash-index))))
                      (setf (%class.cpl class) cpl)
                      (setf (%wrapper-cpl wrapper) cpl
                            (%class.own-wrapper class) wrapper
                            (%wrapper-cpl-bits wrapper)
                            (let* ((bv (make-array 1 :element-type 'bit)))
                                     (setf (aref bv 0) 1)
                                     bv))
                      (setf (%class.ctype class) (make-class-ctype class))
                      (setf (find-class 't) class)
                      class)))

(defun compute-cpl (class)
  (flet ((%real-class-cpl (class)
           (or (%class-cpl class)
               (compute-cpl class))))
    (let* ((predecessors (list (list class))) candidates cpl)
      (dolist (sup (%class-direct-superclasses class))
        (when (symbolp sup) (report-bad-arg sup 'class))
        (dolist (sup (%real-class-cpl sup))
          (unless (assq sup predecessors) (push (list sup) predecessors))))
      (labels ((compute-predecessors (class table)
                 (dolist (sup (%class-direct-superclasses class) table)
                   (compute-predecessors sup table)
                   ;(push class (cdr (assq sup table)))
                   (let ((a (assq sup table))) (%rplacd a (cons class (%cdr a))))
                   (setq class sup))))
        (compute-predecessors class predecessors))
      (setq candidates (list (assq class predecessors)))
      (while predecessors
        (dolist (c candidates (error "Inconsistent superclasses for ~d" class))
          (when (null (%cdr c))
            (setq predecessors (nremove c predecessors))
            (dolist (p predecessors) (%rplacd p (nremove (%car c) (%cdr p))))
            (setq candidates (nremove c candidates))
            (setq cpl (%rplacd c cpl))
            (dolist (sup (%class-direct-superclasses (%car c)))
              (when (setq c (assq sup predecessors)) (push c candidates)))
            (return))))
      (setq cpl (nreverse cpl))
      (do* ((tail cpl (%cdr tail))
            sup-cpl)
           ((null (setq sup-cpl (and (cdr tail) (%real-class-cpl (cadr tail))))))
        (when (equal (%cdr tail) sup-cpl)
          (setf (%cdr tail) sup-cpl)
          (return)))
      cpl)))

(defun make-cpl-bits (cpl)
  (declare (optimize speed))
  (when cpl  
    (let* ((max 0))
      (declare (fixnum max))
      (dolist (class cpl)
        (let* ((ordinal (%class-ordinal class)))
          (declare (fixnum ordinal))
          (when (> ordinal max)
            (setq max ordinal))))
      (let* ((bits (make-array (the fixnum (1+ max)) :element-type 'bit)))
        (dolist (class cpl bits)
          (let* ((ordinal (%class-ordinal class)))
            (setf (sbit bits ordinal) 1)))))))

          
(defun make-built-in-class (name &rest supers)
  (if (null supers)
    (setq supers (list *t-class*))
    (do ((supers supers (%cdr supers)))
        ((null supers))
      (when (symbolp (%car supers)) (%rplaca supers (find-class (%car supers))))))
  (let ((class (find-class name nil)))
    (if class
      (progn
        ;Must be debugging.  Give a try at redefinition...
        (dolist (sup (%class.local-supers class))
          (setf (%class.subclasses sup) (nremove class (%class.subclasses sup)))))
      (progn
        (setq class (%cons-built-in-class name))
        (setf (instance.hash class) (%next-class-ordinal))))
    (dolist (sup supers)
      (setf (%class.subclasses sup) (cons class (%class.subclasses sup))))
    (setf (%class.local-supers class) supers)
    (let* ((wrapper (%cons-wrapper class (new-class-wrapper-hash-index)))
           (cpl (compute-cpl class)))
      (setf (%class.cpl class) cpl)
      (setf (%class.own-wrapper class) wrapper)
      (setf (%wrapper-cpl wrapper) cpl
            (%wrapper-cpl-bits wrapper) (make-cpl-bits cpl)
            (%wrapper-class-ordinal wrapper) (%class-ordinal class)))
    (setf (%class.ctype class)  (make-class-ctype class))
    (setf (find-class name) class)
    (dolist (sub (%class.subclasses class))   ; Only non-nil if redefining
      ;Recompute the cpl.
      (apply #'make-built-in-class (%class.name sub) (%class.local-supers sub)))
    class))

(defun make-istruct-class (name &rest supers)
  (let* ((class (apply #'make-built-in-class name supers))
         (cell (register-istruct-cell name)))
    (setf (istruct-cell-info cell) (%class.own-wrapper class))
    class))

;;; This will be filled in below.  Need it defined now as it goes in
;;; the instance.class-wrapper of all the classes that STANDARD-CLASS
;;; inherits from.
(defstatic *standard-class-wrapper* 
  (%cons-wrapper 'standard-class))

(defun make-standard-class (name &rest supers)
  (make-class name *standard-class-wrapper* supers))

(defun make-class (name metaclass-wrapper supers &optional own-wrapper)
  (let ((class (if (find-class name nil)
                 (error "Attempt to remake standard class ~s" name)
                 (%cons-standard-class name metaclass-wrapper))))
    (setf (instance.hash class) (%next-class-ordinal))
    (if (null supers)
      (setq supers (list *standard-class-class*))
      (do ((supers supers (cdr supers))
           sup)
          ((null supers))
        (setq sup (%car supers))
        (if (symbolp sup) (setf (%car supers) (setq sup (find-class (%car supers)))))
        #+nil (unless (or (eq sup *t-class*) (std-class-p sup))
          (error "~a is not of type ~a" sup 'std-class))))
    (setf (%class.local-supers class) supers)
    (let ((cpl (compute-cpl class))
          (wrapper (if own-wrapper
                     (progn
                       (setf (%wrapper-class own-wrapper) class)
                       own-wrapper)
                     (%cons-wrapper class))))
      (setf (%class.cpl class) cpl
            (%wrapper-instance-slots wrapper) (vector)
            (%class.own-wrapper class) wrapper
            (%class.ctype class) (make-class-ctype class)
            (%class.slots class) nil
            (%wrapper-class-ordinal wrapper) (%class-ordinal class)
            (%wrapper-cpl wrapper) cpl
            (%wrapper-cpl-bits wrapper) (make-cpl-bits cpl)
            (find-class name) class
            )
      (dolist (sup supers)
        (setf (%class.subclasses sup) (cons class (%class.subclasses sup))))
      class)))





(defun standard-object-p (thing)
  ;; returns thing's class-wrapper or nil if it isn't a standard-object
  (if (standard-instance-p thing)
    (instance.class-wrapper thing)
    (if (typep thing 'macptr)
      (foreign-instance-class-wrapper thing))))


(defun std-class-p (class)
  ;; (typep class 'std-class)
  ;; but works at bootstrapping time as well
  (let ((wrapper (standard-object-p class)))
    (and wrapper
         (or (eq wrapper *standard-class-wrapper*)
             (memq *std-class-class* (%inited-class-cpl (%wrapper-class wrapper) t))))))

(set-type-predicate 'std-class 'std-class-p)

(defun slots-class-p (class)
  (let ((wrapper (standard-object-p class)))
    (and wrapper
         (or (eq wrapper *slots-class-wrapper*)
             (memq *slots-class* (%inited-class-cpl (%wrapper-class wrapper) t))))))  

(set-type-predicate 'slots-class 'slots-class-p)

(defun specializer-p (thing)
  (memq *specializer-class* (%inited-class-cpl (class-of thing))))

(defstatic *standard-object-class* (make-standard-class 'standard-object *t-class*))

(defstatic *metaobject-class* (make-standard-class 'metaobject *standard-object-class*))

(defstatic *specializer-class* (make-standard-class 'specializer *metaobject-class*))
(defstatic *eql-specializer-class* (make-standard-class 'eql-specializer *specializer-class*))

(defstatic *standard-method-combination*
  (make-instance-vector
   (%class.own-wrapper
    (make-standard-class
     'standard-method-combination
     (make-standard-class 'method-combination *metaobject-class*)))
   1))


(defun eql-specializer-p (x)
  (memq *eql-specializer-class* (%inited-class-cpl (class-of x))))

(setf (type-predicate 'eql-specializer) 'eql-specializer-p)

;;; The *xxx-class-class* instances get slots near the end of this file.
(defstatic *class-class* (make-standard-class 'class *specializer-class*))

(defstatic *slots-class* (make-standard-class 'slots-class *class-class*))
(defstatic *slots-class-wrapper* (%class.own-wrapper *slots-class*))


;;; an implementation class that exists so that
;;; standard-class & funcallable-standard-class can have a common ancestor not
;;; shared by anybody but their subclasses.

(defstatic *std-class-class* (make-standard-class 'std-class *slots-class*))

;;; The class of all objects whose metaclass is standard-class. Yow.
(defstatic *standard-class-class* (make-standard-class 'standard-class *std-class-class*))
;;; Replace its wrapper and the circle is closed.
(setf (%class.own-wrapper *standard-class-class*) *standard-class-wrapper*
      (%wrapper-class *standard-class-wrapper*) *standard-class-class*
      (%wrapper-class-ordinal *standard-class-wrapper*) (%class-ordinal *standard-class-class*)
      (%wrapper-instance-slots *standard-class-wrapper*) (vector))

(defstatic *built-in-class-class* (make-standard-class 'built-in-class *class-class*))
(setf *built-in-class-wrapper* (%class.own-wrapper *built-in-class-class*)
      (instance.class-wrapper *t-class*) *built-in-class-wrapper*)

(defstatic *structure-class-class* (make-standard-class 'structure-class *slots-class*))
(defstatic *structure-class-wrapper* (%class.own-wrapper *structure-class-class*))
(defstatic *structure-object-class* 
  (make-class 'structure-object *structure-class-wrapper* (list *t-class*)))

(defstatic *forward-referenced-class-class*
  (make-standard-class 'forward-referenced-class *class-class*))

(defstatic *function-class* (make-built-in-class 'function))

#+arm-target
(make-built-in-class 'pseudofunction)

(defun alias-class (name class)
  (setf (find-class name) class
        (info-type-kind name) :instance)
  class)

;;;Right now, all functions are compiled.


(defstatic *compiled-function-class* *function-class*)
(alias-class 'compiled-function *compiled-function-class*)

(defstatic *compiled-lexical-closure-class* 
  (make-standard-class 'compiled-lexical-closure *function-class*))





(defstatic *funcallable-standard-class-class*
  (make-standard-class 'funcallable-standard-class *std-class-class*))

(defstatic *funcallable-standard-object-class*
  (make-class 'funcallable-standard-object
              (%class.own-wrapper *funcallable-standard-class-class*)
              (list *standard-object-class* *function-class*)))

(defstatic *generic-function-class*
  (make-class 'generic-function
              (%class.own-wrapper *funcallable-standard-class-class*)
              (list *metaobject-class* *funcallable-standard-object-class*)))
(setq *generic-function-class-wrapper* (%class.own-wrapper *generic-function-class*))

(defstatic *standard-generic-function-class*
  (make-class 'standard-generic-function
              (%class.own-wrapper *funcallable-standard-class-class*)
              (list *generic-function-class*)))
(setq *standard-generic-function-class-wrapper*
      (%class.own-wrapper *standard-generic-function-class*))

;;; *standard-method-class* is upgraded to a real class below
(defstatic *method-class* (make-standard-class 'method *metaobject-class*))
(defstatic *standard-method-class* (make-standard-class 'standard-method *method-class*))
(defstatic *accessor-method-class* (make-standard-class 'standard-accessor-method *standard-method-class*))
(defstatic *standard-reader-method-class* (make-standard-class 'standard-reader-method *accessor-method-class*))
(defstatic *standard-writer-method-class* (make-standard-class 'standard-writer-method *accessor-method-class*))
(defstatic *method-function-class* (make-standard-class 'method-function *function-class*))


(defstatic *combined-method-class* (make-standard-class 'combined-method *function-class*))

(defstatic *slot-definition-class* (make-standard-class 'slot-definition *metaobject-class*))
(defstatic direct-slot-definition-class (make-standard-class 'direct-slot-definition
                                                           *slot-definition-class*))
(defstatic effective-slot-definition-class (make-standard-class 'effective-slot-definition
                                                              *slot-definition-class*))
(defstatic *standard-slot-definition-class* (make-standard-class 'standard-slot-definition
                                                                 *slot-definition-class*))
(defstatic *standard-direct-slot-definition-class* (make-class
                                                    'standard-direct-slot-definition
                                                    *standard-class-wrapper*
                                                    (list
                                                     *standard-slot-definition-class*
                                                     direct-slot-definition-class)))

(defstatic *standard-effective-slot-definition-class* (make-class
                                                    'standard-effective-slot-definition
                                                    *standard-class-wrapper*
                                                    (list
                                                     *standard-slot-definition-class*
                                                     effective-slot-definition-class)
))

(defstatic *standard-effective-slot-definition-class-wrapper*
  (%class.own-wrapper *standard-effective-slot-definition-class*))



(defun constantly (x)
  "Return a function that always returns VALUE."
  (cond ((null x) #'false)
        ((eq x t) #'true)        
        (t
         (let* ((f (%copy-function #'constant-ref)))
           (set-nth-immediate f 1 x)
           f))))


  

(let ((*dont-find-class-optimize* t)
      (ordinal-type-class-alist ())
      (ordinal-type-class-alist-lock (make-lock)))

  (declare (optimize speed)) ;; make sure everything gets inlined that needs to be.

;; The built-in classes.
  (defstatic *array-class* (make-built-in-class 'array))
  (defstatic *character-class* (make-built-in-class 'character))
  (make-built-in-class 'number)
  (make-built-in-class 'sequence)
  (defstatic *symbol-class* (make-built-in-class 'symbol))
  (defstatic *immediate-class* (make-built-in-class 'immediate)) ; Random immediate
  ;; Random uvectors - these are NOT class of all things represented by a uvector
  ;;type. Just random uvectors which don't fit anywhere else.
  (make-built-in-class 'ivector)        ; unknown ivector
  (make-built-in-class 'gvector)        ; unknown gvector
  (defstatic *istruct-class* (make-built-in-class 'internal-structure)) ; unknown istruct
  
  (defstatic *slot-vector-class* (make-built-in-class 'slot-vector (find-class 'gvector)))
  
  (defstatic *macptr-class* (make-built-in-class 'macptr))
  (defstatic *foreign-standard-object-class*
    (make-standard-class 'foreign-standard-object
                         *standard-object-class* *macptr-class*))

  (defstatic *foreign-class-class*
    (make-standard-class 'foreign-class *foreign-standard-object-class* *slots-class*))
  
  (make-built-in-class 'population)
  (make-built-in-class 'pool)
  (make-built-in-class 'package)
  (defstatic *lock-class* (make-built-in-class 'lock))
  (defstatic *recursive-lock-class* (make-built-in-class 'recursive-lock *lock-class*))
  (defstatic *read-write-lock-class* (make-built-in-class 'read-write-lock *lock-class*))
  
  (make-istruct-class 'lock-acquisition *istruct-class*)
  (make-istruct-class 'semaphore-notification *istruct-class*)
  (make-istruct-class 'class-wrapper *istruct-class*)
  ;; Compiler stuff, mostly
  (make-istruct-class 'faslapi *istruct-class*)
  (make-istruct-class 'faslstate *istruct-class*)
  (make-istruct-class 'var *istruct-class*)
  (make-istruct-class 'afunc *istruct-class*)
  (make-istruct-class 'lexical-environment *istruct-class*)
  (make-istruct-class 'definition-environment *istruct-class*)
  (make-istruct-class 'compiler-policy *istruct-class*)
  (make-istruct-class 'deferred-warnings *istruct-class*)
  (make-istruct-class 'ptaskstate *istruct-class*)
  (make-istruct-class 'entry *istruct-class*)
  (make-istruct-class 'foreign-object-domain *istruct-class*)
  (make-istruct-class 'acode)

  
  (make-istruct-class 'slot-id *istruct-class*)
  (make-built-in-class 'value-cell)
  (make-istruct-class 'restart *istruct-class*)
  (make-istruct-class 'hash-table *istruct-class*)
  (make-istruct-class 'readtable *istruct-class*)
  (make-istruct-class 'pathname *istruct-class*)
  (make-istruct-class 'random-state *istruct-class*)
  (make-istruct-class 'xp-structure *istruct-class*)
  (make-istruct-class 'lisp-thread *istruct-class*)
  (make-istruct-class 'resource *istruct-class*)
  (make-istruct-class 'periodic-task *istruct-class*)
  (make-istruct-class 'semaphore *istruct-class*)
  
  (make-istruct-class 'type-class *istruct-class*)
  
  (defstatic *ctype-class* (make-istruct-class 'ctype *istruct-class*))
  (make-istruct-class 'key-info *istruct-class*)
  (defstatic *args-ctype* (make-istruct-class 'args-ctype *ctype-class*))
  (make-istruct-class 'values-ctype *args-ctype*)
  (make-istruct-class 'function-ctype *args-ctype*)
  (make-istruct-class 'constant-ctype *ctype-class*)
  (make-istruct-class 'named-ctype *ctype-class*)
  (make-istruct-class 'cons-ctype *ctype-class*)
  (make-istruct-class 'unknown-ctype (make-istruct-class 'hairy-ctype *ctype-class*))
  (make-istruct-class 'numeric-ctype *ctype-class*)
  (make-istruct-class 'array-ctype *ctype-class*)
  (make-istruct-class 'member-ctype *ctype-class*)
  (make-istruct-class 'union-ctype *ctype-class*)
  (make-istruct-class 'foreign-ctype *ctype-class*)
  (make-istruct-class 'class-ctype *ctype-class*)
  (make-istruct-class 'negation-ctype *ctype-class*)
  (make-istruct-class 'intersection-ctype *ctype-class*)
  
  (make-istruct-class 'class-cell *istruct-class*)
  (make-istruct-class 'type-cell *istruct-class*)
  (make-istruct-class 'package-ref *istruct-class*)

  (make-istruct-class 'foreign-variable *istruct-class*)
  (make-istruct-class 'external-entry-point *istruct-class*)
  (make-istruct-class 'shlib *istruct-class*)

  (make-built-in-class 'complex (find-class 'number))
  (make-built-in-class 'complex-single-float (find-class 'complex))
  (make-built-in-class 'complex-double-float (find-class 'complex))  
  (make-built-in-class 'real (find-class 'number))
  (defstatic *float-class* (make-built-in-class 'float (find-class 'real)))
  (defstatic *double-float-class* (make-built-in-class 'double-float (find-class 'float)))
  (defstatic *single-float-class*  (make-built-in-class 'single-float (find-class 'float)))
  (alias-class 'short-float *single-float-class*)
  (alias-class 'long-float *double-float-class*)

  (make-built-in-class 'rational (find-class 'real))
  (make-built-in-class 'ratio (find-class 'rational))
  (make-built-in-class 'integer (find-class 'rational))
  (defstatic *fixnum-class* (make-built-in-class 'fixnum (find-class 'integer)))

  #+x86-target
  (defstatic *tagged-return-address-class* (make-built-in-class 'tagged-return-address))
  (make-built-in-class 'bignum (find-class 'integer))
  
  (make-built-in-class 'bit *fixnum-class*)
  (make-built-in-class 'unsigned-byte (find-class 'integer))
  (make-built-In-class 'signed-byte (find-class 'integer))


  (make-istruct-class 'logical-pathname (find-class 'pathname))

  
  (defstatic *base-char-class* (alias-class 'base-char *character-class*))
  (defstatic *standard-char-class* (make-built-in-class 'standard-char *base-char-class*))
  
  (defstatic *keyword-class* (make-built-in-class 'keyword *symbol-class*))

  (make-built-in-class  'list (find-class 'sequence))
  (defstatic *cons-class* (make-built-in-class 'cons (find-class 'list)))
  (defstatic *null-class* (make-built-in-class 'null *symbol-class* (find-class 'list)))
  (defstatic *vector-class* (make-built-in-class 'vector *array-class* (find-class 'sequence)))
  (defstatic *simple-array-class* (make-built-in-class 'simple-array *array-class*))
  (make-built-in-class 'simple-1d-array *vector-class* *simple-array-class*)
  
  ;;Maybe should do *float-array-class* etc?
  ;;Also, should straighten out the simple-n-dim-array mess...
  (make-built-in-class 'unsigned-byte-vector *vector-class*)
  (make-built-in-class 'simple-unsigned-byte-vector (find-class 'unsigned-byte-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'unsigned-word-vector *vector-class*)
  (make-built-in-class 'simple-unsigned-word-vector (find-class 'unsigned-word-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'fixnum-vector *vector-class*)
  (make-built-in-class 'simple-fixnum-vector (find-class 'fixnum-vector) (find-class 'simple-1d-array))


  (progn
    (make-built-in-class 'double-float-vector *vector-class*)
    (make-built-in-class 'short-float-vector *vector-class*)
    (alias-class 'long-float-vector (find-class 'double-float-vector))
    (alias-class 'single-float-vector (find-class 'short-float-vector))
    (make-built-in-class 'simple-double-float-vector (find-class 'double-float-vector) (find-class 'simple-1d-array))
    (make-built-in-class 'simple-short-float-vector (find-class 'short-float-vector) (find-class 'simple-1d-array))
    (alias-class 'simple-long-float-vector (find-class 'simple-double-float-vector))
    (alias-class 'simple-single-float-vector (find-class 'simple-short-float-vector))
    (make-built-in-class 'complex-single-float-vector *vector-class*)
    (make-built-in-class 'complex-double-float-vector *vector-class*)
    )

  #+x8664-target
  (progn
    (make-built-in-class 'symbol-vector (find-class 'gvector))
    (make-built-in-class 'function-vector (find-class 'gvector)))

  #+64-bit-target
  (progn
    (make-built-in-class 'doubleword-vector *vector-class*)
    (make-built-in-class 'simple-doubleword-vector (find-class 'doubleword-vector) (find-class 'simple-1d-array))
    (make-built-in-class 'unsigned-doubleword-vector *vector-class*)
    (make-built-in-class 'simple-unsigned-doubleword-vector (find-class 'unsigned-doubleword-vector) (find-class 'simple-1d-array))
    )                                   ; #+64-bit-target

  (make-built-in-class 'long-vector *vector-class*)
  (make-built-in-class 'simple-long-vector (find-class 'long-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'unsigned-long-vector *vector-class*)
  (make-built-in-class 'simple-unsigned-long-vector (find-class 'unsigned-long-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'byte-vector *vector-class*)
  (make-built-in-class 'simple-byte-vector (find-class 'byte-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'bit-vector *vector-class*)
  (make-built-in-class 'simple-bit-vector (find-class 'bit-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'word-vector *vector-class*)
  (make-built-in-class 'simple-word-vector (find-class 'word-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'string *vector-class*)
  (make-built-in-class 'base-string (find-class 'string))
  (make-built-in-class 'simple-string (find-class 'string) (find-class 'simple-1d-array))
  (make-built-in-class 'simple-base-string (find-class 'base-string) (find-class 'simple-string))
  (make-built-in-class 'simple-complex-single-float-vector (find-class 'complex-single-float-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'simple-complex-double-float-vector (find-class 'complex-double-float-vector) (find-class 'simple-1d-array))
  (make-built-in-class 'general-vector *vector-class*)
  (make-built-in-class 'simple-vector (find-class 'general-vector) (find-class 'simple-1d-array))

  (make-built-in-class 'hash-table-vector)
  (make-built-in-class 'catch-frame)
  (make-built-in-class 'code-vector)
  #+ppc32-target
  (make-built-in-class 'creole-object)

  (make-built-in-class 'xfunction)
  (make-built-in-class 'xcode-vector)

  (defun class-cell-find-class (class-cell errorp)
    (unless (istruct-typep class-cell 'class-cell)
      (setq class-cell (%kernel-restart $xwrongtype class-cell 'class-cell)))
    (locally (declare (type class-cell class-cell))
      (let ((class (class-cell-class class-cell)))
        (or class
            (and 
             (setq class (find-class (class-cell-name class-cell) nil))
             (when class 
               (setf (class-cell-class class-cell) class)
               class))
            (if errorp (error "Class ~s not found." (class-cell-name class-cell)) nil)))))

;;; (%wrapper-class (instance.class-wrapper frob))



  (defstatic *general-vector-class* (find-class 'general-vector))

  #+ppc32-target
  (defparameter *ivector-vector-classes*
    (vector (find-class 'short-float-vector)
            (find-class 'unsigned-long-vector)
            (find-class 'long-vector)
            (find-class 'fixnum-vector)
            (find-class 'base-string)
            (find-class 'unsigned-byte-vector)
            (find-class 'byte-vector)
            (find-class 'unsigned-word-vector)
            (find-class 'word-vector)
            (find-class 'double-float-vector)
            (find-class 'complex-single-float-vector)
            (find-class 'complex-double-float-vector)
            (find-class 'bit-vector)))

  #+ppc64-target
  (defparameter *ivector-vector-classes*
    (vector *t-class*
            *t-class*
            *t-class*
            *t-class*
            (find-class 'byte-vector)
            (find-class 'word-vector)
            (find-class 'long-vector)
            (find-class 'doubleword-vector)
            (find-class 'unsigned-byte-vector)
            (find-class 'unsigned-word-vector)
            (find-class 'unsigned-long-vector)
            (find-class 'unsigned-doubleword-vector)
            *t-class*
            *t-class*
            (find-class 'short-float-vector)
            (find-class 'fixnum-vector)
            *t-class*
            *t-class*
            *t-class*
            (find-class 'double-float-vector)
            (find-class 'base-string)
            *t-class*
            (find-class 'base-string)
            *t-class*
            *t-class*
            *t-class*
            *t-class*
            *t-class*
            *t-class*
            (find-class 'bit-vector)
            *t-class*
            *t-class*))

  #+x8632-target
  (defparameter *ivector-vector-classes*
    (vector (find-class 'short-float-vector)
            (find-class 'unsigned-long-vector)
            (find-class 'long-vector)
            (find-class 'fixnum-vector)
            (find-class 'base-string)
            (find-class 'unsigned-byte-vector)
            (find-class 'byte-vector)
            (find-class 'unsigned-word-vector)
            (find-class 'word-vector)
            (find-class 'double-float-vector)
            (find-class 'complex-single-float-vector)
            (find-class 'complex-double-float-vector)
            (find-class 'bit-vector)))

  #+x8664-target
  (progn
    (defparameter *immheader-0-classes*
      (vector *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              (find-class 'word-vector)
              (find-class 'unsigned-word-vector)
              (find-class 'base-string) ;old
              (find-class 'byte-vector)
              (find-class 'unsigned-byte-vector)
              (find-class 'bit-vector)))

    (defparameter *immheader-1-classes*
      (vector *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              (find-class 'base-string)
              (find-class 'long-vector)
              (find-class 'unsigned-long-vector)
              (find-class 'short-float-vector)))

    (defparameter *immheader-2-classes*
      (vector *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              *t-class*
              (find-class 'fixnum-vector)
              (find-class 'doubleword-vector)
              (find-class 'unsigned-doubleword-vector)
              (find-class 'double-float-vector))))

  #+arm-target
  (defparameter *ivector-vector-classes*
    (vector (find-class 'short-float-vector)
            (find-class 'unsigned-long-vector)
            (find-class 'long-vector)
            (find-class 'fixnum-vector)
            (find-class 'base-string)
            (find-class 'unsigned-byte-vector)
            (find-class 'byte-vector)
            (find-class 'unsigned-word-vector)
            (find-class 'word-vector)
            (find-class 'double-float-vector)
            (find-class 'complex-single-float-vector)
            (find-class 'complex-double-float-vector)
            (find-class 'bit-vector)))




  (defun make-foreign-object-domain (&key index name recognize class-of classp
                                          instance-class-wrapper
                                          class-own-wrapper
                                          slots-vector class-ordinal
                                          set-class-ordinal)
    (%istruct 'foreign-object-domain index name recognize class-of classp
              instance-class-wrapper class-own-wrapper slots-vector
              class-ordinal set-class-ordinal))
  
  (let* ((n-foreign-object-domains 0)
         (foreign-object-domains (make-array 10))
         (foreign-object-domain-lock (make-lock)))
    (defun register-foreign-object-domain (name
                                           &key
                                           recognize
                                           class-of
                                           classp
                                           instance-class-wrapper
                                           class-own-wrapper
                                           slots-vector
                                           class-ordinal
                                           set-class-ordinal)
      (with-lock-grabbed (foreign-object-domain-lock)
        (dotimes (i n-foreign-object-domains)
          (let* ((already (svref foreign-object-domains i)))
            (when (eq name (foreign-object-domain-name already))
              (setf (foreign-object-domain-recognize already) recognize
                    (foreign-object-domain-class-of already) class-of
                    (foreign-object-domain-classp already) classp
                    (foreign-object-domain-instance-class-wrapper already)
                    instance-class-wrapper
                    (foreign-object-domain-class-own-wrapper already)
                    class-own-wrapper
                    (foreign-object-domain-slots-vector already) slots-vector
                    (foreign-object-domain-class-ordinal already) class-ordinal
                    (foreign-object-domain-set-class-ordinal already)
                    set-class-ordinal)
              (return-from register-foreign-object-domain i))))
        (let* ((i n-foreign-object-domains)
               (new (make-foreign-object-domain :index i
                                                :name name
                                                :recognize recognize
                                                :class-of class-of
                                                :classp classp
                                                :instance-class-wrapper
                                                instance-class-wrapper
                                                :class-own-wrapper
                                                class-own-wrapper
                                                :slots-vector
                                                slots-vector
                                                :class-ordinal class-ordinal
                                                :set-class-ordinal set-class-ordinal)))
          (incf n-foreign-object-domains)
          (if (= i (length foreign-object-domains))
            (setq foreign-object-domains (%extend-vector i foreign-object-domains (* i 2))))
          (setf (svref foreign-object-domains i) new)
          i)))
    (defun foreign-class-of (p)
      (funcall (foreign-object-domain-class-of (svref foreign-object-domains (%macptr-domain p))) p))
    (defun foreign-classp (p)
      (funcall (foreign-object-domain-classp (svref foreign-object-domains (%macptr-domain p))) p))
    (defun foreign-instance-class-wrapper (p)
      (funcall (foreign-object-domain-instance-class-wrapper (svref foreign-object-domains (%macptr-domain p))) p))
    (defun foreign-class-own-wrapper (p)
      (funcall (foreign-object-domain-class-own-wrapper (svref foreign-object-domains (%macptr-domain p))) p))
    (defun foreign-slots-vector (p)
      (funcall (foreign-object-domain-slots-vector (svref foreign-object-domains (%macptr-domain p))) p))
    (defun foreign-class-ordinal (p)
      (funcall (foreign-object-domain-class-ordinal (svref foreign-object-domains (%macptr-domain p))) p))
    (defun (setf foreign-class-ordinal) (new p)
      (funcall (foreign-object-domain-set-class-ordinal (svref foreign-object-domains (%macptr-domain p))) p new))
    (defun classify-foreign-pointer (p)
      (do* ((i (1- n-foreign-object-domains) (1- i)))
           ((zerop i) (error "this can't happen"))
        (when (funcall (foreign-object-domain-recognize (svref foreign-object-domains i)) p)
          (%set-macptr-domain p i)
          (return p)))))



  (defun %register-type-ordinal-class (foreign-type class-name)
    ;; ordinal-type-class shouldn't already exist
    (with-lock-grabbed (ordinal-type-class-alist-lock)
      (or (let* ((class (cdr (assq foreign-type ordinal-type-class-alist))))
            (if (and class (eq class-name (class-name class)))
              class))
          (let* ((class (make-built-in-class class-name 'macptr)))
            (push (cons foreign-type class) ordinal-type-class-alist)
            class))))

  (defun %ordinal-type-class-for-macptr (p)
    (with-lock-grabbed (ordinal-type-class-alist-lock)
      (or (unless (%null-ptr-p p)
            (cdr (assoc (%macptr-type p) ordinal-type-class-alist :key #'foreign-type-ordinal)))
          *macptr-class*)))
                  

  (register-foreign-object-domain :unclassified
                                  :recognize #'(lambda (p)
                                                 (declare (ignore p))
                                                 (error "Shouldn't happen"))
                                  :class-of #'(lambda (p)
                                                (foreign-class-of
                                                 (classify-foreign-pointer p)))
                                  :classp #'(lambda (p)
                                              (foreign-classp
                                               (classify-foreign-pointer p)))
                                  :instance-class-wrapper
                                  #'(lambda (p)
                                      (foreign-instance-class-wrapper
                                       (classify-foreign-pointer p)))
                                  :class-own-wrapper
                                  #'(lambda (p)
                                      (foreign-class-own-wrapper 
                                       (classify-foreign-pointer p)))
                                  :slots-vector
                                  #'(lambda (p)
                                      (foreign-slots-vector
                                       (classify-foreign-pointer p))))

;;; "Raw" macptrs, that aren't recognized as "standard foreign objects"
;;; in some other domain, should always be recognized as such (and this
;;; pretty much has to be domain #1.)

  (register-foreign-object-domain :raw
                                  :recognize #'true
                                  :class-of #'%ordinal-type-class-for-macptr
                                  :classp #'false
                                  :instance-class-wrapper
                                  (lambda (p)
                                    (%class.own-wrapper (%ordinal-type-class-for-macptr p)))
                                  :class-own-wrapper #'false
                                  :slots-vector #'false)

  (defstatic *class-table*
      (let* ((v (make-array 256 :initial-element nil))
             (class-of-function-function
              #'(lambda (thing)
                  (let ((bits (lfun-bits-known-function thing)))
                    (declare (fixnum bits))
                    (if (logbitp $lfbits-trampoline-bit bits)
                      ;; closure
                      (let ((inner-fn (closure-function thing)))
                        (if (neq inner-fn thing)
                          (let ((inner-bits (lfun-bits inner-fn)))
                            (if (logbitp $lfbits-method-bit inner-bits)
                              *compiled-lexical-closure-class*
                              (if (logbitp $lfbits-gfn-bit inner-bits)
                                (%wrapper-class (gf.instance.class-wrapper thing))
                                (if (logbitp $lfbits-cm-bit inner-bits)
                                  *combined-method-class*
                                  *compiled-lexical-closure-class*))))
                          *compiled-lexical-closure-class*))
                      (if (logbitp  $lfbits-method-bit bits)
                        *method-function-class* 
                        (if (logbitp $lfbits-gfn-bit bits)
                          (%wrapper-class (gf.instance.class-wrapper thing))
                          (if (logbitp $lfbits-cm-bit bits)
                            *combined-method-class*
                            *compiled-function-class*))))))))
        ;; Make one loop through the vector, initializing fixnum & list
        ;; cells.  Set all immediates to *immediate-class*, then
        ;; special-case characters later.
        #+ppc32-target
        (do* ((slice 0 (+ 8 slice)))
             ((= slice 256))
          (declare (type (unsigned-byte 8) slice))
          (setf (%svref v (+ slice ppc32::fulltag-even-fixnum)) *fixnum-class*
                (%svref v (+ slice ppc32::fulltag-odd-fixnum))  *fixnum-class*
                (%svref v (+ slice ppc32::fulltag-cons)) *cons-class*
                (%svref v (+ slice ppc32::fulltag-nil)) *null-class*
                (%svref v (+ slice ppc32::fulltag-imm)) *immediate-class*))
        #+ppc64-target
        (do* ((slice 0 (+ 16 slice)))
             ((= slice 256))
          (declare (type (unsigned-byte 8) slice))
          (setf (%svref v (+ slice ppc64::fulltag-even-fixnum)) *fixnum-class*
                (%svref v (+ slice ppc64::fulltag-odd-fixnum))  *fixnum-class*
                (%svref v (+ slice ppc64::fulltag-cons)) *cons-class*
                (%svref v (+ slice ppc64::fulltag-imm-0)) *immediate-class*
                (%svref v (+ slice ppc64::fulltag-imm-1)) *immediate-class*
                (%svref v (+ slice ppc64::fulltag-imm-2)) *immediate-class*
                (%svref v (+ slice ppc64::fulltag-imm-3)) *immediate-class*))
        #+x8632-target
        (do* ((slice 0 (+ 8 slice))
	      (cons-fn #'(lambda (x) (if (null x) *null-class* *cons-class*))))
             ((= slice 256))
          (declare (type (unsigned-byte 8) slice))
          (setf (%svref v (+ slice x8632::fulltag-even-fixnum)) *fixnum-class*
                (%svref v (+ slice x8632::fulltag-odd-fixnum))  *fixnum-class*
                (%svref v (+ slice x8632::fulltag-cons)) cons-fn
                (%svref v (+ slice x8632::fulltag-tra)) *tagged-return-address-class*
                (%svref v (+ slice x8632::fulltag-imm)) *immediate-class*))
        #+x8664-target
        (do* ((slice 0 (+ 16 slice)))
             ((= slice 256))
          (declare (type (unsigned-byte 8) slice))
          (setf (%svref v (+ slice x8664::fulltag-even-fixnum)) *fixnum-class*
                (%svref v (+ slice x8664::fulltag-odd-fixnum))  *fixnum-class*
                (%svref v (+ slice x8664::fulltag-cons)) *cons-class*
                (%svref v (+ slice x8664::fulltag-imm-0)) *immediate-class*
                (%svref v (+ slice x8664::fulltag-imm-1)) *immediate-class*
                (%svref v (+ slice x8664::fulltag-tra-0)) *tagged-return-address-class*
                (%svref v (+ slice x8664::fulltag-tra-1)) *tagged-return-address-class*
                (%svref v (+ slice x8664::fulltag-nil)) *null-class*))
        #+arm-target
        (do* ((slice 0 (+ 8 slice)))
             ((= slice 256))
          (declare (type (unsigned-byte 8) slice))
          (setf (%svref v (+ slice arm::fulltag-even-fixnum)) *fixnum-class*
                (%svref v (+ slice arm::fulltag-odd-fixnum))  *fixnum-class*
                (%svref v (+ slice arm::fulltag-cons)) *cons-class*
                (%svref v (+ slice arm::fulltag-nil)) *null-class*
                (%svref v (+ slice arm::fulltag-imm)) *immediate-class*))

        (macrolet ((map-subtag (subtag class-name)
                     `(setf (%svref v ,subtag) (find-class ',class-name))))
          ;; immheader types map to built-in classes.
          (map-subtag target::subtag-bignum bignum)
          (map-subtag target::subtag-double-float double-float)
          (map-subtag target::subtag-single-float short-float)
          (map-subtag target::subtag-dead-macptr ivector)
          #+ppc32-target
          (map-subtag ppc32::subtag-code-vector code-vector)
          #+ppc64-target
          (map-subtag ppc64::subtag-code-vector code-vector)
          #+arm-target
          (map-subtag arm::subtag-code-vector code-vector)
          #+ppc32-target
          (map-subtag ppc32::subtag-creole-object creole-object)
          (map-subtag target::subtag-xcode-vector xcode-vector)
          (map-subtag target::subtag-xfunction xfunction)
          #+arm-target
          (map-subtag arm::subtag-pseudofunction pseudofunction)
          (map-subtag target::subtag-single-float-vector simple-short-float-vector)
          #+64-bit-target
          (map-subtag target::subtag-u64-vector simple-unsigned-doubleword-vector)
          #+64-bit-target
          (map-subtag target::subtag-s64-vector simple-doubleword-vector)
          (map-subtag target::subtag-fixnum-vector simple-fixnum-vector)
          (map-subtag target::subtag-u32-vector simple-unsigned-long-vector)
          (map-subtag target::subtag-s32-vector simple-long-vector)
          (map-subtag target::subtag-u8-vector simple-unsigned-byte-vector)
          (map-subtag target::subtag-s8-vector simple-byte-vector)
          (map-subtag target::subtag-simple-base-string simple-base-string)
          (map-subtag target::subtag-u16-vector simple-unsigned-word-vector)
          (map-subtag target::subtag-s16-vector simple-word-vector)
          (map-subtag target::subtag-double-float-vector simple-double-float-vector)
          (map-subtag target::subtag-bit-vector simple-bit-vector)
          ;; Some nodeheader types map to built-in-classes; others require
          ;; further dispatching.
          (map-subtag target::subtag-ratio ratio)
          (map-subtag target::subtag-complex complex)
          (map-subtag target::subtag-complex-single-float complex-single-float)
          (map-subtag target::subtag-complex-double-float complex-double-float)
          (map-subtag target::subtag-complex-single-float-vector simple-complex-single-float-vector)
          (map-subtag target::subtag-complex-double-float-vector simple-complex-double-float-vector)
          (map-subtag target::subtag-catch-frame catch-frame)
          (map-subtag target::subtag-hash-vector hash-table-vector)
          (map-subtag target::subtag-value-cell value-cell)
          (map-subtag target::subtag-pool pool)
          (map-subtag target::subtag-weak population)
          (map-subtag target::subtag-package package)
          (map-subtag target::subtag-simple-vector simple-vector)
          (map-subtag target::subtag-slot-vector slot-vector)
          #+x8664-target (map-subtag x8664::subtag-symbol symbol-vector)
          #+x8664-target (map-subtag x8664::subtag-function function-vector))
        (setf (%svref v target::subtag-arrayH)
              #'(lambda (x)
                  (if (logbitp $arh_simple_bit
                               (the fixnum (%svref x target::arrayH.flags-cell)))
                    *simple-array-class*
                    *array-class*)))
        ;; These need to be special-cased:
        (setf (%svref v target::subtag-macptr) #'foreign-class-of)
        (setf (%svref v target::subtag-character)
              #'(lambda (c) (let* ((code (%char-code c)))
                              (if (or (eq c #\NewLine)
                                      (and (>= code (char-code #\space))
                                           (< code (char-code #\rubout))))
                                *standard-char-class*
                                *base-char-class*))))
        (setf (%svref v target::subtag-struct)
              #'(lambda (s) (%structure-class-of s))) ; need DEFSTRUCT
        (setf (%svref v target::subtag-istruct)
              #'(lambda (i)
                  (let* ((cell (%svref i 0))
                         (wrapper (istruct-cell-info  cell)))
                    (if wrapper
                      (%wrapper-class wrapper)
                      (or (find-class (istruct-cell-name cell) nil)
                          *istruct-class*)))))
        (setf (%svref v target::subtag-basic-stream)
              #'(lambda (b) (%wrapper-class (basic-stream.wrapper b))))
        (setf (%svref v target::subtag-instance)
              #'%class-of-instance)
        (setf (%svref v #+ppc-target target::subtag-symbol
                      #+arm-target target::subtag-symbol
		      #+x8632-target target::subtag-symbol
		      #+x8664-target target::tag-symbol)
              #-ppc64-target
              #'(lambda (s) (if (eq (symbol-package s) *keyword-package*)
                              *keyword-class*
                              *symbol-class*))
              #+ppc64-target
              #'(lambda (s)
                  (if s
                    (if (eq (symbol-package s) *keyword-package*)
                      *keyword-class*
                      *symbol-class*)
                    *null-class*)))
        
        (setf (%svref v
                      #+ppc-target target::subtag-function
                      #+arm-target target::subtag-function
                      #+x8632-target target::subtag-function
                      #+x8664-target target::tag-function) 
              class-of-function-function)
        (setf (%svref v target::subtag-vectorH)
              #'(lambda (v)
                  (let* ((subtype (%array-header-subtype v)))
                    (declare (fixnum subtype))
                    (if (eql subtype target::subtag-simple-vector)
                      *general-vector-class*
                      #-x8664-target
                      (%svref *ivector-vector-classes*
                              #+ppc32-target
                              (ash (the fixnum (- subtype ppc32::min-cl-ivector-subtag))
                                   (- ppc32::ntagbits))
                              #+arm-target
                              (ash (the fixnum (- subtype arm::min-cl-ivector-subtag))
                                   (- arm::ntagbits))
                              #+ppc64-target
                              (ash (the fixnum (logand subtype #x7f)) (- ppc64::nlowtagbits))
			      #+x8632-target
			      (ash (the fixnum (- subtype x8632::min-cl-ivector-subtag))
				   (- x8632::ntagbits)))
                      #+x8664-target
                      (let* ((class (logand x8664::fulltagmask subtype))
                             (idx (ash subtype (- x8664::ntagbits))))
                        (cond ((= class x8664::fulltag-immheader-0)
                               (%svref *immheader-0-classes* idx))
                              ((= class x8664::fulltag-immheader-1)
                               (%svref *immheader-1-classes* idx))
                              ((= class x8664::fulltag-immheader-2)
                               (%svref *immheader-2-classes* idx))
                              (t *t-class*)))
                               
                      ))))
        (setf (%svref v target::subtag-lock)
              #'(lambda (thing)
                  (case (%svref thing target::lock.kind-cell)
                    (recursive-lock *recursive-lock-class*)
                    (read-write-lock *read-write-lock-class*)
                    (t *lock-class*))))
        v))





  (defun no-class-error (x)
    (error "Bug (probably): can't determine class of ~s" x))
  

                                        ; return frob from table




  )                                     ; end let



(defun classp (x)
  (if (%standard-instance-p x)
    (< (the fixnum (instance.hash x)) max-class-ordinal)
    (and (typep x 'macptr) (foreign-classp x))))

(set-type-predicate 'class 'classp)

(defun subclassp (c1 c2)
  (and (classp c1)
       (classp c2)
       (not (null (memq c2 (or (%class-cpl c1) (ignore-errors (%inited-class-cpl c1 t))))))))

(defun %class-get (class indicator &optional default)
  (let ((cell (assq indicator (%class-alist class))))
    (if cell (cdr cell) default)))

(defun %class-put (class indicator value)
  (let ((cell (assq indicator (%class-alist class))))
    (if cell
      (setf (cdr cell) value)
      (push (cons indicator value) (%class-alist class))))
  value)
  
(defsetf %class-get %class-put)

(defun %class-remprop (class indicator)
  (let* ((handle (cons nil (%class-alist class)))
         (last handle))
    (declare (dynamic-extent handle))
    (while (cdr last)
      (if (eq indicator (caar (%cdr last)))
        (progn
          (setf (%cdr last) (%cddr last))
          (setf (%class-alist class) (%cdr handle)))
        (setf last (%cdr last))))))    


(pushnew :primary-classes *features*)

(defun %class-primary-p (class)
  (if (typep class 'slots-class)
    (%class-get class :primary-p)
    t))

(defun (setf %class-primary-p) (value class)
  (if value
    (setf (%class-get class :primary-p) value)
    (progn
      (%class-remprop class :primary-p)
      nil)))

;;; Returns the first element of the CPL that is primary
(defun %class-or-superclass-primary-p (class)
  (unless (class-has-a-forward-referenced-superclass-p class)
    (dolist (super (%inited-class-cpl class t))
      (when (and (typep super 'standard-class) (%class-primary-p super))
	(return super)))))


;;; Bootstrapping version of union
(unless (fboundp 'union)
  (fset 'union (nlambda bootstrapping-union (l1 l2)
                 (dolist (e l1)
                   (unless (memq e l2)
                     (push e l2)))
                 l2))
)

(defun %add-direct-methods (method)
  (dolist (spec (%method-specializers method))
    (%do-add-direct-method spec method)))

(defun %do-add-direct-method (spec method)
  (pushnew method (specializer.direct-methods spec)))

(defun %remove-direct-methods (method)
  (dolist (spec (%method-specializers method))
    (%do-remove-direct-method spec method)))

(defun %do-remove-direct-method (spec method)
  (setf (specializer.direct-methods spec)
	(nremove method (specializer.direct-methods spec))))

(ensure-generic-function 'initialize-instance
			 :lambda-list '(instance &rest initargs &key &allow-other-keys))

(defmethod find-method ((generic-function standard-generic-function)
                        method-qualifiers specializers &optional (errorp t))
  (dolist (m (%gf-methods generic-function)
	   (when errorp
             (cerror "Try finding the method again"
                     "~s has no method for ~s ~s"
                     generic-function method-qualifiers specializers)
             (find-method generic-function method-qualifiers specializers
                          errorp)))
    (flet ((err ()
	     (error "Wrong number of specializers: ~s" specializers)))
      (let ((ss (%method-specializers m))
	    (q (%method-qualifiers m))
	    s)
	(when (equal q method-qualifiers)
	  (dolist (spec (canonicalize-specializers specializers nil)
		   (if (null ss)
		     (return-from find-method m)
		     (err)))
	    (unless (setq s (pop ss))
	      (err))
	    (unless (eq s spec)
	      (return))))))))

(defmethod create-reader-method-function ((class slots-class)
					  (reader-method-class standard-reader-method)
					  (dslotd direct-slot-definition))
  #+ppc-target
  (gvector :function
           (uvref *reader-method-function-proto* 0)
           (ensure-slot-id (%slot-definition-name dslotd))
           'slot-id-value
           nil				;method-function name
           (dpb 1 $lfbits-numreq (ash 1 $lfbits-method-bit)))
  #+x86-target
  (%clone-x86-function
   *reader-method-function-proto*
   (ensure-slot-id (%slot-definition-name dslotd))
   'slot-id-value
   nil				;method-function name
   (dpb 1 $lfbits-numreq (ash 1 $lfbits-method-bit)))
  #+arm-target
  (%fix-fn-entrypoint
   (gvector :function
           0
           (uvref *reader-method-function-proto* 1)
           (ensure-slot-id (%slot-definition-name dslotd))
           'slot-id-value
           nil				;method-function name
           (dpb 1 $lfbits-numreq (ash 1 $lfbits-method-bit))))
  )

(defmethod create-writer-method-function ((class slots-class)
					  (writer-method-class standard-writer-method)
					  (dslotd direct-slot-definition))
  #+ppc-target
  (gvector :function
           (uvref *writer-method-function-proto* 0)
           (ensure-slot-id (%slot-definition-name dslotd))
           'set-slot-id-value
           nil
           (dpb 2 $lfbits-numreq (ash 1 $lfbits-method-bit)))
  #+x86-target
    (%clone-x86-function
     *writer-method-function-proto*
     (ensure-slot-id (%slot-definition-name dslotd))
     'set-slot-id-value
     nil
     (dpb 2 $lfbits-numreq (ash 1 $lfbits-method-bit)))
    #+arm-target
    (%fix-fn-entrypoint
     (gvector :function
             0
             (uvref *writer-method-function-proto* 1)
             (ensure-slot-id (%slot-definition-name dslotd))
             'set-slot-id-value
             nil
             (dpb 2 $lfbits-numreq (ash 1 $lfbits-method-bit))))
  )






(defun %make-instance (class-cell &rest initargs)
  (declare (dynamic-extent initargs))
  (declare (optimize speed)) ;; make sure everything gets inlined that needs to be.
  (apply #'make-instance
         (or (class-cell-class class-cell) (class-cell-name  (the class-cell class-cell)))
         initargs))


(defmethod make-instance ((class symbol) &rest initargs)
  (declare (dynamic-extent initargs))
  (apply 'make-instance (find-class class) initargs))


(defmethod make-instance ((class standard-class) &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (%make-std-instance class initargs))

(defmethod make-instance ((class std-class) &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (%make-std-instance class initargs))


(defun %make-std-instance (class initargs)
  (setq initargs (default-initargs class initargs))
  (when initargs
    (apply #'check-initargs
           nil class initargs t
           #'initialize-instance #'allocate-instance #'shared-initialize
           nil))
  (let ((instance (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance instance initargs)
    instance))

(defun default-initargs (class initargs)
  (unless (typep class 'slots-class)
    (setq class (require-type class 'slots-class)))
  (when (null (%class.cpl class)) (update-class class t))
  (let ((defaults ()))
    (dolist (key.form (%class-default-initargs class))
      (unless (pl-search initargs (%car key.form))
        (setq defaults
              (list* (funcall (caddr key.form))
                     (%car key.form)
                     defaults))))
    (when defaults
      (setq initargs (append initargs (nreverse defaults))))
    initargs))


(defun %allocate-std-instance (class)
  (unless (class-finalized-p class)
    (finalize-inheritance class))
  (let* ((wrapper (%class.own-wrapper class))
         (len (length (%wrapper-instance-slots wrapper))))
    (declare (fixnum len))
    (make-instance-vector wrapper len)))




(defmethod copy-instance ((instance standard-object))
  (let* ((new-slots (copy-uvector (instance.slots instance)))
	 (copy (gvector :instance 0 (instance-class-wrapper instance) new-slots)))
    (setf (instance.hash copy) (strip-tag-to-fixnum copy)
	  (slot-vector.instance new-slots) copy)))

(defmethod initialize-instance ((instance standard-object) &rest initargs)
  (declare (dynamic-extent initargs))
  (apply 'shared-initialize instance t initargs))


(defmethod reinitialize-instance ((instance standard-object) &rest initargs)
  (declare (dynamic-extent initargs))
  (when initargs
    (check-initargs 
     instance nil initargs t #'reinitialize-instance #'shared-initialize))
  (apply 'shared-initialize instance nil initargs))

(defmethod shared-initialize ((instance standard-object) slot-names &rest initargs)
  (declare (dynamic-extent initargs))
  (%shared-initialize instance slot-names initargs))

(defmethod shared-initialize ((instance standard-generic-function) slot-names
                              &rest initargs)
  (declare (dynamic-extent initargs))
  (%shared-initialize instance slot-names initargs))


;;; Slot-value, slot-boundp, slot-makunbound, etc.
(declaim (inline find-slotd))
(defun find-slotd (name slots)
  (dolist (slotd slots)
    (when (eq name (standard-slot-definition.name slotd))
      (return slotd))))

(declaim (inline %std-slot-vector-value))

(defun %std-slot-vector-value (slot-vector slotd)
  (let* ((loc (standard-effective-slot-definition.location slotd)))
    (symbol-macrolet ((instance (slot-vector.instance slot-vector)))
      (typecase loc
	(fixnum
	 (%slot-ref slot-vector loc))
	(cons
	 (let* ((val (%cdr loc)))
	   (if (eq val (%slot-unbound-marker))
	     (slot-unbound (class-of instance) instance (standard-effective-slot-definition.name slotd))
	   val)))
      (t
       (error "Slot definition ~s has invalid location ~s (allocation ~s)."
 	      slotd loc (slot-definition-allocation slotd)))))))


(defmethod slot-value-using-class ((class standard-class)
				   instance
				   (slotd standard-effective-slot-definition))
  (ecase (standard-slot-definition.allocation slotd)
    ((:instance :class)
     (%std-slot-vector-value (instance-slots instance) slotd))))

(defun %maybe-std-slot-value-using-class (class instance slotd)
  (if (and (eql (typecode class) target::subtag-instance)
	   (eql (typecode slotd) target::subtag-instance)
	   (eq *standard-effective-slot-definition-class-wrapper*
	       (instance.class-wrapper slotd))
	   (eq *standard-class-wrapper* (instance.class-wrapper class))
           (let* ((allocation (standard-effective-slot-definition.allocation slotd)))
             (or (eq allocation :instance) (eq allocation :class))))
    (%std-slot-vector-value (instance-slots instance) slotd)
    (if (= (the fixnum (typecode instance)) target::subtag-struct)
      (struct-ref instance (standard-effective-slot-definition.location slotd))
      (slot-value-using-class class instance slotd))))


(declaim (inline  %set-std-slot-vector-value))

(defun %set-std-slot-vector-value (slot-vector slotd  new)
  (let* ((loc (standard-effective-slot-definition.location slotd))
	 (type (standard-effective-slot-definition.type slotd))
	 (type-predicate (standard-effective-slot-definition.type-predicate slotd)))
    (unless (or (eq new (%slot-unbound-marker))
                (null type-predicate)
		(funcall type-predicate new))
      (error 'bad-slot-type
	     :instance (slot-vector.instance slot-vector)
	     :datum new :expected-type type
	     :slot-definition slotd))
    (typecase loc
      (fixnum
       (setf (%svref slot-vector loc) new))
      (cons
       (setf (%cdr loc) new))
      (t
       (error "Slot definition ~s has invalid location ~s (allocation ~s)."
	      slotd loc (slot-definition-allocation slotd))))))
  
  
(defmethod (setf slot-value-using-class)
    (new
     (class standard-class)
     instance
     (slotd standard-effective-slot-definition))
  (ecase (standard-slot-definition.allocation slotd)
    ((:instance :class)
     (%set-std-slot-vector-value (instance-slots instance) slotd new))))


(defun %maybe-std-setf-slot-value-using-class (class instance slotd new)
  (if (and (eql (typecode class) target::subtag-instance)
	   (eql (typecode slotd) target::subtag-instance)
	   (eq *standard-effective-slot-definition-class-wrapper*
	       (instance.class-wrapper slotd))
	   (eq *standard-class-wrapper* (instance.class-wrapper class))
           (let* ((allocation (standard-effective-slot-definition.allocation slotd)))
             (or (eq allocation :instance) (eq allocation :class))))
    ;; Not safe to use instance.slots here, since the instance is not
    ;; definitely of type SUBTAG-INSTANCE.  (Anyway, INSTANCE-SLOTS
    ;; should be inlined here.)
    (%set-std-slot-vector-value (instance-slots instance) slotd new)
    (if (structurep instance)
      (setf (struct-ref instance (standard-effective-slot-definition.location slotd))
            new)
      (setf (slot-value-using-class class instance slotd) new))))

(defmethod slot-value-using-class ((class funcallable-standard-class)
				   instance
				   (slotd standard-effective-slot-definition))
  (%std-slot-vector-value (gf.slots instance) slotd))

(defmethod (setf slot-value-using-class)
    (new
     (class funcallable-standard-class)
     instance
     (slotd standard-effective-slot-definition))
  (%set-std-slot-vector-value (gf.slots instance) slotd new))

(defun slot-value (instance slot-name)
  (let* ((wrapper
          (let* ((w (instance-class-wrapper instance)))
            (if (eql 0 (%wrapper-hash-index w))
              (instance.class-wrapper (update-obsolete-instance instance))
              w)))
         (class (%wrapper-class wrapper))
         (slotd (find-slotd slot-name (if (%standard-instance-p class)
                                        (%class.slots class)
                                        (class-slots class)))))
    (if slotd
      (%maybe-std-slot-value-using-class class instance slotd)
      (if (typep slot-name 'symbol)
        (restart-case
         (values (slot-missing class instance slot-name 'slot-value))
         (continue ()
                   :report "Try accessing the slot again"
                   (slot-value instance slot-name))
         (use-value (value)
                    :report "Return a value"
                    :interactive (lambda ()
                                   (format *query-io* "~&Value to use: ")
                                   (list (read *query-io*)))
                    value))
        (report-bad-arg slot-name 'symbol)))))


(defmethod slot-unbound (class instance slot-name)
  (declare (ignore class))
  (restart-case (error 'unbound-slot :name slot-name :instance instance)
    (use-value (value)
      :report "Return a value"
      :interactive (lambda ()
                     (format *query-io* "~&Value to use: ")
                     (list (read *query-io*)))
      value)))



(defmethod slot-makunbound-using-class ((class slots-class)
					instance
					(slotd standard-effective-slot-definition))
  (setf (slot-value-using-class class instance slotd) (%slot-unbound-marker))
  instance)

(defmethod slot-missing (class object slot-name operation &optional new-value)
  (declare (ignore class operation new-value))
  (error "~s has no slot named ~s." object slot-name))


(defun set-slot-value (instance name value)
  (let* ((wrapper
          (let* ((w (instance-class-wrapper instance)))
            (if (eql 0 (%wrapper-hash-index w))
              (instance.class-wrapper (update-obsolete-instance instance))
              w)))
         (class (%wrapper-class wrapper))
         (slotd (find-slotd name (if (%standard-instance-p class)
                                   (%class.slots class)
                                   (class-slots class)))))
    (if slotd
      (%maybe-std-setf-slot-value-using-class class instance slotd value)
      (if (typep name 'symbol)
        (progn	    
          (slot-missing class instance name 'setf value)
          value)
        (report-bad-arg name 'symbol)))))

(defsetf slot-value set-slot-value)

(defun slot-makunbound (instance name)
  (let* ((class (class-of instance))
	 (slotd (find-slotd name (%class-slots class))))
    (if slotd
      (slot-makunbound-using-class class instance slotd)
      (slot-missing class instance name 'slot-makunbound))
    instance))

(defun %std-slot-vector-boundp (slot-vector slotd)
  (let* ((loc (standard-effective-slot-definition.location slotd)))
    (typecase loc
      (fixnum
       (not (eq (%svref slot-vector loc) (%slot-unbound-marker))))
      (cons
       (not (eq (%cdr loc) (%slot-unbound-marker))))
      (t
       (error "Slot definition ~s has invalid location ~s (allocation ~s)."
		slotd loc (slot-definition-allocation slotd))))))

(defun %maybe-std-slot-boundp-using-class (class instance slotd)
  (if (and (eql (typecode class) target::subtag-instance)
	   (eql (typecode slotd) target::subtag-instance)
	   (eq *standard-effective-slot-definition-class-wrapper*
	       (instance.class-wrapper slotd))
	   (eq *standard-class-wrapper* (instance.class-wrapper class))
           (let* ((allocation (standard-slot-definition.allocation slotd)))
             (or (eq allocation :class)
                 (eq allocation :instance))))
    (%std-slot-vector-boundp (instance-slots instance) slotd)
    (slot-boundp-using-class class instance slotd)))


(defmethod slot-boundp-using-class ((class standard-class)
				    instance
				    (slotd standard-effective-slot-definition))
  (ecase (standard-slot-definition.allocation slotd)
    ((:instance :class)
     (%std-slot-vector-boundp (instance-slots instance) slotd))))

(defmethod slot-boundp-using-class ((class funcallable-standard-class)
				    instance
				    (slotd standard-effective-slot-definition))
  (%std-slot-vector-boundp (gf.slots instance) slotd))



(defun slot-boundp (instance name)
  (let* ((wrapper
          (let* ((w (instance-class-wrapper instance)))
            (if (eql 0 (%wrapper-hash-index w))
              (instance.class-wrapper (update-obsolete-instance instance))
              w)))
         (class (%wrapper-class wrapper))
         (slotd (find-slotd name (if (%standard-instance-p class)
                                   (%class.slots class)
                                   (class-slots class)))))
    (if slotd
      (%maybe-std-slot-boundp-using-class class instance slotd)
      (if (typep name 'symbol)
        (values (slot-missing class instance name 'slot-boundp))
        (report-bad-arg name 'symbol)))))

(defun slot-value-if-bound (instance name &optional default)
  (if (slot-boundp instance name)
    (slot-value instance name)
    default))

(defun slot-exists-p (instance name)
  (let* ((class (class-of instance))
	 (slots  (class-slots class)))
    (find-slotd name slots)))


(defun slot-id-value (instance slot-id)
  (let* ((wrapper (instance-class-wrapper instance)))
    (funcall (%wrapper-slot-id-value wrapper) instance slot-id)))

(defun set-slot-id-value (instance slot-id value)
  (let* ((wrapper (instance-class-wrapper instance)))
    (funcall (%wrapper-set-slot-id-value wrapper) instance slot-id value)))

(defun slot-id-boundp (instance slot-id)
  (let* ((wrapper (instance-class-wrapper instance))
         (class (%wrapper-class wrapper))
         (slotd (funcall (%wrapper-slot-id->slotd wrapper) instance slot-id)))
    (if slotd
      (%maybe-std-slot-boundp-using-class class instance slotd)
      (values (slot-missing class instance (slot-id.name slot-id) 'slot-boundp)))))
  
;;; returns nil if (apply gf args) wil cause an error because of the
;;; non-existance of a method (or if GF is not a generic function or the name
;;; of a generic function).
(defun method-exists-p (gf &rest args)
  (declare (dynamic-extent args))
  (when (symbolp gf)
    (setq gf (fboundp gf)))
  (when (typep gf 'standard-generic-function)
    (or (null args)
        (let* ((methods (sgf.methods gf)))
          (dolist (m methods)
            (when (null (%method-qualifiers m))
              (let ((specializers (%method-specializers m))
                    (args args))
                (when (dolist (s specializers t)
                        (unless (cond ((typep s 'eql-specializer) 
				       (eql (eql-specializer-object s)
					    (car args)))
                                      (t (memq s (%inited-class-cpl
                                                  (class-of (car args))))))
                          (return nil))
                        (pop args))
                  (return-from method-exists-p m)))))
          nil))))

(defun funcall-if-method-exists (gf &optional default &rest args)
  (declare (dynamic-extent args))
  (if (apply #'method-exists-p gf args)
    (apply gf args)
    (if default (apply default args))))


(defun find-specializer (specializer)
  (if (and (listp specializer) (eql (car specializer) 'eql))
    (intern-eql-specializer (cadr specializer))
    (find-class specializer)))

(defmethod make-instances-obsolete ((class symbol))
  (make-instances-obsolete (find-class class)))

(defmethod make-instances-obsolete ((class standard-class))
  (let ((wrapper (%class-own-wrapper class)))
    (when wrapper
      (setf (%class-own-wrapper class) nil)
      (make-wrapper-obsolete wrapper)))
  class)

(defmethod make-instances-obsolete ((class funcallable-standard-class))
  (let ((wrapper (%class.own-wrapper class)))
    (when wrapper
      (setf (%class-own-wrapper class) nil)
      (make-wrapper-obsolete wrapper)))
  class)

(defmethod make-instances-obsolete ((class structure-class))
  ;; could maybe warn that instances are obsolete, but there's not
  ;; much that we can do about that.
  class)



;;; A wrapper is made obsolete by setting the hash-index & instance-slots to 0
;;; The instance slots are saved for update-obsolete-instance
;;; by consing them onto the class slots.
;;; Method dispatch looks at the hash-index.
;;; slot-value & set-slot-value look at the instance-slots.
;;; Each wrapper may have an associated forwarding wrapper, which must
;;; also be made obsolete.  The forwarding-wrapper is stored in the
;;; hash table below keyed on the wrapper-hash-index of the two
;;; wrappers.
(defvar *forwarding-wrapper-hash-table* (make-hash-table :test 'eq))  


(defun make-wrapper-obsolete (wrapper)
  (without-interrupts
   (let ((forwarding-info
          (unless (eql 0 (%wrapper-instance-slots wrapper))   ; already forwarded or obsolete?
            (%cons-forwarding-info (%wrapper-instance-slots wrapper)
                                   (%wrapper-class-slots wrapper)))))
     (when forwarding-info
       (setf (%wrapper-hash-index wrapper) 0
             (%wrapper-cpl wrapper) nil
             (%wrapper-cpl-bits wrapper) nil
             (%wrapper-instance-slots wrapper) 0
             (%wrapper-forwarding-info wrapper) forwarding-info
	     (%wrapper-slot-id->slotd wrapper) #'%slot-id-lookup-obsolete
	     (%wrapper-slot-id-value wrapper) #'%slot-id-ref-obsolete
	     (%wrapper-set-slot-id-value wrapper) #'%slot-id-set-obsolete
             ))))
  wrapper)

(defun %clear-class-primary-slot-accessor-offsets (class)
  (let ((info-list (%class-get class '%class-primary-slot-accessor-info)))
    (dolist (info info-list)
      (setf (%slot-accessor-info.offset info) nil))))

(defun primary-class-slot-offset (class slot-name)
  (dolist (super (%class.cpl class))
    (let* ((pos (and (typep super 'standard-class)
                     (%class-primary-p super)
                     (dolist (slot (%class-slots class))
		       (when (eq (%slot-definition-allocation slot)
				 :instance)
			 (when (eq slot-name (%slot-definition-name slot))
			   (return (%slot-definition-location slot))))))))
      (when pos (return pos)))))

;;; Called by the compiler-macro expansion for slot-value
;;; info is the result of a %class-primary-slot-accessor-info call.
;;; value-form is specified if this is set-slot-value.
;;; Otherwise it's slot-value.
(defun primary-class-slot-value (instance info &optional (value-form nil value-form-p))
  (let ((slot-name (%slot-accessor-info.slot-name info)))
    (prog1
      (if value-form-p
        (setf (slot-value instance slot-name) value-form)
        (slot-value instance slot-name))
      (setf (%slot-accessor-info.offset info)
            (primary-class-slot-offset (class-of instance) slot-name)))))

(defun primary-class-accessor (instance info &optional (value-form nil value-form-p))
  (let ((accessor (%slot-accessor-info.accessor info)))
    (prog1
      (if value-form-p
        (funcall accessor value-form instance)
        (funcall accessor instance))
      (let ((methods (compute-applicable-methods
                      accessor
                      (if value-form-p (list value-form instance) (list instance))))
            method)
        (when (and (eql (length methods) 1)
                   (typep (setq method (car methods)) 'standard-accessor-method))
          (let* ((slot-name (method-slot-name method)))
            (setf (%slot-accessor-info.offset info)
                  (primary-class-slot-offset (class-of instance) slot-name))))))))

(defun exchange-slot-vectors-and-wrappers (a b)
  (if (typep a 'funcallable-standard-object)
    (let* ((temp-wrapper (gf.instance.class-wrapper a))
           (orig-a-slots (gf.slots a))
           (orig-b-slots (gf.slots b)))
      (setf (gf.instance.class-wrapper a) (gf.instance.class-wrapper b)
            (gf.instance.class-wrapper b) temp-wrapper
            (gf.slots a) orig-b-slots
            (gf.slots b) orig-a-slots
            (slot-vector.instance orig-a-slots) b
            (slot-vector.instance orig-b-slots) a))    
    (let* ((temp-wrapper (instance.class-wrapper a))
           (orig-a-slots (instance.slots a))
           (orig-b-slots (instance.slots b)))
      (setf (instance.class-wrapper a) (instance.class-wrapper b)
            (instance.class-wrapper b) temp-wrapper
            (instance.slots a) orig-b-slots
            (instance.slots b) orig-a-slots
            (slot-vector.instance orig-a-slots) b
            (slot-vector.instance orig-b-slots) a))))




;;; How slot values transfer (from PCL):
;;;
;;; local  --> local        transfer 
;;; local  --> shared       discard
;;; local  -->  --          discard
;;; shared --> local        transfer
;;; shared --> shared       discard
;;; shared -->  --          discard
;;;  --    --> local        added
;;;  --    --> shared        --
;;;
;;; See make-wrapper-obsolete to see how we got here.
;;; A word about forwarding.  When a class is made obsolete, the
;;; %wrapper-instance-slots slot of its wrapper is set to 0.
;;; %wrapper-class-slots = (instance-slots . class-slots)
;;; Note: this should stack-cons the new-instance if we can reuse the
;;; old instance or it's forwarded value.
(defun update-obsolete-instance (instance)
  (let* ((added ())
	 (discarded ())
	 (plist ()))
    (without-interrupts			; Not -close- to being correct
     (let* ((old-wrapper (standard-object-p instance)))
       (unless old-wrapper
         (when (typep instance 'funcallable-standard-object)
           (setq old-wrapper (gf.instance.class-wrapper instance)))
         (unless old-wrapper
           (report-bad-arg instance '(or standard-object funcallable-standard-object))))
       (when (eql 0 (%wrapper-instance-slots old-wrapper)) ; is it really obsolete?
         (let* ((class (%wrapper-class old-wrapper))
                (new-wrapper (or (%class.own-wrapper class)
                                 (progn
                                   (update-class class t)
                                   (%class.own-wrapper class))))
                (forwarding-info (%wrapper-forwarding-info old-wrapper))
                (old-class-slots (%forwarding-class-slots forwarding-info))
                (old-instance-slots (%forwarding-instance-slots forwarding-info))
                (new-instance-slots (%wrapper-instance-slots new-wrapper))
                (new-class-slots (%wrapper-class-slots new-wrapper))
		(new-instance (allocate-instance class))
		(old-slot-vector (instance-slots instance))
		(new-slot-vector (instance-slots new-instance)))
           ;; Lots to do.  Hold onto your hat.
           (let* ((old-size (uvsize old-instance-slots))
                  (new-size (uvsize new-instance-slots)))
             (declare (fixnum old-size new-size))
             (dotimes (i old-size)
               (declare (fixnum i))
               (let* ((slot-name (%svref old-instance-slots i))
                      (pos (%vector-member slot-name new-instance-slots))
                      (val (%svref old-slot-vector (%i+ i 1))))
                 (if pos
                   (setf (%svref new-slot-vector (%i+ pos 1)) val)
                   (progn
                     (push slot-name discarded)
                     (unless (eq val (%slot-unbound-marker))
                       (setf (getf plist slot-name) val))))))
             ;; Go through old class slots
             (dolist (pair old-class-slots)
               (let* ((slot-name (%car pair))
                      (val (%cdr pair))
                      (pos (%vector-member slot-name new-instance-slots)))
                 (if pos
                   (setf (%svref new-slot-vector (%i+ pos 1)) val)
                   (progn
                     (push slot-name discarded)
                     (unless (eq val (%slot-unbound-marker))
                       (setf (getf plist slot-name) val))))))
                                        ; Go through new instance slots
             (dotimes (i new-size)
               (declare (fixnum i))
               (let* ((slot-name (%svref new-instance-slots i)))
                 (unless (or (%vector-member slot-name old-instance-slots)
                             (assoc slot-name old-class-slots))
                   (push slot-name added))))
             ;; Go through new class slots
             (dolist (pair new-class-slots)
               (let ((slot-name (%car pair)))
                 (unless (or (%vector-member slot-name old-instance-slots)
                             (assoc slot-name old-class-slots))
                   (push slot-name added))))
             (exchange-slot-vectors-and-wrappers new-instance instance))))))
    ;; run user code with interrupts enabled.
    (update-instance-for-redefined-class instance added discarded plist))
  instance)
            
          
(defmethod update-instance-for-redefined-class ((instance standard-object)
						added-slots
						discarded-slots
						property-list
						&rest initargs)
  (declare (ignore discarded-slots property-list))
  (when initargs
    (check-initargs
     instance nil initargs t
     #'update-instance-for-redefined-class #'shared-initialize))
  (apply #'shared-initialize instance added-slots initargs))

(defmethod update-instance-for-redefined-class ((instance standard-generic-function)
						added-slots
						discarded-slots
						property-list
						&rest initargs)
  (declare (ignore discarded-slots property-list))
  (when initargs
    (check-initargs
     instance nil initargs t
     #'update-instance-for-redefined-class #'shared-initialize))
  (apply #'shared-initialize instance added-slots initargs))

(defun check-initargs (instance class initargs errorp &rest functions)
  (declare (dynamic-extent functions))
  (declare (list functions))
  (setq class (require-type (or class (class-of instance)) 'class))
  (unless (getf initargs :allow-other-keys)
    (let ((initvect (initargs-vector instance class functions)))
      (when (eq initvect t) (return-from check-initargs nil))
      (do* ((tail initargs (cddr tail))
	    (initarg (car tail) (car tail))
	    bad-keys? bad-key)
	   ((null (cdr tail))
	    (if bad-keys?
	      (if errorp
		(signal-program-error
		 "~s is an invalid initarg to ~s for ~s.~%~
                                    Valid initargs: ~s."
		 bad-key
		 (function-name (car functions))
		 class (coerce initvect 'list))
		(values bad-keys? bad-key))))
	(if (eq initarg :allow-other-keys)
	  (if (cadr tail)
	    (return))                   ; (... :allow-other-keys t ...)
	  (unless (or bad-keys? (%vector-member initarg initvect))
	    (setq bad-keys? t
		  bad-key initarg)))))))

(defun initargs-vector (instance class functions)
  (let ((index (cadr (assq (car functions) *initialization-invalidation-alist*))))
    (unless index
      (error "Unknown initialization function: ~s." (car functions)))
    (let ((initvect (%svref (instance-slots class) index)))
      (unless initvect
        (setf (%svref (instance-slots class) index) 
              (setq initvect (compute-initargs-vector instance class functions))))
      initvect)))


;; This is used for compile-time defclass option checking.
(defun class-keyvect (class-arg initargs)
  (let* ((class (if (typep class-arg 'class) class-arg (find-class class-arg nil)))
	 (meta-arg (getf initargs :metaclass (if (and class (not (typep class 'forward-referenced-class)))
					       (class-of class)
					       *standard-class-class*)))
	 (meta-spec (if (quoted-form-p meta-arg) (%cadr meta-arg) meta-arg))
	 (meta (if (typep meta-spec 'class) meta-spec (find-class meta-spec nil))))
    (if (and meta (not (typep meta 'forward-referenced-class)))
      (compute-initargs-vector class meta (list #'initialize-instance #'allocate-instance #'shared-initialize) t)
      t)))

(defun compute-initargs-vector (instance class functions &optional require-rest)
  (let ((initargs (class-slot-initargs class))
        (cpl (%inited-class-cpl class)))
    (dolist (f functions)         ; for all the functions passed
      #+no
      (if (logbitp $lfbits-aok-bit (lfun-bits f))
	(return-from compute-initargs-vector t))
      (dolist (method (%gf-methods f))   ; for each applicable method
        (let ((spec (car (%method-specializers method))))
          (when (if (typep spec 'eql-specializer)
                  (eql instance (eql-specializer-object spec))
                  (memq spec cpl))
            (let* ((func (%inner-method-function method))
                   (keyvect (if (and (logbitp $lfbits-aok-bit (lfun-bits func))
				     (or (not require-rest)
					 (logbitp $lfbits-rest-bit (lfun-bits func))))
			      (return-from compute-initargs-vector t)
                              (lfun-keyvect func))))
              (dovector (key keyvect)
                (pushnew key initargs)))))))   ; add all of the method's keys
    (apply #'vector initargs)))



;;; A useful function
(defun class-make-instance-initargs (class)
  (setq class (require-type (if (symbolp class) (find-class class) class)
                            'std-class))
  (flet ((iv (class &rest functions)
           (declare (dynamic-extent functions))
           (initargs-vector (class-prototype class) class functions)))
    (let ((initvect (apply #'iv
                           class
                           #'initialize-instance #'allocate-instance #'shared-initialize
                           nil)))
      (if (eq initvect 't)
        t
        (concatenate 'list initvect)))))

                                   

;;; This is part of the MOP
;;; Maybe it was, at one point in the distant past ...
(defmethod class-slot-initargs ((class slots-class))
  (collect ((initargs))
    (dolist (slot (%class-slots class) (initargs))
      (dolist (i (%slot-definition-initargs slot))
        (initargs i)))))

  
(defun maybe-update-obsolete-instance (instance)
  (let ((wrapper (standard-object-p instance)))
    (unless wrapper
              (when (typep instance 'funcallable-standard-object)
          (setq wrapper (gf.instance.class-wrapper instance)))
      
      (unless wrapper
        (report-bad-arg instance '(or standard-object funcallable-standard-object))))
    (when (eql 0 (%wrapper-hash-index wrapper))
      (update-obsolete-instance instance)))
  instance)


;;; If you ever reference one of these through anyone who might call
;;; update-obsolete-instance, you will lose badly.
(defun %maybe-forwarded-instance (instance)
  (maybe-update-obsolete-instance instance)
  instance)



(defmethod change-class (instance
			 (new-class symbol)
			 &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (apply #'change-class instance (find-class new-class) initargs))

(defmethod change-class ((instance standard-object)
			 (new-class standard-class)
			  &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (%change-class instance new-class initargs))


(defun %change-class (object new-class initargs)
  (let* ((old-class (class-of object))
	 (old-wrapper (%class.own-wrapper old-class))
	 (new-wrapper (or (%class.own-wrapper new-class)
			  (progn
			    (update-class new-class t)
			    (%class.own-wrapper new-class))))
	 (old-instance-slots-vector (%wrapper-instance-slots old-wrapper))
	 (new-instance-slots-vector (%wrapper-instance-slots new-wrapper))
	 (num-new-instance-slots (length new-instance-slots-vector))
	 (new-object (allocate-instance new-class)))
    (declare (fixnum num-new-instance-slots)
	     (simple-vector new-instance-slots-vector old-instance-slots-vector))
    ;; Retain local slots shared between the new class and the old.
    (do* ((new-pos 0 (1+ new-pos))
	  (new-slot-location 1 (1+ new-slot-location)))
	 ((= new-pos num-new-instance-slots))
      (declare (fixnum new-pos new-slot-location))
      (let* ((old-pos (position (svref new-instance-slots-vector new-pos)
				old-instance-slots-vector :test #'eq)))
	(when old-pos
	  (setf (%standard-instance-instance-location-access
		 new-object
		 new-slot-location)
		(%standard-instance-instance-location-access
		 object
		 (the fixnum (1+ (the fixnum old-pos))))))))
    ;; If the new class defines a local slot whos name matches
    ;; that of a shared slot in the old class, the shared slot's
    ;; value is used to initialize the new instance's local slot.
    (dolist (shared-slot (%wrapper-class-slots old-wrapper))
      (destructuring-bind (name . value) shared-slot
	(let* ((new-slot-pos (position name new-instance-slots-vector
				       :test #'eq)))
	  (if new-slot-pos
	    (setf (%standard-instance-instance-location-access
		   new-object
		   (the fixnum (1+ (the fixnum new-slot-pos))))
		  value)))))
    (exchange-slot-vectors-and-wrappers object new-object)
    (apply #'update-instance-for-different-class new-object object initargs)
    object))

(defmethod update-instance-for-different-class ((previous standard-object)
                                                (current standard-object)
                                                &rest initargs)
  (declare (dynamic-extent initargs))
  (%update-instance-for-different-class previous current initargs))

(defun %update-instance-for-different-class (previous current initargs)
  (when initargs
    (check-initargs
     current nil initargs t
     #'update-instance-for-different-class #'shared-initialize))
  (let* ((previous-slots (class-slots (class-of previous)))
	 (current-slots (class-slots (class-of current)))
	 (added-slot-names ()))
    (dolist (s current-slots)
      (let* ((name (%slot-definition-name s)))
	(unless (find-slotd name previous-slots)
	  (push name added-slot-names))))
    (apply #'shared-initialize
	   current
	   added-slot-names
	   initargs)))




;;; Clear all the valid initargs caches.
(defun clear-valid-initargs-caches ()
  (map-classes #'(lambda (name class)
                   (declare (ignore name))
                   (when (std-class-p class)
                     (setf (%class.make-instance-initargs class) nil
                           (%class.reinit-initargs class) nil
                           (%class.redefined-initargs class) nil
                           (%class.changed-initargs class) nil)))))

(defun clear-clos-caches ()
  (clear-all-gf-caches)
  (clear-valid-initargs-caches))

(defmethod allocate-instance ((class standard-class) &rest initargs)
  (declare (ignore initargs))
  (%allocate-std-instance class))

(defmethod allocate-instance ((class funcallable-standard-class) &rest initargs)
  (declare (ignore initargs))
  (%allocate-gf-instance class))

(unless *initialization-invalidation-alist*
  (setq *initialization-invalidation-alist*
        (list (list #'initialize-instance %class.make-instance-initargs)
              (list #'allocate-instance %class.make-instance-initargs)
              (list #'reinitialize-instance %class.reinit-initargs)
              (list #'shared-initialize 
                    %class.make-instance-initargs %class.reinit-initargs
                    %class.redefined-initargs %class.changed-initargs)
              (list #'update-instance-for-redefined-class
                    %class.redefined-initargs)
              (list #'update-instance-for-different-class
                    %class.changed-initargs))))


(defstatic *initialization-function-lists*
  (list (list #'initialize-instance #'allocate-instance #'shared-initialize)
        (list #'reinitialize-instance #'shared-initialize)
        (list #'update-instance-for-redefined-class #'shared-initialize)
        (list #'update-instance-for-different-class #'shared-initialize)))



(unless *clos-initialization-functions*
  (setq *clos-initialization-functions*
        (list #'initialize-instance #'allocate-instance #'shared-initialize
              #'reinitialize-instance
              #'update-instance-for-different-class #'update-instance-for-redefined-class)))

(defun compute-initialization-functions-alist ()
  (let ((res nil)
        (lists *initialization-function-lists*))
    (dolist (cell *initialization-invalidation-alist*)
      (let (res-list)
        (dolist (slot-num (cdr cell))
          (push
           (ecase slot-num
             (#.%class.make-instance-initargs 
              (assq #'initialize-instance lists))
             (#.%class.reinit-initargs
              (assq #'reinitialize-instance lists))
             (#.%class.redefined-initargs
              (assq #'update-instance-for-redefined-class lists))
             (#.%class.changed-initargs
              (assq #'update-instance-for-different-class lists)))
           res-list))
        (push (cons (car cell) (nreverse res-list)) res)))
    (setq *initialization-functions-alist* res)))

(compute-initialization-functions-alist)

                  




;;; Need to define this for all of the BUILT-IN-CLASSes.
(defmethod class-prototype ((class class))
  (%class.prototype class))

(defmethod class-prototype ((class std-class))
  (or (%class.prototype class)
      (setf (%class.prototype class) (allocate-instance class))))


(defun gf-class-prototype (class)
  (%allocate-gf-instance class))



(defmethod class-prototype ((class structure-class))
  (or (%class.prototype class)
      (setf (%class.prototype class)
            (let* ((sd (gethash (class-name class) %defstructs%))
                   (slots (class-slots class))
                   (proto (allocate-typed-vector :struct (1+ (length slots)))))
              (setf (uvref proto 0) (sd-superclasses sd))
              (dolist (slot slots proto)
                (setf (slot-value-using-class class proto slot)
                      (funcall (slot-definition-initfunction slot))))))))


(defmethod remove-method ((generic-function standard-generic-function)
                          (method standard-method))
  (when (eq generic-function (%method-gf method))
    (%remove-standard-method-from-containing-gf method))
  generic-function)



(defmethod function-keywords ((method standard-method))
  (let ((f (%inner-method-function method)))
    (values
     (concatenate 'list (lfun-keyvect f))
     (%ilogbitp $lfbits-aok-bit (lfun-bits f)))))

(defmethod no-next-method ((generic-function standard-generic-function)
                           (method standard-method)
                           &rest args)
  (error "There is no next method for ~s~%args: ~s" method args))

(defmethod add-method ((generic-function standard-generic-function) (method standard-method))
  (%add-standard-method-to-standard-gf generic-function method))

(defmethod no-applicable-method (gf &rest args)
  (cerror "Try calling it again"
          (make-condition 'no-applicable-method-exists :gf gf :args args))
  (apply gf args))


(defmethod no-applicable-primary-method (gf methods)
  (%method-combination-error "No applicable primary methods for ~s~@
                              Applicable methods: ~s" gf methods))

(defmethod compute-applicable-methods ((gf standard-generic-function) args)
  (%compute-applicable-methods* gf args))

(defmethod compute-applicable-methods-using-classes ((gf standard-generic-function) args)
  (let ((res (%compute-applicable-methods* gf args t)))
    (if (eq res :undecidable)
      (values nil nil)
      (values res t))))

(defun %compute-applicable-methods+ (gf &rest args)
  (declare (dynamic-extent args))
  (%compute-applicable-methods* gf args))

(defun %compute-applicable-methods* (gf args &optional using-classes-p)
  (let* ((methods (%gf-methods gf))
         (args-length (length args))
         (bits (inner-lfun-bits gf))
         arg-count res)
    (when methods
      (setq arg-count (length (%method-specializers (car methods))))
      (unless (<= arg-count args-length)
        (error "Too few args to ~s" gf))
      (unless (or (logbitp $lfbits-rest-bit bits)
                  (logbitp $lfbits-restv-bit bits)
                  (logbitp $lfbits-keys-bit bits)
                  (<= args-length 
                      (+ (ldb $lfbits-numreq bits) (ldb $lfbits-numopt bits))))
        (error "Too many args to ~s" gf))
      (let ((cpls (make-list arg-count)))
        (declare (dynamic-extent cpls))
        (do* ((args-tail args (cdr args-tail))
              (cpls-tail cpls (cdr cpls-tail)))
            ((null cpls-tail))
          (setf (car cpls-tail)
                (%class-precedence-list (if using-classes-p
                                          ;; extension for use in source location support
                                          (if (typep (car args-tail) 'eql-specializer)
                                            (class-of (eql-specializer-object (car args-tail)))
                                            (car args-tail))
                                          (class-of (car args-tail))))))
        (dolist (m methods)
          (let ((appp (%method-applicable-p m args cpls using-classes-p)))
            (when appp
              (when (eq appp :undecidable) ;; can only happen if using-classes-p
                (return-from %compute-applicable-methods* appp))
              (push m res))))
        (sort-methods res cpls (%gf-precedence-list gf))))))


(defun %method-applicable-p (method args cpls &optional using-classes-p)
  (do* ((specs (%method-specializers method) (%cdr specs))
        (args args (%cdr args))
        (cpls cpls (%cdr cpls)))
      ((null specs) t)
    (let ((spec (%car specs))
          (arg (%car args)))
      (if (typep spec 'eql-specializer)
        (if using-classes-p
          (if (typep arg 'eql-specializer) ;; extension for use in source location support
            (unless (eql (eql-specializer-object arg) (eql-specializer-object spec))
              (return nil))
            (if (typep (eql-specializer-object spec) arg)
              ;; Can't tell if going to be applicable or not based on class alone
              ;; Except for the special case of NULL which is a singleton
              (unless (eq arg *null-class*)
                (return :undecidable))
              (return nil)))
          (unless (eql arg (eql-specializer-object spec))
            (return nil)))
        (unless (memq spec (%car cpls))
          (return nil))))))


;;; Need this so that (compute-applicable-methods
;;; #'class-precedence-list ...)  will not recurse.
(defun %class-precedence-list (class)
  (if (eq (class-of class) *standard-class-class*)
    (%inited-class-cpl class)
    (class-precedence-list class)))

(defmethod class-precedence-list ((class class))
  (%inited-class-cpl class))


(defun make-all-methods-kernel ()
  (dolist (f (population.data %all-gfs%))
    (let ((smc *standard-method-class*))
      (dolist (method (slot-value-if-bound f 'methods))
	(when (eq (class-of method) smc)
	  (change-class method *standard-kernel-method-class*))))))


(defun make-all-methods-non-kernel ()
  (dolist (f (population.data %all-gfs%))
    (let ((skmc *standard-kernel-method-class*))
      (dolist (method (slot-value-if-bound f 'methods))
	(when (eq (class-of method) skmc)
	  (change-class method *standard-method-class*))))))


(defun required-lambda-list-args (l)
  (multiple-value-bind (ok req) (verify-lambda-list l)
    (unless ok (error "Malformed lambda-list: ~s" l))
    req))


(defun check-generic-function-lambda-list (ll &optional (errorp t))
  (multiple-value-bind (ok reqsyms opttail resttail keytail auxtail)
                       (verify-lambda-list ll)
    (declare (ignore reqsyms resttail))
    (when ok 
      (block checkit
        (when (eq (car opttail) '&optional)
          (dolist (elt (cdr opttail))
            (when (memq elt lambda-list-keywords) (return))
            (unless (or (symbolp elt)
                        (and (listp elt)
                             (non-nil-symbol-p (car elt))
                             (null (cdr elt))))
              (return-from checkit (setq ok nil)))))
        (dolist (elt (cdr keytail))
          (when (memq elt lambda-list-keywords) (return))
          (unless (or (symbolp elt)
                      (and (listp elt)
                           (or (non-nil-symbol-p (car elt))
                               (and (listp (car elt))
                                    (non-nil-symbol-p (caar elt))
                                    (non-nil-symbol-p (cadar elt))
                                    (null (cddar elt))))
                           (null (cdr elt))))
            (return-from checkit (setq ok nil))))
        (when auxtail (setq ok nil))))
    (when (and errorp (not ok))
      (signal-program-error "Bad generic function lambda list: ~s" ll))
    ok))


(defun canonicalize-argument-precedence-order (apo req)
  (cond ((equal apo req) nil)
        ((not (eql (length apo) (length req)))
         (signal-program-error "Lengths of ~S and ~S differ." apo req))
        (t (let ((res nil))
             (dolist (arg apo (nreverse res))
               (let ((index (position arg req)))
                 (if (or (null index) (memq index res))
                   (error "Missing or duplicate arguments in ~s" apo))
                 (push index res)))))))


(defun %defgeneric (function-name lambda-list method-combination generic-function-class
                                  options)
  (setq generic-function-class (find-class generic-function-class))
  (setq method-combination 
        (find-method-combination
         (class-prototype generic-function-class)
         (car method-combination)
         (cdr method-combination)))
  (let ((gf (fboundp function-name)))
    (when gf
      (dolist (method (%defgeneric-methods gf))
        (remove-method gf method))))
  (record-source-file function-name 'function)
  (record-arglist function-name lambda-list)
  (apply #'ensure-generic-function 
         function-name
         :lambda-list lambda-list
         :method-combination method-combination
         :generic-function-class generic-function-class
         options))




;;; Redefined in lib;method-combination.lisp
(defmethod find-method-combination ((gf standard-generic-function) type options)
  (unless (and (eq type 'standard) (null options))
    (error "non-standard method-combination not supported yet."))
  *standard-method-combination*)



(defmethod add-direct-method ((spec specializer) (method method))
  (pushnew method (specializer.direct-methods spec)))

(setf (fdefinition '%do-add-direct-method) #'add-direct-method)

(defmethod remove-direct-method ((spec specializer) (method method))
  (setf (specializer.direct-methods spec)
	(nremove method (specializer.direct-methods spec))))

(setf (fdefinition '%do-remove-direct-method) #'remove-direct-method)





				   



(defvar *make-load-form-saving-slots-hash* (make-hash-table :test 'eq))

(defun make-load-form-saving-slots (object &key
					   (slot-names nil slot-names-p)
					   environment)
  (declare (ignore environment))
  (let* ((class (class-of object))
         (class-name (class-name class))
         (structurep (structurep object))
         (sd (and structurep (require-type (gethash class-name %defstructs%) 'vector))))
    (unless (or structurep
                (standard-instance-p object))
      (%badarg object '(or standard-object structure-object)))
    (if slot-names-p
      (dolist (slot slot-names)
        (unless (slot-exists-p object slot)
          (error "~s has no slot named ~s" object slot)))
      (setq slot-names
            (if structurep
              (let ((res nil))
                (dolist (slot (sd-slots sd))
                  (unless (fixnump (car slot))
                    (push (%car slot) res)))
                (nreverse res))
              (mapcar '%slot-definition-name
                      (extract-instance-effective-slotds
                       (class-of object))))))
    (values
     (let* ((form (gethash class-name *make-load-form-saving-slots-hash*)))
       (or (and (consp form)
                (eq (car form) 'allocate-instance)
                form)
           (setf (gethash class-name *make-load-form-saving-slots-hash*)
                 `(allocate-instance (find-class ',class-name)))))
     ;; initform is NIL when there are no slots
     (when slot-names
       `(%set-slot-values
         ',object
         ',slot-names
         ',(let ((temp #'(lambda (slot)
                           (if (slot-boundp object slot)
                             (slot-value object slot)
                             (%slot-unbound-marker)))))
             (declare (dynamic-extent temp))
             (mapcar temp slot-names)))))))


    

(defmethod allocate-instance ((class structure-class) &rest initargs)
  (declare (ignore initargs))
  (let* ((class-name (%class-name class))
         (sd (or (gethash class-name %defstructs%)
                 (error "Can't find structure named ~s" class-name)))
         (res (make-structure-vector (sd-size sd))))
    (setf (%svref res 0) (mapcar (lambda (x)
                                   (find-class-cell x t)) (sd-superclasses sd)))
    res))


(defun %set-slot-values (object slots values)
  (dolist (slot slots)
    (let ((value (pop values)))
      (if (eq value (%slot-unbound-marker))
        (slot-makunbound object slot)
        (setf (slot-value object slot) value)))))


(defun %recache-class-direct-methods ()
  (let ((*maintain-class-direct-methods* t))   ; in case we get an error
    (dolist (f (population-data %all-gfs%))
      (when (standard-generic-function-p f)
        (dolist (method (%gf-methods f))
          (%add-direct-methods method)))))
  (setq *maintain-class-direct-methods* t))   ; no error, all is well

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-clos-boot.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/x86-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 2005-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


(in-package "CCL")

;;; The order in which GPRs appear in an exception context generally
;;; has nothing to do with how they're encoded in instructions/uuos,
;;; and is OS-dependent.

#+linuxx8664-target
(progn
  (defconstant gp-regs-offset (+ (get-field-offset :ucontext.uc_mcontext)
                                 (get-field-offset :mcontext_t.gregs)))
  (defmacro xp-gp-regs (xp) xp)
  (defconstant flags-register-offset #$REG_EFL)
  (defconstant rip-register-offset #$REG_RIP)
  (defun xp-mxcsr (xp)
    (pref xp :ucontext.uc_mcontext.fpregs.mxcsr))
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp :ucontext.uc_mcontext.fpregs._xmm))
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(13                                ;rax
      14                                ;rcx
      12                                ;rdx
      11                                ;rbx
      15                                ;rsp
      10                                ;rbp
      9                                 ;rsi
      8                                 ;rdi
      0                                 ;r8
      1                                 ;r9
      2                                 ;r10
      3                                 ;r11
      4                                 ;r12
      5                                 ;r13
      6                                 ;r14
      7                                 ;r15
      )))

#+freebsdx8664-target
(progn
  (defconstant gp-regs-offset (get-field-offset :ucontext_t.uc_mcontext))
  (defmacro xp-gp-regs (xp) xp)
  (defconstant flags-register-offset 22)
  (defconstant rip-register-offset 20)
  (defun xp-mxcsr (xp)
    (with-macptrs ((state (pref xp :__ucontext.uc_mcontext.mc_fpstate)))
      (pref state :savefpu.sv_env.en_mxcsr)))
  (defmacro xp-xmm-regs (xp)
    (let* ((state (gensym)))
      `(with-macptrs ((,state (pref ,xp :__ucontext.uc_mcontext.mc_fpstate)))
        (pref ,state :savefpu.sv_xmm))))
      
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(7					;rax
      4					;rcx
      3					;rdx
      8					;rbx
      23                                ;rsp
      9					;rbp
      2                                 ;rsi
      1                                 ;rdi
      5                                 ;r8
      6                                 ;r9
      10				;r10
      11                                ;r11
      12				;r12
      13				;r13
      14				;r14
      15                                ;r15
      )))

#+darwinx8664-target
(progn
  (defconstant gp-regs-offset 0)
  (defun xp-mxcsr (xp)
     (pref xp :ucontext_t.uc_mcontext.__fs.__fpu_mxcsr))
  (defmacro xp-gp-regs (xp)
    `(pref ,xp :ucontext_t.uc_mcontext.__ss))
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp :ucontext_t.uc_mcontext.__fs.__fpu_xmm0))

  (defconstant flags-register-offset 17)
  (defconstant rip-register-offset 16)  
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(0					;rax
      2					;rcx
      3					;rdx
      1					;rbx
      7                                 ;rsp
      6					;rbp
      5                                 ;rsi
      4                                 ;rdi
      8                                 ;r8
      9                                 ;r9
      10				;r10
      11                                ;r11
      12				;r12
      13				;r13
      14				;r14
      15                                ;r15
      )))

#+solarisx8664-target
(progn
  (defconstant gp-regs-offset (+ (get-field-offset :ucontext.uc_mcontext)
                                 (get-field-offset :mcontext_t.gregs)))
  (defmacro xp-gp-regs (xp) xp)
  (defconstant flags-register-offset #$REG_RFL)
  (defconstant rip-register-offset #$REG_RIP)
  (defun xp-mxcsr (xp)
    (pref xp :ucontext.uc_mcontext.fpregs.fp_reg_set.fpchip_state.mxcsr))
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp :ucontext.uc_mcontext.fpregs.fp_reg_set.fpchip_state.xmm))
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(14                                ;rax
      13                                ;rcx
      12                                ;rdx
      11                                ;rbx
      20                                ;rsp
      10                                ;rbp
      9                                 ;rsi
      8                                 ;rdi
      7                                 ;r8
      6                                 ;r9
      5                                 ;r10
      4                                 ;r11
      3                                 ;r12
      2                                 ;r13
      1                                 ;r14
      0                                 ;r15
      )))

#+win64-target
(progn
  (defconstant gp-regs-offset (get-field-offset #>CONTEXT.Rax))
  (defmacro xp-gp-regs (xp) xp)
  (defconstant rip-register-offset 16)
  (defun xp-mxcsr (xp)
    (pref xp #>CONTEXT.MxCsr))
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp #>CONTEXT.nil.FltSave.XmmRegisters))
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(0					;rax
      1					;rcx
      2					;rdx
      3					;rbx
      4                                 ;rsp
      5					;rbp
      6                                 ;rsi
      7                                 ;rdi
      8                                 ;r8
      9                                 ;r9
      10				;r10
      11                                ;r11
      12				;r12
      13				;r13
      14				;r14
      15                                ;r15
      )))

#+darwinx8632-target
(progn
  (defconstant gp-regs-offset 0)
  (defmacro xp-gp-regs (xp)
    `(pref ,xp :ucontext_t.uc_mcontext.__ss))
  (defun xp-mxcsr (xp)
    (pref xp :ucontext_t.uc_mcontext.__fs.__fpu_mxcsr))
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp :ucontext_t.uc_mcontext.__fs.__fpu_xmm0))
  (defconstant flags-register-offset 9)
  (defconstant eip-register-offset 10)
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(0					;eax
      2					;ecx
      3					;edx
      1					;ebx
      7					;esp
      6					;ebp
      5					;esi
      4					;edi
      )))

#+linuxx8632-target
(progn
  (defconstant gp-regs-offset 0)
  (defmacro xp-gp-regs (xp)
    `(pref (pref ,xp :ucontext.uc_mcontext) :mcontext_t.gregs))
  (defun xp-mxcsr (xp)
    (pref (pref (pref xp :ucontext.uc_mcontext) :mcontext_t.fpregs)
          :_fpstate.mxcsr))
  (defmacro xp-xmm-regs (xp)
    `(pref (pref ,xp :ucontext.uc_mcontext.fpregs) :_fpstate._xmm))
  (defconstant flags-register-offset #$REG_EFL)
  (defconstant eip-register-offset #$REG_EIP)
  (defparameter *encoded-gpr-to-indexed-gpr*
    (vector
     #$REG_EAX                         ;eax
      #$REG_ECX                         ;ecx
      #$REG_EDX                         ;edx
      #$REG_EBX                         ;ebx
      #$REG_ESP                         ;esp
      #$REG_EBP                         ;ebp
      #$REG_ESI                         ;esi
      #$REG_EDI                         ;edi
      )))

#+win32-target
(progn
  (defconstant gp-regs-offset 0)
  (defmacro xp-gp-regs (xp)
    `,xp)
  (defun xp-mxcsr (xp)
    (%get-unsigned-long (pref xp #>CONTEXT.ExtendedRegisters) 24))
  (defmacro xp-xmm-regs (xp)
    `(%inc-ptr ,xp #x16c))
  (defconstant flags-register-offset 48)
  (defconstant eip-register-offset 45)
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(
     44                                ;eax
     43                                ;ecx
     42                                ;edx
     41                                ;ebx
     49                                ;esp
     45                                ;ebp
     40                                ;esi
     39                                ;edi
      )))

#+solarisx8632-target
(progn
  (defconstant gp-regs-offset 0)
  (defmacro xp-gp-regs (xp)
    `(pref (pref ,xp :ucontext.uc_mcontext) :mcontext_t.gregs))
  (defun xp-mxcsr (xp)
    (pref xp :ucontext.uc_mcontext.fpregs.fp_reg_set.fpchip_state.mxcsr))
  (defconstant flags-register-offset #$EFL)
  (defmacro xp-xmm-regs (xp)
    `(pref ,xp :ucontext.uc_mcontext.fpregs.fp_reg_set.fpchip_state.xmm))
  (defconstant eip-register-offset #$EIP)
  (defparameter *encoded-gpr-to-indexed-gpr*
    (vector
     #$EAX
     #$ECX
     #$EDX
     #$EBX
     #$ESP
     #$EBP
     #$ESI
     #$EDI)
      ))

#+freebsdx8632-target
(progn
  (defconstant gp-regs-offset 0)
  (defmacro xp-gp-regs (xp)
    `(pref ,xp :ucontext_t.uc_mcontext))
  (defun xp-mxcsr (xp)
    (pref (pref xp :ucontext_t.uc_mcontext.mc_fpstate) :savexmm.sv_env.en_mxcsr))
  (defmacro xp-xmm-regs (xp)
    `(pref (pref ,xp :ucontext_t.uc_mcontext.mc_fpstate) :savexmm.sv_xmm))
  (defconstant flags-register-offset 17)
  (defconstant eip-register-offset 15)
  (defparameter *encoded-gpr-to-indexed-gpr*
    #(
      12                                ;eax
      11                                ;ecx
      10                                ;edx
      9                                 ;ebx
      18                                ;esp
      7                                 ;ebp
      6                                 ;esi
      5                                 ;edi
      )
      ))

(defun indexed-gpr-lisp (xp igpr)
  (%get-object (xp-gp-regs xp) (+ gp-regs-offset (ash igpr target::word-shift))))
(defun (setf indexed-gpr-lisp) (new xp igpr)
  (%set-object (xp-gp-regs xp) (+ gp-regs-offset (ash igpr target::word-shift)) new))
(defun encoded-gpr-lisp (xp gpr)
  (indexed-gpr-lisp xp (aref *encoded-gpr-to-indexed-gpr* gpr)))
(defun (setf encoded-gpr-lisp) (new xp gpr)
  (setf (indexed-gpr-lisp xp (aref *encoded-gpr-to-indexed-gpr* gpr)) new))
(defun indexed-gpr-integer (xp igpr)
  #+x8664-target
  (%get-signed-long-long (xp-gp-regs xp) (+ gp-regs-offset (ash igpr x8664::word-shift)))
  #+x8632-target
  (%get-signed-long (xp-gp-regs xp) (+ gp-regs-offset (ash igpr x8632::word-shift))))
(defun (setf indexed-gpr-integer) (new xp igpr)
  (setf
   #+x8664-target
   (%get-signed-long-long (xp-gp-regs xp) (+ gp-regs-offset (ash igpr x8664::word-shift)))
   #+x8632-target
   (%get-signed-long (xp-gp-regs xp) (+ gp-regs-offset (ash igpr x8632::word-shift)))
   new))
(defun encoded-gpr-integer (xp gpr)
  (indexed-gpr-integer xp (aref *encoded-gpr-to-indexed-gpr* gpr)))
(defun (setf encoded-gpr-integer) (new xp gpr)
  (setf (indexed-gpr-integer xp (aref *encoded-gpr-to-indexed-gpr* gpr)) new))
(defun indexed-gpr-macptr (xp igpr)
  (%get-ptr (xp-gp-regs xp) (+ gp-regs-offset (ash igpr target::word-shift))))
(defun (setf indexed-gpr-macptr) (new xp igpr)
  (setf (%get-ptr (xp-gp-regs xp) (+ gp-regs-offset (ash igpr target::word-shift))) new))
(defun encoded-gpr-macptr (xp gpr)
  (indexed-gpr-macptr xp (aref *encoded-gpr-to-indexed-gpr* gpr)))
(defun (setf encoded-gpr-macptr) (new xp gpr)
  (setf (indexed-gpr-macptr xp (aref *encoded-gpr-to-indexed-gpr* gpr)) new))
(defun xp-flags-register (xp)
  #+windows-target (pref xp #>CONTEXT.EFlags)
  #-windows-target
  (progn
  #+x8664-target
  (%get-signed-long-long (xp-gp-regs xp) (+ gp-regs-offset (ash flags-register-offset x8664::fixnumshift)))
  #+x8632-target
  (%get-signed-long (xp-gp-regs xp) (+ gp-regs-offset (ash flags-register-offset x8632::fixnumshift)))))
(defmacro xp-xmm-single-float (xp n)
  `(%get-single-float (xp-xmm-regs ,xp) (ash ,n 4)))
(defmacro xp-xmm-double-float (xp n)
  `(%get-double-float (xp-xmm-regs ,xp) (ash ,n 4)))

(defun %get-xcf-byte (xcf-ptr delta)
  (let* ((containing-object (%get-object xcf-ptr target::xcf.containing-object))
         (byte-offset (%get-object xcf-ptr target::xcf.relative-pc)))
    (if containing-object
      (locally (declare (optimize (speed 3) (safety 0))
                        (type (simple-array (unsigned-byte 8) (*)) containing-object))
        (aref containing-object (the fixnum (+ byte-offset delta))))
      (let* ((high-half (%get-object xcf-ptr target::xcf.pc-high))
             (low-half (%get-object xcf-ptr target::xcf.pc-low))
	     (pc #+64-bit-target (dpb high-half (byte 32 32) low-half)
                 #+32-bit-target (dpb high-half (byte 16 16) low-half)))
	(%get-unsigned-byte (%int-to-ptr pc) delta)))))

;;; If the byte following a uuo (which is "skip" bytes long, set
;;; the xcf's relative PC to the value contained in the 32-bit
;;; word preceding the current relative PC and return -1, else return skip.
(defun %check-anchored-uuo (xcf skip)
  (if (eql 0 (%get-xcf-byte xcf skip))
    (let* ((new-rpc (+ #+x8664-target target::tag-function
		       #+x8632-target target::fulltag-misc
                       (logior (ash (%get-xcf-byte xcf -1) 24)
                               (ash (%get-xcf-byte xcf -2) 16)
                               (ash (%get-xcf-byte xcf -3) 8)
                               (%get-xcf-byte xcf -4)))))
      (%set-object xcf target::xcf.relative-pc new-rpc)
      -1)
    skip))

(defun arithmetic-error-operation-from-instruction (instruction)
  (let* ((name (make-keyword (string-upcase (x86-di-mnemonic instruction)))))
    (case name
      ((:divss :divsd :idivl :idivq) '/)
      ((:mulss :mulsd) '*)
      ((:addss :addsd) '+)
      ((:subss :subsd) '-)
      (t 'coerce))))

(defun arithmetic-error-operands-from-instruction (instruction xp)
  (let* ((name (make-keyword (string-upcase (x86-di-mnemonic instruction)))))
    (let* ((op0 (x86-di-op0 instruction))
           (op1 (x86-di-op1 instruction))
           (xmmop0 (register-operand-regno op0 #.x86::+operand-type-RegXMM+))
           (xmmop1 (register-operand-regno op1 #.x86::+operand-type-RegXMM+)))
      (collect ((opvals))
        (case name
          ((:divss :mulss :addss :subss)
           (when (and xmmop0 xmmop1)
             (opvals (xp-xmm-single-float xp xmmop1))
             (opvals (xp-xmm-single-float xp xmmop0))))
          ((:divsd :mulsd :addsd :subsd)
           (when (and xmmop0 xmmop1)
             (opvals (xp-xmm-double-float xp xmmop1))
             (opvals (xp-xmm-double-float xp xmmop0))))
          ;; (coerce a-double 'single-float) can overflow.
          (:cvtsd2ss
           (when xmmop0
             (opvals (xp-xmm-double-float xp xmmop1))
             (opvals 'single-float)))
          #+x8632-target
          (:idivl
           (let* ((reg (register-operand-regno op0 #.x86::+operand-type-Reg32+)))
             (when reg
               (opvals (logior (ash (encoded-gpr-integer xp 2) 32)
                               (logand #xfffffffff (encoded-gpr-integer xp 0))))
               (opvals (encoded-gpr-integer xp reg)))))
          #+x8664-target
          (:idivq
           (let* ((reg (register-operand-regno op0 #.x86::+operand-type-Reg64+)))
             (when reg
               (opvals (logior (ash (encoded-gpr-integer xp 2) 64)
                               (logand (1- (ash 1 64)) (encoded-gpr-integer xp 0))))
               (opvals (encoded-gpr-integer xp reg)))))
               
            
          )
        (opvals)))))


                                  
(defun decode-arithmetic-error (xp xcf)
  (declare (ignorable xp xcf))
  (let* ((code-vector (make-array 15 :element-type '(unsigned-byte 8)))
         (xfunction (%alloc-misc 1 target::subtag-xfunction)))
    (dotimes (i 15)                     ;maximum instructon size
      (setf (aref code-vector i) (%get-xcf-byte xcf i)))
    (setf (uvref xfunction 0) code-vector)
    (let* ((ds (make-x86-disassembly-state
                :mode-64 #+x8664-target t #+x8632-target nil
                :code-vector code-vector
                :constants-vector xfunction
                :entry-point 0
                :code-pointer 0           ; for next-u32/next-u16 below
                :symbolic-names nil
                :pending-labels (list 0)
                :code-limit 15
                :code-pointer 0))
           (instruction (ignore-errors (x86-disassemble-instruction ds nil))))
      (if instruction
        (values (arithmetic-error-operation-from-instruction  instruction)
                (arithmetic-error-operands-from-instruction instruction xp))
        (values 'unknown nil)))))

(eval-when (:compile-toplevel :execute)
  (progn
    (defun conditional-os-constant (alternatives)
      (dolist (c alternatives (error "None of the constants in ~s could be loaded" alternatives))
        (if (load-os-constant c t)
          (return (load-os-constant c)))))

    (defconstant integer-divide-by-zero-code
      (conditional-os-constant '(os::EXCEPTION_INT_DIVIDE_BY_ZERO os::FPE_INTDIV))
)
    (defconstant float-divide-by-zero-code
      (conditional-os-constant '(os::EXCEPTION_FLT_DIVIDE_BY_ZERO os::FPE_FLTDIV)))
    (defconstant float-overflow-code
      (conditional-os-constant '(os::FPE_FLTOVF os::EXCEPTION_FLT_OVERFLOW)))
    (defconstant float-underflow-code
      (conditional-os-constant '(os::FPE_FLTUND os::EXCEPTION_FLT_UNDERFLOW)))
    (defconstant float-inexact-code
      (conditional-os-constant '(os::FPE_FLTRES os::EXCEPTION_FLT_INEXACT_RESULT)))))

(defparameter *pending-gc-notification-hook* nil)

;;; UUOs are handled elsewhere.  This should handle all signals other than
;;; those generated by UUOs (and the non-UUO cases of things like SIGSEGV.)
;;; If the signal number is 0, other arguments (besides the exception context XP)
;;; may not be meaningful.
(defcallback xcmain (:address xp :address xcf :int signal :long code :long addr :long other :int)
  (let* ((frame-ptr (macptr->fixnum xcf))
	 (skip 0))
    (cond ((zerop signal)               ;thread interrupt
           (cmain))
          ((< signal 0)
           (if (and (zerop code)
                    (eql other arch::error-allocation-disabled))
             (restart-case (%error 'allocation-disabled nil frame-ptr)
                           (continue ()
                                     :report (lambda (stream)
                                               (format stream "retry the heap allocation."))))
             (%err-disp-internal code () frame-ptr)))
          ((= signal #$SIGFPE)
           (setq code (logand #xffffffff code))
           (multiple-value-bind (operation operands)
               (decode-arithmetic-error xp xcf)
             (let* ((condition-name
                     (cond ((or (= code integer-divide-by-zero-code)
                                (= code float-divide-by-zero-code))
                            'division-by-zero)
                           ((= code float-overflow-code)
                            'floating-point-overflow)
                           ((= code float-underflow-code)
                            'floating-point-underflow)
                           ((= code float-inexact-code)
                            'floating-point-inexact)
                           (t
                            'floating-point-invalid-operation))))
               (%error (make-condition condition-name
                                       :operation operation
                                       :operands operands
                                       :status (xp-mxcsr xp))
                       ()
                       frame-ptr))))
          ((= signal #$SIGSEGV)
	   (cond
	     ((or (= code 0) (= code 1))
	      ;; Stack overflow.
	      (let* ((on-tsp (= code 1)))
		(unwind-protect
		     (%error
		      (make-condition
		       'stack-overflow-condition 
		       :format-control "Stack overflow on ~a stack."
		       :format-arguments (list (if on-tsp "temp" "value")))
		      nil frame-ptr)
		  (ff-call (%kernel-import target::kernel-import-restore-soft-stack-limit)
			   :unsigned-fullword code
			   :void))))
	     ((= code 2)
	      ;; Write to a watched object.
	      (let* ((offset other)
		     ;; The kernel exception handler leaves the
		     ;; watched object on the lisp stack under the
		     ;; xcf.
		     (object (%get-object xcf target::xcf.size)))
		(multiple-value-bind (insn insn-length)
		    (ignore-errors (x86-faulting-instruction xp))
		  (restart-case (%error (make-condition
					 'write-to-watched-object
					 :offset offset
					 :object object
					 :instruction insn)
					nil frame-ptr)
                                #-windows-target
                                (emulate ()
                                         :test (lambda (c)
                                                 (declare (ignore c))
                                                 (x86-can-emulate-instruction insn))
                                         :report
                                         "Emulate this instruction, leaving the object watched."
                                         (flet ((watchedp (object)
                                                  (%map-areas #'(lambda (x)
                                                                  (when (eq object x)
                                                                    (return-from watchedp t)))
                                                              area-watched)))
                                           (let ((result nil))
                                             (with-other-threads-suspended
                                                 (when (watchedp object)
                                                   ;; We now trust that the object is in a
                                                   ;; static gc area.
                                                   (let* ((a (+ (%address-of object) offset))
                                                          (ptr (%int-to-ptr
                                                                (logandc2 a (1- *host-page-size*)))))
                                                     (#_mprotect ptr *host-page-size* #$PROT_WRITE)
                                                     (setq result (x86-emulate-instruction xp insn))
                                                     (#_mprotect ptr *host-page-size*
                                                                 (logior #$PROT_READ #$PROT_EXEC)))))
                                             (if result
                                               (setq skip insn-length)
                                               (error "could not emulate the instrution")))))
                                (skip ()
                                      :test (lambda (c)
                                              (declare (ignore c))
                                              insn)
                                      :report "Skip over this write instruction."
                                      (setq skip insn-length))
                                (unwatch ()
                                         :report "Unwatch the object and retry the write."
                                         (unwatch object))))))))
          ((= signal #+win32-target 10 #-win32-target #$SIGBUS)
           (if (= code -1)
             (%error (make-condition 'invalid-memory-operation)
                     ()
                     frame-ptr)
             (%error (make-condition 'invalid-memory-access
                                     :address addr
                                     :write-p (not (zerop code)))
                     ()
                     frame-ptr)))
          ((= signal #-win32-target #$SIGTRAP #+win32-target 5)
           (when (= code 0)
             (let* ((hook *pending-gc-notification-hook*))
               (declare (special *pending-gc-notification-hook*))
               (when hook (funcall hook))))))
    skip))

(defun x86-faulting-instruction (xp)
  (let* ((code-bytes (make-array 15 :element-type '(unsigned-byte 8)))
         (pc (indexed-gpr-macptr xp #+x8632-target eip-register-offset
                                    #+x8664-target rip-register-offset)))
    (dotimes (i (length code-bytes))
      (setf (aref code-bytes i) (%get-unsigned-byte pc i)))
    (let* ((ds (make-x86-disassembly-state
                :mode-64 #+x8664-target t #+x8632-target nil
                :code-vector code-bytes
                :code-pointer 0))
           (insn (x86-disassemble-instruction ds nil))
           (len (- (x86-ds-code-pointer ds) (x86-ds-insn-start ds))))
      (values insn len))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/x86-trap-support.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.
;;;

;;; At this point in the load sequence, the handful of extant basic classes
;;; exist only in skeletal form (without direct or effective slot-definitions.)

(in-package "CCL")

(defun extract-slotds-with-allocation (allocation slotds)
  (collect ((right-ones))
    (dolist (s slotds (right-ones))
      (if (eq (%slot-definition-allocation s) allocation)
        (right-ones s)))))

(defun extract-instance-direct-slotds (class)
  (extract-slotds-with-allocation :instance (%class-direct-slots class)))

(defun extract-class-direct-slotds (class)
  (extract-slotds-with-allocation :class (%class-direct-slots class)))

(defun extract-instance-effective-slotds (class)
  (extract-slotds-with-allocation :instance (%class-slots class)))

(defun extract-class-effective-slotds (class)
  (extract-slotds-with-allocation :class (%class-slots class)))

(defun extract-instance-class-and-other-slotds (slotds)
  (collect ((instance-slots)
	    (shared-slots)
            (other-slots))
    (dolist (s slotds (values (instance-slots) (shared-slots) (other-slots)))
      (case (%slot-definition-allocation s)
        (:instance (instance-slots s))
        (:class (shared-slots s))
        (t (other-slots s))))))


(defun %early-shared-initialize (instance slot-names initargs)
  (unless (or (listp slot-names) (eq slot-names t))
    (report-bad-arg slot-names '(or list (eql t))))
  ;; Check that initargs contains valid key/value pairs,
  ;; signal a PROGRAM-ERROR otherwise.  (Yes, this is
  ;; an obscure way to do so.)
  (destructuring-bind (&key &allow-other-keys) initargs)
  (let* ((wrapper (instance-class-wrapper instance))
         (class (%wrapper-class wrapper)))
    (when (eql 0 (%wrapper-hash-index wrapper)) ; obsolete
      (update-obsolete-instance instance)
      (setq wrapper (instance-class-wrapper instance)))
    (dolist (slotd (%class-slots class))
      (let* ((loc (%slot-definition-location slotd)))
        (multiple-value-bind (ignore new-value foundp)
            (get-properties initargs
                            (%slot-definition-initargs slotd))
          (declare (ignore ignore))
          (if foundp
	    (progn
	      (unless (funcall (standard-effective-slot-definition.type-predicate slotd) new-value)
		(error 'bad-slot-type-from-initarg
		       :slot-definition slotd
		       :instance instance
		       :datum new-value
		       :expected-type  (%slot-definition-type slotd)
		       :initarg-name (car foundp)))
	      (if (consp loc)
		(rplacd loc new-value)
		(setf (standard-instance-instance-location-access instance loc)
		      new-value)))
            (if (or (eq slot-names t)
                    (member (%slot-definition-name slotd)
                            slot-names
			    :test #'eq))
              (let* ((curval (if (consp loc)
                               (cdr loc)
                               (%standard-instance-instance-location-access
				instance loc))))
                (if (eq curval (%slot-unbound-marker))
                  (let* ((initfunction (%slot-definition-initfunction slotd)))
                    (if initfunction
                      (let* ((newval (funcall initfunction)))
			(unless (funcall (standard-effective-slot-definition.type-predicate slotd) newval)
			  (error 'bad-slot-type-from-initform
				 :slot-definition slotd
				 :expected-type (%slot-definition-type slotd)
				 :datum newval
				 :instance instance))
                        (if (consp loc)
                          (rplacd loc newval)
                          (setf (standard-instance-instance-location-access
				 instance loc)
				newval)))))))))))))
  instance)

(setf (fdefinition '%shared-initialize) #'%early-shared-initialize)

;;; This is redefined (to call MAKE-INSTANCE) below.
(setf (fdefinition '%make-direct-slotd)
      #'(lambda (slotd-class &key
			     name
			     initfunction
			     initform
			     initargs
			     (allocation :instance)
			     class
			     (type t)
			     (documentation (%slot-unbound-marker))
			     readers
			     writers)
	  (declare (ignore slotd-class))
	  (%instance-vector
	   (%class.own-wrapper *standard-direct-slot-definition-class*)
	   name type initfunction initform initargs allocation
	   documentation class readers writers)))

;;; Also redefined below, after MAKE-INSTANCE is possible.
(setf (fdefinition '%make-effective-slotd)
      #'(lambda (slotd-class &key
			     name
			     initfunction
			     initform
			     initargs
			     allocation
			     class
			     type
			     documentation)
	  (declare (ignore slotd-class))
	  (%instance-vector
	   (%class.own-wrapper *standard-effective-slot-definition-class*)
	   name type initfunction initform initargs allocation
	   documentation class nil (ensure-slot-id name) #'true)))


(defmethod compile-time-class-p ((class class)) nil)

(defmethod direct-slot-definition-class ((class std-class) &key  &allow-other-keys)
  *standard-direct-slot-definition-class*)

(defmethod effective-slot-definition-class ((class std-class) &key  &allow-other-keys)
  *standard-effective-slot-definition-class*)

(defun make-direct-slot-definition (class initargs)
  (apply #'%make-direct-slotd
	 (apply #'direct-slot-definition-class class initargs)
	 :class class
	 initargs))

(defun make-effective-slot-definition (class &rest initargs)
  (declare (dynamic-extent initargs))
  (apply #'%make-effective-slotd
	 (apply #'effective-slot-definition-class class initargs)
	 initargs))

;; Bootstrapping version, replaced in l1-typesys
(fset 'standardized-type-specifier
      (nlambda bootstrapping-standardized-type-specifier (spec)
        (when (and (consp spec)
                   (memq (%car spec) '(and or))
                   (consp (%cdr spec))
                   (null (%cddr spec)))
          (setq spec (%cadr spec)))
        (if (consp spec)
          (cons (%car spec) (mapcar #'standardized-type-specifier (%cdr spec)))
          (or (cdr (assoc spec '((string . base-string))))
              spec))))

;;; The type of an effective slot definition is the intersection of
;;; the types of the direct slot definitions it's initialized from.
(defun dslotd-type-intersection (direct-slots)
  (or (dolist (dslotd direct-slots t)
        (unless (eq t (%slot-definition-type dslotd))
          (return)))
      (standardized-type-specifier
       (if (cdr direct-slots)
         `(and ,@(mapcar #'(lambda (d) (or (%slot-definition-type d) t))
                         direct-slots))
         (%slot-definition-type (car direct-slots))))))

(defmethod compute-effective-slot-definition ((class slots-class)
                                              name
                                              direct-slots)
  
  (let* ((initer (dolist (s direct-slots)
                   (when (%slot-definition-initfunction s)
                     (return s))))
         (documentor (dolist (s direct-slots)
		       (when (%slot-definition-documentation s)
                         (return s))))
         (first (car direct-slots))
         (initargs (let* ((initargs nil))
                     (dolist (dslot direct-slots initargs)
                       (dolist (dslot-arg (%slot-definition-initargs  dslot))
                         (pushnew dslot-arg initargs :test #'eq))))))
    (make-effective-slot-definition
     class
     :name name
     :allocation (%slot-definition-allocation first)
     :documentation (when documentor (nth-value
				      1
				      (%slot-definition-documentation
				       documentor)))
     :class (%slot-definition-class first)
     :initargs initargs
     :initfunction (if initer (%slot-definition-initfunction initer))
     :initform (if initer (%slot-definition-initform initer))
     :type (dslotd-type-intersection direct-slots))))

(defmethod compute-slots ((class slots-class))
  (let* ((slot-name-alist ()))
    (labels ((note-direct-slot (dslot)
               (let* ((sname (%slot-definition-name dslot))
                      (pair (assq sname slot-name-alist)))
                 (if pair
                   (push dslot (cdr pair))
                   (push (list sname dslot) slot-name-alist))))
             (rwalk (tail)
               (when tail
                 (rwalk (cdr tail))
		 (let* ((c (car tail)))
		   (unless (eq c *t-class*)
		     (dolist (dslot (%class-direct-slots c))
		       (note-direct-slot dslot)))))))
      (rwalk (class-precedence-list class)))
    (collect ((effective-slotds))
      (dolist (pair (nreverse slot-name-alist) (effective-slotds))
        (effective-slotds (compute-effective-slot-definition class (car pair) (cdr pair)))))))


(defmethod compute-slots :around ((class std-class))
  (let* ((cpl (%class.cpl class)))
    (multiple-value-bind (instance-slots class-slots other-slots)
        (extract-instance-class-and-other-slotds (call-next-method))
      (setq instance-slots (sort-effective-instance-slotds instance-slots class cpl))
      (do* ((loc 1 (1+ loc))
            (islotds instance-slots (cdr islotds)))
           ((null islotds))
        (declare (fixnum loc))
        (setf (%slot-definition-location (car islotds)) loc))
      (dolist (eslotd class-slots)
        (setf (%slot-definition-location eslotd) 
              (assoc (%slot-definition-name eslotd)
                     (%class-get (%slot-definition-class eslotd)
				 :class-slots)
		     :test #'eq)))
      (append instance-slots class-slots other-slots))))

(defmethod compute-slots :around ((class structure-class))
  (let* ((slots (call-next-method))	 )
      (do* ((loc 1 (1+ loc))
            (islotds slots (cdr islotds)))
           ((null islotds) slots)
        (declare (fixnum loc))
        (setf (%slot-definition-location (car islotds)) loc))))

;;; Should eventually do something here.
;(defmethod compute-slots ((s structure-class))
;  (call-next-method))

(defmethod direct-slot-definition-class ((class structure-class) &rest initargs)
  (declare (ignore initargs))
  (find-class 'structure-direct-slot-definition))

(defmethod effective-slot-definition-class ((class structure-class) &rest  initargs)
  (declare (ignore initargs))
  (find-class 'structure-effective-slot-definition))


(defmethod compute-default-initargs ((class slots-class))
  (let* ((initargs ()))
    (dolist (c (%class-precedence-list class) (nreverse initargs))
      (if (typep c 'forward-referenced-class)
	(error
	 "Class precedence list of ~s contains FORWARD-REFERENCED-CLASS ~s ."
	 class c)
	(dolist (i (%class-direct-default-initargs c))
	  (pushnew i initargs :test #'eq :key #'car))))))




(defvar *update-slots-preserve-existing-wrapper* nil)

(defvar *optimized-dependents* (make-hash-table :test 'eq :weak :key)
  "Hash table mapping a class to a list of all objects that have been optimized to
   depend in some way on the layout of the class")

(defun note-class-dependent (class gf)
  (pushnew gf (gethash class *optimized-dependents*)))

(defun unoptimize-dependents (class)
  (pessimize-make-instance-for-class-name (%class-name class))
  (loop for obj in (gethash class *optimized-dependents*)
        do (etypecase obj
             (standard-generic-function
              (let* ((dt (%gf-dispatch-table obj))
                     (argnum (%gf-dispatch-table-argnum dt)))
                (when (< argnum 0)
                  (setf (%gf-dispatch-table-argnum dt) (lognot argnum)
                        (%gf-dcode obj) (%gf-dispatch-table-gf dt)
                        (%gf-dispatch-table-gf dt) obj)
                  (clear-gf-dispatch-table dt)))))))

(defun update-slots (class eslotds)
  (let* ((instance-slots (extract-slotds-with-allocation :instance eslotds))
         (new-ordering
          (let* ((v (make-array (the fixnum (length instance-slots))))
                 (i 0))
            (declare (simple-vector v) (fixnum i))
            (dolist (e instance-slots v)
              (setf (svref v i)
                    (%slot-definition-name e))
              (incf i))))
         (old-wrapper (%class-own-wrapper class))
         (new-wrapper
          (cond ((null old-wrapper)
                 (%cons-wrapper class))
                ((and old-wrapper *update-slots-preserve-existing-wrapper*)
                 old-wrapper)
                (t
                 (unoptimize-dependents class)
                 (make-instances-obsolete class)
                 (%cons-wrapper class)))))
    (setf (%class-slots class) eslotds)
    (setf (%wrapper-instance-slots new-wrapper) new-ordering
          (%wrapper-class-slots new-wrapper) (%class-get class :class-slots)
          (%class-own-wrapper class) new-wrapper)
    (setup-slot-lookup new-wrapper eslotds)))


  
(defun setup-slot-lookup (wrapper eslotds)
  (when eslotds
    (let* ((nslots (length eslotds))
	   (total-slot-ids (current-slot-index))
	   (small (< nslots 255))
	   (map
	    (if small
	      (make-array total-slot-ids :element-type '(unsigned-byte 8))
	      (make-array total-slot-ids :element-type '(unsigned-byte 32))))
	   (table (make-array (the fixnum (1+ nslots))))
	   (i 0))
      (declare (fixnum nslots total-slot-ids i) (simple-vector table))
      (setf (svref table 0) nil)
      (dolist (slotd eslotds)
	(incf i)
        (setf (svref table i) slotd)
        (if small
          (locally (declare (type (simple-array (unsigned-byte 8) (*)) map))
            (setf (aref map
                        (slot-id.index
                         (standard-effective-slot-definition.slot-id slotd)))
                  i))
          (locally (declare (type (simple-array (unsigned-byte 32) (*)) map))
            (setf (aref map
                        (slot-id.index
                         (standard-effective-slot-definition.slot-id slotd)))
                  i))))
      (let* ((lookup-f
              #+ppc-target
              (gvector :function
				(%svref (if small
					  #'%small-map-slot-id-lookup
					  #'%large-map-slot-id-lookup) 0)
				map
				table
				(dpb 1 $lfbits-numreq
				     (ash -1 $lfbits-noname-bit)))
              #+arm-target
              (%fix-fn-entrypoint
               (gvector :function
                       0
                       (%svref (if small
                                 #'%small-map-slot-id-lookup
                                 #'%large-map-slot-id-lookup) 1)
                       map
                       table
                       (dpb 1 $lfbits-numreq
                            (ash -1 $lfbits-noname-bit))))
              #+x86-target
              (%clone-x86-function (if small
					  #'%small-map-slot-id-lookup
					  #'%large-map-slot-id-lookup)
                                   map
                                   table
                                   (dpb 1 $lfbits-numreq
				     (ash -1 $lfbits-noname-bit))))
	     (class (%wrapper-class wrapper))
	     (get-f
              #+ppc-target
              (gvector :function
                       (%svref (if small
                                 #'%small-slot-id-value
                                 #'%large-slot-id-value) 0)
                       map
                       table
                       class
                       #'%maybe-std-slot-value-using-class
                       #'%slot-id-ref-missing
                       (dpb 2 $lfbits-numreq
                            (ash -1 $lfbits-noname-bit)))
              #+arm-target
              (%fix-fn-entrypoint
               (gvector :function
                        0
                       (%svref (if small
                                 #'%small-slot-id-value
                                 #'%large-slot-id-value) 1)
                       map
                       table
                       class
                       #'%maybe-std-slot-value-using-class
                       #'%slot-id-ref-missing
                       (dpb 2 $lfbits-numreq
                            (ash -1 $lfbits-noname-bit))))
              #+x86-target
              (%clone-x86-function (if small
                                     #'%small-slot-id-value
                                     #'%large-slot-id-value)
                                   map
                                   table
                                   class
                                   #'%maybe-std-slot-value-using-class
                                   #'%slot-id-ref-missing
                                   (dpb 2 $lfbits-numreq
                                        (ash -1 $lfbits-noname-bit))))
	     (set-f
              #+ppc-target
              (gvector :function
                       (%svref (if small
                                 #'%small-set-slot-id-value
                                 #'%large-set-slot-id-value) 0)
                       map
                       table
                       class
                       #'%maybe-std-setf-slot-value-using-class
                       #'%slot-id-set-missing
                       (dpb 3 $lfbits-numreq
                            (ash -1 $lfbits-noname-bit)))
              #+arm-target
              (%fix-fn-entrypoint
               (gvector :function
                        0
                       (%svref (if small
                                 #'%small-set-slot-id-value
                                 #'%large-set-slot-id-value) 1)
                       map
                       table
                       class
                       #'%maybe-std-setf-slot-value-using-class
                       #'%slot-id-set-missing
                       (dpb 3 $lfbits-numreq
                            (ash -1 $lfbits-noname-bit))))
              #+x86-target
              (%clone-x86-function
               (if small
                 #'%small-set-slot-id-value
                 #'%large-set-slot-id-value)
               map
               table
               class
               #'%maybe-std-setf-slot-value-using-class
               #'%slot-id-set-missing
               (dpb 3 $lfbits-numreq
                    (ash -1 $lfbits-noname-bit)))))
	(setf (%wrapper-slot-id->slotd wrapper) lookup-f
	      (%wrapper-slot-id-value wrapper) get-f
	      (%wrapper-set-slot-id-value wrapper) set-f
	      (%wrapper-slot-id-map wrapper) map
	      (%wrapper-slot-definition-table wrapper) table))))
  wrapper)

                       
    

(defmethod validate-superclass ((class class) (super class))
  (or (eq super *t-class*)
      (let* ((class-of-class (class-of class))
             (class-of-super (class-of super)))
        (or (eq class-of-class class-of-super)
            (and (eq class-of-class *standard-class-class*)
                 (eq class-of-super *funcallable-standard-class-class*))
            (and (eq class-of-class *funcallable-standard-class-class*)
                 (eq class-of-super *standard-class-class*))))))

(defmethod validate-superclass ((class foreign-class) (super standard-class))
  t)

(defmethod validate-superclass ((class std-class) (super forward-referenced-class))
  t)


(defmethod add-direct-subclass ((class class) (subclass class))
  (pushnew subclass (%class-direct-subclasses class))
  subclass)

(defmethod remove-direct-subclass ((class class) (subclass class))
  (setf (%class-direct-subclasses class)
        (remove subclass (%class-direct-subclasses class)))
  subclass)

(defun add-direct-subclasses (class new)
  (dolist (n new)
    (unless (memq class (%class-direct-subclasses  class))
      (add-direct-subclass n class))))

(defun remove-direct-subclasses (class old-supers new-supers)
  (dolist (o old-supers)
    (unless (memq o new-supers)
      (remove-direct-subclass o class))))

;;; Built-in classes are always finalized.
(defmethod class-finalized-p ((class class))
  t)

;;; Standard classes are finalized if they have a wrapper and that
;;; wrapper has an instance-slots vector; that implies that
;;; both UPDATE-CPL and UPDATE-SLOTS have been called on the class.
(defmethod class-finalized-p ((class std-class))
  (let* ((w (%class-own-wrapper class)))
    (and w (typep (%wrapper-instance-slots w) 'vector))))

(defmethod finalize-inheritance ((class std-class))
  (update-class class t))


(defmethod finalize-inheritance ((class forward-referenced-class))
  (error "Class ~s can't be finalized." class))

(defmethod class-primary-p ((class slots-class))
  (%class-primary-p class))

(defmethod (setf class-primary-p) (new (class std-class))
  (setf (%class-primary-p class) new))

(defmethod class-primary-p ((class class))
  t)

(defmethod (setf class-primary-p) (new (class class))
  new)


(defun forward-referenced-class-p (class)
  (and (%standard-instance-p class)
       (eq (%class-of-instance class) *forward-referenced-class-class*)))

;;; This uses the primary class information to sort the slots of a class.
(defun sort-effective-instance-slotds (slotds class cpl)
  (let (primary-slotds
        primary-slotds-class
        (primary-slotds-length 0))
    (declare (fixnum primary-slotds-length))
    (dolist (sup (cdr cpl))
      (unless (eq sup *t-class*)      
        (when (class-primary-p sup)
          (let ((sup-slotds (extract-instance-effective-slotds sup)))
            (if (null primary-slotds-class)
              (setf primary-slotds-class sup
                    primary-slotds sup-slotds
                    primary-slotds-length (length sup-slotds))
              (let ((sup-slotds-length (length sup-slotds)))
                (do* ((i 0 (1+ i))
                      (n (min sup-slotds-length primary-slotds-length))
                      (sup-slotds sup-slotds (cdr sup-slotds))
                      (primary-slotds primary-slotds (cdr primary-slotds)))
                     ((= i n))
                  (unless (eq (%slot-definition-name (car sup-slotds))
                              (%slot-definition-name (car primary-slotds)))
                    (error "While initializing ~s:~%~
                            attempt to mix incompatible primary classes:~%~
                            ~s and ~s"
                           class sup primary-slotds-class)))
                (when (> sup-slotds-length primary-slotds-length)
                  (setq primary-slotds-class sup
                        primary-slotds sup-slotds
                        primary-slotds-length sup-slotds-length))))))))
    (if (null primary-slotds-class)
      slotds
      (flet ((slotd-position (slotd)
               (let* ((slotd-name (%slot-definition-name slotd)))
                 (do* ((i 0 (1+ i))
                       (primary-slotds primary-slotds (cdr primary-slotds)))
                      ((= i primary-slotds-length) primary-slotds-length)
                   (declare (fixnum i))
                   (when (eq slotd-name
                                (%slot-definition-name (car primary-slotds)))
                   (return i))))))
        (declare (dynamic-extent #'slotd-position))
        (sort-list slotds '< #'slotd-position)))))




(defun update-cpl (class cpl)
  (if (class-finalized-p class)
    (unless (equal (%class.cpl class) cpl)
      (setf (%class.cpl class) cpl)
      #|(force-cache-flushes class)|#)
    (setf (%class.cpl class) cpl))
  cpl)


(defun class-has-a-forward-referenced-superclass-p (original)
  (labels ((scan-forward-refs (class seen)
             (unless (memq class seen)
               (or (if (forward-referenced-class-p class) class)
                   (let ((seen (cons class seen)))
		     (declare (dynamic-extent seen))
                     (dolist (s (%class-direct-superclasses class))
                       (when (eq s original)
                         (error "circular class hierarchy: the class ~s is a superclass of at least one of its superclasses (~s)." original class))
                       (let* ((fwdref (scan-forward-refs s seen)))
                         (when fwdref (return fwdref)))))))))
    (or (compile-time-class-p original)
        (scan-forward-refs original ()))))

(defun class-forward-referenced-superclasses (original)
  (labels ((scan-forward-refs (class seen fwdrefs)
             (unless (memq class seen)
	       (if (forward-referenced-class-p class)
		 (push class fwdrefs)
		 (let ((seen (cons class seen)))
		   (declare (dynamic-extent seen))
		   (dolist (s (%class-direct-superclasses class))
		     (when (eq s original)
		       (error "circular class hierarchy: the class ~s is a superclass of at least one of its superclasses (~s)." original class))
		     (setq fwdrefs (scan-forward-refs s seen fwdrefs))))))
	     fwdrefs))
    (scan-forward-refs original () ())))
  


(defmethod compute-class-precedence-list ((class class))
  (let* ((fwdrefs (class-forward-referenced-superclasses class)))
    (if fwdrefs
      (if (cdr fwdrefs)
	(error "Class ~s can't be finalized because superclasses ~s are not defined yet"
	       class (mapcar #'%class-name fwdrefs))
	(error "Class ~s can't be finalized because superclass ~s is not defined yet"
	       class (%class-name (car fwdrefs))))
      (compute-cpl class))))

;;; Classes that can't be instantiated via MAKE-INSTANCE have no
;;; initargs caches.
(defmethod %flush-initargs-caches ((class class))
  )

;;; Classes that have initargs caches should flush them when the
;;; class is finalized.
(defmethod %flush-initargs-caches ((class std-class))
  (setf (%class.make-instance-initargs class) nil
	(%class.reinit-initargs class) nil
	(%class.redefined-initargs class) nil
	(%class.changed-initargs class) nil))

(defun update-class (class finalizep)
  ;;
  ;; Calling UPDATE-SLOTS below sets the class wrapper of CLASS, which
  ;; makes the class finalized.  When UPDATE-CLASS isn't called from
  ;; FINALIZE-INHERITANCE, make sure that this finalization invokes
  ;; FINALIZE-INHERITANCE as per AMOP.  Note, that we can't simply
  ;; delay the finalization when CLASS has no forward referenced
  ;; superclasses because that causes bootstrap problems.
  (when (and (not (or finalizep (class-finalized-p class)))
	     (not (class-has-a-forward-referenced-superclass-p class)))
    (finalize-inheritance class)
    (return-from update-class))
  (when (or finalizep (class-finalized-p class))
    (let* ((cpl (update-cpl class (compute-class-precedence-list  class))))
      ;; This -should- be made to work for structure classes
      (update-slots class (compute-slots class))
      (setf (%class-default-initargs class) (compute-default-initargs class))
      (%flush-initargs-caches class)
      (let* ((wrapper (%class-own-wrapper class)))
        (when wrapper
          (setf (%wrapper-cpl wrapper) cpl
                (%wrapper-cpl-bits wrapper) (make-cpl-bits cpl))))))
  (unless finalizep
    (dolist (sub (%class-direct-subclasses class))
      (update-class sub nil))))

(defun add-accessor-methods (class dslotds)
  (dolist (dslotd dslotds)
    (dolist (reader (%slot-definition-readers dslotd))
      (add-reader-method class
                         (ensure-generic-function reader)
                         dslotd))
    (dolist (writer (%slot-definition-writers dslotd))
      (add-writer-method class
			 (ensure-generic-function writer)
			 dslotd))))

(defun remove-accessor-methods (class dslotds)
  (dolist (dslotd dslotds)
    (dolist (reader (%slot-definition-readers dslotd))
      (remove-reader-method class (ensure-generic-function reader :lambda-list '(x))))
    (dolist (writer (%slot-definition-writers dslotd))
      (remove-writer-method class (ensure-generic-function writer :lambda-list '(x y))))))

(defmethod reinitialize-instance :before ((class std-class)  &key direct-superclasses)
  (remove-accessor-methods class (%class-direct-slots class))
  (remove-direct-subclasses class (%class-direct-superclasses class) direct-superclasses))

(defmethod ensure-class-initialized ((class slots-class) &key
                                     (direct-superclasses nil direct-superclasses-p)
                                     (direct-slots nil direct-slots-p)
                                     (direct-default-initargs nil direct-default-initargs-p)
                                     (documentation nil doc-p)
                                     (primary-p nil primary-p-p)
                                     &allow-other-keys)
  (if direct-superclasses-p
    (progn
      (setq direct-superclasses
            (or direct-superclasses
                (list (if (typep class 'funcallable-standard-class)
                        *funcallable-standard-object-class*
                        *standard-object-class*))))
      (dolist (superclass direct-superclasses)
        (unless (validate-superclass class superclass)
          (error "The class ~S was specified as a~%super-class of the class ~S;~%~
                    but the meta-classes ~S and~%~S are incompatible."
                 superclass class (class-of superclass) (class-of class))))
      (setf (%class-direct-superclasses class) direct-superclasses))
    (setq direct-superclasses (%class-direct-superclasses class)))
  (setq direct-slots
	(if direct-slots-p
          (setf (%class-direct-slots class)
                (mapcar #'(lambda (initargs)
			    (make-direct-slot-definition class initargs))
			direct-slots))
          (%class-direct-slots class)))
  (if direct-default-initargs-p
    (setf (%class-direct-default-initargs class)  direct-default-initargs)
    (setq direct-default-initargs (%class-direct-default-initargs class)))
  (let* ((new-class-slot-cells ())
         (old-class-slot-cells (%class-get class :class-slots)))
    (dolist (slot direct-slots)
      (when (eq (%slot-definition-allocation slot) :class)
        (let* ((slot-name (%slot-definition-name slot))
               (pair (assq slot-name old-class-slot-cells)))
          ;;; If the slot existed as a class slot in the old
          ;;; class, retain the definition (even if it's unbound.)
          (unless pair
            (let* ((initfunction (%slot-definition-initfunction slot)))
              (setq pair (cons slot-name
                               (if initfunction
                                 (funcall initfunction)
                                 (%slot-unbound-marker))))))
          (push pair new-class-slot-cells))))
    (when new-class-slot-cells
      (setf (%class-get class :class-slots) new-class-slot-cells)))
  (when doc-p
    (set-documentation class 'type documentation))
  (when primary-p-p
    (setf (class-primary-p class) primary-p))

  (add-direct-subclasses class direct-superclasses)
  (update-class class nil)
  (add-accessor-methods class direct-slots))

(defmethod shared-initialize :after
  ((class slots-class)
   slot-names &key
   direct-superclasses
   direct-slots
   direct-default-initargs
   documentation
   primary-p)
  (declare (ignorable slot-names direct-superclasses 
                      direct-slots 
                      direct-default-initargs 
                      documentation 
                      primary-p))
)


(defmethod initialize-instance :before ((class class) &key &allow-other-keys)
  (setf (%class-ordinal class) (%next-class-ordinal))
  (setf (%class.ctype class) (make-class-ctype class)))

(defmethod initialize-instance :after ((class slots-class) &rest keys &key)
  (apply #'ensure-class-initialized class keys))

(defmethod reinitialize-instance :after ((class slots-class) &rest keys &key )
  (apply #'ensure-class-initialized class keys))

(defun ensure-class-metaclass-and-initargs (class args)
  (let* ((initargs (copy-list args))
         (missing (cons nil nil))
         (supplied-meta (getf initargs :metaclass missing))
         (supplied-supers (getf initargs :direct-superclasses missing))
         (supplied-slots (getf initargs :direct-slots missing))
         (metaclass (cond ((not (eq supplied-meta missing))
			   (if (typep supplied-meta 'class)
			     supplied-meta
			     (find-class supplied-meta)))
                          ((or (null class)
                               (typep class 'forward-referenced-class))
                           *standard-class-class*)
                          (t (class-of class)))))
    (declare (dynamic-extent missing))
    (flet ((fix-super (s)
             (cond ((classp s) s)
                   ((not (and s (symbolp s)))
                    (error "~s is not a class or a legal class name." s))
                   (t
                    (or (find-class s nil)
			(setf (find-class s)
			      (make-instance 'forward-referenced-class :name s))))))
           (excise-all (keys)
             (dolist (key keys)
               (loop (unless (remf initargs key) (return))))))
      (excise-all '(:metaclass :direct-superclasses :direct-slots))
      (values metaclass
              `(,@ (unless (eq supplied-supers missing)
                     `(:direct-superclasses ,(mapcar #'fix-super supplied-supers)))
                ,@ (unless (eq supplied-slots missing)
                     `(:direct-slots ,supplied-slots))
               ,@initargs)))))


;;; This defines a new class.
(defmethod ensure-class-using-class ((class null) name &rest keys &key &allow-other-keys)
  (disable-clos-optimizations "define new class" name)
  (multiple-value-bind (metaclass initargs)
      (ensure-class-metaclass-and-initargs class keys)
    (let* ((class (apply #'make-instance metaclass :name name initargs)))
      (setf (find-class name) class))))

(defmethod ensure-class-using-class ((class forward-referenced-class) name &rest keys &key &allow-other-keys)
  (disable-clos-optimizations "define new class" name)
  (multiple-value-bind (metaclass initargs)
      (ensure-class-metaclass-and-initargs class keys)
    (apply #'change-class class metaclass initargs)
    (apply #'reinitialize-instance class initargs)
    (setf (find-class name) class)))
	   
;; Can't go with optimize-make-instance-for-class-name because
;; ensure-class-using-class is called before that is defined.
(defun pessimize-make-instance-for-class-name (class-name)
  (let ((cell (find-class-cell class-name nil)))
    (when cell
      (init-class-cell-instantiator cell))))

(defun init-class-cell-instantiator (cell)
  (when cell
    (setf (class-cell-instantiate cell) '%make-instance)
    (setf (class-cell-extra cell) nil)))

;;; Redefine an existing (not forward-referenced) class.
(defmethod ensure-class-using-class ((class class) name &rest keys &key)
  (disable-clos-optimizations "redefine existing class" name)  
  (multiple-value-bind (metaclass initargs)
      (ensure-class-metaclass-and-initargs class keys)
    (unless (eq (class-of class) metaclass)
      (error "Can't change metaclass of ~s to ~s." class metaclass))
    (apply #'reinitialize-instance class initargs)
    (setf (find-class name) class)))


(defun ensure-class (name &rest keys &key &allow-other-keys)
  (declare (dynamic-extent keys))
  (apply #'ensure-class-using-class (find-class name nil) name keys))

(defparameter *defclass-redefines-improperly-named-classes-pedantically* 
   t
  "ANSI CL expects DEFCLASS to redefine an existing class only when
the existing class is properly named, the MOP function ENSURE-CLASS
redefines existing classes regardless of their CLASS-NAME.  This variable
governs whether DEFCLASS makes that distinction or not.")

(defun ensure-class-for-defclass (name &rest keys &key &allow-other-keys)
  (declare (dynamic-extent keys))
  (record-source-file name 'class)
  (let* ((existing-class (find-class name nil)))
    (when (and *defclass-redefines-improperly-named-classes-pedantically* 
	       existing-class 
	       (not (eq (class-name existing-class) name)))
      ;; Class isn't properly named; act like it didn't exist
      (setq existing-class nil))
    (apply #'ensure-class-using-class existing-class name keys)))




(defmethod method-slot-name ((m standard-accessor-method))
  (standard-direct-slot-definition.name (%accessor-method.slot-definition m)))


(defun %ensure-class-preserving-wrapper (&rest args)
  (declare (dynamic-extent args))
  (let* ((*update-slots-preserve-existing-wrapper* t))
    (apply #'ensure-class args)))

(defun %find-direct-slotd (class name)
  (dolist (dslotd (%class-direct-slots class)
           (error "Direct slot definition for ~s not found in ~s" name class))
    (when (eq (%slot-definition-name dslotd) name)
      (return dslotd))))

(defun %add-slot-readers (class-name pairs)
  (let* ((class (find-class class-name)))
    (dolist (pair pairs)
      (destructuring-bind (slot-name &rest readers) pair
        (setf (%slot-definition-readers (%find-direct-slotd class slot-name)) readers)))
    (add-accessor-methods class (%class-direct-slots class))))

(defun %add-slot-writers (class-name pairs)
  (let* ((class (find-class class-name)))
    (dolist (pair pairs)
      (destructuring-bind (slot-name &rest readers) pair
        (setf (%slot-definition-writers (%find-direct-slotd class slot-name)) readers)))
    (add-accessor-methods class (%class-direct-slots class))))


(%ensure-class-preserving-wrapper
 'standard-method
 :direct-superclasses '(method)
 :direct-slots `((:name qualifiers :initargs (:qualifiers) :initfunction ,#'false :initform nil)
                 (:name specializers :initargs (:specializers) :initfunction ,#'false :initform nil)
                 (:name function :initargs (:function))
                 (:name generic-function :initargs (:generic-function) :initfunction ,#'false :initform nil)
                 (:name name :initargs (:name) :initfunction ,#'false :initform nil)
		 (:name lambda-list :initform nil :initfunction ,#'false
		  :initargs (:lambda-list)))
 :primary-p t)

(defmethod shared-initialize :after ((method standard-method)
                                     slot-names
                                     &key function &allow-other-keys)
  (declare (ignore slot-names))
  (when function
    (let* ((inner (closure-function function)))
      (unless (eq inner function)
	(copy-method-function-bits inner function)))    
    (lfun-name function method)))

;;; Reader & writer methods classes.
(%ensure-class-preserving-wrapper
 'standard-accessor-method
 :direct-superclasses '(standard-method)
 :direct-slots '((:name slot-definition :initargs (:slot-definition)))
 :primary-p t)

(%ensure-class-preserving-wrapper
 'standard-reader-method
 :direct-superclasses '(standard-accessor-method))

(%ensure-class-preserving-wrapper
 'standard-writer-method
 :direct-superclasses '(standard-accessor-method))

(defmethod reader-method-class ((class standard-class)
				(dslotd standard-direct-slot-definition)
				&rest initargs)
  (declare (ignore initargs))
  *standard-reader-method-class*)

(defmethod reader-method-class ((class funcallable-standard-class)
				(dslotd standard-direct-slot-definition)
				&rest initargs)
  (declare (ignore  initargs))
  *standard-reader-method-class*)

(defmethod add-reader-method ((class slots-class) gf dslotd)
  (let* ((initargs
	  `(:qualifiers nil
	    :specializers ,(list class)
	    :lambda-list (,(or (%class-name class) 'instance))
	    :name ,(function-name gf)
	    :slot-definition ,dslotd))
	 (reader-method-class
	  (apply #'reader-method-class class dslotd initargs))
	 (method-function (create-reader-method-function
			   class (class-prototype reader-method-class) dslotd))
         (method (apply #'make-instance reader-method-class
			:function method-function
			initargs)))
    (declare (dynamic-extent initargs))
    (record-source-file method 'reader-method)
    (add-method gf method)))

(defmethod remove-reader-method ((class std-class) gf)
  (let* ((method (find-method gf () (list class) nil)))
    (when method (remove-method gf method))))

(defmethod writer-method-class ((class standard-class)
				(dslotd standard-direct-slot-definition)
				&rest initargs)
  (declare (ignore initargs))
  *standard-writer-method-class*)

(defmethod writer-method-class ((class funcallable-standard-class)
				(dslotd standard-direct-slot-definition)
				&rest initargs)
  (declare (ignore initargs))
  *standard-writer-method-class*)


(defmethod add-writer-method ((class slots-class) gf dslotd)
  (let* ((initargs
	  `(:qualifiers nil
	    :specializers ,(list *t-class* class)
	    :lambda-list (new-value ,(or (%class-name class) 'instance))
	    :name ,(function-name gf)
	    :slot-definition ,dslotd))
	 (method-class (apply #'writer-method-class class dslotd initargs))
	 (method 
	  (apply #'make-instance
		 method-class
		 :function (create-writer-method-function
			    class
			    (class-prototype method-class)
			    dslotd)
		 initargs)))
    (declare (dynamic-extent initargs))
    (record-source-file method 'writer-method)
    (add-method gf method)))

(defmethod remove-writer-method ((class std-class) gf)
  (let* ((method (find-method gf () (list *t-class* class) nil)))
    (when method (remove-method gf method))))

;;; We can now define accessors.  Fix up the slots in the classes defined
;;; thus far.

(%add-slot-readers 'standard-method '((qualifiers method-qualifiers)
				      (specializers method-specializers)
				      (name method-name)
				      ;(function method-function)
				      (generic-function method-generic-function)
				      (lambda-list method-lambda-list)))

(%add-slot-writers 'standard-method '((function (setf method-function))
				      (generic-function (setf method-generic-function))))


(defmethod method-function ((m standard-method))
  (%method.function m))


(%add-slot-readers 'standard-accessor-method
		   '((slot-definition accessor-method-slot-definition)))


(%ensure-class-preserving-wrapper
 'specializer
 :direct-superclasses '(metaobject)
 :direct-slots `((:name direct-methods
		  :readers (specializer-direct-methods)
		  :initform nil :initfunction ,#'false))
 :primary-p t)
		  
(%ensure-class-preserving-wrapper
 'eql-specializer
 :direct-superclasses '(specializer)
 :direct-slots '((:name object :initargs (:object) :readers (eql-specializer-object)))
 :primary-p t)


(%ensure-class-preserving-wrapper
 'class
 :direct-superclasses '(specializer)
 :direct-slots
 `((:name prototype :initform nil :initfunction ,#'false)
   (:name name :initargs (:name) :initform nil :initfunction ,#'false :readers (class-name))
   (:name precedence-list :initform nil  :initfunction ,#'false)
   (:name own-wrapper :initform nil  :initfunction ,#'false :readers (class-own-wrapper) :writers ((setf class-own-wrapper)))
   (:name direct-superclasses  :initform nil  :initfunction ,#'false :readers (class-direct-superclasses))
   (:name direct-subclasses  :initform nil  :initfunction ,#'false :readers (class-direct-subclasses))
   (:name dependents :initform nil :initfunction ,#'false)
   (:name class-ctype :initform nil :initfunction ,#'false)
   (:name direct-slots :initform nil :initfunction ,#'false
                  :readers (class-direct-slots)
		  :writers ((setf class-direct-slots)))
   (:name slots :initform nil :initfunction ,#'false
    :readers (class-slots)
    :writers ((setf class-slots)))
   (:name info :initform (cons nil nil) :initfunction ,(lambda () (cons nil nil)) :readers (class-info))
   (:name direct-default-initargs  :initform nil  :initfunction ,#'false :readers (class-direct-default-initargs))
   (:name default-initargs :initform nil  :initfunction ,#'false :readers (class-default-initargs)))
 :primary-p t)

(%ensure-class-preserving-wrapper
 'forward-referenced-class
 :direct-superclasses '(class))



(%ensure-class-preserving-wrapper
 'built-in-class
 :direct-superclasses '(class))


(%ensure-class-preserving-wrapper
 'slots-class
 :direct-superclasses '(class)
 :direct-slots `((:name alist :initform nil  :initfunction ,#'false))
 :primary-p t)

;;; This class exists only so that standard-class & funcallable-standard-class
;;; can inherit its slots.
(%ensure-class-preserving-wrapper
 'std-class
 :direct-superclasses '(slots-class)
 :direct-slots `(
                 (:name make-instance-initargs :initform nil  :initfunction ,#'false)
                 (:name reinit-initargs :initform nil  :initfunction ,#'false)
                 (:name redefined-initargs :initform nil :initfunction ,#'false)
                 (:name changed-initargs :initform nil  :initfunction ,#'false))
 :primary-p t)



(%ensure-class-preserving-wrapper
 'standard-class
 :direct-superclasses '(std-class))

(%ensure-class-preserving-wrapper
 'funcallable-standard-class
 :direct-superclasses '(std-class))


(%ensure-class-preserving-wrapper
 'funcallable-standard-object
#|| 
 :direct-superclasses '(standard-object function)
||#
 :direct-slots `((:name name :initargs (:name) :readers (generic-function-name)))
 :metaclass 'funcallable-standard-class)

(%ensure-class-preserving-wrapper
 'generic-function
 :direct-superclasses '(metaobject funcallable-standard-object)
 :direct-slots `(
		 (:name method-combination :initargs (:method-combination)
                  :initform *standard-method-combination*
                  :initfunction ,#'(lambda () *standard-method-combination*)
		  :readers (generic-function-method-combination))
                 (:name method-class :initargs (:method-class)
                  :initform *standard-method-class*
                  :initfunction ,#'(lambda () *standard-method-class*)
		  :readers (generic-function-method-class))
		 (:name methods :initargs (:methods)
		  :initform nil :initfunction ,#'false
		  :readers (generic-function-methods))
		 (:name declarations
		  :initargs (:declarations)
		  :initform nil :initfunction ,#'false
		  :readers (generic-function-declarations))
                 (:name %lambda-list
                  :initform :unspecified
                  :initfunction ,(constantly :unspecified))
		 (:name dependents
		  :initform nil :initfunction ,#'false)) 
 :metaclass 'funcallable-standard-class)



(%ensure-class-preserving-wrapper
 'standard-generic-function
 :direct-superclasses '(generic-function)

 :metaclass 'funcallable-standard-class
 :primary-p t)

(%ensure-class-preserving-wrapper
 'standard-generic-function
 :direct-superclasses '(generic-function)

 :metaclass 'funcallable-standard-class)

(%ensure-class-preserving-wrapper
 'structure-class
 :direct-superclasses '(slots-class))

(%ensure-class-preserving-wrapper
 'slot-definition
 :direct-superclasses '(metaobject)
  :direct-slots `((:name name :initargs (:name) :readers (slot-definition-name)
		  :initform nil :initfunction ,#'false)
		 (:name type :initargs (:type) :readers (slot-definition-type)
		  :initform t :initfunction ,#'true)
		 (:name initfunction :initargs (:initfunction) :readers (slot-definition-initfunction)
		  :initform nil :initfunction ,#'false)
		 (:name initform :initargs (:initform) :readers (slot-definition-initform)
		  :initform nil :initfunction ,#'false)
		 (:name initargs :initargs (:initargs) :readers (slot-definition-initargs)
		  :initform nil :initfunction ,#'false)
		 (:name allocation :initargs (:allocation) :readers (slot-definition-allocation)
		  :initform :instance :initfunction ,(constantly :instance))
		 (:name documentation :initargs (:documentation) :readers (slot-definition-documentation)
		  :initform nil :initfunction ,#'false)
		 (:name class :initargs (:class) :readers (slot-definition-class)))
  
 :primary-p t)

(%ensure-class-preserving-wrapper
 'direct-slot-definition
 :direct-superclasses '(slot-definition)
 :direct-slots `((:name readers :initargs (:readers) :initform nil
		  :initfunction ,#'false :readers (slot-definition-readers))
		 (:name writers :initargs (:writers) :initform nil
		  :initfunction ,#'false :readers (slot-definition-writers))))

(%ensure-class-preserving-wrapper
 'effective-slot-definition
 :direct-superclasses '(slot-definition)
 :direct-slots `((:name location :initform nil :initfunction ,#'false
		  :readers (slot-definition-location))
		 (:name slot-id :initform nil :initfunction ,#'false
                  :readers (slot-definition-slot-id))
		 (:name type-predicate :initform nil
		  :initfunction ,#'false
		  :readers (slot-definition-predicate))
		 )
 
 :primary-p t)

(%ensure-class-preserving-wrapper
 'standard-slot-definition
 :direct-superclasses '(slot-definition)
)







(%ensure-class-preserving-wrapper
 'standard-direct-slot-definition
 :direct-superclasses '(standard-slot-definition direct-slot-definition)
)

(%ensure-class-preserving-wrapper
 'standard-effective-slot-definition
 :direct-superclasses '(standard-slot-definition effective-slot-definition))

		 


      
                             



;;; Fake method-combination, redefined in lib;method-combination.
(unless *type-system-initialized*
 (defclass method-combination (metaobject) 
   ((name :initarg :name))))




(defclass standard-method-combination (method-combination) ())

(initialize-instance *standard-method-combination* :name 'standard)

(setq *standard-kernel-method-class*
  (defclass standard-kernel-method (standard-method)
    ()))

(unless *standard-method-combination*
  (setq *standard-method-combination*
        (make-instance 'standard-method-combination :name 'standard)))

;;; For %compile-time-defclass
(defclass compile-time-class (class) ())

(defmethod compile-time-class-p ((class compile-time-class))
  t)

(defmethod class-finalized-p ((class compile-time-class))
  nil)


(defclass structure-slot-definition (slot-definition) ())
(defclass structure-effective-slot-definition (structure-slot-definition
					       effective-slot-definition)
    ())

(defclass structure-direct-slot-definition (structure-slot-definition
					    direct-slot-definition)
    ())

(defmethod shared-initialize :after ((class structure-class)
                                     slot-names
                                     &key
                                     (direct-superclasses nil direct-superclasses-p)
				     &allow-other-keys)
  (declare (ignore slot-names))
  (labels ((obsolete (class)
             (dolist (sub (%class-direct-subclasses class)) (obsolete sub))
             ;;Need to save old class info in wrapper for obsolete
             ;;instance access...
             (setf (%class.cpl class) nil)))
    (obsolete class)
    (when direct-superclasses-p
      (let* ((old-supers (%class-direct-superclasses class))
             (new-supers direct-superclasses))
        (dolist (c old-supers)
          (unless (memq c new-supers)
            (remove-direct-subclass c class)))
        (dolist (c new-supers)
          (unless (memq c old-supers)
            (add-direct-subclass c class)))
        (setf (%class.local-supers class) new-supers)))
    (let* ((wrapper (or (%class-own-wrapper class)
                        (setf (%class-own-wrapper class) (%cons-wrapper class))))
           (cpl (compute-cpl class)))
      (setf (%class.cpl class) cpl)
      (setf (%wrapper-cpl wrapper) cpl
            (%wrapper-cpl-bits wrapper) (make-cpl-bits cpl)))))
              

                                     
                                     
;;; Called from DEFSTRUCT expansion.
(defun %define-structure-class (sd)
  (let* ((dslots ()))
    (dolist (ssd (cdr (sd-slots sd)) (setq dslots (nreverse dslots)))
      (let* ((type (ssd-type ssd))
	     (refinfo (ssd-refinfo ssd)))
	(unless (logbitp $struct-inherited refinfo)
	  (let* ((name (ssd-name ssd))
		 (initform (cadr ssd))
		 (initfunction (constantly initform)))
	    (push `(:name ,name :type ,type :initform ,initform :initfunction ,initfunction :initargs ,(list (make-keyword name))) dslots)))))
    (ensure-class (sd-name sd)
		  :metaclass 'structure-class
		  :direct-superclasses (list (or (cadr (sd-superclasses sd)) 'structure-object))
		  :direct-slots  dslots 
		  )))


(defun standard-instance-access (instance location)
  (etypecase location
    (fixnum (%standard-instance-instance-location-access instance location))
    (cons (%cdr location))))

(defun (setf standard-instance-access) (new instance location)
  (etypecase location
    (fixnum (setf (standard-instance-instance-location-access instance location)
		  new))
    (cons (setf (%cdr location) new))))

(defun funcallable-standard-instance-access (instance location)
  (etypecase location
    (fixnum (%standard-generic-function-instance-location-access instance location))
    (cons (%cdr location))))

(defun (setf funcallable-standard-instance-access) (new instance location)
  (etypecase location
    (fixnum (setf (%standard-generic-function-instance-location-access instance location) new))
    (cons (setf (%cdr location) new))))

;;; Handle a trap from %slot-ref
(defun %slot-unbound-trap (slotv idx frame-ptr)
  (let* ((instance nil)
	 (class nil)
	 (slot nil))
    (if (and (eq (typecode slotv) target::subtag-slot-vector)
	     (setq instance (slot-vector.instance slotv))
	     (setq slot
		   (find idx (class-slots (setq class (class-of instance)))
			 :key #'slot-definition-location)))
      (slot-unbound class instance (slot-definition-name slot))
      (%error "Unbound slot at index ~d in ~s" (list idx slotv) frame-ptr))))


;;;
;;; Now that CLOS is nominally bootstrapped, it's possible to redefine some
;;; of the functions that really should have been generic functions ...
(setf (fdefinition '%class-name) #'class-name
      (fdefinition '%class-default-initargs) #'class-default-initargs
      (fdefinition '%class-direct-default-initargs) #'class-direct-default-initargs
      (fdefinition '(setf %class-direct-default-initargs))
      #'(lambda (new class)
	  (if (typep class 'slots-class)
	    (setf (slot-value class 'direct-default-initargs) new)
	    new))
      (fdefinition '%class-direct-slots) #'class-direct-slots
      (fdefinition '(setf %class-direct-slots))
		   #'(setf class-direct-slots)
      (fdefinition '%class-slots) #'class-slots
      (fdefinition '%class-direct-superclasses) #'class-direct-superclasses
      (fdefinition '(setf %class-direct-superclasses))
      #'(lambda (new class)
	  (setf (slot-value class 'direct-superclasses) new))
      (fdefinition '%class-direct-subclasses) #'class-direct-subclasses
      ;(fdefinition '%class-own-wrapper) #'class-own-wrapper
      (fdefinition '(setf %class-own-wrapper)) #'(setf class-own-wrapper)
)



(setf (fdefinition '%slot-definition-name) #'slot-definition-name
      (fdefinition '%slot-definition-type) #'slot-definition-type
      (fdefinition '%slot-definition-initargs) #'slot-definition-initargs
      (fdefinition '%slot-definition-allocation) #'slot-definition-allocation
      (fdefinition '%slot-definition-location) #'slot-definition-location
      (fdefinition '%slot-definition-readers) #'slot-definition-readers
      (fdefinition '%slot-definition-writers) #'slot-definition-writers)


(setf (fdefinition '%method-qualifiers) #'method-qualifiers
      (fdefinition '%method-specializers) #'method-specializers
      (fdefinition '%method-function) #'method-function
      (fdefinition '(setf %method-function)) #'(setf method-function)
      (fdefinition '%method-gf) #'method-generic-function
      (fdefinition '(setf %method-gf)) #'(setf method-generic-function)
      (fdefinition '%method-name) #'method-name
      (fdefinition '%method-lambda-list) #'method-lambda-list
      )

(setf (fdefinition '%add-method) #'add-method)
		   
      
;;; Make a direct-slot-definition of the appropriate class.
(defun %make-direct-slotd (slotd-class &rest initargs)
  (declare (dynamic-extent initargs))
  (apply #'make-instance slotd-class initargs))

;;; Likewise, for an effective-slot-definition.
(defun %make-effective-slotd (slotd-class &rest initargs)
  (declare (dynamic-extent initargs))
  (apply #'make-instance slotd-class initargs))

;;; Likewise, for methods
(defun %make-method-instance (class &rest initargs)
  (apply #'make-instance class initargs))

(defmethod initialize-instance :after ((slotd effective-slot-definition) &key name)
  (setf (standard-effective-slot-definition.slot-id slotd)
        (ensure-slot-id name)))

  
(defmethod specializer-direct-generic-functions ((s specializer))
  (let* ((gfs ())
	 (methods (specializer-direct-methods s)))
    (dolist (m methods gfs)
      (let* ((gf (method-generic-function m)))
	(when gf (pushnew gf gfs))))))

(defmethod generic-function-lambda-list ((gf standard-generic-function))
  (%maybe-compute-gf-lambda-list gf (car (generic-function-methods gf))))

(defmethod generic-function-argument-precedence-order
    ((gf standard-generic-function))
  (let* ((req (required-lambda-list-args (generic-function-lambda-list gf)))
	 (apo (%gf-dispatch-table-precedence-list
	       (%gf-dispatch-table gf))))
    (if (null apo)
      req
      (mapcar #'(lambda (n) (nth n req)) apo))))

(defun normalize-egf-keys (keys gf)
  (let* ((missing (cons nil nil))
	 (env (getf keys :environment nil)))
    (declare (dynamic-extent missing))
    (remf keys :environment)
    (let* ((gf-class (getf keys :generic-function-class missing))
	   (mcomb (getf keys :method-combination missing))
	   (method-class (getf keys :method-class missing)))
      (if (eq gf-class missing)
	(setf gf-class (if gf (class-of gf) *standard-generic-function-class*))
	(progn
	  (remf keys :generic-function-class)
	  (if (typep gf-class 'symbol)
	    (setq gf-class
		  (find-class gf-class t env)))
	  (unless (or (eq gf-class *standard-generic-function-class*)
		      (subtypep gf-class *generic-function-class*))
	    (error "Class ~S is not a subclass of ~S"
                   gf-class *generic-function-class*))))
      (unless (eq mcomb missing)
	(unless (typep mcomb 'method-combination)
	  (setf (getf keys :method-combination)
		(find-method-combination (class-prototype gf-class)
					 (car mcomb)
					 (cdr mcomb)))))
      (unless (eq method-class missing)
	(if (typep method-class 'symbol)
	  (setq method-class (find-class method-class t env)))
	(unless (subtypep method-class *method-class*)
	  (error "~s is not a subclass of ~s" method-class *method-class*))
	(setf (getf keys :method-class) method-class))
      (values gf-class keys))))
    
(defmethod ensure-generic-function-using-class
    ((gf null)
     function-name
     &rest keys
     &key
     &allow-other-keys)
  (declare (dynamic-extent keys))
  (multiple-value-bind (gf-class initargs)
      (normalize-egf-keys keys nil)
    (let* ((gf (apply #'make-instance gf-class
		      :name function-name
		      initargs)))
      (setf (fdefinition function-name) gf))))

(defparameter *error-on-gf-class-redefinition* nil
  "The MOP spec requires ENSURE-GENERIC-FUNCTION-USING-CLASS of an
   existing gf to signal an error if the :GENERIC-FUNCTION-CLASS
   argument specifies a class other than the existing gf's class.
   ANSI CL allows this kind of redefinition if the classes are
   \"compatible\", but doesn't define what compatibility means
   in this case.  When *ERROR-ON-GF-CLASS-REDEFINITION* is true,
   a continuable error is signaled.

   Historically, Clozure CL CERRORed, but didn't offer a useful
   CHANGE-CLASS method that would change the GF's class")

(defmethod ensure-generic-function-using-class
    ((gf generic-function)
     function-name
     &rest keys
     &key
     &allow-other-keys)
  (declare (dynamic-extent keys) (ignorable function-name))
  (multiple-value-bind (gf-class initargs)
      (normalize-egf-keys keys gf)
    (unless (eq gf-class (class-of gf))
      (when *error-on-gf-class-redefinition*
        (cerror (format nil "Change the class of ~s to ~s." gf gf-class)
                "The class of the existing generic function ~s is not ~s"
                gf gf-class))
      (change-class gf gf-class))
    (apply #'reinitialize-instance gf initargs)))


(defmethod initialize-instance :before ((instance generic-function)
                                       &key &allow-other-keys)
  (setf (%gf-dcode instance)  #'%%0-arg-dcode))

(defmethod initialize-instance :after ((gf standard-generic-function)
				       &key
				       (lambda-list nil ll-p)
				       (argument-precedence-order nil apo-p)
				       &allow-other-keys)
  (if (and apo-p (not ll-p))
    (error
     "Cannot specify :ARGUMENT-PRECEDENCE-ORDER without specifying :LAMBDA-LIST"))
  (if ll-p
    (progn
      (unless (verify-lambda-list lambda-list)
	(error "~s is not a valid generic function lambda list" lambda-list))
      (if apo-p
	(set-gf-arg-info gf :lambda-list lambda-list
			 :argument-precedence-order argument-precedence-order)
	(set-gf-arg-info gf :lambda-list lambda-list)))
    (set-gf-arg-info gf))
  (if (gf-arg-info-valid-p gf)
    (compute-dcode gf (%gf-dispatch-table gf)))
  gf)

(defmethod reinitialize-instance :after ((gf standard-generic-function)
					 &rest args
					 &key
					 (lambda-list nil ll-p)
					 (argument-precedence-order nil apo-p)
					 &allow-other-keys)
  (if (and apo-p (not ll-p))
    (error
     "Cannot specify :ARGUMENT-PRECEDENCE-ORDER without specifying :LAMBDA-LIST"))
  (if ll-p
    (progn
      (unless (verify-lambda-list lambda-list)
	(error "~s is not a valid generic function lambda list" lambda-list))
      (if apo-p
	(set-gf-arg-info gf :lambda-list lambda-list
			 :argument-precedence-order argument-precedence-order)
	(set-gf-arg-info gf :lambda-list lambda-list)))
    (set-gf-arg-info gf))
  (if (and (gf-arg-info-valid-p gf)
	   args
	   (or ll-p (cddr args)))
    (compute-dcode gf (%gf-dispatch-table gf)))
  (when (sgf.dependents gf)
    (map-dependents gf #'(lambda (d)
			   (apply #'update-dependent gf d args))))
  gf)
  

(defun decode-method-lambda-list (method-lambda-list)
  (flet ((bad ()
	   (error "Invalid lambda-list syntax in ~s" method-lambda-list)))
    (collect ((specnames)
                    (required))
       (do* ((tail method-lambda-list (cdr tail))
	     (head (car tail) (car tail)))
	    ((or (null tail) (member head lambda-list-keywords))
	     (if (verify-lambda-list tail)
	       (values (required) tail (specnames))
	       (bad)))
	 (cond ((atom head)
		(unless (typep head 'symbol) (bad))
		(required head)
		(specnames t))
	       (t
		(unless (and (typep (car head) 'symbol)
			     (consp (cdr head))
			     (null (cddr head)))
		  (bad))
		(required (car head))
		(specnames (cadr head))))))))
  
(defun extract-specializer-names (method-lambda-list)
  (nth-value 2 (decode-method-lambda-list method-lambda-list)))

(defun extract-lambda-list (method-lambda-list)
  (multiple-value-bind (required tail)
      (decode-method-lambda-list method-lambda-list)
    (nconc required tail)))

(setf (fdefinition '%ensure-generic-function-using-class)
      #'ensure-generic-function-using-class)


(defmethod shared-initialize :after ((gf generic-function) slot-names
				     &key
				     (documentation nil doc-p))
  (declare (ignore slot-names))
  (when doc-p
    (if documentation (check-type documentation string))
    (set-documentation gf t documentation)))




(defmethod allocate-instance ((b built-in-class) &rest initargs)
  (declare (ignore initargs))
  (error "Can't allocate instances of BUILT-IN-CLASS."))

(defmethod reinitialize-instance ((m method) &rest initargs)
  (declare (ignore initargs))
  (error "Can't reinitialze ~s ~s" (class-of m) m))

(defmethod add-dependent ((class class) dependent)
  (pushnew dependent (%class.dependents class)))

(defmethod add-dependent ((gf standard-generic-function) dependent)
  (pushnew dependent (sgf.dependents gf)))

(defmethod remove-dependent ((class class) dependent)
  (setf (%class.dependents class)
	(delete dependent (%class.dependents class))))

(defmethod remove-dependent ((gf standard-generic-function) dependent)
  (setf (sgf.dependents gf)
	(delete dependent (sgf.dependents gf))))

(defmethod map-dependents ((class class) function)
  (dolist (d (%class.dependents class))
    (funcall function d)))

(defmethod map-dependents ((gf standard-generic-function) function)
  (dolist (d (sgf.dependents gf))
    (funcall function d)))

(defgeneric update-dependent (metaobject dependent &rest initargs))

(defmethod reinitialize-instance :after ((class std-class) &rest initargs)
  (map-dependents class #'(lambda (d)
			    (apply #'update-dependent class d initargs))))


(defun %allocate-gf-instance (class)
  (unless (class-finalized-p class)
    (finalize-inheritance class))
  (let* ((wrapper (%class.own-wrapper class))
         (gf-p (member *generic-function-class* (%class-cpl class)))
	 (len (length (%wrapper-instance-slots wrapper)))
	 (dt (if gf-p (make-gf-dispatch-table)))
	 (slots (allocate-typed-vector :slot-vector (1+ len) (%slot-unbound-marker)))
	 (fn
          #+ppc-target
           (gvector :function
                    *unset-fin-code*
                    wrapper
                    slots
                    dt
                    #'false
                    0
                    (logior (ash 1 $lfbits-gfn-bit)
                            (ash 1 $lfbits-aok-bit)))
           #+x86-target
           (%clone-x86-function #'unset-fin-trampoline
                                wrapper
                                slots
                                dt
                                #'false
                                0
                                (logior (ash 1 $lfbits-gfn-bit)
                                        (ash 1 $lfbits-aok-bit)))
           #+arm-target
           (%fix-fn-entrypoint
            (gvector :function
                     0
                    *unset-fin-code*
                    wrapper
                    slots
                    dt
                    #'false
                    0
                    (logior (ash 1 $lfbits-gfn-bit)
                            (ash 1 $lfbits-aok-bit))))))
    (setf (slot-vector.instance slots) fn)
    (when dt
      (setf (%gf-dispatch-table-gf dt) fn))
    (if gf-p
      (push fn (population.data %all-gfs%)))
    fn))


(defmethod slot-value-using-class ((class structure-class)
				   instance
				   (slotd structure-effective-slot-definition))
  (let* ((loc (standard-effective-slot-definition.location slotd)))
      (typecase loc
	(fixnum
	 (struct-ref  instance loc))
	(t
	 (error "Slot definition ~s has invalid location ~s (allocation ~s)."
		slotd loc (slot-definition-allocation slotd))))))

;;; Some STRUCTURE-CLASS leftovers.
(defmethod (setf slot-value-using-class)
    (new
     (class structure-class)
     instance
     (slotd structure-effective-slot-definition))
  (let* ((loc (standard-effective-slot-definition.location slotd))
	 (type (standard-effective-slot-definition.type slotd)))
    (if (and type (not (eq type t)))
      (unless (or (eq new (%slot-unbound-marker))
		  (typep new type))
	(setq new (require-type new type))))
    (typecase loc
      (fixnum
       (setf (struct-ref instance loc) new))
      (t
       (error "Slot definition ~s has invalid location ~s (allocation ~s)."
	      slotd loc (slot-definition-allocation slotd))))))

(defmethod slot-boundp-using-class ((class structure-class)
				    instance
				    (slotd structure-effective-slot-definition))
  (declare (ignore instance))
  t)

;;; This has to be somewhere, so it might as well be here.
(defmethod make-load-form ((s slot-id) &optional env)
  (declare (ignore env))
  `(ensure-slot-id ,(slot-id.name s)))

(defmethod make-load-form ((c class-cell) &optional env)
  (declare (ignore env))
  `(find-class-cell ',(class-cell-name c) t))



(defmethod (setf class-name) (new (class class))
  (check-type new symbol)
  (when (and (standard-instance-p class)
             (%class-kernel-p class)
             (not (eq new (%class.name class)))
             *warn-if-redefine-kernel*)
    (cerror "Change the name of ~s to ~s."
            "The class ~s may be a critical part of the system;
changing its name to ~s may have serious consequences." class new))
  (let* ((old-name (class-name class)))
    (if (eq (find-class old-name nil) class)
      (progn
        (setf (info-type-kind old-name) nil)
        (clear-type-cache))))
  (when (eq (find-class new nil) class)
    (when (%deftype-expander new)
      (cerror "Change the name of ~S anyway, removing the DEFTYPE definition."
              "Changing the name of ~S to ~S would conflict with the type defined by DEFTYPE."
              class new)
      (%deftype new nil nil))
    (setf (info-type-kind new) :instance)
    (clear-type-cache))
  (reinitialize-instance class :name new)
  (setf (%class-proper-name class)
        (if (eq (find-class new nil) class)
          new))
  new)


;;; From Tim Moore, as part of a set of patches to support funcallable
;;; instances.

;;; Support for objects with metaclass funcallable-instance-class that are not
;;; standard-generic-function. The objects still look a lot like generic
;;; functions, complete with vestigial dispatch
;;; tables. set-funcallable-instance-function will work on generic functions,
;;; though after that it won't be much of a generic function.





(defun set-funcallable-instance-function (funcallable-instance function)
  (unless (typep funcallable-instance 'funcallable-standard-object)
    (error "~S is not a funcallable instance" funcallable-instance))
  (unless (functionp function)
    (error "~S is not a function" function))
  (setf (%gf-dcode funcallable-instance) function))

(defmethod reinitialize-instance ((slotd slot-definition) &key &allow-other-keys)
  (error "Can't reinitialize ~s" slotd))

(defmethod (setf generic-function-name) (new-name (gf generic-function))
  (reinitialize-instance gf :name new-name))

;;; Are we CLOS yet ?

(defun %shared-initialize (instance slot-names initargs)
  (unless (or (listp slot-names) (eq slot-names t))
    (report-bad-arg slot-names '(or list (eql t))))
  ;; Check that initargs contains valid key/value pairs,
  ;; signal a PROGRAM-ERROR otherwise.  (Yes, this is
  ;; an obscure way to do so.)
  (destructuring-bind (&key &allow-other-keys) initargs)
  ;; I'm not sure if there's a more portable way of detecting
  ;; obsolete instances.  This'll eventually call
  ;; UPDATE-INSTANCE-FOR-REDEFINED-CLASS if it needs to.
  (let* ((wrapper (if (eq (typecode instance) target::subtag-instance)
                    (instance.class-wrapper instance)
                    (instance-class-wrapper instance)))
         (class (%wrapper-class wrapper)))
    (when (eql 0 (%wrapper-hash-index wrapper)) ; obsolete
      (update-obsolete-instance instance))
    ;; Now loop over all of the class's effective slot definitions.
    (dolist (slotd (class-slots class))
      ;; Anything that inherits from STANDARD-EFFECTIVE-SLOT-DEFINITION
      ;; in Clozure CL will have a CCL::TYPE-PREDICATE slot.  It's not
      ;; well-defined to inherit from EFFECTIVE-SLOT-DEFINITION without
      ;; also inheriting from STANDARD-EFFECTIVE-SLOT-DEFINITION,
      ;; and I'd rather not check here.  If you really want to
      ;; create that kind of slot definition, write your own SHARED-INITIALIZE
      ;; method for classes that use such slot definitions ...
      (let* ((predicate (slot-definition-predicate slotd)))
        (multiple-value-bind (ignore new-value foundp)
            (get-properties initargs (slot-definition-initargs slotd))
          (declare (ignore ignore))
          (cond (foundp
                 ;; an initarg for the slot was passed to this function
                 ;; Typecheck the new-value, then call
                 ;; (SETF SLOT-VALUE-USING-CLASS)
                 (unless (or (null predicate)
                             (funcall predicate new-value))
                   (error 'bad-slot-type-from-initarg
                          :slot-definition slotd
                          :instance instance
                          :datum new-value
                          :expected-type  (slot-definition-type slotd)
                          :initarg-name (car foundp)))
                 (setf (slot-value-using-class class instance slotd) new-value))
                ((and (or (eq slot-names t)
                          (member (slot-definition-name slotd)
                                  slot-names
                                  :test #'eq))
                      (not (slot-boundp-using-class class instance slotd)))
                 ;; If the slot name is among the specified slot names, or
                 ;; we're reinitializing all slots, and the slot is currently
                 ;; unbound in the instance, set the slot's value based
                 ;; on the initfunction (which captures the :INITFORM).
                 (let* ((initfunction (slot-definition-initfunction slotd)))
                   (if initfunction
                     (let* ((newval (funcall initfunction)))
                       (unless (or (null predicate)
                                   (funcall predicate newval))
                         (error 'bad-slot-type-from-initform
                                :slot-definition slotd
                                :expected-type (slot-definition-type slotd)
                                :datum newval
                                :instance instance))
                       (setf (slot-value-using-class class instance slotd)
                             newval))))))))))
  instance)

(defmethod shared-initialize ((struct structure-object) slot-names &rest initargs)
  (unless (eq slot-names t)
    (error "Structure instance ~s can't be reinitialized." struct))
  (dolist (slotd (class-slots (class-cell-class (car (%svref struct 0)))))
    (let* ((predicate (slot-definition-predicate slotd))
           (location (slot-definition-location slotd)))
      (declare (fixnum location))
      (multiple-value-bind (ignore new-value foundp)
          (get-properties initargs (slot-definition-initargs slotd))
        (declare (ignore ignore))
        (cond (foundp
               ;; an initarg for the slot was passed to this function
               ;; Typecheck the new-value, then call
               ;; (SETF SLOT-VALUE-USING-CLASS)
               (unless (or (null predicate)
                           (funcall predicate new-value))
                 (error 'bad-slot-type-from-initarg
                        :slot-definition slotd
                        :instance struct
                        :datum new-value
                        :expected-type  (slot-definition-type slotd)
                          :initarg-name (car foundp)))
                 (setf (struct-ref struct location) new-value))
                (t
                 ;; If the slot name is among the specified slot names, or
                 ;; we're reinitializing all slots, and the slot is currently
                 ;; unbound in the instance, set the slot's value based
                 ;; on the initfunction (which captures the :INITFORM).
                 (let* ((initfunction (slot-definition-initfunction slotd)))
                   (if initfunction
                     (let* ((newval (funcall initfunction)))
                       (unless (or (null predicate)
                                   (funcall predicate newval))
                         (error 'bad-slot-type-from-initform
                                :slot-definition slotd
                                :expected-type (slot-definition-type slotd)
                                :datum newval
                                :instance struct))
                       (setf (struct-ref struct location) newval)))))))))
  struct)

(defmethod initialize-instance ((struct structure-object) &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (apply #'shared-initialize struct t initargs))

(defmethod make-instance ((class structure-class)  &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (let* ((struct (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance struct initargs)))

    

;;; Sometimes you can do a lot better at generic function dispatch than the
;;; default. This supports that for the one-arg-dcode case.
(defmethod override-one-method-one-arg-dcode ((generic-function t) (method t))
  nil)

(defun optimize-generic-function-dispatching ()
  (dolist (gf (population.data %all-gfs%))
    (optimize-dispatching-for-gf gf)))

(defun optimize-dispatching-for-gf (gf)
  (let* ((dcode (%gf-dcode gf))
         (name (function-name dcode)))
    (when (or (eq name '%%one-arg-dcode)
              (eq name '%%nth-arg-dcode))
      (let ((methods (generic-function-methods gf)))
        (when (and methods (null (cdr methods)))
          (when (or (eq #'%%one-arg-dcode dcode)
                    (and (eq #'%%nth-arg-dcode dcode)
                         (let ((spec (method-specializers (car methods)))
                               (argnum (%gf-dispatch-table-argnum
                                        (%gf-dispatch-table gf))))
                           (and (eql 2 (length spec))
                                (and (eql argnum 1) (eq (car spec) *t-class*))))))
            (override-one-method-one-arg-dcode gf (car methods))))))))

(defparameter *unique-reader-dcode-functions* t)

;;; dcode for a GF with a single reader method which accesses
;;; a slot in a class that has no subclasses (that restriction
;;; makes typechecking simpler and also ensures that the slot's
;;; location is correct.)
(defun singleton-reader-dcode (dt instance)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((wrapper (%svref dt %gf-dispatch-table-first-data))
         (location (%svref dt (1+ %gf-dispatch-table-first-data))))
    (if (eq (if (eq (typecode instance) target::subtag-instance)
              (instance.class-wrapper instance))
            wrapper)
      (%slot-ref (instance.slots instance) location)
      (cond ((and (eq (typecode instance) target::subtag-instance)
                  (eq 0 (%wrapper-hash-index (instance.class-wrapper instance)))
                  (progn (update-obsolete-instance instance)
                         (eq (instance.class-wrapper instance) wrapper)))
             (%slot-ref (instance.slots instance) location))
            (t (no-applicable-method (method-generic-function (car (%gf-dispatch-table-methods dt))) instance))))))
(register-dcode-proto #'singleton-reader-dcode *gf-proto-one-arg*)

;;; Dcode for a GF whose methods are all reader-methods which access a
;;; slot in one or more classes which have multiple subclasses, all of
;;; which (by luck or design) have the same slot-definition location.
(defun reader-constant-location-dcode (dt instance)
  (declare (optimize (speed 3) (safety 0)))
    (if (memq (if (eq (typecode instance) target::subtag-instance)
              (%class-of-instance instance))
              (%svref dt %gf-dispatch-table-first-data))
      (%slot-ref (instance.slots instance) (%svref dt (1+ %gf-dispatch-table-first-data)))
      (no-applicable-method (method-generic-function (car (%gf-dispatch-table-methods dt))) instance)))
(register-dcode-proto #'reader-constant-location-dcode *gf-proto-one-arg*)

;;; Dcode for a GF whose methods are all reader-methods which access a
;;; slot in one or more classes which have multiple subclasses, all of
;;; which (by luck or design) have the same slot-definition location.
;;; The number of classes for which the method is applicable is
;;; potentially large, but all are subclasses of a single class
(defun reader-constant-location-inherited-from-single-class-dcode (dt instance)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((defining-class-ordinal (%svref dt %gf-dispatch-table-first-data))
         (bits  (let* ((wrapper
                        (if (eq (typecode instance) target::subtag-instance)
                          (instance.class-wrapper instance))))
                  (when wrapper (or (%wrapper-cpl-bits wrapper)
                                    (make-cpl-bits (%inited-class-cpl
                                                    (%wrapper-class wrapper))))))))
    (declare (fixnum defining-class-ordinal))
    (if (and bits
             (< defining-class-ordinal (the fixnum (uvsize bits)))
             (not (eql 0 (sbit bits defining-class-ordinal))))
      (%slot-ref (instance.slots instance) (%svref dt (1+ %gf-dispatch-table-first-data)))
      (no-applicable-method (method-generic-function (car (%gf-dispatch-table-methods dt))) instance))))
(register-dcode-proto #'reader-constant-location-inherited-from-single-class-dcode *gf-proto-one-arg*)

;;; It may be faster to make individual functions that take their
;;; "parameters" (defining class ordinal, slot location) as constants.
;;; It may not be.  Use *unique-reader-dcode-functions* to decide
;;; whether or not to do so.
(defun make-reader-constant-location-inherited-from-single-class-dcode
    (defining-class-ordinal location gf)
  (if *unique-reader-dcode-functions*
    (let* ((gf-name (function-name gf)))
      (values
       (%make-function 
        `(slot-reader for ,gf-name)
        `(lambda (instance)
          (locally (declare (optimize (speed 3) (safety 0)))
            (let* ((bits (let* ((wrapper
                                 (if (eq (typecode instance) target::subtag-instance)
                                   (instance.class-wrapper instance))))
                           (when wrapper (or (%wrapper-cpl-bits wrapper)
                                             (make-cpl-bits (%inited-class-cpl
                                                             (%wrapper-class wrapper))))))))
              (if (and bits
                       (< ,defining-class-ordinal (the fixnum (uvsize bits)))
                       (not (eql 0 (sbit bits ,defining-class-ordinal))))
                (%slot-ref (instance.slots instance) ,location)
                (no-applicable-method (function ,gf-name) instance)))))
        nil)
       #'funcallable-trampoline))
    (let* ((dt (gf.dispatch-table gf)))
      (setf (%svref dt %gf-dispatch-table-first-data)
            defining-class-ordinal
            (%svref dt (1+ %gf-dispatch-table-first-data))
            location)
      (values
       (dcode-for-gf gf #'reader-constant-location-inherited-from-single-class-dcode)
       (cdr (assq #'reader-constant-location-inherited-from-single-class-dcode dcode-proto-alist))))))

;;; Dcode for a GF whose methods are all reader-methods which access a
;;; slot in one or more classes which have multiple subclasses, all of
;;; which (by luck or design) have the same slot-definition location.
;;; The number of classes is for which the method is applicable is
;;; large, but all are subclasses of one of a (small) set of defining classes.
(defun reader-constant-location-inherited-from-multiple-classes-dcode (dt instance)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((wrapper (if (eq (typecode instance) target::subtag-instance)
                    (instance.class-wrapper instance)))
         (bits (if wrapper (or (%wrapper-cpl-bits wrapper)
                               (make-cpl-bits (%inited-class-cpl (%wrapper-class wrapper))))))
         (nbits (if bits (uvsize bits) 0)))
    (declare (fixnum nbits))
    (if (dolist (ordinal (%svref dt %gf-dispatch-table-first-data))
          (declare (fixnum ordinal))
          (when (and (< ordinal nbits)
                     (not (eql 0 (sbit bits ordinal))))
            (return t)))
      (%slot-ref (instance.slots instance) (%svref dt (1+ %gf-dispatch-table-first-data)))
      (no-applicable-method (method-generic-function (car (%gf-dispatch-table-methods dt))) instance))))
(register-dcode-proto #'reader-constant-location-inherited-from-multiple-classes-dcode *gf-proto-one-arg*)


;;; Similar to the case above, but we use an alist to map classes
;;; to their non-constant locations.
(defun reader-variable-location-dcode (dt instance)
  (declare (optimize (speed 3) (safety 0)))
  (let* ((alist (%svref dt %gf-dispatch-table-first-data))
         (location (cdr
                    (assq
                     (if (eq (typecode instance) target::subtag-instance)
                       (%class-of-instance instance))
                     alist))))
    (if location
      (%slot-ref (instance.slots instance) location)
      (no-applicable-method (method-generic-function (car (%gf-dispatch-table-methods dt))) instance))))
(register-dcode-proto #'reader-variable-location-dcode *gf-proto-one-arg*)

(defun class-and-slot-location-alist (classes slot-name)
  (let* ((alist nil))
    (labels ((add-class (c)
               (unless (assq c alist)
                 (let* ((slots (class-slots c)))
                   (unless slots
                     (finalize-inheritance c)
                     (setq slots (class-slots c)))
                   (push (cons c (slot-definition-location (find-slotd slot-name slots))) alist))
                 (dolist (sub (class-direct-subclasses c))
                   (add-class sub)))))
      (dolist (class classes) (add-class class))
      ;; Building the alist the way that we have should often approximate
      ;; this ordering; the idea is that leaf classes are more likely to
      ;; be instantiated than non-leaves.
      (sort alist (lambda (c1 c2)
                    (< (length (class-direct-subclasses c1))
                       (length (class-direct-subclasses c2))))
            :key #'car))))

;;; Return a list of all classes in CLASS-LIST that aren't subclasses
;;; of any other class in the list.
(defun remove-subclasses-from-class-list (class-list)
  (if (null (cdr class-list))
    class-list
    (collect ((unique))
      (dolist (class class-list (unique))
        (when (dolist (other class-list t)
                (unless (eq class other)
                  (when (subtypep class other) (return nil))))
          (unique class))))))


;;; Try to replace gf dispatch with something faster in f.
(defun %snap-reader-method (f &key (redefinable t))
  (when (slot-boundp f 'methods)
    (let* ((methods (generic-function-methods f)))
      (when (and methods
                 (every (lambda (m) (eq (class-of m) *standard-reader-method-class*)) methods)
                 (every (lambda (m) (subtypep (class-of (car (method-specializers m))) *standard-class-class*)) methods)
                 (every (lambda (m) (null (method-qualifiers m))) methods))
        (let* ((m0 (car methods))
               (name (slot-definition-name (accessor-method-slot-definition m0))))
          (when (every (lambda (m)
                         (eq name (slot-definition-name (accessor-method-slot-definition m))))
                       (cdr methods))
            ;; All methods are *STANDARD-READER-METHODS* that
            ;; access the same slot name.  Build an alist of
            ;; mapping all subclasses of all classes on which those
            ;; methods are specialized to the effective slot's
            ;; location in that subclass.
            (let* ((classes (mapcar #'(lambda (m) (car (method-specializers m)))
                                    methods))
                   (alist (class-and-slot-location-alist classes name))
                   (loc (cdar alist))
                   (dt (gf.dispatch-table f)))
              ;; Only try to handle the case where all slots have
              ;; :allocation :instance (and all locations - the CDRs
              ;; of the alist pairs - are small, positive fixnums.
              (when (every (lambda (pair) (typep (cdr pair) 'fixnum)) alist)
                (when redefinable
                  (loop for (c . nil) in alist
                        do (note-class-dependent c f)))
                (clear-gf-dispatch-table dt)
                (let* ((argnum (%gf-dispatch-table-argnum dt)))
                  (unless (< argnum 0)
                    (setf (%gf-dispatch-table-argnum dt) (lognot argnum)
                          (%gf-dispatch-table-gf dt) (%gf-dcode f))))
                    
                (cond ((null (cdr alist))
                       ;; Method is only applicable to a single class.
                       (destructuring-bind (class . location) (car alist)
                         (setf (%svref dt %gf-dispatch-table-first-data) (%class.own-wrapper class)
                               (%svref dt (1+ %gf-dispatch-table-first-data)) location
                               (gf.dcode f) (dcode-for-gf f #'singleton-reader-dcode))))
                      ((dolist (other (cdr alist) t)
                         (unless (eq (cdr other) loc)
                           (return)))
                       ;; All classes have the slot in the same location,
                       ;; by luck or design.
                       (cond
                         ((< (length alist) 10)
                          ;; Only a small number of classes, just do MEMQ
                          (setf (%svref dt %gf-dispatch-table-first-data)
                                (mapcar #'car alist)
                                (%svref dt (1+ %gf-dispatch-table-first-data))
                                loc
                                (gf.dcode f) (dcode-for-gf f #'reader-constant-location-dcode)))
                         ((null (cdr (setq classes (remove-subclasses-from-class-list classes))))
                          ;; Lots of classes, all subclasses of a single class
                          (multiple-value-bind (dcode trampoline)
                              (make-reader-constant-location-inherited-from-single-class-dcode (%class-ordinal (car classes)) loc f)
                            (setf (gf.dcode f) dcode)
                            (replace-function-code f trampoline)))
                         (t
                          ;; Multple classes.  We should probably check
                          ;; to see they're disjoint
                          (setf (%svref dt %gf-dispatch-table-first-data)
                                (mapcar #'%class-ordinal classes)
                                (%svref dt (1+ %gf-dispatch-table-first-data))
                                loc
                                (gf.dcode f)
                                (dcode-for-gf f #'reader-constant-location-inherited-from-multiple-classes-dcode)))))
                      (t
                       ;; Multiple classes; the slot's location varies.
                       (setf (%svref dt %gf-dispatch-table-first-data)
                             alist
                             
                             (gf.dcode f) (dcode-for-gf f #'reader-variable-location-dcode))))))))))))

;;; Hack-o-rama: GF has nothing but primary methods, first (and only non-T)
;;; specializers are all EQL specializers whose objects are symbols.
;;; The effective method applicable for each symbol is stored on the
;;; plist of the symbol under a property EQ to the dispatch table (which
;;; is mostly ignored, otherwise.)
(defun %%1st-arg-eql-method-hack-dcode (dt args)
  (let* ((sym (if (listp args) (car args)(%lexpr-ref args (%lexpr-count args) 0)))
         (mf (if (symbolp sym) (get sym dt))))
    (if mf
      (if (listp args)
        (apply mf args)
        (%apply-lexpr-tail-wise mf args))
      ;;; Let %%1st-arg-dcode deal with it.
      (%%1st-arg-dcode dt args))))
(register-dcode-proto #'%%1st-arg-eql-method-hack-dcode *gf-proto*)

(defun %%1st-two-arg-eql-method-hack-dcode (dt arg1 arg2)
  (let* ((mf (if (typep arg1 'symbol) (get arg1 dt))))
    (if mf
      (funcall mf arg1 arg2)
      (%%1st-two-arg-dcode dt arg1 arg2))))
(register-dcode-proto #'%%1st-two-arg-eql-method-hack-dcode *gf-proto-two-arg*)

(defun %%one-arg-eql-method-hack-dcode (dt arg)
  (let* ((mf (if (typep arg 'symbol) (get arg dt))))
    (if mf
      (funcall mf arg))))
(register-dcode-proto #'%%one-arg-eql-method-hack-dcode *gf-proto-one-arg*)

(defun install-eql-method-hack-dcode (gf)
  (let* ((bits (inner-lfun-bits gf))
         (nreq (ldb $lfbits-numreq bits))
         (other-args? (or (not (eql 0 (ldb $lfbits-numopt bits)))
                          (logbitp $lfbits-rest-bit bits)
                          (logbitp $lfbits-restv-bit bits)
                          (logbitp $lfbits-keys-bit bits)
                          (logbitp $lfbits-aok-bit bits))))
    (setf (%gf-dcode gf)
          (dcode-for-gf gf
                        (cond ((and (eql nreq 1) (null other-args?))
                               #'%%one-arg-eql-method-hack-dcode)
                              ((and (eql nreq 2) (null other-args?))
                               #'%%1st-two-arg-eql-method-hack-dcode)
                              (t
                               #'%%1st-arg-eql-method-hack-dcode))))))

(defun maybe-hack-eql-methods (gf)
  (let* ((methods (generic-function-methods gf)))
    (when (and methods
               (every #'(lambda (method)
                          (let* ((specializers (method-specializers method))
                                      (first (car specializers)))
                                 (and (typep first 'eql-specializer)
                                      (typep (eql-specializer-object first) 'symbol)
                                      (dolist (s (cdr specializers) t)
                                        (unless (eq s *t-class*)
                                          (return nil)))
                                      (null (cdr (compute-applicable-methods gf (cons (eql-specializer-object first) (make-list (length (cdr specializers))))))))))
                      methods))
      (let* ((dt (%gf-dispatch-table gf)))
        (dolist (m methods)
          (let* ((sym (eql-specializer-object (car (method-specializers m))))
                 (f (method-function m)))
            (setf (get sym dt) f)))
        (install-eql-method-hack-dcode gf)
        t))))


            
                            
;;; Return a list of :after methods for INITIALIZE-INSTANCE on the
;;; class's prototype, and a boolean that's true if no other qualified
;;; methods are defined and at most one primary one.
(defun initialize-instance-after-methods (proto class)
  (let* ((method-list (compute-method-list (sort-methods
                            (compute-applicable-methods #'initialize-instance (list proto))
                            (list (class-precedence-list class))))))
    (if (atom method-list)
      (values nil t)
      (if (and (null (car method-list))
	       (null (cdddr method-list)))
        (values (cadr method-list) t)
        ;; :around or :before methods, or more than one primary method, give up
        (values nil nil)))))

(defparameter *typecheck-slots-in-optimized-make-instance* t)


;;; Return a lambda form or NIL.
(defun make-instantiate-lambda-for-class-cell (cell)
  (let* ((class (class-cell-class cell))
         (after-methods nil))
    (when (and (typep class 'standard-class)
               (progn (unless (class-finalized-p class)
                        (finalize-inheritance class))
                      t)
               (null (cdr (compute-applicable-methods #'allocate-instance (list class))))
               (let* ((proto (class-prototype class)))
                 (and (multiple-value-bind (afters ok)
                          (initialize-instance-after-methods proto class)
                        (when ok
                          (setq after-methods afters)
                          t))
                      (null (cdr (compute-applicable-methods #'shared-initialize (list proto t)))))))
      (let* ((slotds (sort (copy-list (class-slots class))
                           #'(lambda (x y)
                               (if (consp x) x (if (consp y) y (< x y))))
                           :key #'slot-definition-location))
             (default-initargs (class-default-initargs class)))
        (collect ((keys)
                  (binds)
                  (class-binds)
                  (ignorable)
                  (class-slot-inits)
                  (after-method-forms)
                  (forms))
          (flet ((generate-type-check (form type &optional spvar)
                   (if (or (null *typecheck-slots-in-optimized-make-instance*)
                           (eq type t)
                           (and (quoted-form-p type) (eq (cadr type) t)))
                     form
                     (if spvar
                       `(if ,spvar
                         (require-type ,form ',type)
                         ,form)
                       `(require-type ,form ',type)))))
            (dolist (slot slotds)
              (let* ((initargs (slot-definition-initargs slot))
                     (initfunction (slot-definition-initfunction slot))
                     (initform (slot-definition-initform slot))
                     (location (slot-definition-location slot))
                     (location-var nil)
                     (class-init-p nil)
                     (one-initarg-p (null (cdr initargs)))
                     (name (slot-definition-name slot))
                     (type (slot-definition-type slot)))
                (when (consp location)
                  (setq location-var (gensym "LOCATION")))
                (when initfunction
                  (setq initform
                        (if (self-evaluating-p initform)
                            initform
                            `(funcall ,initfunction))))
                (cond ((null initargs)
                       (let ((initial-value-form
                              (if initfunction
                                  (generate-type-check initform type)
                                  `(%slot-unbound-marker))))
                         (if location-var
                             (when initfunction
                               (setq class-init-p t)
                               (class-slot-inits
                                `(when (eq (%slot-unbound-marker) (cdr ,location-var))
                                   (setf (cdr ,location-var) ,initial-value-form))))
                             (forms initial-value-form))))
                      (t (collect ((cond-clauses))
                           (let ((last-cond-clause nil))
                             (dolist (initarg initargs)
                               (let* ((spvar nil)
                                      (name (if one-initarg-p
                                                name
                                                (gensym (string name))))
                                      (initial-value-form
                                       (if (and initfunction
                                                one-initarg-p
                                                (null location-var))
                                           initform
                                           (progn
                                             (when initarg
                                               (setq spvar (make-symbol
                                                            (concatenate
                                                             'string
                                                             (string initarg)
                                                             "-P"))))
                                             (and one-initarg-p
                                                  (null location-var)
                                                  (if initfunction
                                                      initform
                                                      `(%slot-unbound-marker))))))
                                      (default (assq initarg default-initargs))
                                      (default-value-form nil))
                                 (when spvar (ignorable spvar))
                                 (when default
                                   (destructuring-bind (form function)
                                       (cdr default)
                                     (setq default-value-form
                                           (if (or (quoted-form-p form)
                                                   (self-evaluating-p form))
                                               form
                                               `(funcall ,function)))))
                                 (keys (list*
                                        (list initarg name)
                                        (if (and default one-initarg-p (null location-var))
                                            default-value-form
                                            initial-value-form)
                                        (if spvar (list spvar))))
                                 (if one-initarg-p
                                   (if location-var
                                     (progn
                                       (setq class-init-p t)
                                       (class-slot-inits
                                        `(if ,spvar
                                           (setf (cdr ,location-var)
                                                 ,(generate-type-check
                                                   name type))
                                           ,(if default
                                              `(setf (cdr ,location-var)
                                                     ,(generate-type-check
                                                       default type))
                                              (when initfunction
                                                `(when (eq (%slot-unbound-marker)
                                                           (cdr ,location-var))
                                                   (setf (cdr ,location-var)
                                                         ,(generate-type-check
                                                           initform type))))))))
                                     (forms `,(generate-type-check name type spvar)))
                                     (progn (cond-clauses `(,spvar ,name))
                                            (when (and default (null last-cond-clause))
                                              (setq last-cond-clause
                                                    `(t ,default)))))))
                             (when (cond-clauses)
                               (when last-cond-clause
                                 (cond-clauses last-cond-clause))
                               (cond ((null location-var)
                                      (unless last-cond-clause
                                        (cond-clauses `(t ,initform)))
                                      (forms (generate-type-check
                                              `(cond ,@(cond-clauses))
                                              type)))
                                     (t
                                      (let ((initform-p-var
                                             (unless last-cond-clause
                                               (make-symbol "INITFORM-P")))
                                            (value-var (make-symbol "VALUE")))
                                        (unless last-cond-clause
                                          (cond-clauses
                                           `(t (setq ,initform-p-var t)
                                               ,(if initfunction
                                                    initform
                                                    `(%slot-unbound-marker)))))
                                        (setq class-init-p t)
                                        (class-slot-inits
                                         `(let* (,@(and initform-p-var
                                                        (list `(,initform-p-var nil)))
                                                 (,value-var
                                                  ,(generate-type-check
                                                    `(cond ,@(cond-clauses)) type)))
                                            (when
                                                ,(if initform-p-var
                                                     `(or (null ,initform-p-var)
                                                          (and (eq (cdr ,location-var)
                                                                   (%slot-unbound-marker))
                                                               (not (eq ,value-var
                                                                        (%slot-unbound-marker)))))
                                                     t)
                                                (setf (cdr ,location-var) ,value-var))))))))))))
                (when class-init-p
                  (class-binds `(,location-var
                                 (load-time-value
                                  (slot-definition-location ',slot))))))))
          (let* ((cell (make-symbol "CLASS-CELL"))
                 (args (make-symbol "ARGS"))
                 (slots (make-symbol "SLOTS"))
                 (instance (make-symbol "INSTANCE")))
            (dolist (after after-methods)
              (after-method-forms `(apply ,(method-function after) ,instance ,args)))
            (when after-methods
              (after-method-forms instance))
            (binds `(,slots (gvector :slot-vector nil ,@(forms))))
            (binds `(,instance (gvector :instance 0 (class-cell-extra ,cell) ,slots)))
            `(lambda (,cell ,@(when after-methods `(&rest ,args)) &key ,@(keys) ,@(when after-methods '(&allow-other-keys)))
              (declare (ignorable ,@(ignorable)))
              ,@(when after-methods `((declare (dynamic-extent ,args))))
              (let (,@(class-binds))
                ,@(class-slot-inits))
              (let* (,@(binds))
                (setf (instance.hash ,instance) (strip-tag-to-fixnum ,instance)
                      (%svref ,slots 0) ,instance)
                ,@(after-method-forms)))))))))

(defun optimize-make-instance-for-class-cell (cell)
  (init-class-cell-instantiator cell)
  (let* ((lambda (make-instantiate-lambda-for-class-cell cell)))
    (when lambda
      (setf (class-cell-instantiate cell) (compile nil lambda)
            (class-cell-extra cell) (%class.own-wrapper
                                     (class-cell-class cell)))
      t)))

(defun optimize-make-instance-for-class-name (class-name)
  (optimize-make-instance-for-class-cell (find-class-cell class-name t)))

(defun optimize-named-class-make-instance-methods ()
  (maphash (lambda (class-name class-cell)
             (handler-case (optimize-make-instance-for-class-cell class-cell)
               (error (c)
                      (warn "error optimizing make-instance for ~s:~&~a"
                            class-name c))))
           %find-classes%))




;;; Iterate over all known GFs; try to optimize their dcode in cases
;;; involving reader methods.

(defun snap-reader-methods (&rest args
                                  &key known-sealed-world
                                 (check-conflicts t)
                                 (optimize-make-instance t))
  (declare (ignore check-conflicts)
	   (ignore known-sealed-world))
  (if *clos-optimizations-active*
    (values nil nil 0)
    (progn
      (setq *clos-optimizations-active* (cons t args))
      (when optimize-make-instance
        (optimize-named-class-make-instance-methods))
      (let* ((ngf 0)
             (nwin 0))
        (dolist (f (population.data %all-gfs%))
          (incf ngf)
          (when (%snap-reader-method f)
            (incf nwin)))
        (values ngf nwin 0)))))


    

(defun register-non-dt-dcode-function (f)
  (flet ((symbol-or-function-name (x)
           (etypecase x
             (symbol x)
             (function (function-name x)))))
    (let* ((already (member (symbol-or-function-name f) *non-dt-dcode-functions* :key #'symbol-or-function-name)))
      (if already
        (setf (car already) f)
        (push f *non-dt-dcode-functions*))
      f)))

(defun pessimize-clos ()
  ;; Undo MAKE-INSTANCE optimization
  (maphash (lambda (class-name class-cell)
	     (declare (ignore class-name))
	     (init-class-cell-instantiator class-cell))
	   %find-classes%)
  ;; Un-snap reader methods, undo other GF optimizations.
  (dolist (f (population-data %all-gfs%))
    (let* ((dt (%gf-dispatch-table f))
           (argnum (%gf-dispatch-table-argnum dt)))
      (when (< argnum 0)
        (let* ((dcode (%gf-dispatch-table-gf dt)))
          (setf (%gf-dispatch-table-argnum dt) (lognot argnum)
                (%gf-dispatch-table-gf dt) f
                (%gf-dcode f) dcode)
        (clear-gf-dispatch-table dt))))))

;;; If there's a single method (with standard method combination) on
;;; GF and all of that method's arguments are specialized to the T
;;; class - and if the method doesn't accept &key or do any
;;; next-method things - we can just have the generic function call
;;; the method-function
(defun dcode-for-universally-applicable-singleton (gf)
  (when (eq (generic-function-method-combination gf)
            *standard-method-combination*)
    (let* ((methods (generic-function-methods gf))
           (method (car methods)))
      (when (and method
                 (null (cdr methods))
                 (null (method-qualifiers method))
                 (not (logtest (logior (ash 1 $lfbits-keys-bit)
                                       (ash 1 $lfbits-nextmeth-bit))
                                 (lfun-bits (method-function method))))
                 (dolist (spec (method-specializers method) t)
                   (unless (eq spec *t-class*)
                     (return nil))))
        (method-function method)))))

(register-non-dt-dcode-function #'dcode-for-universally-applicable-singleton)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/sysutils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


;; sysutils.lisp - things which have outgrown l1-utils

(in-package "CCL")

(eval-when (:execute :compile-toplevel)
  (require 'level-2)
  (require 'optimizers)
  (require 'backquote)
  (require 'defstruct-macros)
  )

;;; things might be clearer if this stuff were in l1-typesys?
;;; Translation from type keywords to specific predicates.
(eval-when (:execute :compile-toplevel)

(defconstant type-pred-pairs
  '((array . arrayp)
    (atom . atom)
    (base-string . base-string-p)
    (bignum . bignump)
    (bit . bitp)
    (bit-vector . bit-vector-p)
    (character . characterp)
    (compiled-function . compiled-function-p)
    (complex . complexp)
    (cons . consp)
    (double-float . double-float-p)
    (fixnum . fixnump) ;not cl
    (float . floatp)
    (function . functionp)
    (hash-table . hash-table-p)
    (integer . integerp)
    (real . realp)
    (keyword . keywordp)
    (list . listp)
    (long-float . double-float-p)
    (nil . false)
    (null . null)
    (number . numberp)
    (package . packagep)
    (pathname . pathnamep)
    (logical-pathname . logical-pathname-p)
    (random-state . random-state-p)
    (ratio . ratiop)
    (rational . rationalp)
    (readtable . readtablep)
    (sequence . sequencep)
    (short-float . short-float-p)
    (signed-byte . integerp)
    (simple-array . simple-array-p)
    (simple-base-string . simple-base-string-p)
    (simple-bit-vector . simple-bit-vector-p)
    (simple-string . simple-string-p)
    (simple-vector . simple-vector-p)
    (single-float . short-float-p)
    (stream . streamp)
    (string . stringp)
    (base-char . base-char-p)
    (extended-char . extended-char-p)
    (structure-object . structurep)
    (symbol . symbolp)
    (t . true)
    (unsigned-byte . unsigned-byte-p)
    (vector . vectorp)
    ))

(defmacro init-type-predicates ()
  `(dolist (pair ',type-pred-pairs)
     (setf (type-predicate (car pair)) (cdr pair))
     (let ((ctype (info-type-builtin (car pair))))       
       (if (typep ctype 'numeric-ctype)
         (setf (numeric-ctype-predicate ctype) (cdr pair))))))

)

(init-type-predicates)

(defun unsigned-byte-8-p (n)
  (and (fixnump n)
       (locally (declare (fixnum n))
         (and 
          (>= n 0)
          (< n #x100)))))

(defun signed-byte-8-p (n)
  (and (fixnump n)
       (locally (declare (fixnum n))
         (and 
          (>= n -128)
          (<= n 127)))))

(defun unsigned-byte-16-p (n)
  (and (fixnump n)
       (locally (declare (fixnum n))
         (and 
          (>= n 0)
          (< n #x10000)))))

(defun signed-byte-16-p (n)
  (and (fixnump n)
       (locally (declare (fixnum n))
         (and 
          (>= n -32768)
          (<= n 32767)))))

(defun unsigned-byte-32-p (n)
  (and (integerp n)
       (>= n 0)
       (<= n #xffffffff)))

(defun signed-byte-32-p (n)
  (and (integerp n)
       (>= n  -2147483648)
       (<= n 2147483647)))

(eval-when (:load-toplevel :execute)
  (let ((more-pairs
         '(((unsigned-byte 8) . unsigned-byte-8-p)
           ((signed-byte 8) . signed-byte-8-p)
           ((unsigned-byte 16) . unsigned-byte-16-p)
           ((signed-byte 16) . signed-byte-16-p)
           ((unsigned-byte 32) . unsigned-byte-32-p)
           ((signed-byte 32) . signed-byte-32-p)
           ((complex single-float) . complex-single-float-p)
           ((complex double-float) . complex-double-float-p))))         
    (dolist (pair more-pairs)
      (let ((ctype (info-type-builtin (car pair))))       
        (if (typep ctype 'numeric-ctype) (setf (numeric-ctype-predicate ctype) (cdr pair))))))
  )


(defun specifier-type-known (type)  
  (let ((ctype (specifier-type type)))
    (if (typep ctype 'unknown-ctype)
      (error "Unknown type specifier ~s." type)
      (if (and (typep ctype 'numeric-ctype) ; complexp??
               (eq 'integer (numeric-ctype-class ctype))
               (not (numeric-ctype-predicate ctype)))
        (setf (numeric-ctype-predicate ctype)(make-numeric-ctype-predicate ctype))))
    ctype))


(defun find-builtin-cell (type  &optional (create t))
  (let ((cell (gethash type %builtin-type-cells%)))
    (or cell
        (when create
          (setf (gethash type %builtin-type-cells%)
                (cons type (or (info-type-builtin type)(specifier-type-known type))))))))


; for now only called for builtin types or car = unsigned-byte, signed-byte, mod or integer

(defun builtin-typep (form cell)
  (unless (listp cell)
    (setq cell (require-type cell 'list)))
  (locally (declare (type list cell))
    (let ((ctype (cdr cell))
          (name (car cell)))
      (when (not ctype)
        (setq ctype (or (info-type-builtin name)(specifier-type-known name)))
        (when ctype (setf (gethash (car cell) %builtin-type-cells%) cell))
        (rplacd cell ctype))
      (if ctype 
        (if (and (typep ctype 'numeric-ctype)
                 (numeric-ctype-predicate ctype))
          ; doing this inline is a winner - at least if true
          (funcall (numeric-ctype-predicate ctype) form)
          (%%typep form ctype))
        (typep form name)))))

#|
(defvar %find-classes% (make-hash-table :test 'eq))

(defun find-class-cell (name create?)
  (let ((cell (gethash name %find-classes%)))
    (or cell
        (and create?
             (setf (gethash name %find-classes%) (cons name nil))))))
|#

;(setq *type-system-initialized* t)


;; Type-of, typep, and a bunch of other predicates.

;;; Data type predicates.

;;; things might be clearer if this stuff were in l1-typesys?
;;; Translation from type keywords to specific predicates.




;necessary since standard-char-p, by definition, errors if not passed a char.
(setf (type-predicate 'standard-char)
      #'(lambda (form) (and (characterp form) (standard-char-p form))))

(defun type-of (form)
  "Return the type of OBJECT."
  (case form
    ((t) 'boolean)
    ((0 1) 'bit)
    (t
     (typecase form
       (standard-char 'standard-char)
       (keyword 'keyword)
       ;; Partition integers so that the negative cases
       ;; are SIGNED-BYTE and the positive are UNSIGNED-BYTE
       (fixnum
	(if (< (the fixnum form) 0)
	  'fixnum
	  '(integer 0 #.target::target-most-positive-fixnum)))
       (bignum
	(if (< form 0)
	  'bignum
	  '(integer  #.(1+ target::target-most-positive-fixnum))))
       ((or array complex) (type-specifier (ctype-of form)))
       (single-float 'single-float)
       (double-float 'double-float)
       (t
	(if (eql (typecode form) target::subtag-istruct)
	  (istruct-type-name form)
	  (let* ((class (class-of form)))
            (or (%class-proper-name class)
                class))))))))

;;; Create the list-style description of an array.

;made more specific by fry. slisp used  (mod 2) , etc.
;Oh.
; As much fun as this has been, I think it'd be really neat if
; it returned a type specifier.

(defun describe-array (array)
  (if (arrayp array)
    (type-specifier
     (specifier-type
      `(,(if (simple-array-p array) 'simple-array 'array) 
        ,(array-element-type array) 
        ,(array-dimensions array))))
    (report-bad-arg array 'array)))
  

;;;; TYPEP and auxiliary functions.



(defun type-specifier-p (form &aux sym)
  (cond ((symbolp form)
         (or (type-predicate form)
             (structure-class-p form)
             (%deftype-expander form)
             (find-class form nil)
             ))
        ((consp form)
         (setq sym (%car form))
         (or (type-specifier-p sym)
             (memq sym '(member satisfies mod))
             (and (memq sym '(and or not))
                  (dolist (spec (%cdr form) t)
                    (unless (type-specifier-p spec) (return nil))))))
        (t (typep form 'class))))

(defun built-in-type-p (type)
  (if (symbolp type)
    (or (type-predicate type)
        (let ((class (find-class type nil)))
          (and class (typep class 'built-in-class))))
    (and (consp type)
         (or (and (memq (%car type) '(and or not))
                  (every #'built-in-type-p (%cdr type)))
             (memq (%car type) '(array simple-array vector simple-vector
                                 string simple-string bit-vector simple-bit-vector 
                                 complex integer mod signed-byte unsigned-byte
                                 rational float short-float single-float
                                 double-float long-float real member))))))

(defun typep (object type &optional env)
  "Is OBJECT of type TYPE?"
  (let* ((pred (if (symbolp type) (type-predicate type))))
    (if pred
      (funcall pred object)
      (values (%typep object (if env (specifier-type type env) type))))))



;;; This is like check-type, except it returns the value rather than setf'ing
;;; anything, and so can be done entirely out-of-line.
(defun require-type (arg type)
  (multiple-value-bind (win sure)
      (ctypep  arg (specifier-type type))
    (if (or win (not sure))
      arg
      (%kernel-restart $xwrongtype arg type))))



;;; Might want to use an inverted mapping instead of (satisfies ccl::obscurely-named)
(defun %require-type (arg predsym)
  (if (funcall predsym arg)
    arg
    (%kernel-restart $xwrongtype arg (type-for-predicate predsym))))

(defun %require-type-builtin (arg type-cell)  
  (if (builtin-typep arg type-cell)
    arg
    (%kernel-restart $xwrongtype arg (car type-cell))))



;;; In lieu of an inverted mapping, at least try to find cases involving
;;; builtin numeric types and predicates associated with them.
(defun type-for-predicate (pred)
  (or (block find
        (maphash #'(lambda (type ctype) (when (and (typep ctype 'numeric-ctype)
                                                   (eq (numeric-ctype-predicate ctype)
                                                       pred))
                                          (return-from find type)))
                 *builtin-type-info*))
      `(satisfies ,pred)))



; Subtypep.

(defun subtypep (type1 type2 &optional env)
  "Return two values indicating the relationship between type1 and type2.
  If values are T and T, type1 definitely is a subtype of type2.
  If values are NIL and T, type1 definitely is not a subtype of type2.
  If values are NIL and NIL, it couldn't be determined."
  (csubtypep (specifier-type type1 env) (specifier-type type2 env)))

(defun types-disjoint-p (type1 type2 &optional env)
  ;; Return true if types are guaranteed to be disjoint, nil if not disjoint or unknown.
  (let ((ctype1 (if (typep type1 'ctype) type1 (specifier-type type1 env)))
	(ctype2 (if (typep type2 'ctype) type2 (specifier-type type2 env))))
    (eq *empty-type* (type-intersection ctype1 ctype2))))



(defun preload-all-functions ()
  nil)


 ; used by arglist
(defun temp-cons (a b)
  (cons a b))




(defun copy-into-float (src dest)
  (%copy-double-float src dest))

(queue-fixup
 (defun fmakunbound (name)
   "Make NAME have no global function definition."
   (let* ((fname (validate-function-name name)))
     (remhash fname %structure-refs%)
     (%unfhave fname))
   name))

(defun frozen-definition-p (name)
  (if (symbolp name)
    (%ilogbitp $sym_fbit_frozen (%symbol-bits name))))

(defun redefine-kernel-function (name)
  (when (and *warn-if-redefine-kernel*
             (frozen-definition-p name)
             (or (lfunp (fboundp name))
                 (and (not (consp name)) (macro-function name)))
             (or (and (consp name) (neq (car name) 'setf))
                 (let ((pkg (symbol-package (if (consp name) (cadr name) name))))
                   (or (eq *common-lisp-package* pkg) (eq *ccl-package* pkg)))))
    (restart-case
	(progn ;; work around ticket:865
	  (cerror "Replace the definition of ~S."
		  "The function ~S is predefined in Clozure CL." name))
      (never-complain ()
	:report (lambda (stream)
		  (format stream "Replace the definition of ~S and allow such redefinitions in the future" name))
	(setq *warn-if-redefine-kernel* nil)))
    (unless (consp name)
      (proclaim-inline nil name))))

(defun fset (name function)
  (setq function (require-type function 'function))
  (when (symbolp name)
    (when (special-operator-p name)
      (error "Can not redefine a special-form: ~S ." name))
    (when (macro-function name)
      (cerror "Redefine the macro ~S as a function"
              "The macro ~S is being redefined as a function." name)))
; This lets us redefine %FHAVE.  Big fun.
  (let ((fhave #'%fhave))
    (redefine-kernel-function name)
    (fmakunbound name)
    (funcall fhave name function)
    function))

(defsetf symbol-function fset-symbol)
(defsetf fdefinition fset)

(defun (setf macro-function) (macro-fun name &optional env)
  (declare (ignore env))
  (unless (typep macro-fun 'function)
    (report-bad-arg macro-fun 'function))
  (if (special-operator-p name)
    (error "Can not redefine a special-form: ~S ." name))
  (when (and (fboundp name) (not (macro-function name)))
    (warn "The function ~S is being redefined as a macro." name))
  (redefine-kernel-function name)
  (fmakunbound name)
  (%macro-have name macro-fun)
  macro-fun)

(defun set-macro-function (name def)
  (setf (macro-function name) def))




;;; Arrays and vectors, including make-array.







(defun char (string index)
  "Given a string and a non-negative integer index less than the length of
  the string, returns the character object representing the character at
  that position in the string."
  (if (typep string 'simple-string)
    (schar (the simple-string string) index)
    (if (stringp string)
      (multiple-value-bind (data offset) (array-data-and-offset string)
        (schar (the simple-string data) (+ index offset)))
      (report-bad-arg string 'string))))

(defun set-char (string index new-el)
  (if (typep string 'simple-string)
    (setf (schar string index) new-el)
    (if (stringp string)
      (multiple-value-bind (data offset) (array-data-and-offset string)
        (setf (schar (the simple-string data) (+ index offset)) new-el))
      (report-bad-arg string 'string))))

(defun equalp (x y)
  "Just like EQUAL, but more liberal in several respects.
  Numbers may be of different types, as long as the values are identical
  after coercion.  Characters may differ in alphabetic case.  Vectors and
  arrays must have identical dimensions and EQUALP elements, but may differ
  in their type restriction.
  If one of x or y is a pathname and one is a string with the name of the
  pathname then this will return T."
  (cond ((eql x y) t)
        ((characterp x) (and (characterp y) (eq (char-upcase x) (char-upcase y))))
        ((numberp x) (and (numberp y) (= x y)))
        ((consp x)
         (and (consp y)
              (equalp (car x) (car y))
              (equalp (cdr x) (cdr y))))        
        ((pathnamep x) (equal x y))
        ((vectorp x)
         (and (vectorp y)
              (let ((length (length x)))
                (when (eq length (length y))
                  (dotimes (i length t)
                    (declare (fixnum i))
                    (let ((x-el (aref x i))
                          (y-el (aref y i)))
                      (unless (or (eq x-el y-el) (equalp x-el y-el))
                        (return nil))))))))
        ((arrayp x)
         (and (arrayp y)
              (let ((rank (array-rank x)) x-el y-el)
                (and (eq (array-rank y) rank)
                     (if (%izerop rank) (equalp (aref x) (aref y))
                         (and
                          (dotimes (i rank t)
                            (declare (fixnum i))
                            (unless (eq (array-dimension x i)
                                        (array-dimension y i))
                              (return nil)))
                          (multiple-value-bind (x0 i) (array-data-and-offset x)
                            (multiple-value-bind (y0 j) (array-data-and-offset y)
                              (dotimes (count (array-total-size x) t)
                                (declare (fixnum count))
                                (setq x-el (uvref x0 i) y-el (uvref y0 j))
                                (unless (or (eq x-el y-el) (equalp x-el y-el))
                                  (return nil))
                                (setq i (%i+ i 1) j (%i+ j 1)))))))))))
        ((and (structurep x) (structurep y))
	 (let ((size (uvsize x)))
	   (and (eq size (uvsize y))
	        (dotimes (i size t)
                  (declare (fixnum i))
		  (unless (equalp (uvref x i) (uvref y i))
                    (return nil))))))
        ((and (hash-table-p x) (hash-table-p y))
         (%hash-table-equalp x y))
	((and (random-state-p x) (random-state-p y))
	 (%random-state-equalp x y))
        (t nil)))


; The compiler (or some transforms) might want to do something more interesting
; with these, but they have to exist as functions anyhow.



(defun complement (function)
  "Return a new function that returns T whenever FUNCTION returns NIL and
   NIL whenever FUNCTION returns non-NIL."
  (let ((f (coerce-to-function function))) ; keep poor compiler from consing value cell
  #'(lambda (&rest args)
      (declare (dynamic-extent args)) ; not tail-recursive anyway
      (not (apply f args)))))

; Special variables are evil, but I can't think of a better way to do this.

(defparameter *outstanding-deferred-warnings* nil)

(defun call-with-compilation-unit (thunk &key override)
  (let* ((*outstanding-deferred-warnings* (%defer-warnings override)))
    (multiple-value-prog1 (funcall thunk)
      (report-deferred-warnings))))

(defun %defer-warnings (override &aux (parent *outstanding-deferred-warnings*))
  (when parent
    (ensure-merged-deferred-warnings parent))
  (%istruct 'deferred-warnings
            (unless override parent)
            nil
            (make-hash-table :test #'eq)
            nil))

(defun ensure-merged-deferred-warnings (parent &aux (last (deferred-warnings.last-file parent)))
  (when last
    (setf (deferred-warnings.last-file parent) nil)
    (let* ((child (car last)) ;; last = (deferred-warnings . file)
           (warnings (deferred-warnings.warnings child))
           (defs (deferred-warnings.defs child))
           (parent-defs (deferred-warnings.defs parent))
           (parent-warnings (deferred-warnings.warnings parent)))
      (maphash (lambda (key val) (setf (gethash key parent-defs) val)) defs)
      (setf (deferred-warnings.warnings parent) (append warnings parent-warnings))))
  parent)


;; Should be a generic function but compiler-warning class not defined yet.
(defun verify-deferred-warning (w)
  (etypecase w
    (undefined-type-reference (verify-deferred-type-warning w))
    (undefined-function-reference (verify-deferred-function-warning w))
    (undefined-keyword-reference (verify-deferred-keyword-warning w))
    (compiler-warning nil)))

(defun verify-deferred-type-warning (w)
  (let* ((args (compiler-warning-args w))
	 (typespec (car args))
	 (defs (deferred-warnings.defs *outstanding-deferred-warnings*)))
    (handler-bind ((parse-unknown-type
		    (lambda (c)
		      (let* ((type (parse-unknown-type-specifier c))
			     (spec (if (consp type) (car type) type))
			     (cell (and (symbolp spec) (gethash spec defs))))
			(unless (and cell (def-info.deftype (cdr cell)))
			  (when (and args (neq type typespec))
			    (setf (car args) type))
			  (return-from verify-deferred-type-warning w))
			;; Else got defined.  TODO: Should check syntax, but don't have enuff info.
			;; TODO: should note if got defined as a deftype (rather than class or struct) and
			;; warn about forward reference, akin to the macro warning?  Might be missing out on
			;; some intended optimizations.
			)))
		   (program-error ;; got defined, but turns out it's being used wrong
		    (lambda (c)
		      (let ((w2 (make-condition 'invalid-type-warning
				  :function-name (compiler-warning-function-name w)
				  :source-note (compiler-warning-source-note w)
				  :warning-type :invalid-type
				  :args (list typespec c))))
			(return-from verify-deferred-type-warning w2)))))
      (values-specifier-type typespec)
      nil)))


(defun deferred-function-def (name)
  (let* ((defs (deferred-warnings.defs *outstanding-deferred-warnings*))
	 (def (or (let ((cell (gethash name defs)))
                    (and cell (def-info.function-p (cdr cell)) cell))
		 (let* ((global (fboundp name)))
		   (and (typep global 'function) global)))))
    def))

(defun check-deferred-call-args (w def wargs)
  (destructuring-bind (arglist spread-p) wargs
    (multiple-value-bind (deftype reason) (nx1-check-call-args def arglist spread-p)
      (when (and (eq deftype :deferred-mismatch)
                 (eq (car reason) :unknown-gf-keywords)
                 (consp def)
                 (not (logbitp $lfbits-gfn-bit (def-info.lfbits (cdr def)))))
        ;; If didn't have a defgeneric, check against global defn
        (let* ((global-def (fboundp (car def)))
               (bad-keys (cadr reason)))
          (when (typep global-def 'generic-function)
            (setq bad-keys
                  (multiple-value-bind (bits keyvect) (innermost-lfun-bits-keyvect global-def)
                    (when (and bits
                               (logbitp  $lfbits-keys-bit bits)
                               (not (logbitp $lfbits-aok-bit bits)))
                      (loop for key in bad-keys
                        unless (or (find key keyvect)
                                   (nx1-valid-gf-keyword-p global-def key))
                        collect key)))))
          (if bad-keys
            (setq reason (list* :unknown-gf-keywords bad-keys (cddr reason)))
            (setq deftype nil))))
      (when deftype
        (when (eq deftype :deferred-mismatch)
          (setq deftype (if (consp def) :environment-mismatch :global-mismatch)))
        (make-condition
         'invalid-arguments
         :function-name (compiler-warning-function-name w)
         :source-note (compiler-warning-source-note w)
         :warning-type deftype
         :args (list (car (compiler-warning-args w)) reason arglist spread-p))))))

(defun verify-deferred-function-warning (w)
  (let* ((args (compiler-warning-args w))
	 (wfname (car args))
	 (def (deferred-function-def wfname)))
    (cond ((null def) w)
	  ((or (typep def 'function)
	       (and (consp def)
		    (def-info.lfbits (cdr def))))
	   ;; Check args in call to forward-referenced function.
	   (when (cdr args)
             (check-deferred-call-args w def (cdr args))))
	  ((def-info.macro-p (cdr def))
	   (let* ((w2 (make-condition
		       'macro-used-before-definition
		       :function-name (compiler-warning-function-name w)
		       :source-note (compiler-warning-source-note w)
		       :warning-type :macro-used-before-definition
		       :args (list (car args)))))
	     w2)))))

(defun verify-deferred-keyword-warning (w)
  (let* ((args (compiler-warning-args w))
         (wfname (car args))
         (def (deferred-function-def wfname)))
    (when def
      (check-deferred-call-args w def (cddr args)))))


(defun report-deferred-warnings (&optional (file nil))
  (let* ((current (ensure-merged-deferred-warnings *outstanding-deferred-warnings*))
         (parent (deferred-warnings.parent current))
         (warnings (deferred-warnings.warnings current))
         (any nil)
         (harsh nil))
    (if parent
      (progn
        (setf (deferred-warnings.last-file parent) (cons current file))
        (unless file ;; don't defer merge for non-file units.
          (ensure-merged-deferred-warnings parent))
        (setq parent t))
      (let* ((file nil)
             (init t))
	(dolist (w warnings)
	  (when (setq w (verify-deferred-warning w))
	    (multiple-value-setq (harsh any file) (signal-compiler-warning w init file harsh any))
	    (setq init nil)))))
    (values any harsh parent)))

(defun print-nested-name (name-list stream)
  (if (null name-list)
    (princ "a toplevel form" stream)
    (progn
      (if (car name-list)
        (prin1 (%car name-list) stream)
        (princ "an anonymous lambda form" stream))
      (when (%cdr name-list)
        (princ " inside " stream)
        (print-nested-name (%cdr name-list) stream)))))

(defparameter *suppress-compiler-warnings* nil)


(defun signal-compiler-warning (w init-p last-w-file harsh-p any-p &optional eval-p)
  (let ((muffled *suppress-compiler-warnings*)
        (w-file (compiler-warning-file-name w))
        (s *error-output*))
    (unless muffled 
      (restart-case (signal w)
        (muffle-warning () (setq muffled t))))
    (unless muffled
      (setq any-p t)
      (unless (typep w 'style-warning)
        (unless (eq harsh-p :very)
          (setq harsh-p t)
          (when (and (typep w 'compiler-warning)
                     (eq (compiler-warning-warning-type w) :program-error)
                     (typep (car (compiler-warning-args w)) 'error))
            (setq harsh-p :very))))
      (when (or init-p (not (equalp w-file last-w-file)))
        (format s "~&;~A warnings " (if (null eval-p) "Compiler" "Interpreter"))
        (if w-file (format s "for ~S :" w-file) (princ ":" s)))
      (let* ((indenting-stream (make-indenting-string-output-stream #\; 4)))
        (format indenting-stream ";~4t~a" w)
        (format s "~&~a~&" (get-output-stream-string indenting-stream))))
    (values harsh-p any-p w-file)))

;;;; Assorted mumble-P type predicates. 
;;;; No functions have been in the kernel for the last year or so.
;;;; (Just thought you'd like to know.)

(defun sequencep (form)
  "Not CL. SLISP Returns T if form is a sequence, NIL otherwise."
   (or (listp form) (vectorp form)))

;;; The following are not defined at user level, but are necessary for
;;; internal use by TYPEP.

(defun bitp (form)
  "Not CL. SLISP"
  (or (eq form 0) (eq form 1)))

(defun unsigned-byte-p (form)
  (and (integerp form) (not (< form 0))))

;This is false for internal structures.
;;; ---- look at defenv.structures, not defenv.structrefs

(defun structure-class-p (form &optional env)
  (and (symbolp form)
       (let ((sd (or (and env
                          (let ((defenv (definition-environment env)))
                            (and defenv
                                 (%cdr (assq form (defenv.structures defenv))))))
                     (gethash form %defstructs%))))
         (and sd
              (null (sd-type sd))
              sd))))





(defun type-keyword-code (type-keyword &optional target)
  ;; Don't really care about speed, but turn off typechecking for bootstrapping reasons
  (declare (optimize (speed 3) (safety 0)))
  (let* ((backend (if target (find-backend target) *target-backend*))
         (alist (arch::target-uvector-subtags (backend-target-arch backend)))
         (entry (assq type-keyword alist)))
    (if entry
      (let* ((code (cdr entry)))
        (or code (error "Vector type ~s invalid," type-keyword)))
      (error "Unknown type-keyword ~s. " type-keyword))))


(defstruct id-map
  (vector (make-array 1 :initial-element nil))
  (free 0)
  (lock (make-lock)))

;;; Caller owns the lock on the id-map.
(defun id-map-grow (id-map)
  (without-interrupts
   (let* ((old-vector (id-map-vector id-map))
          (old-size (length old-vector))
          (new-size (+ old-size old-size))
          (new-vector (make-array new-size)))
     (declare (fixnum old-size new-size))
     (dotimes (i old-size)
       (setf (svref new-vector i) (svref old-vector i)))
     (let* ((limit (1- new-size)))
       (declare (fixnum limit))
       (do* ((i old-size (1+ i)))
            ((= i limit) (setf (svref new-vector i) nil))
         (declare (fixnum i))
         (setf (svref new-vector i) (the fixnum (1+ i)))))
     (setf (id-map-vector id-map) new-vector
           (id-map-free id-map) old-size))))

;;; Map an object to a small fixnum ID in id-map.
;;; Object can't be NIL or a fixnum itself.
(defun assign-id-map-id (id-map object)
  (if (or (null object) (typep object 'fixnum))
    (setq object (require-type object '(not (or null fixnum)))))
  (with-lock-grabbed ((id-map-lock id-map))
    (let* ((free (or (id-map-free id-map) (id-map-grow id-map)))
           (vector (id-map-vector id-map))
           (newfree (svref vector free)))
      (setf (id-map-free id-map) newfree
            (svref vector free) object)
      free)))
      
;;; Referemce the object with id ID in ID-MAP.  Leave the object in
;;; the map.
(defun id-map-object (id-map id)
  (let* ((object (with-lock-grabbed ((id-map-lock id-map))
                   (svref (id-map-vector id-map) id))))
    (if (or (null object) (typep object 'fixnum))
      (error "invalid index ~d for ~s" id id-map)
      object)))

;;; Referemce the object with id ID in ID-MAP.  Remove the object from
;;; the map.
(defun id-map-free-object (id-map id)
  (with-lock-grabbed ((id-map-lock id-map))
    (let* ((vector (id-map-vector id-map))
           (object (svref vector id)))
      (if (or (null object) (typep object 'fixnum))
        (error "invalid index ~d for ~s" id id-map))
      (setf (svref vector id) (id-map-free id-map)
            (id-map-free id-map) id)
      object)))

(defun id-map-modify-object (id-map id old-value new-value)
  (with-lock-grabbed ((id-map-lock id-map))
    (let* ((vector (id-map-vector id-map))
           (object (svref vector id)))
      (if (or (null object) (typep object 'fixnum))
        (error "invalid index ~d for ~s" id id-map))
      (if (eq object old-value)
	(setf (svref vector id) new-value)))))


    

(setq *type-system-initialized* t)

;;; Try to map from a CTYPE describing some array/stream
;;; element-type to a target-specific typecode, catching
;;; cases that CTYPE-SUBTYPE missed.

(defun harder-ctype-subtype (ctype)
  (cond ((csubtypep ctype (load-time-value (specifier-type 'bit)))
         target::subtag-bit-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(unsigned-byte 8))))
         target::subtag-u8-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(unsigned-byte 16))))
         target::subtag-u16-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(unsigned-byte 32))))
         target::subtag-u32-vector)
        #+64-bit-target
        ((csubtypep ctype (load-time-value (specifier-type '(unsigned-byte 64))))
         target::subtag-u64-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(signed-byte 8))))
         target::subtag-s8-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(signed-byte 16))))
         target::subtag-s16-vector)
        #+32-bit-target
        ((csubtypep ctype (load-time-value (specifier-type `(integer ,target::target-most-negative-fixnum ,target::target-most-positive-fixnum))))
         target::subtag-fixnum-vector)
        ((csubtypep ctype (load-time-value (specifier-type '(signed-byte 32))))
         target::subtag-s32-vector)
        #+64-bit-target
        ((csubtypep ctype (load-time-value (specifier-type `(integer ,target::target-most-negative-fixnum ,target::target-most-positive-fixnum))))
         target::subtag-fixnum-vector)
        #+64-bit-target
        ((csubtypep ctype (load-time-value (specifier-type '(signed-byte 64))))
         target::subtag-s64-vector)
        (t target::subtag-simple-vector)))


#+count-gf-calls
(progn
;;; Call-counting for generic functions.  We overload the
;;; (previously unused
(defmethod generic-function-call-count ((gf generic-function))
  (gf.hash gf))


(defun (setf generic-function-call-count) (count gf)
  (setf (gf.hash gf) (require-type count 'fixnum)))

(defun clear-all-generic-function-call-counts ()
  (dolist (gf (population.data %all-gfs%))
    (setf (gf.hash gf) 0)))
);#+count-gf-calls


;;; Sparse vectors, or at least a certain kind of sparse-vector.
;;; This kind is oriented strongly towards maintaining character
;;; attributes for Unicode characters (for the reader, Hemlock,etc.)
(defstruct (sparse-vector (:constructor %make-sparse-vector)
                          (:copier nil))
  size
  element-type
  default
  table
  (lock (make-lock)))

(defun make-sparse-vector (size element-type default)
  (unless (and (typep size 'fixnum)
               (locally (declare (fixnum size))
                 (and (> size 0)
                      (< size array-total-size-limit))))
    (report-bad-arg size `(integer 1 ,array-total-size-limit)))
  (setq element-type (upgraded-array-element-type element-type))
  (unless (typep default element-type)
    (report-bad-arg default element-type))
  (%make-sparse-vector :size size
                       :element-type element-type
                       :default default
                       :table (make-array 1
                                          :element-type t
                                          :initial-element nil)))

(defun sparse-vector-ref (sv i)
  (unless (and (typep i 'fixnum)
               (>= (the fixnum i) 0)
               (< (the fixnum i) (the fixnum (sparse-vector-size sv))))
    (error "~s is not a valid index for ~s" i sv))
  (locally (declare (fixnum i))
    (let* ((major (ash i -8))
           (table (sparse-vector-table sv))
           (v (if (< major (length table))
                (svref table major))))
      (declare (fixnum major))
      (if (null v)
        (sparse-vector-default sv)
        (uvref v (logand i #xff))))))

(defun sparse-vector-count (sv)
  "Returns number of entries in sparse vector.
  (Actually, it just counts how many elements are not the default value.
  So this can be fooled because it can't distinguish the default value from a valid value that happens to be eql to default.)"
  (with-lock-grabbed ((sparse-vector-lock sv))
    (let* ((table (sparse-vector-table sv))
           (majormax (length table))
           (default (sparse-vector-default sv))
           (total 0))
      (declare (fixnum total))
      (flet ((tally-vector (v)
               (dotimes (i 256)
                 (declare (fixnum i))
                 (unless (eql default (uvref v i))
                   (incf total)))))
        (dotimes (i majormax)
          (declare (fixnum i))
          (let ((v (svref table i)))
            (when v (tally-vector v))))
        total))))

(defun (setf sparse-vector-ref) (new sv i)
  (unless (and (typep i 'fixnum)
               (>= (the fixnum i) 0)
               (< (the fixnum i) (the fixnum (sparse-vector-size sv))))
    (%err-disp $xarroob sv i))
  (let* ((default (sparse-vector-default sv)))
    (with-lock-grabbed ((sparse-vector-lock sv))
      (locally (declare (fixnum i))
        (let* ((major (ash i -8))
               (minor (logand i #xff))
               (table (sparse-vector-table sv))
               (tablen (length table))
               (v (if (< major tablen)
                    (svref table major))))
          (unless v
            (unless (eql new default)
              (when (>= major tablen)
                (let* ((newtab (make-array (the fixnum (1+ major)) :initial-element nil)))
                  (%copy-gvector-to-gvector table 0 newtab 0 tablen)
                  (setf (sparse-vector-table sv) (setq table newtab))))
              (setq v (setf (svref table major) (make-array 256 :element-type (sparse-vector-element-type sv) :initial-element default)))))
          (when v
            (uvset v minor new))))))
  new)

(defun copy-sparse-vector (in)
  (let* ((intab (sparse-vector-table in))
         (tabsize (length intab )))
    (declare (fixnum tabsize) (simple-vector intab))
    (let* ((out (%make-sparse-vector :size (sparse-vector-size in)
                                     :element-type (sparse-vector-element-type in)
                                     :default (sparse-vector-default in)
                                     :table (make-array tabsize :initial-element nil)))
           (outtab (sparse-vector-table out)))
      (declare (simple-vector outtab))
      (dotimes (i tabsize out)
        (let* ((v (svref intab i)))
          (when v
            (setf (svref outtab i) (copy-seq v))))))))

(defmethod print-object ((sv sparse-vector) stream)
  (print-unreadable-object (sv stream :type t :identity t)
    (format stream "~d ~s" (sparse-vector-size sv) (sparse-vector-element-type sv))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/sysutils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/l1-sockets.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 2001-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defclass socket ()
  ())

(defclass ip-socket (socket)
  ())

(defclass file-socket (socket)
  ())

(defclass tcp-socket (ip-socket)
  ())

(defclass stream-file-socket (file-socket)
  ())

;;; An active TCP socket is an honest-to-goodness stream.
(defclass tcp-stream (tcp-socket)
  ())

(defclass fundamental-tcp-stream (tcp-stream
                                  fd-stream
                                  buffered-binary-io-stream-mixin
                                  buffered-character-io-stream-mixin)
    ())

(make-built-in-class 'basic-tcp-stream
                     'tcp-stream
                     'basic-binary-io-stream
                     'basic-character-io-stream)

;;; A FILE-SOCKET-STREAM is also honest. To goodness.
(defclass file-socket-stream (stream-file-socket)
  ())

(defclass fundamental-file-socket-stream (file-socket-stream
                                          fd-stream
                                          buffered-binary-io-stream-mixin
                                          buffered-character-io-stream-mixin)
    ())

(make-built-in-class 'basic-file-socket-stream
                     'file-socket-stream
                     'basic-binary-io-stream
                     'basic-character-io-stream)

(defclass device-mixin ()
  ((device :initarg :device :accessor socket-device)
   (keys :initarg :keys :reader socket-keys)))

;; A passive tcp socket just generates connection streams
(defclass listener-socket (tcp-socket device-mixin) ())

(defclass file-listener-socket (stream-file-socket device-mixin) ())

;; A udp socket just sends and receives packets.
(defclass udp-socket (ip-socket device-mixin)
  ((connected :initarg :connected :initform nil :accessor socket-connected
              :documentation "True if the socket is connected in the UDP sense,
              i.e. it has had #_connect successfully called on it.")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/l1-sockets.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/runtime.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Load .pfsl files, create a "runtime" (compiler- & development-tools-less)
;;; image.

(in-package "CCL")

(%fasload "./l1-pfsls/l1-cl-package.pfsl")
(%fasload "./l1-pfsls/l1-utils.pfsl")
(%fasload "./l1-pfsls/l1-init.pfsl")
(%fasload "./l1-pfsls/l1-symhash.pfsl")
(%fasload "./l1-pfsls/l1-numbers.pfsl")
(%fasload "./l1-pfsls/l1-aprims.pfsl")
(%fasload "./l1-pfsls/ppc-callback-support.pfsl")
(%fasload "./l1-pfsls/l1-sort.pfsl")
(%fasload "./l1-pfsls/l1-dcode.pfsl")
(%fasload "./l1-pfsls/l1-clos.pfsl")
(%fasload "./binppc/defstruct.pfsl")
(%fasload "./l1-pfsls/l1-streams.pfsl")
(%fasload "./l1-pfsls/linux-files.pfsl")
(%fasload "./binppc/lists.pfsl")
(%fasload "./binppc/sequences.pfsl")
(%fasload "./binppc/chars.pfsl")
(%fasload "./l1-pfsls/l1-files.pfsl")
(provide "SEQUENCES")
(provide "DEFSTRUCT")
(provide "CHARS")
(provide "LISTS")
(%fasload "./l1-pfsls/ppc-stack-groups.pfsl")
(%fasload "./l1-pfsls/l1-stack-groups.pfsl")
(%fasload "./l1-pfsls/l1-processes.pfsl")
(%fasload "./l1-pfsls/l1-io.pfsl")
(%fasload "./l1-pfsls/l1-reader.pfsl")
(%fasload "./l1-pfsls/l1-readloop.pfsl")
(%fasload "./l1-pfsls/l1-readloop-lds.pfsl")
(%fasload "./l1-pfsls/l1-error-system.pfsl")

(%fasload "./l1-pfsls/l1-events.pfsl")
(%fasload "./l1-pfsls/ppc-trap-support.pfsl")
(%fasload "./l1-pfsls/l1-format.pfsl")
(%fasload "./l1-pfsls/l1-sysio.pfsl")
(%fasload "./l1-pfsls/l1-pathnames.pfsl")
(%fasload "./l1-pfsls/version.pfsl")
(%fasload "./l1-pfsls/l1-boot-lds.pfsl")

(%fasload "./l1-pfsls/l1-boot-1.pfsl")
(catch :toplevel
    (%fasload "./l1-pfsls/l1-typesys.pfsl")
    (%fasload "./l1-pfsls/sysutils.pfsl")
    (%fasload "./l1-pfsls/l1-error-signal.pfsl")
    (setq *LEVEL-1-LOADED* t))

(def-ccl-pointers fd-streams ()
  (let* ((in (make-fd-stream 0 :direction :input))
         (out (make-fd-stream 1 :direction :output))
         (error out))
    (setq *terminal-io* (make-echoing-two-way-stream in out))
    (setq *debug-io* (make-echoing-two-way-stream in error)
          *query-io* *debug-io*)
    (setq *standard-input* in
          *standard-output* out
          *error-output* error
          *trace-output* error)))

(catch :toplevel
    (flet ((load-provide (module path)
             (let* ((*package* *package*))
               (%fasload path)
               (provide module))))
      (load-provide "SORT" "./binppc/sort.pfsl")
      (load-provide "NUMBERS" "./binppc/numbers.pfsl")
      (load-provide "HASH" "./binppc/hash.pfsl")
;;;   (load-provide "DLL-NODE" "./binppc/dll-node.pfsl")
;;;   (load-provide "PPC32-ARCH" "./binppc/ppc32-arch.pfsl")
;;;   (load-provide "VREG" "./binppc/vreg.pfsl")
;;;   (load-provide "PPC-ASM" "./binppc/ppc-asm.pfsl")
;;;   (load-provide "VINSN" "./binppc/vinsn.pfsl")
;;;   (load-provide "PPC-VINSNS" "./binppc/ppc-vinsns.pfsl")
;;;   (load-provide "PPC-REG" "./binppc/ppc-reg.pfsl")
;;;   (load-provide "SUBPRIMS" "./binppc/subprims.pfsl")
;;;   (load-provide "PPC-LAP" "./binppc/ppc-lap.pfsl")
;;;   (provide "PPC2")                  ; Lie, load the module manually
;;;   (load-provide "NX" "./l1-pfsls/nx.pfsl")
;;;   (%fasload "./binppc/ppc2.pfsl")
      (load-provide "LEVEL-2" "./binppc/level-2.pfsl")
;;;     (load-provide "SETF" "./binppc/setf.pfsl")
      (load-provide "SETF-RUNTIME" "./binppc/setf-runtime.pfsl")
      (load-provide "FORMAT" "./binppc/format.pfsl")
      (load-provide "STREAMS" "./binppc/streams.pfsl")
;;;   (load-provide "OPTIMIZERS" "./binppc/optimizers.pfsl")
;;;   (load-provide "PPC-OPTIMIZERS" "./binppc/ppc-optimizers.pfsl")
;;;   (load-provide "LISPEQU" "./library/lispequ.pfsl")          ; Shouldn't need this at load time ...
;;;   (load-provide "DEFSTRUCT-MACROS" "./binppc/defstruct-macros.pfsl")        ;  ... but this file thinks it does.
;;;   (load-provide "DEFSTRUCT-LDS" "./binppc/defstruct-lds.pfsl")
;;;   (load-provide "NFCOMP" "./binppc/nfcomp.pfsl")
;;;   (load-provide "BACKQUOTE" "./binppc/backquote.pfsl")
      (load-provide "BACKTRACE-LDS" "./binppc/backtrace-lds.pfsl")
      (load-provide "BACKTRACE" "./binppc/backtrace.pfsl")
      (load-provide "READ" "./binppc/read.pfsl")
      (load-provide "ARRAYS-FRY" "./binppc/arrays-fry.pfsl")
;;;   (load-provide "APROPOS" "./binppc/apropos.pfsl")
;;;   (load-provide "PPC-DISASSEMBLE" "./binppc/ppc-disassemble.pfsl")
;;;   (load-provide "PPC-LAPMACROS" "./binppc/ppc-lapmacros.pfsl")
;;;   (load-provide "MACTYPES" "./binppc/mactypes.pfsl")
;;;   (load-provide "DEFRECORD" "./binppc/defrecord.pfsl")
;;;   (load-provide "LINUX-RECORDS" "./library/linux-records.pfsl")
      (load-provide "CASE-ERROR" "./binppc/case-error.pfsl")
;;;   (load-provide "ENCAPSULATE" "./binppc/encapsulate.pfsl")
      (load-provide "METHOD-COMBINATION" "./binppc/method-combination.pfsl")
      (load-provide "MISC" "./binppc/misc.pfsl")
      (load-provide "PPRINT" "./binppc/pprint.pfsl")
      (load-provide "DUMPLISP" "./binppc/dumplisp.pfsl")
      (load-provide "PATHNAMES" "./binppc/pathnames.pfsl")
      (load-provide "TIME" "./binppc/time.pfsl")
;;;   (load-provide "COMPILE-CCL" "./binppc/compile-ccl.pfsl")
;;;   (load-provide "SOURCE-FILES" "./binppc/source-files.pfsl")
      (load-provide "CCL-EXPORT-SYMS" "./binppc/ccl-export-syms.pfsl")
      )
    (setq *%fasload-verbose* nil)
    )
(catch :toplevel
    (or (find-package "COMMON-LISP-USER")
        (make-package "COMMON-LISP-USER" :use '("COMMON-LISP" "CCL") :NICKNAMES '("CL-USER")))
)

(defvar *LISTENER-PROCESS-STACKSEG-SIZE* (* 4 16384))

(setf (interrupt-level) 0)

(setq *warn-if-redefine* t)

(setq *level-1-loaded* t)

(set-periodic-task-interval 1)

(do-all-symbols (s)
  (setf (symbol-plist s) nil))

(progn (%set-toplevel #'toplevel-loop) (save-application "RUNTIME"))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/runtime.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/level-1/ppc-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; low-level support for PPC threads and stack-backtrace printing

(in-package "CCL")


;;; Sure would be nice to have &optional in defppclapfunction arglists
;;; Sure would be nice not to do this at runtime.

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref)))))

(let ((bits (lfun-bits #'(lambda (x &optional y) (declare (ignore x y))))))
  (lfun-bits #'%fixnum-ref-natural
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-ref-natural)))))

(let ((bits (lfun-bits #'(lambda (x y &optional z) (declare (ignore x y z))))))
  (lfun-bits #'%fixnum-set
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-set)))))

(let ((bits (lfun-bits #'(lambda (x y &optional z) (declare (ignore x y z))))))
  (lfun-bits #'%fixnum-set-natural
             (dpb (ldb $lfbits-numreq bits)
                  $lfbits-numreq
                  (dpb (ldb $lfbits-numopt bits)
                       $lfbits-numopt
                       (lfun-bits #'%fixnum-set-natural)))))


  
				  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;



    
    
(defun %frame-backlink (p &optional context)
  (cond ((fake-stack-frame-p p)
         (%fake-stack-frame.next-sp p))
        ((fixnump p)
         (let ((backlink (%%frame-backlink p))
               (fake-frame
                (if context (bt.fake-frames context) *fake-stack-frames*)))
           (loop
             (when (null fake-frame) (return backlink))
             (when (eq backlink (%fake-stack-frame.sp fake-frame))
               (return fake-frame))
             (setq fake-frame (%fake-stack-frame.link fake-frame)))))
        (t (error "~s is not a valid stack frame" p))))




(defun catch-frame-sp (catch)
  (uvref catch target::catch-frame.csp-cell))

(defun bottom-of-stack-p (p context)
  (and (fixnump p)
       (locally (declare (fixnum p))
	 (let* ((tcr (if context (bt.tcr context) (%current-tcr)))
                (cs-area (%fixnum-ref tcr target::tcr.cs-area)))
	   (not (%ptr-in-area-p p cs-area))))))

(defun lisp-frame-p (p context)
  (or (fake-stack-frame-p p)
      (locally (declare (fixnum p))
        (let ((next-frame (%frame-backlink p context)))
          (when (fake-stack-frame-p next-frame)
            (setq next-frame (%fake-stack-frame.sp next-frame)))
          (locally (declare (fixnum next-frame))
            (if (bottom-of-stack-p next-frame context)
              (values nil t)
              (and
               (eql (ash target::lisp-frame.size (- target::fixnum-shift))
                    (the fixnum (- next-frame p)))
               ;; EABI C functions keep their saved LRs where we save FN or 0
               ;; The saved LR of such a function would be fixnum-tagged and never 0.
               (let* ((fn (%fixnum-ref p target::lisp-frame.savefn)))
                 (or (eql fn 0) (typep fn 'function))))))))))





#+ppc32-target
(defun valid-subtag-p (subtag)
  (declare (fixnum subtag))
  (let* ((tagval (ldb (byte (- ppc32::num-subtag-bits ppc32::ntagbits) ppc32::ntagbits) subtag)))
    (declare (fixnum tagval))
    (case (logand subtag ppc32::fulltagmask)
      (#. ppc32::fulltag-immheader (not (eq (%svref *immheader-types* tagval) 'bogus)))
      (#. ppc32::fulltag-nodeheader (not (eq (%svref *nodeheader-types* tagval) 'bogus)))
      (t nil))))

#+ppc64-target
(defun valid-subtag-p (subtag)
  (declare (fixnum subtag))
  (let* ((tagval (ash subtag (- ppc64::nlowtagbits))))
    (declare (fixnum tagval))
    (case (logand subtag ppc64::lowtagmask)
      (#. ppc64::lowtag-immheader (not (eq (%svref *immheader-types* tagval) 'bogus)))
      (#. ppc64::lowtag-nodeheader (not (eq (%svref *nodeheader-types* tagval) 'bogus)))
      (t nil))))

#+ppc32-target
(defun valid-header-p (thing)
  (let* ((fulltag (fulltag thing)))
    (declare (fixnum fulltag))
    (case fulltag
      (#.ppc32::fulltag-misc (valid-subtag-p (typecode thing)))
      ((#.ppc32::fulltag-immheader #.ppc32::fulltag-nodeheader) nil)
      (t t))))



#+ppc64-target
(defun valid-header-p (thing)
  (let* ((fulltag (fulltag thing)))
    (declare (fixnum fulltag))
    (case fulltag
      (#.ppc64::fulltag-misc (valid-subtag-p (typecode thing)))
      ((#.ppc64::fulltag-immheader-0
        #.ppc64::fulltag-immheader-1
        #.ppc64::fulltag-immheader-2
        #.ppc64::fulltag-immheader-3
        #.ppc64::fulltag-nodeheader-0
        #.ppc64::fulltag-nodeheader-1
        #.ppc64::fulltag-nodeheader-2
        #.ppc64::fulltag-nodeheader-3) nil)
      (t t))))




#+ppc32-target
(defun bogus-thing-p (x)
  (when x
    #+cross-compiling (return-from bogus-thing-p nil)
    (or (not (valid-header-p x))
        (let ((tag (lisptag x)))
          (unless (or (eql tag ppc32::tag-fixnum)
                      (eql tag ppc32::tag-imm)
                      (in-any-consing-area-p x))
            ;; This is terribly complicated, should probably write some LAP
            (let ((typecode (typecode x)))
                  (not (or (case typecode
                             (#.ppc32::tag-list
                              (temporary-cons-p x))
                             ((#.ppc32::subtag-symbol #.ppc32::subtag-code-vector)
                              t)              ; no stack-consed symbols or code vectors
                             (#.ppc32::subtag-value-cell
                              (on-any-vstack x))
                             (t
                              (on-any-tsp-stack x)))
                           (%heap-ivector-p x)))))))))



#+ppc64-target
(defun bogus-thing-p (x)
  (when x
    (or (not (valid-header-p x))
        (let ((tag (lisptag x)))
          (unless (or (eql tag ppc64::tag-fixnum)
                      (eql tag ppc64::tag-imm-0)
                      (eql tag ppc64::tag-imm-2)
                      (in-any-consing-area-p x))
            ;; This is terribly complicated, should probably write some LAP
            (let ((typecode (typecode x)))
                  (not (or (case typecode
                             (#.ppc64::fulltag-cons
                              (temporary-cons-p x))
                             ((#.ppc64::subtag-symbol #.ppc64::subtag-code-vector)
                              t)              ; no stack-consed symbols or code vectors
                             (#.ppc64::subtag-value-cell
                              (on-any-vstack x))
                             (t
                              (on-any-tsp-stack x)))
                           (%heap-ivector-p x)))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/level-1/ppc-threads-utils.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









