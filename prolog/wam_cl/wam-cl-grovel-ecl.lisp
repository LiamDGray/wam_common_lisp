;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/setf.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;  Copyright (c) 2015, Daniel KochmaÅ„ski.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                                setf routines

(in-package "SYSTEM")

(defun do-setf-method-expansion (name lambda args &optional (stores-no 1))
  (declare (si::c-local))
  (let* ((vars '())
         (inits '())
         (all '())
         (stores '()))
    (dolist (item args)
      (unless (or (fixnump item) (keywordp item))
        (push item inits)
        (setq item (gensym))
        (push item vars))
      (push item all))
    (dotimes (i stores-no)
      (declare (ignore i))
      (push (gensym) stores))
    (let* ((all (nreverse all)))
      (values (nreverse vars)
              (nreverse inits)
              stores
              (if lambda
                  (apply lambda (append stores all))
                  `(funcall #'(setf ,name) ,@stores ,@all))
              (cons name all)))))

(defun do-defsetf (access-fn function &optional (stores-no 1))
  (declare (type-assertions nil))
  (if (symbolp function)
      (do-defsetf access-fn
        #'(lambda (store &rest args)
            `(,function ,@args ,store))
        stores-no)
      (do-define-setf-method access-fn
        #'(lambda (env &rest args)
            (declare (ignore env))
            (do-setf-method-expansion access-fn function args stores-no)))))

(defun do-define-setf-method (access-fn function)
  (declare (type-assertions nil))
  (put-sysprop access-fn 'SETF-METHOD function))

;;; DEFSETF macro.
(defmacro defsetf (&whole whole access-fn &rest rest)
  "Syntax: (defsetf symbol update-fun [doc])
        or
        (defsetf symbol lambda-list (store-var*) {decl | doc}* {form}*)
Defines an expansion
        (setf (SYMBOL arg1 ... argn) value)
        => (UPDATE-FUN arg1 ... argn value)
           or
           (let* ((temp ARG)*)
             (multiple-value-bind (temp-s*)
                 values-form
               rest)
where REST is the value of the last FORM with parameters in
LAMBDA-LIST bound to the symbols TEMP* and with STORE-VAR* bound to
the symbols TEMP-S*.  The doc-string DOC, if supplied, is saved as a
SETF doc and can be retrieved by (documentation 'SYMBOL 'setf)."
  (let (function documentation stores)
    (if (and (car rest) (or (symbolp (car rest)) (functionp (car rest))))
        (setq function `',(car rest)
              documentation (cadr rest)
              stores `(,(gensym)))
        (let* ((args (first rest))
               (body (cddr rest)))
          (setq stores (second rest)
                documentation (find-documentation body)
                function `#'(lambda-block ,access-fn (,@stores ,@args) ,@body))))
    `(eval-when (compile load eval)
       ,(ext:register-with-pde whole `(do-defsetf ',access-fn ,function ,(length stores)))
       ,@(si::expand-set-documentation access-fn 'setf documentation)
       ',access-fn)))


;;; DEFINE-SETF-METHOD macro.
(defmacro define-setf-expander (access-fn args &rest body)
  "Syntax: (define-setf-expander symbol defmacro-lambda-list {decl | doc}*
          {form}*)
Defines the SETF-method for generalized-variables (SYMBOL ...).
When a form (setf (SYMBOL arg1 ... argn) value-form) is evaluated, the FORMs
given in the DEFINE-SETF-EXPANDER are evaluated in order with the parameters in
DEFMACRO-LAMBDA-LIST bound to ARG1 ... ARGn.  The last FORM must return five
values
        (var1 ... vark)
        (form1 ... formk)
        (value-var)
        storing-form
        access-form
in order.  These values are collectively called the five gangs of the
generalized variable (SYMBOL arg1 ... argn).  The whole SETF form is then
expanded into
        (let* ((var1 from1) ... (vark formk)
               (value-var value-form))
          storing-form)
The doc-string DOC, if supplied, is saved as a SETF doc and can be retrieved
by (DOCUMENTATION 'SYMBOL 'SETF)."
  (let ((env (member '&environment args :test #'eq)))
    (if env
        (setq args (cons (second env)
                         (nconc (ldiff args env) (cddr env))))
        (progn
          (setq env (gensym))
          (setq args (cons env args))
          (push `(declare (ignore ,env)) body))))
  `(eval-when (compile load eval)
     (do-define-setf-method ',access-fn #'(ext::lambda-block ,access-fn ,args ,@body))
     ,@(si::expand-set-documentation access-fn 'setf
                                     (find-documentation body))
     ',access-fn))


;;;; get-setf-expansion.

(defun get-setf-expansion (form &optional env &aux f)
  "Args: (form)
Returns the 'five gangs' (see DEFINE-SETF-EXPANDER) for PLACE as five values.
Does not check if the third gang is a single-element list."
  (declare (check-arguments-type nil))
  ;; Note that macroexpansion of SETF arguments can only be done via
  ;; MACROEXPAND-1 [ANSI 5.1.2.7]
  (cond ((symbolp form)
         (if (and (setq f (macroexpand-1 form env)) (not (equal f form)))
             (get-setf-expansion f env)
             (let ((store (gensym)))
               (values nil nil (list store) `(setq ,form ,store) form))))
        ((or (not (consp form)) (not (symbolp (car form))))
         (error "Cannot get the setf-method of ~S." form))
        ((setq f (get-sysprop (car form) 'SETF-METHOD))
         (apply f env (cdr form)))
        ((and (setq f (macroexpand-1 form env)) (not (equal f form)))
         (get-setf-expansion f env))
        (t
         (do-setf-method-expansion (car form) nil (cdr form)))))

;;;; SETF definitions.

(defsetf car (x) (y) `(progn (rplaca ,x ,y) ,y))
(defsetf cdr (x) (y) `(progn (rplacd ,x ,y), y))
(defsetf caar (x) (y) `(progn (rplaca (car ,x) ,y) ,y))
(defsetf cdar (x) (y) `(progn (rplacd (car ,x) ,y) ,y))
(defsetf cadr (x) (y) `(progn (rplaca (cdr ,x) ,y) ,y))
(defsetf cddr (x) (y) `(progn (rplacd (cdr ,x) ,y) ,y))
(defsetf caaar (x) (y) `(progn (rplaca (caar ,x) ,y) ,y))
(defsetf cdaar (x) (y) `(progn (rplacd (caar ,x) ,y) ,y))
(defsetf cadar (x) (y) `(progn (rplaca (cdar ,x) ,y) ,y))
(defsetf cddar (x) (y) `(progn (rplacd (cdar ,x) ,y) ,y))
(defsetf caadr (x) (y) `(progn (rplaca (cadr ,x) ,y) ,y))
(defsetf cdadr (x) (y) `(progn (rplacd (cadr ,x) ,y) ,y))
(defsetf caddr (x) (y) `(progn (rplaca (cddr ,x) ,y) ,y))
(defsetf cdddr (x) (y) `(progn (rplacd (cddr ,x) ,y) ,y))
(defsetf caaaar (x) (y) `(progn (rplaca (caaar ,x) ,y) ,y))
(defsetf cdaaar (x) (y) `(progn (rplacd (caaar ,x) ,y) ,y))
(defsetf cadaar (x) (y) `(progn (rplaca (cdaar ,x) ,y) ,y))
(defsetf cddaar (x) (y) `(progn (rplacd (cdaar ,x) ,y) ,y))
(defsetf caadar (x) (y) `(progn (rplaca (cadar ,x) ,y) ,y))
(defsetf cdadar (x) (y) `(progn (rplacd (cadar ,x) ,y) ,y))
(defsetf caddar (x) (y) `(progn (rplaca (cddar ,x) ,y) ,y))
(defsetf cdddar (x) (y) `(progn (rplacd (cddar ,x) ,y) ,y))
(defsetf caaadr (x) (y) `(progn (rplaca (caadr ,x) ,y) ,y))
(defsetf cdaadr (x) (y) `(progn (rplacd (caadr ,x) ,y) ,y))
(defsetf cadadr (x) (y) `(progn (rplaca (cdadr ,x) ,y) ,y))
(defsetf cddadr (x) (y) `(progn (rplacd (cdadr ,x) ,y) ,y))
(defsetf caaddr (x) (y) `(progn (rplaca (caddr ,x) ,y) ,y))
(defsetf cdaddr (x) (y) `(progn (rplacd (caddr ,x) ,y) ,y))
(defsetf cadddr (x) (y) `(progn (rplaca (cdddr ,x) ,y) ,y))
(defsetf cddddr (x) (y) `(progn (rplacd (cdddr ,x) ,y) ,y))
(defsetf first (x) (y) `(progn (rplaca ,x ,y) ,y))
(defsetf second (x) (y) `(progn (rplaca (cdr ,x) ,y) ,y))
(defsetf third (x) (y) `(progn (rplaca (cddr ,x) ,y) ,y))
(defsetf fourth (x) (y) `(progn (rplaca (cdddr ,x) ,y) ,y))
(defsetf fifth (x) (y) `(progn (rplaca (cddddr ,x) ,y) ,y))
(defsetf sixth (x) (y) `(progn (rplaca (nthcdr 5 ,x) ,y) ,y))
(defsetf seventh (x) (y) `(progn (rplaca (nthcdr 6 ,x) ,y) ,y))
(defsetf eighth (x) (y) `(progn (rplaca (nthcdr 7 ,x) ,y) ,y))
(defsetf ninth (x) (y) `(progn (rplaca (nthcdr 8 ,x) ,y) ,y))
(defsetf tenth (x) (y) `(progn (rplaca (nthcdr 9 ,x) ,y) ,y))
(defsetf rest (x) (y) `(progn (rplacd ,x ,y) ,y))
(defsetf svref sys:svset)
(defsetf elt sys:elt-set)
(defsetf symbol-value set)
(defsetf symbol-function sys:fset)
(defsetf fdefinition sys:fset)
(defsetf macro-function (s &optional env) (v) (declare (ignore env)) `(sys:fset ,s ,v t))
(defsetf aref si::aset)
(defsetf row-major-aref sys:row-major-aset)
(defsetf get (s p &optional d) (v)
  (if d `(progn ,d (sys:putprop ,s ,v ,p)) `(sys:putprop ,s ,v ,p)))
(defsetf get-sysprop put-sysprop)
(defsetf nth (n l) (v) `(progn (rplaca (nthcdr ,n ,l) ,v) ,v))
(defsetf char sys:char-set)
(defsetf schar sys:schar-set)
(defsetf bit sys:aset)
(defsetf sbit sys:aset)
(defsetf fill-pointer sys:fill-pointer-set)
(defsetf symbol-plist sys:set-symbol-plist)
(defsetf gethash (k h &optional d) (v) (declare (ignore d)) `(sys:hash-set ,k ,h ,v))
#-clos
(defsetf documentation sys::set-documentation)
#+clos
(defsetf sys:instance-ref sys:instance-set)
(defsetf compiler-macro-function (fname) (function)
  `(sys::put-sysprop ,fname 'sys::compiler-macro ,function))
(defsetf readtable-case sys:readtable-case-set)
(defsetf stream-external-format sys::stream-external-format-set)

(define-setf-expander getf (&environment env place indicator
                            &optional (default nil default-p))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (let* ((itemp (gensym)) (store (gensym)) (def (gensym)))
      (values `(,@vars ,itemp ,@(if default-p (list def) nil))
              `(,@vals ,indicator ,@(and default-p (list default)))
              `(,store)
              `(let ((,(car stores) (sys:put-f ,access-form ,store ,itemp)))
                 ,store-form
                 ,store)
              `(getf ,access-form ,itemp ,default)))))

(defsetf subseq (sequence1 start1 &optional end1)
                (sequence2)
  `(PROGN (REPLACE ,sequence1 ,sequence2 :START1 ,start1 :END1 ,end1)
    ,sequence2))

(define-setf-expander THE (&environment env type place)
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (values vars vals stores
            (subst `(THE ,type ,(first stores)) (first stores) store-form)
            `(THE ,type ,access-form))))

#|
(define-setf-expander apply (&environment env fn &rest rest)
  (unless (and (consp fn) (eq (car fn) 'FUNCTION) (symbolp (cadr fn))
               (null (cddr fn)))
          (error "Can't get the setf-method of ~S." fn))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion (cons (cadr fn) rest) env)
    (unless (eq (car (last store-form)) (car (last vars)))
            (error "Can't get the setf-method of ~S." fn))
    (values vars vals stores
            `(apply #',(car store-form) ,@(cdr store-form))
            `(apply #',(cadr fn) ,@(cdr access-form)))))
|#

(define-setf-expander apply (&environment env fn &rest rest)
  (unless (and (consp fn)
               (or (eq (car fn) 'FUNCTION) (eq (car fn) 'QUOTE))
               (symbolp (cadr fn))
               (null (cddr fn)))
    (error "Can't get the setf-method of ~S." fn))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion (cons (cadr fn) rest) env)
    (cond ((eq (car (last store-form)) (car (last vars)))
           (values vars vals stores
                   `(apply #',(car store-form) ,@(cdr store-form))
                   `(apply #',(cadr fn) ,@(cdr access-form))))
          ((eq (car (last (butlast store-form))) (car (last vars)))
           (values vars vals stores
                   `(apply #',(car store-form)
                           ,@(cdr (butlast store-form 2))
                           (append ,(car (last (butlast store-form)))
                                   (list ,(car (last store-form)))))
                   `(apply #',(cadr fn) ,@(cdr access-form))))
          (t (error "Can't get the setf-method of ~S." fn)))))

(define-setf-expander ldb (&environment env bytespec int)
  (multiple-value-bind (temps vals stores store-form access-form)
      (get-setf-expansion int env)
    (let* ((btemp (gensym))
           (store (gensym))
           (stemp (first stores)))
      (values `(,btemp ,@temps)
              `(,bytespec ,@vals)
              `(,store)
              `(let ((,stemp (dpb ,store ,btemp ,access-form)))
                 ,store-form ,store)
              `(ldb ,btemp ,access-form)))))

(define-setf-expander mask-field (&environment env bytespec int)
  (multiple-value-bind (temps vals stores store-form access-form)
      (get-setf-expansion int env)
    (let* ((btemp (gensym))
           (store (gensym))
           (stemp (first stores)))
      (values `(,btemp ,@temps)
              `(,bytespec ,@vals)
              `(,store)
              `(let ((,stemp (deposit-field ,store ,btemp ,access-form)))
                 ,store-form ,store)
              `(mask-field ,btemp ,access-form)))))

(defun trivial-setf-form (place vars stores store-form access-form)
  (declare (si::c-local)
           (optimize (speed 3) (safety 0)))
  (and (atom place)
       (null vars)
       (eq access-form place)
       (= (length stores) 1)
       (listp store-form)
       (= (length store-form) 3)
       (member (first store-form) '(setq setf))
       (eq (second store-form) place)
       (eq (third store-form) (first stores))
       ))

(defun try-simpler-expansion (place vars vals stores newvalue store-form)
  ;; When the store form contains all the original arguments in order
  ;; followed by a single stored value, we can produce an expansion
  ;; without LET forms.
  (declare (si::c-local)
           (optimize (speed 3) (safety 0)))
  (when (and (consp place)
             (consp store-form)
             (= (length place) (truly-the fixnum (1- (length store-form)))))
    (let ((function (pop store-form))
          (output '())
          v)
      (dolist (i (rest place)
               (when (eq (first stores) (first store-form))
                 (list* function
                        (nreverse (cons newvalue output)))))
        (unless (consp store-form)
          (return nil))
        (setq v (car (truly-the cons store-form))
              store-form (cdr (truly-the cons store-form)))
        ;; This checks that the argument at this position coincides with
        ;; the corresponding value in the original list. Note that the
        ;; variable list need not be in order.
        (unless (or (eq v i)
                    (and (eq v (pop vars))
                         (eq (pop vals) i)))
          (return nil))
        (push i output)))))

;;; The expansion function for SETF.
(defun setf-expand-1 (place newvalue env)
  (declare (si::c-local)
           (notinline mapcar))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (cond ((trivial-setf-form place vars stores store-form access-form)
           (list 'setq place newvalue))
          ((try-simpler-expansion place vars vals stores newvalue store-form))
          (t
           `(let* ,(mapcar #'list vars vals)
              ;; Unfortunately we cannot do this because there is code out
              ;; there that changes the variables and values
              ;; (declare (:read-only ,@vars))
              (multiple-value-bind ,stores ,newvalue
                ;; Same here
                ;; (declare (:read-only ,@stores))
                ,store-form))))))

(defun setf-expand (l env)
  (declare (si::c-local))
  (cond ((endp l) nil)
        ((endp (cdr l)) (error "~S is an illegal SETF form." l))
        (t
         (cons (setf-expand-1 (car l) (cadr l) env)
               (setf-expand (cddr l) env)))))

;;; SETF macro.
(defmacro setf (&environment env &rest rest)
  "Syntax: (setf {place form}*)
Evaluates each FORM and assigns the value to the corresponding PLACE in order.
Returns the value of the last FORM.
Each PLACE may be any one of the following:
  * A symbol that names a variable.
  * A function call form whose first element is the name of the following
    functions:
        nth     elt     subseq  rest    first ... tenth
        c?r     c??r    c???r   c????r
        aref    svref   char    schar   bit     sbit    fill-pointer
        get     getf    documentation   symbol-value    symbol-function
        symbol-plist    macro-function  gethash         fdefinition
        char-bit        ldb     mask-field
        apply   slot-value
    where '?' stands for either 'a' or 'd'.
  * A function call form whose first element is:
        1. an access function for a structure slot
        2. an accessor method for a CLOS object
  * the form (THE type place) with PLACE being a place recognized by SETF.
  * a macro call which expands to a place recognized by SETF.
  * any form for which a DEFSETF or DEFINE-SETF-EXPANDER declaration has been
    made."
  (cond ((endp rest) nil)
        ((endp (cdr rest)) (error "~S is an illegal SETF form." rest))
        ((endp (cddr rest)) (setf-expand-1 (car rest) (cadr rest) env))
        (t (cons 'progn (setf-expand rest env)))))

;;; PSTEF/SHIFTF/ROTATEF base macros

;; WITH-SETF-EXPANSIONS
(defmacro with-setf-expansions
    ((pairs stores store-forms access-forms)
     (args &optional env) &body body)
  "Syntax: (with-setf-expansions (pairs stores store-forms access-forms)
            ({place}* &optional env) {form}*)
Map setf-expansions of places into list of bindings in PAIRS, list of
stores in STORES, list of store-form in STORE-FORMS and list of
access-form in ACCESS-FORMS.  Creates new lexical scope composed of
these variables."
  (declare (notinline mapcar))
  `(destructuring-bind (,pairs ,stores ,store-forms ,access-forms)
       (reduce (lambda (x y)
                 (list
                  (cons (mapcar #'list (first y) (second y))
                        (first x))
                  (cons (third  y) (second x))
                  (cons (fourth y) (third  x))
                  (cons (fifth  y) (fourth x))))
               (mapcar (lambda (place)
                         (multiple-value-list
                          (get-setf-expansion place ,env)))
                       (reverse ,args))
               :initial-value '(nil nil nil nil))
     ,@body))

;;; PSETF macro.
(defmacro psetf (&environment env &rest args)
    "Syntax: (psetf {place form}*)
Similar to SETF, but evaluates all FORMs first, and then assigns each value to
the corresponding PLACE.  Returns NIL."
    (multiple-value-bind (places forms)
        (do* ((args args (cddr args))
              places forms)
             ((endp args)
              (values (nreverse places)
                      (nreverse forms)))
          (when (endp (cdr args))
            (error "~S is an illegal PSETF form (odd number of arguments)." args))
          (push (car args) places)
          (push (cadr args) forms))
      (with-setf-expansions (pairs stores store-forms access-forms) (places env)
        (declare (ignore access-forms))
        (labels ((thunk (pairs stores access-forms)
                   (if stores
                       `((let ,(car pairs)
                           (multiple-value-bind ,(car stores) ,(car access-forms)
                             ,@(thunk (cdr pairs) (cdr stores) (cdr access-forms)))))
                       store-forms)))
          `(prog1 nil
             ,@(thunk pairs stores forms))))))

;; WITH-EXPANSION-SETTER
(defmacro with-expansion-setter ((name store-forms) &body body)
  "Syntax: (with-expansion-setter (name store-forms) {form}*)
Macro creates lexically-scoped function NAME, which takes two lists as
arguments, and expands into nested MULTIPLE-VALUE-BINDs of ACCESS-FORMS
into STORES.  Finally inside bindings it expands STORE-FORMS."
  `(labels ((,name (stores access-forms)
              (if stores
                  `((multiple-value-bind ,(car stores) ,(car access-forms)
                      ,@(,name (cdr stores) (cdr access-forms))))
                  `(,@,store-forms))))
     ,@body))

;;; SHIFTF macro.
(defmacro shiftf (&environment env &rest args)
    "Syntax: (shiftf {place}+ form)
Saves the values of PLACE and FORM, and then assigns the value of each PLACE
to the PLACE on its left.  The rightmost PLACE gets the value of FORM.
Returns the original value of the leftmost PLACE."
  (with-setf-expansions (pairs stores store-forms access-forms)
      ((butlast args) env)
    (with-expansion-setter (thunk store-forms)
      `(let* ,(reduce #'append pairs)
         (multiple-value-prog1 ,(car access-forms)
           ,@(thunk stores
                    (append (cdr access-forms)
                            (last args))))))))

;;; ROTATEF macro.
(defmacro rotatef (&environment env &rest args)
  "Syntax: (rotatef {place}*)
Saves the values of PLACEs, and then assigns to each PLACE the saved value of
the PLACE to its right.  The rightmost PLACE gets the value of the leftmost
PLACE.  Returns NIL."
  (with-setf-expansions (pairs stores store-forms access-forms)
      (args env)
    (with-expansion-setter (thunk store-forms)
      `(let* ,(reduce #'append pairs)
         ,@(thunk stores
                  (append (cdr access-forms)
                          (list (car access-forms))))
         nil))))

;;; DEFINE-MODIFY-MACRO macro, by Bruno Haible.
(defmacro define-modify-macro (name lambdalist function &optional docstring)
  "Syntax: (define-modify-macro symbol lambda-list function-name [doc])
Defines a read-modify-write macro like INCF.  The defined macro will expand
a form (SYMBOL place form1 ... formn) into a form that in effect SETFs the
value of (FUNCTION-NAME place arg1 ... argm) into PLACE, where ARG1 ... ARGm
are parameters in LAMBDA-LIST which are bound to FORM1 ... FORMn.  For
example, INCF could be defined as
        (define-modify-macro incf (&optional (x 1)) +)
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (DOCUMENTATION 'SYMBOL 'FUNCTION)."
  (let* ((varlist nil)
         (restvar nil))
    (do* ((lambdalistr lambdalist (cdr lambdalistr))
          (next))
         ((null lambdalistr))
      (setq next (first lambdalistr))
      (cond ((eq next '&OPTIONAL))
            ((eq next '&REST)
             (if (symbolp (second lambdalistr))
                 (setq restvar (second lambdalistr))
                 (error "In the definition of ~S: &REST variable ~S should be a symbol."
                        name (second lambdalistr)))
             (if (null (cddr lambdalistr))
                 (return)
                 (error "Only one variable is allowed after &REST, not ~S"
                        lambdalistr)))
            ((or (eq next '&KEY) (eq next '&ALLOW-OTHER-KEYS) (eq next '&AUX))
             (error "Illegal in a DEFINE-MODIFY-MACRO lambda list: ~S"
                    next))
            ((symbolp next) (push next varlist))
            ((and (listp next) (symbolp (first next)))
             (push (first next) varlist))
            (t (error "lambda list may only contain symbols and lists, not ~S"
                      next))))
    (setq varlist (nreverse varlist))
    `(DEFMACRO ,name (&ENVIRONMENT ENV %REFERENCE ,@lambdalist)
       ,@(and docstring (list docstring))
       (DECLARE (NOTINLINE MAPCAR))
       (MULTIPLE-VALUE-BIND (VARS VALS STORES SETTER GETTER)
           (GET-SETF-EXPANSION %REFERENCE ENV)
         (LET ((ALL-VARS (MAPCAR #'(LAMBDA (V) (LIST (GENSYM) V)) (LIST* ,@varlist ,restvar))))
           (IF (SYMBOLP GETTER)
               (SUBST (LIST* (QUOTE ,function) GETTER (MAPCAR #'CAR ALL-VARS))
                      (CAR STORES)
                      `(LET* ,ALL-VARS
                         (DECLARE (:READ-ONLY ,@(mapcar #'first all-vars)))
                         ,SETTER))
               (DO ((D VARS (CDR D))
                    (V VALS (CDR V))
                    (LET-LIST NIL (CONS (LIST (CAR D) (CAR V)) LET-LIST)))
                   ((NULL D)
                    (SETQ LET-LIST
                          (LIST*
                           (LIST
                            (CAR STORES)
                            (LIST* (QUOTE ,function) GETTER (MAPCAR #'CAR ALL-VARS)))
                           (APPEND ALL-VARS LET-LIST)))
                    `(LET* ,(NREVERSE LET-LIST)
                       (DECLARE (:READ-ONLY ,@(mapcar #'first all-vars)
                                            ,@vars))
                       ,SETTER)))))))))

#+(or)
(defmacro define-modify-macro (name lambda-list function &optional doc-string)
  (let ((update-form
         (do ((l lambda-list (cdr l))
              (vs nil))
             ((null l) `(list ',function access-form ,@(nreverse vs)))
           (unless (eq (car l) '&optional)
                   (if (eq (car l) '&rest)
                       (return `(list* ',function
                                       access-form
                                       ,@(nreverse vs)
                                       ,(cadr l))))
                   (if (symbolp (car l))
                       (setq vs (cons (car l) vs))
                       (setq vs (cons (caar l) vs)))))))
    `(defmacro ,name (&environment env reference . ,lambda-list)
       ,@(if doc-string (list doc-string))
       (when (symbolp reference)
             (return-from ,name
               (let ((access-form reference))
                 (list 'setq reference ,update-form))))
       (multiple-value-bind (vars vals stores store-form access-form)
           (get-setf-expansion reference env)
         `(let* ,(mapcar #'list
                  (append vars stores)
                  (append vals (list ,update-form)))
           (declare (:read-only ,@stores)) ; Beppe
           ,store-form)))))

;;; Some macro definitions.

(defmacro remf (&environment env place indicator)
  "Syntax: (remf place form)
Removes the property specified by FORM from the property list stored in PLACE.
Returns T if the property list had the specified property; NIL otherwise."
  (declare (notinline mapcar))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (let ((s (gensym)))
      `(let* (,@(mapcar #'list vars vals) (,s ,indicator))
         (declare (:read-only ,@vars)) ; Beppe
         (multiple-value-bind (,(car stores) flag)
             (sys:rem-f ,access-form ,s)
           ,store-form
           flag)))))

(define-modify-macro incf (&optional (delta 1)) +
  "Syntax: (incf place [form])
Increments the value of PLACE by the value of FORM.  FORM defaults to 1.")

(define-modify-macro decf (&optional (delta 1)) -
  "Syntax: (decf place [form])
Decrements the value of PLACE by the value of FORM.  FORM defaults to 1.")

(defmacro push (&environment env item place)
  "Syntax: (push form place)
Evaluates FORM, conses the value of FORM to the value stored in PLACE, and
makes it the new value of PLACE.  Returns the new value of PLACE."
  (declare (notinline mapcar))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (when (trivial-setf-form place vars stores store-form access-form)
      (return-from push `(setq ,place (cons ,item ,place))))
    ;; The item to be pushed has to be evaluated before the destination
    (unless (constantp item env)
      (setq vals (cons item vals)
            item (gensym)
            vars (cons item vars)))
    `(let* ,(mapcar #'list
                    (append vars stores)
                    (append vals (list (list 'cons item access-form))))
       (declare (:read-only ,@vars)) ; Beppe
       ,store-form)))

(defmacro pushnew (&environment env item place &rest rest)
  "Syntax: (pushnew form place {keyword-form value-form}*)
Evaluates FORM first.  If the value is already in the list stored in PLACE,
does nothing.  Else, conses the value onto the list and makes the result the
new value of PLACE.  Returns NIL.  KEYWORD-FORMs and VALUE-FORMs are used to
check if the value of FORM is already in PLACE as if their values are passed
to MEMBER."
  (declare (notinline mapcar))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (when (trivial-setf-form place vars stores store-form access-form)
      (return-from pushnew `(setq ,place (adjoin ,item ,place ,@rest))))
    ;; The item to be pushed has to be evaluated before the destination
    (unless (constantp item env)
      (setq vals (cons item vals)
            item (gensym)
            vars (cons item vars)))
    `(let* ,(mapcar #'list
                    (append vars stores)
                    (append vals
                            (list (list* 'adjoin item access-form rest))))
       (declare (:read-only ,@vars)) ; Beppe
       ,store-form)))

(defmacro pop (&environment env place)
  "Syntax: (pop place)
Gets the cdr of the value stored in PLACE and makes it the new value of PLACE.
Returns the car of the old value in PLACE."
  (declare (notinline mapcar))
  (multiple-value-bind (vars vals stores store-form access-form)
      (get-setf-expansion place env)
    (let ((store-var (first stores)))
      `(let* ,(mapcar #'list
                      (append vars stores)
                      (append vals (list access-form)))
         (declare (:read-only ,@vars)) ; Beppe
         (prog1 (car ,store-var)
           (setq ,store-var (cdr (truly-the list ,store-var)))
           ,store-form)))))

(define-setf-expander values (&rest values &environment env)
  (let ((all-vars '())
        (all-vals '())
        (all-stores '())
        (all-storing-forms '())
        (all-get-forms '()))
    (dolist (item (reverse values))
      (multiple-value-bind (vars vals stores storing-form get-form)
          (get-setf-expansion item env)
        ;; If a place has more than one store variable, the other ones
        ;; are set to nil.
        (let ((extra (rest stores)))
          (unless (endp extra)
            (setf vars (append extra vars)
                  vals (append (make-list (length extra)) vals)
                  stores (list (first stores)))))
        (setf all-vars (append vars all-vars)
              all-vals (append vals all-vals)
              all-stores (append stores all-stores)
              all-storing-forms (cons storing-form all-storing-forms)
              all-get-forms (cons get-form all-get-forms))))
    (values all-vars all-vals all-stores `(values ,@all-storing-forms)
            `(values ,@all-get-forms))))
#|
;;; Proposed extension:
; Expansion of (SETF (VALUES place1 ... placek) form)
; --> (MULTIPLE-VALUE-BIND (dummy1 ... dummyk) form
;       (SETF place1 dummy1 ... placek dummyk)
;       (VALUES dummy1 ... dummyk))
(define-setf-expander VALUES (&environment env &rest subplaces)
  (do ((temps) (vals) (stores)
       (storeforms) (accessforms)
       (placesr subplaces))
      ((atom placesr)
       (setq temps (nreverse temps)
             vals (nreverse vals)
             stores (nreverse stores)
             storeforms (nreverse storeforms)
             accessforms (nreverse accessforms))
       (values temps
            vals
            stores
            `(VALUES ,@storeforms)
            `(VALUES ,@accessforms)))
    (multiple-value-bind (SM1 SM2 SM3 SM4 SM5)
        (get-setf-expansion (pop placesr) env)
      (setq temps (revappend SM1 temps)
            vals (revappend SM2 vals)
            stores (revappend SM3 stores)
            storeforms (cons SM4 storeforms)
            accessforms (cons SM5 accessforms)))))
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/setf.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/util/defsys.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;
;;; **********************************************************************
;;; (c) Copyright G. Attardi, 1990.  All rights reserved.
;;; **********************************************************************

(defparameter *util-directory*  "")

(sbt:defsystem util

     :modules
     '((system  t       t       ())     ; a system building tool
       )

     :directory *util-directory*

     :pathname-types  '("lsp" . "o"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/util/defsys.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/util/gen-code.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Writing src/h/cons.h and src/c/cons.d
;;;

(defun process-file (filename)
  (let* ((filename (merge-pathnames filename))
         (name (pathname-name filename))
         (input (make-pathname :name (concatenate 'string "bak-" name)
                               :type (pathname-type filename)
                               :directory (pathname-directory filename)))
         (output filename))
    (cond ((not (probe-file filename))
           (error "Unable to find ~a" filename))
          ((probe-file input)
           (error "Backup already exists" input))
          (t
           (format t "~%;;; Renaming ~a -> ~a" filename input)
           (rename-file filename input)))
    (with-open-file (in input :direction :input)
      (with-open-file (out output :direction :output :if-exists :supersede)
        (format t "~%;;; Transforming ~a -> ~a" input output)
        (loop with skip = nil
              for l = (read-line in nil nil nil)
              while l
              do (cond (skip
                        (when (search "END-GENERATED" l)
                          (write-line l out)
                          (setf skip nil)))
                       (t
                        (write-line l out)
                        (let ((ndx (search "BEGIN-GENERATED" l)))
                          (when ndx
                            (let* ((*standard-output* out)
                                   (form-text (subseq l (+ ndx 15)))
                                   (form (read-from-string form-text)))
                              (eval form)
                              (setf skip t)))))))))
    (format t "~%;;; Deleting the file ~a" input)
    (delete-file input)))

(defun write-rec (depth list flag &optional (prefix ""))
  (when (plusp depth)
    (write-rec (1- depth) (cons 'a list) flag)
    (write-rec (1- depth) (cons 'd list) flag)
    (return-from write-rec))
  (let* ((string (apply #'concatenate 'string (mapcar #'string-downcase list))))
    (case flag
      (:inline
       (write-rec depth list :unsafe "static ECL_INLINE "))
      (:unsafe-macro
       (format t "~%#define C~AR(x) _ecl_c~ar(x)" (string-upcase string) string))
      (:unsafe
       (format t "~%~acl_object _ecl_c~ar(cl_object x)~%{" prefix string)
       (loop for what in (reverse list)
             for op = (if (eq what 'a) "ECL_CONS_CAR" "ECL_CONS_CDR")
             do (format t "~%  if (Null(x)) return x;~%  x = ~A(x);" op))
       (format t "~%  return x;~%}~%"))
      (:safe
       (format t "~%cl_object ecl_c~ar(cl_object x)~%{" string)
       (loop for what in (reverse list)
             for op = (if (eq what 'a) "ECL_CONS_CAR" "ECL_CONS_CDR")
             do (format t "~%  if (ecl_unlikely(!ECL_LISTP(x))) FEwrong_type_nth_arg(@[car], 1, x, @[list]);")
             do (format t "~%  if (Null(x)) return x;~%  x = ~A(x);" op))
       (format t "~%  return x;~%}~%"))
      (:common-lisp
       (format t "~%cl_object cl_c~ar(cl_object x)~%{~%  return1(ecl_c~ar(x));~%}~%"
               string string))
      (:declare-unsafe
       (format t "~%extern ECL_API cl_object _ecl_c~ar(cl_object);" string))
      (:declare-safe
       (format t "~%extern ECL_API cl_object ecl_c~ar(cl_object);" string))
      (:declare-common-lisp
       (format t "~%extern ECL_API cl_object cl_c~ar(cl_object);" string))
      (:common-lisp-inline
       (format t "~%(def-inline c~ar :always (t) t \"ecl_c~ar(#0)\")" string string)
       (format t "~%(def-inline c~ar :unsafe (t) t \"_ecl_c~ar(#0)\")" string string)
       )
      )))

(defun gen-cons-h ()
  (format t "~%#if ECL_CAN_INLINE")
  (loop for depth from 1 below 5
        do (write-rec depth nil :inline))
  (format t "~%#else")
  (loop for depth from 1 below 5
        do (write-rec depth nil :declare-unsafe))
  (format t "~%#endif /* !ECL_CAN_INLINE */~%")
  (loop for depth from 1 below 5
        do (write-rec depth nil :declare-safe))
  (terpri)
  (gen-cons-legacy-h)
  (loop for depth from 1 below 5
        do (write-rec depth nil :declare-common-lisp))
  (terpri))

(defun gen-cons-d ()
  (format t "~%#if !ECL_CAN_INLINE")
  (loop for depth from 1 below 5
        do (write-rec depth nil :unsafe))
  (format t "~%#endif /* !ECL_CAN_INLINE */~%")
  (loop for depth from 1 below 5
        do (write-rec depth nil :safe))
  (terpri)
  (loop for depth from 1 below 5
        do (write-rec depth nil :common-lisp))
  (terpri))

(defun gen-cons-legacy-h ()
  (loop for depth from 1 below 5
        do (write-rec depth nil :unsafe-macro))
  (terpri))

(defun gen-cons-sysfun ()
  (loop for depth from 1 below 5
        do (write-rec depth nil :common-lisp-inline))
  (terpri))

(process-file "src/c/cons.d")
(process-file "src/h/cons.h")
;(process-file "src/h/legacy.h")
(process-file "src/cmp/sysfun.lsp")
(terpri)
#+ecl
(ext:quit)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/util/gen-code.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/util/system.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;
;;; **********************************************************************
;;; (c) Copyright G. Attardi, 1993.  All rights reserved.
;;; **********************************************************************
;;;
;;; A simple minded System Builder Tool.
;;;

;;; ----------------------------------------------------------------------
;;; Use:
;;;
;;; (defsystem name
;;;
;;;   :modules
;;;   -----------------------------------------------------------------
;;;    file     |   load           |   compile       | files which force
;;;             | environment      | environment     | recompilations of
;;;   -----------------------------------------------------------------
;;;   `(,@patches
;;;   (pkg          ,(car patches)  ,(car patches)         ())
;;;   (macros       (pkg macros)    (pkg macros)           ())
;;;   (low          (pkg walk)      (pkg macros)           (macros))
;;;   (,xxx-low     (low)           (macros low)           (low))
;;;   (boot         (,xxx)          (macros low ,xxx)      (low ,xxx))
;;;   (last         t               t                      (boot)))
;;;
;;;   :source-directory '("./")
;;;   :source-extension "./"
;;;   :fasl-directory "/usr/src/o/"
;;;   :fasl-extension "o"
;;;   :library-directory "./")
;;;
;;; ----------------------------------------------------------------------

(defpackage "SBT"
  (:use "CL")
  (:export defsystem
           build-system
           compile-system
           load-system
           build-ecl))

(in-package "SBT")

(defmacro defsystem (name &key modules
                     (source-directory '("./"))
                     (source-extension "lsp")
                     (fasl-directory "./")
                     (fasl-extension "o")
                     (library-directory "./"))
  `(defparameter ,name                  ; rather then defvar
     (make-system :NAME ',name
                  :MODULES ,modules
                  :SOURCE-DIRECTORY ,(if (consp source-directory) source-directory (list 'quote (list source-directory)))
                  :SOURCE-EXTENSION ,source-extension
                  :FASL-DIRECTORY ,fasl-directory
                  :FASL-EXTENSION ,fasl-extension
                  :LIBRARY-DIRECTORY ,library-directory)))

;;; ----------------------------------------------------------------------

(defstruct (system (:TYPE vector) :NAMED)
  name
  modules
  (source-directory '("./"))
  (source-extension "lsp")
  (fasl-directory "./")
  (fasl-extension "o")
  (library-directory "./"))

(defun make-source-pathname (name system)
  (let ((name (string-downcase name))
        (extension (system-source-extension system)))
    (dolist (i (system-source-directory system))
      (let ((pathname (make-pathname :name name :type extension
                                     :defaults i)))
        (let ((ok (probe-file pathname)))
          (when ok (return-from make-source-pathname ok)))))
    (error "sbt::make-source-pathname: source file not found")))

(defun make-binary-pathname (name system)
  (make-pathname :name (string-downcase name)
                 :type (system-fasl-extension system)
                 :defaults (system-fasl-directory system)))

(defun make-library-pathname (system target)
  (let* ((name (string-downcase (system-name system)))
         (directory (system-library-directory system))
         (output-name (merge-pathnames name directory)))
    (compile-file-pathname output-name :type target)))

;;; ----------------------------------------------------------------------
;;; Operations on modules
;;; 

(defstruct (module (:TYPE vector) :NAMED
                   (:CONSTRUCTOR make-module (name))
;                   (:PRINT-FUNCTION
;                     (lambda (m s d)
;                       (declare (ignore d))
;                       (format s "#<Module ~A>" (module-name m))))
                   )
  name
  load-env
  comp-env
  recomp-reasons)

(defun make-modules (system-description)
  (let ((modules ()))
    (labels ((get-module (name)
               (or (find name modules :KEY #'module-name)
                   (progn (setq modules (cons (make-module name) modules))
                          (first modules))))
             (parse-spec (spec)
               (if (eq spec 't)
                   (reverse (cdr modules))
                   (mapcar #'get-module spec))))
      (dolist (file system-description)
        (let* ((name (first file))
               (module (get-module name)))
          (setf (module-load-env module) (parse-spec (second file))
                (module-comp-env module) (parse-spec (third file))
                (module-recomp-reasons module) (parse-spec (fourth file))))))
    (reverse modules)))

(defun make-transformations (system filter make-transform)
  (let ((transforms (list nil)))
    (dolist (m (make-modules (system-modules system)))
      (when (funcall filter system m transforms)
        (funcall make-transform m transforms)))
    (nreverse (cdr transforms))))

(defun make-compile-transformation (module transforms)
  (unless (dolist (trans transforms)
            (and (eq (first trans) :COMPILE)
                 (eq (second trans) module)
                 (return trans)))    
    (dolist (c (module-comp-env module))
      (make-load-transformation c transforms))
    (push `(:COMPILE ,module) (cdr transforms))))

(defun make-load-transformation (module transforms)
  (unless (dolist (trans transforms)
            (when (eq (second trans) module)
              (case (first trans)
                (:COMPILE (return nil))
                (:LOAD    (return trans)))))
    (dolist (l (module-load-env module))
      (make-load-transformation l transforms))
    (push `(:LOAD ,module) (cdr transforms))))


(defun make-load-without-dependencies-transformation (module transforms)
  (unless (dolist (trans transforms)
            (and (eq (first trans) :LOAD)
                 (eq (second trans) module)
                 (return trans)))
    (push `(:LOAD ,module) (cdr transforms))))

(defun compile-filter (system module transforms)
  (or (dolist (r (module-recomp-reasons module))
        (when (dolist (transform transforms)
                (when (and (eq (first transform) :COMPILE)
                           (eq (second transform) r))
                  (return t)))
          (return t)))
      (null (probe-file (make-binary-pathname (module-name module) system)))
      (> (file-write-date (make-source-pathname (module-name module) system))
         (file-write-date (make-binary-pathname (module-name module) system)))))

(defun sbt-compile-file (&rest a)
  (apply #'compiler::compile-file a))

(defun operate-on-system (system mode &optional arg print-only
                          &aux (si::*init-function-prefix*
                                (string-upcase (system-name system))))
  (let (transformations)
    (flet ((load-module (m s)
             (let ((name (module-name m)))
               #-dlopen
               (if print-only
                 (format t "~&Loading source of ~A..." name)
                 (load (make-source-pathname name s)))
               #+dlopen
               (if (or (eq mode :source)
                       (dolist (trans transformations)
                               (and (eq (first trans) :compile)
                                    (eq (second trans) m)
                                    ; Is this ok?
                                    (return nil))))
                   (if print-only
                     (format t "~&Loading source of ~A..." name)
                     (load (make-source-pathname name s)))
                   (if print-only
                     (format t "~&Loading binary of ~A..." name)
                     (load (make-binary-pathname name s))))))

           (compile-module (m s)
             (format t "~&Compiling ~A..." (module-name m))
             (unless print-only
               (let  ((name (module-name m)))
                 (sbt-compile-file (make-source-pathname name s)
                   :OUTPUT-FILE (make-binary-pathname name s)))))

           (true (&rest ignore) (declare (ignore ignore)) 't))

      (setq transformations
        (ecase mode
          ((:STATIC-LIBRARY :LIBRARY :SHARED-LIBRARY :FASL)
            (let* ((transforms (make-transformations system
                                                     #'true
                                                     #'make-load-transformation))
                   (objects (mapcar #'(lambda (x) (make-binary-pathname (module-name (cadr x)) system))
                                    (remove-if-not #'(lambda (x) (eq (car x) :LOAD))
                                                   transforms)))
                   (library (make-library-pathname system mode)))
              (operate-on-system system :COMPILE)
              (c::builder mode library :lisp-files objects))
            nil)
          (:COMPILE
            (make-transformations system
                                  #'compile-filter
                                  #'make-compile-transformation))
          (:RECOMPILE
            (make-transformations system
                                  #'true
                                  #'make-compile-transformation))
          (:QUERY-COMPILE
            (make-transformations system
                                  #'(lambda (s m transforms)
                                      (or (compile-filter s m transforms)
                                          (y-or-n-p "Compile ~A?"
                                                    (module-name m))))
                                  #'make-compile-transformation))
          (:COMPILE-FROM
            (make-transformations system
                                  #'(lambda (s m transforms)
                                      (or (member (module-name m) arg)
                                          (compile-filter s m transforms)))
                                  #'make-compile-transformation))
          ((:LOAD :SOURCE)
            (make-transformations system
                                  #'true
                                  #'make-load-transformation))
          (:QUERY-LOAD
            (make-transformations system
              #'(lambda (s m transforms)
                  (declare (ignore s transforms))
                  (y-or-n-p "Load ~A?" (module-name m)))
              #'make-load-without-dependencies-transformation))))
      
      (dolist (transform transformations)
        (ecase (first transform)
          (:COMPILE (compile-module (second transform) system))
          (:LOAD (load-module (second transform) system)))))))


(defun compile-system (system &optional m)
  (cond ((null m)      (operate-on-system system :COMPILE))
        ((eq m 't)     (operate-on-system system :RECOMPILE))
        ((eq m :PRINT) (operate-on-system system :COMPILE () t))
        ((eq m :QUERY) (operate-on-system system :QUERY-COMPILE))
        ((symbolp m)   (operate-on-system system :COMPILE-FROM (list m)))
        ((listp m)     (operate-on-system system :COMPILE-FROM m))))

(defun load-system (system &optional mode)
  (case mode
    ((NIL) (operate-on-system system :LOAD))
    (:SOURCE (operate-on-system system :SOURCE))
    (:QUERY-LOAD (operate-on-system system :QUERY-LOAD))))


;;;----------------------------------------------------------------------
;;; User interface

(defmacro build-system (system &optional op mode)
  (case op
        (:LOAD
         `(load-system ,system ,(case mode
                                      (:QUERY :QUERY-LOAD)
                                      (:SOURCE :SOURCE))))
        (:COMPILE
         `(compile-system ,system ,(case mode
                                         (:QUERY :QUERY-COMPILE)
                                         (:FORCE :RECOMPILE))))
        (:PRINT
         `(compile-system ,system :PRINT))
        (otherwise
         `(load-system ,system))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/util/system.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/packlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                    package routines

(in-package "SYSTEM")

(defun find-all-symbols (string-or-symbol)
  "Args: (string-designator)
Returns a list of all symbols that have the specified print name.
STRING-DESIGNATOR may be a symbol, in which case the print name of the symbol
is used."
  (let ((symbol-name (string string-or-symbol)))
    (mapcan #'(lambda (p)
                (multiple-value-bind (s i)
                    (find-symbol symbol-name p)
                  (if (or (eq i :internal) (eq i :external))
                      (list s)
                      nil)))
            (list-all-packages))))

(defun packages-iterator (packages options maybe-list)
  (let ((all-symbols nil))
    (when (or (atom packages) (not maybe-list))
      (setq packages (list packages)))
    (dolist (p packages)
      (let ((package (si::coerce-to-package p)))
        (multiple-value-bind (hash-ext hash-int packages-used)
            (si::package-hash-tables package)
          (when (member :external options)
            (push (list package :external hash-ext) all-symbols))
          (when (member :internal options)
            (push (list package :internal hash-int) all-symbols))
          (when (member :inherited options)
            (dolist (p packages-used)
              (push (list package :inherited (si::package-hash-tables p))
                    all-symbols))))))
    (unless all-symbols
      (return-from packages-iterator #'(lambda () (values nil nil nil nil))))
    (let* ((current (pop all-symbols))
           (package (first current))
           (type (second current))
           (iterator (si::hash-table-iterator (third current))))
      (flet ((iterate ()
               (tagbody
                AGAIN
                 (multiple-value-bind (found key value)
                     (funcall iterator)
                   (declare (ignore key))
                   (cond 
                     (found
                      (when (eq type :inherited)
                        (multiple-value-bind (s access)
                            (find-symbol (symbol-name value) package)
                          (unless (and (eq s value) (eq access type))
                            (go AGAIN))))
                      (return-from iterate (values t value type package)))
                     ((null all-symbols)
                      (return-from iterate (values nil nil nil nil)))
                     (t
                      (setq current (pop all-symbols))
                      (setq package (first current)
                            type (second current)
                            iterator (si::hash-table-iterator (third current))
                            ))))
                  (go AGAIN))))
        #'iterate))))

(defmacro with-package-iterator ((iterator package-list &rest conditions)
                                 &rest body)
  (if conditions
      (let ((aux (set-difference conditions '(:external :internal :inherited))))
        (when aux
          (signal-simple-error 'program-error nil "Clauses ~{~S~} are not allowed."
                               (list aux))))
      (signal-simple-error 'program-error
                           nil
                           "Must supply at least one of :inherited, :external or :internal"
                           nil))
  `(let ((,iterator (packages-iterator ,package-list ',conditions t)))
    (macrolet ((,iterator () (list 'funcall ',iterator)))
      ,@body)))

(defun expand-do-symbols (var package result-form body options)
  (declare (si::c-local))
  (let* ((i (gensym))
         (found (gensym))
         declaration doc)
    (multiple-value-setq (declaration body doc)
      (find-declarations body nil))
    `(do* ((,i (packages-iterator ,package ',options t))
           ,found ,var)
          (nil)
        ,@declaration
        (multiple-value-setq (,found ,var) (funcall ,i))
        (unless ,found (return ,result-form))
        ,@body)))

(defmacro do-symbols ((var &optional (package '*package*) (result-form nil))
                      &rest body)
  "Syntax: (do-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Executes STATEMENTs once for each symbol in PACKAGE (which defaults to the
current package), with VAR bound to the symbol.  Then evaluates RESULT (which
defaults to NIL) and returns all values."
  (expand-do-symbols var package result-form body '(:inherited :internal :external)))

(defmacro do-external-symbols
          ((var &optional (package '*package*) (result-form nil)) &rest body)
  "Syntax: (do-external-symbols (var [package [result]])
          {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each external symbol
in PACKAGE (which defaults to the current package), with VAR bound to the
variable.  Then evaluates RESULT (which defaults to NIL) and returns all
values."
  (expand-do-symbols var package result-form body '(:external)))

(defmacro do-all-symbols ((var &optional (result-form nil)) &rest body)
  "Syntax: (do-all-symbols (var [result]) {decl}* {tag | statement}*)
Establishes a NIL block and executes STATEMENTs once for each symbol in each
package, with VAR bound to the symbol.  Then evaluates RESULT (which defaults
to NIL) and returns all values."
  (expand-do-symbols var '(list-all-packages) result-form body '(:internal :external)))

(defun print-symbol-apropos (symbol)
  (prin1 symbol)
  (when (fboundp symbol)
        (if (special-operator-p symbol)
            (princ "  Special form")
            (if (macro-function symbol)
                (princ "  Macro")
                (princ "  Function"))))
  (when (boundp symbol)
        (if (constantp symbol)
            (princ "  Constant: ")
            (princ "  has value: "))
        (prin1 (symbol-value symbol)))
  (terpri))


(defun apropos (string &optional package)
  "Args: (string &optional (package nil))
Prints those symbols whose print-names contain STRING as substring.  If
PACKAGE is non-NIL, then only the specified PACKAGE is searched."
  (setq string (string string))
  (mapc #'print-symbol-apropos (apropos-list string package))
  (values))

(defun apropos-list (string &optional package)
  "Args: (string &optional (package nil))
Returns a list of all symbols whose print-names contain STRING as substring.
If PACKAGE is non-NIL, then only the specified PACKAGE is searched."
  (sort (delete-duplicates (apropos-list-inner string package))
        #'(lambda (s1 s2)
            (string-lessp (prin1-to-string s1)
                          (prin1-to-string s2)))))

(defun apropos-list-inner (string package)
  (declare (si::c-local))
  (let* ((list '())
         (string (string string)))
    (cond (package
           (dolist (p (package-use-list package))
             (setf list (nconc (apropos-list-inner string p) list)))
           (do-symbols (symbol package)
             (when (search string (string symbol) :test #'char-equal)
               (setq list (cons symbol list)))))
          (t
           (do-all-symbols (symbol)
             (when (search string (string symbol) :test #'char-equal)
               (setq list (cons symbol list))))))
    list))


;; Package local nicknames
(defun add-package-local-nickname (local-nickname nicknamed-package
                                   &optional (package *package*))
  (si:%add-package-local-nickname local-nickname nicknamed-package package))

(defun remove-package-local-nickname (old-nickname
                                      &optional (package *package*))
  (si:%remove-package-local-nickname old-nickname package))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/packlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/cdr-5.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2011 Juan Jose Garcia-Ripoll
;;;;
;;;;  See file 'LICENSE' for the copyright details.
;;;;

;;;; CDR 5: Sub-interval Numerical Types for Common Lisp
;;;;
;;;;   https://common-lisp.net/project/cdr/document/5/index.html

(pushnew :cdr-5 *features*)

(in-package "EXT")

;;;
;;; List of symbols for symbols_list.h
;;;
#+(or)
(progn
  (loop with *print-case* = :downcase
     for i in '(fixnum integer rational ratio
                   real float short-float single-float
                   double-float long-float)
     do (loop for j in '("negative-~a-p" "non-negative-~a-p"
                         "non-positive-~a-p" "positive-~a-p")
           do (format t "ext:~? " j (list i)))
     do (terpri))
  (loop for i in '(fixnum integer rational ratio
                   real float short-float single-float
                   double-float long-float)
     for name = (substitute #\_ #\- (string-downcase i))
     do (loop for j in '("NEGATIVE-~A" "NON-NEGATIVE-~A" "NON-POSITIVE-~A" "POSITIVE-~A")
           do (format t
                      "~%{EXT_ \"~?\", EXT_ORDINARY, NULL, -1, OBJNULL},"
                      j (list i)))
     do (loop for j in
             '("~%{EXT_ \"NEGATIVE-~A-P\", EXT_ORDINARY, ECL_NAME(si_negative_~A_p), 1, OBJNULL},"
               "~%{EXT_ \"POSITIVE-~A-P\", EXT_ORDINARY, ECL_NAME(si_positive_~A_p), 1, OBJNULL},"
               "~%{EXT_ \"NON-NEGATIVE-~A-P\", EXT_ORDINARY, ECL_NAME(si_non_negative_~A_p), 1, OBJNULL},"
               "~%{EXT_ \"NON-POSITIVE-~A-P\", EXT_ORDINARY, ECL_NAME(si_non_positive_~A_p), 1, OBJNULL},")
           do (format t j i name))
     do (terpri))
  (loop for i in '(fixnum integer rational ratio
                real float short-float single-float
                double-float long-float)
     for name = (substitute #\_ #\- (string-downcase i))
     do (loop for j in '("negative" "non_negative" "non_positive" "positive")
           do (format t "~%extern ECL_API cl_object si_~a_~a_p(cl_object);" j name))
     do (terpri))
  (loop with *print-case* = :downcase
     for i in '(fixnum integer rational ratio
                   real float short-float single-float
                   double-float long-float)
     do (loop for j in '("NEGATIVE-~A-P" "NON-NEGATIVE-~A-P"
                         "NON-POSITIVE-~A-P" "POSITIVE-~A-P")
             for name = (format nil j (symbol-name i))
             for s = (intern name (find-package "EXT"))
             do (print `(proclamation ,s (t) gen-bool :pure)))
     do (terpri)))

;;;
;;; Small integers
;;;

(deftype negative-fixnum ()
  `(integer ,most-negative-fixnum -1))

(deftype non-positive-fixnum ()
  `(integer ,most-negative-fixnum 0))

(deftype non-negative-fixnum ()
  `(integer 0 , most-positive-fixnum))

(deftype positive-fixnum ()
  `(integer 1 ,most-positive-fixnum))

(defun negative-fixnum-p (p)
  (and (si::fixnump p) (minusp (truly-the fixnum p))))

(defun positive-fixnum-p (p)
  (and (si::fixnump p) (plusp (truly-the fixnum p))))

(defun non-negative-fixnum-p (p)
  (and (si::fixnump p) (not (minusp (truly-the fixnum p)))))

(defun non-positive-fixnum-p (p)
  (and (si::fixnump p) (not (plusp (truly-the fixnum p)))))

(defun array-index-p (p)
  (and (si::fixnump p)
       (<= 0 (truly-the fixnum p) array-dimension-limit)))

;;;
;;; Integers
;;;

(deftype negative-integer ()
  '(integer * -1))

(deftype non-positive-integer ()
  '(integer * 0))

(deftype non-negative-integer ()
  '(integer 0 *))

(deftype positive-integer ()
  '(integer 1 *))

(defun negative-integer-p (p)
  (and (integerp p) (minusp (truly-the integer p))))

(defun positive-integer-p (p)
  (and (integerp p) (plusp (truly-the integer p))))

(defun non-negative-integer-p (p)
  (and (integerp p) (not (minusp (truly-the integer p)))))

(defun non-positive-integer-p (p)
  (and (integerp p) (not (plusp (truly-the integer p)))))

;;;
;;; Rationals
;;;

(deftype negative-rational ()
  '(rational * (0)))

(deftype non-positive-rational ()
  '(rational * 0))

(deftype non-negative-rational ()
  '(rational 0 *))

(deftype positive-rational ()
  '(rational (0) *))

(defun negative-rational-p (p)
  (and (rationalp p) (minusp (truly-the rational p))))

(defun positive-rational-p (p)
  (and (rationalp p) (plusp (truly-the rational p))))

(defun non-negative-rational-p (p)
  (and (rationalp p) (not (minusp (truly-the rational p)))))

(defun non-positive-rational-p (p)
  (and (rationalp p) (not (plusp (truly-the rational p)))))

;;;
;;; Ratios
;;;

(defun ratiop (x)
  (eq (type-of x) 'RATIO))

(defun positive-ratio-p (x)
  (and (ratiop x) (plusp x)))

(defun negative-ratio-p (x)
  (and (ratiop x) (minusp x)))

(deftype negative-ratio ()
  '(satisfies negative-ratio-p))

(deftype non-positive-ratio ()
  'negative-ratio)

(deftype non-negative-ratio ()
  'positive-ratio)

(deftype positive-ratio ()
  '(satisfies positive-ratio-p))

(defun non-negative-ratio-p (p)
  (positive-ratio-p p))

(defun non-positive-ratio-p (p)
  (negative-ratio-p p))

;;;
;;; Reals
;;;

(deftype negative-real ()
  '(real * (0)))

(deftype non-positive-real ()
  '(real * 0))

(deftype non-negative-real ()
  '(real 0 *))

(deftype positive-real ()
  '(real (0) *))

(defun negative-real-p (p)
  (and (realp p) (minusp (truly-the real p))))

(defun positive-real-p (p)
  (and (realp p) (plusp (truly-the real p))))

(defun non-negative-real-p (p)
  (and (realp p) (not (minusp (truly-the real p)))))

(defun non-positive-real-p (p)
  (and (realp p) (not (plusp (truly-the real p)))))

;;;
;;; Floats
;;;

(deftype negative-float ()
  '(float * (0)))

(deftype non-positive-float ()
  '(float * 0))

(deftype non-negative-float ()
  '(float 0 *))

(deftype positive-float ()
  '(float (0) *))

(defun negative-float-p (p)
  (and (floatp p) (minusp (truly-the float p))))

(defun positive-float-p (p)
  (and (floatp p) (plusp (truly-the float p))))

(defun non-negative-float-p (p)
  (and (floatp p) (not (minusp (truly-the float p)))))

(defun non-positive-float-p (p)
  (and (floatp p) (not (plusp (truly-the float p)))))

;;;
;;; SHORT-FLOAT
;;;

(deftype negative-short-float ()
  '(short-float * (0S0)))

(deftype non-positive-short-float ()
  '(short-float * 0S0))

(deftype non-negative-short-float ()
  '(short-float 0S0 *))

(deftype positive-short-float ()
  '(short-float (0S0) *))

(defun negative-short-float-p (p)
  (and (short-floatp p) (minusp (truly-the short-float p))))

(defun positive-short-float-p (p)
  (and (short-floatp p) (plusp (truly-the short-float p))))

(defun non-negative-short-float-p (p)
  (and (short-floatp p) (not (minusp (truly-the short-float p)))))

(defun non-positive-short-float-p (p)
  (and (short-floatp p) (not (plusp (truly-the short-float p)))))

;;;
;;; SINGLE-FLOAT
;;;

(deftype negative-single-float ()
  '(single-float * (0F0)))

(deftype non-positive-single-float ()
  '(single-float * 0F0))

(deftype non-negative-single-float ()
  '(single-float 0F0 *))

(deftype positive-single-float ()
  '(single-float (0F0) *))

(defun negative-single-float-p (p)
  (and (single-floatp p) (minusp (truly-the single-float p))))

(defun positive-single-float-p (p)
  (and (single-floatp p) (plusp (truly-the single-float p))))

(defun non-negative-single-float-p (p)
  (and (single-floatp p) (not (minusp (truly-the single-float p)))))

(defun non-positive-single-float-p (p)
  (and (single-floatp p) (not (plusp (truly-the single-float p)))))

;;;
;;; DOUBLE-FLOAT
;;;

(deftype negative-double-float ()
  '(double-float * (0D0)))

(deftype non-positive-double-float ()
  '(double-float * 0D0))

(deftype non-negative-double-float ()
  '(double-float 0D0 *))

(deftype positive-double-float ()
  '(double-float (0D0) *))

(defun negative-double-float-p (p)
  (and (double-floatp p) (minusp (truly-the double-float p))))

(defun positive-double-float-p (p)
  (and (double-floatp p) (plusp (truly-the double-float p))))

(defun non-negative-double-float-p (p)
  (and (double-floatp p) (not (minusp (truly-the double-float p)))))

(defun non-positive-double-float-p (p)
  (and (double-floatp p) (not (plusp (truly-the double-float p)))))

;;;
;;; LONG-FLOAT
;;;

(deftype negative-long-float ()
  '(long-float * (0L0)))

(deftype non-positive-long-float ()
  '(long-float * 0L0))

(deftype non-negative-long-float ()
  '(long-float 0L0 *))

(deftype positive-long-float ()
  '(long-float (0L0) *))

(defun negative-long-float-p (p)
  (and (long-floatp p) (minusp (truly-the long-float p))))

(defun positive-long-float-p (p)
  (and (long-floatp p) (plusp (truly-the long-float p))))

(defun non-negative-long-float-p (p)
  (and (long-floatp p) (not (minusp (truly-the long-float p)))))

(defun non-positive-long-float-p (p)
  (and (long-floatp p) (not (plusp (truly-the long-float p)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/cdr-5.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/defmacro.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;         defines SYS:DEFMACRO*, the defmacro preprocessor

(in-package "SYSTEM")

#+ecl-min
(si::fset 'push
          #'(ext::lambda-block push (args env)
              (let* ((what (second args))
                     (where (caddr args)))
                `(setq ,where (cons ,what ,where))))
          t)

#+ecl-min
(si::fset 'pop
          #'(ext::lambda-block pop (args env)
              (let ((where (cadr args)))
                `(let* ((l ,where)
                        (v (car l)))
                  (setq ,where (cdr l))
                  v)))
          t)

#+ecl-min
(si::fset 'incf
          #'(ext::lambda-block incf (args env)
              (let* ((where (second args))
                     (what (caddr args)))
                (if what
                  `(setq ,where (+ ,where ,what))
                  `(setq ,where (1+ ,where)))))
          t)

#+ecl-min
(si::fset 'decf
          #'(ext::lambda-block decf (args env)
              (let* ((where (second args))
                     (what (caddr args)))
                (if what
                  `(setq ,where (- ,where ,what))
                  `(setq ,where (1- ,where)))))
          t)

(defun sys::search-keyword (list key)
  (cond ((atom list) 'missing-keyword)
        ((atom (cdr list)) 'missing-keyword)
        ((eq (car list) key) (cadr list))
        (t (search-keyword (cddr list) key))))

(defun check-keyword (tail keywords &optional (allow-other-keys nil aok-flag))
  (do (head
       arg
       (err nil))
      ((null tail)
       (when (and err (not allow-other-keys))
         (error "The key ~s is not allowed" err)))
    (if (atom tail)
      (error "keyword list is not a proper list")
      (setq head (car tail) tail (cdr tail)))
    (if (atom tail)
      (error "keyword list is not a proper list")
      (setq arg (car tail) tail (cdr tail)))
    (cond ((eq head :allow-other-keys)
           (when (not aok-flag)
             (setq allow-other-keys arg aok-flag t)))
          ((not (member head keywords))
           (setq err head)))))

(defun dm-too-many-arguments (*current-form*)
  (error "Too many arguments supplied to a macro or a destructuring-bind form:~%~s"
         *current-form*))

(defun dm-too-few-arguments (form-or-nil)
  (if form-or-nil
      (let ((*current-form* form-or-nil))
        (error "Too few arguments supplied to a macro or a destructuring-bind form:~%~S"
               *current-form*))
      (error "Too few arguments supplied to a inlined lambda form.")))

(defun sys::destructure (vl context &aux
                                      (basis-form (gensym))
                                      (destructure-symbols (list basis-form)))
  (declare (special *dl* *arg-check*))
  (labels ((tempsym ()
             (let ((x (gensym)))
               (push x destructure-symbols)
               x))
           (dm-vl (vl whole context)
             (multiple-value-bind (reqs opts rest key-flag keys allow-other-keys auxs)
                 (si::process-lambda-list
                  vl (case context
                       ((defmacro define-compiler-macro)
                        'macro)
                       (otherwise 'destructuring-bind)))
               (let* ((pointer (tempsym))
                      (cons-pointer `(truly-the cons ,pointer))
                      (unsafe-car `(car ,cons-pointer))
                      (unsafe-cdr `(cdr ,cons-pointer))
                      (unsafe-pop `(setq ,pointer ,unsafe-cdr))
                      (no-check nil)
                      (ppn (+ (length reqs) (first opts)))
                      all-keywords)
                 ;; In macros, eliminate the name of the macro from the list
                 (dm-v pointer (case context
                                 (define-compiler-macro
                                  `(if (and (eq (car ,whole) 'cl:funcall)
                                            (eq (caadr ,whole) 'cl:function))
                                       (cddr (truly-the cons ,whole))
                                       (cdr (truly-the cons ,whole))))
                                 (defmacro
                                     `(cdr (truly-the cons ,whole)))
                                 (otherwise whole)))
                 (dolist (v (cdr reqs))
                   (dm-v v `(progn
                              (if (null ,pointer)
                                  (dm-too-few-arguments ,basis-form))
                              (prog1 ,unsafe-car ,unsafe-pop))))
                 (dotimes (i (pop opts))
                   (let* ((x (first opts))
                          (init (second opts))
                          (sv (third opts)))
                     (setq opts (cdddr opts))
                     (cond (sv
                            (dm-v x `(if ,pointer ,unsafe-car ,init))
                            (dm-v sv `(and ,pointer (progn ,unsafe-pop t))))
                           (t
                            (dm-v x `(if ,pointer
                                         (prog1 ,unsafe-car ,unsafe-pop)
                                         ,init))))))
                 (when rest
                   (dm-v rest pointer)
                   (setq no-check t))
                 (dotimes (i (pop keys))
                   (let* ((temp (tempsym))
                          (k (first keys))
                          (v (second keys))
                          (init (third keys))
                          (sv (fourth keys)))
                     (setq no-check t)
                     (setq keys (cddddr keys))
                     (dm-v temp `(search-keyword ,pointer ',k))
                     (dm-v v `(if (eq ,temp 'missing-keyword) ,init ,temp))
                     (when sv (dm-v sv `(not (eq ,temp 'missing-keyword))))
                     (push k all-keywords)))
                 (do ((l auxs (cddr l))) ((endp l))
                   (let* ((v (first l))
                          (init (second l)))
                     (dm-v v init)))
                 (cond (key-flag
                        (push `(check-keyword ,pointer ',all-keywords
                                ,@(if allow-other-keys '(t) '()))
                              *arg-check*))
                       ((not no-check)
                        (push `(if ,pointer (dm-too-many-arguments ,basis-form))
                              *arg-check*)))
                  ppn)))

           (dm-v (v init)
             (cond ((and v (symbolp v))
                    (let ((push-val (if init (list v init) v)))
                      (push push-val *dl*)))
                   ((and v (atom v))
                    (error "destructure: ~A is not a list nor a symbol" v))
                   ((eq (first v) '&whole)
                    (let ((whole-var (second v)))
                      (if (listp whole-var)
                          (let ((new-whole (tempsym)))
                            (dm-v new-whole init)
                            (dm-vl whole-var new-whole nil)
                            (setq whole-var new-whole))
                          (dm-v whole-var init))
                      (dm-vl (cddr v) whole-var nil)))
                   (t
                    (let* ((temp (tempsym))
                           (push-val (if init (list temp init) temp)))
                      (push push-val *dl*)
                      (dm-vl v temp nil))))))

    (let* ((whole basis-form)
           (*dl* nil)
           (*arg-check* nil))
      (declare (special *dl* *arg-check*))
      (cond ((listp vl)
             (when (eq (first vl) '&whole)
               (let ((named-whole (second vl)))
                 (setq vl (cddr vl))
                 (if (listp named-whole)
                     (dm-vl named-whole whole nil)
                     (setq *dl* (list (list named-whole whole)))))))
            ((symbolp vl)
             (setq vl (list '&rest vl)))
            (t (error "The destructuring-lambda-list ~s is not a list." vl)))
      (values (dm-vl vl whole context) whole
              (nreverse *dl*)
              *arg-check*
              destructure-symbols))))

;;; valid lambda-list to DEFMACRO is:
;;;
;;;     ( [ &whole sym ]
;;;       [ &environment sym ]
;;;       { v }*
;;;       [ &optional { sym | ( v [ init [ v ] ] ) }* ]
;;;       {  [ { &rest | &body } v ]
;;;          [ &key { sym | ( { sym | ( key v ) } [ init [ v ]] ) }*
;;;                 [ &allow-other-keys ]]
;;;          [ &aux { sym | ( v [ init ] ) }* ]
;;;       |  . sym }
;;;      )
;;;
;;; where v is short for { defmacro-lambda-list | sym }.
;;; A symbol may be accepted as a DEFMACRO lambda-list, in which case
;;; (DEFMACRO <name> <symbol> ... ) is equivalent to
;;; (DEFMACRO <name> (&REST <symbol>) ...).
;;; Defmacro-lambda-list is defined as:
;;;
;;;     ( { v }*
;;;       [ &optional { sym | ( v [ init [ v ] ] ) }* ]
;;;       {  [ { &rest | &body } v ]
;;;          [ &key { sym | ( { sym | ( key v ) } [ init [ v ]] ) }*
;;;                 [ &allow-other-keys ]]
;;;          [ &aux { sym | ( v [ init ] ) }* ]
;;;       |  . sym }
;;;      )
(defun find-documentation (body)
  (nth-value 3 (process-declarations body t)))

(defun remove-documentation (body)
  (multiple-value-bind (decls body doc)
      (process-declarations body t)
    (when decls (push `(declare ,@decls) body))
    (values body doc)))

(defun find-declarations (body &optional (doc t))
  (multiple-value-bind (decls body doc)
      (process-declarations body doc)
    (values (if decls `((declare ,@decls)) nil)
            body doc)))

;; Optional argument context can be 'cl:define-compiler-macro or 'cl:defmacro (default)
(defun sys::expand-defmacro (name vl body &optional (context 'cl:defmacro))
  (multiple-value-bind (decls body doc)
      (find-declarations body)
    ;; We turn (a . b) into (a &rest b)
    ;; This is required because MEMBER (used below) does not like improper lists
    (let ((cell (last vl)))
      (when (rest cell)
        (setq vl (nconc (butlast vl 0) (list '&rest (rest cell))))))
    ;; If we find an &environment variable in the lambda list, we take not of the
    ;; name and remove it from the list so that DESTRUCTURE does not get confused
    (let ((env (member '&environment vl :test #'eq)))
      (if env
          (setq vl (nconc (ldiff vl env) (cddr env))
                env (second env))
          (setq env (gensym)
                decls (list* `(declare (ignore ,env)) decls)))
      (multiple-value-bind (ppn whole dl arg-check ignorables)
          (destructure vl context)
        (values `(ext::lambda-block ,name (,whole ,env &aux ,@dl)
                                    (declare (ignorable ,@ignorables))
                                    ,@decls 
                                    ,@arg-check
                                    ,@body)
                ppn
                doc)))))

#+ecl-min
(si::fset 'defmacro
          #'(ext::lambda-block defmacro (def env)
              (declare (ignore env))
              (let* ((name (second def))
                     (vl (third def))
                     (body (cdddr def))
                     (function))
                (multiple-value-bind (function pprint doc)
                    (sys::expand-defmacro name vl body)
                  (declare (ignore doc))
                  (setq function `(function ,function))
                  (when *dump-defmacro-definitions*
                    (print function)
                    (setq function `(si::bc-disassemble ,function)))
                  (ext:register-with-pde def `(si::fset ',name ,function t ,pprint)))))
          t)

;;; valid lambda-list to DESTRUCTURING-BIND is:
;;;
;;;     ( [ &whole sym ]
;;;       { v }*
;;;       [ &optional { sym | ( v [ init [ v ] ] ) }* ]
;;;       {  [ { &rest | &body } v ]
;;;          [ &key { sym | ( { sym | ( key v ) } [ init [ v ]] ) }*
;;;                 [ &allow-other-keys ]]
;;;          [ &aux { sym | ( v [ init ] ) }* ]
;;;       |  . sym }
;;;      )
;;;
;;; where v is short for { destructuring-bind-lambda-list | sym }.
;;; A symbol may be accepted as a DESTRUCTURING-BIND lambda-list, in which case
;;; (DESTRUCTURING-BIND <name> <symbol> ... ) is equivalent to
;;; (DESTRUCTURING-BIND <name> (&REST <symbol>) ...).
;;; Destructuring-bind-lambda-list is defined as:
;;;
;;;     ( [ &whole sym ]
;;;       { v }*
;;;       [ &optional { sym | ( v [ init [ v ] ] ) }* ]
;;;       {  [ { &rest | &body } v ]
;;;          [ &key { sym | ( { sym | ( key v ) } [ init [ v ]] ) }*
;;;                 [ &allow-other-keys ]]
;;;          [ &aux { sym | ( v [ init ] ) }* ]
;;;       |  . sym }
;;;      )

(defmacro destructuring-bind (vl list &body body)
  (multiple-value-bind (decls body)
      (find-declarations body)
    (multiple-value-bind (ppn whole dl arg-check ignorables)
        (destructure vl nil)
      (declare (ignore ppn))
      `(let* ((,whole ,list) ,@dl)
         (declare (ignorable ,@ignorables))
         ,@decls
         ,@arg-check
         ,@body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; MACROLET HELPER
;;;

(defun cmp-env-for-bytecodes (old-env)
  "Produce an environment which is safe to pass to the bytecodes
compiler. We remove all blocks and tags and ensure that
references to local variables will cause an error. This
environment can be used to bytecompile the functions in MACROLET
or SYMBOL-MACRO forms, and also to evaluate other forms."
  (declare (si::c-local))
  (flet ((local-var-error-function (name)
          #'(lambda (whole env)
              (declare (ignore whole env))
              (error
"In a MACROLET function you tried to access a local variable, ~A,
from the function in which it appears." name)))
         (local-fun-error-function (name)
          #'(lambda (whole env)
              (declare (ignore whole env))
              (error
"In a MACROLET function you tried to access a local function, ~A,
from the function in which it appears." name))))
    (cons (do ((env (car old-env) (cdr env))
               (variables '()))
              ((endp env) (nreverse variables))
            (let ((i (car env)))
              (if (consp i)
                (let ((name (first i)))
                  (if (not (keywordp name))
                      (push (if (second i)
                                i
                              (list name 'si::symbol-macro (local-var-error-function name)))
                            variables))))))
          (do ((env (cdr old-env) (cdr env))
               (macros '()))
              ((endp env) (nreverse macros))
            (let ((i (car env)))
              (if (consp i)
                (push (if (eq (second i) 'SI::MACRO)
                          i
                        (list (first i) 'SI:MACRO (local-fun-error-function (first i))))
                      macros)))))))

(defun macrolet-functions (definitions old-env)
  (declare (si::c-local))
  (let ((env (cmp-env-for-bytecodes old-env)))
    (si::eval-with-env
     (cons 'list
           (mapcar #'(lambda (x)
                       (let* ((name (first x))
                              (llist (second x))
                              (def (cddr x)))
                         `(list ',name ,(si::expand-defmacro name llist def))))
                   definitions))
     env nil t)))

(defun cmp-env-register-macrolet (definitions old-env)
  (let ((macros (cdr old-env)))
    (dolist (record (macrolet-functions definitions old-env))
      (push (list (first record) 'si::macro (second record))
            macros))
    (rplacd (truly-the cons old-env) macros)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/defmacro.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/defpackage.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;
;;;                              THE BOEING COMPANY
;;;                           BOEING COMPUTER SERVICES
;;;                            RESEARCH AND TECHNOLOGY
;;;                               COMPUTER SCIENCE
;;;                           P.O. BOX 24346, MS 7L-64
;;;                            SEATTLE, WA 98124-0346
;;;
;;;
;;; Copyright (c) 1990, 1991 The Boeing Company, All Rights Reserved.
;;;
;;; Permission is granted to any individual or institution to use,
;;; copy, modify, and distribute this software, provided that this
;;; complete copyright and permission notice is maintained, intact, in
;;; all copies and supporting documentation and that modifications are
;;; appropriately documented with date, author and description of the
;;; change.
;;;
;;; Stephen L. Nicoud (snicoud@boeing.com) provides this software "as
;;; is" without express or implied warranty by him or The Boeing
;;; Company.
;;;
;;; This software is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY.  No author or distributor accepts
;;; responsibility to anyone for the consequences of using it or for
;;; whether it serves any particular purpose or works at all.
;;;
;;;     Author: Stephen L. Nicoud
;;;
;;; -----------------------------------------------------------------
;;;
;;;     Adapted for X3J13 by Stephen L Nicoud, 91/5/23
;;;     Adapted for ECL by Giuseppe Attardi, 6/6/1994.
;;;     Partially rewritten by Daniel KochmaÅ„ski, 2017-05-01
;;; 
;;; -----------------------------------------------------------------

(in-package "SYSTEM")

(defmacro DEFPACKAGE (name &rest options)
  (declare (type (or symbol string character) name))
  "DEFPACKAGE - DEFINED-PACKAGE-NAME {OPTION}*                  [Macro]

   This creates a new package, or modifies an existing one, whose name is
   DEFINED-PACKAGE-NAME.  The DEFINED-PACKAGE-NAME may be a string or a 
   symbol; if it is a symbol, only its print name matters, and not what
   package, if any, the symbol happens to be in.  The newly created or 
   modified package is returned as the value of the DEFPACKAGE form.

   Each standard OPTION is a list of keyword (the name of the option)
   and associated arguments.  No part of a DEFPACKAGE form is
   evaluated.  Except for the :LOCK and :DOCUMENTATION options, more
   than one option of the same kind may occur within the same
   DEFPACKAGE form.

  Valid Options:
        (:documentation         string)
        (:lock                  boolean)
        (:nicknames             {package-name}*)
        (:shadow                {symbol-name}*)
        (:shadowing-import-from package-name {symbol-name}*)
        (:use                   {package-name}*)
        (:local-nicknames       (local-nickname actual-package-name)*)
        (:import-from           package-name {symbol-name}*)
        (:intern                {symbol-name}*)
        (:export                {symbol-name}*)
        (:export-from           {package-name}*)

  [Note: :EXPORT-FROM, :DOCUMENTATION, :LOCK and :LOCAL-NICKNAMES are
         extensions to DEFPACKAGE.

         If a symbol is interned in the package being created and if a
         symbol with the same print name appears as an external symbol
         of one of the packages in the :EXPORT-FROM option, then the
         symbol is exported from the package being created.]"

  (flet ((designators (values)
	   (mapcar #'string values)))
    (let ((nicknames nil)
	  (documentation nil)
	  (shadowed-symbol-names nil)
	  (interned-symbol-names nil)
	  (exported-symbol-names nil)
	  (shadowing-imported-from-symbol-names-list nil)
	  (imported-from-symbol-names-list nil)
	  (exported-from-package-names nil)
	  (use nil)
	  (use-p nil)
	  (lock nil)
	  (local-nicknames nil))
      (dolist (option options)
	(case (car option)
	  (:nicknames
	   (setf nicknames (append nicknames (designators (rest option)))))
	  (:documentation
	   (when documentation
	     (si:simple-program-error
	      "DEFPACKAGE option :DOCUMENTATION specified more than once."))
	   (setf documentation (second option)))
	  (:use
	   (setf use (append use (designators (rest option)))
		 use-p t))
	  (:shadow
	   (setf shadowed-symbol-names
		 (append shadowed-symbol-names (designators (rest option)))))
	  (:intern
	   (setf interned-symbol-names
		 (append interned-symbol-names (designators (rest option)))))
	  (:export
	   (setf exported-symbol-names
		 (append exported-symbol-names (designators (rest option)))))
	  (:shadowing-import-from
	   (destructuring-bind (package-name . names)
	       (designators (rest option))
	     (let ((assoc (assoc package-name shadowing-imported-from-symbol-names-list
				 :test #'string=)))
	       (if assoc
		   (setf (cdr assoc) (append (cdr assoc) names))
		   (setf shadowing-imported-from-symbol-names-list
			 (acons package-name names shadowing-imported-from-symbol-names-list))))))
	  (:import-from
	   (destructuring-bind (package-name . names)
	       (designators (rest option))
	     (let ((assoc (assoc package-name imported-from-symbol-names-list
				 :test #'string=)))
	       (if assoc
		   (setf (cdr assoc) (append (cdr assoc) names))
		   (setf imported-from-symbol-names-list
			 (acons package-name names imported-from-symbol-names-list))))))
	  ;; extensions
	  (:export-from
	   (setf exported-from-package-names
		 (append exported-from-package-names (designators (rest option)))))
	  (:size #+ (or) "we silently ignore `:size' option")
	  (:lock
	   (when lock
	     (si:simple-program-error
	      "DEFPACKAGE option :LOCK specified more than once.")
	     (setf lock (second option))))
	  (:local-nicknames
	   (setf local-nicknames
		 (append local-nicknames
			 (mapcar (lambda (spec)
				   (destructuring-bind (nick name) spec
				     (cons nick name)))
				 (rest option)))))
	  ;; unknown
	  (otherwise
	   (cerror "Proceed, ignoring this option."
		   "~s is not a valid DEFPACKAGE option." option))))
      (check-disjoint `(:intern ,@interned-symbol-names)
		      `(:export ,@exported-symbol-names))
      (check-disjoint `(:intern ,@interned-symbol-names)
		      `(:import-from
			,@(apply #'append (mapcar #'rest imported-from-symbol-names-list)))
		      `(:shadow ,@shadowed-symbol-names)
		      `(:shadowing-import-from
			,@(apply #'append (mapcar #'rest shadowing-imported-from-symbol-names-list))))
      `(eval-when (eval compile load)
	 (si::dodefpackage
	  ,(string name)
	  ',nicknames
	  ,documentation
	  ,(cadr (assoc ':lock options))
	  ',(if use-p use "CL")
	  ',local-nicknames
	  ',shadowed-symbol-names
	  ',interned-symbol-names
	  ',exported-symbol-names
	  ',shadowing-imported-from-symbol-names-list
	  ',imported-from-symbol-names-list
	  ',exported-from-package-names)))))

(defun check-disjoint (&rest args)
  (declare (si::c-local))
  ;; An arg is (:key . set)
  (do ((list args (cdr list)))
      ((endp list))
    (loop
      with x = (car list)
      for y in (rest list)
      for z = (remove-duplicates (intersection (cdr x)(cdr y) :test #'string=))
      when z do (error 'simple-program-error
                       :format-control "Parameters ~S and ~S must be disjoint ~
                                        but have common elements ~%   ~S"
                       :format-arguments (list (car x)(car y) z)))))

(defun dodefpackage
    (name
     nicknames
     documentation
     lock
     use
     local-nicknames
     shadowed-symbol-names
     interned-symbol-names
     exported-symbol-names
     shadowing-imported-from-symbol-names-list
     imported-from-symbol-names-list
     exported-from-package-names)
  (if (find-package name)
      (progn ; (rename-package name name)
        (when nicknames
          (rename-package name name nicknames))
        (when use
          (unuse-package (package-use-list (find-package name)) name)))
      (make-package name :use nil :nicknames nicknames :local-nicknames local-nicknames))
  (let ((*package* (find-package name)))
    (when documentation
      (setf (documentation *package* t) documentation))
    (shadow shadowed-symbol-names)
    (dolist (item shadowing-imported-from-symbol-names-list)
      (let ((package (find-package (first item))))
        (dolist (name (rest item))
          (shadowing-import (find-or-make-symbol name package)))))
    (use-package use)
    (dolist (item imported-from-symbol-names-list)
      (let ((package (find-package (first item))))
        (dolist (name (rest item))
          ;; IMPORT can accept a list as argument, hence if we want to
          ;; import symbol NIL, we have to enclose it in a list.
          (import (or (find-or-make-symbol name package) (list NIL))))))
    (mapc #'intern interned-symbol-names)
    (export (mapcar #'intern exported-symbol-names))
    (dolist (package exported-from-package-names)
      (do-external-symbols (symbol (find-package package))
        (when (nth 1 (multiple-value-list
                      (find-symbol (string symbol))))
          (export (list (intern (string symbol))))))))
  (when lock (lock-package name))
  (find-package name))

(defun find-or-make-symbol (name package)
  (declare (si::c-local))
  (multiple-value-bind (symbol found)
      (find-symbol name package)
    (unless found
      (signal-simple-error 'package-error "INTERN it."
                           "Cannot find symbol ~S in package ~S"
                           (list name package)
                           :package package)
      (setq symbol (intern name package)))
    symbol))

;;;; ------------------------------------------------------------
;;;;    End of File
;;;; ------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/defpackage.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/defstruct.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;        The structure routines.

(in-package "SYSTEM")

(defun si::structure-type-error (value slot-type struct-name slot-name)
  (error 'simple-type-error
         :format-control "Slot ~A in structure ~A only admits values of type ~A."
         :format-arguments (list slot-name struct-name slot-type)
         :datum value
         :expected-type slot-type))

(defun make-access-function (name conc-name type named slot-descr)
  (declare (ignore named)
           (si::c-local))
  (let* ((slot-name (nth 0 slot-descr))
         ;; (default-init (nth 1 slot-descr))
         ;; (slot-type (nth 2 slot-descr))
         (read-only (nth 3 slot-descr))
         (offset (nth 4 slot-descr))
         (access-function (if conc-name
                              (intern (base-string-concatenate conc-name slot-name))
                              slot-name)))
    (if (eql access-function (sixth slot-descr))
        (return-from make-access-function nil)
        (setf (sixth slot-descr) access-function))
    (cond ((null type)
           ;; If TYPE is NIL,
           ;;  the slot is at the offset in the structure-body.
           (fset access-function #'(lambda (x)
                                     (sys:structure-ref x name offset))))
          ((subtypep type '(OR LIST VECTOR))
           ;; If TYPE is VECTOR, (VECTOR ... ) or LIST, ELT is used.
           (fset access-function
                 #'(lambda (x) (elt x offset))))
          (t (error "~S is an illegal structure type." type)))
    (cond (read-only
           (fmakunbound `(setf ,access-function))
           (set-documentation access-function 'SETF nil))
          ;; The following is used by the compiler to expand inline
          ;; the accessor
          (t
           (do-setf-structure-method access-function (or type name)
                                     offset)))))


(defun do-setf-structure-method (access-function type index)
  (declare (si::c-local))
  (put-sysprop access-function 'STRUCTURE-ACCESS (cons type index))
  (do-defsetf access-function
    (cond ((or (eq type 'list) (eq type 'vector))
           #'(lambda (newvalue struct)
               `(sys::elt-set ,struct ,index ,newvalue)))
          ((consp type)
           #'(lambda (newvalue struct)
               `(si::aset (the ,type ,struct) ,index ,newvalue)))
          (t
           #'(lambda (newvalue struct)
               `(sys::structure-set ,struct ',type ,index ,newvalue))))))

(defun process-boa-lambda-list (slot-names slot-descriptions boa-list assertions)
  (declare (si::c-local))
  (let ((mentioned-slots '())
        (aux))
    ;; With a call to PROCESS-LAMBDA-LIST we ensure that the lambda list is
    ;; syntactically correct. This simplifies notably the code in the loop.
    (process-lambda-list (setq boa-list (copy-list boa-list)) 'FUNCTION)
    ;; Search for &optional or &key arguments without initialization.  Also,
    ;; record all slot names which are initialized by means of the BOA call.
    (do* ((i boa-list (rest i))
          (slot (first i) (first i))
          (modify nil))
         ((endp i))
      (cond ((or (eq slot '&optional) (eq slot '&key))
             (setq modify t))
            ((eq slot '&rest)
             (setq modify nil))
            ((eq slot '&aux)
             (setq aux t modify nil))
            ((eq slot '&allow-other-keys)
             )
            ((atom slot)
             (push slot mentioned-slots)
             (when modify
               (setf (first i)
                     (list slot (second (assoc slot slot-descriptions)))))
             (when aux
               (setf assertions (delete slot assertions :key 'cadadr))))
            (t
             (let ((slot-name (first slot)))
               (when (consp slot-name)
                 (setq slot-name (second slot-name)))
               (push slot-name mentioned-slots)
               (when (endp (rest slot))
                 (when modify
                   (setf (rest slot)
                         (list (second (assoc slot-name slot-descriptions)))))
                 (when aux
                   (setf assertions (delete slot assertions :key 'cadadr))))))))
    ;; For all slots not mentioned above, add the default values from
    ;; the DEFSTRUCT slot description.
    (let ((other-slots (nset-difference
                        (delete-if #'consp (copy-list slot-names))
                        mentioned-slots)))
      (do ((l other-slots (cdr l)))
          ((endp l))
        (let* ((slot (assoc (car l) slot-descriptions))
               (slot-init (second slot)))
          (when slot-init
            (setf (car l) (list (car l) slot-init)))))
      (when other-slots
        (unless aux
          (push '&aux other-slots))
        (setf boa-list (nconc boa-list other-slots)))
      (values boa-list assertions))))

(defun make-constructor (name constructor type named slot-descriptions)
  (declare (ignore named)
           (si::c-local))
  ;; CONSTRUCTOR := constructor-name | (constructor-name boa-lambda-list)
  (let* ((boa-constructor-p (consp constructor))
         (keys (unless boa-constructor-p (list '&key)))
         (constructor-name (if boa-constructor-p (first constructor) constructor))
         (slot-names '())
         (assertions '()))
    (dolist (slot slot-descriptions
             (setq slot-names (nreverse slot-names) keys (nreverse keys)))
      (push
       (cond ((null slot)
              ;; If slot-description is NIL, it is padding for initial-offset.
              nil)
             ((eql (first slot) 'TYPED-STRUCTURE-NAME)
              ;; This slot is the name of a typed structure with name.
              (list 'QUOTE (second slot)))
             (t
              (let* ((slot-name (first slot))
                     (slot-type (third slot))
                     (offset (fifth slot))
                     (init-form (second slot))
                     (var-name slot-name))
                ;; Unless BOA constructors are used, we should avoid using
                ;; slot names as lambda variables in the constructor.
                (unless boa-constructor-p
                  (setq var-name (copy-symbol slot-name))
                  (push (if init-form (list var-name init-form) var-name)
                        keys))
                ;; We insert type checks for every slot and only in the
                ;; case of BOA lists we remove some of these checks for
                ;; uninitialized slots.
                (unless (eq 'T slot-type)
                  (push `(unless (typep ,var-name ',slot-type)
                           (structure-type-error ,var-name ',slot-type ',name ',slot-name))
                        assertions))
                var-name)))
       slot-names))
    (when boa-constructor-p
      (setf (values keys assertions)
            (process-boa-lambda-list slot-names slot-descriptions
                                     (second constructor) assertions)))
    (cond ((null type)
           `(defun ,constructor-name ,keys
              ,@assertions
              #-CLOS
              (sys:make-structure ',name ,@slot-names)
              #+CLOS
              ;; the class is defined by an enclosing LET form
              (sys:make-structure .structure-constructor-class. ,@slot-names)))
          ((subtypep type '(VECTOR T))
           `(defun ,constructor-name ,keys
             (vector ,@slot-names)))
          ((subtypep type 'VECTOR)
           `(defun ,constructor-name ,keys
              (make-array ',(list (length slot-names))
                          :element-type ',(closest-sequence-type type)
                          :initial-contents (list ,@slot-names))))
          ((eq type 'LIST)
           `(defun ,constructor-name ,keys
              (list ,@slot-names)))
          ((error "~S is an illegal structure type" type)))))


(defun make-predicate (name type named name-offset)
  (declare (si::c-local))
  (cond ((null type)
         #'(lambda (x)
             (structure-subtype-p x name)))
        ((or (eq type 'VECTOR)
             (and (consp type) (eq (car type) 'VECTOR)))
         ;; The name is at the NAME-OFFSET in the vector.
         (unless named (error "The structure should be named."))
         #'(lambda (x)
             (and (vectorp x)
                  (> (length x) name-offset)
                  ;; AKCL has (aref (the (vector t) x).)
                  ;; which fails with strings
                  (eq (elt x name-offset) name))))
        ((eq type 'LIST)
         ;; The name is at the NAME-OFFSET in the list.
         (unless named (error "The structure should be named."))
         (if (= name-offset 0)
             #'(lambda (x)
                 (and (consp x) (eq (car x) name)))
             #'(lambda (x)
                 (do ((i name-offset (1- i))
                      (y x (cdr y)))
                     ((= i 0) (and (consp y) (eq (car y) name)))
                   (declare (fixnum i))
                   (unless (consp y) (return nil))))))
        ((error "~S is an illegal structure type."))))


;;; PARSE-SLOT-DESCRIPTION parses the given slot-description
;;;  and returns a list of the form:
;;;        (slot-name default-init slot-type read-only offset accessor-name)

(defun parse-slot-description (slot-description offset &optional read-only)
  (declare (si::c-local))
  (let* ((slot-type 'T)
         slot-name default-init)
    (cond ((atom slot-description)
           (setq slot-name slot-description))
          ((endp (cdr slot-description))
           (setq slot-name (car slot-description)))
          (t
           (setq slot-name (car slot-description))
           (setq default-init (cadr slot-description))
           (do ((os (cddr slot-description) (cddr os)) (o) (v))
               ((endp os))
             (setq o (car os))
             (when (endp (cdr os))
                   (error "~S is an illegal structure slot option."
                          os))
             (setq v (cadr os))
             (case o
               (:TYPE (setq slot-type v))
               (:READ-ONLY (setq read-only v))
               (t
                (error "~S is an illegal structure slot option."
                         os))))))
    (list slot-name default-init slot-type read-only offset nil)))


;;; OVERWRITE-SLOT-DESCRIPTIONS overwrites the old slot-descriptions
;;;  with the new descriptions which are specified in the
;;;  :include defstruct option.

(defun overwrite-slot-descriptions (new-slots old-slots)
  (declare (si::c-local))
  (do* ((output '())
        (old-slots old-slots (rest old-slots)))
       ((null old-slots)
        (nreverse output))
    (let* ((old-slot (first old-slots))
           (slot-name (first old-slot))
           (new-slot (first (member slot-name new-slots :key #'car))))
      (if (null new-slot)
          (setf new-slot old-slot)
          (let* ((old-read-only (fourth old-slot))
                 (new-read-only (fourth new-slot)))
            (cond ((and (null new-read-only)
                        old-read-only)
                   (error "Tried to turn a read only slot ~A into writtable."
                          slot-name))
                  ((eq new-read-only :unknown)
                   (setf new-read-only old-read-only)))
            (setf new-slot (copy-list new-slot)
                  (fourth new-slot) new-read-only
                  (fifth new-slot) (fifth old-slot) ; preserve offset
                  (sixth new-slot) (sixth old-slot))))
      (push new-slot output))))

(defun define-structure (name conc-name type named slots slot-descriptions
                         copier include print-function print-object constructors
                         offset name-offset documentation predicate)
  (create-type-name name)
  ;; We are going to modify this list!!!
  (setf slot-descriptions (copy-tree slot-descriptions))
  ;; FIXME! We could do the same with ENSURE-CLASS!
  #+clos
  (unless type
    (eval `(defclass ,name ,(and include (list include))
             ,(mapcar
               #'(lambda (sd)
                   (if sd
                       (list* (first sd)
                              :initform (second sd)
                              :initarg 
                              (intern (symbol-name (first sd))
                                      (find-package 'KEYWORD))
                              (when (third sd) (list :type (third sd))))
                       nil))            ; for initial offset slots
               slot-descriptions)
             (:metaclass structure-class))))
  ;; FIXME! We can do the same with INSTALL-METHOD!
  #+clos
  (when print-function
    (eval `(defmethod print-object ((obj ,name) stream)
             (,print-function obj stream 0)
             obj)))
  #+clos
  (when print-object
    (eval `(defmethod print-object ((obj ,name) stream)
            (,print-object obj stream)
            obj)))
  (when predicate
    (fset predicate (make-predicate name type named name-offset)))
  (put-sysprop name 'DEFSTRUCT-FORM `(defstruct ,name ,@slots))
  (put-sysprop name 'IS-A-STRUCTURE t)
  (put-sysprop name 'STRUCTURE-SLOT-DESCRIPTIONS slot-descriptions)
  (put-sysprop name 'STRUCTURE-INCLUDE include)
  (put-sysprop name 'STRUCTURE-PRINT-FUNCTION print-function)
  (put-sysprop name 'STRUCTURE-TYPE type)
  (put-sysprop name 'STRUCTURE-NAMED named)
  (put-sysprop name 'STRUCTURE-OFFSET offset)
  (put-sysprop name 'STRUCTURE-CONSTRUCTORS constructors)
  #+clos
  (when *keep-documentation*
    (set-documentation name 'STRUCTURE documentation))
  (dolist (x slot-descriptions)
    (and x
         (not (eql (car x) 'TYPED-STRUCTURE-NAME))
         (funcall #'make-access-function name conc-name type named x)))
  (when copier
    (fset copier #'copy-structure))
  #+clos
  (unless type
    (find-class name)))

;;; The DEFSTRUCT macro.

(defmacro defstruct (&whole whole name&opts &rest slots)
  "Syntax: (defstruct
         {name | (name {:conc-name | (:conc-name prefix-string) |
                        :constructor | (:constructor symbol [lambda-list]) |
                        :copier | (:copier symbol) |
                        :predicate | (:predicate symbol) |
                        (:include symbol) |
                        (:print-function function) |
                        (:print-object function) |
                        (:type {vector | (vector type) | list}) |
                        :named |
                        (:initial-offset number)}*)}
         [doc]
         {slot-name |
          (slot-name [default-value-form] {:type type | :read-only flag}*) }*
         )
Defines a structure named by NAME.  The doc-string DOC, if supplied, is saved
as a STRUCTURE doc and can be retrieved by (documentation 'NAME 'structure)."
  (let*((slot-descriptions slots)
        (name (if (consp name&opts) (first name&opts) name&opts))
        (options (when (consp name&opts) (rest name&opts)))
        (conc-name (base-string-concatenate name "-"))
        (default-constructor (intern (base-string-concatenate "MAKE-" name)))
        (copier (intern (base-string-concatenate "COPY-" name)))
        (predicate (intern (base-string-concatenate name "-P")))
        constructors no-constructor
        predicate-specified
        include
        print-function print-object type named initial-offset
        offset name-offset
        documentation)

    ;; Parse the defstruct options.
    (do ((os options (cdr os)) (o) (v))
        ((endp os))
      (cond ((and (consp (car os)) (not (endp (cdar os))))
             (setq o (caar os) v (cadar os))
             (case o
               (:CONC-NAME
                (if (null v)
                    (setq conc-name nil)
                    (setq conc-name v)))
               (:CONSTRUCTOR
                (if (null v)
                    (setq no-constructor t)
                    (if (endp (cddar os))
                        (setq constructors (cons v constructors))
                        (setq constructors (cons (cdar os) constructors)))))
               (:COPIER (setq copier v))
               (:PREDICATE
                (setq predicate v)
                (setq predicate-specified t))
               (:INCLUDE
                (setq include (cdar os))
                (unless (get-sysprop v 'IS-A-STRUCTURE)
                        (error "~S is an illegal included structure." v)))
               (:PRINT-FUNCTION (setq print-function v))
               (:PRINT-OBJECT (setq print-object v))
               (:TYPE (setq type v))
               (:INITIAL-OFFSET (setq initial-offset v))
               (t (error "~S is an illegal defstruct option." o))))
            (t
             (if (consp (car os))
                 (setq o (caar os))
                 (setq o (car os)))
             (case o
               (:CONSTRUCTOR
                (setq constructors
                      (cons default-constructor constructors)))
               (:CONC-NAME
                (setq conc-name nil))
               ((:COPIER :PREDICATE :PRINT-FUNCTION :PRINT-OBJECT))
               (:NAMED (setq named t))
               (t (error "~S is an illegal defstruct option." o))))))

    ;; Skip the documentation string.
    (when (and (not (endp slot-descriptions))
               (stringp (car slot-descriptions)))
          (setq documentation (car slot-descriptions))
          (setq slot-descriptions (cdr slot-descriptions)))

    ;; Check the include option.
    (when include
          (unless (equal type (get-sysprop (car include) 'STRUCTURE-TYPE))
                  (error "~S is an illegal structure include."
                         (car include))))

    ;; Set OFFSET.
    (setq offset (if include
                     (get-sysprop (car include) 'STRUCTURE-OFFSET)
                     0))

    ;; Increment OFFSET.
    (when (and type initial-offset)
          (setq offset (+ offset initial-offset)))
    (when (and type named)
          (unless (or (subtypep '(vector symbol) type)
                      (subtypep type 'list))
            (error "Structure cannot have type ~S and be :NAMED." type))
          (setq name-offset offset)
          (setq offset (1+ offset)))

    ;; Parse slot-descriptions, incrementing OFFSET for each one.
    (do ((ds slot-descriptions (cdr ds))
         (sds nil))
        ((endp ds)
         (setq slot-descriptions (nreverse sds)))
      (push (parse-slot-description (car ds) offset) sds)
      (setq offset (1+ offset)))

    ;; If TYPE is non-NIL and structure is named,
    ;;  add the slot for the structure-name to the slot-descriptions.
    (when (and type named)
          (setq slot-descriptions
                (cons (list 'TYPED-STRUCTURE-NAME name) slot-descriptions)))

    ;; Pad the slot-descriptions with the initial-offset number of NILs.
    (when (and type initial-offset)
          (setq slot-descriptions
                (append (make-list initial-offset) slot-descriptions)))

    ;; Append the slot-descriptions of the included structure.
    ;; The slot-descriptions in the include option are also counted.
    (cond ((null include))
          ((endp (cdr include))
           (setq slot-descriptions
                 (append (get-sysprop (car include) 'STRUCTURE-SLOT-DESCRIPTIONS)
                         slot-descriptions)))
          (t
           (setq slot-descriptions
                 (append (overwrite-slot-descriptions
                          (mapcar #'(lambda (sd)
                                      (parse-slot-description sd 0 :unknown))
                                  (cdr include))
                          (get-sysprop (car include) 'STRUCTURE-SLOT-DESCRIPTIONS))
                         slot-descriptions))))

    (cond (no-constructor
           ;; If a constructor option is NIL,
           ;;  no constructor should have been specified.
           (when constructors
                 (error "Contradictory constructor options.")))
          ((null constructors)
           ;; If no constructor is specified,
           ;;  the default-constructor is made.
           (setq constructors (list default-constructor))))

    ;; Check the named option and set the predicate.
    (when (and type (not named))
      (when (and predicate-specified predicate)
        (error "~S is an illegal structure predicate."
               predicate))
      (setq predicate nil))

    (when include (setq include (car include)))

    ;; Check the print-function.
    (when (and print-function type)
      (error "A print function is supplied to a typed structure."))

    ;;
    ;; The constructors rely on knowing the structure class. For toplevel
    ;; forms we can use LOAD-TIME-VALUE. For non-toplevel forms, we can not
    ;; as the class might be defined _after_ the system decides to evaluate
    ;; LOAD-TIME-VALUE.
    ;;
    (let ((core `(define-structure ',name ',conc-name ',type ',named ',slots
                                ',slot-descriptions ',copier ',include
                                ',print-function ',print-object ',constructors
                                ',offset ',name-offset
                                ',documentation ',predicate))
          (constructors (mapcar #'(lambda (constructor)
                                    (make-constructor name constructor type named
                                                      slot-descriptions))
                                constructors)))
      `(progn
         (eval-when (:compile-toplevel :load-toplevel)
           ,core
           ,(si::register-with-pde whole)
           ,@(subst `(load-time-value (find-class ',name))
                    '.structure-constructor-class.
                    constructors))
         (eval-when (:execute)
           (let ((.structure-constructor-class. ,core))
             ,@constructors))
         ',name))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/defstruct.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/helpfile.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2001, Juan Jose Garcia-Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;

(in-package "SYSTEM")

;;;;----------------------------------------------------------------------
;;;; Documentation system
;;;;

#+ecl-min
(progn
  (*make-special '*documentation-pool*)
  (setq *documentation-pool* nil)
  (*make-special '*keep-documentation*)
  (setq *keep-documentation* t))
#-ecl-min
(progn
  (setq *documentation-pool*
        (list (make-hash-table :test #'equal :size 128)
              "SYS:help.doc"))
  (defparameter *keep-documentation* t))

(defun new-documentation-pool (&optional (size 1024))
  "Args: (&optional hash-size)
Sets up a new hash table for storing documentation strings."
  (push (make-hash-table :test #'eql :size size)
        *documentation-pool*))

(defun record-cons (record key sub-key)
  (let ((cons (cons key sub-key)))
    (dolist (i record i)
      (when (equalp (car i) cons)
        (return i)))))

(defun record-field (record key sub-key)
  (cdr (record-cons record key sub-key)))

(defun set-record-field (record key sub-key value)
  (let ((field (record-cons record key sub-key)))
    (if field
        (rplacd field value)
        (setq record (list* (cons (cons key sub-key) value) record)))
    record))

(defun rem-record-field (record key sub-key)
  (let ((x (record-cons record key sub-key)))
    (if x
        (let ((output '()))
          (dolist (i record output)
            (when (not (eq i x))
              (setq output (cons i output)))))
        record)))

(defun annotate (object key sub-key value)
  (let ((dict (first *documentation-pool*)))
    (when (hash-table-p dict)
      (let ((record (set-record-field (gethash object dict)
                                      key sub-key value)))
        (si::hash-set object dict record)))))

(defun remove-annotation (object key sub-key)
  (let ((dict (first *documentation-pool*)))
    (when (hash-table-p dict)
      (let ((record (rem-record-field (gethash object dict)
                                      key sub-key)))
        (if record
            (si::hash-set object dict record)
            (remhash object dict))))))

(defun get-annotation (object key &optional (sub-key :all))
  (let ((output '()))
    (dolist (dict *documentation-pool* output)
      (let ((record (if (hash-table-p dict)
                        (gethash object dict)
                        (if (stringp dict)
                            (search-help-file object dict)
                            nil))))
        (when record
          (if (eq sub-key :all)
              (dolist (i record)
                (let ((key-sub-key (car i)))
                  (when (equal (car key-sub-key) key)
                    (push (cons (cdr key-sub-key) (cdr i)) output))))
              (if (setq output (record-field record key sub-key))
                  (return output))))))))

(defun dump-documentation (file &optional (merge nil))
  "Args: (filespec &optional (merge nil))
Saves the current hash table for documentation strings to the specificed file.
If MERGE is true, merges the contents of this table with the original values in
the help file."
  (let ((dict (first *documentation-pool*)))
    (when (hash-table-p dict)
      (dump-help-file dict file merge)
      (rplaca *documentation-pool* file))))

(defun get-documentation (object doc-type)
  (when (functionp object)
    (when (null (setq object (compiled-function-name object)))
      (return-from get-documentation nil)))
  (if (and object (listp object) (si::valid-function-name-p object))
      (get-annotation (second object) 'setf-documentation doc-type)
      (get-annotation object 'documentation doc-type)))

(defun set-documentation (object doc-type string)
  (when (not (or (stringp string) (null string)))
    (error "~S is not a valid documentation string" string))
  (let ((key 'documentation))
    (when (and object (listp object) (si::valid-function-name-p object))
      (setq object (second object) key 'setf-documentation))
    (if string
        (annotate object key doc-type string)
        (remove-annotation object key doc-type)))
  string)

(defun expand-set-documentation (symbol doc-type string)
  (when (and *keep-documentation* string)
    (when (not (stringp string))
      (error "~S is not a valid documentation string" string))
    `((set-documentation ',symbol ',doc-type ,string))))

#-clos
(defun documentation (object type)
  "Args: (symbol doc-type)
Returns the DOC-TYPE doc-string of SYMBOL; NIL if none exists.  Possible doc-
types are:
        FUNCTION  (special forms, macros, and functions)
        VARIABLE  (global variables)
        TYPE      (type specifiers)
        STRUCTURE (structures)
        SETF      (SETF methods)
All built-in special forms, macros, functions, and variables have their doc-
strings."
  (cond ((member type '(function type variable setf structure))
         (when (not (symbolp object))
           (error "~S is not a symbol." object))
         (si::get-documentation object type))
        (t
         (error "~S is an unknown documentation type" type))))

(defun make-dspec (definition)
  (when (consp definition)
    (let* ((kind (first definition))
           (name (second definition))
           (extra '()))
      (when (eq kind 'defmethod)
        (let ((list (third definition)))
          (setq extra (if (symbolp list)
                          (cons list (fourth definition))
                          list))))
      (list* kind name extra))))

;; (EXT:OPTIONAL-ANNOTATION arguments for EXT:ANNOTATE)
(si::fset 'ext:optional-annotation
          #'(ext:lambda-block ext:optional-annotation (whole env)
               (declare (ignore env))
               `(ext:annotate ,@(rest whole)))
          t)

(defun default-annotation-logic (source-location definition output-form
                                 &optional (dspec (make-dspec definition)))
  (let* ((kind (first definition))
         (name (second definition)))
    `(progn
       (ext:optional-annotation ',name 'location ',dspec ',source-location)
       ,(when (member kind '(defun defmacro defgeneric))
          `(ext:optional-annotation ',name :lambda-list nil ',(third definition)))
       ,output-form)))

#+ecl-min
(when (null *documentation-pool*) (new-documentation-pool 1024))
(setq ext::*register-with-pde-hook* 'default-annotation-logic)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/helpfile.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/seqlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:
;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                           sequence routines

(in-package "SYSTEM")

#+ecl-min
(eval-when (:execute)
  (load (merge-pathnames "seqmacros.lsp" *load-truename*)))

#-ecl-min
(eval-when (:compile-toplevel)
(define-compiler-macro copy-subarray (&rest args)
  `(ffi:c-inline ,args (:object :fixnum :object :fixnum :fixnum) :void
                 "ecl_copy_subarray(#0,#1,#2,#3,#4)"
                 :one-liner t))
)

(defun seqtype (sequence)
  (declare (si::c-local))
  (cond ((listp sequence) 'list)
        ((base-string-p sequence) 'base-string)
        ((stringp sequence) 'string)
        ((bit-vector-p sequence) 'bit-vector)
        ((vectorp sequence) (list 'vector (array-element-type sequence)))
        (t (error "~S is not a sequence." sequence))))

(defun sequence-count (count)
  (cond ((null count)
         most-positive-fixnum)
        ((fixnump count)
         count)
        ((integerp count)
         (if (minusp count)
             -1
             most-positive-fixnum))
        (t
         (error 'simple-type-error
                :datum count
                :expected-type 'integer
                :format-control "The value of :COUNT is not a valid counter~%~4I~A"
                :format-arguments (list count)))))

(defun test-error()
  (declare (si::c-local))
  (error "both test and test-not are supplied"))

(defun unsafe-funcall1 (f x)
  (declare (function f)
           (optimize (speed 3) (safety 0)))
  (funcall f x))

(defun reduce (function sequence
               &key from-end
                    (start 0)
                    end
                    key (initial-value nil ivsp))
  (let ((function (si::coerce-to-function function)))
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence length)
      (declare (ignore length))
      (with-key (key)
        (cond ((>= start end)
               (if ivsp
                   initial-value
                   (funcall function)))
              ((listp sequence)
               (when from-end
                 (let* ((output nil))
                   (do-sublist (elt sequence start end)
                     (setf output (cons elt output)))
                   (setf sequence output
                         end (- end start) start 0)))
               (while (plusp start)
                 (setf sequence (cons-cdr sequence)
                       start (1- start)
                       end (1- end)))
               (unless ivsp
                 (setf initial-value (key (cons-car sequence))
                       sequence (cons-cdr sequence)
                       end (1- end)))
               (do-sublist (elt sequence 0 end :output initial-value)
                 (setf initial-value
                       (if from-end
                           (funcall function (key elt) initial-value)
                           (funcall function initial-value (key elt))))))
              (from-end
               (unless ivsp
                 (setf initial-value (key (aref sequence (1- end)))
                       end (1- end)))
               (do-vector(elt sequence start end :from-end t
                              :output initial-value)
                 (setf initial-value
                       (funcall function (key elt) initial-value))))
              (t
               (unless ivsp
                 (setf initial-value (key (aref sequence start))
                       start (1+ start)))
               (do-vector(elt sequence start end :output initial-value)
                 (setf initial-value
                       (funcall function initial-value (key elt))))
                 ))))))

(defun fill (sequence item &key (start 0) end)
  ;; INV: WITH-START-END checks the sequence type and size.
  (reckless
   (with-start-end (start end sequence)
     (if (listp sequence)
         (do* ((x (nthcdr start sequence) (cdr x))
               (i (- end start) (1- i)))
              ((zerop i)
               sequence)
           (declare (fixnum i) (cons x))
           (setf (first x) item))
         (si::fill-array-with-elt sequence item start end)))))

(defun replace (sequence1 sequence2 &key (start1 0) end1 (start2 0) end2)
  (with-start-end (start1 end1 sequence1)
   (with-start-end (start2 end2 sequence2)
     (declare (optimize (speed 3) (safety 0) (debug 0)))
     (let ((length (min (- end2 start2) (- end1 start1))))
       (declare (fixnum length))
       ;; If the two sequences are arrays, we can use COPY-SUBARRAY.
       ;; Otherwise we have our own loop, which relies on sequence
       ;; iterators. It becomes inefficient when sequences overlap
       ;; because it has to save the data.
       (if (and (vectorp sequence1)
                (vectorp sequence2))
           (copy-subarray sequence1 start1 sequence2 start2 length)
           (do* ((data (if (and (eq sequence1 sequence2)
                                (> start1 start2))
                           (subseq sequence2 start2 end2)
                           sequence2))
                 (it2 (make-seq-iterator data start2)
                      (seq-iterator-next data it2))
                 (it1 (make-seq-iterator sequence1 start1)
                      (seq-iterator-next sequence1 it1)))
                ((or (<= length 0) (null it1) (null it2)))
             (seq-iterator-set sequence1 it1
                               (seq-iterator-ref sequence2 it2))
             (decf length))))))
  sequence1)

(defun filter-vector (which out in start end from-end count
                      test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end in l)
      (with-count (%count count :output in)
        (let* ((existing 0))
          (declare (fixnum existing))
          ;; If the OUT is empty that means we REMOVE and we have to
          ;; create the destination array. For that we first count how
          ;; many elements are deletable and allocate the
          ;; corresponding amount of space.
          (unless (eq out in)
            (setf existing (count which in :start start :end end
                                   :test test :test-not test-not :key key))
            (when (zerop existing)
              (return-from filter-vector
                (values in l)))
            (setf out (make-array (- l (min existing %count))
                                  :element-type
                                  (array-element-type in))))
          ;; We begin by copying the elements in [0, start)
          (unless (eq out in)
            (copy-subarray out 0 in 0 start))
          ;; ... skip the elements in [start, end) which either
          ;; do not need to be filtered (because of :from-end)
          ;; or do not satisfy the test, 
          (let ((skip 0))
            (declare (fixnum skip))
            (when from-end
              (unless (plusp existing)
                (setf existing (count which in :start start :end end
                                      :test test :test-not test-not
                                      :key key)))
              (setf skip (if (< existing %count) 0 (- existing %count))))
            (if (eq out in)
                (do-vector (elt in start end :index index)
                  (when (and (compare which (key elt))
                             (minusp (decf skip)))
                    (return))
                  (incf start))
                (do-vector (elt in start end :index index)
                  (when (and (compare which (key elt))
                             (minusp (decf skip)))
                    (return))
                  (setf (aref (truly-the vector out) start) elt
                        start (1+ start)))))
          ;; ... now filter the rest
          (do-vector (elt in start end :index index)
            (if (compare which (key elt))
                (when (zerop (decf %count))
                  (setf end (1+ index))
                  (return))
                (setf (aref (truly-the vector out) start) elt
                      start (1+ start))))
          ;; ... and copy the elements outside the limits
          (copy-subarray out start in end l)
          (values out (+ start (- l end))))))))

(defun remove-list (which sequence start end count test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence)
      (with-count (%count count :output sequence)
        (let* ((output nil)
               (index 0))
          (declare (fixnum index))
          (while (and sequence (< index start))
            (setf output (cons (cons-car sequence) output)
                  sequence (cons-cdr sequence)
                  index (1+ index)))
          (loop
             (unless (< index end) (return))
             (let ((elt (cons-car sequence)))
               (setf sequence (cons-cdr sequence))
               (if (compare which (key elt))
                   (when (zerop (decf %count))
                     (return))
                   (push elt output))
               (incf index)))
          (nreconc output sequence))))))

(defun remove (which sequence &key test test-not (start 0) end
               from-end count key)
  (declare (optimize (speed 3) (safety 1) (debug 0)))
  (if (listp sequence)
      (if from-end
          (let ((l (length sequence)))
            (nreverse (delete which (reverse sequence)
                              :start (if end (- l end) 0) :end (- l start)
                              :from-end nil
                              :test test :test-not test-not :key key
                              :count count)))
          (remove-list which sequence start end count test test-not key))
      (values (filter-vector which nil sequence start end from-end count
                             test test-not key))))

(defun remove-if (predicate sequence &key (start 0) end from-end count key)
  (remove (si::coerce-to-function predicate) sequence
          :start start :end end :from-end from-end :count count
          :test #'unsafe-funcall1 :key key))

(defun remove-if-not (predicate sequence &key (start 0) end from-end count key)
  (remove (si::coerce-to-function predicate) sequence
          :start start :end end :from-end from-end :count count
          :test-not #'unsafe-funcall1 :key key))

(defun delete-list (which sequence start end count test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence)
      (with-count (%count count :output sequence)
        (let* ((splice (cons nil sequence))
               (output splice)
               (index 0))
          (declare (fixnum index)
                   (cons splice))
          (while (and sequence (< index start))
            (setf sequence (cons-cdr sequence)
                  splice (cons-cdr splice)
                  index (1+ index)))
          (loop
             (unless (< index end)
               (return))
             (let ((elt (cons-car sequence)))
               (setf sequence (cons-cdr sequence))
               (cond ((compare which (key elt))
                      (setf (cdr splice) sequence)
                      (when (zerop (decf %count))
                        (return)))
                     (t
                      (setf splice (cdr splice))))
               (incf index)))
          (cdr output))))))

(defun delete (which sequence &key test test-not (start 0) end
               from-end count key)
  (declare (optimize (speed 3) (safety 1) (debug 0))
           (ext:check-arguments-type nil))
  (cond ((listp sequence)
         (if from-end
             (let ((l (length sequence)))
               (nreverse
                (delete-list which (nreverse sequence)
                             (if end (- l end) 0) (- l start)
                             count test test-not key)))
             (delete-list which sequence start end count test test-not key)))
        ((not (vectorp sequence))
         (signal-type-error sequence 'sequence))
        ((array-has-fill-pointer-p (truly-the vector sequence))
         (multiple-value-bind (sequence l)
             (filter-vector which sequence sequence start end from-end count
                            test test-not key)
           (setf (fill-pointer (truly-the vector sequence)) l)
           sequence))
        (t
         (values (filter-vector which nil sequence start end from-end count
                                test test-not key)))))

(defun delete-if (predicate sequence &key (start 0) end from-end count key)
  (delete (si::coerce-to-function predicate) sequence
          :start start :end end :from-end from-end :count count
          :test #'unsafe-funcall1 :key key))

(defun delete-if-not (predicate sequence &key (start 0) end
                      from-end count key)
  (delete (si::coerce-to-function predicate) sequence
          :start start :end end :from-end from-end :count count
          :test-not #'unsafe-funcall1 :key key))

(defun count (item sequence &key test test-not from-end (start 0) end key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence l)
      (let ((counter 0))
        (declare (fixnum counter))
        (if from-end
            (if (listp sequence)
                (count item (reverse sequence)
                       :start (- l end) :end (- l start)
                       :test test :test-not test-not :key key)
                (do-vector (elt sequence start end :from-end t
                                :output counter)
                  (when (compare item (key elt))
                    (incf counter))))
            (do-sequence (elt sequence start end :specialize t
                              :output counter)
              (when (compare item (key elt))
                (incf counter))))))))

(defun count-if (predicate sequence &key from-end (start 0) end key)
  (count (si::coerce-to-function predicate) sequence
         :from-end from-end :start start :end end
         :test #'unsafe-funcall1 :key key))

(defun count-if-not (predicate sequence &key from-end (start 0) end key)
  (count (si::coerce-to-function predicate)
         sequence :from-end from-end :start start :end end
         :test-not #'unsafe-funcall1 :key key))

(defun substitute (new old sequence &key test test-not (start 0) end
                   from-end count key)
  (nsubstitute new old (copy-seq sequence) :start start :end end :from-end from-end
               :count count :key key :test test :test-not test-not))

(defun substitute-if (new predicate sequence
                      &key (start 0) end from-end count key)
  (nsubstitute new (si::coerce-to-function predicate) (copy-seq sequence)
               :key key :test #'unsafe-funcall1
               :start start :end end :from-end from-end :count count
               :key key))

(defun substitute-if-not (new predicate sequence
                          &key (start 0) end from-end count key)
  (nsubstitute new (si::coerce-to-function predicate) (copy-seq sequence)
               :key key :test-not #'unsafe-funcall1
               :start start :end end :from-end from-end :count count
               :key key))

(defun nsubstitute (new old sequence &key test test-not (start 0) end
                    from-end count key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence l)
      (with-count (%count count :output sequence)
        ;; FIXME! This could be simplified to (AND FROM-END COUNT)
        ;; but the ANSI test suite complains because it expects always
        ;; a from-end inspection order!
        (if from-end
            (if (listp sequence)
                (nreverse
                 (nsubstitute new old (nreverse sequence)
                              :start (- l end) :end (- l start)
                              :key key :test test :test-not test-not
                              :count count))
                (do-vector (elt sequence start end :setter elt-set
                                :from-end t :output sequence)
                  (when (compare old (key elt))
                    (elt-set new)
                    (when (zerop (decf %count))
                      (return sequence)))))
            (do-sequence (elt sequence start end :setter elt-set
                              :output sequence :specialize t)
              (when (compare old (key elt))
                (elt-set new)
                (when (zerop (decf %count))
                  (return sequence)))))))))

(defun nsubstitute-if (new predicate sequence
                       &key (start 0) end from-end count key)
  (nsubstitute new (si::coerce-to-function predicate) sequence
               :key key :test #'unsafe-funcall1
               :start start :end end :from-end from-end :count count
               :key key))

(defun nsubstitute-if-not (new predicate sequence
                           &key (start 0) end from-end count key)
  (nsubstitute new (si::coerce-to-function predicate) sequence
               :key key :test-not #'unsafe-funcall1
               :start start :end end :from-end from-end :count count
               :key key))


(defun find (item sequence &key test test-not (start 0) end from-end key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence length)
      (declare (ignore length))
      (let ((output nil))
        (do-sequence (elt sequence start end
                          :output output :index index :specialize t)
          (when (compare item (key elt))
            (unless from-end
              (return elt))
            (setf output elt)))))))

(defun find-if (predicate sequence &key from-end (start 0) end key)
  (find (si::coerce-to-function predicate) sequence
        :from-end from-end :start start :end end
        :test #'unsafe-funcall1 :key key))

(defun find-if-not (predicate sequence &key from-end (start 0) end key)
  (find (si::coerce-to-function predicate) sequence
        :from-end from-end :start start :end end
        :test-not #'unsafe-funcall1 :key key))


(defun position (item sequence &key test test-not from-end (start 0) end key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (with-start-end (start end sequence)
      (let ((output nil))
        (do-sequence (elt sequence start end
                      :output output :index index :specialize t)
          (when (compare item (key elt))
            (unless from-end
              (return index))
            (setf output index)))))))

(defun position-if (predicate sequence &key from-end (start 0) end key)
  (position (si::coerce-to-function predicate) sequence
            :from-end from-end :start start :end end
            :test #'unsafe-funcall1 :key key))

(defun position-if-not (predicate sequence &key from-end (start 0) end key)
  (position (si::coerce-to-function predicate) sequence
            :from-end from-end :start start :end end
            :test-not #'unsafe-funcall1 :key key))

(defun remove-duplicates-list (sequence start end from-end test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0) (space 0)))
    (with-start-end (start end sequence)
      (let* ((output nil))
        (while (and sequence (plusp start))
          (setf output (cons (cons-car sequence) output)
                sequence (cons-cdr sequence)
                start (1- start)
                end (1- end)))
        (let ((start sequence)
              (end (nthcdr (- end start) sequence)))
          ;; When from-end, keep the first occurrence of each duplicate
          ;; element; otherwise we keep the last one. Hence, A-I-L-P
          ;; 1) if from-end, return T only when there are no duplicates
          ;;    before current;
          ;; 2) otherwise, return T only when there are no duplicates
          ;;    after the current one.
          (flet ((already-in-list-p (start current end from-end)
                   (let ((elt (key (cons-car current))))
                     (if from-end
                         (loop
                            (when (eq start current)
                              (return nil))
                            (when (compare elt (key (cons-car start)))
                              (return t))
                            (setf start (cons-cdr start)))
                         (loop
                            (setf current (cons-cdr current))
                            (when (eq current end)
                              (return nil))
                            (when (compare elt (key (cons-car current)))
                              (return t)))))))
            (loop
               (when (eq sequence end)
                 (return (nreconc output sequence)))
               (unless (already-in-list-p start sequence end from-end)
                 (push (cons-car sequence) output))
               (setf sequence (cons-cdr sequence)))))))))

(defun remove-duplicates (sequence
                          &key test test-not from-end (start 0) end key)
  "Args: (sequence
       &key key (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil))
Returns a copy of SEQUENCE without duplicated elements."
  (cond ((listp sequence)
         (remove-duplicates-list sequence start
                                 end from-end test test-not key))
        ((vectorp sequence)
         (let* ((l (filter-duplicates-vector nil sequence
                                             start end from-end
                                             test test-not key))
                (v (make-array l :element-type
                               (array-element-type sequence))))
           (filter-duplicates-vector v sequence
                                     start end from-end
                                     test test-not key)
           v))
        ((not (vectorp sequence))
         (signal-type-error sequence 'sequence))))

(defun delete-duplicates-list (sequence start end from-end test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0) (space 0)))
    (with-start-end (start end sequence)
      (let* ((splice (cons nil sequence))
             (output splice))
        (while (and sequence (plusp start))
          (setf splice (cons-cdr splice)
                sequence (cons-cdr sequence)
                start (1- start)
                end (1- end)))
        (let ((start splice)
              (end (nthcdr (- end start) sequence)))
          (flet ((already-in-list-p (start current end from-end)
                   (let ((elt (key (cons-car current))))
                     (if from-end
                         (loop
                            (when (eq start current)
                              (return nil))
                            (when (compare elt (key (cons-car start)))
                              (return t))
                            (setf start (cons-cdr start)))
                         (loop
                            (setf current (cons-cdr current))
                            (when (eq current end)
                              (return nil))
                            (when (compare elt (key (cons-car current)))
                              (return t)))))))
            (loop
               (when (eq sequence end)
                 (return (cons-cdr output)))
               (if (already-in-list-p (cons-cdr start)
                                      sequence end from-end)
                   (setf sequence (cons-cdr sequence)
                         (cdr splice) sequence)
                   (setf sequence (cons-cdr sequence)
                         splice (cons-cdr splice))))))))))

(defun filter-duplicates-vector (out in start end from-end test test-not key)
  (with-tests (test test-not key)
    (declare (optimize (speed 3) (safety 0) (debug 0) (space 0)))
    (with-start-end (start end in length)
      (when (and out (not (eq out in)))
        (copy-subarray out 0 in 0 start))
      (flet ((already-in-vector-p (sequence start current end from-end)
               (declare (vector sequence)
                        (fixnum start current end))
               (if from-end
                   (setf end current)
                   (setf start (1+ current)))
               (let ((base (key (aref sequence current))))
                 (do-vector (elt sequence start end :output nil)
                   (when (compare base (key elt))
                     (return t))))))
        (let ((index start)
              (jndex start))
          (declare (fixnum index jndex))
        (loop
           (when (= index end)
             (return (progn
                       (when out (copy-subarray out jndex in end length))
                       (+ jndex (- length end)))))
           (unless (already-in-vector-p in start index end from-end)
             (when out
               (setf (aref (truly-the vector out) jndex)
                     (aref (truly-the vector in) index)))
             (setf jndex (1+ jndex)))
           (setf index (1+ index))))))))

(defun delete-duplicates (sequence
                          &key test test-not from-end (start 0) end key)
  "Args: (sequence &key key
                     (test '#'eql) test-not
                     (start 0) (end (length sequence)) (from-end nil))
Destructive REMOVE-DUPLICATES.  SEQUENCE may be destroyed."
  (cond ((listp sequence)
         (delete-duplicates-list sequence start end from-end
                                 test test-not key))
        ((not (vectorp sequence))
         (signal-type-error sequence 'sequence))
        ((array-has-fill-pointer-p sequence)
         (let ((l (filter-duplicates-vector sequence sequence
                                            start end from-end
                                            test test-not key)))
           (setf (fill-pointer sequence) l)
           sequence))
        (t
         (let* ((l (filter-duplicates-vector nil sequence
                                             start end from-end
                                             test test-not key))
                (v (make-array l :element-type
                               (array-element-type sequence))))
           (filter-duplicates-vector v sequence
                                     start end from-end
                                     test test-not key)
           v))))       

(defun mismatch (sequence1 sequence2
                 &key from-end test test-not key
                      (start1 0) (start2 0)
                      end1 end2)
  "Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Compares element-wise the specified subsequences of SEQUENCE1 and SEQUENCE2.
Returns NIL if they are of the same length and they have the same elements in
the sense of TEST.  Otherwise, returns the index of SEQUENCE1 to the first
element that does not match."
  (with-start-end (start1 end1 sequence1)
   (with-start-end (start2 end2 sequence2)
    (with-tests (test test-not key)
      (if (not from-end)
          (do ((i1 start1 (1+ i1))
               (i2 start2 (1+ i2)))
              ((or (>= i1 end1) (>= i2 end2))
               (if (and (>= i1 end1) (>= i2 end2)) nil i1))
            (declare (fixnum i1 i2))
            (unless (compare (key (elt sequence1 i1))
                             (key (elt sequence2 i2)))
              (return i1)))
          (do ((i1 (1- end1) (1- i1))
               (i2 (1- end2)  (1- i2)))
              ((or (< i1 start1) (< i2 start2))
               (if (and (< i1 start1) (< i2 start2)) nil (1+ i1)))
            (declare (fixnum i1 i2))
            (unless (compare (key (elt sequence1 i1))
                             (key (elt sequence2 i2)))
              (return (1+ i1)))))))))


(defun search (sequence1 sequence2
               &key from-end test test-not key
                    (start1 0) (start2 0)
                    end1 end2)
  "Args: (sequence1 sequence2
       &key key (test '#'eql) test-not
            (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))
            (from-end nil))
Searches SEQUENCE2 for a subsequence that element-wise matches SEQUENCE1.
Returns the index to the first element of the subsequence if such a
subsequence is found.  Returns NIL otherwise."
  #+(or)
  (search-generic sequence1 start1 end1 sequence2 start2 end2
                  test test-not key from-end)
  (if (and (vectorp sequence1) (vectorp sequence2))
      (search-vector sequence1 start1 end1 sequence2 start2 end2
                     test test-not key from-end)
      (search-generic sequence1 start1 end1 sequence2 start2 end2
                      test test-not key from-end)))

(defun search-vector (sequence1 start1 end1 sequence2 start2 end2
                      test test-not key from-end)
  (declare (si::c-local)
           (optimize (speed 3) (safety 0) (debug 0) (space 0))
           (vector sequence1 sequence2))
  (with-tests (test test-not key)
    (with-start-end (start1 end1 sequence1)
      (with-start-end (start2 end2 sequence2)
        (do* ((last-index -1)
              (last (let* ((l (- end1 start1))
                           (e (- end2 l)))
                      (declare (fixnum l e))
                      (unless (plusp l)
                        (return-from search-vector
                          (if from-end end2 0)))
                      (1+ e)))
              (start2 start2 (1+ start2))
              (base (key (aref sequence1 start1))))
             ((>= start2 last)
              (if (minusp last-index) nil last-index))
          (declare (fixnum start2 last-index))
          (when (compare base (key (aref sequence2 start2)))
            (let* ((i1 start1)
                   (i2 start2))
              (declare (fixnum i1 i2))
              (loop
                 (setf i1 (1+ i1)
                       i2 (1+ i2))
                 (when (or (>= i1 end1) (>= i2 end2))
                   (when from-end
                     (setf last-index start2)
                     (return))
                   (return-from search-vector start2))
                 (unless (compare (key (aref sequence1 i1))
                                  (key (aref sequence2 i2)))
                   (return))))))))))

(defun search-generic (sequence1 start1 end1 sequence2 start2 end2
                       test test-not key from-end)
  (declare (si::c-local)
           (optimize (speed 3) (safety 2) (debug 0) (space 0)))
  (with-tests (test test-not key)
    (with-start-end (start1 end1 sequence1)
      (with-start-end (start2 end2 sequence2)
        (do* ((last-index -1)
              (start2 start2 (1+ start2))
              (last (let* ((l (- end1 start1))
                           (e (- end2 l)))
                      (declare (fixnum l e))
                      (unless (plusp l)
                        (return-from search-generic
                          (if from-end end2 0)))
                      (1+ e)))
              (it1 (make-seq-iterator sequence1 start1))
              (base (key (seq-iterator-ref sequence1 it1)))
              (it2 (make-seq-iterator sequence2 start2)
                   (seq-iterator-next sequence2 it2)))
             ((or (null it2) (>= start2 last))
              (if (minusp last-index) nil last-index))
          (declare (fixnum start2 last-index last))
          (when (compare base (key (seq-iterator-ref sequence2 it2)))
            (let* ((it1 it1)
                   (it2 it2)
                   (i1 start1)
                   (i2 start2))
              (declare (fixnum i1 i2))
              (loop
                 (setf it1 (seq-iterator-next sequence1 it1)
                       it2 (seq-iterator-next sequence2 it2)
                       i1 (1+ i1)
                       i2 (1+ i2))
                 (when (or (>= i1 end1) (>= i2 end2)
                           (null it1) (null it2))
                   (when from-end
                     (setf last-index start2)
                     (return))
                   (return-from search-generic start2))
                 (unless (compare (key (seq-iterator-ref sequence1 it1))
                                  (key (seq-iterator-ref sequence2 it2)))
                   (return))))))))))


(defun sort (sequence predicate &key key)
  "Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  The order of two
elements X and Y is arbitrary if both
        (FUNCALL TEST X Y)
        (FUNCALL TEST Y X)
evaluates to NIL.  See STABLE-SORT."
  (setf key (if key (si::coerce-to-function key) #'identity)
        predicate (si::coerce-to-function predicate))
  (if (listp sequence)
      (list-merge-sort sequence predicate key)
      (quick-sort sequence 0 (truly-the fixnum (1- (length sequence))) predicate key)))


(defun list-merge-sort (l predicate key)
  (declare (si::c-local)
           (optimize (safety 0) (speed 3))
           (function predicate key))
  (prog ((i 0) left right l0 l1 key-left key-right)
     (declare (fixnum i))
     (setq i (length l))
     (cond ((< i 2) (return l))
           ((= i 2)
            (setq key-left (funcall key (car l)))
            (setq key-right (funcall key (cadr l)))
            (cond ((funcall predicate key-left key-right) (return l))
                  ((funcall predicate key-right key-left)
                   (return (nreverse l)))
                  (t (return l)))))
     (setq i (floor i 2))
     (do ((j 1 (1+ j)) (l1 l (cdr l1)))
         ((>= j i)
          (setq left l)
          (setq right (cdr l1))
          (rplacd l1 nil))
       (declare (fixnum j)))
     (setq left (list-merge-sort left predicate key))
     (setq right (list-merge-sort right predicate key))
     (cond ((endp left) (return right))
           ((endp right) (return left)))
     (setq l0 (cons nil nil))
     (setq l1 l0)
     (setq key-left (funcall key (car left)))
     (setq key-right (funcall key (car right)))
   loop
     (cond ((funcall predicate key-left key-right) (go left))
           ((funcall predicate key-right key-left) (go right))
           (t (go left)))
   left
     (rplacd l1 left)
     (setq l1 (cdr l1))
     (setq left (cdr left))
     (when (endp left)
       (rplacd l1 right)
       (return (cdr l0)))
     (setq key-left (funcall key (car left)))
     (go loop)
   right
     (rplacd l1 right)
     (setq l1 (cdr l1))
     (setq right (cdr right))
     (when (endp right)
       (rplacd l1 left)
       (return (cdr l0)))
     (setq key-right (funcall key (car right)))
     (go loop)))


(defun quick-sort (seq start end pred key)
  (declare (fixnum start end)
           (function pred key)
           (optimize (safety 0))
           (si::c-local))
  (if (< start end)
      (let* ((j (1+ end)))
        (declare (fixnum j))
        (let* ((i start)
               (l (- end start))
               (l-half (ash l -1))
               (p (+ start l-half))
               (d (elt seq p))
               (kd (funcall key d)))
          (declare (fixnum i p l l-half))
          (rotatef (elt seq p) (elt seq start))
          (block outer-loop
            (loop
               (loop 
                  (unless (> (decf j) i) (return-from outer-loop))
                  (when (funcall pred 
                                 (funcall key (elt seq j)) kd)
                    (return)))
               (loop 
              (unless (< (incf i) j) (return-from outer-loop))
                  (unless (funcall pred
                                   (funcall key (elt seq i)) kd)
                    (return)))
               (rotatef (elt seq i) (elt seq j))))
          (setf (elt seq start) (elt seq j)
                (elt seq j) d))
        (if (< (truly-the fixnum (- j start))
               (truly-the fixnum (- end j)))
            (progn
              (quick-sort seq start (1- j) pred key)
              (quick-sort seq (1+ j) end pred key))
            (progn
              (quick-sort seq (1+ j) end pred key)
              (quick-sort seq start (1- j) pred key))))
      seq))


(defun stable-sort-merge-vectors (source target start-1
                                  end-1 end-2 pred key)
  (declare (si::c-local))
  (let ((i start-1)
        (j end-1) ; start-2
        (target-i start-1))
    (declare (fixnum i j target-i))
    (loop
      (cond ((= i end-1)
        (loop (if (= j end-2) (return))
                  (setf (aref target target-i)
                        (aref source j))
                  (incf target-i)
                  (incf j))
            (return))
            ((= j end-2)
             (loop (if (= i end-1) (return))
                  (setf (aref target target-i)
                        (aref source i))
                  (incf target-i)
                  (incf i))
             (return))
            ((if key
                 (funcall pred (funcall key (aref source j))
                               (funcall key (aref source i)))
                 (funcall pred (aref source j) (aref source i)))
             (setf (aref target target-i)
                   (aref source j))
             (incf j))
            (t (setf (aref target target-i)
                     (aref source i))
               (incf i)))
     (incf target-i))))


(defun vector-merge-sort (vector pred key)
  (declare (si::c-local))
  (let* ((vector-len (length (the vector vector)))
         (n 1)            ; bottom-up size of contiguous runs to be merged
         (direction t)    ; t vector --> temp    nil temp --> vector
         (temp (make-array vector-len))
         (unsorted 0)   ; unsorted..vector-len are the elements that need
                                    ; to be merged for a given n
         (start-1 0))   ; one n-len subsequence to be merged with the next
    (declare (fixnum vector-len n unsorted start-1))
    (loop
       ;; for each n we start taking n-runs from the start of the vector
      (setf unsorted 0)
      (loop
        (setf start-1 unsorted)
        (let ((end-1 (+ start-1 n)))
          (declare (fixnum end-1))
          (cond ((< end-1 vector-len)
                 ;; there are enough elements for a second run
                 (let ((end-2 (+ end-1 n)))
                   (declare (fixnum end-2))
                   (if (> end-2 vector-len) (setf end-2 vector-len))
                   (setf unsorted end-2)
                   (if direction
                       (stable-sort-merge-vectors
                          vector temp start-1 end-1 end-2 pred key)
                       (stable-sort-merge-vectors
                          temp vector start-1 end-1 end-2 pred key))
                   (if (= unsorted vector-len) (return))))
                ;; if there is only one run copy those elements to the end
                (t (if direction
                       (do ((i start-1 (1+ i)))
                           ((= i vector-len))
                         (declare (fixnum i))
                         (setf (aref temp i) (aref vector i)))
                       (do ((i start-1 (1+ i)))
                           ((= i vector-len))
                         (declare (fixnum i))
                         (setf (aref vector i) (aref temp i))))
                   (return)))))
      ;; If the inner loop only executed once then there were only enough
      ;; elements for two subsequences given n so all the elements have
      ;; been merged into one list. Start-1 will have remained 0 upon exit.
      (when (zerop start-1)
        (when direction
          ;; if we just merged into the temporary copy it all back
          ;; to the given vector.
          (dotimes (i vector-len)
            (setf (aref vector i) (aref temp i))))
        (return vector))
      (setf n (ash n 1))           ; (* 2 n)
      (setf direction (not direction)))))


(defun stable-sort (sequence predicate &key key)
  "Args: (sequence test &key key)
Destructively sorts SEQUENCE and returns the result.  TEST should return non-
NIL if its first argument is to precede its second argument.  For two elements
X and Y, if both
        (FUNCALL TEST X Y)
        (FUNCALL TEST Y X)
evaluates to NIL, then the order of X and Y are the same as in the original
SEQUENCE.  See SORT."
  (setf key (if key (si::coerce-to-function key) #'identity)
        predicate (si::coerce-to-function predicate))
  (if (listp sequence)
      (list-merge-sort sequence predicate key)
      (if (bit-vector-p sequence)
          (sort sequence predicate :key key)
          (vector-merge-sort sequence predicate key))))


(defun merge (result-type sequence1 sequence2 predicate &key key
              &aux (l1 (length sequence1)) (l2 (length sequence2)))
  "Args: (type sequence1 sequence2 test &key key)
Merges two sequences in the way specified by TEST and returns the result as a
sequence of TYPE.  Both SEQUENCEs may be destroyed.  If both SEQUENCE1 and
SEQUENCE2 are sorted in the sense of TEST, then the result is also sorted in
the sense of TEST."
  (declare (fixnum l1 l2))
  (with-key (key)
    (with-predicate (predicate)
      (do* ((size (truly-the fixnum (+ l1 l2)))
            (j 0 (1+ j))
            (newseq (make-sequence result-type size))
            (i1 0)
            (i2 0))
           ((= j size) newseq)
        (declare (fixnum size j i1 i2))
        (if (>= i1 l1)
            (setf (elt newseq j) (elt sequence2 i2)
                  i2 (1+ i2))
            (let ((v1 (elt sequence1 i1)))
              (if (>= i2 l2)
                  (setf (elt newseq j) v1
                        i1 (1+ i1))
                  (let* ((v2 (elt sequence2 i2))
                         (k2 (key v2))
                         (k1 (key v1)))
                    (cond ((predicate k1 k2)
                           (setf (elt newseq j) v1
                                 i1 (1+ i1)))
                          ((predicate k2 k1)
                           (setf (elt newseq j) v2
                                 i2 (1+ i2)))
                          (t
                           (setf (elt newseq j) v1
                                 i1 (1+ i1))))))))))))

(defun complement (f)
  "Args: (f)
Returns a new function which first applies F to its arguments and then negates
the output"
  #'(lambda (&rest x) (not (apply f x))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/seqlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/seq.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                           sequence routines

(in-package "SYSTEM")

#+ecl-min
(eval-when (:execute)
  (load (merge-pathnames "seqmacros.lsp" *load-truename*)))

(defun error-not-a-sequence (value)
  (declare (si::c-local))
  (signal-type-error value 'sequence))

(defun error-sequence-index (sequence index)
  (declare (si::c-local))
  (error 'simple-type-error
         :datum index
         :expected-type 'unsigned-byte
         :format-control "Not a valid index ~A into sequence ~A"
         :format-arguments (list index sequence)))

(defun error-sequence-type (type)
  (declare (si::c-local))
  (error 'simple-type-error
         :datum (vector) ;; Any sequence object will do, because it does not belong to TYPE
         :expected-type type
         :format-control "~S does not specify a sequence type"
         :format-arguments (list type)))

(defun error-sequence-length (object type size)
  (declare (si::c-local))
  (error 'simple-type-error
         :format-control
         "Cannot create a sequence of size ~S which matches type ~S."
         :format-arguments (list size type)
         :expected-type type
         :datum object))

(defun closest-sequence-type (type)
  (let (elt-type length name args)
    (cond ((consp type)
           (setq name (first type) args (cdr type)))
          ((si::instancep type)
           (setf name (class-name (truly-the class type)) args nil))
          (t
           (setq name type args nil)))
    (case name
      ((LIST)
       ;; This is the only descriptor that does not match a real
       ;; array type.
       (setq elt-type 'LIST length '*))
      ((VECTOR)
       (setq elt-type (if (endp args) 'T (first args))
             length (if (endp (rest args)) '* (second args))))
      ((SIMPLE-VECTOR)
       (setq elt-type 'T
             length (if (endp args) '* (first args))))
      #-unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((BASE-STRING SIMPLE-BASE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'CHARACTER
             length (if (endp args) '* (first args))))
      ((BIT-VECTOR SIMPLE-BIT-VECTOR)
       (setq elt-type 'BIT
             length (if (endp args) '* (first args))))
      ((ARRAY SIMPLE-ARRAY)
       (let ((dimension-spec (second args)))
         (cond
           ((eql dimension-spec 1)
            (setf length '*))
           ((and (consp dimension-spec)
                 (null (cdr dimension-spec)))
            (setf length (car dimension-spec)))
           (T (error-sequence-type type))))
       (setq elt-type (upgraded-array-element-type (first args))))
      (t
       ;; We arrive here when the sequence type is not easy to parse.
       ;; We give up trying to guess the length of the sequence.
       ;; Furthermore, we also give up trying to find if the element
       ;; type is *. Instead we just compare with some specialized
       ;; types and otherwise fail.
       (dolist (i '((NIL . NIL)
                    (LIST . LIST)
                    (STRING . CHARACTER)
                    . #.(mapcar #'(lambda (i) `((VECTOR ,i) . ,i))
                         +upgraded-array-element-types+))
                (if (subtypep type 'vector)
                    ;; Does this have to be a type-error?
                    ;; 17.3 for MAKE-SEQUENCE says it should be an error,
                    ;; but does not specialize what kind.
                    (error "Cannot find the element type in vector type ~S" type)
                    (error-sequence-type type)))
          (when (subtypep type (car i))
            (setq elt-type (cdr i) length '*)
            ;; The (NIL . NIL) case above
            (unless elt-type
              (error-sequence-type type))
            (return)))))
    (values elt-type length)))

(defun make-sequence (type size &key (initial-element nil iesp) &aux sequence)
  "Args: (type length &key initial-element)
Creates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-
ELEMENT is given, then it becomes the elements of the created sequence.  The
default value of INITIAL-ELEMENT depends on TYPE."
  (multiple-value-bind (element-type length)
      (closest-sequence-type type)
    (cond ((eq element-type 'LIST)
           (setq sequence (make-list size :initial-element initial-element))
           (unless (subtypep 'LIST type)
             (when (or (and (subtypep type 'NULL) (plusp size))
                       (and (subtypep type 'CONS) (zerop size)))
               (error-sequence-length (make-list size :initial-element initial-element) type 0))))
          (t
           (setq sequence (sys:make-vector (if (eq element-type '*) T element-type)
                                           size nil nil nil nil))
           (when iesp
             (si::fill-array-with-elt sequence initial-element 0 nil))
           (unless (or (eql length '*) (eql length size))
             (error-sequence-length sequence type size))))
    sequence))

(defun make-seq-iterator (sequence &optional (start 0))
  (declare (optimize (safety 0)))
  (cond ((fixnump start)
         (let ((aux start))
           (declare (fixnum aux))
           (cond ((minusp aux)
                  (error-sequence-index sequence start))
                 ((listp sequence)
                  (nthcdr aux sequence))
                 ((vectorp sequence)
                  (and (< start (length (truly-the vector sequence)))
                       start))
                 (t
                  (error-not-a-sequence sequence)))))
        ((not (or (listp sequence) (vectorp sequence)))
         (error-not-a-sequence sequence))
        ((integerp start)
         nil)
        (t
         (error-sequence-index sequence start))))

(defun seq-iterator-ref (sequence iterator)
  (declare (optimize (safety 0)))
  (if (si::fixnump iterator)
      (aref (truly-the vector sequence) iterator)
      (car (truly-the cons iterator))))

(defun seq-iterator-set (sequence iterator value)
  (declare (optimize (safety 0)))
  (if (si::fixnump iterator)
      (setf (aref (truly-the vector sequence) iterator) value)
      (setf (car (truly-the cons iterator)) value)))

(defun seq-iterator-next (sequence iterator)
  (declare (optimize (safety 0)))
  (cond ((fixnump iterator)
         (let ((aux (1+ iterator)))
           (declare (fixnum aux))
           (and (< aux (length (truly-the vector sequence)))
                aux)))
        ((atom iterator)
         (error-not-a-sequence iterator))
        (t
         (setf iterator (cdr (truly-the cons iterator)))
         (unless (listp iterator)
           (error-not-a-sequence iterator))
         iterator)))

(defun seq-iterator-list-pop (values-list seq-list iterator-list)
  (declare (optimize (safety 0)))
  (do* ((it-list iterator-list)
        (v-list values-list))
       ((null v-list)
        values-list)
    (let* ((it (cons-car it-list))
           (sequence (cons-car seq-list)))
      (cond ((null it)
             (return nil))
            ((fixnump it)
             (let* ((n it) (s sequence))
               (declare (fixnum n) (vector s))
               (rplaca v-list (aref s n))
               (rplaca it-list (and (< (incf n) (length s)) n))))
            ((atom it)
             (error-not-a-sequence it))
            (t
             (rplaca v-list (cons-car it))
             (unless (listp (setf it (cons-cdr it)))
               (error-not-a-sequence it))
             (rplaca it-list it)))
      (setf v-list (cons-cdr v-list)
            it-list (cons-cdr it-list)
            seq-list (cons-cdr seq-list)))))

(defun coerce-to-list (object)
  (if (listp object)
      object
      (do ((it (make-seq-iterator object) (seq-iterator-next object it))
           (output nil))
          ((null it) (nreverse output))
        (push (seq-iterator-ref object it) output))))

(defun coerce-to-vector (object elt-type length simple-array-p)
  (let ((output object))
    (unless (and (vectorp object)
                 (or (null simple-array-p) (simple-array-p object))
                 (eq (array-element-type object) elt-type))
      (let* ((final-length (if (eq length '*) (length object) length)))
        (setf output (make-vector elt-type final-length nil nil nil 0))
        (do ((i (make-seq-iterator object) (seq-iterator-next output i))
             (j 0 (truly-the index (1+ j))))
            ((= j final-length)
             (setf object output))
          (declare (index j))
          (setf (aref output j) (seq-iterator-ref object i)))))
    output))

(defun concatenate (result-type &rest sequences)
  "Args: (type &rest sequences)
Returns a new sequence of the specified type, consisting of all elements of
SEQUENCEs."
  (do* ((length-list (mapcar #'length sequences) (rest length-list))
        (output (make-sequence result-type (apply #'+ length-list)))
        (sequences sequences (rest sequences))
        (i (make-seq-iterator output)))
      ((null sequences) output)
    (do* ((s (first sequences))
          (j (make-seq-iterator s) (seq-iterator-next s j)))
         ((null j))
      (seq-iterator-set output i (seq-iterator-ref s j))
      (setq i (seq-iterator-next output i)))))


(defun map (result-type function sequence &rest more-sequences)
  "Args: (type function sequence &rest more-sequences)
Creates and returns a sequence of TYPE with K elements, with the N-th element
being the value of applying FUNCTION to the N-th elements of the given
SEQUENCEs, where K is the minimum length of the given SEQUENCEs."
  (let* ((sequences (list* sequence more-sequences))
         (function (si::coerce-to-function function))
         output
         it)
    (when result-type
      (let ((l (length sequence)))
        (when more-sequences
          (setf l (reduce #'min more-sequences
                          :initial-value l
                          :key #'length)))
        (setf output (make-sequence result-type l)
              it (make-seq-iterator output))))
    (do-sequences (elt-list sequences :output output)
      (let ((value (apply function elt-list)))
        (when result-type
          (seq-iterator-set output it value)
          (setf it (seq-iterator-next output it)))))))

(defun some (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;
NIL otherwise."
  (reckless
   (do-sequences (elt-list (cons sequence more-sequences) :output nil)
     (let ((x (apply predicate elt-list)))
       (when x (return x))))))

(defun every (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise."
  (reckless
   (do-sequences (elt-list (cons sequence more-sequences) :output t)
     (unless (apply predicate elt-list)
       (return nil)))))

#|
(def-seq-bool-parser notany
  "Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise."
  (when that-value (return nil))
  t)

(def-seq-bool-parser notevery
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise."
  (unless that-value (return t))
  nil)
|#

(defun every* (predicate &rest sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences
have the same length; NIL otherwise."
  (and (apply #'= (mapcar #'length sequences))
       (apply #'every predicate sequences)))


(defun notany (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise."
  (not (apply #'some predicate sequence more-sequences)))


(defun notevery (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise."
  (not (apply #'every predicate sequence more-sequences)))

(defun map-into (result-sequence function &rest sequences)
"Fills the output sequence with the values returned by applying FUNCTION to the
elements of the given sequences. The i-th element of RESULT-SEQUENCE is the output
of applying FUNCTION to the i-th element of each of the sequences. The map routine
stops when it reaches the end of one of the given sequences."
  (let ((nel (apply #'min (if (vectorp result-sequence)
                              (array-dimension result-sequence 0)
                              (length result-sequence))
                    (mapcar #'length sequences))))
    (declare (fixnum nel))
    ;; Set the fill pointer to the number of iterations
    (when (and (vectorp result-sequence)
               (array-has-fill-pointer-p result-sequence))
      (setf (fill-pointer result-sequence) nel))
    ;; Perform mapping
    (do ((ir (make-seq-iterator result-sequence) (seq-iterator-next result-sequence ir))
         (it (mapcar #'make-seq-iterator sequences))
         (val (make-sequence 'list (length sequences))))
        ((null ir) result-sequence)
      (do ((i it (cdr i))
           (v val (cdr v))
           (s sequences (cdr s)))
          ((null i))
        (unless (car i) (return-from map-into result-sequence))
        (rplaca v (seq-iterator-ref (car s) (car i)))
        (rplaca i (seq-iterator-next (car s) (car i))))
      (seq-iterator-set result-sequence ir (apply function val)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/seq.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/seqmacros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2010, Juan Jose Garcia-Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;
;;;;  SEQMACROS -- Macros that are used to expand sequence routines
;;;;

(in-package "SYSTEM")

(defmacro with-count ((count &optional (value count) &key (output nil output-p))
                      &body body)
  (setf body `(locally ,@body))
  `(let ((,count (sequence-count ,value)))
     (declare (fixnum ,count))
     ,(if output-p
          `(if (plusp ,count)
               ,body
               ,output)
          body)))

(defmacro with-predicate ((predicate) &body body)
  `(let ((,predicate (si::coerce-to-function ,predicate)))
     (declare (function ,predicate))
     (macrolet ((,predicate (&rest args)
                  `(locally (declare (optimize (safety 0) (speed 3)))
                     (funcall ,',predicate ,@args))))
       ,@body)))

(defmacro with-key ((akey) &body body)
  `(let ((,akey (if ,akey (si::coerce-to-function ,akey) #'identity)))
     (declare (function ,akey))
     (macrolet ((,akey (value)
                  `(locally (declare (optimize (safety 0) (speed 3)))
                     (funcall ,',akey ,value))))
       ,@body)))

(defmacro with-tests (&whole whole (test test-not &optional key) &body body)
  (ext::with-unique-names (%test %test-not %test-fn)
    `(let* ((,%test ,test)
            (,%test-not ,test-not)
            (,%test-fn (if ,%test
                          (progn (when ,%test-not (test-error))
                                 (si::coerce-to-function ,%test))
                          (if ,%test-not
                              (si::coerce-to-function ,%test-not)
                              #'eql))))
       (declare (function ,%test-fn))
       (macrolet ((compare (v1 v2)
                    `(locally (declare (optimize (safety 0) (speed 3)))
                       (if ,',%test-not
                           (not (funcall ,',%test-fn ,v1 ,v2))
                           (funcall ,',%test-fn ,v1 ,v2)))))
         ,@(if key `((with-key (,key) ,@body)) body)))))

(defmacro with-start-end ((start end seq &optional (length (gensym) length-p))
                          &body body)
  `(multiple-value-bind (,start ,end ,length)
       (sequence-start-end 'subseq ,seq ,start ,end) 
     (declare (fixnum ,start ,end ,length)
              ,@(unless length-p `((ignorable ,length))))
     ,@body))

(defmacro reckless (&body body)
  `(locally (declare (optimize (safety 0) (speed 3) (debug 0))) ,@body))

(defmacro do-vector ((elt vector start end
                      &key from-end output setter (index (gensym)))
                     &body body)
  (with-unique-names (%vector %count)
    (when setter
      (setf body `((macrolet ((,setter (value)
                                `(reckless (si::aset ,',%vector
                                                     ,',index
                                                     ,value))))
                     ,@body))))
    (if from-end
        `(do* ((,%vector ,vector)
               (,index ,end)
               (,%count ,start))
              ((= ,index ,%count) ,output)
           (declare (fixnum ,index ,%count)
                    (vector ,%vector))
           (let ((,elt (reckless (aref ,%vector (setf ,index (1- ,index))))))
             ,@body))
        `(do* ((,%vector ,vector)
               (,index ,start (1+ ,index))
               (,%count ,end))
              ((= ,index ,%count) ,output)
           (declare (fixnum ,index ,%count)
                    (vector ,%vector))
           (let ((,elt (reckless (aref ,%vector ,index))))
             ,@body)))))

(defmacro do-sublist ((elt list start end &key output
                       setter (index (gensym)))
                      &body body)
  (with-unique-names (%sublist %count)
    (when setter
      (setf body `((macrolet ((,setter (value)
                                `(reckless (rplaca ,',%sublist ,value))))
                     ,@body))))
    `(do* ((,index ,start (1+ ,index))
           (,%sublist (nthcdr ,index ,list) (cdr ,%sublist))
           (,%count (- ,end ,index) (1- ,%count)))
          ((<= ,%count 0) ,output)
       (declare (fixnum ,index ,%count)
                (cons ,%sublist))
       (let ((,elt (car ,%sublist)))
         ,@body))))

(defmacro do-sequence ((elt sequence start end &rest args
                       &key setter index output specialize)
                       &body body)
  (if specialize
      (with-unique-names (%sequence)
        (setf args (copy-list args))
        (remf args :specialize)
        (setf args (list* elt %sequence start end args))
        `(let ((,%sequence ,sequence))
           (if (listp ,%sequence)
               (do-sublist ,args ,@body)
               (do-vector ,args ,@body))))
      (with-unique-names (%sequence %start %i %count)
        `(do* ((,%sequence ,sequence)
               (,index ,start (1+ ,index))
               (,%i (make-seq-iterator ,%sequence ,index)
                    (seq-iterator-next ,%sequence ,%i))
               (,%count (- ,end ,start) (1- ,%count)))
              ((or (null ,%i) (not (plusp ,%count))) ,output)
           (let ((,elt (seq-iterator-ref ,%sequence ,%i)))
             ,@body)))))

(defmacro do-sequences ((elt-list seq-list &key output) &body body)
  (with-unique-names (%iterators %sequences)
    `(do* ((,%sequences ,seq-list)
           (,%iterators (mapcar #'make-seq-iterator ,%sequences))
           (,elt-list (copy-list ,%sequences)))
          ((null (setf ,elt-list
                       (seq-iterator-list-pop ,elt-list
                                              ,%sequences
                                              ,%iterators)))
           ,@(and output (list output)))
       ,@body)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/seqmacros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/describe.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;                           DESCRIBE and INSPECT

(in-package "SYSTEM")

(defparameter *inspect-level* 0)
(defparameter *inspect-history* nil)
(defparameter *inspect-mode* nil)

(defparameter *old-print-level* nil)
(defparameter *old-print-length* nil)


;; Either the inspector reads and writes everything on *standard-output*,
;; or reads and writes everything on *query-io* but not a mix of each!
;; If this rule is not followed only severe confusion can result. JCB

(defun inspect-read-line ()
  (do ((char (read-char *query-io*) (read-char *query-io*)))
      ((or (char= char #\Newline) (char= char #\Return)))))

(defun select-P (object)
  (let* ((*print-pretty* t) (*print-level* nil) (*print-length* nil))
       (prin1 object)
       (terpri)))

(defun select-E ()
  (dolist (x (multiple-value-list
               (multiple-value-prog1
                 (eval (read-preserving-whitespace *query-io*))
                 (inspect-read-line))))
          (write x
                 :level *old-print-level*
                 :length *old-print-length*)
          (terpri)))

(defun select-U ()
  (prog1
    (eval (read-preserving-whitespace *query-io*))
    (inspect-read-line)))

(defun select-? ()
  (terpri)
  (format t
          "Inspect commands:~%~
                n (or N or Newline):    inspects the field (recursively).~%~
                s (or S):               skips the field.~%~
                p (or P):               pretty-prints the field.~%~
                a (or A):               aborts the inspection ~
                                        of the rest of the fields.~%~
                u (or U) form:          updates the field ~
                                        with the value of the form.~%~
                e (or E) form:          evaluates and prints the form.~%~
                q (or Q):               quits the inspection.~%~
                ?:                      prints this.~%~%"))

(defun read-inspect-command (label object allow-recursive)
  (unless *inspect-mode*
    ;; This is "describe" mode. So we stay non-interactive.
    (inspect-indent-1)
    (if allow-recursive
        (progn (princ label) (inspect-object object))
        (format t label object))
    (return-from read-inspect-command nil))
  (let* ((*quit-tags* (cons *quit-tag* *quit-tag*)) ;; as seen in top.lsp
         (*quit-tag* *quit-tags*))
    (declare (special *quit-tags* *quit-tags*))
    (loop
       (when
           (catch *quit-tag* ;; as seen in top.lsp
             (with-simple-restart (inspect "Go back to inspector.")
               (inspect-indent-1)
               (if allow-recursive
                   (progn (princ label)
                          (inspect-indent)
                          (prin1 object))
                   (format t label object))
               (write-char #\Space) ;; Inspector prompt!?
               (princ " >> ")       ;; This one is more suggestive.
               ;;(force-output) ;; not quite enough.
               (finish-output) ;; this one is stronger.
               (case (do ((char (read-char *query-io*) (read-char *query-io*)))
                         ((and (char/= char #\Space) (char/= char #\Tab)) 
                          (cond
                            ((char= char #\Newline) char)
                            ((char= char #\Return) char)
                            ((alphanumericp (peek-char)) #\!) ;; Invalid command on purpose.
                            (t char))
                          ))
                 ((#\Newline #\Return)
                  (when allow-recursive (inspect-object object))
                  (return nil))
                 ((#\n #\N)
                  (inspect-read-line)
                  (when allow-recursive (inspect-object object))
                  (return nil))
                 ((#\s #\S)
                  (inspect-read-line)
                  (return nil))
                 ((#\p #\P)
                  (inspect-read-line)
                  (select-P object))
                 ((#\a #\A)
                  (inspect-read-line)
                  (throw 'ABORT-INSPECT nil))
                 ((#\u #\U)
                  (return (values t (select-U))))
                 ((#\e #\E)
                  (select-E))
                 ((#\q #\Q)
                  (inspect-read-line)
                  (throw 'QUIT-INSPECT nil))
                 ((#\?)
                  (inspect-read-line)
                  (select-?))
                 (t
                  (inspect-read-line)
                  (inspect-indent)
                  (format t "Unknown inspector command. ~
                       Type ? followed by #\\Newline for help."))
                 )
               )
             nil
             )
         (format t "~&Back to Inspection mode: ~
                      Type ? followed by #\\Newline for help.~%")
         ))))

#+ecl-min
(defmacro inspect-recursively (label object &optional place)
  (if place
      `(multiple-value-bind (update-flag new-value)
            (read-inspect-command ,label ,object t)
         (when update-flag (setf ,place new-value)))
      `(when (read-inspect-command ,label ,object t)
             (princ "Not updated.")
             (terpri))))

#+ecl-min
(defmacro inspect-print (label object &optional place)
  (if place
      `(multiple-value-bind (update-flag new-value)
           (read-inspect-command ,label ,object nil)
         (when update-flag (setf ,place new-value)))
      `(when (read-inspect-command ,label ,object nil)
             (princ "Not updated.")
             (terpri))))

(defun inspect-indent ()
  (fresh-line)
  (format t "~V@T"
          (* 4 (if (< *inspect-level* 8) *inspect-level* 8))))

(defun inspect-indent-1 ()
  (fresh-line)
  (format t "~V@T"
          (- (* 4 (if (< *inspect-level* 8) *inspect-level* 8)) 3)))


(defun inspect-symbol (symbol)
  (declare (si::c-local))
  (let* ((p (symbol-package symbol)))
    (cond ((null p)
           (format t "~:@(~S~) - uninterned symbol" symbol))
          ((eq p (find-package "KEYWORD"))
           (format t "~:@(~S~) - keyword" symbol))
          (t
           (format t "~:@(~S~) - ~:[internal~;external~] symbol in ~A package"
                   symbol
                   (multiple-value-bind (b f)
                                        (find-symbol (symbol-name symbol) p)
                     (declare (ignore b))
                     (eq f :external))
                   (package-name p)))))

  (when (print-doc symbol t)
        (format t "~&-----------------------------------------------------------------------------~%~%"))
  
  (if (or (eq t symbol) (eq nil symbol) (keywordp symbol))
      (progn (inspect-indent-1) (format t "value: ~S" (symbol-value symbol)))
      (when (boundp symbol)
        (if *inspect-mode*
            (inspect-recursively "value:"
                                 (symbol-value symbol)
                                 (symbol-value symbol))
            (inspect-print "value:~%   ~S"
                           (symbol-value symbol)
                           (symbol-value symbol)))))

  (do ((pl (symbol-plist symbol) (cddr pl)))
      ((endp pl))
    (unless (and (symbolp (car pl))
                 (or (eq (symbol-package (car pl)) (find-package 'SYSTEM))
                     (eq (symbol-package (car pl)) (find-package 'COMPILER))))
      (if *inspect-mode*
          (inspect-recursively (format nil "property ~S:" (car pl))
                               (cadr pl)
                               (get symbol (car pl)))
          (inspect-print (format nil "property ~:@(~S~):~%   ~~S" (car pl))
                         (cadr pl)
                         (get symbol (car pl))))))

  )

(defun inspect-package (package)
  (declare (si::c-local))
  (format t "~S - package" package)
  (when (package-nicknames package)
        (inspect-print "nicknames:  ~S" (package-nicknames package)))
  (when (package-use-list package)
        (inspect-print "use list:  ~S" (package-use-list package)))
  (when  (package-used-by-list package)
         (inspect-print "used-by list:  ~S" (package-used-by-list package)))
  (when (package-shadowing-symbols package)
        (inspect-print "shadowing symbols:  ~S"
                       (package-shadowing-symbols package))))

(defun inspect-character (character)
  (declare (si::c-local))
  (format t
          (cond ((standard-char-p character) "~S - standard character")
                (t "~S - character"))
          character)
  (inspect-print "code:  #x~X" (char-code character)))

(defun inspect-number (number)
  (declare (si::c-local))
  (let ((type (type-of number)))
    (when (consp type) ;; Range types, as (INTEGER 0 0)
     (setf type (first type)))
    (format t "~S - ~a" number (string-downcase type))
    (case type
      (INTEGER)
      (RATIO
       (inspect-recursively "numerator:" (numerator number))
       (inspect-recursively "denominator:" (denominator number)))
      (COMPLEX
       (inspect-recursively "real part:" (realpart number))
       (inspect-recursively "imaginary part:" (imagpart number)))
      ((SHORT-FLOAT SINGLE-FLOAT LONG-FLOAT DOUBLE-FLOAT)
       (multiple-value-bind (signif expon sign)
           (integer-decode-float number)
         (declare (ignore sign))
         (inspect-print "exponent:  ~D" expon)
         (inspect-print "mantissa:  ~D" signif))))))

(defun inspect-cons (cons)
  (declare (si::c-local))
  (format t "~S - cons" cons)
  (when *inspect-mode*
        (do ((i 0 (1+ i))
             (l cons (cdr l)))
            ((atom l)
             (case l
               ((t nil) ;; no point in inspecting recursively t nor nil.
                (inspect-print (format nil "nthcdr ~D: ~~S" i) l))
               (t
                (inspect-recursively (format nil "nthcdr ~D:" i)
                                     l (cdr (nthcdr (1- i) cons))))))
          (inspect-recursively (format nil "nth ~D:" i)
                               (car l) (nth i cons)))))

(defun inspect-string (string)
  (declare (si::c-local))
  (format t (if (simple-string-p string) "~S - simple string" "~S - string")
          string)
  (inspect-print  "dimension:  ~D"(array-dimension string 0))
  (when (array-has-fill-pointer-p string)
        (inspect-print "fill pointer:  ~D"
                       (fill-pointer string)
                       (fill-pointer string)))
  (when *inspect-mode*
        (dotimes (i (array-dimension string 0))
                 (inspect-recursively (format nil "aref ~D:" i)
                                      (char string i)
                                      (char string i)))))

(defun inspect-vector (vector)
  (declare (si::c-local))
  (format t (if (simple-vector-p vector) "~S - simple vector" "~S - vector")
          vector)
  (inspect-print  "dimension:  ~D" (array-dimension vector 0))
  (when (array-has-fill-pointer-p vector)
        (inspect-print "fill pointer:  ~D"
                       (fill-pointer vector)
                       (fill-pointer vector)))
  (when *inspect-mode*
        (dotimes (i (array-dimension vector 0))
                 (inspect-recursively (format nil "aref ~D:" i)
                                      (aref vector i)
                                      (aref vector i)))))

(defun inspect-array (array)
  (declare (si::c-local))
  (format t (if (adjustable-array-p array)
                "~S - adjustable aray"
                "~S - array")
          array)
  (inspect-print "rank:  ~D" (array-rank array))
  (inspect-print "dimensions:  ~D" (array-dimensions array))
  (inspect-print "total size:  ~D" (array-total-size array)))

(defun select-ht-N (hashtable)
  (declare (si::c-local))
  (incf *inspect-level*)
  (maphash #'(lambda (key val)
               (inspect-indent-1)
               (format t "key  : ~S" key)
               (inspect-recursively "value:" val (gethash key hashtable)))
           hashtable)
  (decf *inspect-level*))

(defun select-ht-L (hashtable)
  (declare (si::c-local))
  (terpri)
  (format t "The keys of the hash table are:~%")
  (maphash #'(lambda (key val)
               (declare (ignore val))
               (format t "  ~S~%" key))
           hashtable)
  (terpri))

(defun select-ht-J (hashtable)
  (declare (si::c-local))
  (let* ((key (prog1
                (read-preserving-whitespace *query-io*)
                (inspect-read-line)))
         (val (gethash key hashtable)))
        (if val
            (progn
              (incf *inspect-level*)
              (inspect-indent-1)
              (format t "key  : ~S" key)
              (inspect-recursively "value:" val (gethash key hashtable))
              (decf *inspect-level*))
            (progn
              (terpri)
              (format t "The key ~S is not present or the value associated is NIL." key)
              (terpri)
              (terpri)))))

(defun select-ht-? ()
  (declare (si::c-local))
  (terpri)
  (format t
          "Inspect commands for hash tables:~%~
n (or N or #\\Newline):  inspects the keys/values of the hashtable (recursively).~%~
s (or S):             skips the field.~%~
p (or P):             pretty-prints the field.~%~
a (or A):             aborts the inspection of the rest of the fields.~%~
e (or E) form:        evaluates and prints the form.~%~
l (or L):             show the keys of the hash table.~%~
j (or J) key:         inspect the value associated to the key requested.~%~
q (or Q):             quits the inspection.~%~
?:                    prints this help message.~%~%"
          ))

(defun inspect-hashtable (hashtable)
  (declare (si::c-local))
  (if *inspect-mode*
      (progn
        (decf *inspect-level*)
        (loop
          (format t "~S - hash table: " hashtable)
          ;;(force-output) ;; not quite enough.
          (finish-output) ;; this one is stronger.
          (case (do ((char (read-char *query-io*) (read-char *query-io*)))
                    ((and (char/= char #\Space) (char/= #\Tab)) char))
                ((#\Newline #\Return)
                 (select-ht-N hashtable)
                 (return nil))
                ((#\n #\N)
                 (inspect-read-line)
                 (select-ht-N hashtable)
                 (return nil))
                ((#\s #\S)
                 (inspect-read-line)
                 (return nil))
                ((#\p #\P)
                 (inspect-read-line)
                 (select-P hashtable))
                ((#\a #\A)
                 (inspect-read-line)
                 (throw 'ABORT-INSPECT nil))
                ((#\e #\E)
                 (select-E))
                ((#\q #\Q)
                 (inspect-read-line)
                 (throw 'QUIT-INSPECT nil))
                ((#\l #\L)
                 (inspect-read-line)
                 (select-ht-L hashtable))
                ((#\j #\J)
                 (select-ht-J hashtable))
                ((#\?)
                 (inspect-read-line)
                 (select-ht-?)))
          (inspect-indent)))
      (progn
        (format t "~S - hash table: " hashtable)
        (maphash #'(lambda (key val)
                     (inspect-indent-1)
                     (format t "key  : ~S" key)
                     (inspect-indent-1)
                     (format t "value:")
                     (inspect-object val))
                 hashtable))))

#+CLOS
(defun inspect-instance (instance)
  (if *inspect-mode*
      (clos::inspect-obj instance)
      (clos::describe-object instance *standard-output*)))

(defun inspect-object (object &aux (*inspect-level* *inspect-level*))
  (inspect-indent)
  (when (and (not *inspect-mode*)
             (or (> *inspect-level* 5)
                 (member object *inspect-history*)))
        (prin1 object)
        (return-from inspect-object))
  (incf *inspect-level*)
  (push object *inspect-history*)
  (catch 'ABORT-INSPECT
         (cond
               ((symbolp object) (inspect-symbol object))
               ((packagep object) (inspect-package object))
               ((characterp object) (inspect-character object))
               ((numberp object) (inspect-number object))
               ((consp object) (inspect-cons object))
               ((stringp object) (inspect-string object))
               ((vectorp object) (inspect-vector object))
               ((arrayp object) (inspect-array object))
               ((hash-table-p object) (inspect-hashtable object))
               #+clos
               ((sys:instancep object) (inspect-instance object))
               (t (format t "~S - ~S" object (type-of object))))))

(defun default-inspector (object)
  "Args: (object)
Shows the information about OBJECT interactively.  See the ECL Report for the
inspect commands, or type '?' to the inspector."
  (declare (si::c-local))
  ;;(read-line)
  (let ((*inspect-mode* t)
        (*inspect-level* 0)
        (*inspect-history* nil)
        (*old-print-level* *print-level*)
        (*old-print-length* *print-length*)
        (*print-level* 3)
        (*print-length* 3))
    (terpri)
    (princ "Inspection mode: Type ? followed by #\\Newline for help.")
    (terpri)
    (terpri)
    (catch 'QUIT-INSPECT (inspect-object object))
    (terpri)
    (values)))

(defun inspect (object)
  (if ext:*inspector-hook*
      (funcall *inspector-hook* object)
      (default-inspector object))
  object)

(defun describe (object &optional (stream *standard-output*)
                        &aux (*inspect-mode* nil)
                             (*inspect-level* 0)
                             (*inspect-history* nil)
                             (*print-level* nil)
                             (*print-length* nil)
                             (*standard-output* (cond ((streamp stream) stream)
                                                      ((null stream) *standard-output*)
                                                      ((eq stream t) *terminal-io*)
                                                      (t (error 'type-error
                                                                :datum stream
                                                                :expected-type '(or stream t nil))))))
  "Args: (object &optional (stream *standard-output*))
Prints information about OBJECT to STREAM."
  (terpri)
  (catch 'QUIT-INSPECT (inspect-object object))
  (terpri)
  (values))

(defun print-doc (symbol &optional (called-from-apropos-doc-p nil)
                         &aux (f nil) x)
  (flet ((doc1 (doc ind)
           (setq f t)
           (format t
                   "~&-----------------------------------------------------------------------------~%~53S~24@A~%~A"
                   symbol ind doc))
         (good-package ()
           (if (eq (symbol-package symbol) (find-package "CL"))
               (find-package "SYSTEM")
               *package*)))

    (cond ((special-operator-p symbol)
           (doc1 (or (si::get-documentation symbol 'FUNCTION) "")
                 (if (macro-function symbol)
                     "[Special form and Macro]"
                     "[Special form]")))
          ((macro-function symbol)
           (doc1 (or (si::get-documentation symbol 'FUNCTION) "") "[Macro]"))
          ((fboundp symbol)
           (doc1 (or (si::get-documentation symbol 'FUNCTION) "") "[Function]"))
          ((setq x (si::get-documentation symbol 'FUNCTION))
           (doc1 x "[Macro or Function]")))

    (cond ((constantp symbol)
           (unless (and (eq (symbol-package symbol) (find-package "KEYWORD"))
                        (null (si::get-documentation symbol 'VARIABLE)))
             (doc1 (or (si::get-documentation symbol 'VARIABLE) "") "[Constant]")))
          ((sys:specialp symbol)
           (doc1 (or (si::get-documentation symbol 'VARIABLE) "")
                 "[Special variable]"))
          ((or (setq x (si::get-documentation symbol 'VARIABLE)) (boundp symbol))
           (doc1 (or x "") "[Variable]")))

    (cond ((setq x (si::get-documentation symbol 'TYPE))
           (doc1 x "[Type]"))
          ((setq x (get-sysprop symbol 'DEFTYPE-FORM))
           (let ((*package* (good-package)))
             (doc1 (format nil "~%Defined as: ~S~%See the doc of DEFTYPE." x)
                   "[Type]"))))

    (cond ((setq x (si::get-documentation symbol 'STRUCTURE))
           (doc1 x "[Structure]"))
          ((setq x (get-sysprop symbol 'DEFSTRUCT-FORM))
           (doc1 (format nil "~%Defined as: ~S~%See the doc of DEFSTRUCT." x)
                 "[Structure]")))

    (cond ((setq x (si::get-documentation symbol 'SETF))
           (doc1 x "[Setf]"))
          ((setq x (get-sysprop symbol 'SETF-METHOD))
           (let ((*package* (good-package)))
             (doc1
              (format nil
                "~@[~%Defined as: ~S~%See the doc of DEFINE-SETF-EXPANDER.~]"
                (if (consp x)
                    (case (car x)
                          (LAMBDA `(define-setf-expander ,@(cdr x)))
                          (EXT::LAMBDA-BLOCK `(define-setf-expander ,@(cddr x)))
                          (t nil))
                    nil))
            "[Setf]"))))
    )
  (if called-from-apropos-doc-p
      f
      (progn (if f
                 (format t "~&-----------------------------------------------------------------------------")
                 (format t "~&No documentation for ~:@(~S~)." symbol))
             (values))))

(defun help* (string &optional (package "CL"))
  "Args: (string &optional (package-spec 'lisp))
ECL specific.
Prints the documentation associated with those symbols in the specified
package whose print names contain STRING as substring.  STRING may be a
symbol, in which case the print-name of that symbol is used.  If PACKAGE is
NIL, then all packages are searched."
  (do* ((f nil)
        (l (apropos-list string package) (cdr l)))
      ((endp l)
       (format t (if f
                     "~&-----------------------------------------------------------------------------"
                     "~&No documentation for ~S in ~:[any~;~A~] package.")
               string package (and package (package-name (coerce-to-package package)))))
    (when (print-doc (first l) t)
      (setf f t)))
  (values))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/describe.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;








;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/ffi.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2001, Juan Jose Garcia-Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;; FFI        Symbols used in the foreign function interface

(in-package "FFI")

(import 'si:null-pointer-p)
(export 'si:null-pointer-p)

#-ecl-min
(clines "#include <string.h>")

(defmacro def-constant (name value &key (export nil))
  "Macro to define a constant and to export it"
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     (defconstant ,name ,value)
     ,(when export (list 'export `(quote ,name)))
    ',name))

;;;----------------------------------------------------------------------
;;; FOREIGN TYPES
;;;

(defparameter *ffi-types* (make-hash-table :size 128))

(defparameter *use-dffi* t)

(defmacro def-foreign-type (name definition)
  "Syntax: (def-foreign-type name definition)

Defines a new foreign type."
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     (setf (gethash ',name ffi::*ffi-types*) ',definition)))

(defmacro def-type (name definition)
  (declare (ignore definition))
  `(deftype ,name () t))

(defun %convert-to-ffi-type (type &optional context)
  (if (atom type)
    (if (member type context)
      type
      (multiple-value-bind (value present-p) (gethash type *ffi-types* type)
        (if present-p
          (%convert-to-ffi-type value (cons type context))
          value)))
    (cons (%convert-to-ffi-type (first type) context)
          (%convert-to-ffi-type (rest type) context))))

(defmacro %align-data (data align)
  `(setf ,data (* (ceiling (/ ,data ,align)) ,align)))

(defun size-of-foreign-type (name)
  "Syntax: (size-of-foreign-type ftype)

Returns the number of data bytes used by a foreign object type. This
does not include any Lisp storage overhead."
  (let* ((size 0) align
         (type (%convert-to-ffi-type name)))
    (unless type
      (error "Incomplete or unknown foreign type ~A" name))
    (cond ((symbolp type)
           (setf size (si:size-of-foreign-elt-type type)
                 align (si:alignment-of-foreign-elt-type type)))
          ((atom type)
           (error "~A is not a valid foreign type identifier" name))
          ((eq (setf name (first type)) :struct)
           (setf size (slot-position type nil)
                 align (apply #'max (mapcar #'(lambda (field)
                                                (multiple-value-bind (field-size field-align)
                                                    (size-of-foreign-type (second field))
                                                  (declare (ignore field-size))
                                                  field-align))
                                            (rest type))))
           (%align-data size align))
          ((eq name :array)
           (unless (and (setf size (third type)) (realp size))
             (error "Incomplete foreign type: ~S" type))
           (multiple-value-bind (elt-size elt-align)
             (size-of-foreign-type (second type))
             (setf size (* size elt-size)
                   align elt-align)))
          ((eq name :union)
           (dolist (field (rest type))
             (multiple-value-bind (field-size field-align)
               (size-of-foreign-type (second field))
               (when (> field-size size)
                 (setf size field-size))
               (when (or (null align) (> field-align align))
                 (setf align field-align)))))
          ((eq name '*)
           (setf size (si:size-of-foreign-elt-type :pointer-void)
                 align (si:alignment-of-foreign-elt-type :pointer-void)))
          ((eq name 'quote)
           (return-from size-of-foreign-type
             (size-of-foreign-type (second type))))
          (t
           (error "~A does not denote a foreign type" name)))
    (values size (or align 0))))

(defun allocate-foreign-object (type &optional (size 0 size-flag))
    "Syntax: (allocate-foreign-object type &optional (size 0)

Allocates an instance of a foreign object. It returns a pointer to the
object."
  (let ((type-size (size-of-foreign-type type)))
    (cond ((null size-flag)
           (si::allocate-foreign-data type type-size))
          ((and (typep size 'fixnum) (>= size 0))
           (let ((bytes (* size type-size)))
             (si::allocate-foreign-data `(:array ,type ,size) bytes)))
          (t
           (error "~A is not a valid array dimension size" size)))))

(defun free-foreign-object (ptr)
  "Syntax: (free-foreign-object ptr)

Frees memory that was allocated for a foreign object."
  (si::free-foreign-data ptr))

;;;----------------------------------------------------------------------
;;; ENUMERATION TYPES
;;;

(defmacro def-enum (name values-list &key (separator-string "#"))
  "Syntax: (def-enum name (&rest values-list) &key (separator-string \"#\")

Defines a C enumeration"
  (let ((constants '())
        (value -1)
        field
        forms)
    (setf #| name (string name) |#
          separator-string (string separator-string))
    (dolist (item values-list)
      (cond ((symbolp item)
             (setf field item)
             (incf value))
            ((and (consp item)
                  (symbolp (setf field (first item)))
                  (integerp (setf value (second item)))
                  (endp (cddr item))))
            (t
             (error "Not a valid argument to DEF-ENUM~%~a" values-list)))
      (setf field (concatenate 'string
                               (symbol-name name)
                               separator-string
                               (string field)))
      (push `(defconstant ,(intern field (symbol-package name))
               ',value)
            forms))
    `(progn
       (def-foreign-type ,name :int)
       ,@forms)))


;;;----------------------------------------------------------------------
;;; STRUCTURE TYPES
;;;
;;; The structure type is represented by the following list:
;;;
;;;     (STRUCT (SLOT-NAME1 . SLOT-TYPE1)*)
;;;
;;; FIXME! We do not care about slot alignment!
;;;

(defmacro def-struct (name &rest slots)
  "Syntax: (def-struct name (SLOT-NAME . SLOT-TYPE)*)

Defines a C structure. SLOT-TYPE is denoted by a FFI type."
  (let ((struct-type (list :struct))
        field
        type)
    (dolist (item (subst `(* ,name) :pointer-self slots))
      (if (and (consp item)
               (= (length item) 2)
               (symbolp (setf field (first item))))
        (setf type (second item))
        (error "Not a valid DEF-STRUCT slot ~A" item))
      (push (list field type) struct-type))
    `(def-foreign-type ,name ,(nreverse struct-type))))

(defun slot-position (type field)
  (setf type (%convert-to-ffi-type type))
  (let ((ndx 0)
        (is-union nil))
    (cond ((atom type)
           (error "~A is not a foreign STRUCT or UNION type" type))
          ((eq (first type) :struct))
          ((eq (first type) :union)
           (setf is-union t))
          (t
           (error "~A is not a foreign STRUCT or UNION type" type)))
    (dolist (slot (rest type))
      (let* ((slot-name (car slot))
             (slot-type (cadr slot)))
        (multiple-value-bind (slot-size slot-align)
          (size-of-foreign-type slot-type)
          (%align-data ndx slot-align)
          (when (eq slot-name field)
            (return-from slot-position (values ndx slot-type slot-size)))
          (unless is-union
            (incf ndx slot-size)))))
    (values ndx nil nil)))

(defun get-slot-value (object struct-type field)
  "Syntax: (get-slot-value object struct-type field)

Accesses a FIELD value from a OBJECT of type STRUCT-TYPE."
  (multiple-value-bind (slot-ndx slot-type slot-size)
      (slot-position struct-type field)
    (unless slot-size
      (error "~A is not a field of the type ~A" field struct-type))
    (%foreign-data-ref object slot-ndx slot-type slot-size)))

(defun (setf get-slot-value) (value object struct-type field)
  (multiple-value-bind (slot-ndx slot-type slot-size)
      (slot-position struct-type field)
    (unless slot-size
      (error "~A is not a field of the type ~A" field struct-type))
    (%foreign-data-set object slot-ndx slot-type value)))

(defun get-slot-pointer (object struct-type field)
  "Syntax: (get-slot-pointer object struct-type field)

Accesses a FIELD pointer value from a OBJECT of type STRUCT-TYPE."
  (multiple-value-bind (slot-ndx slot-type slot-size)
      (slot-position struct-type field)
    (unless slot-size
      (error "~A is not a field of the type ~A" field struct-type))
    (si::foreign-data-pointer object slot-ndx slot-size slot-type)))


;;;----------------------------------------------------------------------
;;; ARRAYS
;;;

(defmacro def-array-pointer (name element-type)
  `(def-foreign-type ,name (* ,element-type)))

(defun deref-array (array array-type position)
  "Syntax: (deref-array array type position)

Dereferences (retrieves) the value of the foreign ARRAY element on the
POSITION."
  (setf array-type (%convert-to-ffi-type array-type))
  (let* ((element-type (second array-type))
         (element-size (size-of-foreign-type element-type))
         (ndx (* position element-size))
         (length (or (third array-type) '*)))
    (unless (or (eq length '*)
                (> length position -1))
      (error "Out of bounds when accessing array ~A." array))
    (%foreign-data-ref (si::foreign-data-recast array (+ ndx element-size) array-type) ndx element-type element-size)))

(defun (setf deref-array) (value array array-type position)
  (setf array-type (%convert-to-ffi-type array-type))
  (let* ((element-type (second array-type))
         (element-size (size-of-foreign-type element-type))
         (ndx (* position element-size))
         (length (or (third array-type) '*)))
    (unless (or (eq length '*)
                (> length position -1))
      (error "Out of bounds when accessing array ~A." array))
    (%foreign-data-set (si::foreign-data-recast array (+ ndx element-size) array-type) ndx element-type value)))

(defun %foreign-data-set (obj ndx type value)
  (cond ((foreign-elt-type-p type)
         (si::foreign-data-set-elt obj ndx type value))
        ((atom type)
         (error "Unknown foreign primitive type: ~A" type))
        ((eq (first type) '*)
         (si::foreign-data-set-elt obj ndx :pointer-void value))
        (t
         (si::foreign-data-set obj ndx value))))

(defun %foreign-data-ref (obj ndx type &optional (size 0 size-p))
  (cond ((foreign-elt-type-p type)
         (si::foreign-data-ref-elt obj ndx type))
        ((atom type)
         (error "Unknown foreign primitive type: ~A" type))
        ((eq (first type) '*)
         (si::foreign-data-recast (si::foreign-data-ref-elt obj ndx :pointer-void)
                                  (size-of-foreign-type (second type))
                                  type))
        (t
         (si::foreign-data-ref obj ndx (if size-p size (size-of-foreign-type type)) type))))

;;;----------------------------------------------------------------------
;;; UNIONS
;;;

(defmacro def-union (name &rest slots)
  "Syntax: (def-union name (field-name field-type)*)

Defines a foreign union type."
  (let ((struct-type (list :union))
        field
        type)
    (dolist (item (subst `(* ,struct-type) :pointer-self slots))
      (unless (and (consp item)
                   (= (length item) 2)
                   (symbolp (setf field (first item))))
        (error "Not a valid DEF-UNION slot ~A" item))
      (setf type (second item))
      (push (list field type) struct-type))
    `(def-foreign-type ,name ,(nreverse struct-type))))

;;;----------------------------------------------------------------------
;;; POINTERS
;;;

(defparameter +null-cstring-pointer+ (si:allocate-foreign-data :pointer-void 0))

(defun pointer-address (ptr)
  "Syntax: (pointer-address ptr)

Returns the address as an integer of a pointer."
  (si::foreign-data-address ptr))

(defun deref-pointer (ptr ftype)
  "Syntax: (deref-pointer ptr ftype)

Returns the object to which a pointer points."
  ;; FIXME! No checking!
  (setf ftype (%convert-to-ffi-type ftype))
  (cond ((foreign-elt-type-p ftype)
         (si::foreign-data-ref-elt ptr 0 ftype))
        ((atom ftype)
         (error "Unknown foreign primitive type: ~A" ftype))
        ((eq (first ftype) '*)
         (si::foreign-data-recast (si::foreign-data-ref-elt ptr 0 :pointer-void)
                                  (size-of-foreign-type (second ftype))
                                  (second ftype)))
        (t
         (error "Cannot dereference pointer to foreign data, ~A" ptr))
  ))

(defun (setf deref-pointer) (value ptr type)
  ;; FIXME! No checking!
  (setf type (%convert-to-ffi-type type))
  (if (foreign-elt-type-p type)
      (si::foreign-data-set-elt ptr 0 type value)
      (si::foreign-data-set ptr 0 value)))

(defun make-null-pointer (ftype)
  "Syntax; (make-null-pointer ftype)

Creates a NULL pointer of a specified type."
  ;(setf ftype (%convert-to-ffi-type ftype))
  (si::allocate-foreign-data ftype 0))

(defun make-pointer (addr type)
  (c-inline (type (size-of-foreign-type type) addr) (:object :unsigned-long :unsigned-long) :object
            "ecl_make_foreign_data(#0, #1, (void*)#2)"
            :side-effects t
            :one-liner t))

#+(OR) ;; Already defined in core
(defun null-pointer-p (object)
  (si::null-pointer-p object))


;;;----------------------------------------------------------------------
;;; CHARACTERS AND STRINGS
;;;
;;; ECL always returns characters when dereferencing (:array * :char)
;;;

(defun null-char-p (char)
  "Syntax: (null-char-p char)

Tests a character for NULL value."
  (eq char #.(code-char 0)))

(defun ensure-char-character (char)
  "Syntax: (ensure-char-character object)

Ensures that a dereferenced char or integer is a lisp character."
  (cond ((characterp char) char)
        ((integerp char) (code-char char))
        (t (error "~a cannot be coerced to type CHARACTER" char))))

(defun ensure-char-integer (char)
    "Syntax: (ensure-char-integer object)

Ensures that a dereferenced char or integer is a lisp integer."
  (cond ((characterp char) (char-code char))
        ((integerp char) char)
        (t (error "~a cannot be coerced to type INTEGER" char))))

(defun ensure-char-storable (char)
  char)

(defun char-array-to-pointer (obj)
  (si::foreign-data-pointer obj 0 1 '(* :unsigned-char)))

(defmacro convert-from-cstring (object)
  "Syntax: (convert-from-cstring object)

Converts a Lisp string to a cstring. This is most often used when
processing the results of a foreign function that returns a cstring."
  object)

(defmacro convert-to-cstring (object)
  "Syntax: (convert-to-cstring object)

Converts cstring OBJECT to a Lisp string. Allocates memory."
  ;; This enforces that the string contains only as many characters as the
  ;; fill-pointer determines Since ECL always sets a 0 character after the
  ;; last element of a string, this way, the string is always zero-terminated
  `(si:copy-to-simple-base-string ,object))

(defmacro free-cstring (cstring)
  "Syntax: (free-cstring cstring)

Free memory used by CSTRING."
  cstring)

(defmacro with-cstring ((cstring string) &body body)
  "Syntax: (with-cstring (cstring string) &body body)

Binds CSTRING to a cstring created from conversion of a STRING and
evaluated the BODY. Automatically frees the CSTRING."
  `(let ((,cstring (convert-to-cstring ,string))) ,@body))

(defmacro with-cstrings (bindings &rest body)
  "Syntax: (with-cstrings ((cstring string)*) &body body)

See: WITH-CSTRING. Works similar to LET*."
  (if bindings
    `(with-cstring ,(car bindings)
      (with-cstrings ,(cdr bindings)
        ,@body))
    `(progn ,@body)))

(defun foreign-string-length (foreign-string)
  (c-inline (foreign-string) (t) :int
            "strlen((#0)->foreign.data)"
            :side-effects nil
            :one-liner t))

(defun convert-from-foreign-string (foreign-string
                                    &key length (null-terminated-p t))
  "Syntax: (convert-from-foreign-string
         foreign-string &key length (null-terminated-p t)

Returns a Lisp string from a foreign string FOREIGN-STRING. Can
translated ASCII and binary strings."
  (cond ((and (not length) null-terminated-p)
         (setf length (foreign-string-length foreign-string)))
        ((not (integerp length))
         (error "~A is not a valid string length" length)))
  (c-inline (foreign-string length) (t fixnum) string
       "{
        cl_index length = #1;
        cl_object output = ecl_alloc_simple_base_string(length);
        memcpy(output->base_string.self, (#0)->foreign.data, length);
        @(return) = output;
        }"
       :one-liner nil
       :side-effects t))

(defun convert-to-foreign-string (string-designator)
  "Syntax: (convert-to-foreign-string string-designator)

Converts a Lisp string to a foreign string. Memory should be freed
with free-foreign-object."
  (let ((lisp-string (string string-designator)))
    (c-inline (lisp-string) (t) t
       "{
        cl_object lisp_string = #0;
        cl_index size = lisp_string->base_string.fillp;
        cl_object output = ecl_allocate_foreign_data(@(* :char), size+1);
        memcpy(output->foreign.data, lisp_string->base_string.self, size);
        output->foreign.data[size] = '\\0';
        @(return) = output;
        }"
        :one-liner nil
        :side-effects t)
    ))

(defun allocate-foreign-string (size &key (unsigned T))
  "Syntax: (allocate-foreign-string size &key (unsigned t))

Allocates space for a foreign string. Memory should be freed with
FREE-FOREIGN-OBJECT. Initial contents of the string are undefined."
  (si::allocate-foreign-data `(* ,(if unsigned :unsigned-char :char))
                             (1+ size)))

(defmacro with-foreign-string ((foreign-string lisp-string) &rest body)
  "Syntax: (with-foreign-string ((foreign-string lisp-string) &rest body)

Binds FOREIGN-STRING to a foreign string created from conversion of a
STRING and evaluated the BODY. Automatically frees the FOREIGN-STRING."
  (let ((result (gensym)))
    `(let* ((,foreign-string (convert-to-foreign-string ,lisp-string))
            (,result (progn ,@body)))
       (free-foreign-object ,foreign-string)
       ,result)))

(defmacro with-foreign-strings (bindings &rest body)
  "Syntax: (with-foreign-strings ((foreign-string string)*) &body body)

See: WITH-FOREIGN-STRING. Works similar to LET*."
  (if bindings
    `(with-foreign-string ,(car bindings)
      (with-foreign-strings ,(cdr bindings)
        ,@body))
    `(progn ,@body)))

;;;----------------------------------------------------------------------
;;; MACROLOGY
;;;

(defmacro with-foreign-object ((var type) &body body)
  "Syntax: (with-foreign-object (var type) &body body)

Wraps the allocation, binding and destruction of a foreign object
around a body of code"
  `(let ((,var (allocate-foreign-object ,type)))
     (unwind-protect
         (progn ,@body)
       (free-foreign-object ,var))))

(defmacro with-foreign-objects (bindings &rest body)
  (if bindings
    `(with-foreign-object ,(car bindings)
      (with-foreign-objects ,(cdr bindings)
        ,@body))
    `(progn ,@body)))

(defmacro with-cast-pointer (bind &body body)
  "Syntax: (with-cast-pointer (var ptr ftype) &body body)

Executes BODY with PTR cast to be a pointer to type FTYPE. VAR will be
bound to this value during the execution of body."
  (let (binding-name ptr type)
    (case (length bind)
      (2 (setf binding-name (first bind)
               ptr binding-name
               type (second bind)))
      (3 (setf binding-name (first bind)
               ptr (second bind)
               type (third bind)))
      (otherwise (error "Arguments missing in WITH-CAST-POINTER")))
    `(let ((,binding-name (si::foreign-data-pointer (si::foreign-data-recast ,ptr (size-of-foreign-type ',type) :void) 0
                                                    (size-of-foreign-type ',type)
                                                    ',type)))
       ,@body)))

;;;----------------------------------------------------------------------
;;; INTERFACE TO C FUNCTIONS AND VARIABLES
;;;

(defun lisp-to-c-name (name)
  (cond ((or (stringp name)
             (symbolp name))
         (values name (intern (string-upcase (substitute #\- #\_ (string name))))))
        ((and (consp name)
              (= (length name) 2))
         (values (first name) (second name)))))

(defun %convert-to-arg-type (type)
  (let ((type (%convert-to-ffi-type type)))
    (cond ((atom type) type)
          ((eq (first type) '*) :pointer-void)
          ((eq (first type) :array) :pointer-void)
          (t (error "Unsupported argument type: ~A" type))
    )))

(defun %convert-to-return-type (type)
  (let ((type (%convert-to-ffi-type type)))
    (cond ((atom type) type)
          ((eq (first type) '*) (second type))
          (t type))))

(defun produce-function-call (c-name nargs)
  (declare (si::c-local))
  (format nil "~a(~a)" c-name
          (subseq "#0,#1,#2,#3,#4,#5,#6,#7,#8,#9,#a,#b,#c,#d,#e,#f,#g,#h,#i,#j,#k,#l,#m,#n,#o,#p,#q,#r,#s,#t,#u,#v,#w,#x,#y,#z"
                  0 (max 0 (1- (* nargs 3))))))

;;; FIXME! We should turn this into a closure generator that produces no code.
#+DFFI
(defmacro def-lib-function (name args &key returning module (call :default))
  (multiple-value-bind (c-name lisp-name) (lisp-to-c-name name)
    (let* ((return-type (ffi::%convert-to-return-type returning))
           (return-required (not (eq return-type :void)))
           (argtypes (mapcar #'(lambda (a) (ffi::%convert-to-arg-type (second a))) args)))
      `(let ((c-fun (si::find-foreign-symbol ',c-name ,module :pointer-void 0)))
        (defun ,lisp-name ,(mapcar #'first args)
          (si::call-cfun c-fun ',return-type ',argtypes (list ,@(mapcar #'first args)) ,call))))))

(defmacro def-function (name args &key module (returning :void) (call :default))
  "Syntax: (def-function name args
                         &key module (returning :void) (call :default)

Declares a foreign function."
  (declare (ignorable call))
  #+DFFI 
  (when (and module *use-dffi*)
    (return-from def-function
      `(def-lib-function ,name ,args :returning ,returning :module ,module :call ,call)))
  (multiple-value-bind (c-name lisp-name)
      (lisp-to-c-name name)
    (let* ((arguments (mapcar #'first args))
           (arg-types (mapcar #'(lambda (type) (%convert-to-arg-type (second type))) args))
           (return-type (%convert-to-return-type returning))
           (nargs (length arguments))
           (c-string (produce-function-call c-name nargs))
           (casting-required (not (or (member return-type '(:void :cstring))
                                      (foreign-elt-type-p return-type))))
           (inline-form `(c-inline ,arguments ,arg-types
                                   ,(if casting-required :pointer-void return-type)
                                   ,c-string
                                   :one-liner t
                                   :side-effects t)))
      (when casting-required
        (setf inline-form
              `(si::foreign-data-recast ,inline-form
                                        (size-of-foreign-type ',return-type)
                                        ',return-type)))
      (when (> nargs 36)
        (error "FFI can only handle C functions with up to 36 arguments"))
      `(defun ,lisp-name (,@arguments)
         ,inline-form)
      )))

(defmacro def-foreign-var (name type module)
  "Syntax: (def-foreign-var name type module)

Defines a symbol macro which can be used to access (get and set) the
value of a variable in foreign code."
  (declare (ignorable module))
  (multiple-value-bind (c-name lisp-name)
      (lisp-to-c-name name)
    (let* ((ffi-type (%convert-to-ffi-type type))
           (can-deref (or (foreign-elt-type-p ffi-type)
                          (and (consp ffi-type)
                               (member (first ffi-type) '(* :array)))))
           (inline-form (cond #+dffi
                              ((and module *use-dffi*)
                               `(si::find-foreign-symbol ,c-name ,module ',type ,(size-of-foreign-type type)))
                              (t
                               `(c-inline () () :object
                                          ,(format nil "ecl_make_foreign_data(@~S, ~A, &~A)"
                                                   type (size-of-foreign-type type) c-name)
                                          :side-effects t :one-liner t)))))
      (if can-deref
          `(progn
             (put-sysprop ',lisp-name 'ffi-foreign-var ,inline-form)
             (eval-when (:compile-toplevel :load-toplevel :execute)
               (define-symbol-macro ,lisp-name
                 (ffi:deref-pointer (get-sysprop ',lisp-name 'ffi-foreign-var) ',type)
                 )))
          `(defparameter ,lisp-name ,inline-form))
      )))

(defun find-foreign-library (names directories &key drive-letters types)
  "Syntax: (find-foreign-library names directories &key drive-letters type)

Finds a foreign library by searching through a number of possible
locations. Returns the path of the first found file."
  (unless (listp names)
    (setq names (list names)))
  (unless (listp directories)
    (setq directories (list directories)))
  (unless types
    (setq types #+win32 '("lib")
                #-win32 '("so" "a")))
  (unless (listp types)
    (setq types (list types)))
  (unless (listp drive-letters)
    (setq drive-letters (list drive-letters)))
  #-msvc
  (setq drive-letters '(nil))
  #+msvc
  (unless drive-letters
    (setq drive-letters '(nil)))
  (dolist (d drive-letters)
    (dolist (p directories)
      (dolist (n names)
        (dolist (e types)
          (let ((full-path (probe-file (make-pathname
                                          :device d
                                          :directory (etypecase p
                                                       (pathname (pathname-directory p))
                                                       (string (pathname-directory (parse-namestring p)))
                                                       (list p))
                                          :name n
                                          :type e))))
            (when full-path
              (return-from find-foreign-library full-path))
          )))))
  nil)

(defparameter +loaded-libraries+ nil)

(defun do-load-foreign-library (tmp &optional system-library)
  (let* ((path (cond ((pathnamep tmp) tmp)
                     ((probe-file (setf tmp (string tmp))) tmp)
                     (t (compile-file-pathname tmp :type #+msvc :lib #-msvc :dll))))
         (filename (namestring path))
         (pack (find-package "COMPILER"))
         (flag (if system-library
                   (concatenate 'string "-l" tmp)
                   filename)))
    (unless (find filename ffi::+loaded-libraries+ :test #'string-equal)
      (setf (symbol-value (intern "*LD-FLAGS*" pack))
            (concatenate 'string (symbol-value (intern "*LD-FLAGS*" pack)) " " flag))
      (setf (symbol-value (intern "*LD-BUNDLE-FLAGS*" pack))
            (concatenate 'string (symbol-value (intern "*LD-BUNDLE-FLAGS*" pack))
                         " " flag))
      (setf (symbol-value (intern "*LD-SHARED-FLAGS*" pack))
            (concatenate 'string (symbol-value (intern "*LD-SHARED-FLAGS*" pack))
                         " " flag))
      (push filename ffi::+loaded-libraries+))
    t))

(defmacro load-foreign-library (filename &key module supporting-libraries force-load
                                           system-library &environment env)
  "Syntax: (load-foreign-library filename
              &key module supporting-libraries force-load system-library)

Loads a foreign library."
  (declare (ignore module force-load supporting-libraries))
  (let ((compile-form (and (constantp filename env)
                           `((eval-when (:compile-toplevel)
                               (do-load-foreign-library ,filename
                                 ,(ext:constant-form-value system-library))))))
        (dyn-form #+dffi (when (and (not system-library) *use-dffi*)
                           `((si:load-foreign-module ,filename)))
                  #-dffi nil))
    `(progn ,@compile-form ,@dyn-form)))

;;;----------------------------------------------------------------------
;;; CALLBACKS
;;;

#-dffi
(defmacro defcallback (&rest args)
  (error "DEFCALLBACK cannot be used in interpreted forms"))

#+dffi
(defmacro defcallback (name ret-type arg-desc &body body)
  (if *use-dffi*
      (multiple-value-bind (name call-type) (if (consp name)
                                                (values-list name)
                                                (values name :default))
        (let ((arg-types (mapcar #'second arg-desc))
              (arg-names (mapcar #'first arg-desc)))
          `(si::make-dynamic-callback
            #'(ext::lambda-block ,name ,arg-names ,@body)
            ',name ',ret-type ',arg-types ,call-type)))
      (error "DEFCALLBACK cannot be used in interpreted forms when DFFI is disabled.")))

(defun callback (name)
  (let ((x (si::get-sysprop name :callback)))
    (unless x
      (error "There is no callback with name ~a" name))
    x))

;;;----------------------------------------------------------------------
;;; COMPATIBILITY WITH OLDER FFI
;;;

(defun clines (&rest c/c++-code)
  "Syntax: (clines &rest c/c++-code)

CLINES is used to inline C/C++ declarations (strings) at the beginning
of the produced C/C++ header file. Works only in the compiled code and
is required to be a toplevel form."
  (error "The special form clines cannot be used in the interpreter: ~A"
         c/c++-code))

(eval-when (:load-toplevel :execute)
  (defmacro c-inline (lisp-values arg-c-types return-type c/c++-code
                      &key (side-effects t) one-liner)
    `(error "The special form c-inline cannot be used in the interpreter: ~S"
            (list (list ,@lisp-values) ',arg-c-types ',return-type
                  ,c/c++-code
                  :side-effects ,side-effects
                  :one-liner ,one-liner)))
  (defmacro c-progn (args &rest body)
    (declare (ignore args))
    '(error "The special form c-progn cannot be used in the interpreter.")))

(defmacro definline (fun arg-types type code)
"Syntax: (definline symbol (&rest arg-types) result-type &body body) " "

DEFINLINE behaves like a DEFCBODY (see), but also instructs the LISP compiler
to expand inline any call to function SYMBOL into code corresponding
to the C language expression BODY, whenever it can determine that
the actual arguments are of the specified type."
  `(eval-when (:compile-toplevel :load-toplevel :execute)
              ;; defCbody must go first, because it clears symbol-plist of fun
              (defCbody ,fun ,arg-types ,type ,code)
              (declaim (ftype (function ,arg-types ,type) ,fun))
              (c::def-inline ,fun :always ,arg-types ,type ,code)))

(defmacro defla (name args &body body)
  "Syntax: (defla name args &body body)

Used to DEFine Lisp Alternative.  For the interpreter, DEFLA is equivalent to
DEFUN, but the compiler ignores this form."
  `(eval-when (:execute)
     (defun ,name ,args ,@body)))

(defmacro defcbody (name arg-types result-type c-expression)
  "Syntax: (defcbody name arg-types result-type c-expression)

The compiler defines a Lisp function named by NAME whose body consists
of the C code of the string C-EXPRESSION. In the C-EXPRESSION one can
reference the arguments of the function as \"#0\", \"#1\", etc.

The interpreter ignores this form.  ARG-TYPES are argument types of
the defined Lisp function and RESULT-TYPE is its return type."
  (let ((args (mapcar #'(lambda (x) (gensym)) arg-types)))
  `(defun ,name ,args
     (c-inline ,args ,arg-types ,result-type
               ,c-expression :one-liner t))))

(defmacro defentry (name arg-types c-name &key no-interrupts)
  "Syntax: (defentry name arg-types (result-type function-name)
                  &key no-interrupts)

The compiler defines a Lisp function named by NAME whose body consists
of a calling sequence to the C language function named by
FUNCTION-NAME.

The interpreter ignores this form.  ARG-TYPES are argument types of
the C function and RESULT-TYPE is its return type. Symbols OBJECT,
INT, CHAR, CHAR*, FLOAT, DOUBLE are allowed for these types."
  (let ((output-type :object)
        (args (mapcar #'(lambda (x) (gensym)) arg-types)))
    (if (consp c-name)
        (setf output-type (first c-name)
              c-name (second c-name)))
    (let* ((call (produce-function-call (string c-name) (length arg-types)))
           (full-text (if no-interrupts
                          (concatenate 'string
                                       "ecl_disable_interrupts();@(return)="
                                       call
                                       ";ecl_enable_interrupts();")
                          call)))
      `(defun ,name ,args
         (c-inline ,args ,arg-types ,output-type
                   ,full-text
                   :one-liner ,(not no-interrupts))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/ffi.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/mislib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "SYSTEM")

(defun   logical-pathname-translations (p)
  (or (si:pathname-translations p)
      (error 'simple-type-error
             :datum p
             :expected-type 'logical-pathname
             :format-control "logical host not yet defined: ~S"
             :format-arguments (list p))))

(defsetf logical-pathname-translations si:pathname-translations)

(defun load-logical-pathname-translations (host)
  "Search for a logical pathname named host, if not already defined. If already
defined no attempt to find or load a definition is attempted and NIL is
returned. If host is not already defined, but definition is found and loaded
successfully, T is returned, else error."
  (declare (type string host)
           (ext:check-arguments-type))
  (let ((*autoload-translations* nil))
    (unless (or (string-equal host "sys")
                (si::pathname-translations host))
      (with-open-file (in-str (make-pathname :defaults "sys:"
                                             :name (string-downcase host)
                                             :type "translations"))
        (if *load-verbose*
            (format *error-output*
                    ";; Loading pathname translations from ~A~%"
                    (namestring (truename in-str))))
        (setf (logical-pathname-translations host) (read in-str)))
      t)))

(defparameter *do-time-level* -1)

(defun do-time (closure)
  #-boehm-gc
  (let* ((real-start (get-internal-real-time))
         (run-start (get-internal-run-time))
         gc-start
         bytes-consed
         real-end
         run-end
         gc-end)
    ;; Garbage collection forces counters to be updated
    (si::gc t)
    (setf gc-start (si::gc-time))
    (multiple-value-prog1
        (funcall closure)
      (setq run-end (get-internal-run-time)
            real-end (get-internal-real-time)
            gc-end (si::gc-time))
      (format *trace-output*
             "real time : ~,3F secs~%~
              run time  : ~,3F secs~%~
              GC time   : ~,3F secs~%"
             (/ (- real-end real-start) internal-time-units-per-second)
             (/ (- run-end run-start) internal-time-units-per-second)
             (/ (- gc-end gc-start) internal-time-units-per-second))))
  #+boehm-gc
  (let* ((*do-time-level* (1+ *do-time-level*))
         real-start
         run-start
         consed-start
         gc-no-start
         real-end
         run-end
         consed-end
         gc-no-end)
    ;; Garbage collection forces the value of counters to be updated
    (si::gc t)
    ;; If there are no nested calls, we just reset the counters
    (when (zerop *do-time-level*) (si::gc-stats 0))
    ;; but in general we copy the previous values.
    (multiple-value-setq (consed-start gc-no-start) (gc-stats t))
    (setq real-start (get-internal-real-time)
          run-start (get-internal-run-time))
    (multiple-value-prog1
        (funcall closure)
      (setq run-end (get-internal-run-time)
            real-end (get-internal-real-time))
      ;; Garbage collection forces the value of counters to be updated
      (si::gc t)
      (multiple-value-setq (consed-end gc-no-end) (gc-stats nil))
      (fresh-line *trace-output*)
      (format *trace-output*
             "real time : ~,3F secs~%~
              run time  : ~,3F secs~%~
              gc count  : ~D times~%~
              consed    : ~D bytes~%"
             (/ (- real-end real-start) internal-time-units-per-second)
             (/ (- run-end run-start) internal-time-units-per-second)
             (- gc-no-end gc-no-start)
             (- consed-end consed-start)))))

(defmacro time (form)
  "Syntax: (time form)
Evaluates FORM, outputs the realtime and runtime used for the evaluation to
*TRACE-OUTPUT*, and then returns all values of FORM."
  `(do-time #'(lambda () ,form)))

(defun leap-year-p (y)
  (declare (si::c-local))
  (and (zerop (mod y 4))
       (or (not (zerop (mod y 100))) (zerop (mod y 400)))))

(defun number-of-days-from-1900 (y)
  (declare (si::c-local))
  (let ((y1 (1- y)))
    (+ (* (- y 1900) 365)
       (floor y1 4) (- (floor y1 100)) (floor y1 400)
       -460)))

(defconstant month-startdays #(0 31 59 90 120 151 181 212 243 273 304 334 365))

#-ecl-min
(ffi:clines "
#include <time.h>
")

#-ecl-min
(defun get-local-time-zone ()
  "Returns the number of hours West of Greenwich for the local time zone."
  (declare (si::c-local))
  (ffi::c-inline () () :object "
{
  cl_fixnum mw;
#if 0 && defined(HAVE_TZSET)
  tzset();
  mw = timezone/60;
#else
  struct tm ltm, gtm;
  time_t when = time(0) /*0L*/;

  ltm = *localtime(&when);
  gtm = *gmtime(&when);

  mw = (gtm.tm_min + 60 * gtm.tm_hour) - (ltm.tm_min + 60 * ltm.tm_hour);

  if ((gtm.tm_wday + 1) % 7 == ltm.tm_wday)
    mw -= 24*60;
  else if (gtm.tm_wday == (ltm.tm_wday + 1) % 7)
    mw += 24*60;
#endif
  @(return) = ecl_make_ratio(ecl_make_fixnum(mw),ecl_make_fixnum(60));
}"
                 :one-liner nil))

(defun recode-universal-time (sec min hour day month year tz dst)
  (declare (si::c-local))
  (let ((days (+ (if (and (leap-year-p year) (> month 2)) 1 0)
                 (1- day)
                 (svref month-startdays (1- month))
                 (number-of-days-from-1900 year))))
    (+ sec (* 60 (+ min (* 60 (+ tz dst hour (* 24 days))))))))

(defun decode-universal-time (orig-ut &optional (tz nil tz-p) &aux (dstp nil))
  "Args: (integer &optional (timezone (si::get-local-time-zone)))
Returns as nine values the day-and-time represented by INTEGER.  See GET-
DECODED-TIME."
(loop
  (let* ((ut orig-ut) sec min hour day month year dow days)
    (unless tz
      (setq tz (get-local-time-zone)))
    (decf ut (round (* (+ tz (if dstp -1 0)) 3600)))
    (multiple-value-setq (ut sec) (floor ut 60))
    (multiple-value-setq (ut min) (floor ut 60))
    (multiple-value-setq (days hour) (floor ut 24))
    (setq dow (mod days 7))
    (setq year (+ 1900 (floor days 366))) ; Guess!
    (do ((x))
        ((< (setq x (- days (number-of-days-from-1900 year)))
            (if (leap-year-p year) 366 365))
         (setq day (1+ x)))
      (incf year))
    (when (leap-year-p year)
      (cond ((= day 60) (setf month 2 day 29))
            ((> day 60) (decf day))))
    (unless month
      (setq month (position day month-startdays :test #'<=)
            day (- day (svref month-startdays (1- month)))))
    (if (and (not tz-p) (daylight-saving-time-p orig-ut year))
        (setf tz-p t dstp t)
        (return (values sec min hour day month year dow dstp tz))))))

(defun encode-universal-time (sec min hour day month year &optional tz)
  "Args: (second minute hour date month year
       &optional (timezone (si::get-local-time-zone)))
Returns an integer that represents the given day-and-time.  See
GET-DECODED-TIME."
  (when (<= 0 year 99)
    ;; adjust to year in the century within 50 years of this year
    (multiple-value-bind (sec min hour day month this-year dow dstp tz)
        (get-decoded-time)
      (declare (ignore sec min hour day month dow dstp tz))
      (incf year (* 100 (ceiling (- this-year year 50) 100)))))
  (let ((dst 0))
    (unless tz
      (setq tz (rational (get-local-time-zone)))
      (when (daylight-saving-time-p (recode-universal-time sec min hour day month year tz -1) year)
        ;; assume DST applies, and check if at corresponging UT it applies.
        ;; There is an ambiguity between midnight and 1 o'clock on the day
        ;; when time reverts from DST to solar:
        ;; 12:01 on that day could be either 11:01 UT (before the switch) or
        ;; 12:01 UT (after the switch). We opt for the former.
        (setf dst -1)))
    (recode-universal-time sec min hour day month year tz dst)))

(defun daylight-saving-time-p (universal-time year)
  "Returns T if Daylight Saving Time applies to the local time zone at
Universal Time UT, which defaults to the current time."
  (declare (si::c-local))
  ;; Some systems cannot deal with dates before 1-1-1970 and no POSIX
  ;; system will be able to handle dates beyond 2038. We must
  ;; therefore restrict the time to the interval that can handled by
  ;; the timezone database.
  (let* ((utc-1-1-1970 2208988800)
         (unix-time (- universal-time utc-1-1-1970)))
    (cond ((minusp unix-time)
           ;; For dates before 1970 we shift to 1980/81 to guess the daylight
           ;; saving times.
           (setf unix-time
                 (+ (if (leap-year-p year)
                        #.(encode-universal-time 0 0 0 1 1 1980 0)
                        #.(encode-universal-time 0 0 0 1 1 1981 0))
                    (- universal-time (encode-universal-time 0 0 0 1 1 year 0) utc-1-1-1970))))
          ((not (fixnump unix-time))
           ;; Same if date is too big: we shift to year 2035/36, like SBCL does.
           (setf unix-time
                 (+ (if (leap-year-p year)
                        #.(encode-universal-time 0 0 0 1 1 2032 0)
                        #.(encode-universal-time 0 0 0 1 1 2033 0))
                    (- universal-time (encode-universal-time 0 0 0 1 1 year 0) utc-1-1-1970)))))
    #-ecl-min
    (ffi::c-inline (unix-time) (:unsigned-long) :bool "
{
        time_t when = (#0);
        struct tm *ltm = localtime(&when);
        @(return) = ltm->tm_isdst;
}"
                 :one-liner nil)))

(defun get-decoded-time ()
  "Args: ()
Returns the current day-and-time as nine values:
        second (0 - 59)
        minute (0 - 59)
        hour (0 - 23)
        date (1 - 31)
        month (1 - 12)
        year (Christian, not Japanese long-live-Emperor)
        day of week (0 for Mon, .. 6 for Sun)
        summer time or not (T or NIL)
        time zone (-9 in Japan)
Sunday is the *last* day of the week!!"
  (decode-universal-time (get-universal-time)))

(defun ensure-directories-exist (pathname &key verbose (mode #o777))
"Args: (ensure-directories pathname &key :verbose)
Creates tree of directories specified by the given pathname. Outputs
        (VALUES pathname created)
where CREATED is true only if we succeeded on creating all directories."
  (let* ((created nil)
         (full-pathname (merge-pathnames pathname))
         d)
    (when (typep full-pathname 'logical-pathname)
      (setf full-pathname (translate-logical-pathname full-pathname)))
    (when (or (wild-pathname-p full-pathname :directory)
              (wild-pathname-p full-pathname :host)
              (wild-pathname-p full-pathname :device))
      (error 'file-error :pathname pathname))
    ;; Here we have already a full pathname. We set our own
    ;; *default-pathname-defaults* to avoid that the user's value,
    ;; which may contain names or types, clobbers our computations.
    (let ((*default-pathname-defaults*
           (make-pathname :name nil :type nil :directory nil
                          :defaults full-pathname)))
      (dolist (item (pathname-directory full-pathname))
        (setf d (nconc d (list item)))
        (let* ((p (make-pathname :directory d :defaults *default-pathname-defaults*)))
          (unless (or (symbolp item) (si::file-kind p nil))
            (setf created t)
            (let ((ps (namestring p)))
              (when verbose
                (format t "~%;;; Making directory ~A" ps))
              (si::mkdir ps mode)))))
      (values pathname created))))

(defmacro with-hash-table-iterator ((iterator package) &body body)
"Syntax: (with-hash-table-iterator (iterator package) &body body)
Loop over the elements of a hash table. ITERATOR is a lexically bound function
that outputs three values
        (VALUES entry-p key value)
ENTRY-P is true only if KEY and VALUE denote a pair of key and value of the
hash table; otherwise it signals that we have reached the end of the hash table."
  `(let ((,iterator (hash-table-iterator ,package)))
    (macrolet ((,iterator () (list 'funcall ',iterator)))
      ,@body)))

(defun sharp-!-reader (stream subchar arg)
  (declare (ignore arg subchar))
  (read-line stream)
  (values))

(set-dispatch-macro-character #\# #\! 'sharp-!-reader)

(defun si::simple-program-error (message &rest datum)
  (signal-simple-error 'program-error nil message datum))

#-ecl-min
(defun make-stream-from-fd (fd direction &key buffering
                                           element-type
                                           (external-format :default)
                                           (name "FD-STREAM"))
  (check-type name string "name must be a string.")
  (macrolet ((c-const (string) `(ffi:c-inline () () :int ,string :one-liner t)))
    (let* ((smm-mode
            (ecase direction
              (:input                                   (c-const "ecl_smm_input"))
              (:output                                  (c-const "ecl_smm_output"))
              ((:io :input-output)                      (c-const "ecl_smm_io"))
              #+:wsock (:input-wsock                    (c-const "ecl_smm_input_wsock"))
              #+:wsock (:output-wsock                   (c-const "ecl_smm_output_wsock"))
              #+:wsock ((:io-wsock :input-output-wsock) (c-const "ecl_smm_io_wsock"))
              #+:wsock ((:io-wcon :input-output-wcon)   (c-const "ecl_smm_io_wcon"))))
           ;; if external-format is not NIL, flags are ignored
           (external-format (unless (subtypep element-type 'integer) external-format))
           (stream (ffi:c-inline (name fd smm-mode element-type external-format)
                                 (t :int :int t t) stream
                                 "
ecl_make_stream_from_fd(#0,#1,(enum ecl_smmode)#2,
                        ecl_normalize_stream_element_type(#3),
                        ECL_STREAM_BINARY,
                        #4)"
                                 :one-liner t)))
      (when buffering
        (si::set-buffering-mode stream buffering))
      stream)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/mislib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/listlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1995, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;                        list manipulating routines

(in-package "SYSTEM")

(defun union (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, the union of elements in LIST1 and in LIST2."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last list2))
       (or first list2))
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (progn (rplacd last (cons (car x) nil))
                 (setq last (cdr last)))
          (progn (setq first (cons (car x) nil))
                 (setq last first))))))

(defun nunion (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive UNION.  Both LIST1 and LIST2 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last list2))
       (or first list2))
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))

(defun intersection (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns a list consisting of those objects that are elements of both LIST1 and
LIST2."
  (do ((x list1 (cdr x))
       (ans))
      ((null x)
       (nreverse ans)) ; optional nreverse: not required by CLtL
    (when (member1 (car x) list2 test test-not key)
        (push (car x) ans))))

(defun nintersection (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive INTERSECTION.  Only LIST1 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last nil))
       first)
    (when (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))

(defun set-difference (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2."
  (do ((x list1 (cdr x))
       (ans))
      ((null x) (nreverse ans))
    (unless (member1 (car x) list2 test test-not key)
      (push (car x) ans))))

(defun nset-difference (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-DIFFERENCE.  Only LIST1 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last nil))
       first)
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))

(defun swap-args (f)
  (declare (si::c-local))
  (and f #'(lambda (x y) (funcall f y x))))

(defun set-exclusive-or (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2 and
those elements of LIST2 that are not elements of LIST1."
  (nconc (set-difference list1 list2 :test test :test-not test-not :key key)
         (set-difference list2 list1 :test (swap-args test) :test-not (swap-args test-not) :key key)))

(defun nset-exclusive-or (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed."
  (nconc (set-difference list1 list2 :test test :test-not test-not :key key)
         (nset-difference list2 list1 :test (swap-args test) :test-not (swap-args test-not) :key key)))

(defun subsetp (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns T if every element of LIST1 is also an element of LIST2.  Returns NIL
otherwise."
  (do ((l list1 (cdr l)))
      ((null l) t)
    (unless (member1 (car l) list2 test test-not key)
      (return nil))))

(defun rassoc-if (test alist &key key)
  "Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no
such pair exists."
  (rassoc test alist :test #'funcall :key key))
(defun rassoc-if-not (test alist &key key)
  "Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL
if no such pair exists."
  (rassoc test alist :test-not #'funcall :key key))

(defun assoc-if (test alist &key key)
  "Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no
such pair exists."
  (assoc test alist :test #'funcall :key key))
(defun assoc-if-not (test alist &key key)
  "Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL
if no such pair exists."
  (assoc test alist :test-not #'funcall :key key))

(defun member-if (test list &key key)
  "Searches LIST for an element that satisfies TEST.  If found, returns the
sublist of LIST that begins with the element.  If not found, returns NIL."
  (member test list :test #'funcall :key key))
(defun member-if-not (test list &key key)
  "Searches LIST for an element that does not satisfy TEST.  If found, returns
the sublist of LIST that begins with the element.  If not found, returns NIL."
  (member test list :test-not #'funcall :key key))

(defun subst-if (new test tree &key key)
  "Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.
The original TREE is not destroyed."
  (subst new test tree :test #'funcall :key key))
(defun subst-if-not (new test tree &key key)
  "Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the
result.  The original TREE is not destroyed."
  (subst new test tree :test-not #'funcall :key key))

(defun nsubst-if (new test tree &key key)
  "Destructive SUBST-IF. TREE may be modified."
  (nsubst new test tree :test #'funcall :key key))
(defun nsubst-if-not (new test tree &key key)
  "Destructive SUBST-IF-NOT. TREE may be modified."
  (nsubst new test tree :test-not #'funcall :key key))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/listlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/cmdline.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  cmdline.lsp -- command line processing
;;;;
;;;;  Copyright (c) 2005, Juan Jose Garcia-Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;

(in-package "SYSTEM")

(defparameter *command-break-enable* nil)

(defparameter *lisp-init-file-list* '("~/.ecl" "~/.eclrc")
  "List of files automatically loaded when ECL is invoked.")

(defparameter *help-message* "
Usage: ecl [-? | --help]
           [--dir dir] [--load file] [--shell file] [--eval expr] [--rc | --norc]
           [--c-stack size] [--lisp-stack size] [--heap-size size] [--frame-stack size]
           [[-o ofile] [-c [cfile]] [-h [hfile]] [--data [datafile]] [-s] [-q]
            --compile file]
           [[-o ofile] --link file+]
           [--input-encoding external-format] [--output-encoding external-format]
           [--error-encoding external-format] [--encoding external-format]
           [--trap-fpe | --no-trap-fpe]
"
 "Prints a help message about command line arguments of ECL")

(defun command-args ()
  "Returns the original command line arguments as list. First argument is
the ECL program itself."
  (loop for i from 0 below (argc)
           collect (argv i)))

(defparameter *command-args*
  (command-args))

(defparameter *unprocessed-ecl-command-args*
  nil
  "As part of ECL's command line rules, this variable stores all arguments which
appeared after a '--'.")

(defun command-arg-error (str &rest fmt-args)
  ;; Format an error message and quit
  (declare (si::c-local))
  (apply #'format *error-output* str fmt-args)
  (princ *help-message* *error-output*)
  (quit 1))

(defconstant +default-command-arg-rules+
  '((("-?" "--help") 0
     (progn (princ *help-message* *standard-output*)
            (quit))
     :noloadrc)
    (("-norc" "--norc") 0 nil :noloadrc)
    (("-v" "--version") 0
     (progn (setf quit 0)
            (format *standard-output* "ECL ~A~%" (lisp-implementation-version)))
     :noloadrc)
    (("-debug" "--debug") 0 (setf *command-break-enable* t))
    (("-nodebug" "--nodebug") 0 (setf *command-break-enable* nil))
    (("-eval" "--eval") 1 (eval (read-from-string 1)))
    (("-shell" "--shell") 1
     (progn (setq quit 0)
            (setq ext:*unprocessed-ecl-command-args* (rest 1))
            (load (first (rest 1)) :verbose nil))
     :stop)
    (("-load" "--load") 1 (load 1 :verbose verbose))
    (("-dir" "--dir") 1 (setf (logical-pathname-translations "SYS")
                         `(("**;*.*" ,(merge-pathnames "**/*.*" (truename 1))))))
    ("--heap-size" 1 (ext:set-limit 'ext:heap-size (read-from-string 1)))
    ("--lisp-stack" 1 (ext:set-limit 'ext:lisp-stack (read-from-string 1)))
    ("--frame-stack" 1 (ext:set-limit 'ext:frame-stack (read-from-string 1)))
    ("--c-stack" 1 (ext:set-limit 'ext:c-stack (read-from-string 1)))
    ("--trap-fpe" 0 (si::trap-fpe t t))
    ("--no-trap-fpe" 0 (si::trap-fpe t nil))
    ("--encoding" 1 (dolist (i (list *standard-input* *standard-output*
                                     *error-output* *trace-output*))
                      (setf (stream-external-format i) (read-from-string 1))))
    ("--input-encoding" 1
     (setf (stream-external-format *standard-input*) (read-from-string 1)))
    ("--output-encoding" 1
     (setf (stream-external-format *standard-output*) (read-from-string 1)))
    ("--error-encoding" 1
     (setf (stream-external-format *error-output*) (read-from-string 1)))
    (("-compile" "--compile") 1
     (progn
       (setq quit
             (if (nth-value
                  3 (compile-file
                     1 :output-file output-file :c-file c-file
                     :h-file h-file :data-file data-file
                     :verbose verbose :system-p system-p))
                 1
                 0)
             output-file t
             c-file nil
             h-file nil
             data-file nil
             system-p nil)))
    (("-link" "--link") &rest
     (progn
       (require 'cmp)
       (funcall (read-from-string "c::build-program")
                (or output-file "lisp.exe") :lisp-files '&rest)
       (setq output-file t quit t)))
    ("-o" &optional (setq output-file 1))
    ("-c" &optional (setq c-file 1))
    ("-h" &optional (setq h-file 1))
    (("-data" "--data") 1 (setq data-file 1))
    (("-q" "--quiet") 0 (setq verbose nil))
    ("-s" 0 (setq system-p t))
    ("--" 1 (setf ext:*unprocessed-ecl-command-args* (rest 1)) :stop)))

(defun produce-init-code (option-list rules)
  (do* ((match-option (lambda (k r)
                        (if (listp r)
                            (member k r :test #'string=)
                            (string= k r))))
        (commands '())
        (stop nil)
        (loadrc t))
       ((or stop (null option-list))
        (values `(let ((output-file t)
                       (c-file nil)
                       (h-file nil)
                       (data-file nil)
                       (verbose t)
                       (system-p nil)
                       (quit nil)
                       (*command-break-enable* nil))
                   ,@(nreverse commands)
                   (when quit (quit 0)))
                loadrc
                option-list))
    (let* ((option (pop option-list))
           (rule (assoc option rules :test match-option)))
      (unless rule
        ;; If there is a default rule, group all remaining arguments
        ;; including the unmatched one, and pass them to this rule.
        (setf rule (assoc "*DEFAULT*" rules :test match-option)
              stop t)
        (unless rule
          (command-arg-error "Unknown command line option ~A.~%" option)))
      (case (fourth rule)
        (:noloadrc (setf loadrc nil))
        (:loadrc (setf loadrc t))
        (:stop (setf option-list `('(,option ,@option-list))
                     stop t)))
      (let ((pattern (copy-tree (third rule)))
            (noptions (second rule)))
        (cond ((equal noptions 0)
               ;; No extra arguments
               )
              ((and (equal noptions '&optional)
                    (or (null option-list)
                        (assoc (first option-list) rules :test match-option)))
               ;; The argument is optional and the next command line option is
               ;; either absent or it is a valid command line option
               (nsubst t 1 pattern))
              ((null option-list)
               (command-arg-error
                "Missing argument after command line option ~A.~%"
                option))
              ((or (eq noptions 'rest) (eq noptions '&rest))
               (nsubst option-list noptions pattern)
               (setf option-list nil))
              (t
               (nsubst (pop option-list) 1 pattern)))
        (push pattern commands)))))

(defun process-command-args (&key
                             (args (rest *command-args*))
                             (rules +default-command-arg-rules+))
"PROCESS-COMMAND-ARGS takes a list of arguments and processes according
to a set of rules. These rules are of the format

        (option-name nargs template [ :stop | :noloadrc | :loadrc ] )

OPTION-NAME is a string containing the command line option. NARGS is
the number of arguments that this option takes. TEMPLATE is a lisp
form where numbers from 0 to NARGS will be substituted by the
arguments, and which will be evaluated afterwards. The flags :STOP,
:NOLOADRC and :LOADRC denote whether to stop processing the command
line after this option and whether the initialization file will be
loaded before evaluating all forms.

An excerpt of the rules used by ECL:
'((\"--help\" 0 #0=(progn (princ *help-message* *standard-output*) (quit))
               :noloadrc)
  (\"-?\" 0 #0# :noloadrc)
  (\"-h\" 0 #0# :noloadrc)
  (\"-norc\" 0 nil :noloadrc)
  (\"--\" 0 nil :stop)
  (\"-eval\" 1 (eval (read-from-string 1))))
"
  (multiple-value-bind (commands loadrc unprocessed-options)
      (produce-init-code args rules)
    (declare (ignore unprocessed-options))
    (restart-case
        (handler-bind ((error
                        #'(lambda (c)
                            (if *command-break-enable*
                                (invoke-debugger c)
                                (progn
                                  (format *error-output*
                                          "An error occurred during initialization:~%~A.~%"
                                          c)
                                  (quit 1))))))
          (progn
            (when loadrc
              (dolist (file *lisp-init-file-list*)
                (when (load file :if-does-not-exist nil :search-list nil :verbose nil)
                  (return))))
            (eval commands)))
      (continue ()
        :report "Ignore initialization errors and continue.")
      (abort ()
        :report "Quit ECL unsafely, ignoring all existing threads."
        (si::quit -1 nil)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/cmdline.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/cmpinit.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;

(in-package "SYSTEM")

;;; Disable PDE facilities within LISP kernel:
(setq *features* (delete ':pde *features*))
;;; Disable record-source-pathname within LISP kernel:
(defmacro record-source-pathname (x y))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/cmpinit.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/cmuutil.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;; *********************************************************************
;;; This code was written as part of the CMU Common Lisp project at
;;; Carnegie Mellon University, and has been placed in the public domain.
;;;
;;; *********************************************************************

(in-package "SI")


#+ecl-min
(defmacro handler-bind (bindings &body body)
  `(progn ,@body))


;;;; The Collect macro:

;;; Collect-Normal-Expander  --  Internal
;;;
;;;    This function does the real work of macroexpansion for normal
;;; collection macros.  N-Value is the name of the variable which
;;; holds the current value.  Fun is the function which does
;;; collection.  Forms is the list of forms whose values we are
;;; supposed to collect.
;;;
(defun collect-normal-expander (n-value fun forms)
  `(progn
    ,@(mapcar #'(lambda (form) `(setq ,n-value (,fun ,form ,n-value))) forms)
    ,n-value))

;;; Collect-List-Expander  --  Internal
;;;
;;;    This function deals with the list collection case.  N-Tail is
;;; the pointer to the current tail of the list, which is NIL if the
;;; list is empty.
;;;
(defun collect-list-expander (n-value n-tail forms)
  (let ((n-res (gensym)))
    `(progn
      ,@(mapcar #'(lambda (form)
                    `(let ((,n-res (cons ,form nil)))
                       (cond (,n-tail
                              (setf (cdr ,n-tail) ,n-res)
                              (setq ,n-tail ,n-res))
                             (t
                              (setq ,n-tail ,n-res  ,n-value ,n-res)))))
                forms)
      ,n-value)))


;;; Collect  --  Public
;;;
;;;    The ultimate collection macro...
;;;
(defmacro collect (collections &body body)
  "Collect ({(Name [Initial-Value] [Function])}*) {Form}*

Collect some values somehow.  Each of the collections specifies a
bunch of things which collected during the evaluation of the body of
the form.  The name of the collection is used to define a local macro,
a la MACROLET.  Within the body, this macro will evaluate each of its
arguments and collect the result, returning the current value after
the collection is done.  The body is evaluated as a PROGN; to get the
final values when you are done, just call the collection macro with no
arguments.

Initial-Value is the value that the collection starts out with, which
defaults to NIL.  Function is the function which does the collection.
It is a function which will accept two arguments: the value to be
collected and the current collection.  The result of the function is
made the new value for the collection.  As a totally magical
special-case, the Function may be Collect, which tells us to build a
list in forward order; this is the default.  If an Initial-Value is
supplied for Collect, the stuff will be rplacd'd onto the end.  Note
that Function may be anything that can appear in the functional
position, including macros and lambdas.

Bare symbols in `specs' are equivalent to:

(symbol nil 'collect)

Example:

  (collect (a b)
    (a 3)
    (a 4)
    (b 5)
    (list (a) (b)))
  ; => ((3 4) (5))
"

  (let (macros binds)
    (dolist (spec collections)
      (cond ((atom spec)
             (setf spec (list spec)))
            ((not (<= 1 (length spec) 3))
             (error "Malformed collection specifier: ~S." spec)))
      (let ((n-value (gensym))
            (name (first spec))
            (default (second spec))
            (kind (or (third spec) 'collect)))
        (push `(,n-value ,default) binds)
        (if (eq kind 'collect)
            (let ((n-tail (gensym)))
              (if default
                  (push `(,n-tail (last ,n-value)) binds)
                  (push n-tail binds))
              (push `(,name (&rest args)
                            (collect-list-expander ',n-value ',n-tail args))
                    macros))
            (push `(,name (&rest args)
                          (collect-normal-expander ',n-value ',kind args))
                  macros))))
    `(macrolet ,macros (let* ,(nreverse binds) ,@body))))


;;;; The Once-Only macro:

;;; Once-Only  --  Interface
;;;
;;;    Once-Only is a utility useful in writing source transforms and
;;;    macros.  It provides an easy way to wrap a let around some code
;;;    to ensure that some forms are only evaluated once.
;;;
(defmacro once-only (specs &body body)
  "Once-Only ({(Var Value-Expression)}*) Form*

Create a Let* which evaluates each Value-Expression, binding a
temporary variable to the result, and wrapping the Let* around the
result of the evaluation of Body.  Within the body, each Var is bound
to the corresponding temporary variable.

Bare symbols in `specs' are equivalent to:

  (symbol symbol)

Example:

  (defmacro cons1 (x)
    (once-only (x) `(cons ,x ,x)))
  (let ((y 0))
    (cons1 (incf y)))
  ; => (1 . 1)
"
  (labels ((frob (specs body)
             (if (null specs)
                 `(progn ,@body)
                 (let ((spec (first specs)))
                   (cond ((atom spec)
                          (setf spec (list spec spec)))
                         ((/= (length spec) 2)
                          (error "Malformed Once-Only binding spec: ~S." spec)))
                   (let ((name (first spec))
                         (exp-temp (gensym)))
                     `(let ((,exp-temp ,(second spec))
                            (,name (gensym "OO-")))
                        `(let ((,,name ,,exp-temp))
                           ,,(frob (rest specs) body))))))))
    (frob specs body)))


;;; Automate an idiom often found in macros:
;;;   (LET ((FOO (GENSYM "FOO"))
;;;         (MAX-INDEX (GENSYM "MAX-INDEX-")))
;;;     ...)
;;;
;;; "Good notation eliminates thought." -- Eric Siggia
;;;
;;; Incidentally, this is essentially the same operator which
;;; _On Lisp_ calls WITH-GENSYMS.
(defmacro with-unique-names (symbols &body body)
  "Binds each variable named by a symbol in `symbols' to a unique
symbol around `body'."
  `(let* ,(mapcar (lambda (symbol)
                    (let* ((symbol-name (symbol-name symbol))
                           (stem symbol-name))
                      `(,symbol (gensym ,stem))))
                  symbols)
     ,@body))

(defmacro with-gensyms (symbols &body body)
  "Alias for `with-unique-names'."
  `(with-unique-names ,symbols ,@body))


(defmacro with-clean-symbols (symbols &body body)
  "Rewrites the given forms replacing the given symbols with uninterned
ones, which is useful for creating hygienic macros."
  `(progn ,@(sublis
             (mapcar #'(lambda (s)
                         (cons s (make-symbol (symbol-name s))))
                     symbols)
             body)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/cmuutil.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/unicode.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2011, Juan Jose Garcia-Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;
;;;;  unicode.lsp -- encoding and decoding
;;;;

(in-package "SYSTEM")

;;;;
;;;; ENCODING / DECODING ERRORS
;;;;

(define-condition character-coding-error (error)
  ((external-format :initarg :external-format :reader character-coding-error-external-format)))

(define-condition character-encoding-error (character-coding-error)
  ((code :initarg :code :reader character-encoding-error-code)))

(define-condition character-decoding-error (character-coding-error)
  ((octets :initarg :octets :reader character-decoding-error-octets)))

(define-condition stream-encoding-error (stream-error character-encoding-error)
  ()
  (:report
   (lambda (c s)
     (let ((stream (stream-error-stream c))
           (code (character-encoding-error-code c)))
       (format s "~@<encoding error on stream ~S (~S ~S): ~2I~_~
                  the character with code ~D cannot be encoded.~@:>"
               stream ':external-format
               (character-coding-error-external-format c)
               code)))))

(define-condition stream-decoding-error (stream-error character-decoding-error)
  ()
  (:report
   (lambda (c s)
     (let ((stream (stream-error-stream c))
           (octets (character-decoding-error-octets c)))
       (format s "~@<decoding error on stream ~S (~S ~S): ~2I~_~
                  the octet sequence ~S cannot be decoded.~@:>"
               stream ':external-format
               (character-coding-error-external-format c)
               octets)))))

(defun encoding-error (stream external-format code)
  (restart-case (error 'stream-encoding-error
                       :stream stream
                       :external-format external-format
                       :code code)
    (continue ()
      :report "Ignore character"
      nil)
    (use-value (c)
      :report "Store a different character code."
      (if (characterp c) c (code-char c)))))

(defun decoding-error (stream external-format octets)
  (restart-case (error 'stream-decoding-error
                       :stream stream
                       :external-format external-format
                       :octets octets)
    (continue ()
      :report "Read next character"
      nil)
    (use-value (c)
      :report "Replace the bogus sequence with a character"
      (if (characterp c) c (code-char c)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/unicode.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/init.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;

;(load "../cmp/init")

(defun lcs1 (file)
       (compile-file file
                     :c-file t :h-file t :data-file t :output-file nil
                     :system-p t))

(proclaim '(special sys::*indent-formatted-output*))

(defun compile-if-needed (file)
  (let ((cfile-date (file-write-date (merge-pathnames file #".c"))))
    (when (or (not cfile-date)
              (> (file-write-date (merge-pathnames file #".lsp"))
                 cfile-date))
      (compile-file file :c-file t :h-file t :data-file t
                    :output-file nil :system-p t)))
  )
#|
(compile-if-needed "defmacro")
(compile-if-needed "evalmacros")
(compile-if-needed "top")
(compile-if-needed "module")
(compile-if-needed "predlib")
(compile-if-needed "setf")
(compile-if-needed "arraylib")
(compile-if-needed "assert")
(compile-if-needed "defstruct")
(compile-if-needed "describe")
(compile-if-needed "iolib")
(compile-if-needed "listlib")
(compile-if-needed "mislib")
(compile-if-needed "numlib")
(compile-if-needed "packlib")
(compile-if-needed "seq")
(compile-if-needed "seqlib")
(compile-if-needed "trace")
;(compile-if-needed "thread")
;(compile-if-needed "loop")
(bye)
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/init.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/module.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;    module routines

;; This is taken from SBCL's code/module.lisp which is in the public
;; domain.

(in-package "SYSTEM")

;;;; exported specials

(defparameter *modules* ()
  "This is a list of module names that have been loaded into Lisp so far.
It is used by PROVIDE and REQUIRE.")

(defparameter *module-provider-functions* nil
  "See function documentation for REQUIRE")

;;;; PROVIDE and REQUIRE

(defun provide (module-name)
  "Adds a new module name to *MODULES* indicating that it has been loaded.
Module-name is a string designator"
  (pushnew (string module-name) *modules* :test #'string=)
  t)

(defparameter *requiring* nil)

(defun require-error (control &rest arguments)
  (error "Module error: ~?" control arguments))

(defun require (module-name &optional pathnames)
  "Loads a module, unless it already has been loaded. PATHNAMES, if supplied,
is a designator for a list of pathnames to be loaded if the module
needs to be. If PATHNAMES is not supplied, functions from the list
*MODULE-PROVIDER-FUNCTIONS* are called in order with MODULE-NAME
as an argument, until one of them returns non-NIL.  User code is
responsible for calling PROVIDE to indicate a successful load of the
module."
  (let ((name (string module-name)))
    (when (member name *requiring* :test #'string=)
      (require-error "~@<Could not ~S ~A: circularity detected. Please check ~
                     your configuration.~:@>" 'require module-name))
    (let ((saved-modules (copy-list *modules*))
          (*requiring* (cons name *requiring*)))
      (unless (member name *modules* :test #'string=)
        (cond (pathnames
               (unless (listp pathnames) (setf pathnames (list pathnames)))
               ;; ambiguity in standard: should we try all pathnames in the
               ;; list, or should we stop as soon as one of them calls PROVIDE?
               (dolist (ele pathnames t)
                 (load ele)))
              (t
               (unless (some (lambda (p) (funcall p module-name))
                             *module-provider-functions*)
                 (require-error "Don't know how to ~S ~A."
                                'require module-name)))))
      (set-difference *modules* saved-modules))))

(pushnew #'(lambda (module)
             (let* ((module (string module)))
               (or
                (let ((path (make-pathname :name module :defaults "SYS:")))
                  (load path :if-does-not-exist nil))
                (let ((path (make-pathname :name (string-downcase module)
                                           :defaults "SYS:")))
                  (load path :if-does-not-exist nil)))))
         *module-provider-functions*)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/module.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/iolib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;        The IO library.

(in-package "SYSTEM")

(defmacro with-open-stream ((var stream) &rest body)
  "Syntax: (with-open-stream (var stream-form) {decl}* {form}*)
Evaluates FORMs with VAR bound to the value of STREAM-FORM.  The stream is
automatically closed on exit."
  (multiple-value-bind (ds b)
      (find-declarations body)
    `(LET ((,var ,stream))
       ,@ds
       (UNWIND-PROTECT
         (PROGN ,@b)
         (CLOSE ,var)))))

(defmacro with-input-from-string ((var string &key index (start 0) end) &rest body)
  "Syntax: (with-input-from-string (var string-form {keyword value}*)
           {decl}* {form}*)
Evaluates FORMs with VAR bound to a string input stream from the string that
is the value of STRING-FORM.  The stream is automatically closed on exit.
Possible keywords are :INDEX, :START, and :END."
  (if index
      (multiple-value-bind (ds b)
          (find-declarations body)
        `(LET ((,var (MAKE-STRING-INPUT-STREAM ,string ,start ,end)))
           ,@ds
           (UNWIND-PROTECT
             (MULTIPLE-VALUE-PROG1
              (PROGN ,@b)
              (SETF ,index (FILE-POSITION ,var)))
             (CLOSE ,var))))
      `(LET ((,var (MAKE-STRING-INPUT-STREAM ,string ,start ,end)))
         ,@body)))

(defmacro with-output-to-string ((var &optional string &rest r &key element-type) &rest body)
  "Syntax: (with-output-to-string (var [string-form]) {decl}* {form}*)
Evaluates FORMs with VAR bound to a string output stream to the string that is
the value of STRING-FORM.  If STRING-FORM is not given, a new string is used.
The stream is automatically closed on exit and the string is returned."
  (if string
      `(LET* ((,var (MAKE-STRING-OUTPUT-STREAM-FROM-STRING ,string))
              (,(gensym) ,element-type))
        ;; We must evaluate element-type if it has been supplied by the user.
        ;; Even if we ignore the value afterwards.
         ,@body)
      `(LET ((,var (MAKE-STRING-OUTPUT-STREAM ,@r)))
         ,@body
         (GET-OUTPUT-STREAM-STRING ,var))))

(defun read-from-string (string
                         &optional (eof-error-p t) eof-value
                         &key (start 0) (end (length string))
                              preserve-whitespace)
  "Args: (string &optional (eof-error-p t) (eof-value nil)
              &key (start 0) (end (length string)) (preserve-whitespace nil))
Reads an object from STRING and returns the object.  As the second value,
returns the index to the character next to the object's representation.
PRESERVE-WHITESPACE specifies whether to leave the character next to the
object's representation."
  (let ((stream (make-string-input-stream string start end)))
    (if preserve-whitespace
        (values (read-preserving-whitespace stream eof-error-p eof-value)
                (file-position stream))
        (values (read stream eof-error-p eof-value)
                (file-position stream)))))

(defun si::string-to-object (string &optional (err-value nil err-value-p))
  (if err-value-p
      (si::safe-eval `(read-from-string ,string) nil err-value)
      (si::safe-eval `(read-from-string ,string) nil)))

(defun write-to-string (object &rest rest
                        &aux (stream (make-string-output-stream)))
  "Args: (object &key (escape *print-escape*) (radix *print-radix*)
                   (base *print-base*) (circle *print-circle*)
                   (pretty *print-pretty*) (level *print-level*)
                   (length *print-length*) (case *print-case*)
                   (array *print-array*) (gensym *print-gensym*))
Returns as a string the printed representation of OBJECT in the specified
mode.  See the variable docs of *PRINT-...* for the mode."
  (apply #'write object :stream stream rest)
  (get-output-stream-string stream))

(defun prin1-to-string (object
                        &aux (stream (make-string-output-stream)))
  "Args: (object)
PRIN1s OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE T)."
   (prin1 object stream)
   (get-output-stream-string stream))

(defun princ-to-string (object
                        &aux (stream (make-string-output-stream)))
  "Args: (object)
PRINCs OBJECT to a new string and returns the result.  Equivalent to
(WRITE-TO-STRING OBJECT :ESCAPE NIL)."
  (princ object stream)
  (get-output-stream-string stream))

(defmacro with-open-file ((stream . filespec) &rest body)
  "Syntax: (with-open-file (var filespec-form {options}*) {decl}* {form}*)
Opens the specified file using OPTIONs, and evaluates FORMs with VAR bound to
a stream to/from the file.  The file is automatically closed on exit.  See
OPEN for the options."
  (multiple-value-bind (ds b)
      (find-declarations body)
    `(LET ((,stream (OPEN ,@filespec)))
       ,@ds
       (UNWIND-PROTECT
         (MULTIPLE-VALUE-PROG1 (PROGN ,@b) (WHEN ,stream (CLOSE ,stream)))
         (WHEN ,stream (CLOSE ,stream :ABORT T))))))

(defun y-or-n-p (&optional string &rest args)
  "Args: (&optional format-string &rest args)
Asks the user a Y-or-N question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear."
  (do ((reply))
      (nil)
    (when string (format *query-io* "~&~?  (Y or N) " string args))
    (setq reply (read *query-io*))
    (cond ((string-equal (symbol-name reply) "Y")
           (return-from y-or-n-p t))
          ((string-equal (symbol-name reply) "N")
           (return-from y-or-n-p nil)))))

(defun yes-or-no-p (&optional string &rest args)
  "Args: (&optional format-string &rest args)
Asks the user an YES-or-NO question.  Does FRESH-LINE, prints a message as if
FORMAT-STRING and ARGs were given to FORMAT, and then prints \"(Y or N)\" is
printed.  If FORMAT-STRING is NIL, however, no prompt will appear."
  (do ((reply))
      (nil)
    (when string (format *query-io* "~&~?  (Yes or No) " string args))
    (setq reply (read *query-io*))
    (cond ((string-equal (symbol-name reply) "YES")
           (return-from yes-or-no-p t))
          ((string-equal (symbol-name reply) "NO")
           (return-from yes-or-no-p nil)))))

(defun sharp-a-reader (stream subchar arg)
  (declare (ignore subchar))
  (let ((initial-contents (read stream nil nil t)))
    (cond
      (*read-suppress* nil)
      ((null arg)
        ;; readably-pretty-printed array: #A(type dims initial-contents)
        (let ((elt-type (car initial-contents))
              (dims (cadr initial-contents))
              (initial-contents (caddr initial-contents)))
          (make-array dims :element-type elt-type :initial-contents initial-contents)))
      (t
        (do* ((i 0 (1+ i))
              (d nil (cons (length ic) d))
              (ic initial-contents (if (zerop (length ic)) ic (elt ic 0))))
            ((>= i arg)
             (make-array (nreverse d) :initial-contents initial-contents))
          (declare (fixnum i)))))))

(set-dispatch-macro-character #\# #\a 'sharp-a-reader)
(set-dispatch-macro-character #\# #\A 'sharp-a-reader)

(defun sharp-s-reader (stream subchar arg)
  (declare (ignore subchar))
  (when (and arg (null *read-suppress*))
        (error "~S is an extra argument for the #s readmacro." arg))
  (let ((l (read stream t nil t)))
    (when *read-suppress*
      (return-from sharp-s-reader nil))
    (unless (get-sysprop (car l) 'is-a-structure)
            (error "~S is not a structure." (car l)))
    ;; Intern keywords in the keyword package.
    (do ((ll (cdr l) (cddr ll)))
        ((endp ll)
         ;; Find an appropriate construtor.
         (do ((cs (get-sysprop (car l) 'structure-constructors) (cdr cs)))
             ((endp cs)
              (error "The structure ~S has no structure constructor."
                     (car l)))
           (when (symbolp (car cs))
                 (return (apply (car cs) (cdr l))))))
      (rplaca ll (intern (string (car ll)) 'keyword)))))

(set-dispatch-macro-character #\# #\s 'sharp-s-reader)
(set-dispatch-macro-character #\# #\S 'sharp-s-reader)

(defparameter *dribble-closure* nil)

(defun dribble (&optional (pathname "DRIBBLE.LOG" psp))
  "Args: (&optional filespec)
If FILESPEC is given, starts recording the interaction to the specified file.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  If FILESPEC
is not given, ends the recording."
  (cond (*dribble-closure*
         (funcall *dribble-closure* psp))
        ((null psp)
         (error "Not in dribble."))
        (t
         (let* ((namestring (namestring pathname))
                (stream (open pathname :direction :output
                              :if-exists :supersede
                              :if-does-not-exist :create))
                (dribble-stream (make-two-way-stream
                                 (make-echo-stream *terminal-io* stream)
                                 (make-broadcast-stream *terminal-io* stream)))
                (standard-input *standard-input*)
                (standard-output *standard-output*)
                (closure #'(lambda (pathname-p)
                             (when pathname-p
                               (error "Already in dribble (to ~A)" namestring))
                             (unless (and (eq dribble-stream *standard-input*)
                                          (eq dribble-stream *standard-output*))
                               (warn "Stream variables rebound while DRIBBLE is on.~%Some output may be lost."))
                             (format stream "~&Finished dribbling to ~A." namestring)
                             (close stream)
                             (setq *standard-input* standard-input
                                   *standard-output* standard-output
                                   *dribble-closure* nil))))
           (multiple-value-bind (sec min hour day month year)
               (get-decoded-time)
             (format dribble-stream "~&Starts dribbling to ~A (~d/~d/~d, ~2,'0d:~2,'0d:~2,'0d)."
                     namestring year month day hour min sec)
             (setq *standard-input* dribble-stream
                   *standard-output* dribble-stream
                   *dribble-closure* closure)))))
  (values))

;(provide 'iolib)

(defmacro with-standard-io-syntax (&body body)
  "Syntax: ({forms}*)
The forms of the body are executed in a print environment that corresponds to
the one defined in the ANSI standard. *print-base* is 10, *print-array* is t,
*package* is \"CL-USER\", etc."
  (with-clean-symbols (%progv-list)
    `(let ((%progv-list +io-syntax-progv-list+))
       (progv (si:cons-car %progv-list)
           (si:cons-cdr %progv-list)
         ,@body))))

(defmacro with-ecl-io-syntax (&body body)
  "Syntax: ({forms}*)
The forms of the body are executed in a print environment that corresponds to
the one used internally by ECL compiled files."
  (with-clean-symbols (%progv-list)
    `(let ((%progv-list +ecl-syntax-progv-list+))
       (progv (si:cons-car %progv-list)
           (si:cons-cdr %progv-list)
         ,@body))))

#-formatter
(defmacro formatter (control-string)
  `#'(lambda (*standard-output* &rest args)
       (si::formatter-aux *standard-output* ,control-string args)))

(defmacro print-unreadable-object
          ((object stream &key type identity) &body body)
  (if body
      `(flet ((.print-unreadable-object-body. () ,@body))
         (print-unreadable-object-function
           ,object ,stream ,type ,identity #'.print-unreadable-object-body.))
    `(print-unreadable-object-function ,object ,stream ,type ,identity nil)))

(let* ((basic-encodings
        #+unicode
         '(:UTF-8 :UCS-2 :UCS-2BE :UCS-2LE :UCS-4 :UCS-4BE
           :ISO-8859-1 :LATIN-1 :US-ASCII :DEFAULT)
         #-unicode
         '(:DEFAULT))
       (all-encodings nil))
  (defun ext:all-encodings ()
    (or all-encodings
        (progn
          (setf all-encodings basic-encodings)
          #+unicode
          (dolist (i (directory "sys:encodings;*"))
            (push (intern (pathname-name i) "KEYWORD") all-encodings))
          all-encodings))))

(defun ext:load-encoding (name)
  #-unicode
  (warn "EXT:LOAD-ENCODING not available when ECL is built without support for Unicode")
  #+unicode
  (let ((filename (make-pathname :name (symbol-name name) :defaults "sys:encodings;")))
    (cond ((probe-file filename)
           (load filename :verbose nil)
           name)
          ((probe-file (setf filename (make-pathname :type "BIN" :defaults filename)))
           (with-open-file (in filename :element-type '(unsigned-byte 16)
                               :external-format :big-endian)
             (let* ((l (read-byte in))
                    (s (make-array l :element-type '(unsigned-byte 16) :initial-element 0)))
               (read-sequence s in)
               s)))
          (t
           (error "Unable to find mapping file ~A for encoding ~A" filename name)))))

(defun ext:make-encoding (mapping)
  #-unicode
  (error "Not a valid external format ~A" mapping)
  #+unicode
  (cond
    ((symbolp mapping)
     (let ((var (intern (symbol-name mapping) (find-package "EXT"))))
       (unless (boundp var)
         (setf (symbol-value var) (ext::make-encoding (load-encoding mapping))))
       (symbol-value var)))
    ((consp mapping)
     (let ((output (make-hash-table :size 512 :test 'eq)))
       (dolist (record mapping output)
         (let* ((byte (car record))
                (unicode (cdr record))
                (unicode-char (code-char unicode)))
           (when (> byte #xFF)
             (setf (gethash (ash byte -8) output) t))
           (setf (gethash byte output) unicode-char)
           (setf (gethash unicode-char output) byte)))))
    ((arrayp mapping)
      (do* ((l (array-total-size mapping))
            (output (make-hash-table :size (floor (* 1.5 l)) :test 'eq))
            (i 0 (+ 2 i)))
           ((>= i l) output)
        (let* ((byte (aref mapping i))
               (unicode (aref mapping (1+ i)))
               (unicode-char (code-char unicode)))
          (when (> byte #xFF)
            (setf (gethash (ash byte -8) output) t))
          (setf (gethash byte output) unicode-char)
          (setf (gethash unicode-char output) byte))))
    (t
     (error "Not a valid external format ~A" mapping))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/iolib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/loop.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;>
;;;> Portions of LOOP are Copyright (c) 1986 by the Massachusetts Institute of Technology.
;;;> All Rights Reserved.
;;;> 
;;;> Permission to use, copy, modify and distribute this software and its
;;;> documentation for any purpose and without fee is hereby granted,
;;;> provided that the M.I.T. copyright notice appear in all copies and that
;;;> both that copyright notice and this permission notice appear in
;;;> supporting documentation.  The names "M.I.T." and "Massachusetts
;;;> Institute of Technology" may not be used in advertising or publicity
;;;> pertaining to distribution of the software without specific, written
;;;> prior permission.  Notice must be given in supporting documentation that
;;;> copying distribution is by permission of M.I.T.  M.I.T. makes no
;;;> representations about the suitability of this software for any purpose.
;;;> It is provided "as is" without express or implied warranty.
;;;> 
;;;>      Massachusetts Institute of Technology
;;;>      77 Massachusetts Avenue
;;;>      Cambridge, Massachusetts  02139
;;;>      United States of America
;;;>      +1-617-253-1000
;;;>
;;;> Portions of LOOP are Copyright (c) 1989, 1990, 1991, 1992 by Symbolics, Inc.
;;;> All Rights Reserved.
;;;> 
;;;> Permission to use, copy, modify and distribute this software and its
;;;> documentation for any purpose and without fee is hereby granted,
;;;> provided that the Symbolics copyright notice appear in all copies and
;;;> that both that copyright notice and this permission notice appear in
;;;> supporting documentation.  The name "Symbolics" may not be used in
;;;> advertising or publicity pertaining to distribution of the software
;;;> without specific, written prior permission.  Notice must be given in
;;;> supporting documentation that copying distribution is by permission of
;;;> Symbolics.  Symbolics makes no representations about the suitability of
;;;> this software for any purpose.  It is provided "as is" without express
;;;> or implied warranty.
;;;> 
;;;> Symbolics, CLOE Runtime, and Minima are trademarks, and CLOE, Genera,
;;;> and Zetalisp are registered trademarks of Symbolics, Inc.
;;;>
;;;>      Symbolics, Inc.
;;;>      8 New England Executive Park, East
;;;>      Burlington, Massachusetts  01803
;;;>      United States of America
;;;>      +1-617-221-1000

;; $aclHeader: loop.cl,v 1.5 91/12/04 01:13:48 cox acl4_1 $

;;;; LOOP Iteration Macro

#+ecl
(in-package "SI")

;;; The design of this LOOP is intended to permit, using mostly the same
;;; kernel of code, up to three different "loop" macros:
;;; 
;;; (1) The unextended, unextensible ANSI standard LOOP;
;;;
;;; (2) A clean "superset" extension of the ANSI LOOP which provides
;;; functionality similar to that of the old LOOP, but "in the style of"
;;; the ANSI LOOP.  For instance, user-definable iteration paths, with a
;;; somewhat cleaned-up interface.
;;;
;;; (3) Extensions provided in another file which can make this LOOP
;;; kernel behave largely compatibly with the Genera-vintage LOOP macro,
;;; with only a small addition of code (instead of two whole, separate,
;;; LOOP macros).
;;;
;;; Each of the above three LOOP variations can coexist in the same LISP
;;; environment.
;;; 


;;;; Miscellaneous Environment Things

(defmacro loop-unsafe (&rest x)
  `(locally (declare (ext:assume-right-type)) ,@x))


;;;; List Collection Macrology


(defmacro with-loop-list-collection-head ((head-var tail-var &optional user-head-var)
                                          &body body)
  (let ((l (and user-head-var (list (list user-head-var nil)))))
    `(let* ((,head-var (list nil)) (,tail-var ,head-var) ,@l)
       ,@body)))


(defmacro loop-collect-rplacd (&environment env
                               (head-var tail-var &optional user-head-var) form)
  (setq form (macroexpand form env))
  (flet ((cdr-wrap (form n)
           (declare (fixnum n))
           (do () ((<= n 4) (setq form `(,(case n
                                            (1 'cdr)
                                            (2 'cddr)
                                            (3 'cdddr)
                                            (4 'cddddr))
                                         ,form)))
             (setq form `(cddddr ,form) n (- n 4)))))
    (let ((tail-form form) (ncdrs nil))
      ;;Determine if the form being constructed is a list of known length.
      (when (consp form)
        (cond ((eq (car form) 'list)
               (setq ncdrs (1- (length (cdr form)))))
              ((member (car form) '(list* cons))
               (when (and (cddr form) (member (car (last form)) '(nil 'nil)))
                 (setq ncdrs (- (length (cdr form)) 2))))))
      (let ((answer
              (cond ((null ncdrs)
                     `(when (setf (cdr ,tail-var) ,tail-form)
                        (setq ,tail-var (last (cdr ,tail-var)))))
                    ((< ncdrs 0) (return-from loop-collect-rplacd nil))
                    ((= ncdrs 0)
                     ;; Here we have a choice of two idioms:
                     ;; (rplacd tail (setq tail tail-form))
                     ;; (setq tail (setf (cdr tail) tail-form)).
                     ;;Genera and most others I have seen do better with the former.
                     `(rplacd ,tail-var (setq ,tail-var ,tail-form)))
                    (t `(setq ,tail-var ,(cdr-wrap `(setf (cdr ,tail-var) ,tail-form)
                                                   ncdrs))))))
        ;;If not using locatives or something similar to update the user's
        ;; head variable, we've got to set it...  It's harmless to repeatedly set it
        ;; unconditionally, and probably faster than checking.
        (when user-head-var
          (setq answer
                `(progn ,answer
                        (setq ,user-head-var (cdr ,head-var)))))
        answer))))


(defmacro loop-collect-answer (head-var &optional user-head-var)
  (or user-head-var
      `(cdr ,head-var)))


;;;; Maximization Technology


#|
The basic idea of all this minimax randomness here is that we have to
have constructed all uses of maximize and minimize to a particular
"destination" before we can decide how to code them.  The goal is to not
have to have any kinds of flags, by knowing both that (1) the type is
something which we can provide an initial minimum or maximum value for
and (2) know that a MAXIMIZE and MINIMIZE are not being combined.

SO, we have a datastructure which we annotate with all sorts of things,
incrementally updating it as we generate loop body code, and then use
a wrapper and internal macros to do the coding when the loop has been
constructed.
|#


(defstruct (loop-minimax
             #+ecl (:type vector)
             (:constructor make-loop-minimax-internal)
             #+nil (:copier nil)
             #+nil (:predicate nil))
  answer-variable
  type
  temp-variable
  flag-variable
  operations
  infinity-data)


(defparameter *loop-minimax-type-infinities-alist*
  ;; This is the sort of value this should take on for a Lisp that has
  ;; "eminently usable" infinities.  n.b. there are neither constants nor
  ;; printed representations for infinities defined by CL.
  ;; This grotesque read-from-string below is to help implementations
  ;; which croak on the infinity character when it appears in a token, even
  ;; conditionalized out.
#|
          '((fixnum             most-positive-fixnum                    most-negative-fixnum)
            (short-float        ext:single-float-positive-infinity      ext:single-float-negative-infinity)
            (single-float       ext:single-float-positive-infinity      ext:single-float-negative-infinity)
            (double-float       ext:double-float-positive-infinity      ext:double-float-negative-infinity)
            (long-float         ext:long-float-positive-infinity        ext:long-float-negative-infinity))
|#
  ;; If we don't know, then we cannot provide "infinite" initial values for any of the
  ;; types but FIXNUM:
  '((fixnum             most-positive-fixnum            most-negative-fixnum))
  )


(defun make-loop-minimax (answer-variable type)
  (declare (si::c-local))
  (let ((infinity-data (cdr (assoc type *loop-minimax-type-infinities-alist* :test #'subtypep))))
    (make-loop-minimax-internal
      :answer-variable answer-variable
      :type type
      :temp-variable (gensym "LOOP-MAXMIN-TEMP-")
      :flag-variable (and (not infinity-data) (gensym "LOOP-MAXMIN-FLAG-"))
      :operations nil
      :infinity-data infinity-data)))


(defun loop-note-minimax-operation (operation minimax)
  (declare (si::c-local))
  (pushnew (truly-the symbol operation) (loop-minimax-operations minimax))
  (when (and (cdr (loop-minimax-operations minimax))
             (not (loop-minimax-flag-variable minimax)))
    (setf (loop-minimax-flag-variable minimax) (gensym "LOOP-MAXMIN-FLAG-")))
  operation)


(defmacro with-minimax-value (lm &body body)
  (let ((init (loop-typed-init (loop-minimax-type lm)))
        (which (car (loop-minimax-operations lm)))
        (infinity-data (loop-minimax-infinity-data lm))
        (answer-var (loop-minimax-answer-variable lm))
        (temp-var (loop-minimax-temp-variable lm))
        (flag-var (loop-minimax-flag-variable lm))
        (type (loop-minimax-type lm)))
    (if flag-var
        `(let ((,answer-var ,init) (,temp-var ,init) (,flag-var nil))
           (declare (type ,type ,answer-var ,temp-var))
           ,@body)
        `(let ((,answer-var ,(if (eq which 'min) (first infinity-data) (second infinity-data)))
               (,temp-var ,init))
           (declare (type ,type ,answer-var ,temp-var))
           ,@body))))


(defmacro loop-accumulate-minimax-value (lm operation form)
  (let* ((answer-var (loop-minimax-answer-variable lm))
         (temp-var (loop-minimax-temp-variable lm))
         (flag-var (loop-minimax-flag-variable lm))
         (test `(,(ecase operation
                    (min '<)
                    (max '>))
                  ,temp-var ,answer-var)))
    `(progn
       (setq ,temp-var ,form)
       (when ,(if flag-var `(or (not ,flag-var) ,test) test)
         (setq ,@(and flag-var `(,flag-var t))
               ,answer-var ,temp-var)))))



;;;; Loop Keyword Tables


#|
LOOP keyword tables are hash tables string keys and a test of EQUAL.

The actual descriptive/dispatch structure used by LOOP is called a "loop
universe" contains a few tables and parameterizations.  The basic idea is
that we can provide a non-extensible ANSI-compatible loop environment,
an extensible ANSI-superset loop environment, and (for such environments
as CLOE) one which is "sufficiently close" to the old Genera-vintage
LOOP for use by old user programs without requiring all of the old LOOP
code to be loaded.
|#


;;;; Token Hackery


;;;Compare two "tokens".  The first is the frob out of *LOOP-SOURCE-CODE*,
;;; the second a symbol to check against.
(defun loop-tequal (x1 x2)
  (declare (si::c-local))
  (and (symbolp x1) (string= x1 x2)))


(defun loop-tassoc (kwd alist)
  (declare (si::c-local))
  (and (symbolp kwd) (assoc kwd alist :test #'string=)))


(defun loop-tmember (kwd list)
  (declare (si::c-local))
  (and (symbolp kwd) (member kwd list :test #'string=)))


(defun loop-lookup-keyword (loop-token table)
  (declare (si::c-local))
  (and (symbolp loop-token)
       (values (gethash (symbol-name loop-token) table))))


(defmacro loop-store-table-data (symbol table datum)
  `(setf (gethash (symbol-name ,symbol) ,table) ,datum))


(defstruct (loop-universe
             #+ecl (:type vector)
             #-ecl (:print-function print-loop-universe)
             #+nil (:copier nil)
             #+nil (:predicate nil))
  keywords                                      ;hash table, value = (fn-name . extra-data).
  iteration-keywords                            ;hash table, value = (fn-name . extra-data).
  for-keywords                                  ;hash table, value = (fn-name . extra-data).
  path-keywords                                 ;hash table, value = (fn-name . extra-data).
  type-symbols                                  ;hash table of type SYMBOLS, test EQ, value = CL type specifier.
  type-keywords                                 ;hash table of type STRINGS, test EQUAL, value = CL type spec.
  ansi                                          ;NIL, T, or :EXTENDED.
  implicit-for-required                         ;see loop-hack-iteration
  )


#-ecl
(defun print-loop-universe (u stream level)
  (declare (ignore level))
  (let ((str (case (loop-universe-ansi u)
               ((nil) "Non-ANSI")
               ((t) "ANSI")
               (:extended "Extended-ANSI")
               (t (loop-universe-ansi u)))))
    (format stream "#<~S ~A>" (type-of u) str)))


;;;This is the "current" loop context in use when we are expanding a
;;;loop.  It gets bound on each invocation of LOOP.
(defvar *loop-universe*)


(defun make-standard-loop-universe (&key keywords for-keywords iteration-keywords path-keywords
                                    type-keywords type-symbols ansi)
  (declare (si::c-local))
  (flet ((maketable (entries)
           (let* ((size (length entries))
                  (ht (make-hash-table :size (if (< size 10) 10 size) :test #'equal)))
             (dolist (x entries) (setf (gethash (symbol-name (car x)) ht) (cadr x)))
             ht)))
    (make-loop-universe
      :keywords (maketable keywords)
      :for-keywords (maketable for-keywords)
      :iteration-keywords (maketable iteration-keywords)
      :path-keywords (maketable path-keywords)
      :ansi ansi
      :implicit-for-required (not (null ansi))
      :type-keywords (maketable type-keywords)
      :type-symbols (let* ((size (length type-symbols))
                           (ht (make-hash-table :size (if (< size 10) 10 size) :test #'eq)))
                      (dolist (x type-symbols)
                        (if (atom x) (setf (gethash x ht) x) (setf (gethash (car x) ht) (cadr x))))
                      ht)))) 


;;;; Setq Hackery


(defparameter *loop-destructuring-hooks*
        nil
  "If not NIL, this must be a list of two things:
a LET-like macro, and a SETQ-like macro, which perform LOOP-style destructuring.")


(defun loop-make-psetq (frobs)
  (declare (si::c-local))
  (and frobs
       (loop-make-desetq
         (list (car frobs)
               (if (null (cddr frobs)) (cadr frobs)
                   `(prog1 ,(cadr frobs)
                           ,(loop-make-psetq (cddr frobs))))))))


(defun loop-make-desetq (var-val-pairs)
  (declare (si::c-local))
  (if (null var-val-pairs)
      nil
      (cons (if *loop-destructuring-hooks*
                (cadr *loop-destructuring-hooks*)
                'loop-really-desetq)
            var-val-pairs)))


(defparameter *loop-desetq-temporary*
        (make-symbol "LOOP-DESETQ-TEMP"))


(defmacro loop-really-desetq (&environment env &rest var-val-pairs)
  (labels ((find-non-null (var)
             ;; see if there's any non-null thing here
             ;; recurse if the list element is itself a list
             (do ((tail var)) ((not (consp tail)) tail)
               (when (find-non-null (pop tail)) (return t))))
           (loop-desetq-internal (var val &optional temp)
             ;; if the value is declared 'unsafe', then the assignemnt
             ;; is also unsafe.
             (when (and (consp val)
                        (eq (first val) 'LOOP-UNSAFE))
               (let ((forms (rest val)))
                 (setf forms (if (rest forms) `(progn ,@forms) (first forms)))
                 (return-from loop-desetq-internal
                   `((LOOP-UNSAFE ,@(loop-desetq-internal var forms))))))
             ;; returns a list of actions to be performed
             (typecase var
               (null
                 (when (consp val)
                   ;; don't lose possible side-effects
                   (if (eq (car val) 'prog1)
                       ;; these can come from psetq or desetq below.
                       ;; throw away the value, keep the side-effects.
                       ;;Special case is for handling an expanded POP.
                       (mapcan #'(lambda (x)
                                   (and (consp x)
                                        (or (not (eq (car x) 'car))
                                            (not (symbolp (cadr x)))
                                            (not (symbolp (setq x (macroexpand x env)))))
                                        (cons x nil)))
                               (cdr val))
                       `(,val))))
               (cons
                 (let* ((car (car var))
                        (cdr (cdr var))
                        (car-non-null (find-non-null car))
                        (cdr-non-null (find-non-null cdr)))
                   (when (or car-non-null cdr-non-null)
                     (if cdr-non-null
                         (let* ((temp-p temp)
                                (temp (or temp *loop-desetq-temporary*))
                                (body `(,@(loop-desetq-internal car `(car ,temp))
                                          (setq ,temp (cdr ,temp))
                                          ,@(loop-desetq-internal cdr temp temp))))
                           (if temp-p
                               `(,@(unless (eq temp val)
                                     `((setq ,temp ,val)))
                                 ,@body)
                               `((let ((,temp ,val))
                                   ,@body))))
                         ;; no cdring to do
                         (loop-desetq-internal car `(car ,val) temp)))))
               (otherwise
                 (unless (eq var val)
                   `((setq ,var ,val)))))))
    (do ((actions))
        ((null var-val-pairs)
         (if (null (cdr actions)) (car actions) `(progn ,@(nreverse actions))))
      (setq actions (revappend
                      (loop-desetq-internal (pop var-val-pairs) (pop var-val-pairs))
                      actions)))))


;;;; LOOP-local variables

;;;This is the "current" pointer into the LOOP source code.
(defvar *loop-source-code*)


;;;This is the pointer to the original, for things like NAMED that
;;;insist on being in a particular position
(defvar *loop-original-source-code*)


;;;This is *loop-source-code* as of the "last" clause.  It is used
;;;primarily for generating error messages (see loop-error, loop-warn).
(defvar *loop-source-context*)


;;;List of names for the LOOP, supplied by the NAMED clause.
(defvar *loop-names*)

;;;The macroexpansion environment given to the macro.
(defvar *loop-macro-environment*)

;;;This holds variable names specified with the USING clause.
;;; See LOOP-NAMED-VARIABLE.
(defvar *loop-named-variables*)

;;; LETlist-like list being accumulated for one group of parallel bindings.
(defvar *loop-variables*)

;;;List of declarations being accumulated in parallel with
;;;*loop-variables*.
(defvar *loop-declarations*)

;;;Used by LOOP for destructuring binding, if it is doing that itself.
;;; See loop-make-variable.
(defvar *loop-desetq-crocks*)

;;; List of wrapping forms, innermost first, which go immediately inside
;;; the current set of parallel bindings being accumulated in
;;; *loop-variables*.  The wrappers are appended onto a body.  E.g.,
;;; this list could conceivably has as its value ((with-open-file (g0001
;;; g0002 ...))), with g0002 being one of the bindings in
;;; *loop-variables* (this is why the wrappers go inside of the variable
;;; bindings).
(defvar *loop-wrappers*)

;;;This accumulates lists of previous values of *loop-variables* and the
;;;other lists  above, for each new nesting of bindings.  See
;;;loop-bind-block.
(defvar *loop-bind-stack*)

;;;This is a LOOP-global variable for the (obsolete) NODECLARE clause
;;;which inhibits  LOOP from actually outputting a type declaration for
;;;an iteration (or any) variable.
(defvar *loop-nodeclare*)

;;;This is simply a list of LOOP iteration variables, used for checking
;;;for duplications.
(defvar *loop-iteration-variables*)


;;;List of prologue forms of the loop, accumulated in reverse order.
(defvar *loop-prologue*)

(defvar *loop-before-loop*)
(defvar *loop-body*)
(defvar *loop-after-body*)

;;;This is T if we have emitted any body code, so that iteration driving
;;;clauses can be disallowed.   This is not strictly the same as
;;;checking *loop-body*, because we permit some clauses  such as RETURN
;;;to not be considered "real" body (so as to permit the user to "code"
;;;an  abnormal return value "in loop").
(defvar *loop-emitted-body*)


;;;List of epilogue forms (supplied by FINALLY generally), accumulated
;;; in reverse order.
(defvar *loop-epilogue*)

;;;List of epilogue forms which are supplied after the above "user"
;;;epilogue.  "normal" termination return values are provide by putting
;;;the return form in here.  Normally this is done using
;;;loop-emit-final-value, q.v.
(defvar *loop-after-epilogue*)

;;;The "culprit" responsible for supplying a final value from the loop.
;;;This  is so loop-emit-final-value can moan about multiple return
;;;values being supplied.
(defvar *loop-final-value-culprit*)

;;;If not NIL, we are in some branch of a conditional.  Some clauses may
;;;be disallowed.
(defvar *loop-inside-conditional*)

;;;If not NIL, this is a temporary bound around the loop for holding the
;;;temporary  value for "it" in things like "when (f) collect it".  It
;;;may be used as a supertemporary by some other things.
(defvar *loop-when-it-variable*)

;;;Sometimes we decide we need to fold together parts of the loop, but
;;;some part of the generated iteration  code is different for the first
;;;and remaining iterations.  This variable will be the temporary which 
;;;is the flag used in the loop to tell whether we are in the first or
;;;remaining iterations.
(defvar *loop-never-stepped-variable*)

;;;List of all the value-accumulation descriptor structures in the loop.
;;; See loop-get-collection-info.
(defvar *loop-collection-cruft*)                ; for multiple COLLECTs (etc)


;;;; Code Analysis Stuff


(defun loop-constant-fold-if-possible (form &optional expected-type)
  (declare (si::c-local))
  (let ((new-form form) (constantp nil) (constant-value nil))
    (when (setq constantp (constantp new-form))
      (setq constant-value (eval new-form)))
    (when (and constantp expected-type)
      (unless (typep constant-value expected-type)
        (loop-warn "The form ~S evaluated to ~S, which was not of the anticipated type ~S."
                   form constant-value expected-type)
        (setq constantp nil constant-value nil)))
    (values new-form constantp constant-value)))


;;;; LOOP Iteration Optimization

(defparameter *loop-duplicate-code*
        nil)


(defparameter *loop-iteration-flag-variable*
        (make-symbol "LOOP-NOT-FIRST-TIME"))


(defmacro loop-body (&environment env
                     prologue
                     before-loop
                     main-body
                     after-loop
                     epilogue)
  (declare (ignore env))
  (unless (= (length before-loop) (length after-loop))
    (error "LOOP-BODY called with non-synched before- and after-loop lists."))
  ;;All our work is done from these copies, working backwards from the end:
  (let ((rbefore (reverse before-loop))
        (rafter (reverse after-loop)))
    ;; Go backwards from the ends of before-loop and after-loop
    ;; merging all the equivalent forms into the body.
    (do ()
        ((or (null rbefore)
             (not (equal (car rbefore) (car rafter)))))
      (push (pop rbefore) main-body)
      (pop rafter))
    `(tagbody
        ,@(remove nil prologue)
        ,@(nreverse (remove nil rbefore))
      next-loop
        ,@(remove nil main-body)
        ,@(nreverse (remove nil rafter))
        (go next-loop)
      end-loop
        ,@(remove nil epilogue))))

;;;; Loop Errors


(defun loop-context ()
  (declare (si::c-local))
  (do ((l *loop-source-context* (cdr l)) (new nil (cons (car l) new)))
      ((eq l (cdr *loop-source-code*)) (nreverse new))))


(defun loop-error (format-string &rest format-args)
  (declare (si::c-local))
  (si::simple-program-error "~?~%Current LOOP context:~{ ~S~}."
                        format-string format-args (loop-context)))


(defun loop-warn (format-string &rest format-args)
  (declare (si::c-local))
  (warn 'sys::simple-style-warning
        :format-control "~?~%Current LOOP context:~{ ~S~}."
        :format-arguments (list format-string format-args (loop-context))))


(defun loop-check-data-type (specified-type required-type
                             &optional (default-type required-type))
  (declare (si::c-local))
  (if (null specified-type)
      default-type
      (multiple-value-bind (a b) (subtypep specified-type required-type)
        (cond ((not b)
               (loop-warn "LOOP couldn't verify that ~S is a subtype of the required type ~S."
                          specified-type required-type))
              ((not a)
               (loop-error "Specified data type ~S is not a subtype of ~S."
                           specified-type required-type)))
        specified-type)))


;;;INTERFACE: Traditional, ANSI, Lucid.
(defmacro loop-finish () 
  "Causes the iteration to terminate \"normally\", the same as implicit
termination by an iteration driving clause, or by use of WHILE or
UNTIL -- the epilogue code (if any) will be run, and any implicitly
collected result will be returned as the value of the LOOP."
  '(go end-loop))

(defun subst-gensyms-for-nil (tree)
  (declare (special *ignores*))
  (cond
    ((null tree) (car (push (gensym) *ignores*)))
    ((atom tree) tree)
    (t (cons (subst-gensyms-for-nil (car tree))
             (subst-gensyms-for-nil (cdr tree))))))
 
(defun loop-build-destructuring-bindings (crocks forms)
  (if crocks
      (let ((*ignores* ()))
        (declare (special *ignores*))
        `((destructuring-bind ,(subst-gensyms-for-nil (car crocks))
              ,(cadr crocks)
            (declare (ignore ,@*ignores*))
            ,@(loop-build-destructuring-bindings (cddr crocks) forms))))
      forms))

(defun loop-translate (*loop-source-code* *loop-macro-environment* *loop-universe*)
  (declare (si::c-local))
  (let ((*loop-original-source-code* *loop-source-code*)
        (*loop-source-context* nil)
        (*loop-iteration-variables* nil)
        (*loop-variables* nil)
        (*loop-nodeclare* nil)
        (*loop-named-variables* nil)
        (*loop-declarations* nil)
        (*loop-desetq-crocks* nil)
        (*loop-bind-stack* nil)
        (*loop-prologue* nil)
        (*loop-wrappers* nil)
        (*loop-before-loop* nil)
        (*loop-body* nil)
        (*loop-emitted-body* nil)
        (*loop-after-body* nil)
        (*loop-epilogue* nil)
        (*loop-after-epilogue* nil)
        (*loop-final-value-culprit* nil)
        (*loop-inside-conditional* nil)
        (*loop-when-it-variable* nil)
        (*loop-never-stepped-variable* nil)
        (*loop-names* nil)
        (*loop-collection-cruft* nil))
    (loop-iteration-driver)
    (loop-bind-block)
    (let ((answer `(loop-body
                     ,(nreverse *loop-prologue*)
                     ,(nreverse *loop-before-loop*)
                     ,(nreverse *loop-body*)
                     ,(nreverse *loop-after-body*)
                     ,(nreconc *loop-epilogue* (nreverse *loop-after-epilogue*)))))
      (dolist (entry *loop-bind-stack*)
        (let ((vars (first entry))
              (dcls (second entry))
              (crocks (third entry))
              (wrappers (fourth entry)))
          (dolist (w wrappers)
            (setq answer (append w (list answer))))
          (when (or vars dcls crocks)
            (let ((forms (list answer)))
              ;;(when crocks (push crocks forms))
              (when dcls (push `(declare ,@dcls) forms))
              (setq answer `(,(cond ((not vars) 'locally)
                                    (*loop-destructuring-hooks* (first *loop-destructuring-hooks*))
                                    (t 'let))
                             ,vars
                             ,@(loop-build-destructuring-bindings crocks forms)))))))
      (if *loop-names*
          (do () ((null (car *loop-names*)) answer)
            (setq answer `(block ,(pop *loop-names*) ,answer)))
          `(block nil ,answer)))))


(defun loop-iteration-driver ()
  (declare (si::c-local))
  (do () ((null *loop-source-code*))
    (let ((keyword (car *loop-source-code*)) (tem nil))
      (cond ((not (symbolp keyword))
             (loop-error "~S found where LOOP keyword expected." keyword))
            (t (setq *loop-source-context* *loop-source-code*)
               (loop-pop-source)
               (cond ((setq tem (loop-lookup-keyword keyword (loop-universe-keywords *loop-universe*)))
                      ;;It's a "miscellaneous" toplevel LOOP keyword (do, collect, named, etc.)
                      (apply (symbol-function (first tem)) (rest tem)))
                     ((setq tem (loop-lookup-keyword keyword (loop-universe-iteration-keywords *loop-universe*)))
                      (loop-hack-iteration tem))
                     ((loop-tmember keyword '(and else))
                      ;; Alternative is to ignore it, ie let it go around to the next keyword...
                      (loop-error "Secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..."
                                  keyword (car *loop-source-code*) (cadr *loop-source-code*)))
                     (t (loop-error "~S is an unknown keyword in LOOP macro." keyword))))))))



(defun loop-pop-source ()
  (declare (si::c-local))
  (if *loop-source-code*
      (pop *loop-source-code*)
      (loop-error "LOOP source code ran out when another token was expected.")))


(defun loop-get-compound-form ()
  (declare (si::c-local))
  (let ((form (loop-get-form)))
    (unless (consp form)
      (loop-error "Compound form expected, but found ~A." form))
    form))

(defun loop-get-progn ()
  (declare (si::c-local))
  (do ((forms (list (loop-get-compound-form))
              (cons (loop-get-compound-form) forms))
       (nextform (car *loop-source-code*)
                 (car *loop-source-code*)))
      ((atom nextform)
       (if (null (cdr forms)) (car forms) (cons 'progn (nreverse forms))))))


(defun loop-get-form ()
  (declare (si::c-local))
  (if *loop-source-code*
      (loop-pop-source)
      (loop-error "LOOP code ran out where a form was expected.")))


(defun loop-construct-return (form)
  (declare (si::c-local))
  `(return-from ,(car *loop-names*) ,form))

(defun loop-pseudo-body (form)
  (declare (si::c-local))
  (cond ((or *loop-emitted-body* *loop-inside-conditional*)
         (push form *loop-body*))
        (t (push form *loop-before-loop*) (push form *loop-after-body*))))

(defun loop-emit-body (form)
  (declare (si::c-local))
  (setq *loop-emitted-body* t)
  (push form *loop-body*))

(defun loop-emit-final-value (&optional (form nil form-supplied-p))
  (declare (si::c-local))
  (when form-supplied-p
    (push (loop-construct-return form) *loop-after-epilogue*))
  (when *loop-final-value-culprit*
    (loop-warn "LOOP clause is providing a value for the iteration,~@
                however one was already established by a ~S clause."
               *loop-final-value-culprit*))
  (setq *loop-final-value-culprit* (car *loop-source-context*)))


(defun loop-disallow-conditional (&optional kwd)
  (declare (si::c-local))
  (when *loop-inside-conditional*
    (loop-error "~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a conditional." kwd)))

(defun loop-disallow-anonymous-collectors ()
  (when (find-if-not 'loop-collector-name *loop-collection-cruft*)
    (loop-error "This LOOP clause is not permitted with anonymous collectors.")))

(defun loop-disallow-aggregate-booleans ()
  (when (loop-tmember *loop-final-value-culprit* '(always never thereis))
    (loop-error "This anonymous collection LOOP clause is not permitted with aggregate booleans.")))



;;;; Loop Types


(defun loop-typed-init (data-type)
  (declare (si::c-local))
  (cond ((null data-type)
         nil)
        ((subtypep data-type 'character)
         #\0)
        ((not (subtypep data-type 'number))
         nil)
        ((subtypep data-type '(or float (complex float)))
         (coerce 0 data-type))
        (t
         0)))

(defun loop-optional-type (&optional variable)
  (declare (si::c-local))
  ;;No variable specified implies that no destructuring is permissible.
  (and *loop-source-code*                       ;Don't get confused by NILs...
       (let ((z (car *loop-source-code*)))
         (cond ((loop-tequal z 'of-type)
                ;;This is the syntactically unambigous form in that the form of the
                ;; type specifier does not matter.  Also, it is assumed that the
                ;; type specifier is unambiguously, and without need of translation,
                ;; a common lisp type specifier or pattern (matching the variable) thereof.
                (loop-pop-source)
                (loop-pop-source))
                      
               ((symbolp z)
                ;;This is the (sort of) "old" syntax, even though we didn't used to support all of
                ;; these type symbols.
                (let ((type-spec (or (gethash z (loop-universe-type-symbols *loop-universe*))
                                     (gethash (symbol-name z) (loop-universe-type-keywords *loop-universe*)))))
                  (when type-spec
                    (loop-pop-source)
                    type-spec)))
               (t 
                ;;This is our sort-of old syntax.  But this is only valid for when we are destructuring,
                ;; so we will be compulsive (should we really be?) and require that we in fact be
                ;; doing variable destructuring here.  We must translate the old keyword pattern typespec
                ;; into a fully-specified pattern of real type specifiers here.
                (if (consp variable)
                    (unless (consp z)
                     (loop-error
                        "~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern expected."
                        z))
                    (loop-error "~S found where a LOOP keyword or LOOP type keyword expected." z))
                (loop-pop-source)
                (labels ((translate (k v)
                           (cond ((null k) nil)
                                 ((atom k)
                                  (replicate
                                    (or (gethash k (loop-universe-type-symbols *loop-universe*))
                                        (gethash (symbol-name k) (loop-universe-type-keywords *loop-universe*))
                                        (loop-error
                                          "Destructuring type pattern ~S contains unrecognized type keyword ~S."
                                          z k))
                                    v))
                                 ((atom v)
                                  (loop-error
                                    "Destructuring type pattern ~S doesn't match variable pattern ~S."
                                    z variable))
                                 (t (cons (translate (car k) (car v)) (translate (cdr k) (cdr v))))))
                         (replicate (typ v)
                           (if (atom v) typ (cons (replicate typ (car v)) (replicate typ (cdr v))))))
                  (translate z variable)))))))



;;;; Loop Variables


(defun loop-bind-block ()
  (declare (si::c-local))
  (when (or *loop-variables* *loop-declarations* *loop-wrappers*)
    (push (list (nreverse *loop-variables*) *loop-declarations* *loop-desetq-crocks* *loop-wrappers*)
          *loop-bind-stack*)
    (setq *loop-variables* nil
          *loop-declarations* nil
          *loop-desetq-crocks* nil
          *loop-wrappers* nil)))

(defun loop-variable-p (name)
  (do ((entry *loop-bind-stack* (cdr entry))) (nil)
    (cond ((null entry)
           (return nil))
          ((assoc name (caar entry) :test #'eq)
           (return t)))))

(defun loop-make-variable (name initialization dtype &optional iteration-variable-p)
  (declare (si::c-local))
  (cond ((null name)
         (cond ((not (null initialization))
                (push (list (setq name (gensym "LOOP-IGNORE-"))
                            initialization)
                      *loop-variables*)
                (push `(ignore ,name) *loop-declarations*))))
        ((atom name)
         (cond (iteration-variable-p
                (if (member name *loop-iteration-variables*)
                    (loop-error "Duplicated LOOP iteration variable ~S." name)
                    (push name *loop-iteration-variables*)))
               ((assoc name *loop-variables*)
                (loop-error "Duplicated variable ~S in LOOP parallel binding." name)))
         (unless (symbolp name)
           (loop-error "Bad variable ~S somewhere in LOOP." name))
         (loop-declare-variable name dtype)
         ;; We use ASSOC on this list to check for duplications (above),
         ;; so don't optimize out this list:
         (push (list name (or initialization (loop-typed-init dtype)))
               *loop-variables*))
        (initialization
         (cond (*loop-destructuring-hooks*
                (loop-declare-variable name dtype)
                (push (list name initialization) *loop-variables*))
               (t (let ((newvar (gensym "LOOP-DESTRUCTURE-")))
                    (loop-declare-variable name dtype)
                    (push (list newvar initialization) *loop-variables*)
                    ;; *LOOP-DESETQ-CROCKS* gathered in reverse order.
                    (setq *loop-desetq-crocks*
                      (list* name newvar *loop-desetq-crocks*))
                    #+ignore
                    (loop-make-variable name nil dtype iteration-variable-p)))))
        (t (let ((tcar nil) (tcdr nil))
             (if (atom dtype) (setq tcar (setq tcdr dtype))
                 (setq tcar (car dtype) tcdr (cdr dtype)))
             (loop-make-variable (car name) nil tcar iteration-variable-p)
             (loop-make-variable (cdr name) nil tcdr iteration-variable-p))))
  name)


(defun loop-make-iteration-variable (name initialization dtype)
  (declare (si::c-local))
  (loop-make-variable name initialization dtype t))


(defun loop-declare-variable (name dtype)
  (declare (si::c-local))
  (cond ((or (null name) (null dtype) (eq dtype t)) nil)
        ((symbolp name)
         (unless (or (eq dtype t) (member (truly-the symbol name) *loop-nodeclare*))
           ;; Allow redeclaration of a variable. This can be used by
           ;; the loop constructors to make the type more and more
           ;; precise as we add keywords
           (let ((previous (find name *loop-declarations*
                                 :key #'(lambda (d)
                                          (and (consp d)
                                               (= (length d) 3)
                                               (eq (cons-car d) 'type)
                                               (third d))))))
             (if previous
                 (setf (second previous) dtype)
                 (push `(type ,dtype ,name) *loop-declarations*)))))
        ((consp name)
         (cond ((consp dtype)
                (loop-declare-variable (car name) (car dtype))
                (loop-declare-variable (cdr name) (cdr dtype)))
               (t (loop-declare-variable (car name) dtype)
                  (loop-declare-variable (cdr name) dtype))))
        (t (error "Invalid LOOP variable passed in: ~S." name))))


(defun loop-maybe-bind-form (form data-type)
  (declare (si::c-local))
  (if (constantp form *loop-macro-environment*)
      form
      (loop-make-variable (gensym "LOOP-BIND-") form data-type)))



(defun loop-do-if (for negatep)
  (let ((form (loop-get-form))
        (*loop-inside-conditional* t)
        (it-p nil)
        (first-clause-p t))
    (flet ((get-clause (for)
             (do ((body nil)) (nil)
               (let ((key (car *loop-source-code*)) (*loop-body* nil) data)
                 (cond ((not (symbolp key))
                        (loop-error
                          "~S found where keyword expected getting LOOP clause after ~S."
                          key for))
                       (t (setq *loop-source-context* *loop-source-code*)
                          (loop-pop-source)
                          (when (and (loop-tequal (car *loop-source-code*) 'it)
                                     first-clause-p)
                            (setq *loop-source-code*
                                  (cons (or it-p (setq it-p (loop-when-it-variable)))
                                        (cdr *loop-source-code*))))
                          (cond ((or (not (setq data (loop-lookup-keyword
                                                       key (loop-universe-keywords *loop-universe*))))
                                     (progn (apply (symbol-function (car data)) (cdr data))
                                            (null *loop-body*)))
                                 (loop-error
                                   "~S does not introduce a LOOP clause that can follow ~S."
                                   key for))
                                (t (setq body (nreconc *loop-body* body)))))))
               (setq first-clause-p nil)
               (if (loop-tequal (car *loop-source-code*) :and)
                   (loop-pop-source)
                   (return (if (cdr body) `(progn ,@(nreverse body)) (car body)))))))
      (let ((then (get-clause for))
            (else (when (loop-tequal (car *loop-source-code*) :else)
                    (loop-pop-source)
                    (list (get-clause :else)))))
        (when (loop-tequal (car *loop-source-code*) :end)
          (loop-pop-source))
        (when it-p (setq form `(setq ,it-p ,form)))
        (loop-pseudo-body
          `(if ,(if negatep `(not ,form) form)
               ,then
               ,@else))))))


(defun loop-do-initially ()
  (loop-disallow-conditional :initially)
  (push (loop-get-progn) *loop-prologue*))

(defun loop-do-finally ()
  (loop-disallow-conditional :finally)
  (push (loop-get-progn) *loop-epilogue*))

(defun loop-do-do ()
  (loop-emit-body (loop-get-progn)))

(defun loop-do-named ()
  (let ((name (loop-pop-source)))
    (unless (symbolp name)
      (loop-error "~S is an invalid name for your LOOP." name))
    (when (or *loop-before-loop* *loop-body* *loop-after-epilogue* *loop-inside-conditional*)
      (loop-error "The NAMED ~S clause occurs too late." name))
    (when *loop-names*
      (loop-error "You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S."
                  (car *loop-names*) name))
    (setq *loop-names* (list name nil))))

(defun loop-do-return ()
  (loop-emit-body (loop-construct-return (loop-get-form))))


;;;; Value Accumulation: List


(defstruct (loop-collector
             #+ecl (:type vector)
             #+nil (:copier nil)
             #+nil (:predicate nil))
  name
  class
  (history nil)
  (tempvars nil)
  dtype
  (data nil))                                           ;collector-specific data


(defun loop-get-collection-info (collector class default-type)
  (declare (si::c-local))
  (let ((form (loop-get-form))
        (dtype (and (not (loop-universe-ansi *loop-universe*)) (loop-optional-type)))
        (name (when (loop-tequal (car *loop-source-code*) 'into)
                (loop-pop-source)
                (loop-pop-source))))
    (when (not (symbolp name))
      (loop-error "Value accumulation recipient name, ~S, is not a symbol." name))
    (unless name
      (loop-disallow-aggregate-booleans))
    (unless dtype
      (setq dtype (or (loop-optional-type) default-type)))
    (let ((cruft (find (truly-the symbol name) *loop-collection-cruft*
                       :key #'loop-collector-name)))
      (cond ((not cruft)
             (when (and name (loop-variable-p name))
               (loop-error "Variable ~S cannot be used in INTO clause" name))
             (push (setq cruft (make-loop-collector
                                 :name name :class class
                                 :history (list collector) :dtype dtype))
                   *loop-collection-cruft*))
            (t (unless (eq (loop-collector-class cruft) class)
                 (loop-error
                   "Incompatible kinds of LOOP value accumulation specified for collecting~@
                    ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S."
                   name (car (loop-collector-history cruft)) collector))
               (unless (equal dtype (loop-collector-dtype cruft))
                 (loop-warn
                   "Unequal datatypes specified in different LOOP value accumulations~@
                   into ~S: ~S and ~S."
                   name dtype (loop-collector-dtype cruft))
                 (when (eq (loop-collector-dtype cruft) t)
                   (setf (loop-collector-dtype cruft) dtype)))
               (push collector (loop-collector-history cruft))))
      (values cruft form))))


(defun loop-list-collection (specifically)      ;NCONC, LIST, or APPEND
  (multiple-value-bind (lc form) (loop-get-collection-info specifically 'list 'list)
    (let ((tempvars (loop-collector-tempvars lc)))
      (unless tempvars
        (setf (loop-collector-tempvars lc)
              (setq tempvars (list* (gensym "LOOP-LIST-HEAD")
                                    (gensym "LOOP-LIST-TAIL")
                                    (and (loop-collector-name lc)
                                         (list (loop-collector-name lc))))))
        (push `(with-loop-list-collection-head ,tempvars) *loop-wrappers*)
        (unless (loop-collector-name lc)
          (loop-emit-final-value `(loop-collect-answer ,(car tempvars) ,@(cddr tempvars)))))
      (ecase specifically
        (list (setq form `(list ,form)))
        (nconc nil)
        (append (unless (and (consp form) (eq (car form) 'list))
                  (setq form `(copy-list ,form)))))
      (loop-emit-body `(loop-collect-rplacd ,tempvars ,form)))))


;;;; Value Accumulation: max, min, sum, count.



(defun loop-sum-collection (specifically required-type default-type)    ;SUM, COUNT
  (multiple-value-bind (lc form)
      (loop-get-collection-info specifically 'sum default-type)
    (loop-check-data-type (loop-collector-dtype lc) required-type)
    (let ((tempvars (loop-collector-tempvars lc)))
      (unless tempvars
        (setf (loop-collector-tempvars lc)
              (setq tempvars (list (loop-make-variable
                                     (or (loop-collector-name lc)
                                         (gensym "LOOP-SUM-"))
                                     nil (loop-collector-dtype lc)))))
        (unless (loop-collector-name lc)
          (loop-emit-final-value (car (loop-collector-tempvars lc)))))
      (loop-emit-body
        (if (eq specifically 'count)
            `(when ,form
               (setq ,(car tempvars)
                     (1+ ,(car tempvars))))
            `(setq ,(car tempvars)
                   (+ ,(car tempvars)
                      ,form)))))))



(defun loop-maxmin-collection (specifically)
  (multiple-value-bind (lc form)
      (loop-get-collection-info specifically 'maxmin 'real)
    (loop-check-data-type (loop-collector-dtype lc) 'real)
    (let ((data (loop-collector-data lc)))
      (unless data
        (setf (loop-collector-data lc)
              (setq data (make-loop-minimax
                           (or (loop-collector-name lc) (gensym "LOOP-MAXMIN-"))
                           (loop-collector-dtype lc))))
        (unless (loop-collector-name lc)
          (loop-emit-final-value (loop-minimax-answer-variable data))))
      (loop-note-minimax-operation specifically data)
      (push `(with-minimax-value ,data) *loop-wrappers*)
      (loop-emit-body `(loop-accumulate-minimax-value ,data ,specifically ,form))
      )))


;;;; Value Accumulation:  Aggregate Booleans

;;;ALWAYS and NEVER.
;;; Under ANSI these are not permitted to appear under conditionalization.
(defun loop-do-always (restrictive negate)
  (let ((form (loop-get-form)))
    (when restrictive (loop-disallow-conditional))
    (loop-disallow-anonymous-collectors)
    (loop-emit-body `(,(if negate 'when 'unless) ,form
                      ,(loop-construct-return nil)))
    (loop-emit-final-value t)))



;;;THERIS.
;;; Under ANSI this is not permitted to appear under conditionalization.
(defun loop-do-thereis (restrictive)
  (when restrictive (loop-disallow-conditional))
  (loop-disallow-anonymous-collectors)
  (loop-emit-final-value)
  (loop-emit-body `(when (setq ,(loop-when-it-variable) ,(loop-get-form))
                     ,(loop-construct-return *loop-when-it-variable*))))


(defun loop-do-while (negate kwd &aux (form (loop-get-form)))
  (loop-disallow-conditional kwd)
  (loop-pseudo-body `(,(if negate 'when 'unless) ,form (go end-loop))))


(defun loop-do-with ()
  (loop-disallow-conditional :with)
  (do ((var) (val) (dtype)) (nil)
    (setq var (loop-pop-source)
          dtype (loop-optional-type var)
          val (cond ((loop-tequal (car *loop-source-code*) :=)
                     (loop-pop-source)
                     (loop-get-form))
                    (t nil)))
    (when (and var (loop-variable-p var))
      (loop-error "Variable ~S has already been used" var))
    (loop-make-variable var val dtype)
    (if (loop-tequal (car *loop-source-code*) :and)
        (loop-pop-source)
        (return (loop-bind-block)))))


;;;; The iteration driver

(defun loop-hack-iteration (entry)
  (declare (si::c-local))
  (flet ((make-endtest (list-of-forms)
           (cond ((null list-of-forms) nil)
                 ((member t list-of-forms) '(go end-loop))
                 (t `(when ,(if (null (cdr (setq list-of-forms (nreverse list-of-forms))))
                                (car list-of-forms)
                                (cons 'or list-of-forms))
                       (go end-loop))))))
    (do ((pre-step-tests nil)
         (steps nil)
         (post-step-tests nil)
         (pseudo-steps nil)
         (pre-loop-pre-step-tests nil)
         (pre-loop-steps nil)
         (pre-loop-post-step-tests nil)
         (pre-loop-pseudo-steps nil)
         (tem) (data))
        (nil)
      ;; Note we collect endtests in reverse order, but steps in correct
      ;; order.  MAKE-ENDTEST does the nreverse for us.
      (setq tem (setq data (apply (symbol-function (first entry)) (rest entry))))
      (and (car tem) (push (car tem) pre-step-tests))
      (setq steps (nconc steps (copy-list (car (setq tem (cdr tem))))))
      (and (car (setq tem (cdr tem))) (push (car tem) post-step-tests))
      (setq pseudo-steps (nconc pseudo-steps (copy-list (car (setq tem (cdr tem))))))
      (setq tem (cdr tem))
      (when *loop-emitted-body*
        (loop-error "Iteration in LOOP follows body code. This error is typicall caused
by a WHILE, UNTIL or similar condition placed in between FOR, AS, and similar iterations.
Note that this is not a valid ANSI code."))
      (unless tem (setq tem data))
      (when (car tem) (push (car tem) pre-loop-pre-step-tests))
      (setq pre-loop-steps (nconc pre-loop-steps (copy-list (car (setq tem (cdr tem))))))
      (when (car (setq tem (cdr tem))) (push (car tem) pre-loop-post-step-tests))
      (setq pre-loop-pseudo-steps (nconc pre-loop-pseudo-steps (copy-list (cadr tem))))
      (unless (loop-tequal (car *loop-source-code*) :and)
        (setq *loop-before-loop* (list* (loop-make-desetq pre-loop-pseudo-steps)
                                        (make-endtest pre-loop-post-step-tests)
                                        (loop-make-psetq pre-loop-steps)
                                        (make-endtest pre-loop-pre-step-tests)
                                        *loop-before-loop*)
              *loop-after-body* (list* (loop-make-desetq pseudo-steps)
                                       (make-endtest post-step-tests)
                                       (loop-make-psetq steps)
                                       (make-endtest pre-step-tests)
                                       *loop-after-body*))
        (loop-bind-block)
        (return nil))
      (loop-pop-source)                         ; flush the "AND"
      (when (and (not (loop-universe-implicit-for-required *loop-universe*))
                 (setq tem (loop-lookup-keyword
                             (car *loop-source-code*)
                             (loop-universe-iteration-keywords *loop-universe*))))
        ;;Latest ANSI clarification is that the FOR/AS after the AND must NOT be supplied.
        (loop-pop-source)
        (setq entry tem)))))


;;;; Main Iteration Drivers


;FOR variable keyword ..args..
(defun loop-do-for ()
  (let* ((var (loop-pop-source))
         (data-type (loop-optional-type var))
         (keyword (loop-pop-source))
         (first-arg nil)
         (tem nil))
    (setq first-arg (loop-get-form))
    (unless (and (symbolp keyword)
                 (setq tem (loop-lookup-keyword
                             keyword
                             (loop-universe-for-keywords *loop-universe*))))
      (loop-error "~S is an unknown keyword in FOR or AS clause in LOOP." keyword))
    (apply (car tem) var first-arg data-type (cdr tem))))

(defun loop-do-repeat ()
  (loop-disallow-conditional :repeat)
  (let* ((form (loop-get-form))
         (type (if (fixnump form) 'fixnum 'real))
         (var (loop-make-variable (gensym) form type))
         (form `(loop-unsafe (when (minusp (decf ,var)) (go end-loop)))))
      (push form *loop-before-loop*)
      (push form *loop-after-body*)
      ;; FIXME: What should
      ;;   (loop count t into a
      ;;         repeat 3
      ;;         count t into b
      ;;         finally (return (list a b)))
      ;; return: (3 3) or (4 3)? PUSHes above are for the former
      ;; variant, L-P-B below for the latter.
      #+nil (loop-pseudo-body form)))

(defun loop-when-it-variable ()
  (declare (si::c-local))
  (or *loop-when-it-variable*
      (setq *loop-when-it-variable*
            (loop-make-variable (gensym "LOOP-IT-") nil nil))))


;;;; Various FOR/AS Subdispatches


;;;ANSI "FOR x = y [THEN z]" is sort of like the old Genera one when the THEN
;;; is omitted (other than being more stringent in its placement), and like
;;; the old "FOR x FIRST y THEN z" when the THEN is present.  I.e., the first
;;; initialization occurs in the loop body (first-step), not in the variable binding
;;; phase.
(defun loop-ansi-for-equals (var val data-type)
  (loop-make-iteration-variable var nil data-type)
  (cond ((loop-tequal (car *loop-source-code*) :then)
         ;;Then we are the same as "FOR x FIRST y THEN z".
         (loop-pop-source)
         `(() (,var ,(loop-get-form)) () ()
           () (,var ,val) () ()))
        (t ;;We are the same as "FOR x = y".
         `(() (,var ,val) () ()))))


(defun loop-for-across (var val data-type)
  (loop-make-iteration-variable var nil data-type)
  (let ((vector-var (gensym "LOOP-ACROSS-VECTOR-"))
        (index-var (gensym "LOOP-ACROSS-INDEX-")))
    (multiple-value-bind (vector-form constantp vector-value)
        (loop-constant-fold-if-possible val 'vector)
      (loop-make-variable
        vector-var vector-form
        (if (and (consp vector-form) (eq (car vector-form) 'the))
            (cadr vector-form)
            'vector))
      (loop-make-variable index-var 0 'fixnum)
      (let* ((length 0)
             (length-form (cond ((not constantp)
                                 (let ((v (gensym "LOOP-ACROSS-LIST")))
                                   (push `(setq ,v (length ,vector-var)) *loop-prologue*)
                                   (loop-make-variable v 0 'fixnum)))
                                (t (setq length (length vector-value)))))
             (first-test `(>= ,index-var ,length-form))
             (other-test first-test)
             (step `(,var (aref ,vector-var ,index-var)))
             (pstep `(,index-var (1+ ,index-var))))
        (declare (fixnum length))
        (when constantp
          (setq first-test (= length 0))
          (when (<= length 1)
            (setq other-test t)))
        `(,other-test ,step () ,pstep
          ,@(and (not (eq first-test other-test)) `(,first-test ,step () ,pstep)))))))



;;;; List Iteration


(defun loop-list-step (listvar)
  (declare (si::c-local))
  ;;We are not equipped to analyze whether 'FOO is the same as #'FOO here in any
  ;; sensible fashion, so let's give an obnoxious warning whenever 'FOO is used
  ;; as the stepping function.
  ;;While a Discerning Compiler may deal intelligently with (funcall 'foo ...), not
  ;; recognizing FOO may defeat some LOOP optimizations.
  (let ((stepper (cond ((loop-tequal (car *loop-source-code*) :by)
                        (loop-pop-source)
                        (loop-get-form))
                       (t '(function cons-cdr)))))
    (cond ((and (consp stepper) (eq (car stepper) 'quote))
           (loop-warn "Use of QUOTE around stepping function in LOOP will be left verbatim.")
           (values `(funcall ,stepper ,listvar) nil))
          ((and (consp stepper) (eq (car stepper) 'function))
           (values (list (cadr stepper) listvar) (cadr stepper)))
          (t (values `(funcall ,(loop-make-variable (gensym "LOOP-FN") stepper 'function)
                               ,listvar)
                     nil)))))


(defun loop-for-on (var val data-type)
  (multiple-value-bind (list constantp list-value)
      (loop-constant-fold-if-possible val)
    (let ((listvar var))
      (cond ((and var (symbolp var))
             (loop-make-iteration-variable var list data-type))
            (t
             ;; using data type 'list for listvar can lead to errors for dotted lists
             (loop-make-variable (setq listvar (gensym)) list nil)
             (loop-make-iteration-variable var nil data-type)))
      (let ((list-step (loop-list-step listvar)))
        (let* ((first-endtest
                 ;; mysterious comment from original CMU CL sources:
                 ;;   the following should use `atom' instead of `endp', per
                 ;;   [bug2428]
                 `(atom ,listvar))
               (other-endtest first-endtest))
          (when (and constantp (listp list-value))
            (setq first-endtest (null list-value)))
          (cond ((eq var listvar)
                 ;; The contour of the loop is different because we
                 ;; use the user's variable...
                 `(() (,listvar ,list-step)
                   ,other-endtest () () () ,first-endtest ()))
                (t (let ((step `(,var ,listvar))
                         (pseudo `(,listvar ,list-step)))
                     `(,other-endtest ,step () ,pseudo
                       ,@(and (not (eq first-endtest other-endtest))
                              `(,first-endtest ,step () ,pseudo)))))))))))


(defun loop-for-in (var val data-type)
  (multiple-value-bind (list constantp list-value)
      (loop-constant-fold-if-possible val)
    (let ((listvar (gensym "LOOP-LIST")))
      (loop-make-iteration-variable var nil data-type)
      (loop-make-variable listvar list 'list)
      (let ((list-step (loop-list-step listvar)))
        (let* ((first-endtest `(endp ,listvar))
               (other-endtest first-endtest)
               (step `(,var (cons-car ,listvar)))
               (pseudo-step `(,listvar ,list-step)))
          (when (and constantp (listp list-value))
            (setq first-endtest (null list-value)))
          `(,other-endtest ,step () ,pseudo-step
            ,@(and (not (eq first-endtest other-endtest))
                   `(,first-endtest ,step () ,pseudo-step))))))))


;;;; Iteration Paths


(defstruct (loop-path
             #+ecl (:type vector)
             #+nil (:copier nil)
             #+nil (:predicate nil))
  names
  preposition-groups
  inclusive-permitted
  function
  user-data)


(defun add-loop-path (names function universe &key preposition-groups inclusive-permitted user-data)
  (declare (si::c-local))
  (unless (listp names)
    (setq names (list names)))
  (let ((ht (loop-universe-path-keywords universe))
        (lp (make-loop-path
              :names (mapcar #'symbol-name names)
              :function function
              :user-data user-data
              :preposition-groups (mapcar #'(lambda (x) (if (listp x) x (list x))) preposition-groups)
              :inclusive-permitted inclusive-permitted)))
    (dolist (name names) (setf (gethash (symbol-name name) ht) lp))
    lp))


;;; Note:  path functions are allowed to use loop-make-variable, hack
;;; the prologue, etc.
(defun loop-for-being (var val data-type)
  ;; FOR var BEING each/the pathname prep-phrases using-stuff...
  ;; each/the = EACH or THE.  Not clear if it is optional, so I guess we'll warn.
  (let ((path nil)
        (data nil)
        (inclusive nil)
        (stuff nil)
        (initial-prepositions nil))
    (cond ((loop-tmember val '(:each :the)) (setq path (loop-pop-source)))
          ((loop-tequal (car *loop-source-code*) :and)
           (loop-pop-source)
           (setq inclusive t)
           (unless (loop-tmember (car *loop-source-code*) '(:its :each :his :her))
             (loop-error "~S found where ITS or EACH expected in LOOP iteration path syntax."
                         (car *loop-source-code*)))
           (loop-pop-source)
           (setq path (loop-pop-source))
           (setq initial-prepositions `((:in ,val))))
          (t (loop-error "Unrecognizable LOOP iteration path syntax.  Missing EACH or THE?")))
    (cond ((not (symbolp path))
           (loop-error "~S found where a LOOP iteration path name was expected." path))
          ((not (setq data (loop-lookup-keyword path (loop-universe-path-keywords *loop-universe*))))
           (loop-error "~S is not the name of a LOOP iteration path." path))
          ((and inclusive (not (loop-path-inclusive-permitted data)))
           (loop-error "\"Inclusive\" iteration is not possible with the ~S LOOP iteration path." path)))
    (let ((fun (loop-path-function data))
          (preps (nconc initial-prepositions
                        (loop-collect-prepositional-phrases (loop-path-preposition-groups data) t)))
          (user-data (loop-path-user-data data)))
      (when (symbolp fun) (setq fun (symbol-function fun)))
      (setq stuff (if inclusive
                      (apply fun var data-type preps :inclusive t user-data)
                      (apply fun var data-type preps user-data))))
    (when *loop-named-variables*
      (loop-error "Unused USING variables: ~S." *loop-named-variables*))
    ;; STUFF is now (bindings prologue-forms . stuff-to-pass-back).  Protect the system from the user
    ;; and the user from himself.
    (unless (member (length stuff) '(6 10))
      (loop-error "Value passed back by LOOP iteration path function for path ~S has invalid length."
                  path))
    (do ((l (car stuff) (cdr l)) (x)) ((null l))
      (if (atom (setq x (car l)))
          (loop-make-iteration-variable x nil nil)
          (loop-make-iteration-variable (car x) (cadr x) (caddr x))))
    (setq *loop-prologue* (nconc (reverse (cadr stuff)) *loop-prologue*))
    (cddr stuff)))



;;;INTERFACE:  Lucid, exported.
;;; i.e., this is part of our extended ansi-loop interface.
(defun loop-named-var (name)
  (declare (si::c-local))
  (let ((tem (loop-tassoc name *loop-named-variables*)))
    (declare (list tem))
    (cond ((null tem) (values (gensym) nil))
          (t (setq *loop-named-variables* (delete tem *loop-named-variables*))
             (values (cdr tem) t)))))


(defun loop-collect-prepositional-phrases (preposition-groups &optional USING-allowed initial-phrases)
  (declare (si::c-local))
  (flet ((in-group-p (x group) (car (loop-tmember x group))))
    (do ((token nil)
         (prepositional-phrases initial-phrases)
         (this-group nil nil)
         (this-prep nil nil)
         (disallowed-prepositions
           (mapcan #'(lambda (x)
                       (copy-list
                         (find (car x) preposition-groups :test #'in-group-p)))
                   initial-phrases))
         (used-prepositions (mapcar #'car initial-phrases)))
        ((null *loop-source-code*) (nreverse prepositional-phrases))
      (declare (symbol this-prep))
      (setq token (car *loop-source-code*))
      (dolist (group preposition-groups)
        (when (setq this-prep (in-group-p token group))
          (return (setq this-group group))))
      (cond (this-group
             (when (member this-prep disallowed-prepositions)
               (loop-error
                 (if (member this-prep used-prepositions)
                     "A ~S prepositional phrase occurs multiply for some LOOP clause."
                     "Preposition ~S used when some other preposition has subsumed it.")
                 token))
             (setq used-prepositions (if (listp this-group)
                                         (append this-group used-prepositions)
                                         (cons this-group used-prepositions)))
             (loop-pop-source)
             (push (list this-prep (loop-get-form)) prepositional-phrases))
            ((and USING-allowed (loop-tequal token 'using))
             (loop-pop-source)
             (do ((z (loop-pop-source) (loop-pop-source)) (tem)) (nil)
               (when (cadr z)
                 (if (setq tem (loop-tassoc (car z) *loop-named-variables*))
                     (loop-error
                       "The variable substitution for ~S occurs twice in a USING phrase,~@
                        with ~S and ~S."
                       (car z) (cadr z) (cadr tem))
                     (push (cons (car z) (cadr z)) *loop-named-variables*)))
               (when (or (null *loop-source-code*) (symbolp (car *loop-source-code*)))
                 (return nil))))
            (t (return (nreverse prepositional-phrases)))))))


;;;; Master Sequencer Function

(defun loop-sequencer (indexv indexv-type indexv-user-specified-p
                          variable variable-type
                          sequence-variable sequence-type
                          step-hack default-top
                          prep-phrases)
  (declare (si::c-local)
           (ignore indexv-user-specified-p))
   (let ((endform nil)                          ;Form (constant or variable) with limit value.
         (sequencep nil)                        ;T if sequence arg has been provided.
         (testfn nil)                           ;endtest function
         (test nil)                             ;endtest form.
         (stepby (1+ (or (loop-typed-init indexv-type) 0)))     ;Our increment.
         (stepby-constantp t)
         (step nil)                             ;step form.
         (dir nil)                              ;Direction of stepping: NIL, :UP, :DOWN.
         (inclusive-iteration nil)              ;T if include last index.
         (start-given nil)                      ;T when prep phrase has specified start
         (start-value nil)
         (start-constantp nil)
         (limit-given nil)                      ;T when prep phrase has specified end
         (limit-constantp nil)
         (limit-value nil)
         )
     (when variable (loop-make-iteration-variable variable nil variable-type))
     (do ((l prep-phrases (cdr l)) (prep) (form) (odir)) ((null l))
       (setq prep (caar l) form (cadar l))
       (case prep
         ((:of :in)
          (setq sequencep t)
          (loop-make-variable sequence-variable form sequence-type))
         ((:from :downfrom :upfrom)
          (setq start-given t)
          (cond ((eq prep :downfrom) (setq dir ':down))
                ((eq prep :upfrom) (setq dir ':up)))
          (multiple-value-setq (form start-constantp start-value)
            (loop-constant-fold-if-possible form indexv-type))
          (loop-make-iteration-variable indexv form indexv-type))
         ((:upto :to :downto :above :below)
          (cond ((loop-tequal prep :upto) (setq inclusive-iteration (setq dir ':up)))
                ((loop-tequal prep :to) (setq inclusive-iteration t))
                ((loop-tequal prep :downto) (setq inclusive-iteration (setq dir ':down)))
                ((loop-tequal prep :above) (setq dir ':down))
                ((loop-tequal prep :below) (setq dir ':up)))
          (setq limit-given t)
          (multiple-value-setq (form limit-constantp limit-value)
            (loop-constant-fold-if-possible form indexv-type))
          (setq endform (if limit-constantp
                            `',limit-value
                            (loop-make-variable
                              (gensym "LOOP-LIMIT") form indexv-type))))
         (:by
           (multiple-value-setq (form stepby-constantp stepby)
             (loop-constant-fold-if-possible form indexv-type))
           (unless stepby-constantp
             (loop-make-variable (setq stepby (gensym "LOOP-STEP-BY")) form indexv-type)))
         (t (loop-error
              "~S invalid preposition in sequencing or sequence path.~@
               Invalid prepositions specified in iteration path descriptor or something?"
              prep)))
       (when (and odir dir (not (eq dir odir)))
         (loop-error "Conflicting stepping directions in LOOP sequencing path"))
       (setq odir dir))
     (when (and sequence-variable (not sequencep))
       (loop-error "Missing OF or IN phrase in sequence path"))
     ;; Now fill in the defaults.
     (unless start-given
       (loop-make-iteration-variable
         indexv
         (setq start-constantp t start-value (or (loop-typed-init indexv-type) 0))
         indexv-type))
     (cond ((member dir '(nil :up))
            (when (or limit-given default-top)
              (unless limit-given
                (loop-make-variable (setq endform (gensym "LOOP-SEQ-LIMIT-"))
                                    nil indexv-type)
                (push `(setq ,endform ,default-top) *loop-prologue*))
              (setq testfn (if inclusive-iteration '> '>=)))
            (setq step (if (eql stepby 1) `(1+ ,indexv) `(+ ,indexv ,stepby))))
           (t (unless start-given
                (unless default-top
                  (loop-error "Don't know where to start stepping."))
                (push `(setq ,indexv (1- ,default-top)) *loop-prologue*))
              (when (and default-top (not endform))
                (setq endform (loop-typed-init indexv-type) inclusive-iteration t))
              (when endform (setq testfn (if inclusive-iteration  '< '<=)))
              (setq step (if (eql stepby 1) `(1- ,indexv) `(- ,indexv ,stepby)))))
     (setq step `(loop-unsafe ,step))
     (when testfn
       (setq test `(,testfn ,indexv ,endform)))
     (when step-hack
       (setq step-hack `(,variable ,step-hack)))
     (let ((first-test test) (remaining-tests test))
       (when (and stepby-constantp start-constantp limit-constantp)
         ;; We can make the number type more precise when we know the
         ;; start, end and step values.
         (let ((new-type (typecase (+ start-value stepby limit-value)
                           (integer (if (and (fixnump start-value)
                                             (fixnump limit-value))
                                        'fixnum
                                        indexv-type))
                           (single-float 'single-float)
                           (double-float 'double-float)
                           (long-float 'long-float)
                           (short-float 'short-float)
                           (t indexv-type))))
           (unless (subtypep indexv-type new-type)
             (loop-declare-variable indexv new-type)))
         (when (setq first-test (funcall (symbol-function testfn) start-value limit-value))
           (setq remaining-tests t)))
       `(() (,indexv ,step) ,remaining-tests ,step-hack
         () () ,first-test ,step-hack))))


;;;; Interfaces to the Master Sequencer



(defun loop-for-arithmetic (var val data-type kwd)
  (unless var
    (setf var (gensym)))
  (loop-sequencer
    var (loop-check-data-type data-type 'real) t
    nil nil nil nil nil nil
    (loop-collect-prepositional-phrases
      '((:from :upfrom :downfrom) (:to :upto :downto :above :below) (:by))
      nil (list (list kwd val)))))


;;;; Builtin LOOP Iteration Paths


#||
(loop for v being the hash-values of ht do (print v))
(loop for k being the hash-keys of ht do (print k))
(loop for v being the hash-values of ht using (hash-key k) do (print (list k v)))
(loop for k being the hash-keys of ht using (hash-value v) do (print (list k v)))
||#

(defun loop-hash-table-iteration-path (variable data-type prep-phrases &key which)
  (check-type which (member hash-key hash-value))
  (cond ((or (cdr prep-phrases) (not (member (caar prep-phrases) '(:in :of))))
         (loop-error "Too many prepositions!"))
        ((null prep-phrases) (loop-error "Missing OF or IN in ~S iteration path.")))
  (let ((ht-var (gensym "LOOP-HASHTAB-"))
        (next-fn (gensym "LOOP-HASHTAB-NEXT-"))
        (dummy-predicate-var nil)
        (post-steps nil))
    (multiple-value-bind (other-var other-p)
        (loop-named-var (if (eq which 'hash-key) 'hash-value 'hash-key))
      ;; @@@@ LOOP-NAMED-VAR returns a second value of T if the name
      ;; was actually specified, so clever code can throw away the
      ;; GENSYM'ed-up variable if it isn't really needed. The
      ;; following is for those implementations in which we cannot put
      ;; dummy NILs into MULTIPLE-VALUE-SETQ variable lists.
      (setq other-p t
            dummy-predicate-var (loop-when-it-variable))
      (let* ((key-var nil)
             (val-var nil)
             (temp-val-var (gensym "LOOP-HASH-VAL-TEMP-"))
             (temp-key-var (gensym "LOOP-HASH-KEY-TEMP-"))
             (temp-predicate-var (gensym "LOOP-HASH-PREDICATE-VAR-"))
             (variable (or variable (gensym)))
             (bindings `((,variable nil ,data-type)
                         (,ht-var ,(cadar prep-phrases))
                         ,@(and other-p other-var `((,other-var nil))))))
        (if (eq which 'hash-key)
            (setq key-var variable val-var (and other-p other-var))
            (setq key-var (and other-p other-var) val-var variable))
        (push `(with-hash-table-iterator (,next-fn ,ht-var)) *loop-wrappers*)
        (when (consp key-var)
          (setq post-steps `(,key-var ,(setq key-var (gensym "LOOP-HASH-KEY-TEMP-"))
                             ,@post-steps))
          (push `(,key-var nil) bindings))
        (when (consp val-var)
          (setq post-steps `(,val-var ,(setq val-var (gensym "LOOP-HASH-VAL-TEMP-"))
                             ,@post-steps))
          (push `(,val-var nil) bindings))
        `(,bindings                             ;bindings
          ()                                    ;prologue
          ()                                    ;pre-test
          ()                                    ;parallel steps
          (not
           (multiple-value-bind (,temp-predicate-var ,temp-key-var ,temp-val-var)
               (,next-fn)
             ;; We use M-V-BIND instead of M-V-SETQ because we only
             ;; want to assign values to the key and val vars when we
             ;; are in the hash table.  When we reach the end,
             ;; TEMP-PREDICATE-VAR is NIL, and so are temp-key-var and
             ;; temp-val-var.  This might break any type declarations
             ;; on the key and val vars.
             (when ,temp-predicate-var
               (setq ,val-var ,temp-val-var)
               (setq ,key-var ,temp-key-var))
             (setq ,dummy-predicate-var ,temp-predicate-var)
             )) ;post-test
          ,post-steps)))))


(defun loop-package-symbols-iteration-path (variable data-type prep-phrases &key symbol-types)
  (cond ((and prep-phrases (cdr prep-phrases))
         (loop-error "Too many prepositions!"))
        ((and prep-phrases (not (member (caar prep-phrases) '(:in :of))))
         (loop-error "Unknow preposition ~S" (caar prep-phrases))))
  (unless (symbolp variable)
    (loop-error "Destructuring is not valid for package symbol iteration."))
  (let ((pkg-var (gensym "LOOP-PKGSYM-"))
        (next-fn (gensym "LOOP-PKGSYM-NEXT-"))
        (variable (or variable (gensym)))
        (pkg (or (cadar prep-phrases) '*package*)))
    (push `(with-package-iterator (,next-fn ,pkg-var ,@symbol-types)) *loop-wrappers*)
    `(((,variable nil ,data-type) (,pkg-var ,pkg))
      ()
      ()
      ()
      (not (multiple-value-setq (,(progn
                                   ;;@@@@ If an implementation can get away without actually
                                   ;; using a variable here, so much the better.
                                   (loop-when-it-variable))
                                 ,variable)
             (,next-fn)))
      ())))

;;;; ANSI Loop

(defun make-ansi-loop-universe (extended-p)
  (declare (si::c-local))
  (let ((w (make-standard-loop-universe
             :keywords '((named (loop-do-named))
                         (initially (loop-do-initially))
                         (finally (loop-do-finally))
                         (do (loop-do-do))
                         (doing (loop-do-do))
                         (return (loop-do-return))
                         (collect (loop-list-collection list))
                         (collecting (loop-list-collection list))
                         (append (loop-list-collection append))
                         (appending (loop-list-collection append))
                         (nconc (loop-list-collection nconc))
                         (nconcing (loop-list-collection nconc))
                         (count (loop-sum-collection count real fixnum))
                         (counting (loop-sum-collection count real fixnum))
                         (sum (loop-sum-collection sum number number))
                         (summing (loop-sum-collection sum number number))
                         (maximize (loop-maxmin-collection max))
                         (minimize (loop-maxmin-collection min))
                         (maximizing (loop-maxmin-collection max))
                         (minimizing (loop-maxmin-collection min))
                         (always (loop-do-always t nil))        ; Normal, do always
                         (never (loop-do-always t t))   ; Negate the test on always.
                         (thereis (loop-do-thereis t))
                         (while (loop-do-while nil :while))     ; Normal, do while
                         (until (loop-do-while t :until))       ; Negate the test on while
                         (when (loop-do-if when nil))   ; Normal, do when
                         (if (loop-do-if if nil))       ; synonymous
                         (unless (loop-do-if unless t)) ; Negate the test on when
                         (with (loop-do-with))
                         (repeat (loop-do-repeat)))
             :for-keywords '((= (loop-ansi-for-equals))
                             (across (loop-for-across))
                             (in (loop-for-in))
                             (on (loop-for-on))
                             (from (loop-for-arithmetic :from))
                             (downfrom (loop-for-arithmetic :downfrom))
                             (upfrom (loop-for-arithmetic :upfrom))
                             (below (loop-for-arithmetic :below))
                             (above (loop-for-arithmetic :above))
                             (to (loop-for-arithmetic :to))
                             (upto (loop-for-arithmetic :upto))
                             (downto (loop-for-arithmetic :downto))
                             (by (loop-for-arithmetic :by))
                             (being (loop-for-being)))
             :iteration-keywords '((for (loop-do-for))
                                   (as (loop-do-for)))
             :type-symbols '(array atom bignum bit bit-vector character compiled-function
                                   complex cons double-float fixnum float
                                   function hash-table integer keyword list long-float
                                   nil null number package pathname random-state
                                   ratio rational readtable sequence short-float
                                   simple-array simple-bit-vector simple-string
                                   simple-vector single-float standard-char
                                   stream string base-char
                                   symbol t vector)
             :type-keywords nil
             :ansi (if extended-p :extended t))))
    (add-loop-path '(hash-key hash-keys) 'loop-hash-table-iteration-path w
                   :preposition-groups '((:of :in))
                   :inclusive-permitted nil
                   :user-data '(:which hash-key))
    (add-loop-path '(hash-value hash-values) 'loop-hash-table-iteration-path w
                   :preposition-groups '((:of :in))
                   :inclusive-permitted nil
                   :user-data '(:which hash-value))
    (add-loop-path '(symbol symbols) 'loop-package-symbols-iteration-path w
                   :preposition-groups '((:of :in))
                   :inclusive-permitted nil
                   :user-data '(:symbol-types (:internal :external :inherited)))
    (add-loop-path '(external-symbol external-symbols) 'loop-package-symbols-iteration-path w
                   :preposition-groups '((:of :in))
                   :inclusive-permitted nil
                   :user-data '(:symbol-types (:external)))
    (add-loop-path '(present-symbol present-symbols) 'loop-package-symbols-iteration-path w
                   :preposition-groups '((:of :in))
                   :inclusive-permitted nil
                   :user-data '(:symbol-types (:internal :external)))
    w))


(defparameter *loop-ansi-universe*
              (make-ansi-loop-universe nil))


(defun loop-standard-expansion (keywords-and-forms environment universe)
  (declare (si::c-local))
  (if (and keywords-and-forms (symbolp (car keywords-and-forms)))
      (loop-translate keywords-and-forms environment universe)
      (let ((tag (gensym)))
        `(block nil (tagbody ,tag (progn ,@keywords-and-forms) (go ,tag))))))


;;;INTERFACE: ANSI
(defmacro loop (&environment env &rest keywords-and-forms)
  (loop-standard-expansion keywords-and-forms env *loop-ansi-universe*))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/loop.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/top.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  top.lsp -- Top-level loop, break loop, and error handlers
;;;;
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;
;;;;  Revised on July 11, by Carl Hoffman.
;;;;  Modified Oct 1986 by Ken Rimey.
;;;;  Reworked March 1987, by Edward Wang.
;;;;  Merged into new distribution Sept 1987, by Edward Wang.
;;;;  Reworked for Threads November 1988, by Giuseppe Attardi.
;;;;  Reworked for CLOS November 1988, by Giuseppe Attardi.
;;;;  Updated May 2009, by Jean-Claude Beaudoin

(in-package "SYSTEM")

(export '(*break-readtable* *break-on-warnings*
          *tpl-evalhook* *tpl-prompt-hook*))

(defparameter *quit-tag* (cons nil nil))
(defparameter *quit-tags* nil)
(defparameter *break-level* 0)          ; nesting level of error loops
(defparameter *break-env* nil)
(defparameter *ihs-base* 0)
(defparameter *ihs-top* (ihs-top))
(defparameter *ihs-current* 0)
(defparameter *frs-base* 0)
(defparameter *frs-top* 0)
(defparameter *tpl-continuable* t)
(defparameter *tpl-prompt-hook* nil)
(defparameter *eof* (cons nil nil))

(defparameter *last-error* nil)

(defparameter *break-message* nil)
(defparameter *break-condition* nil)

(defparameter *break-readtable* nil)
(defparameter *tpl-level* -1)                   ; nesting level of top-level loops
(defparameter *step-level* 0)                   ; repeated from trace.lsp

(defparameter *break-hidden-functions* '(error cerror apply funcall invoke-debugger))
(defparameter *break-hidden-packages* (list #-ecl-min (find-package 'system)))

(defconstant tpl-commands
   '(("Top level commands"
      ((:cf :compile-file) tpl-compile-command :string
       ":cf             Compile file"
       ":compile-file &string &rest files               [Top level command]~@
        :cf &string &rest files                         [Abbreviation]~@
        ~@
        Compile files.  With no arguments, uses values from latest :cf~@
        command.  File extensions are optional.~%")
      ((:exit :eof) quit :eval
       ":exit           Exit Lisp"
       ":exit &eval &optional (status 0)                [Top level command]~@
        ~@
        Exit Lisp without further confirmation.~%")
      ((:ld :load) tpl-load-command :string
       ":ld             Load file"
       ":load &string &rest files                       [Top level command]~@
        :ld &string &rest files                         [Abbreviation]~@
        ~@
        Load files.  With no arguments, uses values from latest :ld~@
        or :cf command. File extensions are optional.~%")
      ((:step) tpl-step-command nil
       ":step           Single step form"
       ":step form                                      [Top level command]~@
        ~@
        Evaluate form in single step mode.  While stepping, a new break~@
        level is invoked before every evaluation.  Extra commands are~@
        available at this time to control stepping and form evaluation.~%")
      ((:tr :trace) tpl-trace-command nil
       ":tr(ace)        Trace function"
       ":trace &rest functions                          [Top level command]~@
        :tr &rest functions                             [Abbreviation]~@
        ~@
        Trace specified functions.  With no arguments, show currently~@
        traced functions.~@
        ~@
        See also: :untrace.~%")
      ((:untr :untrace) tpl-untrace-command nil
       ":untr(ace)      Untrace function"
       ":untrace &rest functions                        [Top level command]~@
        :untr &rest functions                           [Abbreviation]~@
        ~@
        Untrace specified functions.  With no arguments, untrace~@
        all functions.~@
        ~@
        See also: :trace.~%")
      #+threads
      ((:s :switch) tpl-switch-command nil
       ":s(witch)       Switch to next process to debug"
       ":switch process                                 [Break command]~@
        :s processs                                     [Abbreviation]~@
        ~@
        Switch to next process in need to debugger attention. Argument~@
        process, when provided, must be an integer indicating the rank~@
        of the process in the debugger waiting list.~%")
      #+threads
      ((:br :break) tpl-interrupt-command nil
       ":br(eak)        Stop a given process"
       ":break process                                  [Break command]~@
        :br processs                                    [Abbreviation]~@
        ~@
        Interrupt a given process. Argument process, must be provided and
        it must be an integer indicating the rank~@
        of the process in the debugger waiting list (:waiting).~%")
      #+threads
      ((:w :waiting) tpl-waiting-command nil
       ":w(aiting)      Display list of active toplevels"
       ":waiting                                        [Break command]~@
        :w                                              [Abbreviation]~@
        ~@
        Display list of active toplevels, including open debug sessions.~%")
      )
     ("Help commands"
      ((:apropos) tpl-apropos-command nil
       ":apropos        Apropos"
       ":apropos string &optional package               [Top level command]~@
        ~@
        Finds all available symbols whose print names contain string.~@
        If a non NIL package is specified, only symbols in that package are considered.~@
        ~%")
      ((:doc document) tpl-document-command nil
       ":doc(ument)     Document"
       ":document symbol                                [Top level command]~@
        ~@
        Displays documentation about function, print names contain string.~%")
      ((? :h :help) tpl-help-command nil
       ":h(elp) or ?    Help.  Type \":help help\" for more information"
       ":help &optional topic                           [Top level command]~@
        :h &optional topic                              [Abbreviation]~@
        ~@
        Print information on specified topic.  With no arguments, print~@
        quick summary of top level commands.~@
        ~@
        Help information for top level commands follows the documentation~@
        style found in \"Common Lisp, the Language\"; and, in general, the~@
        commands themselves follow the conventions of Common Lisp functions,~@
        with the exception that arguments are normally not evaluated.~@
        Those commands that do evaluate their arguments are indicated by the~@
        keyword &eval in their description.  A third class of commands~@
        treat their arguments as whitespace-separated, case-sensitive~@
        strings, requiring double quotes only when necessary.  This style~@
        of argument processing is indicated by the keyword &string.~@
        For example, the :load command accepts a list of file names:
        ~@
        :load &string &rest files                       [Top level Command]~@
        ~@
        whereas :exit, which requires an optional evaluated argument, is~@
        ~@
        :exit &eval &optional status                    [Top level Command]~%")
      )))

(defparameter *tpl-commands* tpl-commands)

(defconstant break-commands
  '("Break commands"
     ((:q :quit) tpl-quit-command nil
       ":q(uit)         Return to some previous break level"
       ":quit &optional n                               [Break command]~@
        :q &optional n                                  [Abbreviation]~@
        ~@
        Without argument, return to top level;~@
        otherwise return to break level n.~%")
      ((:pop) (tpl-pop-command) :constant
       ":pop            Pop to previous break level"
       ":pop                                            [Break command]~@
        ~@
        Pop to previous break level, or if already in top level,~@
        exit Lisp after confirmation.~%")
      ((:c :continue) continue nil
       ":c(ontinue)     Continue execution"
       ":continue                                       [Break command]~@
        :c                                              [Abbreviation]~@
        ~@
        Continue execution.  Return from current break level to the caller.~@
        This command is only available when the break level is continuable~@
        (e.g., called from a correctable error or the function break).~%")
      ((:b :backtrace) tpl-backtrace nil
       ":b(acktrace)    Print backtrace"
       ":backtrace &optional n                          [Break command]~@
        :b &optional n                                  [Abbreviation]~@
        ~@
        Show function call history.  Only those functions called since~@
        the previous break level are shown.  In addition, functions compiled~@
        in-line or explicitly hidden are not displayed.  Without an argument,~@
        a concise backtrace is printed with the current function in upper~@
        case.  With integer argument n, the n functions above and including~@
        the current one are printed in a verbose format.~@
        ~@
        See also: :function, :previous, :next.~%")
      ((:f :function) tpl-print-current nil
       ":f(unction)     Show current function"
       ":function                                       [Break command]~@
        :f                                              [Abbreviation]~@
        ~@
        Show current function.  The current function is the implicit focus~@
        of attention for several other commands.  When it is an interpreted~@
        function, its lexical environment is available for inspection and~@
        becomes the environment for evaluating user input forms.~@
        ~@
        See also: :backtrace, :next, previous, :disassemble, :variables.~%")
      ((:p :previous) tpl-previous nil
       ":p(revious)     Go to previous function"
       ":previous &optional (n 1)                       [Break command]~@
        :p &optional (n 1)                              [Abbreviation]~@
        ~@
        Move to the nth previous visible function in the backtrace.~@
        It becomes the new current function.~@
        ~@
        See also: :backtrace, :function, :go, :next.~%")
      ((:d :down) tpl-previous nil
       ":d(own)         Alias to :previous"
       ""
       )
      ((:n :next) tpl-next nil
       ":n(ext)         Go to next function"
       ":next &optional (n 1)                           [Break command]~@
        :n &optional (n 1)                              [Abbreviation]~@
        ~@
        Move to the nth next visible function in the backtrace.  It becomes~@
        the new current function.~@
        ~@
        See also: :backtrace, :function, :go, :previous.~%")
      ((:u :up) tpl-next nil
       ":u(p)           Alias to :next"
       ""
       )
      ((:g :go) tpl-go nil
       ":g(o)           Go to next function"
       ":go &optional (n 1)                             [Break command]~@
        :g &optional (n 1)                              [Abbreviation]~@
        ~@
        Move to the function at IHS[i].~@
        See also: :backtrace, :function, :next, :previous.~%")
      ((:fs :forward-search) tpl-forward-search :string
       ":fs             Search forward for function"
       ":forward-search &string substring               [Break command]~@
        :fs &string substring                           [Abbreviation]~@
        ~@
        Search forward in the backtrace for function containing substring.~@
        The match is case insensitive.~@
        ~@
        See also: :backtrace, :function, :next.~%")
      ((:bs :backward-search) tpl-backward-search :string
       ":bs             Search backward for function"
       ":backward-search &string substring              [Break command]~@
        :bs &string substring                           [Abbreviation]~@
        ~@
        Search backward in the backtrace for function containing substring.~@
        The match is case insensitive.~@
        ~@
        See also: :backtrace, :function, :previous.~%")
      ((:disassemble) tpl-disassemble-command nil
       ":disassemble    Disassemble current function"
       ":disassemble                                    [Break command]~@
        :disassemble                                    [Abbreviation]~@
        ~@
        Disassemble the current function. Currently, only interpreted functions~@
        can be disassembled.~%")
      ((:le :lambda-expression) tpl-lambda-expression-command nil
       ":l(ambda-)e(expression) Show lisp code for current function"
       ":lambda-expression                              [Break command]~@
        :le                                             [Abbreviation]~@
        ~@
        Show the lisp code of the current function. Only works for interpreted~@
        functions.~%")
      ((:v :variables) tpl-variables-command nil
       ":v(ariables)    Show local variables, functions, blocks, and tags"
       ":variables &optional no-values                  [Break command]~@
        :v &optional no-values                          [Abbreviation]~@
        ~@
        Show lexical variables, functions, block names, and tags local~@
        to the current function.  The current function must be interpreted.~@
        The values of local variables and functions are also shown,~@
        unless the argument is non-null.~%")
#|
      ((:l :local) tpl-local-command nil
       ":l(ocal)        Return the nth local value on the stack"
       ":local &optional (n 0)                          [Break command]~@
        :l &optional (n 0)                              [Abbreviation]
        ~@
        For compiled functions, return the value of the nth lexical variable.~@
        As is done normally, the returned value is both printed by the top~@
        level as well as saved in the variable *.~%")
|#
      ((:hide) tpl-hide nil
       ":hide           Hide function"
       ":hide function                                  [Break command]~@
        ~@
        Hide function.  A hidden function is not displayed in a backtrace.~@
        ~@
        See also: :backtrace, :unhide, :hide-package.~%")
      ((:unhide) tpl-unhide nil
       ":unhide         Unhide function"
       ":unhide function                                [Break command]~@
        ~@
        Unhide function.  The specified function will be displayed in future~@
        backtraces, unless its home package is also hidden.~@
        ~@
        See also: :backtrace, :hide, :unhide-package.~%")
      ((:hp :hide-package) tpl-hide-package nil
       ":hp             Hide package"
       ":hide-package package                           [Break command]~@
        :hp package                                     [Abbreviation]~@
        ~@
        Hide package.  Functions in a hidden package are not displayed~@
        in a backtrace.~@
        ~@
        See also: :backtrace, :unhide-package.~%")
      ((:unhp :unhide-package) tpl-unhide-package nil
       ":unhp           Unhide package"
       ":unhide-package package                         [Break command]~@
        :unhp package                                   [Abbreviation]~@
        ~@
        Unhide package.  Functions in the specified package will be displayed~@
        in future backtraces, unless they are individually hidden.~@
        ~@
        See also: :backtrace, :hide-package, :hide, :unhide.~%")
      ((:unhide-all) tpl-unhide-all nil
       ":unhide-all     Unhide all variables and packages"
       ":unhide-all                                     [Break command]~@
        ~@
        Unhide all variables and packages.  All functions will be displayed~@
        in future backtraces.~@
        ~@
        See also: :hide, :unhide, :hide-package, :unhide-package.~%")
#|
      ((:vs :value-stack) tpl-vs-command nil
       ":vs             Show value stack"
       ":value-stack &optional n                        [Break command]~@
        :vs &optional n                                 [Abbreviation]~@
        ~@
        Without an argument, show the entire value stack since the previous~@
        break level.  With an integer argument n, print nothing, but return~@
        the nth value stack entry.~@
        ~@
        See also: :local.~%")
|#
      ((:bds :binding-stack) tpl-bds-command nil
       ":bds            Show binding stack"
       ":binding-stack &optional variable               [Break command]~@
        :bds &optional variable                         [Abbreviation]~@
        ~@
        Without an argument, show the entire binding stack since the previous~@
        break level.  With a variable name, print nothing, but return the~@
        value of the given variable on the binding stack.~%")
      ((:frs :frame-stack) tpl-frs-command nil
       ":frs            Show frame stack"
       ""
       )
      ((:m :message) tpl-print-message nil
       ":m(essage)      Show error message"
       ":message                                        [Break command]~@
        :m                                              [Abbreviation]~@
        ~@
        Show current error message.~%")
      ((:hs :help-stack) tpl-help-stack-command nil
       ":hs             Help stack"
       ":help-stack                                     [Break command]~@
        :hs                                             [Abbreviation]~@
        ~@
        Lists the functions to access the LISP system stacks.~%")
      ((:i :inspect) tpl-inspect-command nil
       ":i(nspect)      Inspect value of local variable"
       ":inspect var-name                               [Break command]~@
        :i var-name                                     [Abbreviation]~@
        ~@
        Inspect value of local variable named by var-name. Argument~@
        var-name can be a string or a symbol whose name string will~@
        then be used regardless of of the symbol's package.~@
        ~@
        See also: :variables.~%")
  ))

(defparameter *lisp-initialized* nil)

(defun top-level (&optional (process-command-line nil))
  "Args: ()
ECL specific.
The top-level loop of ECL. It is called by default when ECL is invoked."
  (catch *quit-tag*
    (let* ((*debugger-hook* nil)
           + ++ +++ - * ** *** / // ///)

      (in-package "CL-USER")

      (unless (or *lisp-initialized* (null process-command-line))
        (process-command-args)
        (format t "ECL (Embeddable Common-Lisp) ~A (git:~D)"
                (lisp-implementation-version)
                (ext:lisp-implementation-vcs-id))
        (format t "~%Copyright (C) 1984 Taiichi Yuasa and Masami Hagiya~@
Copyright (C) 1993 Giuseppe Attardi~@
Copyright (C) 2000 Juan J. Garcia-Ripoll~@
Copyright (C) 2016 Daniel Kochmanski~@
ECL is free software, and you are welcome to redistribute it~@
under certain conditions; see file 'Copyright' for details.")
        (format *standard-output* "~%Type :h for Help.  "))
      (setq *lisp-initialized* t)

      (let ((*tpl-level* -1))
        (tpl))
      0)))

#+threads
(progn

(defparameter *console-lock* (mp:make-lock :name "Console lock"))
(defparameter *console-available* (mp:make-condition-variable))
(defparameter *console-owner* nil)
(defparameter *console-waiting-list* '())

(defun candidate-to-get-console-p (process)
  (or (null *console-owner*)
      (eq *console-owner* process)
      (not (mp:process-active-p *console-owner*))))

(defun register-in-waiting-list (process)
  (mp:with-lock (*console-lock*)
    (push process *console-waiting-list*)))

(defun delete-from-waiting-list (process)
  (mp:with-lock (*console-lock*)
    (setf *console-waiting-list* (delete process *console-waiting-list*))))

(defun grab-console (process)
  (loop with repeat = t
     while repeat
     do (mp:with-lock (*console-lock*)
          (cond ((candidate-to-get-console-p process)
                 (setf *console-owner* process)
                 (setf repeat nil))
                (t
                 (mp:condition-variable-wait *console-available* *console-lock*))))))

(defun release-console (process)
  (mp:with-lock (*console-lock*)
    (and (eq process *console-owner*) (setf *console-owner* nil))
    (mp:condition-variable-signal *console-available*)))

) ; #+threads

(defmacro with-grabbed-console (&rest body)
  #-threads
  `(progn ,@body)
  #+threads
  `(unwind-protect
        (progn
          (register-in-waiting-list mp:*current-process*)
          (grab-console mp:*current-process*)
          ,@body)
     (delete-from-waiting-list mp:*current-process*)
     (release-console mp:*current-process*)))

(defparameter *allow-recursive-debug* nil)
(defparameter *debug-status* nil)

(defun simple-terminal-interrupt ()
  (error 'ext:interactive-interrupt))

#+threads
(defun show-process-list (&optional (process-list (mp:all-processes)))
  (loop with current = mp:*current-process*
        for rank from 1
        for process in process-list
        do (format t (if (eq process current)
                         "~%  >~D: ~s"
                       "~%   ~D: ~s")
                   rank process)))

#+threads
(defun query-process (&optional (process-list (mp:all-processes)))
  (format t "~&Choose the integer code of process to interrupt.
Use special code 0 to cancel this operation.")
  (loop for code = (progn
                     (show-process-list process-list)
                     (tpl-prompt)
                     (tpl-read))
        do (cond ((zerop code)
                  (return nil))
                 ((and (fixnump code) (<= 1 code (length process-list)))
                  (return (list (elt process-list (1- code)))))
                 (t
                  (format t "~&Not a valid process number")))))

(defparameter *interrupt-lonely-threads-p* t)

(defun single-threaded-terminal-interrupt ()
  (restart-case (simple-terminal-interrupt)
    (continue ())))

(defun terminal-interrupt (&key process (correctablep t))
  (declare (ignore correctablep))
  #+threads
  (mp:without-interrupts
   (let* ((suspended '())
          (break-process nil)
          (all-processes
           (loop with this = mp:*current-process*
                 for p in (mp:all-processes)
                 unless (or (eq p this)
                            (member (mp:process-name p)
                                    '(si:signal-servicing si::handle-signal)))
                 collect p)))
     (when (and (= (length all-processes) 1) *interrupt-lonely-threads-p*)
       (mp:interrupt-process (first all-processes)
                             #'single-threaded-terminal-interrupt)
       (return-from terminal-interrupt))
     (loop for i in all-processes
           do (progn (format t "~%;;; Suspending process ~A" i)
                     (push i suspended)
                     (mp:process-suspend i)))
     (flet ((do-query-process ()
              (print all-processes)
              (query-process all-processes)))
       (mp:with-local-interrupts
        (restart-case (simple-terminal-interrupt)
          (continue () (setf break-process nil))
          (mp:interrupt-process (process)
            :interactive do-query-process
            :report (lambda (stream) (princ "Interrupt a certain process." stream))
            (setf break-process process)))))
     (loop for process in suspended
        unless (eq process break-process)
        do (mp:process-resume process))
     (when break-process
       (mp:interrupt-process break-process
                             #'single-threaded-terminal-interrupt))))
  #-threads
  (single-threaded-terminal-interrupt))

(defun tpl (&key ((:commands *tpl-commands*) tpl-commands)
                 ((:prompt-hook *tpl-prompt-hook*) *tpl-prompt-hook*)
                 (broken-at nil)
                 (quiet nil))
  #-ecl-min
  (declare (c::policy-debug-ihs-frame))
  (let* ((*ihs-base* *ihs-top*)
         (*ihs-top* (if broken-at (ihs-search t broken-at) (ihs-top)))
         (*ihs-current* (if broken-at (ihs-prev *ihs-top*) *ihs-top*))
         (*frs-base* (or (sch-frs-base *frs-top* *ihs-base*) (1+ (frs-top))))
         (*frs-top* (frs-top))
         (*quit-tags* (cons *quit-tag* *quit-tags*))
         (*quit-tag* *quit-tags*)       ; any unique new value
         (*tpl-level* (1+ *tpl-level*))
         (break-level *break-level*)
         values)
    (set-break-env)
    (set-current-ihs)
    (flet ((rep ()
             ;; We let warnings pass by this way "warn" does the
             ;; work.  It is conventional not to trap anything
             ;; that is not a SERIOUS-CONDITION. Otherwise we
             ;; would be interferring the behavior of code that relies
             ;; on conditions for communication (for instance our compiler)
             ;; and which expect nothing to happen by default.
             (handler-bind 
                 ((serious-condition
                   (lambda (condition)
                     (cond ((< break-level 1)
                            ;; Toplevel should enter the debugger on any condition.
                            )
                           (*allow-recursive-debug*
                            ;; We are told to let the debugger handle this.
                            )
                           (t
                            (format t "~&Debugger received error of type: ~A~%~A~%~
                                         Error flushed.~%"
                                    (type-of condition) condition)
                            (clear-input)
                            (return-from rep t) ;; go back into the debugger loop.
                            )
                           )
                     )))

               (with-grabbed-console
                   (unless quiet
                     (break-where)
                     (setf quiet t))
                 (setq - (locally (declare (notinline tpl-read))
                           (tpl-prompt)
                           (tpl-read))
                       values (multiple-value-list
                               (eval-with-env - *break-env*))
                       /// // // / / values *** ** ** * * (car /))
                 (tpl-print values)))))
          (loop
           (setq +++ ++ ++ + + -)
           (when
               (catch *quit-tag*
                 (if (zerop break-level)
                   (with-simple-restart 
                    (restart-toplevel "Go back to Top-Level REPL.")
                    (rep))
                   (with-simple-restart
                    (restart-debugger "Go back to debugger level ~D." break-level)
                    (rep)))
                 nil)
             (setf quiet nil))))))

(defun tpl-prompt ()
  (typecase *tpl-prompt-hook*
    (string (format t *tpl-prompt-hook*))
    (function (funcall *tpl-prompt-hook*))
    (t (fresh-line)
       (format t "~A~V,,,'>A "
               (if (eq *package* (find-package 'user))
                   ""
                 (package-name *package*))
               (- *tpl-level* *step-level* -1)
               ""))))

(defun tpl-read (&aux (*read-suppress* nil))
  (finish-output)
  (loop
    (case (peek-char nil *standard-input* nil :EOF)
      ((#\))
       (warn "Ignoring an unmatched right parenthesis.")
       (read-char))
      ((#\space #\tab)
       (read-char))
      ((#\newline #\return)
       (read-char)
       ;; avoid repeating prompt on successive empty lines:
       (let ((command (tpl-make-command :newline "")))
         (when command (return command))))
      (:EOF
       (terpri)
       (return (tpl-make-command :EOF "")))
      (#\:
       (return (tpl-make-command (read-preserving-whitespace)
                                 (read-line))))
      (#\?
       (read-char)
       (case (peek-char nil *standard-input* nil :EOF)
         ((#\space #\tab #\newline #\return :EOF)
          (return (tpl-make-command :HELP (read-line))))
         (t
          (unread-char #\?)
          (return (read-preserving-whitespace)))))
      ;; We use READ-PRESERVING-WHITESPACE because with READ, if an
      ;; error happens within the reader, and we perform a ":C" or
      ;; (CONTINUE), the reader will wait for an inexistent #\Newline.
      (t
       (return (read))))))

(defparameter *debug-tpl-commands* nil)

(defun harden-command (cmd-form)
  `(block 
    tpl-command
    (handler-bind 
     ((error (lambda (condition)
               (unless *debug-tpl-commands*
                 (format t "~&Command aborted.~%Received condition of type: ~A~%~A"
                         (type-of condition) condition)
                 (clear-input)
                 (return-from tpl-command nil)
                 )
               )
             ))
     ,cmd-form
     )
    )
  )

(defun tpl-make-command (name line &aux (c nil))
  (dolist (commands *tpl-commands*)
    (when (setq c (assoc name (cdr commands) :test #'member))
      (return)))
  (cond ((null c)
         (if (eq name :newline)         ; special handling for Newline.
             nil
             `(tpl-unknown-command ',name)))
        ((eq (third c) :restart)
         `(progn
            (invoke-restart-interactively ,(second c))))
        ((eq (third c) :eval)
         `(,(second c) . ,(tpl-parse-forms line)))
        ((eq (third c) :string)
         (harden-command `(,(second c) . ,(tpl-parse-strings line))))
        ((eq (third c) :constant)
         (harden-command (second c)))
        (t
         (harden-command `(,(second c) . ,(tpl-parse-forms line t))))))

(defun tpl-parse-forms (line &optional quote)
  (with-input-from-string (stream line)
    (do ((form (read stream nil *eof*) (read stream nil *eof*))
         (list nil))
        ((eq form *eof*) (nreverse list))
      (push (if quote `',form form) list))))

(defun tpl-parse-strings (line)
  (do ((i 0 end)
       (start)
       (end)
       (list nil)
       (space-p #'(lambda (c) (or (eql c #\space) (eql c #\tab))))
       (length (length line)))
      ((>= i length) (nreverse list))
    (cond ((null (setq start (position-if-not space-p line :START i)))
           (setq end length))
          ((eql (schar line start) #\")
           (multiple-value-bind
               (string n)
               (read-from-string line t nil :START start)
             (push string list)
             (setq end n)))
          (t
           (setq end (or (position-if space-p line :START start) length))
           (push (subseq line start end) list)))))

(defun tpl-print (values)
  (fresh-line)
  (dolist (v values)
    (prin1 v)
    (terpri)))

(defun tpl-unknown-command (command)
  (format t "Unknown top level command: ~s~%" command)
  (values))

(defun tpl-pop-command (&rest any)
  (declare (ignore any))
  (throw (pop *quit-tags*) t))

(defun tpl-quit-command (&optional (level 0))
  (when (and (>= level 0) (< level *tpl-level*))
    (let ((x (nth (- *tpl-level* level 1) *quit-tags*)))
      (throw x x)))
  (tpl-print-current))

(defun tpl-previous (&optional (n 1))
  (do ((i (si::ihs-prev *ihs-current*) (si::ihs-prev i)))
      ((or (< i *ihs-base*) (<= n 0)))
    (when (ihs-visible i)
      (setq *ihs-current* i)
      (decf n)))
  (set-break-env)
  (tpl-print-current))

(defun tpl-next (&optional (n 1))
  (do ((i (si::ihs-next *ihs-current*) (si::ihs-next i)))
      ((or (> i *ihs-top*) (<= n 0)))
    (when (ihs-visible i)
      (setq *ihs-current* i)
      (decf n)))
  (set-break-env)
  (tpl-print-current))

(defun tpl-go (ihs-index)
  (setq *ihs-current* (min (max ihs-index *ihs-base*) *ihs-top*))
  (if (ihs-visible *ihs-current*)
      (progn (set-break-env) (tpl-print-current))
      (tpl-previous)))

(defun tpl-print-message ()
  (when *break-message*
    (princ *break-message*)
    (terpri))
  (values))

(defun tpl-disassemble-command ()
  (let*((*print-level* 2)
        (*print-length* 16)
        (*print-pretty* t)
        (*print-escape* nil)
        (*print-readably* nil)
        (functions) (blocks) (variables))
    (unless (si::bc-disassemble (ihs-fun *ihs-current*))
      (tpl-print-current)
      (format t " Function cannot be disassembled.~%"))
    (values)))

(defun tpl-lambda-expression-command ()
  (let*(;;(*print-level* 2)
        ;;(*print-length* 4)
        ;;(*print-pretty* t)
        ;;(*print-readably* nil)
        (function (ihs-fun *ihs-current*))
        (le (function-lambda-expression function)))
    (if le
        (pprint le)
        (format t " No source code available for this function.~%"))
    (values)))

(defun reconstruct-bytecodes-lambda-list (data)
  (declare (si::c-local data))
  (let ((output '()))
    (dotimes (n (pop data))     ;; required values
      (declare (fixnum n))
      (push (pop data) output))
    (let ((l (pop data)))       ;; optional values
      (declare (fixnum l))
      (unless (zerop l)
        (push '&optional output)
        (dotimes (n l)
          (push (first data) output)
          (setf data (cdddr data)))))
    (let ((rest (pop data)))    ;; &rest value
      (when rest
        (push '&rest output)
        (push rest output)))
    (let* ((allow-other-keys (pop data))) ;; &keys and &allow-other-keys
      (unless (eql allow-other-keys 0)
        (push '&key output)
        (let ((l (pop data)))
          (declare (fixnum l))
          (dotimes (n l)
            (let* ((key (first data))
                   (var (second data)))
              (unless (and (keywordp key) (string= key var))
                (setf var (list (list key var))))
              (push var output))))
        (when allow-other-keys
          (push '&allow-other-keys output))))
    (nreverse output)))

(defun lambda-list-from-annotations (name)
  (declare (si::c-local)) 
  (let ((args (ext:get-annotation name :lambda-list nil)))
    (values args (and args t))))

(defun function-lambda-list (function)
  (cond
    ((symbolp function)
     (cond ((or (special-operator-p function)
                (macro-function function))
            (lambda-list-from-annotations function))
           (t
            (function-lambda-list (fdefinition function)))))
    ((typep function 'generic-function)
     (if (slot-boundp function 'clos::lambda-list)
         (values (clos:generic-function-lambda-list function) t)
         (values nil nil)))
    ;; Use the lambda list from the function definition, if available,
    ;; but remove &aux arguments.
    ((let ((f (function-lambda-expression function)))
       (when f
         (let* ((list (if (eql (first f) 'LAMBDA)
                          (second f)
                          (third f)))
                (ndx (position '&aux list)))
           (return-from function-lambda-list
             (values (if ndx (subseq list 0 (1- ndx)) list) t))))))
    ;; Reconstruct the lambda list from the bytecodes
    ((multiple-value-bind (lex-env bytecodes data)
         (si::bc-split function)
       (declare (ignore lex-env))
       (when bytecodes
         (setq data (coerce data 'list))
         (return-from function-lambda-list
           (values (reconstruct-bytecodes-lambda-list data) t)))))
    ;; If it's a compiled function of ECL itself, reconstruct the
    ;; lambda-list from its documentation string.
    (t
     (lambda-list-from-annotations (compiled-function-name function)))))

#-ecl-min
(defun decode-env-elt (env ndx)
  (ffi:c-inline (env ndx) (:object :fixnum) :object
                "
        cl_object v = #0;
        cl_index ndx = #1;
        typedef struct ecl_var_debug_info *pinfo;
        pinfo d = (pinfo)(v->vector.self.t[1]) + ndx;
        cl_object name = make_constant_base_string(d->name);
        void *value = (void*)(v->vector.self.t[2+ndx]);
        cl_object output;
        switch (d->type) {
        case _ecl_object_loc:
                output = *((cl_object*)value);
                break;
        case _ecl_fixnum_loc: {
                cl_fixnum *p = (cl_fixnum*)value;
                output = ecl_make_integer(*p);
                break;
        }
        case _ecl_float_loc: {
                float *p = (float*)value;
                output = ecl_make_single_float(*p);
                break;
        }
        case _ecl_double_loc: {
                double *p = (double*)value;
                output = ecl_make_double_float(*p);
                break;
        }
#ifdef ECL_SSE2
        case _ecl_int_sse_pack_loc: {
                __m128i *p = (__m128i*)value;
                output = ecl_make_int_sse_pack(_mm_loadu_si128(p));
                break;
        }
        case _ecl_float_sse_pack_loc: {
                __m128 *p = (__m128*)value;
                output = ecl_make_float_sse_pack(_mm_loadu_ps((float*)p));
                break;
        }
        case _ecl_double_sse_pack_loc: {
                __m128d *p = (__m128d*)value;
                output = ecl_make_double_sse_pack(_mm_loadu_pd((double*)p));
                break;
        }
#endif
        default: {
                ecl_base_char *p = (ecl_base_char*)value;
                output = ECL_CODE_CHAR(*p);
                break;
        }
        }
        @(return) = CONS(name,output);
" :one-liner nil))

(defun decode-ihs-env (*break-env*)
  (let ((env *break-env*))
    (if (vectorp env)
      #+ecl-min
      nil
      #-ecl-min
      (let* ((next (decode-ihs-env
                    (ffi:c-inline (env) (:object) :object
                                  "(#0)->vector.self.t[0]" :one-liner t))))
        (nreconc (loop with l = (- (length env) 2)
                       for i from 0 below l
                       do (push (decode-env-elt env i) next))
                   next))
      env)))

(defun ihs-environment (ihs-index)
  (labels ((newly-bound-special-variables (bds-min bds-max)
             (loop for i from bds-min to bds-max
                for variable = (bds-var i)
                unless (member variable output :test #'eq)
                collect variable into output
                finally (return output)))
           (special-variables-alist (ihs-index)
             (let ((top (ihs-top)))
               (unless (> ihs-index top)
                 (let* ((bds-min (1+ (ihs-bds ihs-index)))
                        (bds-top (bds-top))
                        (bds-max (if (= ihs-index top)
                                     bds-top
                                     (ihs-bds (1+ ihs-index))))
                        (variables (newly-bound-special-variables bds-min bds-max)))
                   (loop with output = '()
                      for i from (1+ bds-max) to bds-top
                      for var = (bds-var i)
                      when (member var variables :test #'eq)
                      do (setf variables (delete var variables)
                               output (acons var (bds-val i) output))
                      finally (return
                                (append (loop for v in variables
                                           collect (cons v (symbol-value v)))
                                        output)))))))
           (extract-restarts (variables-alist)
             (let ((record (assoc '*restart-clusters* variables-alist)))
               (if record
                   (let* ((bindings (cdr record))
                          (new-bindings (first bindings)))
                     (values (delete record variables-alist) new-bindings))
                   (values variables-alist nil)))))
    (let* ((functions '())
           (blocks '())
           (local-variables '())
           (special-variables '())
           (restarts '())
           record0 record1)
      (dolist (record (decode-ihs-env (ihs-env ihs-index)))
        (cond ((atom record)
               (push (compiled-function-name record) functions))
              ((progn
                 (setf record0 (car record) record1 (cdr record))
                 (when (stringp record0)
                   (setf record0
                         (let ((*package* (find-package "KEYWORD")))
                           (with-standard-io-syntax
                             (read-from-string record0)))))
                 (or (symbolp record0) (stringp record0)))
               (setq local-variables (acons record0 record1 local-variables)))
              ((symbolp record1)
               (push record1 blocks))
              (t
               )))
      (multiple-value-bind (special-variables restarts)
          (extract-restarts (special-variables-alist ihs-index))
        (values (nreverse local-variables)
                special-variables
                functions blocks restarts)))))

(defun tpl-print-variables (prefix variables no-values)
  ;; This format is what was in the orignal code.
  ;; It simply does not work when no-values is t.
  ;; If you care to debug this kind of conundrum then have fun!
  ;;(format t "Local variables: ~:[~:[none~;~:*~{~a~1*~:@{, ~a~1*~}~}~]~;~
  ;;                            ~:[none~;~:*~{~%  ~a: ~s~}~]~]~%"
  ;;          (not no-values) variables)
  (format t prefix)
  (if variables
      (loop for (var . value) in variables
         do (if no-values
                (format t "~% ~S" var)
                (format t "~% ~S: ~S" var value)))
      (format t "none")))

(defun tpl-variables-command (&optional no-values)
  (let*((*print-level* 2)
        (*print-length* 16)
        (*print-pretty* t)
        (*print-escape* nil)
        (*print-readably* nil))
    (multiple-value-bind (local-variables special-variables functions blocks restarts)
        (ihs-environment *ihs-current*)
      (format t "~:[~;Local functions: ~:*~{~s~^, ~}.~%~]" functions)
      (format t "~:[~;Block names: ~:*~{~s~^, ~}.~%~]" blocks)
      (when restarts
        (format t "New restarts:")
        (loop for r in restarts
           do (format t "~% ~A: ~A" (restart-name r) r)))
      (tpl-print-variables "~%Local variables: " local-variables no-values)
      (tpl-print-variables "~%Special variables: "
                           special-variables no-values))
    (terpri)
    (values)))

(defun tpl-inspect-command (var-name)
  (when (symbolp var-name)
    (setq var-name (symbol-name var-name)))
  (let ((val-pair (assoc var-name (decode-ihs-env *break-env*)
                         :test #'(lambda (s1 s2)
                                   (when (symbolp s2) (setq s2 (symbol-name s2)))
                                   (if (stringp s2)
                                       (string-equal s1 s2)
                                     nil)))))
    (when val-pair
      ;;(format t "~&In tpl-inspect-command: val-pair = ~S~%" val-pair)
      (let ((val (cdr val-pair)))
        (inspect val)))))

(defun tpl-bds-command (&optional var)
  (if var
    (do ((bi (1+ (frs-bds (max 0 (1- *frs-base*)))) (1+ bi))
         (last (frs-bds (1+ *frs-top*))))
        ((> bi last)
         (format t "Variable not found.~%")
         (values))
      (when (eq (bds-var bi) var)
        (return (let ((val (bds-val bi)))
                  (if (eq val si::unbound) "<unbound value>" val)))))
    (do ((bi (1+ (frs-bds (max 0 (1- *frs-base*)))) (1+ bi))
         (last (frs-bds (1+ *frs-top*)))
         (fi *frs-base*)
         (*print-level* 2)
         (*print-length* 16)
         (*print-pretty* t))
        ((> bi last) (values))
      (do ()
          ((or (> fi *frs-top*) (>= (frs-bds fi) bi)))
        (print-frs fi)
        (incf fi))
      (format t "BDS[~d]: ~s = ~s~%"
              bi (bds-var bi)
              (let ((val (bds-val bi)))
                (if (eq val si::unbound) "<unbound value>" val))))))

(defun tpl-backtrace (&optional n)
  (let ((*print-pretty* nil)     ;; because CLOS allows (setf foo) as function names
        (base *ihs-base*)
        (top *ihs-top*))
    (format t "~&Backtrace:~%")
    (if (null n)
        (do ((i top (si::ihs-prev i))
             ;;(b nil t)
             )
            ((< i base))
            (when (ihs-visible i)
              (let ((*print-case* (if (= i *ihs-current*) :UPCASE :DOWNCASE))
                    (*print-readably* nil)
                    (func-name (ihs-fname i)))
                ;;(format t "~:[~; >~] ~S" b (ihs-fname i)) ;; JCB
                (format t "  > ~S" func-name)
                (when (eq func-name 'si::bytecodes)
                  (format t " [Evaluation of: ~S]"
                          (function-lambda-expression (ihs-fun i))))
                (terpri)
                )))
      (progn
        (if (eq t n)
            (setq base 0)
          (progn
            (unless (integerp n)
              (error "Argument to command :backtrace must be an integer or t."))
            (setq top *ihs-current*)
            )
          )
        (do ((i top (si::ihs-prev i))
             ;;(b nil t)
             (j 0 (1+ j))
             (max (if (eq t n) *ihs-top* n))
             )
            ((or (< i base) (>= j max))
             (when (zerop i) (format t "  > ---end-of-stack---~%"))
             )
            (when (or (ihs-visible i) (eq t n))
              (let ((*print-case* (if (= i *ihs-current*) :UPCASE :DOWNCASE))
                    (*print-readably* nil)
                    (func-name (ihs-fname i)))
                ;;(format t "~:[~; >~] ~S" b (ihs-fname i)) ;; JCB
                (format t "  > ~S" (ihs-fname i))
                (when (eq func-name 'si::bytecodes)
                  (format t " [Evaluation of: ~S]"
                          (function-lambda-expression (ihs-fun i))))
                (terpri)
                ))))
      )
    (terpri))
  (values))

(defun tpl-frs-command (&optional n)
  (unless n (setq n *ihs-top*))
  (unless (integerp n)
    (error "Argument to command :frs must be an integer."))
  (do ((i *ihs-top* (si::ihs-prev i))
       (k n (1- k)))
      ((= k 0) (values))
      (let*((j (or (sch-frs-base *frs-base* i) (1+ *frs-top*)))
            (*print-level* 2)
            (*print-length* 16)
            (*print-pretty* t))
        (do () ((or (> j *frs-top*) (> (frs-ihs j) i)))
            (print-frs j)
            (incf j)))))

(defun print-frs (i)
  (format *debug-io* "    FRS[~d]: ---> IHS[~d],BDS[~d]~%"
          i (frs-ihs i) (frs-bds i)))

(defun break-where ()
  (if (<= *tpl-level* 0)
      #-threads (format t "~&Top level.~%")
      #+threads (format t "~&Top level in: ~A.~%" mp:*current-process*)
    (tpl-print-current)))

(defun tpl-print-current ()
  (let ((*print-readably* nil)
        (name (ihs-fname *ihs-current*)))
    (format t "~&Broken at ~:@(~S~)." name)
    (when (eq name 'si::bytecodes)
      (format t " [Evaluation of: ~S]"
              (function-lambda-expression (ihs-fun *ihs-current*)))))
  #-threads (terpri)
  #+threads (format t " In: ~A.~%" mp:*current-process*)
  (let ((fun (ihs-fun *ihs-current*)))
    (when (and (symbolp fun) (fboundp fun))
      (setf fun (fdefinition fun)))
    (multiple-value-bind (file position)
        (ext:compiled-function-file fun)
      (when file
        (format t " File: ~S (Position #~D)~%" file position))))
  (values))

(defun tpl-hide (fname)
  (unless (member fname *break-hidden-functions* :test #'eq)
    (push fname *break-hidden-functions*)
    (unless (ihs-visible *ihs-current*)
      (set-current-ihs)))
  (values))

(defun tpl-unhide (fname)
  (setq *break-hidden-functions*
        (delete fname *break-hidden-functions* :test #'eq))
  (values))

(defun tpl-unhide-package (package)
  (setq *break-hidden-packages*
        (delete (find-package package) *break-hidden-packages* :test #'eq))
  (values))

(defun tpl-unhide-all ()
  (setq *break-hidden-functions* nil)
  (setq *break-hidden-packages* nil)
  (values))

(defun tpl-hide-package (package)
  (setq package (find-package package))
  (unless (member package *break-hidden-packages* :test #'eq)
    (push package *break-hidden-packages*)
    (unless (ihs-visible *ihs-current*)
      (set-current-ihs)))
  (values))

(defun ihs-visible (i)
  (let ((fname (ihs-fname i)))
    #+clos
    (when (and (consp fname) (eq 'SETF (car fname)))
          (setq fname (second fname)))
    (or (eq fname 'EVAL)
        (eq fname 'BYTECODES)
        (and (not (member (symbol-package fname) *break-hidden-packages*
                          :TEST #'eq))
             (not (null fname))
             (not (member fname *break-hidden-functions* :TEST #'eq))))))

(defun ihs-fname (i)
  (let ((function (ihs-fun i)))
    (cond ((symbolp function) function)
          ((compiled-function-p function)
           (or (compiled-function-name function) 'lambda))
          #+clos
          ((si:instancep function) (slot-value function 'name))
          (t :zombi))))

(defun set-current-ihs ()
  (do ((i *ihs-current* (si::ihs-prev i)))
      ((or (and (ihs-visible i) (setq *ihs-current* i))
           (<= i *ihs-base*))))
  (set-break-env))

(defun set-break-env ()
  (setq *break-env* (ihs-env *ihs-current*)))

(defun ihs-search (string unrestricted &optional (start (si::ihs-top)))
  (do ((ihs start (si::ihs-prev ihs)))
      ((< ihs *ihs-base*)
       (return nil))
    (when (and (or unrestricted (ihs-visible ihs))
               (search (string string) (symbol-name (ihs-fname ihs))
                       :test #'char-equal))
      (return ihs))))

(defun tpl-backward-search (string)
  (let ((new-ihs (ihs-search string nil *ihs-current*)))
    (cond (new-ihs
           (setf *ihs-current* new-ihs)
           (set-current-ihs)
           (tpl-print-current))
          (t
           (format *debug-io* "Search for ~a failed.~%" string)))
    (values)))

(defun tpl-forward-search (string)
  (do ((ihs (si::ihs-next *ihs-current*) (si::ihs-next ihs)))
      ((> ihs *ihs-top*)
       (format *debug-io* "Search for ~a failed.~%" string))
    (when (and (ihs-visible ihs)
               (search string (symbol-name (ihs-fname ihs))
                       :test #'char-equal))
      (setq *ihs-current* ihs)
      (set-current-ihs)
      (tpl-print-current)
      (return)))
  (values))

(defun tpl-apropos-command (&optional string pkg)
  (when string (apropos string pkg)))

(defun tpl-document-command (&optional symbol)
  (when symbol (help symbol)))

(defun tpl-step-command (&optional form)
  (when form (step* form)))

(defun tpl-trace-command (&rest functions)
  (trace* functions))

(defun tpl-untrace-command (&rest functions)
  (untrace* functions))

(defparameter *tpl-last-load* nil)

(defun tpl-load-command (&rest files)
  (when files
    (setq *tpl-last-load* files))
  (dolist (file *tpl-last-load*) (load file))
  *tpl-last-load*)

(defparameter *tpl-last-compile* nil)

(defun tpl-compile-command (&rest files)
  (when files
    (setq *tpl-last-compile* files))
  (dolist (file *tpl-last-compile*) (compile-file file))
  (setq *tpl-last-load* *tpl-last-compile*))

(defun tpl-help-command (&optional topic)
  (cond ((null topic)
         (dolist (commands *tpl-commands*)
           (format t "~%~A:~%" (car commands))
           (dolist (c (cdr commands))
             (when (fourth c)
               (format t "~A.~%" (fourth c))))))
        ((or (stringp topic) (symbolp topic))
         (let (c)
           (setq topic (intern (string topic) (find-package 'keyword)))
           (dolist (commands *tpl-commands*)
             (when (setq c (assoc topic (cdr commands) :test #'member))
               (return)))
           (cond ((null (fifth c))
                  (format t "No such help topic: ~s~%"
                          (string topic)))
                 (t
                  (terpri)
                  (format t (fifth c))
                  (terpri)))))
        (t
         (format t "Not a valid help topic: ~s~%" topic)))
  (values))

(defun tpl-help-stack-command ()
  (format t "
Use the following functions to directly access ECL stacks.

Invocation History Stack:
(sys:IHS-TOP)   Returns the index of the TOP of the IHS.
(SYS:IHS-FUN i) Returns the function of the i-th entity in IHS.
(SYS:IHS-ENV i)
(SYS:IHS-PREV i)
(SYS:IHS-NEXT i)

Frame (catch, block) Stack:
(sys:FRS-TOP)   Returns the index of the TOP of the FRS.
(SYS:FRS-BDS i) Returns the BDS index of the i-th entity in FRS.
(SYS:FRS-IHS i) Returns the IHS index of the i-th entity in FRS.
(SYS:FRS-TAG i)

Binding Stack:
(sys:BDS-TOP)   Returns the index of the TOP of the BDS.
(SYS:BDS-VAR i) Returns the symbol of the i-th entity in BDS.
(SYS:BDS-VAL i) Returns the value of the i-th entity in BDS.

Note that these functions are named by external symbols in the SYSTEM
package."
))

(defun compute-restart-commands (condition &key display)
  (let ((restarts (compute-restarts condition))
        (restart-commands (list "Restart commands")))
    (when display
      (format display (if restarts
                          "~&Available restarts:~2%" 
                          "~&No restarts available.~%")))
    (loop for restart in restarts
       and i from 1
       do (let ((user-command (format nil "r~D" i))
                (name (format nil "~@[(~A)~]" (restart-name restart)))
                (helpstring (princ-to-string restart)))
            (push (list
                   (list (intern (string-upcase user-command) :keyword))
                   restart :restart
                   (format nil ":~A~16T~A~24T~A" user-command helpstring name)
                   (format nil ":~A~48T~A~& ~&~A~A" (string-downcase user-command)
                           "[Restart command]" name helpstring))
                  restart-commands)
            (when display
              (format display "~D. ~A ~A~%" i name restart))))
    (when display (terpri display))
    (nreverse restart-commands)))

(defun update-debug-commands (restart-commands)
  (let ((commands (copy-list *tpl-commands*)))
    (unless (member break-commands commands)
      (setq commands (nconc commands (list break-commands)))
      )
    (delete-if
     #'(lambda (x) (string= "Restart commands" (car x)))
     commands)
    (nconc commands (list restart-commands))))

(defparameter *default-debugger-maximum-depth* 16)

(defun check-default-debugger-runaway ()
  (when (< *default-debugger-maximum-depth* *break-level*)
    #+threads 
    (progn
      (format *error-output*
              "~&Excessive debugger depth! Probable infinite recursion!~%~
             Quitting process: ~A.~%" mp:*current-process*)
      (when (< (+ *default-debugger-maximum-depth* 3) *break-level*)
        ;; we tried to be polite but it does not seem to work.
        (quit -1))
      (exit-process))
    #-threads 
    (progn
      (format *error-output*
            "~&Excessive debugger depth! Probable infinite recursion!~%~
             Quitting.~%")
        (quit -1))))

#+threads
(defun tpl-switch-command (&optional rank)
  (let (elect)
    (cond ((integerp rank)
           (let ((max (list-length *console-waiting-list*)))
             (unless (and (< 0 rank) (<= rank max))
               (error "Debugger switch command: Invalid argument value.")))
           (setf elect (elt *console-waiting-list* (1- rank))))
          (t
           (setf elect (find rank *console-waiting-list* :key #'mp:process-name))))
    (when elect
      (setq *console-owner* elect)))
  (values))

#+threads
(defun tpl-waiting-command ()
  (format t "~&~%Debugger's waiting list:~2%")
  (loop for process in *console-waiting-list*
     for rank from 1
     do (format t (if (eq process mp:*current-process*)
                      "   >~D: ~A~%" 
                      "    ~D: ~A~%")
                rank process))
  (terpri)
  (values))

(defun default-debugger (condition)
  (with-standard-io-syntax
    (let* ((*standard-input* *debug-io*)
           (*standard-output* *debug-io*)
           ;;(*tpl-prompt-hook* "[dbg] ")
           (*print-readably* nil)
           (*print-pretty* nil)
           (*print-circle* t)
           (*print-length* 16)
           (*readtable* (or *break-readtable* *readtable*))
           (*break-message* (format nil "~&Condition of type: ~A~%~A~%"
                                    (type-of condition) condition))
           (*break-condition* condition)
           (*break-level* (1+ *break-level*))
           (break-level *break-level*)
           (*break-env* nil))
      (check-default-debugger-runaway)
      #+threads
      ;; We give our process priority for grabbing the console.
      (setq *console-owner* mp:*current-process*)
      ;; As of ECL 9.4.1 making a normal function return from the debugger
      ;; seems to be a very bad idea! Basically, it dumps core...
      (ignore-errors
        (when (listen *debug-io*)
          (clear-input *debug-io*)))
      ;; Like in SBCL, the error message is output through *error-output*
      ;; The rest of the interaction is performed through *debug-io*
      (ignore-errors (finish-output))
      ;; We wrap the following in `ignore-errors' because error may be
      ;; caused by writing to the `*error-output*', what leads to
      ;; infinite recursion!
      (ignore-errors
        (fresh-line *error-output*)
        (terpri *error-output*)
        (princ *break-message* *error-output*))
      (loop
         ;; Here we show a list of restarts and invoke the toplevel with
         ;; an extended set of commands which includes invoking the associated
         ;; restarts.
         (let* ((restart-commands (compute-restart-commands condition :display t))
                (debug-commands 
                 ;;(adjoin restart-commands (adjoin break-commands *tpl-commands*))
                 (update-debug-commands restart-commands)
                  ))
           (tpl :commands debug-commands))))))

(defun invoke-debugger (condition)
  ;; call *INVOKE-DEBUGGER-HOOK* first, so that *DEBUGGER-HOOK* is not
  ;; called when the debugger is disabled. We adopt this mechanism
  ;; from SBCL.
  #-ecl-min
  (declare (c::policy-debug-ihs-frame))
  (let ((old-hook *invoke-debugger-hook*))
    (when old-hook
      (let ((*invoke-debugger-hook* nil))
        (funcall old-hook condition old-hook))))
  (let* ((old-hook *debugger-hook*))
    (when old-hook
      (let ((*debugger-hook* nil))
        (funcall old-hook condition old-hook))))
  (locally 
    (declare (notinline default-debugger))
    (if (<= 0 *tpl-level*) ;; Do we have a top-level REPL above us?
        (default-debugger condition)
        (let* (;; We do not have a si::top-level invocation above us
               ;; so we have to provide the environment for interactive use.
               (*invoke-debugger-hook* *invoke-debugger-hook*)
               (*debugger-hook* *debugger-hook*)
               (*ihs-top* *ihs-top*) ;; Or should it be 1?
               (*tpl-level* *tpl-level*) ;; Or should we simply say 0.
               (*tpl-commands* *tpl-commands*)
               + ++ +++ - * ** *** / // ///)
          (default-debugger condition))))
  (finish-output))

(defun safe-eval (form env &optional (err-value nil err-value-p))
  "Args: (FORM ENV &optional ERR-VALUE)
Evaluates FORM in the given environment, which may be NIL. If the form
signals an error, or tries to jump to an outer point, the function has two
choices: by default, it will invoke a debugger, but if a third value is
supplied, then SAFE-EVAL will not use a debugger but rather return that
value."
  (let ((output nil) (ok nil))
    (unwind-protect
         (handler-bind ((serious-condition
                         (if err-value-p
                             #'(lambda (condition)
                                 (declare (ignore condition))
                                 (return-from safe-eval err-value))
                             #'invoke-debugger)))
           (setf output (si::eval-with-env form env)
                 ok t))
      (return-from safe-eval (if ok output err-value)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/top.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/format.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;; -*- Package: FORMAT -*-
;;;
;;; **********************************************************************
;;; This code was written as part of the CMU Common Lisp project at
;;; Carnegie Mellon University, and has been placed in the public domain.
;;;
;;;
;;; **********************************************************************
;;;
;;; Functions to implement FORMAT and FORMATTER for CMU Common Lisp.
;;;
;;; Written by William Lott, with lots of stuff stolen from the previous
;;; version by David Adam and later rewritten by Bill Maddox.
;;;
;;; Various fixes and adaptations provided by Juan Jose Garcia-Ripoll and
;;; Daniel KochmaÅ„ski for Embeddable Common-Lisp.
;;; 

(in-package "SYS")

(pushnew :cdr-7 *features*)
(pushnew :formatter *features*)

;;;; Float printing.

;;;
;;;  Written by Bill Maddox
;;;
;;;
;;;
;;; FLONUM-TO-STRING (and its subsidiary function FLOAT-STRING) does most of 
;;; the work for all printing of floating point numbers in the printer and in
;;; FORMAT.  It converts a floating point number to a string in a free or 
;;; fixed format with no exponent.  The interpretation of the arguments is as 
;;; follows:
;;;
;;;     X        - The floating point number to convert, which must not be
;;;                negative.
;;;     WIDTH    - The preferred field width, used to determine the number
;;;                of fraction digits to produce if the FDIGITS parameter
;;;                is unspecified or NIL.  If the non-fraction digits and the
;;;                decimal point alone exceed this width, no fraction digits
;;;                will be produced unless a non-NIL value of FDIGITS has been
;;;                specified.  Field overflow is not considerd an error at this
;;;                level.
;;;     FDIGITS  - The number of fractional digits to produce. Insignificant
;;;                trailing zeroes may be introduced as needed.  May be
;;;                unspecified or NIL, in which case as many digits as possible
;;;                are generated, subject to the constraint that there are no
;;;                trailing zeroes.
;;;     SCALE    - If this parameter is specified or non-zero, then the number
;;;                printed is (* x (expt 10 scale)).  This scaling is exact,
;;;                and cannot lose precision.
;;;     FMIN     - This parameter, if specified or non-zero, is the minimum
;;;                number of fraction digits which will be produced, regardless
;;;                of the value of WIDTH or FDIGITS.  This feature is used by
;;;                the ~E format directive to prevent complete loss of
;;;                significance in the printed value due to a bogus choice of
;;;                scale factor.
;;;
;;; Most of the optional arguments are for the benefit for FORMAT and are not
;;; used by the printer.
;;;
;;; Returns:
;;; (VALUES DIGIT-STRING DIGIT-LENGTH LEADING-POINT TRAILING-POINT DECPNT)
;;; where the results have the following interpretation:
;;;
;;;     DIGIT-STRING    - The decimal representation of X, with decimal point.
;;;     DIGIT-LENGTH    - The length of the string DIGIT-STRING.
;;;     LEADING-POINT   - True if the first character of DIGIT-STRING is the
;;;                       decimal point.
;;;     TRAILING-POINT  - True if the last character of DIGIT-STRING is the
;;;                       decimal point.
;;;     POINT-POS       - The position of the digit preceding the decimal
;;;                       point.  Zero indicates point before first digit.
;;;
;;; NOTE:  FLONUM-TO-STRING goes to a lot of trouble to guarantee accuracy.
;;; Specifically, the decimal number printed is the closest possible 
;;; approximation to the true value of the binary number to be printed from 
;;; among all decimal representations  with the same number of digits.  In
;;; free-format output, i.e. with the number of digits unconstrained, it is 
;;; guaranteed that all the information is preserved, so that a properly-
;;; rounding reader can reconstruct the original binary number, bit-for-bit, 
;;; from its printed decimal representation. Furthermore, only as many digits
;;; as necessary to satisfy this condition will be printed.
;;;
;;;
;;; FLOAT-STRING actually generates the digits for positive numbers.  The
;;; algorithm is essentially that of algorithm Dragon4 in "How to Print 
;;; Floating-Point Numbers Accurately" by Steele and White.  The current 
;;; (draft) version of this paper may be found in [CMUC]<steele>tradix.press.
;;; DO NOT EVEN THINK OF ATTEMPTING TO UNDERSTAND THIS CODE WITHOUT READING 
;;; THE PAPER!

(defparameter *digits* "0123456789")

(defun float-to-digits* (digits number position relativep)
  "Does what float-to-digits, but also detects if result is zero."
  (multiple-value-bind (exp string)
      (float-to-digits digits
                       number
                       position
                       relativep)
    (values exp
            string
            (and position
                 (< exp (- (abs position)))))))

(defun flonum-to-string (x &optional width fdigits (scale 0) (fmin 0))
  (declare (type float x))
  (if (zerop x)
      ;; Zero is a special case which FLOAT-STRING cannot handle.
      (cond ((null fdigits)  (values ".0" 2 t nil 0))
            ((zerop fdigits) (values "0." 2 nil t 1))
            (T (let ((s (make-string (1+ fdigits) :initial-element #\0)))
                 (setf (schar s 0) #\.)
                 (values s (length s) t nil 0))))
      (multiple-value-bind (e string zero?)
          (cond (fdigits
                 (float-to-digits* nil x
                                   (min (- (+ fdigits scale))
                                        (- fmin))
                                   nil))
                ((null width)
                 (float-to-digits* nil x nil nil))
                (T (let ((w (multiple-value-list
                             (float-to-digits* nil x
                                               (max 0
                                                    (+ (- width 2)
                                                       (if (minusp scale)
                                                           scale 0)))
                                               t)))
                         (f (multiple-value-list
                             (float-to-digits* nil x
                                               (- (+ fmin scale))
                                               nil))))
                     (if (>= (length (cadr w))
                             (length (cadr f)))
                         (values-list w)
                         (values-list f)))))
        (let* ((exp (+ e scale))
               (stream (make-string-output-stream))
               (length (length string)))
          ;; Integer part
          (when (plusp exp)
            (write-string string
                          stream
                          :end (min length exp))
            (dotimes (i (- exp length))
              (write-char #\0 stream)))
          ;; Separator and fraction
          (write-char #\. stream)
          ;; Fraction part
          (cond ((and zero? fdigits)
                 (dotimes (i fdigits)
                   (write-char #\0 stream)))
                (fdigits
                 (let ((characters-used 0))
                   (dotimes (i (min (- exp) fdigits))
                     (incf characters-used)
                     (write-char #\0 stream))
                   (let* ((start (max 0 (min length exp)))
                          (end (max start
                                    (min length
                                         (+ start (- fdigits characters-used))))))
                     (write-string string stream
                                   :start start
                                   :end   end)
                     (incf characters-used (- end start))
                     (dotimes (i (- fdigits characters-used))
                       (write-char #\0 stream)))))
                (zero?
                 (write-char #\0 stream))
                (T
                 (dotimes (i (- exp))
                   (write-char #\0 stream))
                 (let ((start (max 0 (min length exp))))
                   (write-string string stream
                                 :start start))))
          (let* ((string (get-output-stream-string stream))
                 (length (length string))
                 (position (position #\. string)))
            (values string
                    length
                    (= position 0)
                    (= position (1- length))
                    position))))))

;;; SCALE-EXPONENT  --  Internal
;;;
;;;    Given a non-negative floating point number, SCALE-EXPONENT returns a new
;;; floating point number Z in the range (0.1, 1.0] and an exponent E such
;;; that Z * 10^E is (approximately) equal to the original number.  There may
;;; be some loss of precision due the floating point representation.  The
;;; scaling is always done with long float arithmetic, which helps printing of
;;; lesser precisions as well as avoiding generic arithmetic.
;;;
(defun scale-exponent (original-x)
  (declare (optimize (debug 0) (safety 0)))
  (let* ((x (coerce original-x 'long-float))
         (delta 0))
    (declare (long-float x)
             (fixnum delta))
    (multiple-value-bind (sig exponent)
        (decode-float x)
      (declare (ignore sig)
               (fixnum exponent)
               (long-float sig))
      (when (zerop x)
        (return-from scale-exponent (values (float 0.0l0 original-x) 1)))
      ;; When computing our initial scale factor using EXPT, we pull out part of
      ;; the computation to avoid over/under flow.  When denormalized, we must pull
      ;; out a large factor, since there is more negative exponent range than
      ;; positive range.
      (when (and (minusp exponent)
                 (< least-negative-normalized-long-float x
                    least-positive-normalized-long-float))
        #+long-float
        (setf x (* x 1.0l18) delta -18)
        #-long-float
        (setf x (* x 1.0l16) delta -16))
      ;; We find the appropriate factor that keeps the output within [0.1,1)
      ;; Note that we have to compute the exponential _every_ _time_ in the loop
      ;; because multiplying just by 10.0l0 every time would lead to a greater
      ;; loss of precission.
      (let ((ex (- (round (* exponent #.(log 2l0 10))) delta)))
        (declare (fixnum ex))
        (if (minusp ex)
            (loop for y of-type long-float
                 = (* x (the long-float (expt 10.0l0 (- ex))))
               while (< y 0.1l0)
               do (decf ex)
               finally (return (values y (the fixnum (+ delta ex)))))
            (loop for y of-type long-float
                 = (/ x (the long-float (expt 10.0l0 ex)))
               while (>= y 1.0l0)
               do (incf ex)
               finally (return (values y (the fixnum (+ delta ex)))))))
      #+(or)
      (loop with ex of-type fixnum
           = (round (* exponent #.(log 2l0 10)))
         for y of-type long-float
           = (if (minusp ex)
                 (* x (the long-float (expt 10.0l0 (- ex))))
                 (/ x (the long-float (expt 10.0l0 ex))))
         do (cond ((<= y 0.1l0)
                   (decf ex))
                  ((> y 1.0l0)
                   (incf ex))
                  (t
                   (return (values y (the fixnum (+ delta ex))))))))))
#+(or)
(defun scale-exponent (original-x)
  (let* ((x (coerce original-x 'long-float)))
    (multiple-value-bind (sig exponent)
        (decode-float x)
      (declare (ignore sig))
      (if (= x 0.0l0)
          (values (float 0.0l0 original-x) 1)
          (let* ((ex (round (* exponent (log 2l0 10))))
                 (x (if (minusp ex)
                        (if #-ecl(float-denormalized-p x)
                            #+ecl(< least-negative-normalized-long-float
                                    x
                                    least-positive-normalized-long-float)
                            #-long-float
                            (* x 1.0l16 (expt 10.0l0 (- (- ex) 16)))
                            #+long-float
                            (* x 1.0l18 (expt 10.0l0 (- (- ex) 18)))
                            (* x 10.0l0 (expt 10.0l0 (- (- ex) 1))))
                        (/ x 10.0l0 (expt 10.0l0 (1- ex))))))
            (do ((d 10.0l0 (* d 10.0l0))
                 (y x (/ x d))
                 (ex ex (1+ ex)))
                ((< y 1.0l0)
                 (do ((m 10.0l0 (* m 10.0l0))
                      (z y (* y m))
                      (ex ex (1- ex)))
                     ((>= z 0.1l0)
                      (values (float z original-x) ex))))))))))

(defstruct (format-directive
             #-ecl(:print-function %print-format-directive)
             #+ecl :named
             #+ecl(:type vector))
  (string t :type simple-string)
  (start 0 :type (and unsigned-byte fixnum))
  (end 0 :type (and unsigned-byte fixnum))
  (character #\Space :type base-char)
  (colonp nil :type (member t nil))
  (atsignp nil :type (member t nil))
  (params nil :type list))

(deftype format-directive () 'vector)

#-ecl
(defun %print-format-directive (struct stream depth)
  (declare (ignore depth))
  (print-unreadable-object (struct stream)
    (write-string (format-directive-string struct) stream
                  :start (format-directive-start struct)
                  :end (format-directive-end struct))))

(defconstant +format-directive-limit+ (1+ (char-code #\~)))

#+formatter
(defparameter *format-directive-expanders*
  (make-array +format-directive-limit+ :initial-element nil))
(defparameter *format-directive-interpreters*
  (make-array +format-directive-limit+ :initial-element nil))

(defparameter *default-format-error-control-string* nil)
(defparameter *default-format-error-offset* nil)

;; If this flag is 1, directives ~W, ~_, ~<...~:>, ~I or ~T were found.
;; If the flag is 2, directive ~<...~:;...~> was found.
;; NIL otherwise.
(defparameter *output-layout-mode* nil)

;; The condition FORMAT-ERROR is found later in conditions.lsp


;;;; TOKENIZE-CONTROL-STRING

(defun tokenize-control-string (string)
  (declare (simple-string string)
           (si::c-local))
  (let ((index 0)
        (end (length string))
        (result nil))
    (loop
       (let ((next-directive (or (position #\~ string :start index) end)))
         (when (> next-directive index)
           (push (subseq string index next-directive) result))
         (when (= next-directive end)
           (return))
         (let ((directive (parse-directive string next-directive)))
           (push directive result)
           (setf index (format-directive-end directive)))))
    (nreverse result)))

(defun parse-directive (string start)
  (declare (simple-string string)
           (si::c-local))
  (let ((posn (1+ start)) (params nil) (colonp nil) (atsignp nil)
        (end (length string)))
    (flet ((get-char ()
             (if (= posn end)
                 (error 'format-error
                        :complaint "String ended before directive was found."
                        :control-string string
                        :offset start)
                 (schar string posn))))
      (loop
         (let ((char (get-char)))
           (cond ((or (char<= #\0 char #\9) (char= char #\+) (char= char #\-))
                  (multiple-value-bind
                        (param new-posn)
                      (parse-integer string :start posn :junk-allowed t)
                    (push (cons posn param) params)
                    (setf posn new-posn)
                    (case (get-char)
                      (#\,)
                      ((#\: #\@)
                       (decf posn))
                      (t
                       (return)))))
                 ((or (char= char #\v) (char= char #\V))
                  (push (cons posn :arg) params)
                  (incf posn)
                  (case (get-char)
                    (#\,)
                    ((#\: #\@)
                     (decf posn))
                    (t
                     (return))))
                 ((char= char #\#)
                  (push (cons posn :remaining) params)
                  (incf posn)
                  (case (get-char)
                    (#\,)
                    ((#\: #\@)
                     (decf posn))
                    (t
                     (return))))
                 ((char= char #\')
                  (incf posn)
                  (push (cons posn (get-char)) params)
                  (incf posn)
                  (unless (char= (get-char) #\,)
		   (decf posn)))
                 ((char= char #\,)
                  (push (cons posn nil) params))
                 ((char= char #\:)
                  (if colonp
                      (error 'format-error
                             :complaint "Too many colons supplied."
                             :control-string string
                             :offset posn)
                      (setf colonp t)))
                 ((char= char #\@)
                  (if atsignp
                      (error 'format-error
                             :complaint "Too many at-signs supplied."
                             :control-string string
                             :offset posn)
                      (setf atsignp t)))
                 (t
                  (return))))
         (incf posn))
      (let ((char (get-char)))
        (when (char= char #\/)
          (let ((closing-slash (position #\/ string :start (1+ posn))))
            (if closing-slash
                (setf posn closing-slash)
                (error 'format-error
                       :complaint "No matching closing slash."
                       :control-string string
                       :offset posn))))
        (make-format-directive
         :string string :start start :end (1+ posn)
         :character (char-upcase char)
         :colonp colonp :atsignp atsignp
         :params (nreverse params))))))


;;;; Specials used to communicate information.

;;; *UP-UP-AND-OUT-ALLOWED* -- internal.
;;;
;;; Used both by the expansion stuff and the interpreter stuff.  When it is
;;; non-NIL, up-up-and-out (~:^) is allowed.  Otherwise, ~:^ isn't allowed.
;;;
(defparameter *up-up-and-out-allowed* nil)

;;; *LOGICAL-BLOCK-POPPER* -- internal.
;;;
;;; Used by the interpreter stuff.  When it non-NIL, its a function that will
;;; invoke PPRINT-POP in the right lexical environemnt.
;;;
(defparameter *logical-block-popper* nil)

;;; *EXPANDER-NEXT-ARG-MACRO* -- internal.
;;;
;;; Used by the expander stuff.  This is bindable so that ~<...~:>
;;; can change it.
;;;
#+formatter
(defparameter *expander-next-arg-macro* 'expander-next-arg)

;;; *ONLY-SIMPLE-ARGS* -- internal.
;;;
;;; Used by the expander stuff.  Initially starts as T, and gets set to NIL
;;; if someone needs to do something strange with the arg list (like use
;;; the rest, or something).
;;; 
(defvar *only-simple-args*)

;;; *ORIG-ARGS-AVAILABLE* -- internal.
;;;
;;; Used by the expander stuff.  We do an initial pass with this as NIL.
;;; If someone doesn't like this, they (throw 'need-orig-args nil) and we try
;;; again with it bound to T.  If this is T, we don't try to do anything
;;; fancy with args.
;;; 
(defparameter *orig-args-available* nil)

;;; *SIMPLE-ARGS* -- internal.
;;;
;;; Used by the expander stuff.  List of (symbol . offset) for simple args.
;;; 
(defvar *simple-args*)




;;;; FORMAT

#-ecl
(defun format (destination control-string &rest format-arguments)
  "Provides various facilities for formatting output.
  CONTROL-STRING contains a string to be output, possibly with embedded
  directives, which are flagged with the escape character \"~\".  Directives
  generally expand into additional text to be output, usually consuming one
  or more of the FORMAT-ARGUMENTS in the process.  A few useful directives
  are:
        ~A or ~nA     Prints one argument as if by PRINC
        ~S or ~nS     Prints one argument as if by PRIN1
        ~D or ~nD     Prints one argument as a decimal integer
        ~%            Does a TERPRI
        ~&            Does a FRESH-LINE

         where n is the width of the field in which the object is printed.
  
  DESTINATION controls where the result will go.  If DESTINATION is T, then
  the output is sent to the standard output stream.  If it is NIL, then the
  output is returned in a string as the value of the call.  Otherwise,
  DESTINATION must be a stream to which the output will be sent.

  Example:   (FORMAT NIL \"The answer is ~D.\" 10) => \"The answer is 10.\"

  FORMAT has many additional capabilities not described here.  Consult
  Section 22.3 (Formatted Output) of the ANSI Common Lisp standard for
  details."
  (etypecase destination
    (null
     (with-output-to-string (stream)
       (formatter-aux stream control-string format-arguments)))
    (string
     (with-output-to-string (stream destination)
       (formatter-aux stream control-string format-arguments)))
    ((member t)
     (formatter-aux *standard-output* control-string format-arguments)
     nil)
    (stream
     (formatter-aux destination control-string format-arguments)
     nil)))

(defun formatter-aux (stream string-or-fun orig-args &optional (args orig-args))
  (if (functionp string-or-fun)
      (apply string-or-fun stream args)
      (catch 'up-and-out
        (let* ((string (etypecase string-or-fun
                         (simple-string
                          string-or-fun)
                         (string
                          (coerce string-or-fun 'simple-string))))
               (*output-layout-mode* nil)
               (*default-format-error-control-string* string)
               (*logical-block-popper* nil))
          (interpret-directive-list stream (tokenize-control-string string)
                                    orig-args args)))))

(defun interpret-directive-list (stream directives orig-args args)
  (declare (si::c-local))
  (if directives
      (let ((directive (car directives)))
        (etypecase directive
          (simple-string
           (write-string directive stream)
           (interpret-directive-list stream (cdr directives) orig-args args))
          (#-ecl format-directive #+ecl vector
           (multiple-value-bind
                 (new-directives new-args)
               (let* ((code (char-code (format-directive-character directive)))
                      (function
                        (and (< code +format-directive-limit+)
                             (svref *format-directive-interpreters* code)))
                      (*default-format-error-offset*
                        (1- (format-directive-end directive))))
                 (unless function
                   (error 'format-error
                          :complaint "Unknown format directive."))
                 (multiple-value-bind
                       (new-directives new-args)
                     (funcall function stream directive
                              (cdr directives) orig-args args)
                   (values new-directives new-args)))
             (interpret-directive-list stream new-directives
                                       orig-args new-args)))))
      args))


;;;; FORMATTER

#+formatter
(progn
  (defmacro formatter (control-string)
    `#',(%formatter control-string))

  (defun %formatter (control-string)
    (declare (si::c-local))
    (block nil
      (catch 'need-orig-args
        (let* ((*simple-args* nil)
               (*only-simple-args* t)
               (guts (expand-control-string control-string))
               (args nil))
          (dolist (arg *simple-args*)
            (push `(,(car arg)
                     (error
                      'format-error
                      :complaint "Required argument missing"
                      :control-string ,control-string
                      :offset ,(cdr arg)))
                  args))
          (return `(lambda (stream &optional ,@args &rest args)
                     ,guts
                     args))))
      (let ((*orig-args-available* t)
            (*only-simple-args* nil))
        `(lambda (stream &rest orig-args)
           (let ((args orig-args))
             ,(expand-control-string control-string)
             args)))))

  (defun expand-control-string (string)
    (declare (si::c-local))
    (let* ((string (etypecase string
                     (simple-string
                      string)
                     (string
                      (coerce string 'simple-string))))
           (*output-layout-mode* nil)
           (*default-format-error-control-string* string)
           (directives (tokenize-control-string string)))
      `(block nil
         ,@(expand-directive-list directives))))

  (defun expand-directive-list (directives)
    (declare (si::c-local))
    (let ((results nil)
          (remaining-directives directives))
      (loop
         (unless remaining-directives
           (return))
         (multiple-value-bind
               (form new-directives)
             (expand-directive (car remaining-directives)
                               (cdr remaining-directives))
           (push form results)
           (setf remaining-directives new-directives)))
      (reverse results)))

  (defun expand-directive (directive more-directives)
    (declare (si::c-local))
    (etypecase directive
      (simple-string
       (values `(write-string ,directive stream)
               more-directives))
      (format-directive
       (let* ((code (char-code (format-directive-character directive)))
              (expander
                (and (< code +format-directive-limit+)
                     (svref *format-directive-expanders* code)))
              (*default-format-error-offset*
                (1- (format-directive-end directive))))
         (if expander
             (funcall expander directive more-directives)
             (error 'format-error
                    :complaint "Unknown directive."))))))

  (defun expand-next-arg (&optional offset)
    (declare (si::c-local))
    (if (or *orig-args-available* (not *only-simple-args*))
        `(,*expander-next-arg-macro*
          ,*default-format-error-control-string*
          ,(or offset *default-format-error-offset*))
        (let ((symbol (gensym "FORMAT-ARG-")))
          (push (cons symbol (or offset *default-format-error-offset*))
                *simple-args*)
          symbol)))

  (defun need-hairy-args ()
    (declare (si::c-local))
    (when *only-simple-args*
      ))

  
;;;; Format directive definition macros and runtime support.

  (defmacro expander-next-arg (string offset)
    `(if args
         (pop args)
         (error 'format-error
                :complaint "No more arguments."
                :control-string ,string
                :offset ,offset)))

  (defmacro expander-pprint-next-arg (string offset)
    `(progn
       (when (null args)
         (error 'format-error
                :complaint "No more arguments."
                :control-string ,string
                :offset ,offset))
       (pprint-pop)
       (pop args)))
  );#+formatter

(eval-when (:compile-toplevel :execute)

;;; NEXT-ARG -- internal.
;;;
;;; This macro is used to extract the next argument from the current arg list.
;;; This is the version used by format directive interpreters.
;;; 
  (defmacro next-arg (&optional offset)
    `(progn
       (when (null args)
         (error 'format-error
                :complaint "No more arguments."
                ,@(when offset
                        `(:offset ,offset))))
       (when *logical-block-popper*
         (funcall *logical-block-popper*))
       (pop args)))

  (defmacro def-complex-format-directive (char lambda-list &body body)
    #+formatter
    (let* ((name (or (char-name char) (string char)))
           (defun-name (intern (concatenate 'string name "-FORMAT-DIRECTIVE-EXPANDER")))
           (directive (gensym))
           (directives (if lambda-list (car (last lambda-list)) (gensym))))
      `(%set-format-directive-expander ,char
                                       (ext::lambda-block ,defun-name (,directive ,directives)
                                                          ,@(if lambda-list
                                                                `((let ,(mapcar #'(lambda (var)
                                                                                    `(,var
                                                                                      (,(intern (concatenate
                                                                                                 'string
                                                                                                 "FORMAT-DIRECTIVE-"
                                                                                                 (symbol-name var))
                                                                                                (symbol-package 'foo))
                                                                                        ,directive)))
                                                                                (butlast lambda-list))
                                                                    ,@body))
                                                                `((declare (ignore ,directive ,directives))
                                                                  ,@body))))))

  (defmacro def-format-directive (char lambda-list &body body)
    #+formatter
    (let ((directives (gensym))
          (declarations nil)
          (body-without-decls body))
      (loop
         (let ((form (car body-without-decls)))
           (unless (and (consp form) (eq (car form) 'declare))
             (return))
           (push (pop body-without-decls) declarations)))
      (setf declarations (reverse declarations))
      `(def-complex-format-directive ,char (,@lambda-list ,directives)
         ,@declarations
         (values (progn ,@body-without-decls)
                 ,directives))))

  (defmacro expand-bind-defaults (specs params &body body)
    (once-only ((params params))
               (if specs
                   (collect ((expander-bindings) (runtime-bindings))
                            (dolist (spec specs)
                              (destructuring-bind (var default) spec
                                (let ((symbol (gensym)))
                                  (expander-bindings
                                   `(,var ',symbol))
                                  (runtime-bindings
                                   `(list ',symbol
                                          (let* ((param-and-offset (pop ,params))
                                                 (offset (car param-and-offset))
                                                 (param (cdr param-and-offset)))
                                            (case param
                                              (:arg `(or ,(expand-next-arg offset)
                                                         ,,default))
                                              (:remaining
                                               (setf *only-simple-args* nil)
                                               '(length args))
                                              ((nil) ,default)
                                              (t param))))))))
                            `(let ,(expander-bindings)
                               `(let ,(list ,@(runtime-bindings))
                                  ,@(if ,params
                                        (error 'format-error
                                               :complaint
                                               "Too many parameters, expected no more than ~D"
                                               :arguments (list ,(length specs))
                                               :offset (caar ,params)))
                                  ,,@body)))
                   `(progn
                      (when ,params
                        (error 'format-error
                               :complaint "Too many parameters, expected no more than 0"
                               :offset (caar ,params)))
                      ,@body))))

  (defmacro def-complex-format-interpreter (char lambda-list &body body)
    (let ((directive (gensym))
          (directives (if lambda-list (car (last lambda-list)) (gensym))))
      `(%set-format-directive-interpreter ,char
                                          (lambda (stream ,directive ,directives orig-args args)
                                            (declare (ignorable stream orig-args args))
                                            ,@(if lambda-list
                                                  `((let ,(mapcar #'(lambda (var)
                                                                      `(,var
                                                                        (,(intern (concatenate
                                                                                   'string
                                                                                   "FORMAT-DIRECTIVE-"
                                                                                   (symbol-name var))
                                                                                  (symbol-package 'foo))
                                                                          ,directive)))
                                                                  (butlast lambda-list))
                                                      (values (progn ,@body) args)))
                                                  `((declare (ignore ,directive ,directives))
                                                    ,@body))))))

  (defmacro def-format-interpreter (char lambda-list &body body)
    (let ((directives (gensym)))
      `(def-complex-format-interpreter ,char (,@lambda-list ,directives)
         ,@body
         ,directives)))

  (defmacro interpret-bind-defaults (specs params &body body)
    (once-only ((params params))
               (collect ((bindings))
                        (dolist (spec specs)
                          (destructuring-bind (var default) spec
                            (bindings `(,var (let* ((param-and-offset (pop ,params))
                                                    (offset (car param-and-offset))
                                                    (param (cdr param-and-offset)))
                                               (case param
                                                 (:arg (or (next-arg offset) ,default))
                                                 (:remaining (length args))
                                                 ((nil) ,default)
                                                 (t param)))))))
                        `(let* ,(bindings)
                           (when ,params
                             (error 'format-error
                                    :complaint
                                    "Too many parameters, expected no more than ~D"
                                    :arguments (list ,(length specs))
                                    :offset (caar ,params)))
                           ,@body))))

  ); eval-when

#+formatter
(defun %set-format-directive-expander (char fn)
  (setf (aref *format-directive-expanders* (char-code (char-upcase char))) fn)
  char)

(defun %set-format-directive-interpreter (char fn)
  (declare (si::c-local))
  (setf (aref *format-directive-interpreters*
              (char-code (char-upcase char)))
        fn)
  char)

(defun find-directive (directives kind stop-at-semi)
  (declare (si::c-local))
  (if directives
      (let ((next (car directives)))
        (if (format-directive-p next)
            (let ((char (format-directive-character next)))
              (if (or (char= kind char)
                      (and stop-at-semi (char= char #\;)))
                  (car directives)
                  (find-directive
                   (cdr (flet ((after (char)
                                 (member (find-directive (cdr directives)
                                                         char
                                                         nil)
                                         directives)))
                          (case char
                            (#\( (after #\)))
                            (#\< (after #\>))
                            (#\[ (after #\]))
                            (#\{ (after #\}))
                            (t directives))))
                   kind stop-at-semi)))
            (find-directive (cdr directives) kind stop-at-semi)))))


;;;; Simple outputting noise.

(defun format-write-field (stream string mincol colinc minpad padchar padleft)
  (declare (si::c-local))
  (unless padleft
    (write-string string stream))
  (setf minpad (max minpad 0))
  (dotimes (i minpad)
    (write-char padchar stream))
  (and mincol minpad colinc
       (do ((chars (+ (length string) minpad) (+ chars colinc)))
           ((>= chars mincol))
         (dotimes (i colinc)
           (write-char padchar stream))))
  (when padleft
    (write-string string stream)))

(defun format-princ (stream arg colonp atsignp mincol colinc minpad padchar)
  #-formatter
  (declare (si::c-local))
  (format-write-field stream
                      (if (or arg (not colonp))
                          (princ-to-string arg)
                          "()")
                      mincol colinc minpad padchar atsignp))

(def-format-directive #\A (colonp atsignp params)
  (if params
      (expand-bind-defaults ((mincol 0) (colinc 1) (minpad 0)
                             (padchar #\space))
                            params
                            `(format-princ stream ,(expand-next-arg) ',colonp ',atsignp
                                           ,mincol ,colinc ,minpad ,padchar))
      `(princ ,(if colonp
                   `(or ,(expand-next-arg) "()")
                   (expand-next-arg))
              stream)))

(def-format-interpreter #\A (colonp atsignp params)
  (if params
      (interpret-bind-defaults ((mincol 0) (colinc 1) (minpad 0)
                                (padchar #\space))
                               params
                               (format-princ stream (next-arg) colonp atsignp
                                             mincol colinc minpad padchar))
      (princ (if colonp (or (next-arg) "()") (next-arg)) stream)))

(defun format-prin1 (stream arg colonp atsignp mincol colinc minpad padchar)
  #-formatter
  (declare (si::c-local))
  (format-write-field stream
                      (if (or arg (not colonp))
                          (prin1-to-string arg)
                          "()")
                      mincol colinc minpad padchar atsignp))

(def-format-directive #\S (colonp atsignp params)
  (cond (params
         (expand-bind-defaults ((mincol 0) (colinc 1) (minpad 0)
                                (padchar #\space))
                               params
                               `(format-prin1 stream ,(expand-next-arg) ,colonp ,atsignp
                                              ,mincol ,colinc ,minpad ,padchar)))
        (colonp
         `(let ((arg ,(expand-next-arg)))
            (if arg
                (prin1 arg stream)
                (princ "()" stream))))
        (t
         `(prin1 ,(expand-next-arg) stream))))

(def-format-interpreter #\S (colonp atsignp params)
  (cond (params
         (interpret-bind-defaults ((mincol 0) (colinc 1) (minpad 0)
                                   (padchar #\space))
                                  params
                                  (format-prin1 stream (next-arg) colonp atsignp
                                                mincol colinc minpad padchar)))
        (colonp
         (let ((arg (next-arg)))
           (if arg
               (prin1 arg stream)
               (princ "()" stream))))
        (t
         (prin1 (next-arg) stream))))

(def-format-directive #\C (colonp atsignp params)
  (expand-bind-defaults () params
                        (if colonp
                            `(format-print-named-character ,(expand-next-arg) stream)
                            (if atsignp
                                `(prin1 ,(expand-next-arg) stream)
                                `(write-char ,(expand-next-arg) stream)))))

(def-format-interpreter #\C (colonp atsignp params)
  (interpret-bind-defaults () params
                           (if colonp
                               (format-print-named-character (next-arg) stream)
                               (if atsignp
                                   (prin1 (next-arg) stream)
                                   (write-char (next-arg) stream)))))

;;; "printing" as defined in the ANSI CL glossary, which is normative.
(defun char-printing-p (char)
  (declare (si::c-local))
  (and (not (eql char #\Space))
       (graphic-char-p char)))

(defun format-print-named-character (char stream)
  (cond ((not (char-printing-p char))
         (write-string (char-name char) stream))
        (t
         (write-char char stream))))

(def-format-directive #\W (colonp atsignp params)
  (check-output-layout-mode 1)
  (expand-bind-defaults () params
                        (if (or colonp atsignp)
                            `(let (,@(when colonp
                                           '((*print-pretty* t)))
                                   ,@(when atsignp
                                           '((*print-level* nil)
                                             (*print-length* nil))))
                               (write-object ,(expand-next-arg) stream))
                            `(write-object ,(expand-next-arg) stream))))

(def-format-interpreter #\W (colonp atsignp params)
  (check-output-layout-mode 1)
  (interpret-bind-defaults () params
                           (let ((*print-pretty* (or colonp *print-pretty*))
                                 (*print-level* (and atsignp *print-level*))
                                 (*print-length* (and atsignp *print-length*)))
                             (write-object (next-arg) stream))))


;;;; Integer outputting.

;;; FORMAT-PRINT-NUMBER does most of the work for the numeric printing
;;; directives.  The parameters are interpreted as defined for ~D.
;;;
(defun format-print-integer (stream number print-commas-p print-sign-p
                             radix mincol padchar commachar commainterval)
  #-formatter
  (declare (si::c-local))
  (let ((*print-base* radix)
        (*print-radix* nil))
    (if (integerp number)
        (let* ((text (princ-to-string (abs number)))
               (commaed (if print-commas-p
                            (format-add-commas text commachar commainterval)
                            text))
               (signed (cond ((minusp number)
                              (concatenate 'string "-" commaed))
                             (print-sign-p
                              (concatenate 'string "+" commaed))
                             (t commaed))))
          ;; colinc = 1, minpad = 0, padleft = t
          (format-write-field stream signed mincol 1 0 padchar t))
        (princ number stream))))

(defun format-add-commas (string commachar commainterval)
  (declare (si::c-local))
  (let ((length (length string)))
    (multiple-value-bind (commas extra)
        (truncate (1- length) commainterval)
      (let ((new-string (make-string (+ length commas)))
            (first-comma (1+ extra)))
        (replace new-string string :end1 first-comma :end2 first-comma)
        (do ((src first-comma (+ src commainterval))
             (dst first-comma (+ dst commainterval 1)))
            ((= src length))
          (setf (schar new-string dst) commachar)
          (replace new-string string :start1 (1+ dst)
                   :start2 src :end2 (+ src commainterval)))
        new-string))))

#+formatter
(defun expand-format-integer (base colonp atsignp params)
  (if (or colonp atsignp params)
      (expand-bind-defaults
       ((mincol 0) (padchar #\space) (commachar #\,) (commainterval 3))
       params
       `(format-print-integer stream ,(expand-next-arg) ,colonp ,atsignp
                              ,base ,mincol ,padchar ,commachar
                              ,commainterval))
      `(write ,(expand-next-arg) :stream stream :base ,base :radix nil
              :escape nil)))

(eval-when (:compile-toplevel :execute)
  (defmacro interpret-format-integer (base)
    `(if (or colonp atsignp params)
         (interpret-bind-defaults
          ((mincol 0) (padchar #\space) (commachar #\,) (commainterval 3))
          params
          (format-print-integer stream (next-arg) colonp atsignp ,base mincol
                                padchar commachar commainterval))
         (write (next-arg) :stream stream :base ,base :radix nil :escape nil)))
  )

(def-format-directive #\D (colonp atsignp params)
  (expand-format-integer 10 colonp atsignp params))

(def-format-interpreter #\D (colonp atsignp params)
  (interpret-format-integer 10))

(def-format-directive #\B (colonp atsignp params)
  (expand-format-integer 2 colonp atsignp params))

(def-format-interpreter #\B (colonp atsignp params)
  (interpret-format-integer 2))

(def-format-directive #\O (colonp atsignp params)
  (expand-format-integer 8 colonp atsignp params))

(def-format-interpreter #\O (colonp atsignp params)
  (interpret-format-integer 8))

(def-format-directive #\X (colonp atsignp params)
  (expand-format-integer 16 colonp atsignp params))

(def-format-interpreter #\X (colonp atsignp params)
  (interpret-format-integer 16))

(def-format-directive #\R (colonp atsignp params)
  (expand-bind-defaults
   ((base nil) (mincol 0) (padchar #\space) (commachar #\,)
    (commainterval 3))
   params
   (let ((n-arg (gensym)))
     `(let ((,n-arg ,(expand-next-arg)))
        (if ,base
            (format-print-integer stream ,n-arg ,colonp ,atsignp
                                  ,base ,mincol
                                  ,padchar ,commachar ,commainterval)
            ,(if atsignp
                 (if colonp
                     `(format-print-old-roman stream ,n-arg)
                     `(format-print-roman stream ,n-arg))
                 (if colonp
                     `(format-print-ordinal stream ,n-arg)
                     `(format-print-cardinal stream ,n-arg))))))))

(def-format-interpreter #\R (colonp atsignp params)
  (interpret-bind-defaults
   ((base nil) (mincol 0) (padchar #\space) (commachar #\,)
    (commainterval 3))
   params
   (if base
       (format-print-integer stream (next-arg) colonp atsignp base mincol
                             padchar commachar commainterval)
       (if atsignp
           (if colonp
               (format-print-old-roman stream (next-arg))
               (format-print-roman stream (next-arg)))
           (if colonp
               (format-print-ordinal stream (next-arg))
               (format-print-cardinal stream (next-arg)))))))

(defconstant cardinal-ones
  #(nil "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))

(defconstant cardinal-tens
  #(nil nil "twenty" "thirty" "forty"
    "fifty" "sixty" "seventy" "eighty" "ninety"))

(defconstant cardinal-teens
  #("ten" "eleven" "twelve" "thirteen" "fourteen"  ;;; RAD
    "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))

(defconstant cardinal-periods
  #("" " thousand" " million" " billion" " trillion" " quadrillion"
    " quintillion" " sextillion" " septillion" " octillion" " nonillion"
    " decillion" " undecillion" " duodecillion" " tredecillion"
    " quattuordecillion" " quindecillion" " sexdecillion" " septendecillion"
    " octodecillion" " novemdecillion" " vigintillion"))

(defconstant ordinal-ones
  #(nil "first" "second" "third" "fourth"
    "fifth" "sixth" "seventh" "eighth" "ninth")
  "Table of ordinal ones-place digits in English")

(defconstant ordinal-tens 
  #(nil "tenth" "twentieth" "thirtieth" "fortieth"
    "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth")
  "Table of ordinal tens-place digits in English")

(defun format-print-small-cardinal (stream n)
  (declare (si::c-local))
  (multiple-value-bind 
        (hundreds rem) (truncate n 100)
    (when (plusp hundreds)
      (write-string (svref cardinal-ones hundreds) stream)
      (write-string " hundred" stream)
      (when (plusp rem)
        (write-char #\space stream)))
    (when (plusp rem)
      (multiple-value-bind (tens ones)
          (truncate rem 10)
        (cond ((< 1 tens)
               (write-string (svref cardinal-tens tens) stream)
               (when (plusp ones)
                 (write-char #\- stream)
                 (write-string (svref cardinal-ones ones) stream)))
              ((= tens 1)
               (write-string (svref cardinal-teens ones) stream))
              ((plusp ones)
               (write-string (svref cardinal-ones ones) stream)))))))

(defun format-print-cardinal (stream n)
  #-formatter
  (declare (si::c-local))
  (cond ((minusp n)
         (write-string "negative " stream)
         (format-print-cardinal-aux stream (- n) 0 n))
        ((zerop n)
         (write-string "zero" stream))
        (t
         (format-print-cardinal-aux stream n 0 n))))

(defun format-print-cardinal-aux (stream n period err)
  (declare (si::c-local))
  (multiple-value-bind (beyond here) (truncate n 1000)
    (unless (<= period 20)
      (error "Number too large to print in English: ~:D" err))
    (unless (zerop beyond)
      (format-print-cardinal-aux stream beyond (1+ period) err))
    (unless (zerop here)
      (unless (zerop beyond)
        (write-char #\space stream))
      (format-print-small-cardinal stream here)
      (write-string (svref cardinal-periods period) stream))))

(defun format-print-ordinal (stream n)
  #-formatter
  (declare (si::c-local))
  (when (minusp n)
    (write-string "negative " stream))
  (let ((number (abs n)))
    (multiple-value-bind
          (top bot) (truncate number 100)
      (unless (zerop top)
        (format-print-cardinal stream (- number bot)))
      (when (and (plusp top) (plusp bot))
        (write-char #\space stream))
      (multiple-value-bind
            (tens ones) (truncate bot 10)
        (cond ((= bot 12) (write-string "twelfth" stream))
              ((= tens 1)
               (write-string (svref cardinal-teens ones) stream);;;RAD
               (write-string "th" stream))
              ((and (zerop tens) (plusp ones))
               (write-string (svref ordinal-ones ones) stream))
              ((and (zerop ones)(plusp tens))
               (write-string (svref ordinal-tens tens) stream))
              ((plusp bot)
               (write-string (svref cardinal-tens tens) stream)
               (write-char #\- stream)
               (write-string (svref ordinal-ones ones) stream))
              ((plusp number)
               (write-string "th" stream))
              (t
               (write-string "zeroth" stream)))))))

;;; Print Roman numerals

(defun format-print-old-roman (stream n)
  #-formatter
  (declare (si::c-local))
  (unless (< 0 n 5000)
    (error "Number too large to print in old Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (start n (do ((i start (progn
                                (write-char cur-char stream)
                                (- i cur-val))))
                    ((< i cur-val) i))))
      ((zerop start))))

(defun format-print-roman (stream n)
  #-formatter
  (declare (si::c-local))
  (unless (< 0 n 4000)
    (error "Number too large to print in Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (sub-chars '(#\C #\X #\X #\I #\I) (cdr sub-chars))
       (sub-val '(100 10 10 1 1 0) (cdr sub-val))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (cur-sub-char #\C (car sub-chars))
       (cur-sub-val 100 (car sub-val))
       (start n (do ((i start (progn
                                (write-char cur-char stream)
                                (- i cur-val))))
                    ((< i cur-val)
                     (cond ((<= (- cur-val cur-sub-val) i)
                            (write-char cur-sub-char stream)
                            (write-char cur-char stream)
                            (- i (- cur-val cur-sub-val)))
                           (t i))))))
      ((zerop start))))


;;;; Plural.

(def-format-directive #\P (colonp atsignp params end)
  (expand-bind-defaults () params
                        (let ((arg (cond
                                     ((not colonp)
                                      (expand-next-arg))
                                     (*orig-args-available*
                                      `(if (eq orig-args args)
                                           (error 'format-error
                                                  :complaint "No previous argument."
                                                  :offset ,(1- end))
                                           (do ((arg-ptr orig-args (cdr arg-ptr)))
                                               ((eq (cdr arg-ptr) args)
                                                (car arg-ptr)))))
                                     (*only-simple-args*
                                      (unless *simple-args*
                                        (error 'format-error
                                               :complaint "No previous argument."))
                                      (caar *simple-args*))
                                     (t
                                      (throw 'need-orig-args nil)))))
                          (if atsignp
                              `(write-string (if (eql ,arg 1) "y" "ies") stream)
                              `(unless (eql ,arg 1) (write-char #\s stream))))))

(def-format-interpreter #\P (colonp atsignp params)
  (interpret-bind-defaults () params
                           (let ((arg (if colonp
                                          (if (eq orig-args args)
                                              (error 'format-error
                                                     :complaint "No previous argument.")
                                              (do ((arg-ptr orig-args (cdr arg-ptr)))
                                                  ((eq (cdr arg-ptr) args)
                                                   (car arg-ptr))))
                                          (next-arg))))
                             (if atsignp
                                 (write-string (if (eql arg 1) "y" "ies") stream)
                                 (unless (eql arg 1) (write-char #\s stream))))))


;;;; Floating point noise.

(defun decimal-string (n)
  (declare (si::c-local))
  (write-to-string n :base 10 :radix nil :escape nil))

(def-format-directive #\F (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (expand-bind-defaults ((w nil) (d nil) (k 0) (ovf nil) (pad #\space)) params
                        `(format-fixed stream ,(expand-next-arg) ,w ,d ,k ,ovf ,pad ,atsignp)))

(def-format-interpreter #\F (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (interpret-bind-defaults ((w nil) (d nil) (k 0) (ovf nil) (pad #\space))
                           params
                           (format-fixed stream (next-arg) w d k ovf pad atsignp)))

(defun format-fixed (stream number w d k ovf pad atsign)
  #-formatter
  (declare (si::c-local))
  (if (numberp number)
      (if (floatp number)
          (format-fixed-aux stream number w d k ovf pad atsign)
          (if (rationalp number)
              (format-fixed-aux stream
                                (coerce number 'single-float)
                                w d k ovf pad atsign)
              (format-write-field stream
                                  (decimal-string number)
                                  w 1 0 #\space t)))
      (format-princ stream number nil nil w 1 0 pad)))


;;; We return true if we overflowed, so that ~G can output the overflow char
;;; instead of spaces.
;;;
(defun format-fixed-aux (stream number w d k ovf pad atsign)
  (declare (si::c-local))
  (cond
    ((or (not (or w d k))
         (and (floatp number)
              (or (float-infinity-p number)
                  (float-nan-p number))))
     (prin1 number stream)
     nil)
    (t
     (let ((spaceleft w))
       (when (and w (or atsign
                        (minusp number)
                        #+ieee-floating-point
                        (and (zerop number)
                             (minusp (atan number -1)))))
         (decf spaceleft))
       (multiple-value-bind (str len lpoint tpoint)
           (sys::flonum-to-string (abs number) spaceleft d k)
         ;; if caller specifically requested no fraction digits, suppress the
         ;; trailing zero
         (when (eql d 0)
           (setq tpoint nil))
         (when w 
           (decf spaceleft len)
           ;; obligatory trailing zero (unless explicitly cut with ,d)
           (when tpoint
             (decf spaceleft))
           ;; optional leading zero
           (when lpoint
             (if (or (> spaceleft 0)
                     (eql d 0))
                 (decf spaceleft)
                 (setq lpoint nil))))
         (cond ((and w (< spaceleft 0) ovf)
                ;;field width overflow
                (dotimes (i w)
                  (write-char ovf stream))
                t)
               (t
                (when w (dotimes (i spaceleft) (write-char pad stream)))
                (if (or (minusp number)
                        #+ieee-floating-point
                        (and (zerop number)
                             (minusp (atan number -1))))
                    (write-char #\- stream)
                    (if atsign (write-char #\+ stream)))
                (when lpoint (write-char #\0 stream))
                (write-string str stream)
                (when tpoint (write-char #\0 stream))
                nil)))))))

(def-format-directive #\E (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (expand-bind-defaults
   ((w nil) (d nil) (e nil) (k 1) (ovf nil) (pad #\space) (mark nil))
   params
   `(format-exponential stream ,(expand-next-arg) ,w ,d ,e ,k ,ovf ,pad ,mark
                        ,atsignp)))

(def-format-interpreter #\E (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (interpret-bind-defaults
   ((w nil) (d nil) (e nil) (k 1) (ovf nil) (pad #\space) (mark nil))
   params
   (format-exponential stream (next-arg) w d e k ovf pad mark atsignp)))

(defun format-exponential (stream number w d e k ovf pad marker atsign)
  #-formatter
  (declare (si::c-local))
  (cond
    ((not (numberp number))
     (format-princ stream number nil nil w 1 0 pad))
    ((floatp number)
     (format-exp-aux stream number w d e k ovf pad marker atsign))
    ((rationalp number)
     (format-exp-aux stream
                     (coerce number 'single-float)
                     w d e k ovf pad marker atsign))
    (T
     (format-write-field stream
                         (decimal-string number)
                         w 1 0 #\space t))))

(defun format-exponent-marker (number)
  (declare (si::c-local))
  (if (typep number *read-default-float-format*)
      #\e
      (typecase number
        (single-float #\f)
        (double-float #\d)
        (short-float #\s)
        (long-float #\l))))

;;;Here we prevent the scale factor from shifting all significance out of
;;;a number to the right.  We allow insignificant zeroes to be shifted in
;;;to the left right, athough it is an error to specify k and d such that this
;;;occurs.  Perhaps we should detect both these condtions and flag them as
;;;errors.  As for now, we let the user get away with it, and merely guarantee
;;;that at least one significant digit will appear.

;;; toy@rtp.ericsson.se:  The Hyperspec seems to say that the exponent
;;; marker is always printed.  Make it so.  Also, the original version
;;; causes errors when printing infinities or NaN's.  The Hyperspec is
;;; silent here, so let's just print out infinities and NaN's instead
;;; of causing an error.
(defun format-exp-aux (stream number w d e k ovf pad marker atsign)
  (declare (si::c-local))
  (if (and (floatp number)
           (or (float-infinity-p number)
               (float-nan-p number)))
      (prin1 number stream)
      (multiple-value-bind (num expt)
          (sys::scale-exponent (abs number))
        (when (< expt 0)                ; adjust scale factor
          (decf k))
        (let* ((expt (- expt k))
               (estr (decimal-string (abs expt)))
               (elen (if e (max (length estr) e) (length estr)))
               (fdig (if d (if (plusp k) (1+ (- d k)) d) nil))
               (fmin (if (minusp k) (- 1 k) 0))
               (spaceleft (if w
                              (- w 2 elen
                                 (if (or atsign (minusp number))
                                     1 0))
                              nil)))
          (if (and w ovf e (> elen e)) ;exponent overflow
              (dotimes (i w) (write-char ovf stream))
              (multiple-value-bind (fstr flen lpoint)
                  (sys::flonum-to-string num spaceleft fdig k fmin)
                (when w 
                  (decf spaceleft flen)
                  (when lpoint
                    (if (> spaceleft 0)
                        (decf spaceleft)
                        (setq lpoint nil))))
                (cond ((and w (< spaceleft 0) ovf)
                       ;;significand overflow
                       (dotimes (i w) (write-char ovf stream)))
                      (t (when w
                           (dotimes (i spaceleft) (write-char pad stream)))
                         (if (minusp number)
                             (write-char #\- stream)
                             (if atsign (write-char #\+ stream)))
                         (when lpoint (write-char #\0 stream))
                         (write-string fstr stream)
                         (write-char (if marker
                                         marker
                                         (format-exponent-marker number))
                                     stream)
                         (write-char (if (minusp expt) #\- #\+) stream)
                         (when e 
                           ;;zero-fill before exponent if necessary
                           (dotimes (i (- e (length estr)))
                             (write-char #\0 stream)))
                         (write-string estr stream)))))))))

(def-format-directive #\G (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (expand-bind-defaults
   ((w nil) (d nil) (e nil) (k 0) (ovf nil) (pad #\space) (mark nil))
   params
   `(format-general stream ,(expand-next-arg) ,w ,d ,e ,k ,ovf ,pad ,mark ,atsignp)))

(def-format-interpreter #\G (colonp atsignp params)
  (when colonp
    (error 'format-error
           :complaint
           "Cannot specify the colon modifier with this directive."))
  (interpret-bind-defaults
   ((w nil) (d nil) (e nil) (k 0) (ovf nil) (pad #\space) (mark nil))
   params
   (format-general stream (next-arg) w d e k ovf pad mark atsignp)))

(defun format-general (stream number w d e k ovf pad marker atsign)
  #-formatter
  (declare (si::c-local))
  (if (numberp number)
      (if (floatp number)
          (format-general-aux stream number w d e k ovf pad marker atsign)
          (if (rationalp number)
              (format-general-aux stream
                                  (coerce number 'single-float)
                                  w d e k ovf pad marker atsign)
              (format-write-field stream
                                  (decimal-string number)
                                  w 1 0 #\space t)))
      (format-princ stream number nil nil w 1 0 pad)))


;;; toy@rtp.ericsson.se:  Same change as for format-exp-aux.
(defun format-general-aux (stream number w d e k ovf pad marker atsign)
  (declare (si::c-local))
  (if (and (floatp number)
           (or (float-infinity-p number)
               (float-nan-p number)))
      (prin1 number stream)
      (multiple-value-bind (ignore n) 
          (sys::scale-exponent (abs number))
        (declare (ignore ignore))
        ;;Default d if omitted.  The procedure is taken directly
        ;;from the definition given in the manual, and is not
        ;;very efficient, since we generate the digits twice.
        ;;Future maintainers are encouraged to improve on this.
        (unless d
          (multiple-value-bind (str len) 
              (sys::flonum-to-string (abs number))
            (declare (ignore str))
            (let ((q (if (= len 1) 1 (1- len))))
              (setq d (max q (min n 7))))))
        (let* ((ee (if e (+ e 2) 4))
               (ww (if w (- w ee) nil))
               (dd (- d n)))
          (cond ((<= 0 dd d)
                 (let ((char (if (format-fixed-aux stream number ww dd 0
                                                   ovf pad atsign)
                                 ovf
                                 #\space)))
                   (dotimes (i ee) (write-char char stream))))
                (t
                 (format-exp-aux stream number w d e (or k 1)
                                 ovf pad marker atsign)))))))

(def-format-directive #\$ (colonp atsignp params)
  (expand-bind-defaults ((d 2) (n 1) (w 0) (pad #\space)) params
                        `(format-dollars stream ,(expand-next-arg) ,d ,n ,w ,pad ,colonp
                                         ,atsignp)))

(def-format-interpreter #\$ (colonp atsignp params)
  (interpret-bind-defaults ((d 2) (n 1) (w 0) (pad #\space)) params
                           (format-dollars stream (next-arg) d n w pad colonp atsignp)))

(defun format-dollars (stream number d n w pad colon atsign)
  #-formatter
  (declare (si::c-local))
  (if (rationalp number) (setq number (coerce number 'single-float)))
  (if (floatp number)
      (let* ((signstr (if (minusp number) "-" (if atsign "+" "")))
             (signlen (length signstr)))
        (multiple-value-bind (str strlen ig2 ig3 pointplace)
            (sys::flonum-to-string (abs number) nil d)
          (declare (ignore ig2 ig3))
          (when colon (write-string signstr stream))
          (dotimes (i (- w signlen (max 0 (- n pointplace)) strlen))
            (write-char pad stream))
          (unless colon (write-string signstr stream))
          (dotimes (i (- n pointplace)) (write-char #\0 stream))
          (write-string str stream)))
      (format-write-field stream
                          (decimal-string number)
                          w 1 0 #\space t)))


;;;; line/page breaks and other stuff like that.

(def-format-directive #\% (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (if params
      (expand-bind-defaults ((count 1)) params
                            `(dotimes (i ,count)
                               (terpri stream)))
      '(terpri stream)))

(def-format-interpreter #\% (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (interpret-bind-defaults ((count 1)) params
                           (dotimes (i count)
                             (terpri stream))))

(def-format-directive #\& (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (if params
      (expand-bind-defaults ((count 1)) params
                            `(progn
                               (fresh-line stream)
                               (dotimes (i (1- ,count))
                                 (terpri stream))))
      '(fresh-line stream)))

(def-format-interpreter #\& (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (interpret-bind-defaults ((count 1)) params
                           (fresh-line stream)
                           (dotimes (i (1- count))
                             (terpri stream))))

(def-format-directive #\| (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (if params
      (expand-bind-defaults ((count 1)) params
                            `(dotimes (i ,count)
                               (write-char #\page stream)))
      '(write-char #\page stream)))

(def-format-interpreter #\| (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (interpret-bind-defaults ((count 1)) params
                           (dotimes (i count)
                             (write-char #\page stream))))

(def-format-directive #\~ (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (if params
      (expand-bind-defaults ((count 1)) params
                            `(dotimes (i ,count)
                               (write-char #\~ stream)))
      '(write-char #\~ stream)))

(def-format-interpreter #\~ (colonp atsignp params)
  (when (or colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify either colon or atsign for this directive."))
  (interpret-bind-defaults ((count 1)) params
                           (dotimes (i count)
                             (write-char #\~ stream))))

(def-complex-format-directive #\newline (colonp atsignp params directives)
  (when (and colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify both colon and atsign for this directive."))
  (values (expand-bind-defaults () params
                                (if atsignp
                                    '(write-char #\newline stream)
                                    nil))
          (if (and (not colonp)
                   directives
                   (simple-string-p (car directives)))
              (cons (string-left-trim '(#\space #\newline #\tab)
                                      (car directives))
                    (cdr directives))
              directives)))

(def-complex-format-interpreter #\newline (colonp atsignp params directives)
  (when (and colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify both colon and atsign for this directive."))
  (interpret-bind-defaults () params
                           (when atsignp
                             (write-char #\newline stream)))
  (if (and (not colonp)
           directives
           (simple-string-p (car directives)))
      (cons (string-left-trim '(#\space #\newline #\tab)
                              (car directives))
            (cdr directives))
      directives))

(def-complex-format-directive #\return (colonp atsignp params directives)
  (when (and colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify both colon and atsign for this directive."))
  (values (expand-bind-defaults () params
                                (if atsignp
                                    '(write-char #\newline stream)
                                    nil))
          (if (and (not colonp)
                   directives
                   (simple-string-p (car directives)))
              (cons (string-left-trim '(#\space #\newline #\tab)
                                      (car directives))
                    (cdr directives))
              directives)))

(def-complex-format-interpreter #\return (colonp atsignp params directives)
  (when (and colonp atsignp)
    (error 'format-error
           :complaint
           "Cannot specify both colon and atsign for this directive."))
  (interpret-bind-defaults () params
                           (when atsignp
                             (write-char #\newline stream)))
  (if (and (not colonp)
           directives
           (simple-string-p (car directives)))
      (cons (string-left-trim '(#\space #\newline #\tab)
                              (car directives))
            (cdr directives))
      directives))

;;;; Tab and simple pretty-printing noise.

(def-format-directive #\T (colonp atsignp params)
  (check-output-layout-mode 1)
  (if colonp
      (expand-bind-defaults ((n 1) (m 1)) params
                            `(pprint-tab ,(if atsignp :section-relative :section)
                                         ,n ,m stream))
      (if atsignp
          (expand-bind-defaults ((colrel 1) (colinc 1)) params
                                `(format-relative-tab stream ,colrel ,colinc))
          (expand-bind-defaults ((colnum 1) (colinc 1)) params
                                `(format-absolute-tab stream ,colnum ,colinc)))))

(def-format-interpreter #\T (colonp atsignp params)
  (check-output-layout-mode 1)
  (if colonp
      (interpret-bind-defaults ((n 1) (m 1)) params
                               (pprint-tab (if atsignp :section-relative :section) n m stream))
      (if atsignp
          (interpret-bind-defaults ((colrel 1) (colinc 1)) params
                                   (format-relative-tab stream colrel colinc))
          (interpret-bind-defaults ((colnum 1) (colinc 1)) params
                                   (format-absolute-tab stream colnum colinc)))))

(defun output-spaces (stream n)
  (declare (si::c-local))
  (let ((spaces #.(make-string 100 :initial-element #\space)))
    (loop
       (when (< n (length spaces))
         (return))
       (write-string spaces stream)
       (decf n (length spaces)))
    (write-string spaces stream :end n)))

(defun format-relative-tab (stream colrel colinc)
  #-formatter
  (declare (si::c-local))
  (if (#-ecl pp:pretty-stream-p #+ecl sys::pretty-stream-p stream)
      (pprint-tab :line-relative colrel colinc stream)
      (let* ((cur (#-ecl sys::charpos #+ecl sys::file-column stream))
             (spaces (if (and cur (plusp colinc))
                         (- (* (ceiling (+ cur colrel) colinc) colinc) cur)
                         colrel)))
        (output-spaces stream spaces))))

(defun format-absolute-tab (stream colnum colinc)
  #-formatter
  (declare (si::c-local))
  (if (#-ecl pp:pretty-stream-p #+ecl sys::pretty-stream-p stream)
      (pprint-tab :line colnum colinc stream)
      (let ((cur (#-ecl sys::charpos #+ecl sys:file-column stream)))
        (cond ((null cur)
               (write-string "  " stream))
              ((< cur colnum)
               (output-spaces stream (- colnum cur)))
              (t
               (unless (zerop colinc)
                 (output-spaces stream
                                (- colinc (rem (- cur colnum) colinc)))))))))

(def-format-directive #\_ (colonp atsignp params)
  (check-output-layout-mode 1)
  (expand-bind-defaults () params
                        `(pprint-newline ,(if colonp
                                              (if atsignp
                                                  :mandatory
                                                  :fill)
                                              (if atsignp
                                                  :miser
                                                  :linear))
                                         stream)))

(def-format-interpreter #\_ (colonp atsignp params)
  (check-output-layout-mode 1)
  (interpret-bind-defaults () params
                           (pprint-newline (if colonp
                                               (if atsignp
                                                   :mandatory
                                                   :fill)
                                               (if atsignp
                                                   :miser
                                                   :linear))
                                           stream)))

(def-format-directive #\I (colonp atsignp params)
  (check-output-layout-mode 1)
  (when atsignp
    (error 'format-error
           :complaint "Cannot specify the at-sign modifier."))
  (expand-bind-defaults ((n 0)) params
                        `(pprint-indent ,(if colonp :current :block) ,n stream)))

(def-format-interpreter #\I (colonp atsignp params)
  (check-output-layout-mode 1)
  (when atsignp
    (error 'format-error
           :complaint "Cannot specify the at-sign modifier."))
  (interpret-bind-defaults ((n 0)) params
                           (pprint-indent (if colonp :current :block) n stream)))


;;;; *

(def-format-directive #\* (colonp atsignp params end)
  (if atsignp
      (if colonp
          (error 'format-error
                 :complaint "Cannot specify both colon and at-sign.")
          (expand-bind-defaults ((posn 0)) params
                                (unless *orig-args-available*
                                  (throw 'need-orig-args nil))
                                `(if (<= 0 ,posn (length orig-args))
                                     (setf args (nthcdr ,posn orig-args))
                                     (error 'format-error
                                            :complaint "Index ~D out of bounds.  Should have been ~
                                    between 0 and ~D."
                                            :arguments (list ,posn (length orig-args))
                                            :offset ,(1- end)))))
      (if colonp
          (expand-bind-defaults ((n 1)) params
                                (unless *orig-args-available*
                                  (throw 'need-orig-args nil))
                                `(do ((cur-posn 0 (1+ cur-posn))
                                      (arg-ptr orig-args (cdr arg-ptr)))
                                     ((eq arg-ptr args)
                                      (let ((new-posn (- cur-posn ,n)))
                                        (if (<= 0 new-posn (length orig-args))
                                            (setf args (nthcdr new-posn orig-args))
                                            (error 'format-error
                                                   :complaint
                                                   "Index ~D out of bounds.  Should have been ~
                                between 0 and ~D."
                                                   :arguments
                                                   (list new-posn (length orig-args))
                                                   :offset ,(1- end)))))))
          (if params
              (expand-bind-defaults ((n 1)) params
                                    (setf *only-simple-args* nil)
                                    `(dotimes (i ,n)
                                       ,(expand-next-arg)))
              (expand-next-arg)))))

(def-format-interpreter #\* (colonp atsignp params)
  (if atsignp
      (if colonp
          (error 'format-error
                 :complaint "Cannot specify both colon and at-sign.")
          (interpret-bind-defaults ((posn 0)) params
                                   (if (<= 0 posn (length orig-args))
                                       (setf args (nthcdr posn orig-args))
                                       (error 'format-error
                                              :complaint "Index ~D out of bounds.  Should have been ~
                                   between 0 and ~D."
                                              :arguments (list posn (length orig-args))))))
      (if colonp
          (interpret-bind-defaults ((n 1)) params
                                   (do ((cur-posn 0 (1+ cur-posn))
                                        (arg-ptr orig-args (cdr arg-ptr)))
                                       ((eq arg-ptr args)
                                        (let ((new-posn (- cur-posn n)))
                                          (if (<= 0 new-posn (length orig-args))
                                              (setf args (nthcdr new-posn orig-args))
                                              (error 'format-error
                                                     :complaint
                                                     "Index ~D out of bounds.  Should have been ~
                               between 0 and ~D."
                                                     :arguments
                                                     (list new-posn (length orig-args))))))))
          (interpret-bind-defaults ((n 1)) params
                                   (dotimes (i n)
                                     (next-arg))))))


;;;; Indirection.

(def-format-directive #\? (colonp atsignp params string end)
  (when colonp
    (error 'format-error
           :complaint "Cannot specify the colon modifier."))
  (expand-bind-defaults () params
                        `(handler-bind
                             ((format-error
                               #'(lambda (condition)
                                   (error 'format-error
                                          :complaint
                                          "~A~%while processing indirect format string:"
                                          :arguments (list condition)
                                          :print-banner nil
                                          :control-string ,string
                                          :offset ,(1- end)))))
                           ,(if atsignp
                                (if *orig-args-available*
                                    `(setf args (formatter-aux stream ,(expand-next-arg) orig-args args))
                                    (throw 'need-orig-args nil))
                                `(formatter-aux stream ,(expand-next-arg) ,(expand-next-arg))))))

(def-format-interpreter #\? (colonp atsignp params string end)
  (when colonp
    (error 'format-error
           :complaint "Cannot specify the colon modifier."))
  (interpret-bind-defaults () params
                           (handler-bind
                               ((format-error
                                 #'(lambda (condition)
                                     (error 'format-error
                                            :complaint
                                            "~A~%while processing indirect format string:"
                                            :arguments (list condition)
                                            :print-banner nil
                                            :control-string string
                                            :offset (1- end)))))
                             (if atsignp
                                 (setf args (formatter-aux stream (next-arg) orig-args args))
                                 (formatter-aux stream (next-arg) (next-arg))))))


;;;; Capitalization.

(defun nstring-capitalize-first (s)
  (nstring-downcase s)
  (let ((where (position-if #'alpha-char-p s)))
    (when where
      (nstring-capitalize s :start 0 :end (1+ where)))
    s))

(def-complex-format-directive #\( (colonp atsignp params directives)
  (let ((close (find-directive directives #\) nil)))
    (unless close
      (error 'format-error
             :complaint "No corresponding close paren."))
    (let* ((posn (position close directives))
           (before (subseq directives 0 posn))
           (after (nthcdr (1+ posn) directives)))
      (values
       (expand-bind-defaults () params
                             #-ecl
                             `(let ((stream (make-case-frob-stream stream
                                                                   ,(if colonp
                                                                        (if atsignp
                                                                            :upcase
                                                                            :capitalize)
                                                                        (if atsignp
                                                                            :capitalize-first
                                                                            :downcase)))))
                                ,@(expand-directive-list before))
                             #+ecl
                             `(let ((string (make-array 10 :element-type 'character
                                                        :fill-pointer 0 :adjustable t)))
                                (unwind-protect
                                     (with-output-to-string (stream string)
                                       ,@(expand-directive-list before))
                                  (princ (,(if colonp
                                               (if atsignp 'nstring-upcase 'nstring-capitalize)
                                               (if atsignp 'nstring-capitalize-first 'nstring-downcase))
                                           string)
                                         stream))))
       after))))

(def-complex-format-interpreter #\( (colonp atsignp params directives)
  (let ((close (find-directive directives #\) nil)))
    (unless close
      (error 'format-error
             :complaint "No corresponding close paren."))
    (interpret-bind-defaults () params
                             #-ecl
                             (let* ((posn (position close directives))
                                    (before (subseq directives 0 posn))
                                    (after (nthcdr (1+ posn) directives))
                                    (stream (make-case-frob-stream stream
                                                                   (if colonp
                                                                       (if atsignp
                                                                           :upcase
                                                                           :capitalize)
                                                                       (if atsignp
                                                                           :capitalize-first
                                                                           :downcase)))))
                               (setf args (interpret-directive-list stream before orig-args args))
                               after)
                             #+ecl
                             (let* ((posn (position close directives))
                                    (before (subseq directives 0 posn))
                                    (jumped t)
                                    (after (nthcdr (1+ posn) directives))
                                    (string (make-array 10 :element-type 'character
                                                        :adjustable t :fill-pointer 0)))
                               (unwind-protect
                                    (with-output-to-string (stream string)
                                      (setf args (interpret-directive-list stream before orig-args args)))
                                 (princ (funcall
                                         (if colonp
                                             (if atsignp 'nstring-upcase 'nstring-capitalize)
                                             (if atsignp 'nstring-capitalize-first 'nstring-downcase))
                                         string) stream))
                               after))))

(def-complex-format-directive #\) ()
  (error 'format-error
         :complaint "No corresponding open paren."))

(def-complex-format-interpreter #\) ()
  (error 'format-error
         :complaint "No corresponding open paren."))


;;;; Conditionals

(defun parse-conditional-directive (directives)
  (declare (si::c-local))
  (let ((sublists nil)
        (last-semi-with-colon-p nil)
        (remaining directives))
    (loop
       (let ((close-or-semi (find-directive remaining #\] t)))
         (unless close-or-semi
           (error 'format-error
                  :complaint "No corresponding close bracket."))
         (let ((posn (position close-or-semi remaining)))
           (push (subseq remaining 0 posn) sublists)
           (setf remaining (nthcdr (1+ posn) remaining))
           (when (char= (format-directive-character close-or-semi) #\])
             (return))
           (setf last-semi-with-colon-p
                 (format-directive-colonp close-or-semi)))))
    (values sublists last-semi-with-colon-p remaining)))

(def-complex-format-directive #\[ (colonp atsignp params directives)
  (multiple-value-bind
        (sublists last-semi-with-colon-p remaining)
      (parse-conditional-directive directives)
    (values
     (if atsignp
         (if colonp
             (error 'format-error
                    :complaint
                    "Cannot specify both the colon and at-sign modifiers.")
             (if (cdr sublists)
                 (error 'format-error
                        :complaint
                        "Can only specify one section")
                 (expand-bind-defaults () params
                                       (expand-maybe-conditional (car sublists)))))
         (if colonp
             (if (= (length sublists) 2)
                 (expand-bind-defaults () params
                                       (expand-true-false-conditional (car sublists)
                                                                      (cadr sublists)))
                 (error 'format-error
                        :complaint
                        "Must specify exactly two sections."))
             (expand-bind-defaults ((index nil)) params
                                   (setf *only-simple-args* nil)
                                   (let* ((clauses nil)
                                          (case `(or ,index ,(expand-next-arg))))
                                     (when last-semi-with-colon-p
                                       (push `(t ,@(expand-directive-list (pop sublists)))
                                             clauses))
                                     (let ((count (length sublists)))
                                       (dolist (sublist sublists)
                                         (push `(,(decf count)
                                                  ,@(expand-directive-list sublist))
                                               clauses)))
                                     `(case ,case ,@clauses)))))
     remaining)))

#+formatter
(defun expand-maybe-conditional (sublist)
  (declare (si::c-local))
  (flet ((hairy ()
           `(let ((prev-args args)
                  (arg ,(expand-next-arg)))
              (when arg
                (setf args prev-args)
                ,@(expand-directive-list sublist)))))
    (if *only-simple-args*
        (multiple-value-bind (guts new-args)
            (let ((*simple-args* *simple-args*))
              (values (expand-directive-list sublist)
                      *simple-args*))
          (cond ((and new-args (eq *simple-args* (cdr new-args)))
                 (setf *simple-args* new-args)
                 `(when ,(caar new-args)
                    ,@guts))
                (t
                 (setf *only-simple-args* nil)
                 (hairy))))
        (hairy))))

#+formatter
(defun expand-true-false-conditional (true false)
  (declare (si::c-local))
  (let ((arg (expand-next-arg)))
    (flet ((hairy ()
             `(if ,arg
                  (progn
                    ,@(expand-directive-list true))
                  (progn
                    ,@(expand-directive-list false)))))
      (if *only-simple-args*
          (multiple-value-bind
                (true-guts true-args true-simple)
              (let ((*simple-args* *simple-args*)
                    (*only-simple-args* t))
                (values (expand-directive-list true)
                        *simple-args*
                        *only-simple-args*))
            (multiple-value-bind
                  (false-guts false-args false-simple)
                (let ((*simple-args* *simple-args*)
                      (*only-simple-args* t))
                  (values (expand-directive-list false)
                          *simple-args*
                          *only-simple-args*))
              (if (= (length true-args) (length false-args))
                  `(if ,arg
                       (progn
                         ,@true-guts)
                       ,(do ((false false-args (cdr false))
                             (true true-args (cdr true))
                             (bindings nil (cons `(,(caar false) ,(caar true))
                                                 bindings)))
                            ((eq true *simple-args*)
                             (setf *simple-args* true-args)
                             (setf *only-simple-args*
                                   (and true-simple false-simple))
                             (if bindings
                                 `(let ,bindings
                                    ,@false-guts)
                                 `(progn
                                    ,@false-guts)))))
                  (progn
                    (setf *only-simple-args* nil)
                    (hairy)))))
          (hairy)))))



(def-complex-format-interpreter #\[ (colonp atsignp params directives)
  (multiple-value-bind
        (sublists last-semi-with-colon-p remaining)
      (parse-conditional-directive directives)
    (setf args
          (if atsignp
              (if colonp
                  (error 'format-error
                         :complaint
                         "Cannot specify both the colon and at-sign modifiers.")
                  (if (cdr sublists)
                      (error 'format-error
                             :complaint
                             "Can only specify one section")
                      (interpret-bind-defaults () params
                                               (let ((prev-args args)
                                                     (arg (next-arg)))
                                                 (if arg
                                                     (interpret-directive-list stream
                                                                               (car sublists)
                                                                               orig-args
                                                                               prev-args)
                                                     args)))))
              (if colonp
                  (if (= (length sublists) 2)
                      (interpret-bind-defaults () params
                                               (if (next-arg)
                                                   (interpret-directive-list stream (car sublists)
                                                                             orig-args args)
                                                   (interpret-directive-list stream (cadr sublists)
                                                                             orig-args args)))
                      (error 'format-error
                             :complaint
                             "Must specify exactly two sections."))
                  (interpret-bind-defaults ((index (next-arg))) params
                                           (let* ((default (and last-semi-with-colon-p
                                                                (pop sublists)))
                                                  (last (1- (length sublists)))
                                                  (sublist
                                                   (if (<= 0 index last)
                                                       (nth (- last index) sublists)
                                                       default)))
                                             (interpret-directive-list stream sublist orig-args
                                                                       args))))))
    remaining))

(def-complex-format-directive #\; ()
  (error 'format-error
         :complaint
         "~~; not contained within either ~~[...~~] or ~~<...~~>."))

(def-complex-format-interpreter #\; ()
  (error 'format-error
         :complaint
         "~~; not contained within either ~~[...~~] or ~~<...~~>."))

(def-complex-format-interpreter #\] ()
  (error 'format-error
         :complaint
         "No corresponding open bracket."))

(def-complex-format-directive #\] ()
  (error 'format-error
         :complaint
         "No corresponding open bracket."))


;;;; Up-and-out.

(defvar *outside-args*)

(def-format-directive #\^ (colonp atsignp params)
  (when atsignp
    (error 'format-error
           :complaint "cannot use the at-sign modifier with this directive"))
  (when (and colonp (not *up-up-and-out-allowed*))
    (error 'format-error
           :complaint "attempt to use ~~:^ outside a ~~:{...~~} construct"))
  `(when ,(expand-bind-defaults ((arg1 nil) (arg2 nil) (arg3 nil)) params
                                `(cond (,arg3 (<= ,arg1 ,arg2 ,arg3))
                                       (,arg2 (eql ,arg1 ,arg2))
                                       (,arg1 (eql ,arg1 0))
                                       (t ,(if colonp
                                               '(null outside-args)
                                               (progn
                                                 (setf *only-simple-args* nil)
                                                 '(null args))))))
     ,(if colonp
          '(return-from outside-loop nil)
          '(return))))

(def-format-interpreter #\^ (colonp atsignp params)
  (when atsignp
    (error 'format-error
           :complaint "cannot specify the at-sign modifier"))
  (when (and colonp (not *up-up-and-out-allowed*))
    (error 'format-error
           :complaint "attempt to use ~~:^ outside a ~~:{...~~} construct"))
  (when (interpret-bind-defaults ((arg1 nil) (arg2 nil) (arg3 nil)) params
                                 (cond (arg3 (<= arg1 arg2 arg3))
                                       (arg2 (eql arg1 arg2))
                                       (arg1 (eql arg1 0))
                                       (t (if colonp
                                              (null *outside-args*)
                                              (null args)))))
    (throw (if colonp 'up-up-and-out 'up-and-out)
      args)))


;;;; Iteration.

(def-complex-format-directive #\{ (colonp atsignp params string end directives)
  (let ((close (find-directive directives #\} nil)))
    (unless close
      (error 'format-error
             :complaint "no corresponding close brace"))
    (let* ((closed-with-colon (format-directive-colonp close))
           (posn (position close directives)))
      (labels
          ((compute-insides ()
             (if (zerop posn)
                 (if *orig-args-available*
                     `((handler-bind
                           ((format-error
                             (lambda (condition)
                               (error 'format-error
                                      :complaint
                                      "~A~%while processing indirect format string:"
                                      :args (list condition)
                                      :print-banner nil
                                      :control-string ,string
                                      :offset ,(1- end)))))
                         (setf args
                               (formatter-aux stream inside-string orig-args args))))
                     (throw 'need-orig-args nil))
                 (let ((*up-up-and-out-allowed* colonp))
                   (expand-directive-list (subseq directives 0 posn)))))
           (compute-loop (count)
             (when atsignp
               (setf *only-simple-args* nil))
             `(loop
                 ,@(unless closed-with-colon
                           '((when (null args)
                               (return))))
                 ,@(when count
                         `((when (and ,count (minusp (decf ,count)))
                             (return))))
                 ,@(if colonp
                       (let ((*expander-next-arg-macro* 'expander-next-arg)
                             (*only-simple-args* nil)
                             (*orig-args-available* t))
                         `((let* ((orig-args ,(expand-next-arg))
                                  (outside-args args)
                                  (args orig-args))
                             (declare (ignorable orig-args outside-args args))
                             (block nil
                               ,@(compute-insides)))))
                       (compute-insides))
                 ,@(when closed-with-colon
                         '((when (null args)
                             (return))))))
           (compute-block (count)
             (if colonp
                 `(block outside-loop
                    ,(compute-loop count))
                 (compute-loop count)))
           (compute-bindings (count)
             (if atsignp
                 (compute-block count)
                 `(let* ((orig-args ,(expand-next-arg))
                         (args orig-args))
                    (declare (ignorable orig-args args))
                    ,(let ((*expander-next-arg-macro* 'expander-next-arg)
                           (*only-simple-args* nil)
                           (*orig-args-available* t))
                          (compute-block count))))))
        (values (if params
                    (expand-bind-defaults ((count nil)) params
                                          (if (zerop posn)
                                              `(let ((inside-string ,(expand-next-arg)))
                                                 ,(compute-bindings count))
                                              (compute-bindings count)))
                    (if (zerop posn)
                        `(let ((inside-string ,(expand-next-arg)))
                           ,(compute-bindings nil))
                        (compute-bindings nil)))
                (nthcdr (1+ posn) directives))))))

(def-complex-format-interpreter #\{
    (colonp atsignp params string end directives)
  (let ((close (find-directive directives #\} nil)))
    (unless close
      (error 'format-error
             :complaint
             "No corresponding close brace."))
    (interpret-bind-defaults ((max-count nil)) params
                             (let* ((closed-with-colon (format-directive-colonp close))
                                    (posn (position close directives))
                                    (insides (if (zerop posn)
                                                 (next-arg)
                                                 (subseq directives 0 posn)))
                                    (*up-up-and-out-allowed* colonp))
                               (labels
                                   ((do-guts (orig-args args)
                                      (if (zerop posn)
                                          (handler-bind
                                              ((format-error
                                                #'(lambda (condition)
                                                    (error 'format-error
                                                           :complaint
                                                           "~A~%while processing indirect format string:"
                                                           :arguments (list condition)
                                                           :print-banner nil
                                                           :control-string string
                                                           :offset (1- end)))))
                                            (formatter-aux stream insides orig-args args))
                                          (interpret-directive-list stream insides
                                                                    orig-args args)))
                                    (bind-args (orig-args args)
                                      (if colonp
                                          (let* ((arg (next-arg))
                                                 (*logical-block-popper* nil)
                                                 (*outside-args* args))
                                            (catch 'up-and-out
                                              (do-guts arg arg))
                                            args)
                                          (do-guts orig-args args)))
                                    (do-loop (orig-args args)
                                      (catch (if colonp 'up-up-and-out 'up-and-out)
                                        (loop
                                           (when (and (not closed-with-colon) (null args))
                                             (return))
                                           (when (and max-count (minusp (decf max-count)))
                                             (return))
                                           (setf args (bind-args orig-args args))
                                           (when (and closed-with-colon (null args))
                                             (return)))
                                        args)))
                                 (if atsignp
                                     (setf args (do-loop orig-args args))
                                     (let ((arg (next-arg))
                                           (*logical-block-popper* nil))
                                       (do-loop arg arg)))
                                 (nthcdr (1+ posn) directives))))))

(def-complex-format-directive #\} ()
  (error 'format-error
         :complaint "No corresponding open brace."))

(def-complex-format-interpreter #\} ()
  (error 'format-error
         :complaint "No corresponding open brace."))



;;;; Justification.

(defparameter *illegal-inside-justification*
  (mapcar (lambda (x) (parse-directive x 0))
          '("~W" "~:W" "~@W" "~:@W"
            "~_" "~:_" "~@_" "~:@_"
            "~:>" "~:@>"
            "~I" "~:I" "~@I" "~:@I"
            "~:T" "~:@T")))

(defun check-output-layout-mode (mode)
  (declare (si::c-local))
  (when (and *output-layout-mode*
             (not (eql *output-layout-mode* mode)))
    (error 'format-error
           :complaint "Cannot mix ~~W, ~~_, ~~<...~~:>, ~~I, or ~~T with ~~<...~~:;...~~>"))
  (setf *output-layout-mode* mode))

(defun illegal-inside-justification-p (directive)
  (member directive *illegal-inside-justification*
          :test (lambda (x y)
                  (and (format-directive-p x)
                       (format-directive-p y)
                       (eql (format-directive-character x) (format-directive-character y))
                       (eql (format-directive-colonp x) (format-directive-colonp y))
                       (eql (format-directive-atsignp x) (format-directive-atsignp y))))))

(def-complex-format-directive #\< (colonp atsignp params string end directives)
  (multiple-value-bind
        (segments first-semi close remaining)
      (parse-format-justification directives)
    (values
     (if (format-directive-colonp close)
         (multiple-value-bind
               (prefix per-line-p insides suffix)
             (parse-format-logical-block segments colonp first-semi
                                         close params string end)
           (expand-format-logical-block prefix per-line-p insides
                                        suffix atsignp))
         (let ((count (reduce #'+ (mapcar (lambda (x)
                                            (count-if #'illegal-inside-justification-p x))
                                          segments))))
           (when (> count 0)
             ;; ANSI specifies that "an error is signalled" in this
             ;; situation.
             (error 'format-error
                    :complaint "~D illegal directive~:P found inside justification block"
                    :arguments (list count)))
           (expand-format-justification segments colonp atsignp
                                        first-semi params)))
     remaining)))

(def-complex-format-interpreter #\<
    (colonp atsignp params string end directives)
  (multiple-value-bind
        (segments first-semi close remaining)
      (parse-format-justification directives)
    (setf args
          (if (format-directive-colonp close)
              (multiple-value-bind
                    (prefix per-line-p insides suffix)
                  (parse-format-logical-block segments colonp first-semi
                                              close params string end)
                (interpret-format-logical-block stream orig-args args
                                                prefix per-line-p insides
                                                suffix atsignp))
              (let ((count (reduce #'+ (mapcar (lambda (x)
                                                 (count-if #'illegal-inside-justification-p x))
                                               segments))))
                (when (> count 0)
                  ;; ANSI specifies that "an error is signalled" in this
                  ;; situation.
                  (error 'format-error
                         :complaint "~D illegal directive~:P found inside justification block"
                         :arguments (list count)))
                (interpret-format-justification stream orig-args args
                                                segments colonp atsignp
                                                first-semi params))))
    remaining))

(defun parse-format-justification (directives)
  (declare (si::c-local))
  (let ((first-semi nil)
        (close nil)
        (remaining directives))
    (collect ((segments))
             (loop
                (let ((close-or-semi (find-directive remaining #\> t)))
                  (unless close-or-semi
                    (error 'format-error
                           :complaint "No corresponding close bracket."))
                  (let ((posn (position close-or-semi remaining)))
                    (segments (subseq remaining 0 posn))
                    (setf remaining (nthcdr (1+ posn) remaining)))
                  (when (char= (format-directive-character close-or-semi)
                               #\>)
                    (setf close close-or-semi)
                    (return))
                  (unless first-semi
                    (setf first-semi close-or-semi))))
             (values (segments) first-semi close remaining))))

#+formatter
(defun expand-format-justification (segments colonp atsignp first-semi params)
  (declare (si::c-local))
  (let ((newline-segment-p
         (and first-semi
              (format-directive-colonp first-semi))))
    (when newline-segment-p
      (check-output-layout-mode 2))
    (expand-bind-defaults
     ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
     params
     `(let ((segments nil)
            ,@(when newline-segment-p
                    '((newline-segment nil)
                      (extra-space 0)
                      (line-len 72))))
        (block nil
          ,@(when newline-segment-p
                  `((setf newline-segment
                          (with-output-to-string (stream)
                            ,@(expand-directive-list (pop segments))))
                    ,(expand-bind-defaults
                      ((extra 0)
                       (line-len '(or #-ecl (sys::line-length stream) 72)))
                      (format-directive-params first-semi)
                      `(setf extra-space ,extra line-len ,line-len))))
          ,@(mapcar #'(lambda (segment)
                        `(push (with-output-to-string (stream)
                                 ,@(expand-directive-list segment))
                               segments))
                    segments))
        (format-justification stream
                              ,@(if newline-segment-p
                                    '(newline-segment extra-space line-len)
                                    '(nil 0 0))
                              segments ,colonp ,atsignp
                              ,mincol ,colinc ,minpad ,padchar)))))

(defun interpret-format-justification
    (stream orig-args args segments colonp atsignp first-semi params)
  (declare (si::c-local))
  (interpret-bind-defaults
   ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
   params
   (let ((newline-string nil)
         (strings nil)
         (extra-space 0)
         (line-len 0))
     (setf args
           (catch 'up-and-out
             (when (and first-semi (format-directive-colonp first-semi))
               (check-output-layout-mode 2)
               (interpret-bind-defaults
                ((extra 0)
                 (len (or #-ecl (sys::line-length stream) 72)))
                (format-directive-params first-semi)
                (setf newline-string
                      (with-output-to-string (stream)
                        (setf args
                              (interpret-directive-list stream
                                                        (pop segments)
                                                        orig-args
                                                        args))))
                (setf extra-space extra)
                (setf line-len len)))
             (dolist (segment segments)
               (push (with-output-to-string (stream)
                       (setf args
                             (interpret-directive-list stream segment
                                                       orig-args args)))
                     strings))
             args))
     (format-justification stream newline-string extra-space line-len strings
                           colonp atsignp mincol colinc minpad padchar)))
  args)

(defun format-justification (stream newline-prefix extra-space line-len strings
                             pad-left pad-right mincol colinc minpad padchar)
  #-formatter
  (declare (si::c-local))
  (setf strings (reverse strings))
  (when (and (not pad-left) (not pad-right) (null (cdr strings)))
    (setf pad-left t))
  (let* ((num-gaps (1- (length strings)))
         (chars (+ (* num-gaps minpad)
                   (loop for string in strings summing (length string))))
         (length (if (> chars mincol)
                     (+ mincol (* (ceiling (- chars mincol) colinc) colinc))
                     mincol))
         (padding (- length chars)))
    (when (and newline-prefix
               (> (+ (or (#-ecl sys::charpos #+ecl sys:file-column stream) 0)
                     length extra-space)
                  line-len))
      (write-string newline-prefix stream))
    (when pad-left
      (incf num-gaps))
    (when pad-right
      (incf num-gaps))
    (when (zerop num-gaps)
      (incf num-gaps)
      (setf pad-left t))
    (flet ((do-padding (border)
             (let ((pad-len (truncate padding num-gaps)))
               (decf padding pad-len)
               (decf num-gaps)
               (unless border
                 (incf pad-len minpad))
               (dotimes (i pad-len) (write-char padchar stream)))))
      (when pad-left
        (do-padding t))
      (when strings
        (write-string (car strings) stream)
        (dolist (string (cdr strings))
          (do-padding nil)
          (write-string string stream)))
      (when pad-right
        (do-padding t)))))

(defun parse-format-logical-block
    (segments colonp first-semi close params string end)
  (declare (si::c-local))
  (check-output-layout-mode 1)
  (when params
    (error 'format-error
           :complaint "No parameters can be supplied with ~~<...~~:>."
           :offset (caar params)))
  (multiple-value-bind
        (prefix insides suffix)
      (multiple-value-bind (prefix-default suffix-default)
          (if colonp (values "(" ")") (values "" ""))
        (flet ((extract-string (list prefix-p)
                 (let ((directive (find-if #'format-directive-p list)))
                   (if directive
                       (error 'format-error
                              :complaint
                              "Cannot include format directives inside the ~
                               ~:[suffix~;prefix~] segment of ~~<...~~:>"
                              :arguments (list prefix-p)
                              :offset (1- (format-directive-end directive)))
                       (apply #'concatenate 'string list)))))
          (case (length segments)
            (0 (values prefix-default nil suffix-default))
            (1 (values prefix-default (car segments) suffix-default))
            (2 (values (extract-string (car segments) t)
                       (cadr segments) suffix-default))
            (3 (values (extract-string (car segments) t)
                       (cadr segments)
                       (extract-string (caddr segments) nil)))
            (t
             (error 'format-error
                    :complaint "Too many segments for ~~<...~~:>.")))))
    (when (format-directive-atsignp close)
      (setf insides
            (add-fill-style-newlines insides
                                     string
                                     (if first-semi
                                         (format-directive-end first-semi)
                                         end))))
    (values prefix
            (and first-semi (format-directive-atsignp first-semi))
            insides
            suffix)))

(defun add-fill-style-newlines (list string offset)
  (declare (si::c-local))
  (if list
      (let ((directive (car list)))
        (if (simple-string-p directive)
            (nconc (add-fill-style-newlines-aux directive string offset)
                   (add-fill-style-newlines (cdr list)
                                            string
                                            (+ offset (length directive))))
            (cons directive
                  (add-fill-style-newlines (cdr list)
                                           string
                                           (format-directive-end directive)))))
      nil))

(defun add-fill-style-newlines-aux (literal string offset)
  (declare (si::c-local))
  (let ((end (length literal))
        (posn 0))
    (collect ((results))
             (loop
                (let ((blank (position #\space literal :start posn)))
                  (when (null blank)
                    (results (subseq literal posn))
                    (return))
                  (let ((non-blank (or (position #\space literal :start blank
                                                 :test #'char/=)
                                       end)))
                    (results (subseq literal posn non-blank))
                    (results (make-format-directive
                              :string string :character #\_
                              :start (+ offset non-blank) :end (+ offset non-blank)
                              :colonp t :atsignp nil :params nil))
                    (setf posn non-blank))
                  (when (= posn end)
                    (return))))
             (results))))

#+formatter
(defun expand-format-logical-block (prefix per-line-p insides suffix atsignp)
  `(let ((arg ,(if atsignp 'args (expand-next-arg))))
     ,@(when atsignp
             (setf *only-simple-args* nil)
             '((setf args nil)))
     (pprint-logical-block
         (stream arg
                 ,(if per-line-p :per-line-prefix :prefix) ,prefix
                 :suffix ,suffix)
       (let ((args arg)
             ,@(unless atsignp
                       `((orig-args arg))))
         (declare (ignorable args ,@(unless atsignp '(orig-args))))
         (block nil
           ,@(let ((*expander-next-arg-macro* 'expander-pprint-next-arg)
                   (*only-simple-args* nil)
                   (*orig-args-available* t))
                  (expand-directive-list insides)))))))

(defun interpret-format-logical-block
    (stream orig-args args prefix per-line-p insides suffix atsignp)
  (declare (si::c-local))
  (let ((arg (if atsignp args (next-arg))))
    (if per-line-p
        (pprint-logical-block
            (stream arg :per-line-prefix prefix :suffix suffix)
          (let ((*logical-block-popper* #'(lambda () (pprint-pop))))
            (catch 'up-and-out
              (interpret-directive-list stream insides
                                        (if atsignp orig-args arg)
                                        arg))))
        (pprint-logical-block (stream arg :prefix prefix :suffix suffix)
          (let ((*logical-block-popper* #'(lambda () (pprint-pop))))
            (catch 'up-and-out
              (interpret-directive-list stream insides
                                        (if atsignp orig-args arg)
                                        arg))))))
  (if atsignp nil args))

(def-complex-format-directive #\> ()
  (error 'format-error
         :complaint "No corresponding open bracket."))


;;;; User-defined method.

(def-format-directive #\/ (string start end colonp atsignp params)
  (let ((symbol (extract-user-function-name string start end)))
    (collect ((param-names) (bindings))
             (dolist (param-and-offset params)
               (let ((param (cdr param-and-offset)))
                 (let ((param-name (gensym)))
                   (param-names param-name)
                   (bindings `(,param-name
                               ,(case param
                                      (:arg (expand-next-arg))
                                      (:remaining '(length args))
                                      (t param)))))))
             `(let ,(bindings)
                (,symbol stream ,(expand-next-arg) ,colonp ,atsignp
                         ,@(param-names))))))

(def-format-interpreter #\/ (string start end colonp atsignp params)
  (let ((symbol (extract-user-function-name string start end)))
    (collect ((args))
      (dolist (param-and-offset params)
	(let ((param (cdr param-and-offset)))
	  (case param
	    (:arg (args (next-arg)))
	    (:remaining (args (length args)))
	    (t (args param)))))
      (apply (fdefinition symbol) stream (next-arg) colonp atsignp (args)))))

(defun extract-user-function-name (string start end)
  (declare (si::c-local))
  (let ((slash (position #\/ string :start start :end (1- end)
                         :from-end t)))
    (unless slash
      (error 'format-error
             :complaint "Malformed ~~/ directive."))
    (let* ((name (string-upcase (let ((foo string))
                                  ;; Hack alert: This is to keep the compiler
                                  ;; quit about deleting code inside the subseq
                                  ;; expansion.
                                  (subseq foo (1+ slash) (1- end)))))
           (first-colon (position #\: name))
           (second-colon (if first-colon (position #\: name :start (1+ first-colon))))
           (package-name (if first-colon
                             (subseq name 0 first-colon)
                             "COMMON-LISP-USER"))
           (package (find-package package-name)))
      (unless package
        (error 'format-error
               :complaint "No package named ~S"
               :arguments (list package-name)))
      (intern (cond
                ((and second-colon (= second-colon (1+ first-colon)))
                 (subseq name (1+ second-colon)))
                (first-colon
                 (subseq name (1+ first-colon)))
                (t name))
              package))))


;;;; Compile-time checking of format arguments and control string

#-ecl(progn
;;;
;;; Return the min/max numbers of arguments required for a call to
;;; FORMAT with control string FORMAT-STRING, null if we can't tell,
;;; or a string with an error message if parsing the control string
;;; causes a FORMAT-ERROR.
;;;
;;; This is called from FORMAT deftransforms.
;;;
       (defun min/max-format-arguments-count (string)
         #-formatter
         (declare (si::c-local))
         (handler-case
             (catch 'give-up
               ;; For the side effect of validating the control string.
               (%formatter string)
               (%min/max-format-args (tokenize-control-string string)))
           (format-error (e)
             (format nil "~a" e))))

       (defun %min/max-format-args (directives)
         #-formatter
         (declare (si::c-local))
         (let ((min-req 0) (max-req 0))
           (flet ((incf-both (&optional (n 1))
                    (incf min-req n)
                    (incf max-req n)))
             (loop
                (let ((dir (pop directives)))
                  (when (null dir)
                    (return (values min-req max-req)))
                  (when (format-directive-p dir)
                    (incf-both (count :arg (format-directive-params dir) :key #'cdr))
                    (let ((c (format-directive-character dir)))
                      (cond ((find c "ABCDEFGORSWX$/")
                             (incf-both))
                            ((char= c #\P)
                             (unless (format-directive-colonp dir)
                               (incf-both)))
                            ((or (find c "IT%&|_<>();") (char= c #\newline)))
                            ((char= c #\[)
                             (multiple-value-bind (min max remaining)
                                 (%min/max-conditional-args dir directives)
                               (setq directives remaining)
                               (incf min-req min)
                               (incf max-req max)))
                            ((char= c #\{)
                             (multiple-value-bind (min max remaining)
                                 (%min/max-iteration-args dir directives)
                               (setq directives remaining)
                               (incf min-req min)
                               (incf max-req max)))
                            ((char= c #\?)
                             (cond ((format-directive-atsignp dir)
                                    (incf min-req)
                                    (setq max-req most-positive-fixnum))
                                   (t (incf-both 2))))
                            (t (throw 'give-up nil))))))))))

;;;
;;; ANSI: if arg is out of range, no clause is selected.  That means
;;; the minimum number of args required for the interior of ~[~] is
;;; always zero.
;;;
       (defun %min/max-conditional-args (conditional directives)
         #-formatter
         (declare (si::c-local))
         (multiple-value-bind (sublists last-semi-with-colon-p remaining)
             (parse-conditional-directive directives)
           (declare (ignore last-semi-with-colon-p))
           (let ((sub-max (loop for s in sublists maximize
                               (nth-value 1 (%min/max-format-args s))))
                 (min-req 1)
                 max-req)
             (cond ((format-directive-atsignp conditional)
                    (setq max-req (max 1 sub-max)))
                   ((loop for p in (format-directive-params conditional)
                       thereis (or (integerp (cdr p))
                                   (memq (cdr p) '(:remaining :arg))))
                    (setq min-req 0)
                    (setq max-req sub-max))
                   (t
                    (setq max-req (1+ sub-max))))
             (values min-req max-req remaining))))

       (defun %min/max-iteration-args (iteration directives)
         #-formatter
         (declare (si::c-local))
         (let* ((close (find-directive directives #\} nil))
                (posn (position close directives))
                (remaining (nthcdr (1+ posn) directives)))
           (if (format-directive-atsignp iteration)
               (values (if (zerop posn) 1 0) most-positive-fixnum remaining)
               (let ((nreq (if (zerop posn) 2 1)))
                 (values nreq nreq remaining)))))
       )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/format.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/mp.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  MP.LSP  -- Multiprocessing capabilities.

;;;;  Copyright (c) 2003, Juan Jose Garcia-Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

#-threads
(defpackage "MP"
  (:use "CL" "SI")
  (:export "WITH-LOCK"))

(in-package "MP")

(defmacro without-interrupts (&body body)
  #!+sb-doc
  "Executes BODY with all deferrable interrupts disabled. Deferrable
interrupts arriving during execution of the BODY take effect after BODY has
been executed.

Deferrable interrupts include most blockable POSIX signals, and
MP:INTERRUPT-THREAD. Does not interfere with garbage collection, and
unlike in many traditional Lisps using userspace threads, in ECL
WITHOUT-INTERRUPTS does not inhibit scheduling of other threads.

Binds ALLOW-WITH-INTERRUPTS, WITH-LOCAL-INTERRUPTS and WITH-RESTORED-INTERRUPTS
as a local macros.

WITH-RESTORED-INTERRUPTS executes the body with interrupts enabled if and only
if the WITHOUT-INTERRUPTS was in an environment in which interrupts were allowed.

ALLOW-WITH-INTERRUPTS allows the WITH-INTERRUPTS to take effect during the
dynamic scope of its body, unless there is an outer WITHOUT-INTERRUPTS without
a corresponding ALLOW-WITH-INTERRUPTS.

WITH-LOCAL-INTERRUPTS executes its body with interrupts enabled provided that
for there is an ALLOW-WITH-INTERRUPTS for every WITHOUT-INTERRUPTS surrounding
the current one. WITH-LOCAL-INTERRUPTS is equivalent to:

  (allow-with-interrupts (with-interrupts ...))

Care must be taken not to let either ALLOW-WITH-INTERRUPTS or
WITH-LOCAL-INTERRUPTS appear in a function that escapes from inside the
WITHOUT-INTERRUPTS in:

  (without-interrupts
    ;; The body of the lambda would be executed with WITH-INTERRUPTS allowed
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (allow-with-interrupts ...)))

  (without-interrupts
    ;; The body of the lambda would be executed with interrupts enabled
    ;; regardless of the interrupt policy in effect when it is called.
    (lambda () (with-local-interrupts ...)))
"
  (ext:with-unique-names (outer-allow-with-interrupts outer-interrupts-enabled)
    `(multiple-value-prog1
         (macrolet ((allow-with-interrupts (&body allow-forms)
                      `(let ((si:*allow-with-interrupts* ,',outer-allow-with-interrupts))
                         ,@allow-forms))
                    (with-restored-interrupts (&body with-forms)
                      `(let ((si:*interrupts-enabled* ,',outer-interrupts-enabled))
                         ,@with-forms))
                    (with-local-interrupts (&body with-forms)
                      `(let* ((si:*allow-with-interrupts* ,',outer-allow-with-interrupts)
                              (si:*interrupts-enabled* ,',outer-allow-with-interrupts))
                         (when ,',outer-allow-with-interrupts
                           (si::check-pending-interrupts))
                         (locally ,@with-forms))))
           (let* ((,outer-interrupts-enabled si:*interrupts-enabled*)
                  (si:*interrupts-enabled* nil)
                  (,outer-allow-with-interrupts si:*allow-with-interrupts*)
                  (si:*allow-with-interrupts* nil))
             (declare (ignorable ,outer-allow-with-interrupts
                                 ,outer-interrupts-enabled))
             ,@body))
       (when si:*interrupts-enabled*
         (si::check-pending-interrupts)))))

(defmacro with-interrupts (&body body)
  "Executes BODY with deferrable interrupts conditionally enabled. If there
are pending interrupts they take effect prior to executing BODY.

As interrupts are normally allowed WITH-INTERRUPTS only makes sense if there
is an outer WITHOUT-INTERRUPTS with a corresponding ALLOW-WITH-INTERRUPTS:
interrupts are not enabled if any outer WITHOUT-INTERRUPTS is not accompanied
by ALLOW-WITH-INTERRUPTS."
  (ext:with-unique-names (allowp enablep)
    ;; We could manage without ENABLEP here, but that would require
    ;; taking extra care not to ever have *ALLOW-WITH-INTERRUPTS* NIL
    ;; and *INTERRUPTS-ENABLED* T -- instead of risking future breakage
    ;; we take the tiny hit here.
    `(let* ((,allowp si:*allow-with-interrupts*)
            (,enablep si:*interrupts-enabled*)
            (si:*interrupts-enabled* (or ,enablep ,allowp)))
       (when (and ,allowp (not ,enablep))
         (si::check-pending-interrupts))
       (locally ,@body))))

(defmacro with-lock ((lock-form &rest options) &body body)
  #-threads
  `(progn ,@body)
  ;; Why do we need %count? Even if get-lock succeeeds, an interrupt may
  ;; happen between the end of get-lock and when we save the output of
  ;; the function. That means we lose the information and ignore that
  ;; the lock was actually acquired. Furthermore, a lock can be recursive
  ;; and mp:lock-holder is also not reliable.
  ;;
  ;; Next notice how we need to disable interrupts around the body and
  ;; the get-lock statement, to ensure that the unlocking is done with
  ;; interrupts disabled.
  #+threads
  (ext:with-unique-names (lock owner count process)
    `(let* ((,lock ,lock-form)
            (,owner (mp:lock-owner ,lock))
            (,count (mp:lock-count ,lock)))
       (declare (type fixnum ,count))
       (without-interrupts
           (unwind-protect
                (with-restored-interrupts
                    (mp::get-lock ,lock)
                  (locally ,@body))
             (let ((,process mp:*current-process*))
               (declare (optimize (speed 3) (safety 0) (debug 0)))
               (when (and (eq ,process (mp:lock-owner ,lock))
                          (or (not (eq ,owner ,process))
                              (> (the fixnum (mp:lock-count ,lock))
                                 (the fixnum ,count))))
                 (mp::giveup-lock ,lock))))))))

#+ecl-read-write-lock
(defmacro with-rwlock ((lock op) &body body)
  "Acquire rwlock for the dynamic scope of BODY for operation OP,
which is executed with the lock held by current thread, and
WITH-RWLOCK returns the values of body.

Valid values of argument OP are :READ or :WRITE
\(for reader and writer access accordingly)."
  (assert (member op '(:read :write) :test #'eq))
  (let ((s-lock (gensym)))
    `(let ((,s-lock ,lock))
       (,(if (eq :read op)
             'mp:get-rwlock-read
             'mp:get-rwlock-write)
         ,s-lock t)
       (unwind-protect
            (progn
              ,@body)
         (,(if (eq :read op)
               'mp:giveup-rwlock-read
               'mp:giveup-rwlock-write)
           ,s-lock)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/mp.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/pprint.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;; -*- Package: PRETTY-PRINT -*-
;;;
;;; **********************************************************************
;;; This code was written as part of the CMU Common Lisp project at
;;; Carnegie Mellon University, and has been placed in the public domain.
;;;
;;; CMU Common Lisp pretty printer.
;;; Written by William Lott.  Algorithm stolen from Richard Waters' XP.
;;;

(in-package "SI")

(declaim #.+ecl-unsafe-declarations+)

;;;; Pretty streams

;;; There are three different units for measuring character positions:
;;;  COLUMN - offset (if characters) from the start of the current line.
;;;  INDEX - index into the output buffer.
;;;  POSN - some position in the stream of characters cycling through
;;;             the output buffer.
;;; 
(deftype column ()
  '(and fixnum unsigned-byte))
;;; The INDEX type is picked up from the kernel package.
(deftype posn ()
  'fixnum)

(defconstant initial-buffer-size 128)

(defconstant default-line-length 80)

(defclass pretty-stream (gray:fundamental-character-output-stream) (
  ;;
  ;; Where the output is going to finally go.
  ;;
  (target :initarg :target :initform t :type stream
          :accessor pretty-stream-target)
  ;;
  ;; Line length we should format to.  Cached here so we don't have to keep
  ;; extracting it from the target stream.
  (line-length :initform (or *print-right-margin* default-line-length)
               :type column
               :accessor pretty-stream-line-length)
  ;;
  ;; A simple string holding all the text that has been output but not yet
  ;; printed.
  (buffer :initform (make-string initial-buffer-size) :type simple-string
          :accessor pretty-stream-buffer)
  ;;
  ;; The index into BUFFER where more text should be put.
  (buffer-fill-pointer :initform 0 :type index :accessor pretty-stream-buffer-fill-pointer)
  ;;
  ;; Whenever we output stuff from the buffer, we shift the remaining noise
  ;; over.  This makes it difficult to keep references to locations in
  ;; the buffer.  Therefore, we have to keep track of the total amount of
  ;; stuff that has been shifted out of the buffer.
  (buffer-offset :initform 0 :type posn :accessor pretty-stream-buffer-offset)
  ;;
  ;; The column the first character in the buffer will appear in.  Normally
  ;; zero, but if we end up with a very long line with no breaks in it we
  ;; might have to output part of it.  Then this will no longer be zero.
  (buffer-start-column :initarg :buffer-start-column :type column
                       :accessor pretty-stream-buffer-start-column)
  ;;
  ;; The line number we are currently on.  Used for *print-lines* abrevs and
  ;; to tell when sections have been split across multiple lines.
  (line-number :initform 0 :type index
               :accessor pretty-stream-line-number)
  ;;
  ;; Stack of logical blocks in effect at the buffer start.
  (blocks :initform (list (make-logical-block)) :type list
               :accessor pretty-stream-blocks)
  ;;
  ;; Buffer holding the per-line prefix active at the buffer start.
  ;; Indentation is included in this.  The length of this is stored
  ;; in the logical block stack.
  (prefix :initform (make-string initial-buffer-size) :type string
               :accessor pretty-stream-prefix)
  ;;
  ;; Buffer holding the total remaining suffix active at the buffer start.
  ;; The characters are right-justified in the buffer to make it easier
  ;; to output the buffer.  The length is stored in the logical block
  ;; stack.
  (suffix :initform (make-string initial-buffer-size) :type string
          :accessor pretty-stream-suffix)
  ;;
  ;; Queue of pending operations.  When empty, HEAD=TAIL=NIL.  Otherwise,
  ;; TAIL holds the first (oldest) cons and HEAD holds the last (newest)
  ;; cons.  Adding things to the queue is basically (setf (cdr head) (list
  ;; new)) and removing them is basically (pop tail) [except that care must
  ;; be taken to handle the empty queue case correctly.]
  (queue-tail :initform nil :type list :accessor pretty-stream-queue-tail)
  (queue-head :initform nil :type list :accessor pretty-stream-queue-head)
  ;;
  ;; Block-start queue entries in effect at the queue head.
  (pending-blocks :initform nil :type list :accessor pretty-stream-pending-blocks)
  )
  (:sealedp t)
)

(defun pretty-stream-p (stream)
  (typep stream 'pretty-stream))

(defun make-pretty-stream (target)
  (make-instance 'pretty-stream :target target
                 :buffer-start-column (or (file-column target) 0)
                 ))

(defmethod print-object ((pretty-stream pretty-stream) stream)
  (print-unreadable-object (pretty-stream stream :type t :identity t))
  #+nil
  (format stream "#<pretty stream {~8,'0X}>"
          (kernel:get-lisp-obj-address pretty-stream)))

(declaim (inline index-posn posn-index posn-column))
(defun index-posn (index stream)
  (declare (type index index) (type pretty-stream stream))
  (+ index (pretty-stream-buffer-offset stream)))
(defun posn-index (posn stream)
  (declare (type posn posn) (type pretty-stream stream))
  (- posn (pretty-stream-buffer-offset stream)))
(defun posn-column (posn stream)
  (declare (type posn posn) (type pretty-stream stream))
  (index-column (posn-index posn stream) stream))


;;;; Stream interface routines.

(defmethod gray::stream-write-char ((stream pretty-stream) char)
  (pretty-out stream char))

(defmethod gray::stream-force-output ((stream pretty-stream))
  (declare (ignore stream))
  ;(force-pretty-output stream)
)

(defmethod gray::stream-clear-output ((stream pretty-stream))
  (declare (type pretty-stream stream))
  (clear-output (pretty-stream-target stream)))

(defun pretty-out (stream char)
  (declare (type pretty-stream stream)
           (type character char)
           (si::c-local))
  (cond ((char= char #\newline)
         (enqueue-newline stream :literal))
        (t
         (assure-space-in-buffer stream 1)
         (let ((fill-pointer (pretty-stream-buffer-fill-pointer stream)))
           (setf (schar (pretty-stream-buffer stream) fill-pointer) char)
           (setf (pretty-stream-buffer-fill-pointer stream)
                 (1+ fill-pointer))))))

(defun pretty-sout (stream string start end)
  (declare (type pretty-stream stream)
           (type string string)
           (type index start)
           (type (or index null) end)
           (si::c-local))
  (let ((end (or end (length string))))
    (unless (= start end)
      (let ((newline (position #\newline string :start start :end end)))
        (cond
         (newline
          (pretty-sout stream string start newline)
          (enqueue-newline stream :literal)
          (pretty-sout stream string (1+ newline) end))
         (t
          (let ((chars (- end start)))
            (loop
              (let* ((available (assure-space-in-buffer stream chars))
                     (count (min available chars))
                     (fill-pointer (pretty-stream-buffer-fill-pointer stream))
                     (new-fill-ptr (+ fill-pointer count)))
                (replace (pretty-stream-buffer stream)
                         string
                         :start1 fill-pointer :end1 new-fill-ptr
                         :start2 start)
                (setf (pretty-stream-buffer-fill-pointer stream) new-fill-ptr)
                (decf chars count)
                (when (zerop count)
                  (return))
                (incf start count))))))))))


;;;; Logical blocks.

(defstruct logical-block
  ;;
  ;; The column this logical block started in.
  (start-column 0 :type column)
  ;;
  ;; The column the current section started in.
  (section-column 0 :type column)
  ;;
  ;; The length of the per-line prefix.  We can't move the indentation
  ;; left of this.
  (per-line-prefix-end 0 :type index)
  ;;
  ;; The overall length of the prefix, including any indentation.
  (prefix-length 0 :type index)
  ;;
  ;; The overall length of the suffix.
  (suffix-length 0 :type index)
  ;; 
  ;; The line number 
  (section-start-line 0 :type index))

(defun really-start-logical-block (stream column prefix suffix)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((blocks (pretty-stream-blocks stream))
         (prev-block (car blocks))
         (per-line-end (logical-block-per-line-prefix-end prev-block))
         (prefix-length (logical-block-prefix-length prev-block))
         (suffix-length (logical-block-suffix-length prev-block))
         (block (make-logical-block
                 :start-column column
                 :section-column column
                 :per-line-prefix-end per-line-end
                 :prefix-length prefix-length
                 :suffix-length suffix-length
                 :section-start-line (pretty-stream-line-number stream))))
    (setf (pretty-stream-blocks stream) (cons block blocks))
    (set-indentation stream column)
    (when prefix
      (setf (logical-block-per-line-prefix-end block) column)
      (replace (pretty-stream-prefix stream) prefix
               :start1 (- column (length prefix)) :end1 column))
    (when suffix
      (let* ((total-suffix (pretty-stream-suffix stream))
             (total-suffix-len (length total-suffix))
             (additional (length suffix))
             (new-suffix-len (+ suffix-length additional)))
        (when (> new-suffix-len total-suffix-len)
          (let ((new-total-suffix-len
                 (max (* total-suffix-len 2)
                      (+ suffix-length
                         (floor (* additional 5) 4)))))
            (setf total-suffix
                  (replace (make-string new-total-suffix-len) total-suffix
                           :start1 (- new-total-suffix-len suffix-length)
                           :start2 (- total-suffix-len suffix-length)))
            (setf total-suffix-len new-total-suffix-len)
            (setf (pretty-stream-suffix stream) total-suffix)))
        (replace total-suffix suffix
                 :start1 (- total-suffix-len new-suffix-len)
                 :end1 (- total-suffix-len suffix-length))
        (setf (logical-block-suffix-length block) new-suffix-len))))
  nil)

(defun set-indentation (stream column)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((prefix (pretty-stream-prefix stream))
         (prefix-len (length prefix))
         (block (car (pretty-stream-blocks stream)))
         (current (logical-block-prefix-length block))
         (minimum (logical-block-per-line-prefix-end block))
         (column (max minimum column)))
    (when (> column prefix-len)
      (setf prefix
            (replace (make-string (max (* prefix-len 2)
                                       (+ prefix-len
                                          (floor (* (- column prefix-len) 5)
                                                 4))))
                     prefix
                     :end1 current))
      (setf (pretty-stream-prefix stream) prefix))
    (when (> column current)
      (fill prefix #\space :start current :end column))
    (setf (logical-block-prefix-length block) column)))

(defun really-end-logical-block (stream)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((old (pop (pretty-stream-blocks stream)))
         (old-indent (logical-block-prefix-length old))
         (new (car (pretty-stream-blocks stream)))
         (new-indent (logical-block-prefix-length new)))
    (when (> new-indent old-indent)
      (fill (pretty-stream-prefix stream) #\space
            :start old-indent :end new-indent)))
  nil)


;;;; The pending operation queue.

(defstruct queued-op
  (posn 0 :type posn))

(eval-when (:compile-toplevel :execute)
(defmacro enqueue (stream type &rest args)
  (let ((constructor (intern (concatenate 'string
                                          "MAKE-"
                                          (symbol-name type)))))
    (once-only ((stream stream)
                (entry `(,constructor :posn
                                      (index-posn
                                       (pretty-stream-buffer-fill-pointer
                                        (truly-the pretty-stream ,stream))
                                       ,stream)
                                      ,@args))
                (op `(list ,entry))
                (head `(pretty-stream-queue-head (truly-the pretty-stream ,stream))))
      `(progn
         (if ,head
             (setf (cdr ,head) ,op)
             (setf (pretty-stream-queue-tail (truly-the pretty-stream ,stream)) ,op))
         (setf (pretty-stream-queue-head (truly-the pretty-stream ,stream)) ,op)
         ,entry))))
)

(defstruct (section-start
            (:include queued-op))
  (depth 0 :type index)
  (section-end nil :type (or null newline block-end)))

(defstruct (newline
            (:include section-start))
  (kind (required-argument)
        :type (member :linear :fill :miser :literal :mandatory)))

(defun enqueue-newline (stream kind)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((depth (length (pretty-stream-pending-blocks stream)))
         (newline (enqueue stream newline :kind kind :depth depth)))
    (dolist (entry (pretty-stream-queue-tail stream))
      (when (and (not (eq newline entry))
                 (section-start-p entry)
                 (null (section-start-section-end entry))
                 (<= depth (section-start-depth entry)))
        (setf (section-start-section-end entry) newline))))
  (maybe-output stream (or (eq kind :literal) (eq kind :mandatory))))

(defstruct (indentation
            (:include queued-op))
  (kind (required-argument) :type (member :block :current))
  (amount 0 :type fixnum))

(defun enqueue-indent (stream kind amount)
  (declare (si::c-local))
  (enqueue stream indentation :kind kind :amount amount))

(defstruct (block-start
            (:include section-start))
  (block-end nil :type (or null block-end))
  (prefix nil :type (or null string))
  (suffix nil :type (or null string)))

(defun start-logical-block (stream prefix per-line-p suffix)
  (declare (si::c-local)
           (type string prefix suffix)
           (type pretty-stream stream)
           (ext:check-arguments-type))
  (let ((prefix-len (length prefix)))
    (when (plusp prefix-len)
      (pretty-sout stream prefix 0 prefix-len))
    (let* ((pending-blocks (pretty-stream-pending-blocks stream))
           (start (enqueue stream block-start
                           :prefix (and (plusp prefix-len) per-line-p prefix)
                           :suffix (and (plusp (length suffix)) suffix)
                           :depth (length pending-blocks))))
      (setf (pretty-stream-pending-blocks stream)
            (cons start pending-blocks)))))

(defstruct (block-end
            (:include queued-op))
  (suffix nil :type (or null string)))

(defun end-logical-block (stream)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((start (pop (pretty-stream-pending-blocks stream)))
         (suffix (block-start-suffix start))
         (end (enqueue stream block-end :suffix suffix)))
    (when suffix
      (pretty-sout stream suffix 0 (length suffix)))
    (setf (block-start-block-end start) end)))

(defstruct (tab
            (:include queued-op))
  (sectionp nil :type (member t nil))
  (relativep nil :type (member t nil))
  (colnum 0 :type column)
  (colinc 0 :type column))

(defun enqueue-tab (stream kind colnum colinc)
  (declare (si::c-local))
  (multiple-value-bind
      (sectionp relativep)
      (ecase kind
        (:line (values nil nil))
        (:line-relative (values nil t))
        (:section (values t nil))
        (:section-relative (values t t)))
    (enqueue stream tab :sectionp sectionp :relativep relativep
             :colnum colnum :colinc colinc)))


;;;; Tab support.

(defun compute-tab-size (tab section-start column)
  (declare (si::c-local))
  (let ((colnum (tab-colnum tab))
        (colinc (tab-colinc tab)))
    (when (tab-sectionp tab)
      (setf column (- column section-start)))
    (cond ((tab-relativep tab)
           (unless (<= colinc 1)
             (let ((newposn (+ column colnum)))
               (let ((rem (rem newposn colinc)))
                 (unless (zerop rem)
                   (incf colnum (- colinc rem))))))
           colnum)
          ((< column colnum)
           (- colnum column))
          ((= column colnum)
           colinc)
          ((plusp colinc)
           (- colinc (rem (- column colnum) colinc)))
          (t
           0))))

(defun index-column (index stream)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let ((column (pretty-stream-buffer-start-column stream))
        (section-start (logical-block-section-column
                        (first (pretty-stream-blocks stream))))
        (end-posn (index-posn index stream)))
    (dolist (op (pretty-stream-queue-tail stream))
      (when (>= (queued-op-posn op) end-posn)
        (return))
      (typecase op
        (tab
         (incf column
               (compute-tab-size op
                                 section-start
                                 (+ column
                                    (posn-index (tab-posn op)
                                                    stream)))))
        ((or newline block-start)
         (setf section-start
               (+ column (posn-index (queued-op-posn op)
                                         stream))))))
    (+ column index)))

(defun expand-tabs (stream through)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let ((insertions nil)
        (additional 0)
        (column (pretty-stream-buffer-start-column stream))
        (section-start (logical-block-section-column
                        (first (pretty-stream-blocks stream)))))
    (dolist (op (pretty-stream-queue-tail stream))
      (typecase op
        (tab
         (let* ((index (posn-index (tab-posn op) stream))
                (tabsize (compute-tab-size op
                                           section-start
                                           (+ column index))))
           (unless (zerop tabsize)
             (push (cons index tabsize) insertions)
             (incf additional tabsize)
             (incf column tabsize))))
        ((or newline block-start)
         (setf section-start
               (+ column (posn-index (queued-op-posn op) stream)))))
      (when (eq op through)
        (return)))
    (when insertions
      (let* ((fill-ptr (pretty-stream-buffer-fill-pointer stream))
             (new-fill-ptr (+ fill-ptr additional))
             (buffer (pretty-stream-buffer stream))
             (new-buffer buffer)
             (length (length buffer))
             (end fill-ptr))
        (when (> new-fill-ptr length)
          (let ((new-length (max (* length 2)
                                 (+ fill-ptr
                                    (floor (* additional 5) 4)))))
            (setf new-buffer (make-string new-length))
            (setf (pretty-stream-buffer stream) new-buffer)))
        (setf (pretty-stream-buffer-fill-pointer stream) new-fill-ptr)
        (decf (pretty-stream-buffer-offset stream) additional)
        (dolist (insertion insertions)
          (let* ((srcpos (car insertion))
                 (amount (cdr insertion))
                 (dstpos (+ srcpos additional)))
            (replace new-buffer buffer :start1 dstpos :start2 srcpos :end2 end)
            (fill new-buffer #\space :start (- dstpos amount) :end dstpos)
            (decf additional amount)
            (setf end srcpos)))
        (unless (eq new-buffer buffer)
          (replace new-buffer buffer :end1 end :end2 end))))))


;;;; Stuff to do the actual outputting.

(defun assure-space-in-buffer (stream want)
  (declare (type pretty-stream stream)
           (type index want)
           (si::c-local))
  (let* ((buffer (pretty-stream-buffer stream))
         (length (length buffer))
         (fill-ptr (pretty-stream-buffer-fill-pointer stream))
         (available (- length fill-ptr)))
    (cond ((plusp available)
           available)
          ((> fill-ptr (pretty-stream-line-length stream))
           (unless (maybe-output stream nil)
             (output-partial-line stream))
           (assure-space-in-buffer stream want))
          (t
           (let* ((new-length (max (* length 2)
                                   (+ length
                                      (floor (* want 5) 4))))
                  (new-buffer (make-string new-length)))
             (setf (pretty-stream-buffer stream) new-buffer)
             (replace new-buffer buffer :end1 fill-ptr)
             (- new-length fill-ptr))))))

(defun maybe-output (stream force-newlines-p)
  (declare (type pretty-stream stream)
           (si::c-local))
  (let ((tail (pretty-stream-queue-tail stream))
        (output-anything nil))
    (loop
      (unless tail
        (setf (pretty-stream-queue-head stream) nil)
        (return))
      (let ((next (pop tail)))
        (etypecase next
          (newline
           (when (ecase (newline-kind next)
                   ((:literal :mandatory :linear) t)
                   (:miser (misering-p stream))
                   (:fill
                    (or (misering-p stream)
                        (> (pretty-stream-line-number stream)
                           (logical-block-section-start-line
                            (first (pretty-stream-blocks stream))))
                        (ecase (fits-on-line-p stream
                                               (newline-section-end next)
                                               force-newlines-p)
                          ((t) nil)
                          ((nil) t)
                          (:dont-know
                           (return))))))
             (setf output-anything t)
             (output-line stream next)))
          (indentation
           (unless (misering-p stream)
             (set-indentation stream
                              (+ (ecase (indentation-kind next)
                                   (:block
                                    (logical-block-start-column
                                     (car (pretty-stream-blocks stream))))
                                   (:current
                                    (posn-column
                                     (indentation-posn next)
                                     stream)))
                                 (indentation-amount next)))))
          (block-start
           (ecase (fits-on-line-p stream (block-start-section-end next)
                                  force-newlines-p)
             ((t)
              ;; Just nuke the whole logical block and make it look like one
              ;; nice long literal.
              (let ((end (block-start-block-end next)))
                (expand-tabs stream end)
                (setf tail (cdr (member end tail)))))
             ((nil)
              (really-start-logical-block
               stream
               (posn-column (block-start-posn next) stream)
               (block-start-prefix next)
               (block-start-suffix next)))
             (:dont-know
              (return))))
          (block-end
           (really-end-logical-block stream))
          (tab
           (expand-tabs stream next))))
      (setf (pretty-stream-queue-tail stream) tail))
    output-anything))

(defun misering-p (stream)
  (declare (type pretty-stream stream)
           (si::c-local))
  (and *print-miser-width*
       (<= (- (pretty-stream-line-length stream)
              (logical-block-start-column (car (pretty-stream-blocks stream))))
           *print-miser-width*)))

(defun fits-on-line-p (stream until force-newlines-p)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let ((available (pretty-stream-line-length stream)))
    (when (and (not *print-readably*) *print-lines*
               (= *print-lines* (pretty-stream-line-number stream)))
      (decf available 3) ; for the `` ..''
      (decf available (logical-block-suffix-length
                       (car (pretty-stream-blocks stream)))))
    (cond (until
           (<= (posn-column (queued-op-posn until) stream) available))
          (force-newlines-p nil)
          ((> (index-column (pretty-stream-buffer-fill-pointer stream) stream)
              available)
           nil)
          (t
           :dont-know))))

(defun output-line (stream until)
  (declare (type pretty-stream stream)
           (type newline until)
           (si::c-local))
  (let* ((target (pretty-stream-target stream))
         (buffer (pretty-stream-buffer stream))
         (kind (newline-kind until))
         (literal-p (eq kind :literal))
         (amount-to-consume (posn-index (newline-posn until) stream))
         (amount-to-print
          (if literal-p
              amount-to-consume
              (let ((last-non-blank
                     (position #\space buffer :end amount-to-consume
                               :from-end t :test #'char/=)))
                (if last-non-blank
                    (1+ last-non-blank)
                    0)))))
    (write-string buffer target :end amount-to-print)
    (let ((line-number (pretty-stream-line-number stream)))
      (incf line-number)
      (when (and (not *print-readably*)
                 *print-lines* (>= line-number *print-lines*))
        (write-string " .." target)
        (let ((suffix-length (logical-block-suffix-length
                              (car (pretty-stream-blocks stream)))))
          (unless (zerop suffix-length)
            (let* ((suffix (pretty-stream-suffix stream))
                   (len (length suffix)))
              (write-string suffix target
                            :start (- len suffix-length)
                            :end len))))
        (throw 'line-limit-abbreviation-happened t))
      (setf (pretty-stream-line-number stream) line-number)
      (write-char #\newline target)
      (setf (pretty-stream-buffer-start-column stream) 0)
      (let* ((fill-ptr (pretty-stream-buffer-fill-pointer stream))
             (block (first (pretty-stream-blocks stream)))
             (prefix-len
              (if literal-p
                  (logical-block-per-line-prefix-end block)
                  (logical-block-prefix-length block)))
             (shift (- amount-to-consume prefix-len))
             (new-fill-ptr (- fill-ptr shift))
             (new-buffer buffer)
             (buffer-length (length buffer)))
        (when (> new-fill-ptr buffer-length)
          (setf new-buffer
                (make-string (max (* buffer-length 2)
                                  (+ buffer-length
                                     (floor (* (- new-fill-ptr buffer-length)
                                               5)
                                            4)))))
          (setf (pretty-stream-buffer stream) new-buffer))
        (replace new-buffer buffer
                 :start1 prefix-len :start2 amount-to-consume :end2 fill-ptr)
        (replace new-buffer (pretty-stream-prefix stream)
                 :end1 prefix-len)
        (setf (pretty-stream-buffer-fill-pointer stream) new-fill-ptr)
        (incf (pretty-stream-buffer-offset stream) shift)
        (unless literal-p
          (setf (logical-block-section-column block) prefix-len)
          (setf (logical-block-section-start-line block) line-number))))))

(defun output-partial-line (stream)
  (declare (si::c-local)
           (type pretty-stream stream))
  (let* ((fill-ptr (pretty-stream-buffer-fill-pointer stream))
         (tail (pretty-stream-queue-tail stream))
         (count
          (if tail
              (posn-index (queued-op-posn (car tail)) stream)
              fill-ptr))
         (new-fill-ptr (- fill-ptr count))
         (buffer (pretty-stream-buffer stream)))
    (when (zerop count)
      (error "Output-partial-line called when nothing can be output."))
    (write-string buffer (pretty-stream-target stream)
                  :start 0 :end count)
    (incf (pretty-stream-buffer-start-column stream) count)
    (replace buffer buffer :end1 new-fill-ptr :start2 count :end2 fill-ptr)
    (setf (pretty-stream-buffer-fill-pointer stream) new-fill-ptr)
    (incf (pretty-stream-buffer-offset stream) count)))

(defun force-pretty-output (stream)
  (declare (si::c-local)
           (type pretty-stream stream))
  (maybe-output stream nil)
  (expand-tabs stream nil)
  (write-string (pretty-stream-buffer stream)
                (pretty-stream-target stream)
                :end (pretty-stream-buffer-fill-pointer stream)))


;;;; Utilities.

(defun pprint-pop-helper (object count stream &aux code)
  (cond ((not (listp object))
         (write-string ". " stream)
         (write-object object stream)
         nil)
        ((and (not *print-readably*)
              (eql count *print-length*))
         (write-string "..." stream)
         nil)
        ((or (null object)
             (zerop count)
             (fixnump object)
             (characterp object)
             (and (symbolp object) (symbol-package object))
             (null *circle-counter*))
         t)
        ((eql 'NULL (setf code (gethash object *circle-stack* 'NULL)))
         ;; We visit this part of the list for the first time and thus we must
         ;; register it in the hash, or we are on the second pass and have
         ;; found a completely new list. This should not happend, but anyway
         ;; we try to print it.
         (search-print-circle object)
         t)
        ((and (null code) (integerp *circle-counter*))
         ;; This object is not visited twice.
         t)
        (t
         ;; In all other cases, WRITE-OBJECT
         (write-string ". " stream)
         (write-object object stream)
         nil)))

;;;; User interface to the pretty printer.

(defun check-print-level ()
  (declare (si::c-local))
  "Automatically handle *print-level* abbreviation.  If we are too deep, then
   a # is printed to STREAM and BODY is ignored."
  (cond ((or *print-readably* (null *print-level*))
         t)
        ((zerop *print-level*)
         nil)
        (t
         (setf *print-level* (1- *print-level*)))))

(defun search-print-circle (object)
  (declare (si::c-local))
  (let ((code (gethash object *circle-stack* -1)))
    (if (fixnump *circle-counter*)
        (cond ((or (eql code -1) (null code))
               ;; Is not referenced or was not found before
               0)
              ((eql code t)
               ;; Reference twice but had no code yet
               (setf (gethash object *circle-stack*)
                     (setf *circle-counter* (1+ *circle-counter*)))
               (- *circle-counter*))
              (t code))
        (cond ((eql code -1)
               ;; Was not found before
               (setf (gethash object *circle-stack*) nil)
               0)
              ((null code)
               ;; Second reference
               (setf (gethash object *circle-stack*) t)
               1)
              (t
               ;; Further references
               2)))))

(defun do-pprint-logical-block (function object stream prefix
                                per-line-prefix-p suffix)
  (declare (si::c-local))
  (unless (listp object)
    (write-object object stream)
    (return-from do-pprint-logical-block nil))
  (when (and (not *print-readably*) (eql *print-level* 0))
    (write-char #\# stream)
    (return-from do-pprint-logical-block nil))
  (unless (or (not *print-circle*)
              (fixnump object)
              (characterp object)
              (and (symbolp object) (symbol-package object)))
    (let (code)
      (cond ((not *circle-counter*)
             (let* ((hash (make-hash-table :test 'eq :size 1024
                                           :rehash-size 1.5
                                           :rehash-threshold 0.75))
                    (*circle-counter* t)
                    (*circle-stack* hash))
               (do-pprint-logical-block function object
                                        (make-pretty-stream (make-broadcast-stream))
                                        prefix per-line-prefix-p suffix)
               (setf *circle-counter* 0)
               (do-pprint-logical-block function object stream
                                        prefix per-line-prefix-p suffix))
             (return-from do-pprint-logical-block nil))
            ((zerop (setf code (search-print-circle object)))
             ;; Object was not referenced before: we must either traverse it
             ;; or print it.
             )
            ((minusp code)
             ;; First definition, we write the #n=... prefix
             (write-string "#" stream)
             (let ((*print-radix* nil) (*print-base* 10))
               (write-ugly-object (- code) stream))
             (write-string "=" stream))
            (t
             ;; Further references, we write the #n# tag and exit
             (write-string "#" stream)
             (let ((*print-radix* nil) (*print-base* 10))
               (write-ugly-object code stream))
             (write-string "#" stream)
             (return-from do-pprint-logical-block nil)))))
  (let ((*print-level* (and (not *print-readably*)
                            *print-level*
                            (1- *print-level*))))
    (start-logical-block stream prefix per-line-prefix-p suffix)
    (funcall function object stream)
    (end-logical-block stream))
  nil)

(defun pprint-logical-block-helper (function object stream prefix
                                    per-line-prefix-p suffix)
  (setf stream (case stream
                 ((nil) *standard-output*)
                 ((t) *terminal-io*)
                 (t stream)))
  (if (pretty-stream-p stream)
      (do-pprint-logical-block function object stream prefix
                               per-line-prefix-p suffix)
      (let ((stream (make-pretty-stream stream)))
        (catch 'line-limit-abbreviation-happened
          (do-pprint-logical-block function object stream prefix
                                   per-line-prefix-p suffix)
          (force-pretty-output stream))
        nil)))

(defmacro pprint-logical-block
          ((stream-symbol object &key (prefix "" prefix-p)
                          (per-line-prefix "" per-line-prefix-p)
                          (suffix "" suffix-p))
           &body body)
  "Group some output into a logical block.  STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*).  The printer
   control variable *PRINT-LEVEL* is automatically handled."
  (declare #.+ecl-safe-declarations+)
  (when per-line-prefix-p
    (when prefix-p
      (error "Cannot specify both a prefix and a per-line-prefix."))
    (setf prefix per-line-prefix))
  (let* ((object-var (gensym))
         (block-name (gensym "PPRINT-LOGICAL-BLOCK-"))
         (count-name (gensym "PPRINT-LOGICAL-BLOCK-LENGTH-"))
         (stream-var (case stream-symbol
                       ((nil) '*standard-output*)
                       ((t) '*terminal-io*)
                       (t stream-symbol)))
         (function
          `(ext::lambda-block ,block-name (,object-var ,stream-var
                                           &aux (,count-name 0))
            (declare (ignorable ,object-var ,stream-var ,count-name))
            (macrolet ((pprint-pop ()
                         '(progn
                           (unless (pprint-pop-helper ,object-var ,count-name
                                                      ,stream-var)
                             (return-from ,block-name nil))
                           (incf ,count-name)
                           ,(if object `(pop ,object-var) nil)))
                       (pprint-exit-if-list-exhausted ()
                         ,(if object
                              `'(when (null ,object-var)
                                 (return-from ,block-name nil))
                              `'(return-from ,block-name nil))))
              ,@body))))
      `(pprint-logical-block-helper #',function ,object ,stream-symbol
                                    ,prefix ,per-line-prefix-p ,suffix)))

(defmacro pprint-exit-if-list-exhausted ()
  "Cause the closest enclosing use of PPRINT-LOGICAL-BLOCK to return
   if it's list argument is exhausted.  Can only be used inside
   PPRINT-LOGICAL-BLOCK, and only when the LIST argument to
   PPRINT-LOGICAL-BLOCK is supplied."
  (declare #.+ecl-safe-declarations+)
  (error "PPRINT-EXIT-IF-LIST-EXHAUSTED must be lexically inside ~
          PPRINT-LOGICAL-BLOCK."))

(defmacro pprint-pop ()
  "Return the next element from LIST argument to the closest enclosing
   use of PPRINT-LOGICAL-BLOCK, automatically handling *PRINT-LENGTH*
   and *PRINT-CIRCLE*.  Can only be used inside PPRINT-LOGICAL-BLOCK.
   If the LIST argument to PPRINT-LOGICAL-BLOCK was NIL, then nothing
   is poped, but the *PRINT-LENGTH* testing still happens."
  (declare #.+ecl-safe-declarations+)
  (error "PPRINT-POP must be lexically inside PPRINT-LOGICAL-BLOCK."))

(defun pprint-newline (kind &optional stream)
  "Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not.  KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line.  (See PPRINT-INDENT.)"
  (declare (type (member :linear :miser :fill :mandatory) kind)
           (type (or stream (member t nil)) stream)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (let ((stream (case stream
                  ((t) *terminal-io*)
                  ((nil) *standard-output*)
                  (t stream))))
    (when (and (pretty-stream-p stream) *print-pretty*)
      (enqueue-newline stream kind)))
  nil)

(defun pprint-indent (relative-to n &optional stream)
  "Specify the indentation to use in the current logical block if STREAM
   (which defaults to *STANDARD-OUTPUT*) is it is a pretty-printing stream
   and do nothing if not.  (See PPRINT-LOGICAL-BLOCK.)  N is the indention
   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:
     :BLOCK - Indent relative to the column the current logical block
        started on.
     :CURRENT - Indent relative to the current column.
   The new indention value does not take effect until the following line
   break."
  (declare (type (member :block :current) relative-to)
           (type real n)
           (type (or stream (member t nil)) stream)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (let ((stream (case stream
                  ((t) *terminal-io*)
                  ((nil) *standard-output*)
                  (t stream))))
    (when (and (pretty-stream-p stream) *print-pretty*)
      (enqueue-indent stream relative-to (round n))))
  nil)

(defun pprint-tab (kind colnum colinc &optional stream)
  "If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing.  KIND can
   be one of:
     :LINE - Tab to column COLNUM.  If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line."
  (declare (type (member :line :section :line-relative :section-relative) kind)
           (type unsigned-byte colnum colinc)
           (type (or stream (member t nil)) stream)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (let ((stream (case stream
                  ((t) *terminal-io*)
                  ((nil) *standard-output*)
                  (t stream))))
    (when (and (pretty-stream-p stream) *print-pretty*)
      (enqueue-tab stream kind colnum colinc)))
  nil)

(defun pprint-fill (stream list &optional (colon? t) atsign?)
  "Output LIST to STREAM putting :FILL conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the ~/.../ format directive."
  (declare (ignore atsign?)
           (type (or stream (member t nil)) stream)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (pprint-logical-block (stream list
                                :prefix (if colon? "(" "")
                                :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop
      (write-object (pprint-pop) stream)
      (pprint-exit-if-list-exhausted)
      (write-char #\space stream)
      (pprint-newline :fill stream))))

(defun pprint-linear (stream list &optional (colon? t) atsign?)
  "Output LIST to STREAM putting :LINEAR conditional newlines between each
   element.  If COLON? is NIL (defaults to T), then no parens are printed
   around the output.  ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the ~/.../ format directive."
  (declare (ignore atsign?)
           (type (or stream (member t nil)) stream)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (pprint-logical-block (stream list
                                :prefix (if colon? "(" "")
                                :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop
      (write-object (pprint-pop) stream)
      (pprint-exit-if-list-exhausted)
      (write-char #\space stream)
      (pprint-newline :linear stream))))

(defun pprint-tabular (stream list &optional (colon? t) atsign? (tabsize 16))
  "Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element.  :FILL style
   conditional newlines are also output between each element.  If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the ~/.../ format directive."
  (declare (ignore atsign?)
           (type (or stream (member t nil)) stream)
           (type (or unsigned-byte null) tabsize)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (pprint-logical-block (stream list
                                :prefix (if colon? "(" "")
                                :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop
      (write-object (pprint-pop) stream)
      (pprint-exit-if-list-exhausted)
      (write-char #\space stream)
      (pprint-tab :section-relative 0 (or tabsize 16) stream)
      (pprint-newline :fill stream))))


;;;; Pprint-dispatch tables.

(defvar *standard-pprint-dispatch*)
(defvar *initial-pprint-dispatch*)

(defstruct (pprint-dispatch-entry
            (:print-function %print-pprint-dispatch-entry))
  ;;
  ;; The type specifier for this entry.
  (type (required-argument) :type t)
  ;;
  ;; The priority for this guy.
  (priority 0 :type real)
  ;;
  ;; T iff one of the original entries.
  (initial-p (not (boundp '*initial-pprint-dispatch*)) :type (member t nil))
  ;;
  ;; And the associated function.
  (function (required-argument) :type (or function symbol)))

(defun %print-pprint-dispatch-entry (entry stream depth)
  (declare (ignore depth))
  (print-unreadable-object (entry stream :type t)
    (format stream "Type=~S, priority=~S~@[ [Initial]~]"
            (pprint-dispatch-entry-type entry)
            (pprint-dispatch-entry-priority entry)
            (pprint-dispatch-entry-initial-p entry))))

(defstruct (pprint-dispatch-table
            (:print-function %print-pprint-dispatch-table))
  ;; Are we allowed to modify this table?
  (read-only-p nil)
  ;;
  ;; A list of all the entries (except for CONS entries below) in highest
  ;; to lowest priority.
  (entries nil :type list)
  ;;
  ;; A hash table mapping things to entries for type specifiers of the
  ;; form (CONS (MEMBER <thing>)).  If the type specifier is of this form,
  ;; we put it in this hash table instead of the regular entries table.
  (cons-entries (make-hash-table :test #'eql)))

(defun %print-pprint-dispatch-table (table stream depth)
  (declare (ignore depth))
  (print-unreadable-object (table stream :type t :identity t)))

(defun cons-type-specifier-p (spec)
  (declare (si::c-local))
  (and (consp spec)
       (eq (car spec) 'cons)
       (cdr spec)
       (null (cddr spec))
       (let ((car (cadr spec)))
         (and (consp car)
              (let ((carcar (car car)))
                (or (eq carcar 'member)
                    (eq carcar 'eql)))
              (cdr car)
              (null (cddr car))))))

(defun entry< (e1 e2)
  (declare (type pprint-dispatch-entry e1 e2)
           (si::c-local))
  (if (pprint-dispatch-entry-initial-p e1)
      (if (pprint-dispatch-entry-initial-p e2)
          (< (pprint-dispatch-entry-priority e1)
             (pprint-dispatch-entry-priority e2))
          t)
      (if (pprint-dispatch-entry-initial-p e2)
          nil
          (< (pprint-dispatch-entry-priority e1)
             (pprint-dispatch-entry-priority e2)))))


(defun copy-pprint-dispatch (&optional (table *print-pprint-dispatch*))
  (declare (type (or pprint-dispatch-table null) table)
           #.+ecl-safe-declarations+)
  (let* ((orig (or table *initial-pprint-dispatch*)))
    (let* ((new (make-pprint-dispatch-table
                 :entries (copy-list (pprint-dispatch-table-entries orig))))
           (new-cons-entries (pprint-dispatch-table-cons-entries new)))
      (maphash #'(lambda (key value)
                   (setf (gethash key new-cons-entries) value))
               (pprint-dispatch-table-cons-entries orig))
      new)))

(defun default-pprint-dispatch (stream object)
  (write-ugly-object object stream))

(defun pprint-dispatch (object &optional (table *print-pprint-dispatch*))
  (declare (type (or pprint-dispatch-table null) table)
           (ext:check-arguments-type)
           #.+ecl-safe-declarations+)
  (let* ((table (or table *initial-pprint-dispatch*))
         (cons-entry
          (and (consp object)
               (gethash (car object)
                        (pprint-dispatch-table-cons-entries table))))
         (entry
          (dolist (entry (pprint-dispatch-table-entries table) cons-entry)
            (when (and cons-entry
                       (entry< entry cons-entry))
              (return cons-entry))
            (when (typep object (pprint-dispatch-entry-type entry))
              (return entry)))))
    (if entry
        (values (pprint-dispatch-entry-function entry) t)
        (values #'default-pprint-dispatch nil))))

(defun set-pprint-dispatch (type function &optional
                            (priority 0) (table *print-pprint-dispatch*))
  (declare (type t type)
           (type (or null function symbol) function)
           (type real priority)
           (type pprint-dispatch-table table)
           #.+ecl-safe-declarations+)
  (when (pprint-dispatch-table-read-only-p table)
    (cerror "Ignore and continue"
            "Tried to modify a read-only pprint dispatch table: ~A"
            table))
  ;; FIXME! This check should be automatically generated when compiling
  ;; with high enough safety mode.
  (unless (typep priority 'real)
    (error 'simple-type-error
           :format-control "Not a valid priority for set-pprint-dispatch: ~A"
           :format-arguments (list priority)
           :expected-type 'real
           :datum priority))
  (if function
      (if (cons-type-specifier-p type)
          (setf (gethash (second (second type))
                         (pprint-dispatch-table-cons-entries table))
                (make-pprint-dispatch-entry :type type :priority priority
                                            :function function))
          (let ((list (delete type (pprint-dispatch-table-entries table)
                              :key #'pprint-dispatch-entry-type
                              :test #'equal))
                (entry (make-pprint-dispatch-entry
                        :type type
                        :priority priority :function function)))
            (do ((prev nil next)
                 (next list (cdr next)))
                ((null next)
                 (if prev
                     (setf (cdr prev) (list entry))
                     (setf list (list entry))))
              (when (entry< (car next) entry)
                (if prev
                    (setf (cdr prev) (cons entry next))
                    (setf list (cons entry next)))
                (return)))
            (setf (pprint-dispatch-table-entries table) list)))
      (if (cons-type-specifier-p type)
          (remhash (second (second type))
                   (pprint-dispatch-table-cons-entries table))
          (setf (pprint-dispatch-table-entries table)
                (delete type (pprint-dispatch-table-entries table)
                        :key #'pprint-dispatch-entry-type
                        :test #'equal))))
  nil)


;;;; Standard pretty-printing routines.

(defun pprint-array (stream array)
  (cond ((or (and (null *print-array*) (null *print-readably*))
             (stringp array)
             (bit-vector-p array))
         (write-ugly-object array stream))
        (*print-readably*
         (pprint-raw-array stream array))
        ((vectorp array)
         (pprint-vector stream array))
        (t
         (pprint-multi-dim-array stream array))))

(defun pprint-vector (stream vector)
  (pprint-logical-block (stream nil :prefix "#(" :suffix ")")
    (dotimes (i (length vector))
      (unless (zerop i)
        (write-char #\space stream)
        (pprint-newline :fill stream))
      (pprint-pop)
      (write-object (aref vector i) stream))))

(defun pprint-array-contents (stream array)
  (declare (si::c-local)
           (array array))
  (labels ((output-guts (stream index dimensions)
               (if (null dimensions)
                   (write-object (row-major-aref array index) stream)
                   (pprint-logical-block
                    (stream nil :prefix "(" :suffix ")")
                    (let ((dim (car dimensions)))
                      (unless (zerop dim)
                        (let* ((dims (cdr dimensions))
                               (index index)
                               (step (reduce #'* dims))
                               (count 0))
                          (loop                         
                           (pprint-pop)
                           (output-guts stream index dims)
                           (when (= (incf count) dim)
                             (return))
                           (write-char #\space stream)
                           (pprint-newline (if dims :linear :fill)
                                           stream)
                           (incf index step)))))))))
    (output-guts stream 0 (array-dimensions array))))

(defun pprint-multi-dim-array (stream array)
  (declare (si::c-local))
  (funcall (formatter "#~DA") stream (array-rank array))
  (pprint-array-contents stream array))

(defun pprint-raw-array (stream array)
  (declare (si::c-local))
  (write-string "#A" stream)
  (pprint-logical-block (stream nil :prefix "(" :suffix ")")
    (write-object (array-element-type array) stream)
    (write-char #\Space stream)
    (pprint-newline :fill stream)
    (write-object (array-dimensions array) stream)
    (write-char #\Space stream)
    (pprint-newline :fill stream)
    (pprint-array-contents stream array)))

(defun pprint-lambda-list (stream lambda-list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream lambda-list :prefix "(" :suffix ")")
    (let ((state :required)
          (first t))
      (loop
        (pprint-exit-if-list-exhausted)
        (unless first
          (write-char #\space stream))
        (let ((arg (pprint-pop)))
          (unless first
            (case arg
              (&optional
               (setf state :optional)
               (pprint-newline :linear stream))
              ((&rest &body)
               (setf state :required)
               (pprint-newline :linear stream))
              (&key
               (setf state :key)
               (pprint-newline :linear stream))
              (&aux
               (setf state :optional)
               (pprint-newline :linear stream))
              (t
               (pprint-newline :fill stream))))
          (ecase state
            (:required
             (pprint-lambda-list stream arg))
            ((:optional :key)
             (pprint-logical-block
                 (stream arg :prefix "(" :suffix ")")
               (pprint-exit-if-list-exhausted)
               (if (eq state :key)
                   (pprint-logical-block
                       (stream (pprint-pop) :prefix "(" :suffix ")")
                     (pprint-exit-if-list-exhausted)
                     (write-object (pprint-pop) stream)
                     (pprint-exit-if-list-exhausted)
                     (write-char #\space stream)
                     (pprint-newline :fill stream)
                     (pprint-lambda-list stream (pprint-pop))
                     (loop
                       (pprint-exit-if-list-exhausted)
                       (write-char #\space stream)
                       (pprint-newline :fill stream)
                       (write-object (pprint-pop) stream)))
                   (pprint-lambda-list stream (pprint-pop)))
               (loop
                 (pprint-exit-if-list-exhausted)
                 (write-char #\space stream)
                 (pprint-newline :linear stream)
                 (write-object (pprint-pop) stream))))))
        (setf first nil)))))

(defun pprint-lambda (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^~3I ~:_~/SI:PPRINT-LAMBDA-LIST/~1I~@{ ~_~W~}~:>")
           stream list))

(defun pprint-block (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter "~:<~^~W~^~3I ~:_~W~1I~@{ ~_~W~}~:>") stream list))

(defun pprint-flet (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^ ~@_~:<~@{~:<~^~W~^~3I ~:_~/SI:PPRINT-LAMBDA-LIST/~1I~:@_~@{~W~^ ~_~}~:>~^ ~_~}~:>~1I~@:_~@{~W~^ ~_~}~:>")
           stream
           list))

(defun pprint-let (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter "~:<~^~W~^ ~@_~:<~@{~:<~^~W~@{ ~_~W~}~:>~^ ~_~}~:>~1I~:@_~@{~W~^ ~_~}~:>")
           stream
           list))

(defun pprint-progn (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter "~:<~^~W~@{ ~_~W~}~:>") stream list))

(defun pprint-progv (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter "~:<~^~W~^~3I ~_~W~^ ~_~W~^~1I~@{ ~_~W~}~:>")
           stream list))

(defun pprint-quote (stream list &rest noise)
  (declare (ignore noise))
  (if (and (consp list)
           (consp (cdr list))
           (null (cddr list)))
      (case (car list)
        (function
         (write-string "#'" stream)
         (write-object (cadr list) stream))
        (quote
         (write-char #\' stream)
         (write-object (cadr list) stream))
        (t
         (pprint-fill stream list)))
      (pprint-fill stream list)))

(defun pprint-setq (stream list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream list :prefix "(" :suffix ")")
    (pprint-exit-if-list-exhausted)
    (write-object (pprint-pop) stream)
    (pprint-exit-if-list-exhausted)
    (write-char #\space stream)
    (pprint-newline :miser stream)
    (if (and (consp (cdr list)) (consp (cddr list)))
        (loop
          (pprint-indent :current 2 stream)
          (write-object (pprint-pop) stream)
          (pprint-exit-if-list-exhausted)
          (write-char #\space stream)
          (pprint-newline :linear stream)
          (pprint-indent :current -2 stream)
          (write-object (pprint-pop) stream)
          (pprint-exit-if-list-exhausted)
          (write-char #\space stream)
          (pprint-newline :linear stream))
        (progn
          (pprint-indent :current 0 stream)
          (write-object (pprint-pop) stream)
          (pprint-exit-if-list-exhausted)
          (write-char #\space stream)
          (pprint-newline :linear stream)
          (write-object (pprint-pop) stream)))))

#+ecl-min  
(defmacro pprint-tagbody-guts (stream)
  `(loop
     (pprint-exit-if-list-exhausted)
     (write-char #\space ,stream)
     (let ((form-or-tag (pprint-pop)))
       (pprint-indent :block 
                      (if (atom form-or-tag) 0 1)
                      ,stream)
       (pprint-newline :linear ,stream)
       (write-object form-or-tag ,stream))))

(defun pprint-tagbody (stream list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream list :prefix "(" :suffix ")")
    (pprint-exit-if-list-exhausted)
    (write-object (pprint-pop) stream)
    (pprint-tagbody-guts stream)))

(defun pprint-case (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^ ~3I~:_~W~1I~@{ ~_~:<~^~:/SI:PPRINT-FILL/~^~@{ ~_~W~}~:>~}~:>")
           stream
           list))

(defun pprint-defun (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^ ~@_~:I~W~^ ~:_~/SI:PPRINT-LAMBDA-LIST/~1I~@{ ~_~W~}~:>")
           stream
           list))

(defun pprint-destructuring-bind (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^~3I ~_~:/SI:PPRINT-LAMBDA-LIST/~^ ~_~W~^~1I~@{ ~_~W~}~:>")
           stream list))

(defun pprint-do (stream list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream list :prefix "(" :suffix ")")
    (pprint-exit-if-list-exhausted)
    (write-object (pprint-pop) stream)
    (pprint-exit-if-list-exhausted)
    (write-char #\space stream)
    (pprint-indent :current 0 stream)
    (funcall (formatter "~:<~@{~:<~^~W~^ ~@_~:I~W~@{ ~_~W~}~:>~^~:@_~}~:>")
             stream
             (pprint-pop))
    (pprint-exit-if-list-exhausted)
    (write-char #\space stream)
    (pprint-newline :linear stream)
    (pprint-linear stream (pprint-pop))
    (pprint-tagbody-guts stream)))

(defun pprint-dolist (stream list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream list :prefix "(" :suffix ")")
    (pprint-exit-if-list-exhausted)
    (write-object (pprint-pop) stream)
    (pprint-exit-if-list-exhausted)
    (pprint-indent :block 3 stream)
    (write-char #\space stream)
    (pprint-newline :fill stream)
    (funcall (formatter "~:<~^~W~^ ~:_~:I~W~@{ ~_~W~}~:>")
             stream
             (pprint-pop))
    (pprint-tagbody-guts stream)))

(defun pprint-typecase (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter
            "~:<~^~W~^ ~3I~:_~W~1I~@{ ~_~:<~^~W~^~@{ ~_~W~}~:>~}~:>")
           stream
           list))

(defun pprint-prog (stream list &rest noise)
  (declare (ignore noise))
  (pprint-logical-block (stream list :prefix "(" :suffix ")")
    (pprint-exit-if-list-exhausted)
    (write-object (pprint-pop) stream)
    (pprint-exit-if-list-exhausted)
    (write-char #\space stream)
    (pprint-newline :miser stream)
    (pprint-fill stream (pprint-pop))
    (pprint-tagbody-guts stream)))

(defun pprint-function-call (stream list &rest noise)
  (declare (ignore noise))
  (funcall (formatter "~:<~^~W~^ ~:_~:I~@{~W~^ ~_~}~:>")
           stream
           list))


;;;; Interface seen by regular (ugly) printer and initialization routines.

(eval-when (:compile-toplevel :execute)
(defconstant +magic-forms+
  '((lambda pprint-lambda)
    ;; Special forms.
    (block pprint-block)
    (catch pprint-block)
    (compiler-let pprint-let)
    (eval-when pprint-block)
    (flet pprint-flet)
    (function pprint-quote)
    (labels pprint-flet)
    (let pprint-let)
    (let* pprint-let)
    (locally pprint-progn)
    (macrolet pprint-flet)
    (multiple-value-call pprint-block)
    (multiple-value-prog1 pprint-block)
    (progn pprint-progn)
    (progv pprint-progv)
    (quote pprint-quote)
    (return-from pprint-block)
    (setq pprint-setq)
    (symbol-macrolet pprint-let)
    (tagbody pprint-tagbody)
    (throw pprint-block)
    (unwind-protect pprint-block)
    
    ;; Macros.
    (case pprint-case)
    (ccase pprint-case)
    (ctypecase pprint-typecase)
    (defconstant pprint-block)
    (define-modify-macro pprint-defun)
    (define-setf-expander pprint-defun)
    (defmacro pprint-defun)
    (defparameter pprint-block)
    (defsetf pprint-defun)
    (defstruct pprint-block)
    (deftype pprint-defun)
    (defun pprint-defun)
    (defvar pprint-block)
    (destructuring-bind pprint-destructuring-bind)
    (do pprint-do)
    (do* pprint-do)
    (do-all-symbols pprint-dolist)
    (do-external-symbols pprint-dolist)
    (do-symbols pprint-dolist)
    (dolist pprint-dolist)
    (dotimes pprint-dolist)
    (ecase pprint-case)
    (etypecase pprint-typecase)
    #+nil (handler-bind ...)
    #+nil (handler-case ...)
    #+nil (loop ...)
    (multiple-value-bind pprint-progv)
    (multiple-value-setq pprint-block)
    (pprint-logical-block pprint-block)
    (print-unreadable-object pprint-block)
    (prog pprint-prog)
    (prog* pprint-prog)
    (prog1 pprint-block)
    (prog2 pprint-progv)
    (psetf pprint-setq)
    (psetq pprint-setq)
    #+nil (restart-bind ...)
    #+nil (restart-case ...)
    (setf pprint-setq)
    (step pprint-progn)
    (time pprint-progn)
    (typecase pprint-typecase)
    (unless pprint-block)
    (when pprint-block)
    (with-compilation-unit pprint-block)
    #+nil (with-condition-restarts ...)
    (with-hash-table-iterator pprint-block)
    (with-input-from-string pprint-block)
    (with-open-file pprint-block)
    (with-open-stream pprint-block)
    (with-output-to-string pprint-block)
    (with-package-iterator pprint-block)
    (with-simple-restart pprint-block)
    (with-standard-io-syntax pprint-progn))))

(progn
  (let ((*print-pprint-dispatch* (make-pprint-dispatch-table)))
    ;; Printers for regular types.
    (set-pprint-dispatch 'array #'pprint-array)
    (set-pprint-dispatch '(cons (and symbol (satisfies fboundp)))
                         #'pprint-function-call -1)
    (set-pprint-dispatch 'cons #'pprint-fill -2)
    ;; Cons cells with interesting things for the car.
    (dolist (magic-form '#.+magic-forms+)
      (set-pprint-dispatch `(cons (eql ,(first magic-form)))
                           (symbol-function (second magic-form))))
    (setf *initial-pprint-dispatch* *print-pprint-dispatch*)
    )
  (setf *print-pprint-dispatch* (copy-pprint-dispatch nil)
        *standard-pprint-dispatch* *initial-pprint-dispatch*)
  (setf (pprint-dispatch-table-read-only-p *standard-pprint-dispatch*) t)
  (setf (first (cdr si::+io-syntax-progv-list+)) *standard-pprint-dispatch*)
  (setf (first (cdr si::+ecl-syntax-progv-list+)) *standard-pprint-dispatch*)
  #-ecl-min
  (setf *print-pretty* t))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/pprint.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/trace.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;        Tracer package for Common Lisp

(in-package "SYSTEM")

(defparameter *trace-level* 0)
;; (defparameter *trace-list* nil) ; In all_symbols.d !
(defparameter *trace-max-indent* 20)

(defmacro trace (&rest r)
"Syntax: (trace ({function-name | ({function-name}+)} {keyword [form]\}*)
Begins tracing the specified functions.  With no FUNCTION-NAMEs, returns a
list of functions currently being traced. The printed information consists of
the name of function followed at entry by its arguments and on exit by its
return values.
The keywords allow to control when and how tracing is performed.
The possible keywords are:

 :BREAK         a breakpoint is entered after printing the entry trace
                information, but before applying the traced function to its
                arguments, if form evaluates to non-nil
 :BREAK-AFTER   like :BREAK but the breakpoint is entered after the function
                has been executed and the exit trace information has been
                printed and before control returns
 :COND-BEFORE   information is printed upon entry if form evaluates to non-nil
 :COND-AFTER    information is printed upon exit if form evaluates to non-nil
 :COND          specifies a single condition for both entry and exit
 :PRINT         prints the values of the forms in the list upon entry.
                They are preceeded by a backslash (\\)
 :PRINT-AFTER   prints the values of the forms in the list upon exit from the
                function. They are preceeded by a backslash (\\)
 :STEP          turns on the stepping facility

Forms can refer to the list of arguments of the function through the variable
SI::ARGS."
  `(trace* ',r))

(defun trace* (r)
  (if (null r)
      (mapcar #'first *trace-list*)
      (mapc #'trace-one r)))

(defmacro untrace (&rest r)
  "Syntax: (untrace {function-name}*)

Ends tracing the specified functions.  With no FUNCTION-NAMEs, ends tracing
all functions."
  `(untrace* ',r))

(defun untrace* (r)
  (mapc #'untrace-one (or r (trace* nil))))

(defparameter *inside-trace* nil)

(defun trace-one (spec)
  (let* (break exitbreak (entrycond t) (exitcond t) entry exit
               step (barfp t) fname oldf)
    (cond ((si::valid-function-name-p spec)
           (setq fname spec))
          ((not (si::proper-list-p spec))
           (error "Not a valid argument to TRACE: ~S" spec))
          ((si::valid-function-name-p (first spec))
           (setq fname (first spec))
           (do ((specs (cdr spec) (cdr specs)))
               ((null specs))
             (case (car specs)
               (:break (setq barfp specs specs (cdr specs) break (car specs)))
               (:break-after (setq barfp specs specs (cdr specs) exitbreak (car specs)))
               (:step (setq step t))
               (:cond (setq barfp specs specs (cdr specs))
                      (setq exitcond (setq entrycond (car specs))))
               (:cond-before (setq barfp specs specs (cdr specs) entrycond (car specs)))
               (:cond-after (setq barfp specs specs (cdr specs) exitcond (car specs)))
               (:print (setq barfp specs specs (cdr specs) entry (car specs)))
               (:print-after (setq barfp specs specs (cdr specs) exit (car specs)))
               (t (error "Meaningless TRACE keyword: ~S" (car specs))))
             (unless barfp (error "Parameter missing"))))
          ((si::proper-list-p (first spec))
           (let (results)
             (dolist (fname (first spec))
               (push (trace-one (list* fname (rest spec))) results))
             (return-from trace-one (nreverse results))))
          (t
           (error "Not a valid argument to TRACE: ~S" spec)))
    (when (null (fboundp fname))
      (warn "The function ~S is not defined." fname)
      (return-from trace-one nil))
    (when (symbolp fname)
      (when (special-operator-p fname)
        (warn "Unable to trace special form ~S." fname)
        (return-from trace-one nil))
      (when (macro-function fname)
        (warn "Unable to trace macro ~S." fname)
        (return-from trace-one nil)))
    (let ((record (trace-record fname)))
      (when record
        (cond ((traced-and-redefined-p record)
               (delete-from-trace-list fname))
              (t
               (warn "The function ~S is already traced. Statement has no effect." fname)
               (return-from trace-one nil)))))
    (setq oldf (fdefinition fname))
    (eval
     `(defun ,fname (&rest args)
          (let* (values (*trace-level* (1+ *trace-level*)))
            (if *inside-trace*
                (setq values (multiple-value-list (apply ',oldf args)))
                (let ((*inside-trace* t))
                  ,@(when entrycond
                       (if (eq t entrycond)
                         `((trace-print 'ENTER ',fname args ,@entry))
                         `((when ,entrycond
                             (trace-print 'ENTER ',fname args ,@entry)))))
                  ,@(when break
                      `((when ,break (let (*inside-trace*)
                                       (break "tracing ~S" ',fname)))))
                  (setq values
                        (let (*inside-trace*)
                          (multiple-value-list
                              (apply ',oldf args)
                              #+nil
                              ,(if step
                                   `(let (*step-quit*)
                                     (applyhook ',oldf args #'stepper nil))
                                   `(apply ',oldf args)))))
                  ,@(when exitcond
                      (if (eq t exitcond)
                          `((trace-print 'EXIT ',fname values ,@exit))
                          `((when ,exitcond
                              (trace-print 'EXIT ',fname values ,@exit)))))
                  ,@(when exitbreak
                      `((when ,exitbreak
                          (let (*inside-trace*)
                            (break "after tracing ~S" ',fname)))))))
            (values-list values))))
  (add-to-trace-list fname oldf)
  (list fname)))

(defun trace-print (direction fname vals &rest extras)
  (let ((indent (min (* (1- *trace-level*) 2) *trace-max-indent*))
        (*print-circle* t))
    (princ
      (with-output-to-string (*trace-output*)
        (fresh-line *trace-output*)
        (case direction
          (ENTER
            (multiple-value-bind (bars rem)
              (floor indent 4)
              (dotimes (i bars) (princ (if (< i 10) "|   " "|    ") *trace-output*))
              (when (plusp rem) (format *trace-output* "~V,,,' A" rem "|")))
            (format *trace-output*
                    "~D> (~S~{ ~S~})~%"
                    *trace-level* fname vals))
          (EXIT
            (multiple-value-bind (bars rem)
              (floor indent 4)
              (dotimes (i bars) (princ "|   " *trace-output*))
              (when (plusp rem) (format *trace-output* "~V,,,' A" rem "|")))
            (format *trace-output*
                    "<~D (~S~{ ~S~})~%"
                    *trace-level*
                    fname vals)
            ))
        (when extras
          (multiple-value-bind (bars rem)
            (floor indent 4)
            (dotimes (i bars) (princ "|   " *trace-output*))
            (when (plusp rem) (format *trace-output* "~V,,,' A" rem "|")))
          (format *trace-output*
                  "~0,4@T\\\\ ~{ ~S~}~%"
                  extras))
        *trace-output*)
      *trace-output*)))

(defun trace-record (fname)
  (declare (si::c-local))
  (find fname *trace-list* :key #'first :test #'equal))

(defun trace-record-name (record)
  (declare (si::c-local))
  (first record))

(defun trace-record-definition (record)
  (declare (si::c-local))
  (second record))

(defun trace-record-old-definition (record)
  (declare (si::c-local))
  (third record))

(defun traced-old-definition (fname)
  (let ((record (trace-record fname)))
    (when record
      (unless (traced-and-redefined-p record)
        (trace-record-old-definition record)))))

(defun delete-from-trace-list (fname)
  (setq *trace-list* (delete fname *trace-list* :key #'first :test #'equal)))

(defun add-to-trace-list (fname old-definition)
  (push (list fname (fdefinition fname) old-definition)
        *trace-list*))

(defun traced-and-redefined-p (record)
  (declare (si::c-local))
  (and record (not (eq (trace-record-definition record)
                       (fdefinition (trace-record-name record))))))

(defun untrace-one (fname)
  (let ((record (trace-record fname)))
    (cond ((null record)
           (warn "The function ~S was not traced." fname))
          ((traced-and-redefined-p record)
           (warn "The function ~S was traced, but redefined." fname))
          (t
           (sys:fset fname (trace-record-old-definition record))))
    (delete-from-trace-list fname)
    (values)))

(defparameter *step-level* 0)
(defparameter *step-action* nil)
(defparameter *step-form* nil)
(defparameter *step-tag* (cons nil nil))
(defparameter *step-functions* nil)
(defconstant step-commands
  `("Stepper commands"
     ((:newline) (step-next) :constant
      "newline         Advance to the next form"
      "newline                                         [Stepper command]~@
       ~@
       Step to next form.~%")
     ((:s :skip) step-skip nil
      ":s(kip)         Skip current form or until function"
      ":skip &optional arg                             [Stepper command]~@
       :s &optional arg                                [Abbreviation]~@
       ~@
       Continue evaluation without stepping.  Without argument, resume~@
       stepping after the current form.  With numeric argument (n),~@
       resume stepping at the n-th level above.  With function name, resume~@
       when given function is called.~%")
     ((:pr :print) (step-print) :constant
      ":pr(int)        Pretty print current form"
      ":print                                          [Stepper command]~@
       :pr                                             [Abbreviation]~@
       ~@
       Pretty print current form.~%")
     ((:form) *step-form* :constant
      ":form           Current form"
      ":form                                           [Stepper command]~@
       ~@
       Return the current form.  Nothing is done, but the current form~@
       is returned as the value of this command.  As a consequence,~@
       it is printed by the top level in the usual way and saved in~@
       the variable *.  The main purpose of this command is to allow~@
       the current form to be examined further by accessing *.~%")
     ((:x :exit) (step-quit) :constant
      ":x or :exit     Finish evaluation and exit stepper"
      ":exit                                           [Stepper command]~@
       :x                                              [Abbreviation]~@
       ~@
       Finish evaluation without stepping.~%")
     ))

(defmacro step (form)
"Syntax: (step form)
Evaluates FORM in the Stepper mode and returns all its values.  See ECL Report
for Stepper mode commands."
  `(step* ',form))

(defun step* (form)
  (let* ((*step-action* t)
         (*step-level* 0)
         (*step-functions* (make-hash-table :size 128 :test 'eq)))
    (catch *step-tag*
      (si:eval-with-env form nil t))))

(defun steppable-function (form)
  (let ((*step-action* nil))
    (or (gethash form *step-functions*)
        (multiple-value-bind (f env name)
            (function-lambda-expression form)
          (if (and (not (trace-record name)) f)
              (setf (gethash form *step-functions*)
                    (eval-with-env `(function ,f) env t))
              form)))))

(defun stepper (form)
  (when (typep form '(or symbol function))
    (return-from stepper (steppable-function (coerce form 'function))))
  (let* ((*step-form* form)
         (*step-action* nil)
         (indent (min (* *tpl-level* 2) 20))
         prompt)
    (setq prompt
          #'(lambda ()
              (format *debug-io* "~VT" indent)
              (write form :stream *debug-io* :pretty nil
                     :level 2 :length 2)
              (princ #\space *debug-io*)
              (princ #\- *debug-io*)))
    (when (catch *step-tag*
            (tpl :quiet t
                 :commands (adjoin step-commands
                                   (adjoin break-commands *tpl-commands*))
                 :broken-at 'stepper
                 :prompt-hook prompt))
      (throw *step-tag* t))))

(defun step-next ()
  (throw *step-tag* nil))

(defun step-skip (&optional (when 0))
  (declare (ignore when))
  (setf *step-action* 0)
  (throw *step-tag* nil))

(defun step-print ()
  (write *step-form* :stream *debug-io* :pretty t :level nil :length nil)
  (terpri)
  (values))

(defun step-quit ()
  (throw *step-tag* t))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/trace.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/predlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                              predicate routines

(in-package "SYSTEM")

(defun constantly-t (&rest foo)
  (declare (ignore foo))
  t)

(defun constantly-nil (&rest foo)
  (declare (ignore foo))
  nil)

(defun constantly (n)
  "Args: (n)
Builds a new function which accepts any number of arguments but always outputs N."
  (case n
    ((nil) #'constantly-nil)
    ((t) #'constantly-t)
    (t #'(lambda (&rest x) (declare (ignore x)) n))))

(defparameter *subtypep-cache* (si:make-vector t 256 nil nil nil 0))

(defparameter *upgraded-array-element-type-cache* (si:make-vector t 128 nil nil nil 0))

(defun subtypep-clear-cache ()
  (ext:fill-array-with-elt *subtypep-cache* nil 0 nil)
  (ext:fill-array-with-elt *upgraded-array-element-type-cache* nil 0 nil))

(defun create-type-name (name)
  (when (member name *alien-declarations*)
    (error "Symbol ~s is a declaration specifier and cannot be used to name a new type" name)))

(defun do-deftype (name form function)
  (unless (symbolp name)
    (error-type-specifier name))
  (create-type-name name)
  (put-sysprop name 'DEFTYPE-FORM form)
  (put-sysprop name 'DEFTYPE-DEFINITION
               (if (functionp function) function (constantly function)))
  (subtypep-clear-cache)
  name)

;;; DEFTYPE macro.
(defmacro deftype (name lambda-list &rest body &environment env)
  "Syntax: (deftype name macro-lambda-list {decl | doc}* {form}*)
Defines a new type-specifier abbreviation in terms of an 'expansion'
function

        (lambda (whole) {DECL}* {FORM}*)

where WHOLE is identical to MACRO-LAMBDA-LIST except that all optional
parameters with no default value specified in LAMBDA-LIST defaults to
the symbol '*', but not to NIL. When the type system of ECL encounters
a type specifier (NAME arg1 ... argn), it calls the expansion function
with the argument (ARG1 ... ARGn), and uses the returned value instead
of the original type specifier.  When the symbol NAME is used as a
type specifier, the expansion function is called with no argument.
The doc-string DOC, if supplied, is saved as a TYPE doc and can be
retrieved by (documentation 'NAME 'type)."
  (labels ((set-default (list*)
             "Sets default value for optional arguments to *. Doesn't
              modify arguments which happen to be in lambda-list
              keywords."
             (if (consp list*)
                 (let ((variable (car list*)))
                   (cons
                    (if (and (symbolp variable)
                             (not (member variable lambda-list-keywords)))
                        `(,variable '*)
                        variable)
                    (set-default (cdr list*))))
                 list*))
           (verify-tree (elt)
             "Vefrifies if ELT is the list containing optional arg."
             (and (consp elt)
                  (member (car elt)
                          '(&key &optional))))
           (maptree (function tree test)
             "Applies FUNCTION to branches for which TEST resolves to
              true. MAPTREE doesn't traverse this branch further. It
              is correct in this context, because we can't create
              nested lambda-list after both &key and &optional, since
              it would be considered as default value or an error."
             (cond ((funcall test tree)
                    (funcall function tree))
                   ((consp tree)
                    (cons
                     (maptree function (car tree) test)
                     (maptree function (cdr tree) test)))
                   (T tree))))
    (setf lambda-list
          (maptree #'set-default lambda-list #'verify-tree)))
  (multiple-value-bind (decls body documentation)
      (si::find-declarations body)
    (multiple-value-bind (ppn whole dl arg-check ignorables)
        (destructure lambda-list 'deftype)
      (declare (ignore ppn))
      (let ((function `#'(ext::lambda-block ,name (,whole &aux ,@dl)
                                            (declare (ignorable ,@ignorables))
                                            ,@decls ,@arg-check
                                            ,@body)))
        (when (and (null lambda-list)
                   (consp body)
                   (null (rest body)))
          (let ((form (first body)))
            (when (constantp form env)
              (setf function (ext:maybe-quote (ext:constant-form-value form env))))))
        `(eval-when (:compile-toplevel :load-toplevel :execute)
           ,@(si::expand-set-documentation name 'type documentation)
           (do-deftype ',name '(DEFTYPE ,name ,lambda-list ,@body)
                       ,function))))))

;;; Some DEFTYPE definitions.
(deftype boolean ()
  "A BOOLEAN is an object which is either NIL or T."
  '(member nil t))

(deftype index ()
  '(INTEGER 0 #.array-dimension-limit))

(deftype fixnum ()
  "A FIXNUM is an integer between MOST-NEGATIVE-FIXNUM (= - 2^29 in ECL) and
MOST-POSITIVE-FIXNUM (= 2^29 - 1 in ECL) inclusive.  Other integers are
bignums."
  '(INTEGER #.most-negative-fixnum #.most-positive-fixnum))
(deftype bignum ()
  '(OR (INTEGER * (#.most-negative-fixnum)) (INTEGER (#.most-positive-fixnum) *)))

(deftype ext::byte8 () '(INTEGER 0 255))
(deftype ext::integer8 () '(INTEGER -128 127))
(deftype ext::byte16 () '(INTEGER 0 #xFFFF))
(deftype ext::integer16 () '(INTEGER #x-8000 #x7FFF))
(deftype ext::byte32 () '(INTEGER 0 #xFFFFFFFF))
(deftype ext::integer32 () '(INTEGER #x-80000000 #x7FFFFFFF))
(deftype ext::byte64 () '(INTEGER 0 #xFFFFFFFFFFFFFFFF))
(deftype ext::integer64 () '(INTEGER #x-8000000000000000 #x7FFFFFFFFFFFFFFF))
(deftype ext::cl-fixnum () '(SIGNED-BYTE #.CL-FIXNUM-BITS))
(deftype ext::cl-index () '(UNSIGNED-BYTE #.CL-FIXNUM-BITS))

(deftype real (&optional (start '* start-p) (end '*))
  (if start-p
      (let (rat-start
            real-start
            rat-end
            real-end)
        (cond ((consp start)
               (setf start (first start)
                     rat-start (list (rational start))
                     real-start (list (float start))))
              ((numberp start)
               (setf rat-start (rational start)
                     real-start (float start)))
              (t
               (setf rat-start start
                     real-start start)))
        (cond ((consp end)
               (setf end (first end)
                     rat-end (list (rational end))
                     real-end (list (float end))))
              ((numberp end)
               (setf rat-end (rational end)
                     real-end (float end)))
              (t
               (setf rat-end end
                     real-end end)))
        `(OR (RATIONAL ,rat-start ,rat-end) (FLOAT ,real-start ,real-end)))
      '(OR RATIONAL FLOAT)))

#-short-float
(deftype short-float (&rest args)
  (if args
      `(single-float ,@args)
      'single-float))

#-long-float
(deftype long-float (&rest args)
  (if args
      `(double-float ,@args)
      'double-float))

(deftype bit ()
  "A BIT is either integer 0 or 1."
  '(INTEGER 0 1))

(deftype mod (n)
  `(INTEGER 0 ,(1- n)))

(deftype signed-byte (&optional s)
  "As a type specifier, (SIGNED-BYTE n) specifies those integers that can be
represented with N bits in 2's complement representation."
  (if (or (null s) (eq s '*))
      '(INTEGER * *)
      `(INTEGER ,(- (expt 2 (1- s))) ,(1- (expt 2 (1- s))))))

(deftype unsigned-byte (&optional s)
  "As a type specifier, (UNSIGNED-BYTE n) specifies non-negative integers that
can be represented with N bits."
  (if (or (null s) (eq s '*))
      '(INTEGER 0 *)
      `(INTEGER 0 ,(1- (expt 2 s)))))

(deftype null ()
  "The type to which only NIL belongs."
  '(MEMBER NIL))

(deftype sequence ()
  "A sequence is either a list or a vector."
  '(OR CONS NULL (ARRAY * (*))))

(deftype list ()
  "As a type specifier, LIST is used to specify the type consisting of NIL and
cons objects.  In our ordinary life with Lisp, however, a list is either NIL
or a cons whose cdr is a list, and is notated by its elements surrounded with
parentheses.
The backquote macro is sometimes useful to construct a complicated list
structure.  When evaluating `(...)
        ,form embeds the value of FORM,
        ,@form and ,.form embed all elements of the list value of FORM,
        and other things embed itself
into the structure at their position.  For example,
        `(a b ,c d e) expands to (list* 'a 'b c '(d e))
        `(a b ,@c d e) expands to (list* 'a 'b (append c '(d e)))
        `(a b ,.c d e) expands to (list* 'a 'b (nconc c '(d e)))"
  '(OR CONS NULL))

(deftype proper-list ()
  '(OR (CONS T PROPER-LIST) NULL))

(deftype property-list ()
  '(OR (CONS T (CONS T PROPERTY-LIST)) NULL))

(deftype atom ()
  "An ATOM is an object that is not a CONS."
  '(NOT CONS))
;(deftype null () '(MEMBER NIL))

(deftype vector (&optional (element-type '*) (size '*))
  "A vector is a one-dimensional array.  Strings and bit-vectors are kinds of
vectors.  Other vectors are called general vectors and are notated as
        #(elem ... elem)
Some vectors may be displaced to another array, may have a fill-pointer, or
may be adjustable.  Other vectors are called simple-vectors."
  `(array ,element-type (,size)))

(deftype extended-char ()
  "A character which is not of type BASE-CHAR."
  '(and character (not base-char)))

(deftype string (&optional size)
  "A string is a vector of characters.  A string is notated by surrounding the
characters with double quotes.  Some strings may be displaced to another
string, may have a fill-pointer, or may be adjustable.  Other strings are
called simple-strings."
  #-unicode
  (if (eq size '*)
      '(array character (*))
      `(array character (,size)))
  #+unicode
  (if (eq size '*)
      '(or (array base-char (*)) (array character (*)))
      `(or (array base-char (,size))
           (array character (,size)))))

(deftype base-string (&optional (size '*))
  "A string which is made of BASE-CHAR."
  (if (eq size '*) '(array base-char (*)) `(array base-char (,size))))

(deftype extended-string (&optional (size '*))
  "A string which is nt a base string"
  #-unicode
  NIL
  #+unicode
  (if (eq size '*) '(array character (*)) `(array character (,size))))

(deftype bit-vector (&optional (size '*))
  "A bit-vector is a vector of bits.  A bit-vector is notated by '#*' followed
by its elements (0 or 1).  Bit-vectors may be displaced to another array, may
have a fill-pointer, or may be adjustable.  Other bit-vectors are called
simple-bit-vectors.  Only simple-bit-vectors can be input in the above format
using '#*'."
  (if (eq size '*) '(array bit (*)) `(array bit (,size))))

(deftype simple-vector (&optional (size '*))
  "A simple-vector is a vector that is not displaced to another array, has no
fill-pointer, and is not adjustable."
  (if (eq size '*) '(simple-array t (*)) `(simple-array t (,size))))

(deftype simple-string (&optional size)
  "A simple-string is a string that is not displaced to another array, has no
fill-pointer, and is not adjustable."
  #-unicode
  (if size
    `(simple-array character (,size))
    '(simple-array character (*)))
  #+unicode
  (if size
      `(or (simple-array base-char (,size))
           (simple-array character (,size)))
      '(or (simple-array base-char (*)) (simple-array character (*)))))

(deftype simple-base-string (&optional size)
  "A base-string which cannot be adjusted nor displaced."
  (if size `(simple-array base-char (,size)) '(simple-array base-char (*))))

(deftype simple-bit-vector (&optional size)
  "A bit-vector that is not displaced to another array, has no fill-pointer,
and is not adjustable."
  (if size `(simple-array bit (,size)) '(simple-array bit (*))))

(deftype array-index ()
  '(integer 0 #.(1- array-dimension-limit)))

(deftype ext:virtual-stream ()
  '(or string-stream
    #+clos-streams gray:fundamental-stream))

;;************************************************************
;;                      TYPEP
;;************************************************************

(defun simple-array-p (x)
  (and (arrayp x)
       (not (adjustable-array-p x))
       (not (array-has-fill-pointer-p x))
       (not (array-displacement x))))

(defun complex-array-p (x)
  (and (arrayp x)
       (or (adjustable-array-p x)
           (array-has-fill-pointer-p x)
           (array-displacement x))))

(defun ratiop (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_ratio" :one-liner t)
  #+ecl-min
  (and (rationalp x) (not (integerp x))))

#+short-float
(defun short-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_shortfloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'short-float))

#-short-float
(defun short-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_singlefloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'single-float))

(defun single-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_singlefloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'single-float))

(defun double-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_doublefloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'double-float))

#+long-float
(defun long-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_longfloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'long-float))

#-long-float
(defun long-float-p (x)
  #-ecl-min
  (ffi::c-inline (x) (t) :bool "type_of(#0) == t_doublefloat" :one-liner t)
  #+ecl-min
  (eq (type-of x) 'double-float))

(eval-when (:execute :load-toplevel :compile-toplevel)
  (defconstant +known-typep-predicates+
    '((ARRAY . ARRAYP)
      (ATOM . ATOM)
      #-unicode
      (EXTENDED-CHAR . CONSTANTLY-NIL)
      (BASE-CHAR . BASE-CHAR-P)
      (BASE-STRING . BASE-STRING-P)
      (BIT-VECTOR . BIT-VECTOR-P)
      (CHARACTER . CHARACTERP)
      (COMPILED-FUNCTION . COMPILED-FUNCTION-P)
      (COMPLEX . COMPLEXP)
      (COMPLEX-ARRAY . COMPLEX-ARRAY-P)
      (CONS . CONSP)
      (DOUBLE-FLOAT . SI:DOUBLE-FLOAT-P)
      (FLOAT . FLOATP)
      (SI:FOREIGN-DATA . SI:FOREIGN-DATA-P)
      (FUNCTION . FUNCTIONP)
      (HASH-TABLE . HASH-TABLE-P)
      (INTEGER . INTEGERP)
      (FIXNUM . SI::FIXNUMP)
      (KEYWORD . KEYWORDP)
      (LIST . LISTP)
      (LOGICAL-PATHNAME . LOGICAL-PATHNAME-P)
      (LONG-FLOAT . SI:LONG-FLOAT-P)
      (NIL . CONSTANTLY-NIL)
      (NULL . NULL)
      (NUMBER . NUMBERP)
      (PACKAGE . PACKAGEP)
      (RATIO . SI:RATIOP)
      (RANDOM-STATE . RANDOM-STATE-P)
      (RATIONAL . RATIONALP)
      (PATHNAME . PATHNAMEP)
      (READTABLE . READTABLEP)
      (REAL . REALP)
      (SHORT-FLOAT . SI:SHORT-FLOAT-P)
      (SIMPLE-ARRAY . SIMPLE-ARRAY-P)
      (SIMPLE-STRING . SIMPLE-STRING-P)
      (SIMPLE-VECTOR . SIMPLE-VECTOR-P)
      (SINGLE-FLOAT . SI:SINGLE-FLOAT-P)
      (STREAM . STREAMP)
      (STRING . STRINGP)
      (STRUCTURE . SYS:STRUCTUREP)
      (SYMBOL . SYMBOLP)
      #+sse2 (EXT:SSE-PACK . EXT:SSE-PACK-P)
      #+sse2 (EXT:INT-SSE-PACK . EXT:SSE-PACK-P)
      #+sse2 (EXT:FLOAT-SSE-PACK . EXT:SSE-PACK-P)
      #+sse2 (EXT:DOUBLE-SSE-PACK . EXT:SSE-PACK-P)
      (T . CONSTANTLY-T)
      (VECTOR . VECTORP))))

(dolist (l +known-typep-predicates+)
  (put-sysprop (car l) 'TYPE-PREDICATE (cdr l)))

(defconstant +upgraded-array-element-types+
  '#.(append '(NIL BASE-CHAR #+unicode CHARACTER BIT EXT:BYTE8 EXT:INTEGER8)
             #+:uint16-t '(EXT:BYTE16 EXT:INTEGER16)
             #+:uint32-t '(EXT:BYTE32 EXT:INTEGER32)
             (when (< 32 cl-fixnum-bits 64) '(EXT::CL-INDEX FIXNUM))
             #+:uint64-t '(EXT:BYTE64 EXT:INTEGER64)
             (when (< 64 cl-fixnum-bits) '(EXT::CL-INDEX FIXNUM))
             '(SINGLE-FLOAT DOUBLE-FLOAT T)))

(defun upgraded-array-element-type (element-type &optional env)
  (declare (ignore env))
  (let* ((hash (logand 127 (si:hash-eql element-type)))
         (record (aref *upgraded-array-element-type-cache* hash)))
    (declare (type (integer 0 127) hash))
    (if (and record (eq (car record) element-type))
        (cdr record)
        (let ((answer (if (member element-type +upgraded-array-element-types+
                                  :test #'eq)
                          element-type
                          (dolist (v +upgraded-array-element-types+ 'T)
                            (when (subtypep element-type v)
                              (return v))))))
          (setf (aref *upgraded-array-element-type-cache* hash)
                (cons element-type answer))
          answer))))

(defun upgraded-complex-part-type (real-type &optional env)
  (declare (ignore env))
  ;; ECL does not have specialized complex types. If we had them, the
  ;; code would look as follows
  ;;   (dolist (v '(INTEGER RATIO RATIONAL SINGLE-FLOAT DOUBLE-FLOAT FLOAT REAL)
  ;;       (error "~S is not a valid part type for a complex." real-type))
  ;;     (when (subtypep real-type v)
  ;;       (return v))))
  (unless (subtypep real-type 'REAL)
    (error "~S is not a valid part type for a complex." real-type))
  'REAL)

(defun in-interval-p (x interval)
  (declare (si::c-local))
  (let* (low high)
    (if (endp interval)
        (setq low '* high '*)
        (if (endp (cdr interval))
            (setq low (car interval) high '*)
            (setq low (car interval) high (second interval))))
    (cond ((eq low '*))
          ((consp low)
           (when (<= x (car low)) (return-from in-interval-p nil)))
          ((when (< x low) (return-from in-interval-p nil))))
    (cond ((eq high '*))
          ((consp high)
           (when (>= x (car high)) (return-from in-interval-p nil)))
          ((when (> x high) (return-from in-interval-p nil))))
    (return-from in-interval-p t)))

(defun error-type-specifier (type)
  (declare (si::c-local))
  (error "~S is not a valid type specifier." type))

(defun match-dimensions (array pat)
  (declare (si::c-local))
  (or (eq pat '*)
      (let ((rank (array-rank array)))
        (cond ((numberp pat) (= rank pat))
              ((listp pat)
               (dotimes (i rank (null pat))
                 (unless (and (consp pat)
                              (or (eq (car pat) '*)
                                  (eql (array-dimension array i) (car pat))))
                   (return nil))
                 (setq pat (cdr pat))))
              ((atom pat)
               (error "~S does not describe array dimensions." pat))))))

(defun typep (object type &optional env &aux tp i c)
  "Args: (object type)
Returns T if X belongs to TYPE; NIL otherwise."
  (declare (ignore env))
  (cond ((symbolp type)
         (let ((f (get-sysprop type 'TYPE-PREDICATE)))
           (if f
               (return-from typep (funcall f object))
               (setq tp type i nil))))
        ((consp type)
         (setq tp (car type) i (cdr type)))
        ((sys:instancep type)
         (return-from typep (si::subclassp (class-of object) type)))
        (t
         (error-type-specifier type)))
  (case tp
    ((EQL MEMBER) (and (member object i) t))
    (NOT (not (typep object (car i))))
    (OR (dolist (e i)
          (when (typep object e) (return t))))
    (AND (dolist (e i t)
           (unless (typep object e) (return nil))))
    (SATISFIES (funcall (car i) object))
    ((T *) t)
    ((NIL) nil)
    (BIGNUM (and (integerp object) (not (si::fixnump object))))
    (STANDARD-CHAR
     (and (characterp object) (standard-char-p object)))
    (INTEGER
     (and (integerp object) (in-interval-p object i)))
    (RATIO
     (and (ratiop object) (in-interval-p object i)))
    (RATIONAL
     (and (rationalp object) (in-interval-p object i)))
    (FLOAT
     (and (floatp object) (in-interval-p object i)))
    (REAL
     (and (or (rationalp object) (floatp object)) (in-interval-p object i)))
    (SHORT-FLOAT
     (and (si:short-float-p object) (in-interval-p object i)))
    (SINGLE-FLOAT
     (and (si:single-float-p object) (in-interval-p object i)))
    (DOUBLE-FLOAT
     (and (si:double-float-p object) (in-interval-p object i)))
    (LONG-FLOAT
     (and (si:long-float-p object) (in-interval-p object i)))
    (COMPLEX
     (and (complexp object)
          (or (null i)
              (and (typep (realpart object) (car i))
                   ;;wfs--should only have to check one.
                   ;;Illegal to mix real and imaginary types!
                   (typep (imagpart object) (car i))))
           ))
    (SEQUENCE (or (listp object) (vectorp object)))
    (CONS (and (consp object)
               (or (endp i)
                   (let ((car-type (first i)))
                     (or (eq car-type '*) (typep (car object) car-type))))
               (or (endp (cdr i))
                   (let ((cdr-type (second i)))
                     (or (eq cdr-type '*) (typep (cdr object) cdr-type))))))
    (BASE-STRING
     (and (base-string-p object)
          (or (null i) (match-dimensions object i))))
    (STRING
     (and (stringp object)
          (or (null i) (match-dimensions object i))))
    (BIT-VECTOR
     (and (bit-vector-p object)
          (or (null i) (match-dimensions object i))))
    (SIMPLE-BASE-STRING
     (and (base-string-p object)
          (simple-string-p object)
          (or (null i) (match-dimensions object i))))
    (SIMPLE-STRING
     (and (simple-string-p object)
          (or (null i) (match-dimensions object i))))
    (SIMPLE-BIT-VECTOR
     (and (simple-bit-vector-p object)
          (or (null i) (match-dimensions object i))))
    (SIMPLE-VECTOR
     (and (simple-vector-p object)
          (or (null i) (match-dimensions object i))))
    (COMPLEX-ARRAY
     (and (complex-array-p object)
          (or (endp i) (eq (car i) '*)
              ;; (car i) needs expansion
              (eq (array-element-type object)
                  (upgraded-array-element-type (car i))))
          (or (endp (cdr i)) (match-dimensions object (second i)))))
    (SIMPLE-ARRAY
     (and (simple-array-p object)
          (or (endp i) (eq (car i) '*)
              ;; (car i) needs expansion
              (eq (array-element-type object)
                  (upgraded-array-element-type (car i))))
          (or (endp (cdr i)) (match-dimensions object (second i)))))
    (ARRAY
     (and (arrayp object)
          (or (endp i) (eq (car i) '*)
              ;; Or the element type of object should be EQUAL to (car i).
              ;; Is this too strict?
              (eq (array-element-type object)
                  (upgraded-array-element-type (car i))))
          (or (endp (cdr i)) (match-dimensions object (second i)))))
    (t
     (cond ((get-sysprop tp 'DEFTYPE-DEFINITION)
            (typep object (funcall (get-sysprop tp 'DEFTYPE-DEFINITION) i)))
           ((consp i)
            (error-type-specifier type))
           ((setq c (find-class type nil))
            ;; Follow the inheritance chain
            (si::subclassp (class-of object) c))
           (t
            (error-type-specifier type))))))

(defun subclassp (low high)
  (or (eq low high)
      (member high (sys:instance-ref low clos::+class-precedence-list-ndx+)
              :test #'eq))) ; (class-precedence-list low)

(defun of-class-p (object class)
  (declare (optimize (speed 3) (safety 0)))
  (macrolet ((class-precedence-list (x)
               `(si::instance-ref ,x clos::+class-precedence-list-ndx+))
             (class-name (x)
               `(si::instance-ref ,x clos::+class-name-ndx+)))
    (let* ((x-class (class-of object)))
      (declare (class x-class))
      (if (eq x-class class)
          t
          (let ((x-cpl (class-precedence-list x-class)))
            (if (instancep class)
                (member class x-cpl :test #'eq)
                (dolist (c x-cpl)
                  (declare (class c))
                  (when (eq (class-name c) class)
                    (return t)))))))))

#+(and clos ecl-min)
(defun clos::classp (foo)
  (declare (ignore foo))
  nil)

;;************************************************************
;;                      NORMALIZE-TYPE
;;************************************************************
;; NORMALIZE-TYPE normalizes the type using the DEFTYPE definitions.
;; The result is a pair of values
;;  VALUE-1 = normalized type name or object
;;  VALUE-2 = normalized type arguments or nil
(defun normalize-type (type &aux tp i fd)
  ;; Loops until the car of type has no DEFTYPE definition.
  (cond ((symbolp type)
         (if (setq fd (get-sysprop type 'DEFTYPE-DEFINITION))
           (normalize-type (funcall fd nil))
           (values type nil)))
        ((clos::classp type) (values type nil))
        ((atom type)
         (error-type-specifier type))
        ((progn
           (setq tp (car type) i (cdr type))
           (setq fd (get-sysprop tp 'DEFTYPE-DEFINITION)))
         (normalize-type (funcall fd i)))
        ((and (eq tp 'INTEGER) (consp (cadr i)))
         (values tp (list (car i) (1- (caadr i)))))
        (t (values tp i))))

(defun expand-deftype (type)
  (let (base args)
    (if (atom type)
        (setf base type
              args nil)
        (setf base (car type)
              args (cdr type)))
    (let ((fn (get-sysprop base 'DEFTYPE-DEFINITION)))
      (if fn
          (expand-deftype (funcall fn args))
          type))))

;;************************************************************
;;                      COERCE
;;************************************************************

(defun coerce (object type &aux aux)
  "Args: (x type)
Coerces X to an object of the specified type, if possible.  Signals an error
if not possible."
  (when (typep object type)
    ;; Just return as it is.
    (return-from coerce object))
  (flet ((fail ()
           (error "Cannot coerce ~S to type ~S." object type)))
    (let ((type (expand-deftype type)))
      (cond ((atom type)
             (case type
               ((T) object)
               (LIST
                (do ((io (make-seq-iterator object) (seq-iterator-next object io))
                     (l nil (cons (seq-iterator-ref object io) l)))
                    ((null io) l)))
               ((CHARACTER BASE-CHAR) (character object))
               (FLOAT (float object))
               (SHORT-FLOAT (float object 0.0S0))
               (SINGLE-FLOAT (float object 0.0F0))
               (DOUBLE-FLOAT (float object 0.0D0))
               (LONG-FLOAT (float object 0.0L0))
               (COMPLEX (complex (realpart object) (imagpart object)))
               (FUNCTION (coerce-to-function object))
               ((VECTOR SIMPLE-VECTOR #+unicode SIMPLE-BASE-STRING SIMPLE-STRING
                        #+unicode BASE-STRING STRING BIT-VECTOR SIMPLE-BIT-VECTOR)
                (concatenate type object))
               (t
                (if (or (listp object) (vectorp object))
                    (concatenate type object)
                    (fail)))))
            ((eq (setq aux (first type)) 'COMPLEX)
             (if type
                 (complex (coerce (realpart object) (second type))
                          (coerce (imagpart object) (second type)))
                 (complex (realpart object) (imagpart object))))
            ((member aux '(SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT FLOAT))
             (setq aux (coerce object aux))
             (unless (typep aux type)
               (fail))
             aux)
            ((eq aux 'AND)
             (dolist (type (rest type))
               (setq aux (coerce aux type)))
             (unless (typep aux type)
               (fail))
             aux)
            ((or (listp object) (vectorp object))
             (concatenate type object))
            (t
             (fail))))))

;;************************************************************
;;                      SUBTYPEP
;;************************************************************
;;
;; TYPES LATTICE (Following Henry Baker's paper)
;;
;; The algorithm works as follows. Types are identified with sets. Some sets
;; are elementary, in the sense that other types may be expressed as
;; combination of them. We partition these sets into FAMILIES
;;
;;      Built-in objects --- Hash tables, etc
;;      Intervals --- (INTEGER a b), (REAL a b), etc
;;      Arrays --- (ARRAY * (2)), etc
;;      Classes
;;
;; When passed a type specifier, ECL canonicalizes it: it decomposes the
;; type into the most elementary sets, assigns a unique bit pattern (TAG) to
;; each of these sets, and builds a composite tag for the type by LOGIOR.
;; Operations between these sets reduce to logical operations between these
;; bit patterns. Given types T1, T2 and a function which produces tags f(T)
;;
;;      f((AND T1 T2)) = (LOGIAND f(T1) f(T2))
;;      f((OR T1 T2)) = (LOGIOR f(T1) f(T2))
;;      f((NOT T1)) = (LOGNOT f(T2))
;;
;; However, tags are not permanent: whenever a new type is registered, the
;; tag associated to a type may be changed (for instance, because new
;; elementary sets are discovered, which also belong to existing types).

(defparameter *save-types-database* nil)

(defparameter *highest-type-tag*
  #+ecl-min #B1
  #-ecl-min '#.*highest-type-tag*)

(defparameter *member-types*
  #+ecl-min NIL
  #-ecl-min '#.*member-types*)

(defparameter *intervals-mask* #B1)

(defparameter *elementary-types*
  #+ecl-min
  '()
  #-ecl-min
  '#.*elementary-types*)

(defun new-type-tag ()
  (declare (si::c-local))
  (prog1 *highest-type-tag*
    (setq *highest-type-tag* (ash *highest-type-tag* 1))))

;; Find out the tag for a certain type, if it has been already registered.
;;
(defun find-registered-tag (type &optional (test #'equal))
  (declare (si::c-local))
  (let* ((pos (assoc type *elementary-types* :test test)))
    (and pos (cdr pos))))

;; We are going to make changes in the types database. Save a copy if this
;; will cause trouble.
;;
(defun maybe-save-types ()
  (declare (si::c-local))
  (when *save-types-database*
    (setf *save-types-database* nil
          *elementary-types* (copy-tree *elementary-types*)
          *member-types* (copy-tree *member-types*))))

;; We have created and tagged a new type (NEW-TAG). However, there are
;; composite and synonym types registered around which are supertypes of
;; this type and need to be tagged. TYPE-MASK is a bit pattern which helps
;; us in recognizing these supertypes.
;;
(defun update-types (type-mask new-tag)
  (declare (ext:assume-no-errors))
  (maybe-save-types)
  (dolist (i *elementary-types*)
    (unless (zerop (logand (cdr i) type-mask))
      (setf (cdr i) (logior new-tag (cdr i))))))

;; FIND-TYPE-BOUNDS => (VALUES TAG-SUPER TAG-SUB)
;;
;; This function outputs two values: TAG-SUB, the tag for the union-type of all
;; types which are subtypes of the supplied one; and TAG-SUPER, which is either
;; the tag for the union-type of all types which a supertype of the supplied
;; one (MINIMIZE-SUPER = NIL) or the tag for the smallest type which is a
;; supertype of the given one (MINIMIZE-SUPER = TRUE). The search process is
;; restricted to types in the same family class.
;;
;; A value of MINIMIZE-SUPER = TRUE only makes sense for some families (such
;; as semi-infinite intervals), for which (SUBTYPEP T1 T2) = T and (SUBTYPEP T1
;; T3) = T implies either (SUBTYPEP T2 T3) = T or (SUBTYPEP T3 T2) = T.
;;
(defun find-type-bounds (type in-our-family-p type-<= minimize-super)
  (declare (si::c-local)
           (optimize (safety 0))
           (function in-our-family-p type-<=)) 
  (let* ((subtype-tag 0)
         (disjoint-tag 0)
         (supertype-tag (if minimize-super -1 0)))
    (dolist (i *elementary-types*)
      (declare (cons i))
      (let ((other-type (car i))
            (other-tag (cdr i)))
        (when (funcall in-our-family-p other-type)
          (cond ((funcall type-<= type other-type)
                 (if minimize-super
                     (when (zerop (logandc2 other-tag supertype-tag))
                       (setq supertype-tag other-tag))
                     (setq supertype-tag (logior other-tag supertype-tag))))
                ((funcall type-<= other-type type)
                 (setq subtype-tag (logior other-tag subtype-tag)))
                (t
                 (setq disjoint-tag (logior disjoint-tag other-tag)))))))
    (values (if (= supertype-tag -1) 0
                (logandc2 supertype-tag (logior disjoint-tag subtype-tag)))
            subtype-tag)))

;; A new type is to be registered, which is not simply a composition of
;; previous types. A new tag has to be created, and all supertypes are to be
;; tagged. Here we have to distinguish two possibilities: first, a supertype
;; may belong to the same family (intervals, arrays, etc); second, some
;; supertypes may be basic types (NUMBER is a supertype for (INTEGER 0 2),
;; for instance). The first possibility is detected with the comparison
;; procedure, TYPE-<=; the second possibility is detected by means of tags.
;;
(defun register-type (type in-our-family-p type-<=)
  (declare (si::c-local)
           (optimize (safety 0))
           (function in-our-family-p type-<=))
  (or (find-registered-tag type)
      (multiple-value-bind (tag-super tag-sub)
          (find-type-bounds type in-our-family-p type-<= nil)
        (let ((tag (new-type-tag)))
          (update-types (logandc2 tag-super tag-sub) tag)
          (setf tag (logior tag tag-sub))
          (push-type type tag)))))

;;----------------------------------------------------------------------
;; MEMBER types. We register this object in a separate list, *MEMBER-TYPES*,
;; and tag all types to which it belongs. We need to treat three cases
;; separately
;;      - Ordinary types, via simple-member-type, check the objects
;;        against all pre-registered types, adding their tags.
;;      - Ordinary numbers, are translated into intervals.
;;      - Floating point zeros, have to be treated separately. This
;;        is done by assigning a special tag to -0.0 and translating
;;        (MEMBER 0.0) = (AND (float-type 0.0 0.0) (NOT (MEMBER -0.0)))
;;
(defun register-member-type (object)
  ;(declare (si::c-local))
  (let ((pos (assoc object *member-types*)))
    (cond ((and pos (cdr pos)))
          ((not (realp object))
           (simple-member-type object))
          ((and (floatp object) (zerop object))
           #.(if (eql (- 0.0) 0.0)
                 '(number-member-type object)
                 '(if (minusp (float-sign object))
                      (simple-member-type object)
                      (logandc2 (number-member-type object)
                                (register-member-type (- object))))))
          (t
           (number-member-type object)))))

(defun simple-member-type (object)
  (declare (si::c-local)
           (ext:assume-no-errors))
  (let* ((tag (new-type-tag)))
    (maybe-save-types)
    (setq *member-types* (acons object tag *member-types*))
    (dolist (i *elementary-types*)
      (let ((type (car i)))
        (when (typep object type)
          (setf (cdr i) (logior tag (cdr i))))))
    tag))

;; We convert number into intervals, so that (AND INTEGER (NOT (EQL
;; 10))) is detected as a subtype of (OR (INTEGER * 9) (INTEGER 11
;; *)).
(defun number-member-type (object)
  (let* ((base-type (if (integerp object) 'INTEGER (type-of object)))
         (type (list base-type object object)))
    (or (find-registered-tag type)
        (register-interval-type type))))

(defun push-type (type tag)
  (declare (si::c-local)
           (ext:assume-no-errors))
  (dolist (i *member-types*)
    (declare (cons i))
    (when (typep (car i) type)
      (setq tag (logior tag (cdr i)))))
  (push (cons type tag) *elementary-types*)
  tag)

;;----------------------------------------------------------------------
;; SATISFIES types. Here we should signal some error which is caught
;; somewhere up, to denote failure of the decision procedure.
;;
(defun register-satisfies-type (type)
  (declare (si::c-local)
           (ignore type))
  (throw '+canonical-type-failure+ 'satisfies))

;;----------------------------------------------------------------------
;; CLOS classes and structures.
;;
(defun register-class (class)
  (declare (si::c-local)
           (notinline class-name))
  (or (find-registered-tag class)
      ;; We do not need to register classes which belong to the core type
      ;; system of LISP (ARRAY, NUMBER, etc).
      (let* ((name (class-name class)))
        (and name
             (eq class (find-class name 'nil))
             (or (find-registered-tag name)
                 (find-built-in-tag name))))
      (and (not (clos::class-finalized-p class))
           (throw '+canonical-type-failure+ nil))
      (register-type class
                     #'(lambda (c) (or (si::instancep c) (symbolp c)))
                     #'(lambda (c1 c2)
                         (when (symbolp c1)
                           (setq c1 (find-class c1 nil)))
                         (when (symbolp c2)
                           (setq c2 (find-class c2 nil)))
                         (and c1 c2 (si::subclassp c1 c2))))))

;;----------------------------------------------------------------------
;; ARRAY types.
;;
(defun register-array-type (type)
  (declare (si::c-local))
  (multiple-value-bind (array-class elt-type dimensions)
      (parse-array-type type)
    (cond ((eq elt-type '*)
           (canonical-type `(OR ,@(mapcar #'(lambda (type) `(,array-class ,type ,dimensions))
                                          +upgraded-array-element-types+))))
          ((find-registered-tag (setq type (list array-class elt-type dimensions))))
          (t
           #+nil
           (when (and (consp dimensions) (> (count-if #'numberp dimensions) 1))
             (dotimes (i (length dimensions))
               (when (numberp (elt dimensions i))
                 (let ((dims (make-list (length dimensions) :initial-element '*)))
                   (setf (elt dims i) (elt dimensions i))
                   (register-type (list array-class elt-type dims)
                                  #'array-type-p #'array-type-<=)))))
           (register-type type #'array-type-p #'array-type-<=)))))

;;
;; We look for the most specialized type which is capable of containing
;; this object. LIST always contains 'T, so that this procedure never
;; fails. It is faster than UPGRADED-... because we use the tags of types
;; that have been already registered.
;;
(defun fast-upgraded-array-element-type (type)
  (declare (si::c-local))
  (cond ((eql type '*) '*)
        ((member type +upgraded-array-element-types+ :test #'eq)
         type)
        (t
         (dolist (other-type +upgraded-array-element-types+ 'T)
           (when (fast-subtypep type other-type)
             (return other-type))))))

;;
;; This canonicalizes the array type into the form
;;      ({COMPLEX-ARRAY | SIMPLE-ARRAY} {elt-type | '*} {'* | (['*]*)})
;;
;; ELT-TYPE is the upgraded element type of the input.
;;
(defun parse-array-type (input)
  (declare (si::c-local))
  (let* ((type input)
         (name (pop type))
         (elt-type (fast-upgraded-array-element-type (if type (pop type) '*)))
         (dims (if type (pop type) '*)))
    (when type
      (error "Wrong array type designator ~S." input))
    (cond ((numberp dims)
           (unless (< -1 dims array-rank-limit)
             (error "Wrong rank size array type ~S." input))
           (setq dims (nthcdr (- array-rank-limit dims)
                              '#.(make-list array-rank-limit :initial-element '*))))
          ((consp dims)
           (dolist (i dims)
             (unless (or (eq i '*)
                         (and (integerp i) (< -1 i array-dimension-limit)))
               (error "Wrong dimension size in array type ~S." input)))))
    (values name elt-type dims)))

;;
;; This function checks whether the array type T1 is a subtype of the array
;; type T2.
;;
(defun array-type-<= (t1 t2)
  (unless (and (eq (first t1) (first t2))
               (eq (second t1) (second t2)))
    (return-from array-type-<= nil))
  (let ((dim (third t1))
        (pat (third t2)))
    (cond ((eq pat '*) t)
          ((eq dim '*) nil)
          (t (do ((a dim (cdr a))
                  (b pat (cdr b)))
                 ((or (endp a)
                      (endp b)
                      (not (or (eq (car b) '*)
                               (eql (car b) (car a)))))
                  (and (null a) (null b)))
               )))))

(defun array-type-p (type)
  (and (consp type)
       (member (first type) '(COMPLEX-ARRAY SIMPLE-ARRAY))))

;;----------------------------------------------------------------------
;; INTERVALS:
;;
;; Arbitrary intervals may be defined as the union or intersection of
;; semi-infinite intervals, of the form (number-type b *), where B is
;; either a real number, a list with one real number or *.
;; Any other interval, may be defined using these. For instance
;;  (INTEGER 0 2) = (AND (INTEGER 0 *) (NOT (INTEGER (2) *)))
;;  (SHORT-FLOAT (0.2) (2)) = (AND (SHORT-FLOAT (0.2) *) (NOT (SHORT-FLOAT 2 *)))

(defun register-elementary-interval (type b)
  (declare (si::c-local))
  (setq type (list type b))
  (or (find-registered-tag type #'equalp)
      (multiple-value-bind (tag-super tag-sub)
          (find-type-bounds type
                            #'(lambda (other-type)
                                (and (consp other-type)
                                     (null (cddr other-type))))
                            #'(lambda (i1 i2)
                                (and (eq (first i1) (first i2))
                                     (bounds-<= (second i2) (second i1))))
                            t)
        (let ((tag (new-type-tag)))
          (update-types (logandc2 tag-super tag-sub) tag)
          (setq tag (logior tag tag-sub))
          (push-type type tag)))))

(defun register-interval-type (interval)
  (declare (si::c-local))
  (let* ((i interval)
         (type (pop i))
         (low (if i (pop i) '*))
         (high (if i (pop i) '*))
         (tag-high (cond ((eq high '*)
                          0)
                         ((eq type 'INTEGER)
                          (setq high (if (consp high)
                                         (ceiling (first high))
                                         (floor (1+ high))))
                          (register-elementary-interval type high))
                         ((consp high)
                          (register-elementary-interval type (first high)))
                         (t
                          (register-elementary-interval type (list high)))))
         (tag-low (register-elementary-interval type
                    (cond ((or (eq '* low) (not (eq type 'INTEGER)) (integerp low))
                           low)
                          ((consp low)
                           (floor (1+ (first low))))
                          (t
                           (ceiling low)))))
         (tag (logandc2 tag-low tag-high)))
    (unless (eq high '*)
      (push-type interval tag))
    tag))

;; All comparisons between intervals operations may be defined in terms of
;;
;;      (BOUNDS-<= b1 b2)       and     (BOUNDS-< b1 b2)
;;
;; The first one checks whether (REAL b2 *) is contained in (REAL b1 *). The
;; second one checks whether (REAL b2 *) is strictly contained in (REAL b1 *)
;; (i.e., (AND (REAL b1 *) (NOT (REAL b2 *))) is not empty).
;;
(defun bounds-<= (b1 b2)
  (cond ((eq b1 '*) t)
        ((eq b2 '*) nil)
        ((consp b1)
         (if (consp b2)
             (<= (first b1) (first b2))
             (< (first b1) b2)))
        ((consp b2)
         (<= b1 (first b2)))
        (t
         (<= b1 b2))))

(defun bounds-< (b1 b2)
  (cond ((eq b1 '*) (not (eq b2 '*)))
        ((eq b2 '*) nil)
        ((consp b1)
         (if (consp b2)
             (< (first b1) (first b2))
             (< (first b1) b2)))
        ((consp b2)
         (<= b1 (first b2)))
        (t
         (< b1 b2))))

;;----------------------------------------------------------------------
;; COMPLEX types. We do not need to register anything, because all
;; possibilities have been covered by the definitions above. We only have to
;; bring the type to canonical form, which is a union of all specialized
;; complex types that can store an element of the corresponding type.
;;
(defun canonical-complex-type (real-type)
  (declare (si::c-local))
  ;; UPGRADE-COMPLEX-PART-TYPE will signal an error if REAL-TYPE
  ;; is not a subtype of REAL.
  (unless (eq real-type '*)
    (upgraded-complex-part-type real-type))
  (or (find-registered-tag '(COMPLEX REAL))
      (let ((tag (new-type-tag)))
        (push-type '(COMPLEX REAL) tag)))
  #+(or)
  (case real-type
    ((#+short-float SHORT-FLOAT
      SINGLE-FLOAT
      DOUBLE-FLOAT
      INTEGER
      RATIO
      #+long-float LONG-FLOAT)
     (let ((tag (new-type-tag)))
       (push-type `(COMPLEX ,real-type) tag)))
    ((RATIONAL) (canonical-type '(OR (COMPLEX INTEGER) (COMPLEX RATIO))))
    ((FLOAT) (canonical-type '(OR
                               #+short-float (COMPLEX SHORT-FLOAT)
                               (COMPLEX SINGLE-FLOAT)
                               (COMPLEX DOUBLE-FLOAT)
                               #+long-float (COMPLEX LONG-FLOAT))))
    ((* NIL REAL) (canonical-type
                   '(OR (COMPLEX INTEGER) (COMPLEX RATIO)
                     #+short-float (COMPLEX SHORT-FLOAT)
                     (COMPLEX SINGLE-FLOAT)
                     (COMPLEX DOUBLE-FLOAT)
                     #+long-float (COMPLEX LONG-FLOAT)
                     )))
    (otherwise (canonical-complex-type (upgraded-complex-part-type real-type)))))

;;----------------------------------------------------------------------
;; CONS types. Only (CONS T T) and variants, as well as (CONS NIL *), etc
;; are strictly supported.
;;
(defun register-cons-type (&optional (car-type '*) (cdr-type '*))
  ;; The problem with the code below is that it does not suport infinite
  ;; recursion. Instead we just canonicalize everything to CONS, irrespective
  ;; of whether the arguments are valid types or not!
  #+(or)
  (canonical-type 'CONS)
  (let ((car-tag (if (eq car-type '*) -1 (canonical-type car-type)))
        (cdr-tag (if (eq cdr-type '*) -1 (canonical-type cdr-type))))
    (cond ((or (zerop car-tag) (zerop cdr-tag))
           0)
          ((and (= car-tag -1) (= cdr-tag -1))
           (canonical-type 'CONS))
          (t
           (throw '+canonical-type-failure+ 'CONS)))))

;;----------------------------------------------------------------------
;; FIND-BUILT-IN-TAG
;;
;; This function computes the tags for all builtin types. We used to
;; do this computation and save it. However, for most cases it seems
;; faster if we just repeat it every time we need it, because the list of
;; *elementary-types* is kept smaller and *highest-type-tag* may be just
;; a fixnum.
;;
;; Note 1: There is some redundancy between this and the built-in
;; classes definitions. REGISTER-CLASS knows this and calls
;; FIND-BUILT-IN-TAG, which has priority. This is because some built-in
;; classes are also interpreted as intervals, arrays, etc.
;;
;; Note 2: All built in types listed here have to be symbols.
;;
#+ecl-min
(defconstant +built-in-type-list+
             '((SYMBOL)
               (KEYWORD NIL SYMBOL)
               (PACKAGE)
               (COMPILED-FUNCTION)
               (FUNCTION (OR COMPILED-FUNCTION GENERIC-FUNCTION))

               (INTEGER (INTEGER * *))
               (FIXNUM (INTEGER #.most-negative-fixnum #.most-positive-fixnum))
               (BIGNUM (OR (INTEGER * (#.most-negative-fixnum)) (INTEGER (#.most-positive-fixnum) *)))
               #+short-float
               (SHORT-FLOAT (SHORT-FLOAT * *))
               (SINGLE-FLOAT (SINGLE-FLOAT * *))
               (DOUBLE-FLOAT (DOUBLE-FLOAT * *))
               #+long-float
               (LONG-FLOAT (LONG-FLOAT * *))
               (RATIO (RATIO * *))

               (RATIONAL (OR INTEGER RATIO))
               (FLOAT (OR
                       #+short-float SHORT-FLOAT
                       SINGLE-FLOAT
                       DOUBLE-FLOAT
                       #+long-float LONG-FLOAT))
               (REAL (OR INTEGER
                      #+short-float SHORT-FLOAT
                      SINGLE-FLOAT
                      DOUBLE-FLOAT
                      #+long-float LONG-FLOAT
                      RATIO))
               (COMPLEX (COMPLEX REAL))

               (NUMBER (OR REAL COMPLEX))

               (CHARACTER)
               #-unicode
               (BASE-CHAR CHARACTER)
               #+unicode
               (BASE-CHAR NIL CHARACTER)
               (STANDARD-CHAR NIL BASE-CHAR)

               (CONS)
               (NULL (MEMBER NIL))
               (LIST (OR CONS (MEMBER NIL)))

               (ARRAY (ARRAY * *))
               (SIMPLE-ARRAY (SIMPLE-ARRAY * *))
               (SIMPLE-VECTOR (SIMPLE-ARRAY T (*)))
               (SIMPLE-BIT-VECTOR (SIMPLE-ARRAY BIT (*)))
               (VECTOR (ARRAY * (*)))
               (STRING (ARRAY CHARACTER (*)))
               #+unicode
               (BASE-STRING (ARRAY BASE-CHAR (*)))
               (SIMPLE-STRING (SIMPLE-ARRAY CHARACTER (*)))
               #+unicode
               (SIMPLE-BASE-STRING (SIMPLE-ARRAY BASE-CHAR (*)))
               (BIT-VECTOR (ARRAY BIT (*)))

               (SEQUENCE (OR CONS (MEMBER NIL) (ARRAY * (*))))

               (HASH-TABLE)
               (PATHNAME)
               (LOGICAL-PATHNAME NIL PATHNAME)

               (BROADCAST-STREAM)
               (CONCATENATED-STREAM)
               (ECHO-STREAM)
               (FILE-STREAM)
               (STRING-STREAM)
               (SYNONYM-STREAM)
               (TWO-WAY-STREAM)
               (EXT:SEQUENCE-STREAM)
               (EXT:ANSI-STREAM (OR BROADCAST-STREAM CONCATENATED-STREAM ECHO-STREAM
                                 FILE-STREAM STRING-STREAM SYNONYM-STREAM TWO-WAY-STREAM
                                 EXT:SEQUENCE-STREAM))
               #+clos-streams (GRAY:FUNDAMENTAL-STREAM)
               (STREAM (OR EXT:ANSI-STREAM
                        #+clos-streams GRAY:FUNDAMENTAL-STREAM))
               (EXT:VIRTUAL-STREAM (OR STRING-STREAM #+clos-streams GRAY:FUNDAMENTAL-STREAM))

               (READTABLE)
               #+threads (MP::PROCESS)
               #+threads (MP::LOCK)
               #+threads (MP::RWLOCK)
               #+threads (MP::CONDITION-VARIABLE)
               #+threads (MP::SEMAPHORE)
               #+threads (MP::BARRIER)
               #+threads (MP::MAILBOX)
               #+ffi (FOREIGN-DATA)
               #+sse2 (EXT:SSE-PACK (OR EXT:INT-SSE-PACK
                                     EXT:FLOAT-SSE-PACK
                                     EXT:DOUBLE-SSE-PACK))
               #+sse2 (EXT:INT-SSE-PACK)
               #+sse2 (EXT:FLOAT-SSE-PACK)
               #+sse2 (EXT:DOUBLE-SSE-PACK)
               (CODE-BLOCK)
               ))

(defconstant +built-in-types+
  (ext:hash-table-fill
     (make-hash-table :test 'eq :size 128)
     '#.+built-in-type-list+))

(defun find-built-in-tag (name)
  (declare (si::c-local))
  (let (record)
    (cond ((eq name T)
           -1)
          ((eq (setf record (gethash name +built-in-types+ name))
                    name)
           nil)
          (t
           (let* ((alias (pop record))
                  tag)
             (if alias
                 (setq tag (canonical-type alias))
                 (let* ((strict-supertype (or (first record) 'T))
                        (strict-supertype-tag (canonical-type strict-supertype)))
                   (setq tag (new-type-tag))
                   (unless (eq strict-supertype 't)
                     (extend-type-tag tag strict-supertype-tag))))
             (push-type name tag))))))

(defun extend-type-tag (tag minimal-supertype-tag)
  (declare (si::c-local)
           (ext:assume-no-errors))
  (dolist (type *elementary-types*)
    (let ((other-tag (cdr type)))
      (when (zerop (logandc2 minimal-supertype-tag other-tag))
        (setf (cdr type) (logior tag other-tag))))))

;;----------------------------------------------------------------------
;; CANONICALIZE (removed)
;;
;; This function takes a type tag and produces a more or less human
;; readable representation of the type in terms of elementary types,
;; intervals, arrays and classes.
;;
#+nil
(defun canonicalize (type)
  (let ((*highest-type-tag* *highest-type-tag*)
        (*save-types-database* t)
        (*member-types* *member-types*)
        (*elementary-types* *elementary-types*))
    (let ((tag (canonical-type type))
          (out))
      (setq tag (canonical-type type))
      ;;(print-types-database *elementary-types*)
      ;;(print-types-database *member-types*)
      (dolist (i *member-types*)
        (unless (zerop (logand (cdr i) tag))
          (push (car i) out)))
      (when out
        (setq out `((MEMBER ,@out))))
      (dolist (i *elementary-types*)
        (unless (zerop (logand (cdr i) tag))
          ;;(print (list tag (cdr i) (logand tag (cdr i))))
          (push (car i) out)))
        (values tag `(OR ,@out)))))

;;----------------------------------------------------------------------
;; (CANONICAL-TYPE TYPE)
;;
;; This function registers all types mentioned in the given expression,
;; and outputs a code corresponding to the represented type. This
;; function has side effects: it destructively modifies the content of
;; *ELEMENTARY-TYPES* and *MEMBER-TYPES*.
;;
(defun canonical-type (type)
  (declare (notinline clos::classp))
  (cond ((find-registered-tag type))
        ((eq type 'T) -1)
        ((eq type 'NIL) 0)
        ((symbolp type)
         (let ((expander (get-sysprop type 'DEFTYPE-DEFINITION)))
           (cond (expander
                  (canonical-type (funcall expander nil)))
                 ((find-built-in-tag type))
                 (t (let ((class (find-class type nil)))
                      (if class
                          (register-class class)
                          (throw '+canonical-type-failure+ nil)))))))
        ((consp type)
         (case (first type)
           (AND (apply #'logand (mapcar #'canonical-type (rest type))))
           (OR (apply #'logior (mapcar #'canonical-type (rest type))))
           (NOT (lognot (canonical-type (second type))))
           ((EQL MEMBER) (apply #'logior (mapcar #'register-member-type (rest type))))
           (SATISFIES (register-satisfies-type type))
           ((INTEGER #+short-float SHORT-FLOAT
                     SINGLE-FLOAT
                     DOUBLE-FLOAT
                     RATIO
                     #+long-float LONG-FLOAT)
            (register-interval-type type))
           ((FLOAT)
            (canonical-type `(OR #+short-float
                                 (SHORT-FLOAT ,@(rest type))
                                 (SINGLE-FLOAT ,@(rest type))
                                 (DOUBLE-FLOAT ,@(rest type))
                                 #+long-float
                                 (LONG-FLOAT ,@(rest type)))))
           ((REAL)
            (canonical-type `(OR (INTEGER ,@(rest type))
                                 (RATIO ,@(rest type))
                                 #+short-float
                                 (SHORT-FLOAT ,@(rest type))
                                 (SINGLE-FLOAT ,@(rest type))
                                 (DOUBLE-FLOAT ,@(rest type))
                                 #+long-float
                                 (LONG-FLOAT ,@(rest type)))))
           ((RATIONAL)
            (canonical-type `(OR (INTEGER ,@(rest type))
                                 (RATIO ,@(rest type)))))
           (COMPLEX
            (or (find-built-in-tag type)
                (canonical-complex-type (second type))))
           (CONS (apply #'register-cons-type (rest type)))
           (ARRAY (logior (register-array-type `(COMPLEX-ARRAY ,@(rest type)))
                          (register-array-type `(SIMPLE-ARRAY ,@(rest type)))))
           ((COMPLEX-ARRAY SIMPLE-ARRAY) (register-array-type type))
           ;;(FUNCTION (register-function-type type))
           ;;(VALUES (register-values-type type))
           (FUNCTION (canonical-type 'FUNCTION))
           (t (let ((expander (get-sysprop (first type) 'DEFTYPE-DEFINITION)))
                (if expander
                    (canonical-type (funcall expander (rest type)))
                    (unless (assoc (first type) *elementary-types*)
                      (throw '+canonical-type-failure+ nil)))))))
        ((clos::classp type)
         (register-class type))
        ((and (fboundp 'function-type-p) (function-type-p type))
         (register-function-type type))
        ((and (fboundp 'values-type-p) (values-type-p type))
         (register-values-type type))
        (t
         (error-type-specifier type))))

(defun safe-canonical-type (type)
  (catch '+canonical-type-failure+
    (canonical-type type)))

(defun fast-subtypep (t1 t2)
  (declare (si::c-local))
  (when (eq t1 t2)
    (return-from fast-subtypep (values t t)))
  (let* ((tag1 (safe-canonical-type t1))
         (tag2 (safe-canonical-type t2)))
    (cond ((and (numberp tag1) (numberp tag2))
           (values (zerop (logandc2 (safe-canonical-type t1)
                                    (safe-canonical-type t2)))
                   t))
          #+nil
          ((null tag1)
           (error "Unknown type specifier ~S." t1))
          #+nil
          ((null tag2)
           (error "Unknown type specifier ~S." t2))
          (t
           (values nil nil)))))

(defun subtypep (t1 t2 &optional env)
  (declare (ignore env))
  ;; One easy case: types are equal
  (when (eq t1 t2)
    (return-from subtypep (values t t)))
  ;; Another easy case: types are classes.
  (when (and (instancep t1) (instancep t2)
             (clos::classp t1) (clos::classp t2))
    (return-from subtypep (values (subclassp t1 t2) t)))
  ;; Finally, cached results.
  (let* ((cache *subtypep-cache*)
         (hash (truly-the (integer 0 255) (logand (hash-eql t1 t2) 255)))
         (elt (aref cache hash)))
    (when (and elt (eq (caar elt) t1) (eq (cdar elt) t2))
      (setf elt (cdr elt))
      (return-from subtypep (values (car elt) (cdr elt))))
    (let* ((*highest-type-tag* *highest-type-tag*)
           (*save-types-database* t)
           (*member-types* *member-types*)
           (*elementary-types* *elementary-types*))
      (multiple-value-bind (test confident)
          (fast-subtypep t1 t2)
        (setf (aref cache hash) (cons (cons t1 t2) (cons test confident)))
        (values test confident)))))

(defun fast-type= (t1 t2)
  (declare (si::c-local))
  (when (eq t1 t2)
    (return-from fast-type= (values t t)))
  (let* ((tag1 (safe-canonical-type t1))
         (tag2 (safe-canonical-type t2)))
    (cond ((and (numberp tag1) (numberp tag2))
           (values (= (safe-canonical-type t1) (safe-canonical-type t2))
                   t))
          #+nil
          ((null tag1)
           (error "Unknown type specifier ~S." t1))
          #+nil
          ((null tag2)
           (error "Unknown type specifier ~S." t2))
          (t
           (values nil nil)))))

(defun type= (t1 t2)
  (let ((*highest-type-tag* *highest-type-tag*)
        (*save-types-database* t)
        (*member-types* *member-types*)
        (*elementary-types* *elementary-types*))
    (fast-type= t1 t2)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/predlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/process.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  process.lsp  -- External processes.

;;;;  Copyright (c) 2003, Juan Jose Garcia-Ripoll
;;;;  Copyright (c) 2017, Daniel KochmaÅ„ski
;;;;
;;;;    See file 'LICENSE' for the copyright details.

(in-package "EXT")

(defmacro with-process-lock ((process) &body body)
  #+threads `(mp:with-lock ((external-process-%lock process)) ,@body)
  #-threads `(progn ,@body))

(defstruct (external-process (:constructor make-external-process ()))
  pid
  input
  output
  error-stream
  (%status :running)
  (%code nil)
  #+threads (%lock (mp:make-lock))
  #+threads (%pipe (mp:make-process)))

(defun external-process-status (external-process)
  (let ((status (external-process-%status external-process)))
    (if (member status '(:stopped :resumed :running))
        (ext:external-process-wait external-process nil)
        (values status (external-process-%code external-process)))))

;;; ---------------------------------------------------------------------
;;; si:waitpid -> (values                              status  code  pid)
;;; ---------------------------------------------------------------------
;;;  no change :: (values                                 nil   nil  nil)
;;;  error     :: (values (member              :abort :error)   nil  nil)
;;;  finished  :: (values (member          :exited :signaled)  code  pid)
;;;  running   :: (values (member :stopped :resumed :running)  code  pid)
;;; ---------------------------------------------------------------------
(defun external-process-wait (process &optional wait)
  (with-process-lock (process)
    (let ((pid (external-process-pid process)))
      (when pid
        (multiple-value-bind (status code pid) (si:waitpid pid wait)
          (ecase status
            ((:exited :signaled :abort :error)
             (setf (external-process-pid process) nil
                   (external-process-%status process) status
                   (external-process-%code process) code)
             #+threads (mp:process-join (external-process-%pipe process)))
            ((:stopped :resumed :running)
             (setf (external-process-%status process) status
                   (external-process-%code process) code))
            ((nil) #| wait was nil and process didn't change |#))))))
  (values (external-process-%status process)
          (external-process-%code process)))

(defun terminate-process (process &optional force)
  (with-process-lock (process)
    (let ((pid (external-process-pid process)))
      (when pid
        #+windows
        (ffi:c-inline
         (process pid) (:object :object) :void
         "HANDLE *ph = (HANDLE*)ecl_foreign_data_pointer_safe(#1);
         int ret = TerminateProcess(*ph, -1);
         if (ret == 0) FEerror(\"Cannot terminate the process ~A\", 1, #0);")
        #-windows
        (unless (zerop (si:killpid pid (if force +sigkill+ +sigterm+)))
          (error "Cannot terminate the process ~A" process))))))

;;;
;;; Backwards compatible SI:SYSTEM call. We avoid ANSI C system()
;;; because we are consuming the process wait status using a SIGCHLD
;;; handler -- this breaks some C libraries out there (OS X 32 bit).
;;;
#+ (or)
(defun system (cmd-string)
  (let ((shell "/bin/sh")
        (option "-c"))
    #+windows
    (let ((comspec (getenv "ComSpec")))
      (when comspec
        (setf shell comspec
              option "/c")))
    (nth-value 1 (run-program shell (list option cmd-string)
                              :wait t :output nil :input nil :error nil
                              #+windows :escape-arguments #+windows nil))))

;;; We don't handle `sigchld' because we don't want races with
;;; `external-process-wait'. Take care of forgotten processes.
(defun finalize-external-process (process)
  (unless (member (ext:external-process-wait process nil)
                  '(:exited :signaled :abort :error))
    (ext:set-finalizer process #'finalize-external-process)))

;;;
;;; Almighty EXT:RUN-PROGRAM. Built on top of SI:SPAWN-SUBPROCESS. For
;;; simpler alternative see SI:RUN-PROGRAM-INNER.
;;;
(defun run-program (command argv
                    &key
                      (input :stream)
                      (output :stream)
                      (error :output)
                      (wait t)
                      (environ :default)
                      (if-input-does-not-exist nil)
                      (if-output-exists :error)
                      (if-error-exists :error)
                      (external-format :default)
                      #+windows (escape-arguments t))

  (when (eql input t) (setf input *standard-input*))
  (when (eql output t) (setf output *standard-output*))
  (when (eql error t) (setf error *error-output*))

  (labels ((process-stream (which &rest args)
             (cond ((null which)
                    (null-stream (getf args :direction)))
                   ((or (stringp which)
                        (pathnamep which))
                    (apply #'open which :external-format external-format args))
                   #+clos-streams
                   ((typep which 'virtual-stream)
                    :virtual-stream)
                   ((or (eql which :stream)
                        (streamp which))
                    which)
                   ;; signal error as early as possible
                   (T (error "Invalid ~S argument to EXT:RUN-PROGRAM" which))))
           (prepare-args (args)
             #-windows
             (mapcar #'si:copy-to-simple-base-string args)
             #+windows
             (si:copy-to-simple-base-string
              (with-output-to-string (str)
                (loop for (arg . rest) on args
                   do (if (and escape-arguments
                               (find-if (lambda (c)
                                          (find c '(#\Space #\Tab #\")))
                                        arg))
                          (escape-arg arg str)
                          (princ arg str))
                     (when rest
                       (write-char #\Space str))))))
           (null-stream (direction)
             (open #-windows "/dev/null"
                   #+windows "nul"
                   :direction direction)))
    (let ((progname (si:copy-to-simple-base-string command))
          (args (prepare-args (cons command argv)))
          (process (make-external-process))
          (process-input (process-stream input
                                         :direction :input
                                         :if-does-not-exist if-input-does-not-exist))
          (process-output (process-stream output
                                          :direction :output
                                          :if-exists if-output-exists))
          (process-error (if (eql error :output)
                             :output
                             (process-stream error
                                             :direction :output
                                             :if-exists if-error-exists)))
          pid parent-write parent-read parent-error)

      (multiple-value-setq (pid parent-write parent-read parent-error)
        (si:spawn-subprocess progname args environ
                             (case process-input
                               ((nil) (null-stream :output))
                               (:virtual-stream :stream)
                               (otherwise process-input))
                             (case process-output
                               ((nil) (null-stream :input))
                               (:virtual-stream :stream)
                               (otherwise process-output))
                             (case process-error
                               ((nil) (null-stream :input))
                               (:virtual-stream :stream)
                               (otherwise process-error))))

      (let ((stream-write
             (when (plusp parent-write)
               (ext:make-stream-from-fd parent-write :output
                                        :element-type 'base-char
                                        :external-format external-format)))
            (stream-read
             (when (plusp parent-read)
               (ext:make-stream-from-fd parent-read :input
                                        :element-type 'base-char
                                        :external-format external-format)))
            (stream-error
             (when (plusp parent-error)
               (ext:make-stream-from-fd parent-error :input
                                        :element-type 'base-char
                                        :external-format external-format)))
            (piped-pairs nil))

        (when (eql process-input :virtual-stream)
          (push (cons input stream-write) piped-pairs))
        (when (eql process-output :virtual-stream)
          (push (cons stream-read output) piped-pairs))
        (when (eql process-error :virtual-stream)
          (push (cons stream-error error) piped-pairs))

        (setf (external-process-pid process) pid
              (external-process-input process) stream-write
              (external-process-output process) stream-read
              (external-process-error-stream process) stream-error)

        (when piped-pairs
          #+threads
          (let ((thread (external-process-%pipe process)))
            (mp:process-preset thread #'pipe-streams process piped-pairs)
            (mp:process-enable thread))
          #-threads
          (if wait
              (pipe-streams process piped-pairs)
              (warn "EXT:RUN-PROGRAM: Ignoring virtual stream I/O argument.")))

        (if wait
            (si:external-process-wait process t)
            (ext:set-finalizer process #'finalize-external-process))

        (values (if (and stream-read stream-write)
                    (make-two-way-stream stream-read stream-write)
                    (or stream-read stream-write))
                (external-process-%code process)
                process)))))

#+windows
(defun escape-arg (arg stream)
  ;; Normally, #\\ doesn't have to be escaped But if #\"
  ;; follows #\\, then they have to be escaped.  Do that by
  ;; counting the number of consequent backslashes, and
  ;; upon encoutering #\" immediately after them, output
  ;; the same number of backslashes, plus one for #\"
  (write-char #\" stream)
  (loop with slashes = 0
     for i below (length arg)
     for previous-char = #\a then char
     for char = (char arg i)
     do
       (case char
         (#\"
          (loop repeat slashes
             do (write-char #\\ stream))
          (write-string "\\\"" stream))
         (t
          (write-char char stream)))
       (case char
         (#\\
          (incf slashes))
         (t
          (setf slashes 0)))
     finally
     ;; The final #\" counts too, but doesn't need to be escaped itself
       (loop repeat slashes
          do (write-char #\\ stream)))
  (write-char #\" stream))


(defun pipe-streams (process pairs &aux to-remove)
  ;; note we don't use serve-event here because process input may be a
  ;; virtual stream and `select' won't catch this stream change.
  (si:until (or (null pairs)
                (member #-threads (external-process-wait process nil)
                        #+threads (external-process-%status process)
                        '(:exited :siognaled :abort :error)))
    (dolist (pair pairs)
      (destructuring-bind (input . output) pair
        (when (or (null (open-stream-p output))
                  (null (open-stream-p input))
                  (and (listen input)
                       (si:copy-stream input output nil)))
          (push pair to-remove))))
    ;; remove from the list exhausted streams
    (when to-remove
      (setf pairs (set-difference pairs to-remove)))
    #+threads (mp:process-yield)
    #-threads (sleep 0.0001)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/process.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/proclaim.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
(in-package "SYSTEM")
(proclaim '(FTYPE (FUNCTION (T T T) T) DEFMACRO*))
(proclaim '(FTYPE (FUNCTION (T T T) T) DM-VL))
(proclaim '(FTYPE (FUNCTION (T T) T) DM-V))
(proclaim '(FTYPE (FUNCTION (T T) T) DM-NTH))
(proclaim '(FTYPE (FUNCTION (T T) T) DM-NTH-CDR))
(proclaim '(FTYPE (FUNCTION (T) T) DM-BAD-KEY))
(proclaim '(FTYPE (FUNCTION (T) T) DM-KEY-NOT-ALLOWED))
;(proclaim '(FTYPE (FUNCTION (T T) T) FIND-DOC))
;(proclaim '(FTYPE (FUNCTION (T) T) FIND-DECLARATIONS))
(proclaim '(FTYPE (FUNCTION (T) T) CLEAR-COMPILER-PROPERTIES))
(proclaim '(FTYPE (FUNCTION (T) T) TERMINAL-INTERRUPT))
(proclaim '(FTYPE (FUNCTION (T T) T) BREAK-LEVEL))
(proclaim '(FTYPE (FUNCTION (T T) T) TPL-MAKE-COMMAND))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-PARSE-STRINGS))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-PRINT))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-UNKNOWN-COMMAND))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-GO))
(proclaim '(FTYPE (FUNCTION (T) T) PRINT-IHS))
(proclaim '(FTYPE (FUNCTION (T) T) PRINT-FRS))
(proclaim '(FTYPE (FUNCTION (T) T) FRS-KIND))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-HIDE))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-UNHIDE))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-UNHIDE-PACKAGE))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-HIDE-PACKAGE))
(proclaim '(FTYPE (FUNCTION (T) T) IHS-VISIBLE))
(proclaim '(FTYPE (FUNCTION (T) T) IHS-FNAME))
(proclaim '(FTYPE (FUNCTION (T) T) IHS-COMPILED-P))
(proclaim '(FTYPE (FUNCTION (T T) T) SUPER-GO))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-BACKWARD-SEARCH))
(proclaim '(FTYPE (FUNCTION (T) T) TPL-FORWARD-SEARCH))
(proclaim '(FTYPE (FUNCTION (T) T) PROVIDE))
(proclaim '(FTYPE (FUNCTION (T T) T) DOCUMENTATION))
(proclaim '(FTYPE (FUNCTION (T) T) FIND-DOCUMENTATION))
(proclaim '(FTYPE (FUNCTION (T) T) SIMPLE-ARRAY-P))
(proclaim '(FTYPE (FUNCTION (T T) T) TYPEP))
(proclaim '(FTYPE (FUNCTION (T T) T) SI::SUBCLASSP))
(proclaim '(FTYPE (FUNCTION (T) T) NORMALIZE-TYPE))
(proclaim '(FTYPE (FUNCTION (T) T) KNOWN-TYPE-P))
(proclaim '(FTYPE (FUNCTION (T T) T) SUBTYPEP))
(proclaim '(FTYPE (FUNCTION (T T) T) SUB-INTERVAL-P))
(proclaim '(FTYPE (FUNCTION (T T) T) IN-INTERVAL-P))
(proclaim '(FTYPE (FUNCTION (T T) T) MATCH-DIMENSIONS))
(proclaim '(FTYPE (FUNCTION (T T) T) COERCE))
(proclaim '(FTYPE (FUNCTION (T) T) CLEAR-COMPILER-PROPERTIES))
(proclaim '(FTYPE (FUNCTION (T) T) GET-SETF-METHOD))
(proclaim '(FTYPE (FUNCTION (T) T) GET-SETF-METHOD-MULTIPLE-VALUE))
(proclaim '(FTYPE (FUNCTION (T T T) T) SETF-EXPAND-1))
(proclaim '(FTYPE (FUNCTION (T T) T) SETF-EXPAND))
(proclaim '(FTYPE (FUNCTION (T T) T) INCREMENT-CURSOR))
(proclaim '(FTYPE (FUNCTION (T T) T) SEQUENCE-CURSOR))
(proclaim '(FTYPE (FUNCTION (T) T) ARRAY-DIMENSIONS))
(proclaim '(FTYPE (FUNCTION (T T) T) VECTOR-PUSH))
(proclaim '(FTYPE (FUNCTION (T) T) VECTOR-POP))
(proclaim '(FTYPE (FUNCTION (T) T) ASK-FOR-FORM))
(proclaim '(FTYPE (FUNCTION (T T T) T) TYPECASE-ERROR-STRING))
(proclaim '(FTYPE (FUNCTION (T) T) TYPECASE-ERROR-STRINGS))
(proclaim '(FTYPE (FUNCTION (T) T) BOIN-P))
(proclaim '(FTYPE (FUNCTION (T T T T T T T T T) T) MAKE-ACCESS-FUNCTION))
(proclaim '(FTYPE (FUNCTION (T T T T T) T) MAKE-CONSTRUCTOR))
(proclaim '(FTYPE (FUNCTION (T T T T) T) MAKE-COPIER))
(proclaim '(FTYPE (FUNCTION (T T T T T) T) MAKE-PREDICATE))
(proclaim '(FTYPE (FUNCTION (T T) T) PARSE-SLOT-DESCRIPTION))
(proclaim '(FTYPE (FUNCTION (T T) T) OVERWRITE-SLOT-DESCRIPTIONS))
(proclaim '(FTYPE (FUNCTION (T T T) T) SHARP-S-READER))
(proclaim '(FTYPE (FUNCTION (T T T) T) READ-INSPECT-COMMAND))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-SYMBOL))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-PACKAGE))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-CHARACTER))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-NUMBER))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-CONS))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-STRING))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-VECTOR))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-ARRAY))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT-OBJECT))
(proclaim '(FTYPE (FUNCTION (T) T) DESCRIBE))
(proclaim '(FTYPE (FUNCTION (T) T) INSPECT))
(proclaim '(FTYPE (FUNCTION (T) T) ARG-LIST))
(proclaim '(FTYPE (FUNCTION (T) T) PRIN1-TO-STRING))
(proclaim '(FTYPE (FUNCTION (T) T) PRINC-TO-STRING))
(proclaim '(FTYPE (FUNCTION (T T T) T) SHARP-A-READER))
(proclaim '(FTYPE (FUNCTION (T T T) T) SHARP-S-READER-SI))
(proclaim '(FTYPE (FUNCTION (T) T) LEAP-YEAR-P))
(proclaim '(FTYPE (FUNCTION (T) T) NUMBER-OF-DAYS-FROM-1900))
(proclaim '(FTYPE (FUNCTION (T) T) ISQRT))
(proclaim '(FTYPE (FUNCTION (T) T) ABS))
(proclaim '(FTYPE (FUNCTION (T) T) PHASE))
(proclaim '(FTYPE (FUNCTION (T) T) SIGNUM))
(proclaim '(FTYPE (FUNCTION (T) T) CIS))
(proclaim '(FTYPE (FUNCTION (T) T) ASIN))
(proclaim '(FTYPE (FUNCTION (T) T) ACOS))
(proclaim '(FTYPE (FUNCTION (T) T) SINH))
(proclaim '(FTYPE (FUNCTION (T) T) COSH))
(proclaim '(FTYPE (FUNCTION (T) T) TANH))
(proclaim '(FTYPE (FUNCTION (T) T) ASINH))
(proclaim '(FTYPE (FUNCTION (T) T) ACOSH))
(proclaim '(FTYPE (FUNCTION (T) T) ATANH))
(proclaim '(FTYPE (FUNCTION (T) T) RATIONAL))
(proclaim '(FTYPE (FUNCTION (T) T) RATIONALIZE))
(proclaim '(FTYPE (FUNCTION (T T) T) RATIONALIZE-FLOAT))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGNAND))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGNOR))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGANDC1))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGANDC2))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGORC1))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGORC2))
(proclaim '(FTYPE (FUNCTION (T) T) LOGNOT))
(proclaim '(FTYPE (FUNCTION (T T) T) LOGTEST))
(proclaim '(FTYPE (FUNCTION (T T) T) BYTE))
(proclaim '(FTYPE (FUNCTION (T) T) BYTE-SIZE))
(proclaim '(FTYPE (FUNCTION (T) T) BYTE-POSITION))
(proclaim '(FTYPE (FUNCTION (T T) T) LDB))
(proclaim '(FTYPE (FUNCTION (T T) T) LDB-TEST))
(proclaim '(FTYPE (FUNCTION (T T) T) MASK-FIELD))
(proclaim '(FTYPE (FUNCTION (T T T) T) DPB))
(proclaim '(FTYPE (FUNCTION (T T T) T) DEPOSIT-FIELD))
(proclaim '(FTYPE (FUNCTION (T) T) FIND-ALL-SYMBOLS))
(proclaim '(FTYPE (FUNCTION (T T) T) SUBSTRINGP))
(proclaim '(FTYPE (FUNCTION (T) T) PRINT-SYMBOL-APROPOS))
(proclaim '(FTYPE (FUNCTION (T) T) SEQTYPE))
(proclaim '(FTYPE (FUNCTION (T T T T) T) CALL-TEST))
(proclaim '(FTYPE (FUNCTION (T T) T) CHECK-SEQ-TEST))
(proclaim '(FTYPE (FUNCTION (T T) T) CHECK-SEQ-START-END))
(proclaim '(FTYPE (FUNCTION (T T T T) T) CHECK-SEQ-ARGS))
(proclaim '(FTYPE (FUNCTION (T T T) T) LIST-MERGE-SORT))
(proclaim '(FTYPE (FUNCTION (T FIXNUM FIXNUM T T) T) QUICK-SORT))
(proclaim '(FTYPE (FUNCTION (T) T) TRACE*))
(proclaim '(FTYPE (FUNCTION (T) T) UNTRACE*))
(proclaim '(FTYPE (FUNCTION (T) T) TRACE-ONE))
(proclaim '(FTYPE (FUNCTION (T) T) UNTRACE-ONE))
(proclaim '(FTYPE (FUNCTION (T) T) TRACING-BODY))
(proclaim '(FTYPE (FUNCTION (T) T) STEP*))
(proclaim '(FTYPE (FUNCTION (T T) T) LOOP-TEQUAL))
(proclaim '(FTYPE (FUNCTION (T T) T) LOOP-TMEMBER))
(proclaim '(FTYPE (FUNCTION (T T) T) LOOP-TASSOC))
(proclaim '(FTYPE (FUNCTION (T) T) LOOP-NAMED-VARIABLE))
(proclaim '(FTYPE (FUNCTION (T) T) PARSE-TYPE))
(proclaim '(FTYPE (FUNCTION (T T T) T) LV-BIND))
(proclaim '(FTYPE (FUNCTION (T) T) LV-SET))
(proclaim '(FTYPE (FUNCTION (T T) T) MERGE-INF))
(proclaim '(FTYPE (FUNCTION (T) T) SET-ITERATION))
(proclaim '(FTYPE (FUNCTION (T T T T T T) T) PARSE-FOR1))
(proclaim '(FTYPE (FUNCTION (T) T) PARSE-LOOP-PATH))
(proclaim '(FTYPE (FUNCTION (T) T) GET-ACC))
(proclaim '(FTYPE (FUNCTION (T) T) PARSE-WHEN))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/proclaim.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/arraylib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;    arraylib.lsp
;;;;
;;;;                            array routines
(in-package "SYSTEM")

(defun make-array (dimensions
                   &key (element-type t)
                        (initial-element nil initial-element-supplied-p)
                        (initial-contents nil initial-contents-supplied-p)
                        adjustable fill-pointer
                        displaced-to (displaced-index-offset 0))
  "Args: (dimensions &key (element-type t) initial-element (initial-contents nil)
                    (adjustable nil) (fill-pointer nil) (displaced-to nil)
                    (displaced-index-offset 0) (static nil))
Creates an array of the specified DIMENSIONS.  DIMENSIONS is a list of
non-negative integers each representing the length of the corresponding
dimension.  It may be an integer for vectors, i.e., one-dimensional arrays.
ELEMENT-TYPE specifies the type of array elements.  INITIAL-ELEMENT specifies
the initial value for all elements.  Its default value depends on ELEMENT-
TYPE.  INITIAL-CONTENTS specifies each element in terms of sequences.
ADJUSTABLE specifies whether or not the array is adjustable (see ADJUST-
ARRAY).  FILL-POINTER is meaningful only for vectors.  It specifies whether
the vector has fill-pointer or not, and if it has, the initial value of the
fill-pointer.  Possible values are NIL (no fill-pointer), T (the length of the
vector), or an integer.  See VECTOR-PUSH and VECTOR-POP.  DISPLACED-TO, if
non-NIL, must be an array and specifies that the new array is displaced to the
given array.  DISPLACED-INDEX-OFFSET is meaningful only when DISPLACED-TO is
non-NIL and specifies that the reference to the I-th element of the new array
in raw-major indexing is actually the reference to the (I + DISPLACED-INDEX-
OFFSET)th element of the given array.If the STATIC argument is supplied
with a non-nil value, then the body of the array is allocated as a
contiguous block."
  (let ((x (sys:make-pure-array element-type dimensions adjustable
                                fill-pointer displaced-to displaced-index-offset)))
    (declare (array x))
    (cond (initial-element-supplied-p
           (when initial-contents-supplied-p
             (error "MAKE-ARRAY: Cannot supply both :INITIAL-ELEMENT and :INITIAL-CONTENTS"))
           (fill-array-with-elt x initial-element 0 nil))
          (initial-contents-supplied-p
           (fill-array-with-seq x initial-contents))
          (t
           x))))

(defun fill-array-with-seq (array initial-contents)
  (declare (array array)
           (sequence initial-contents)
           (optimize (safety 0))
           (si::c-local))
  (labels ((iterate-over-contents (array contents dims written)
             (declare (fixnum written)
                      (array array)
                      (optimize (safety 0)))
             (when (/= (length contents) (first dims))
               (error "In MAKE-ARRAY: the elements in :INITIAL-CONTENTS do not match the array dimensions"))
             (if (= (length dims) 1)
                 (do* ((it (make-seq-iterator contents) (seq-iterator-next contents it)))
                      ((null it))
                   (sys:row-major-aset array written (seq-iterator-ref contents it))
                   (incf written))
                 (do* ((it (make-seq-iterator contents) (seq-iterator-next contents it)))
                      ((null it))
                   (setf written (iterate-over-contents array
                                                        (seq-iterator-ref contents it)
                                                        (rest dims)
                                                        written))))
             written))
    (let ((dims (array-dimensions array)))
      (if dims
          (iterate-over-contents array initial-contents dims 0)
          (setf (aref array) initial-contents))))
  array)


(defun vector (&rest objects)
  "Args: (&rest objects)
Creates and returns a simple-vector, with the N-th OBJECT being the N-th
element."
  (let ((a (si:make-vector t (length objects) nil nil nil 0)))
    (fill-array-with-seq a objects)))

(defun array-dimensions (array)
  "Args: (array)
Returns a list whose N-th element is the length of the N-th dimension of ARRAY."
  (do ((i (array-rank array))
       (d nil))
      ((= i 0) d)
    (declare (fixnum i)
             (optimize (safety 0)))
    (push (array-dimension array (decf i)) d)))


(defun array-in-bounds-p (array &rest indices)
  "Args: (array &rest indexes)
Returns T if INDEXes are valid indexes of ARRAY; NIL otherwise.  The number of
INDEXes must be equal to the rank of ARRAY."
  (declare (type array array)
           (optimize (safety 0))
           (ext:check-arguments-type))
  (do* ((indices indices (cons-cdr indices))
        (r (array-rank array))
        (i 0 (1+ i)))
       ((>= i r) t)
    (declare (type index r i))
    (if indices
        (let* ((index (cons-car indices)))
          (when (or (not (si::fixnump index))
                    (minusp (truly-the fixnum index))
                    (>= (truly-the fixnum index) (array-dimension array i)))
            (return nil)))
        (error "The rank of the array is ~R,~%~
               ~7@Tbut ~R ~:*~[indices are~;index is~:;indices are~] ~
               supplied."
                 r i))))

(defun row-major-index-inner (array indices)
  (declare (optimize (safety 0))
           (array array)
           (si::c-local))
  (flet ((indexing-error (array indices)
           (error "Not valid index or indices~%~A~%into array~%~A" indices array)))
    (do* ((r (array-rank array))
          (i 0 (1+ i))
          (j 0)
          (s indices (cons-cdr s)))
         ((null s)
          (when (< i r)
            (indexing-error array indices))
          j)
      (declare (ext:array-index j)
               (fixnum i r))
      (let* ((d (array-dimension array i))
             (o (cons-car s))
             ndx)
        (declare (ext:array-index ndx))
        (unless (and (typep o 'fixnum)
                     (<= 0 (setf ndx o))
                     (< ndx (array-dimension array i)))
          (indexing-error array indices))
        (setf j (* j d)
              j (+ j ndx))))))

(defun array-row-major-index (array &rest indices)
  "Args: (array &rest indexes)
Returns the non-negative integer that represents the location of the element
of ARRAY specified by INDEXes, assuming all elements of ARRAY are aligned in
row-major order."
  (declare (array array)
           (ext:check-arguments-type))
  (row-major-index-inner array indices))


(defun bit (bit-array &rest indices)
  "Args: (bit-array &rest indexes)
Returns the bit of BIT-ARRAY specified by INDEXes."
  (declare (array bit-array) ;; FIXME! Should be (simple-array bit)
           (ext:check-arguments-type))
  (row-major-aref bit-array (row-major-index-inner bit-array indices)))


(defun sbit (bit-array &rest indices)
  "Args: (simple-bit-array &rest subscripts)
Returns the specified bit in SIMPLE-BIT-ARRAY."
  (declare (array bit-array) ;; FIXME! Should be (simple-array bit)
           (ext:check-arguments-type))
  (row-major-aref bit-array (row-major-index-inner bit-array indices)))


(defun bit-and (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and BIT-ARRAY2.  Puts the results
into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T, or into
RESULT if RESULT is a bit-array."
  (bit-array-op boole-and bit-array1 bit-array2 result-bit-array))


(defun bit-ior (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-ior bit-array1 bit-array2 result-bit-array))


(defun bit-xor (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EXCLUSIVE OR of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-xor bit-array1 bit-array2 result-bit-array))


(defun bit-eqv (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise EQUIVALENCE of BIT-ARRAY1 and BIT-ARRAY2.  Puts the
results into a new bit-array if RESULT is NIL, into BIT-ARRAY1 if RESULT is T,
or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-eqv bit-array1 bit-array2 result-bit-array))

    
(defun bit-nand (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise AND of BIT-ARRAY1 and BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-nand bit-array1 bit-array2 result-bit-array))

    
(defun bit-nor (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise NOT of {the element-wise INCLUSIVE OR of BIT-ARRAY1
and BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-nor bit-array1 bit-array2 result-bit-array))

    
(defun bit-andc1 (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of {the element-wise NOT of BIT-ARRAY1} and BIT-
ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-andc1 bit-array1 bit-array2 result-bit-array))

    
(defun bit-andc2 (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise AND of BIT-ARRAY1 and {the element-wise NOT of BIT-
ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into BIT-
ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-andc2 bit-array1 bit-array2 result-bit-array))

    
(defun bit-orc1 (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of {the element-wise NOT of BIT-ARRAY1}
and BIT-ARRAY2.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-orc1 bit-array1 bit-array2 result-bit-array))

    
(defun bit-orc2 (bit-array1 bit-array2 &optional result-bit-array)
  "Args: (bit-array1 bit-array2 &optional (result nil))
Returns the element-wise INCLUSIVE OR of BIT-ARRAY1 and {the element-wise NOT
of BIT-ARRAY2}.  Puts the results into a new bit-array if RESULT is NIL, into
BIT-ARRAY1 if RESULT is T, or into RESULT if RESULT is a bit-array."
  (bit-array-op boole-orc2 bit-array1 bit-array2 result-bit-array))

    
(defun bit-not (bit-array &optional result-bit-array)
  "Args: (bit-array &optional (result nil))
Returns the element-wise NOT of BIT-ARRAY.  Puts the results into a new bit-
array if RESULT is NIL, into BIT-ARRAY if RESULT is T, or into RESULT if
RESULT is a bit-array."
  (bit-array-op boole-c1 bit-array bit-array result-bit-array))


(defun vector-pop (vector)
  "Args: (vector)
Decrements the fill-pointer of VECTOR by one and returns the element pointed
to by the new fill-pointer.  Signals an error if the old value of the fill-
pointer is 0 already."
  ;; FILL-POINTER asserts vector is a vector and has fill pointer
  (let* ((fp (fill-pointer vector))
         (vector (truly-the vector vector)))
    (declare (ext:array-index fp)
             (optimize (safety 0)))
    (when (zerop fp)
      (error "The fill pointer of the vector ~S zero." vector))
    (sys:fill-pointer-set vector (decf fp))
    (aref vector fp)))

(defun copy-array-contents (dest orig)
  (declare (si::c-local)
           (array dest orig)
           (optimize (safety 0)))
  (labels
      ((do-copy (dest orig dims1 dims2 start1 start2)
         (declare (array dest orig)
                  (list dims1 dims2)
                  (ext:array-index start1 start2))
         (let* ((d1 (pop dims1))
                (d2 (pop dims2))
                (l (min d1 d2))
                (i1 start1)
                (i2 start2))
           (declare (ext:array-index d1 d2 l i1 i2))
           (if (null dims1)
               (copy-subarray dest i1 orig i2 l)
               (let ((step1 (apply #'* dims1))
                     (step2 (apply #'* dims2)))
                 (declare (ext:array-index step1 step2))
                 (dotimes (i l)
                   (declare (ext:array-index i))
                   (do-copy dest orig dims1 dims2 i1 i2)
                   (incf i1 step1)
                   (incf i2 step2)))))))
    ;; We have to lie to DO-COPY reshaping the zero-dimensional array
    ;; as a one-dimensional array of one element.
    (do-copy dest orig (or (array-dimensions dest) '(1))
                       (or (array-dimensions orig) '(1))
                       0 0)))

(defun adjust-array (array new-dimensions
                     &rest r
                     &key (element-type (array-element-type array))
                          initial-element
                          initial-contents
                          fill-pointer
                          displaced-to
                          displaced-index-offset)
  "Args: (array dimensions
       &key (element-type (array-element-type array))
            initial-element (initial-contents nil) (fill-pointer nil)
            (displaced-to nil) (displaced-index-offset 0))
Adjusts the dimensions of ARRAY to the given DIMENSIONS.  ARRAY must be an
adjustable array."
  (declare (ignore initial-element
                   displaced-index-offset))
  (when (integerp new-dimensions)
        (setq new-dimensions (list new-dimensions)))
  ;; FILL-POINTER = NIL means use the old value of the fill pointer
  ;; Cannot set a fill pointer for an array that does not have any.
  (if (array-has-fill-pointer-p array)
      (unless fill-pointer
        (setf r (list* :fill-pointer (fill-pointer array) r)))
      (when fill-pointer
        (error 'simple-type-error
               :datum array
               :expected-type '(satisfies array-has-fill-pointer-p)
               :format-control "You supplied a fill pointer for an array without it.")))
  (let ((x (apply #'make-array new-dimensions :adjustable t :element-type element-type r)))
    (declare (array x))
    (unless (or displaced-to initial-contents)
      (copy-array-contents x array))
    (sys:replace-array array x)
    ))

;;; Copied from cmuci-compat.lisp of CLSQL by Kevin M. Rosenberg (LLGPL-licensed)
(defun shrink-vector (vec len)
  "Shrinks a vector."
  (cond ((adjustable-array-p vec)
         (adjust-array vec len))
        ((typep vec 'simple-array)
         (let ((new-vec (make-array len :element-type (array-element-type vec))))
           (copy-subarray new-vec 0 vec 0 len)))
        ((typep vec 'vector)
         (setf (fill-pointer vec) len)
         vec)
        (t
         (error "Unable to shrink vector ~S which is type-of ~S" vec (type-of vec))) 
        ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/arraylib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/assert.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "SYSTEM")

(defun read-evaluated-form ()
  (format *query-io* "~&Type a form to be evaluated:~%")
  (list (eval (read *query-io*))))

(defun wrong-type-argument (object type &optional place function)
  #-ecl-min
  (declare (c::policy-debug-ihs-frame))
  (tagbody again
     (restart-case
         (error 'simple-type-error
                :format-control
                "In ~:[an anonymous function~;~:*function ~A~], ~
                 ~:[found object~;~:*the value of ~A is~]~%~8t~S~%~
                 which is not of expected type ~A"
                :format-arguments (list function place object type)
                :datum object
                :expected-type type
                )
       (use-value (value)
         :report (lambda (stream)
                   (format stream "Supply a new value of type ~A." type))
         :interactive read-evaluated-form
         (setf object value)
         (unless (typep object type)
           (go again)))))
  object)

(defmacro check-type (place type &optional type-string)
  "Args: (check-type place typespec [string-form])
Signals a continuable error, if the value of PLACE is not of the specified
type.  Before continuing, receives a new value of PLACE from the user and
checks the type again.  Repeats this process until the value of PLACE becomes
of the specified type.  STRING-FORM, if given, is evaluated only once and the
value is used to indicate the expected type in the error message."
  (let ((aux (gensym)))
    `(let ((,aux ,place))
       (declare (:read-only ,aux))
       (unless (typep ,aux ',type)
         (setf ,place (do-check-type ,aux ',type ',type-string ',place)))
       nil)))

(defun do-check-type (value type type-string place)
  (tagbody again
     (unless (typep value type)
       (restart-case
           (error 'simple-type-error
                  :datum value
                  :expected-type type
                  :format-control "The value of ~S is ~S, which is not ~:[of type ~S~;~:*~A~]."
                  :format-arguments (list place value type-string type))
         (store-value (new-value)
           :report (lambda (stream)
                     (format stream "Supply a new value of ~S" place))
           :interactive read-evaluated-form
           (setf value new-value)
           (go again)))))
  value)

(defmacro assert (test-form &optional places &rest arguments)
  "Args: (assert form [({place}*) [string {arg}*]])
Evaluates FORM and signals a continuable error if the value is NIL.  Before
continuing, receives new values of PLACEs from user.  Repeats this process
until FORM returns a non-NIL value.  Returns NIL.  STRING is the format string
for the error message and ARGs are arguments to the format string."
  (let ((repl
         (if places
             `(setf (values ,@places)
                    (assert-failure ',test-form ',places (list ,@places)
                                    ,@arguments))
             `(assert-failure ',test-form
                              ,@(and arguments
                                     (list* nil nil arguments))))))
  `(while (not ,test-form)
     ,repl)))

(defun accumulate-cases (cases list-is-atom-p)
  (declare (si::c-local))
  (do ((c cases (cdr c))
       (l '()))
      ((null c) (nreverse l))
    (let ((keys (caar c)))
      (cond ((atom keys) (unless (null keys) (push keys l)))
            (list-is-atom-p (push keys l))
            (t (setq l (append keys l)))))))

(defun ecase-error (value values)
  (error 'CASE-FAILURE :name 'ECASE
         :datum value
         :expected-type (cons 'MEMBER values)
         :possibilities values))

(defmacro ecase (keyform &rest clauses)
  "Syntax: (ecase keyform {({key | ({key}*)} {form}*)}*)
Evaluates KEYFORM and tries to find the KEY that is EQL to the value of
KEYFORM.  If found, then evaluates FORMs that follow the KEY (or the key list
that contains the KEY) and returns all values of the last FORM.  If not,
signals an error."
  (setq clauses (remove-otherwise-from-clauses clauses))
  (let ((key (gensym)))
    `(let ((,key ,keyform))
       (case ,key ,@clauses
         (t (si::ecase-error ,key ',(accumulate-cases clauses nil)))))))

(defun ccase-error (keyform key values)
  (restart-case (error 'CASE-FAILURE
                       :name 'CCASE
                       :datum key
                       :expected-type (cons 'MEMBER values)
                       :possibilities values)
    (store-value (value)
      :REPORT (lambda (stream)
                (format stream "Supply a new value of ~S" keyform))
      :INTERACTIVE read-evaluated-form
      (return-from ccase-error value))))

(defun remove-otherwise-from-clauses (clauses)
  (declare (si::c-local))
  (mapcar #'(lambda (clause)
              (let ((options (first clause)))
                (if (member options '(t otherwise))
                    (cons (list options) (rest clause))
                    clause)))
          clauses))

(defmacro ccase (keyplace &rest clauses)
  "Syntax: (ccase place {({key | ({key}*)} {form}*)}*)
Searches a KEY that is EQL to the value of PLACE.  If found, then evaluates
FORMs in order that follow the KEY (or the key list that contains the KEY) and
returns all values of the last FORM.  If no such KEY is found, signals a
continuable error.  Before continuing, receives a new value of PLACE from
user and searches a KEY again.  Repeats this process until the value of PLACE
becomes EQL to one of the KEYs."
  (let* ((key (gensym))
         (repeat (gensym))
         (block (gensym)))
    (setq clauses (remove-otherwise-from-clauses clauses))
    `(block ,block
       (tagbody ,repeat
         (let ((,key ,keyplace))
           (return-from ,block
             (case ,key ,@clauses
               (t (setf ,keyplace
                        (si::ccase-error ',keyplace ,key
                                         ',(accumulate-cases clauses nil)))
                  (go ,repeat)))))))))

(defmacro typecase (keyform &rest clauses)
  "Syntax: (typecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, simply returns NIL.  The symbols T and OTHERWISE may
be used as a TYPE to specify the default case."
  (do ((l (reverse clauses) (cdr l))
       (form nil) (key (gensym)))
      ((endp l) `(let ((,key ,keyform)) ,form))
      (if (or (eq (caar l) 't) (eq (caar l) 'otherwise))
          (setq form `(progn ,@(cdar l)))
          (setq form
                `(if (typep ,key (quote ,(caar l)))
                     (progn ,@(cdar l))
                     ,form))))
  )

(defun etypecase-error (value types)
  (error 'CASE-FAILURE :name 'ETYPECASE
         :datum value
         :expected-type (cons 'OR types)
         :possibilities types))

(defmacro etypecase (keyform &rest clauses &aux (key (gensym)))
  "Syntax: (etypecase keyform {(type {form}*)}*)
Evaluates KEYFORM and searches a TYPE to which the value of KEYFORM belongs.
If found, then evaluates FORMs that follow the TYPE and returns all values of
the last FORM.  If not, signals an error."
   (setq clauses (remove-otherwise-from-clauses clauses))
   (do ((l (reverse clauses) (cdr l))   ; Beppe
        (form `(etypecase-error ,key ',(accumulate-cases clauses t))))
       ((endp l) `(let ((,key ,keyform)) ,form))
       (setq form `(if (typep ,key ',(caar l))
                       (progn ,@(cdar l))
                       ,form))
       )
   )

(defun ctypecase-error (keyplace value types)
  (restart-case (error 'CASE-FAILURE
                       :name 'CTYPECASE
                       :datum value
                       :expected-type (cons 'OR types)
                       :possibilities types)
    (store-value (value)
      :REPORT (lambda (stream)
                (format stream "Supply a new value of ~S." keyplace))
      :INTERACTIVE read-evaluated-form
      (return-from ctypecase-error value))))

(defmacro ctypecase (keyplace &rest clauses &aux (key (gensym)))
  "Syntax: (ctypecase place {(type {form}*)}*)
Searches a TYPE to which the value of PLACE belongs.  If found, then evaluates
FORMs that follow the TYPE and returns all values of the last FORM.  If no
such TYPE is found, signals a continuable error.  Before continuing, receives
a new value of PLACE from the user and searches an appropriate TYPE again.
Repeats this process until the value of PLACE becomes of one of the TYPEs."
  (setq clauses (remove-otherwise-from-clauses clauses))
  `(loop
    (let ((,key ,keyplace))
      ,@(mapcar #'(lambda (l)
                    `(when (typep ,key ',(car l))
                      (return (progn ,@(cdr l)))))
                clauses)
      (setf ,keyplace (ctypecase-error ',keyplace ,key
                                       ',(accumulate-cases clauses t))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/assert.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/numlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;                           number routines

(in-package "SYSTEM")

#-ecl-min
(ffi:clines "#include <math.h>")

#.
(flet ((binary-search (f min max)
         (do ((new (/ (+ min max) 2) (/ (+ min max) 2)))
             ((>= min max)
              max)
           (if (funcall f new)
               (if (= new max)
                   (return max)
                   (setq max new))
               (if (= new min)
                   (return max)
                   (setq min new)))))
       (epsilon+ (x)
         (/= (float 1 x) (+ (float 1 x) x)))
       (epsilon- (x)
         (/= (float 1 x) (- (float 1 x) x))))
  #+ecl-min
  (si::trap-fpe 'last nil)
  `(eval-when (compile load eval)
    (defconstant short-float-epsilon
      ,(binary-search #'epsilon+ (coerce 0 'short-float) (coerce 1 'short-float))
      "The smallest postive short-float E that satisfies
        (not (= (float 1 E) (+ (float 1 E) E)))")
    (defconstant single-float-epsilon
      ,(binary-search #'epsilon+ (coerce 0 'single-float) (coerce 1 'single-float))
      "The smallest postive single-float E that satisfies
        (not (= (float 1 E) (+ (float 1 E) E)))")
    (defconstant double-float-epsilon
      ,(binary-search #'epsilon+ (coerce 0 'double-float) (coerce 1 'double-float))
      "The smallest postive double-float E that satisfies
        (not (= (float 1 E) (+ (float 1 E) E)))")
    (defconstant long-float-epsilon
      ,(binary-search #'epsilon+ (coerce 0 'long-float) (coerce 1 'long-float))
      "The smallest postive long-float E that satisfies
        (not (= (float 1 E) (+ (float 1 E) E)))")
    (defconstant short-float-negative-epsilon
      ,(binary-search #'epsilon- (coerce 0 'short-float) (coerce 1 'short-float))
      "The smallest positive short-float E that satisfies
        (not (= (float 1 E) (- (float 1 E) E)))")
    (defconstant single-float-negative-epsilon
      ,(binary-search #'epsilon- (coerce 0 'single-float) (coerce 1 'single-float))
      "The smallest positive single-float E that satisfies
        (not (= (float 1 E) (- (float 1 E) E)))")
    (defconstant double-float-negative-epsilon
      ,(binary-search #'epsilon- (coerce 0 'double-float) (coerce 1 'double-float))
      "The smallest positive double-float E that satisfies
        (not (= (float 1 E) (- (float 1 E) E)))")
    (defconstant long-float-negative-epsilon
      ,(binary-search #'epsilon- (coerce 0 'long-float) (coerce 1 'long-float))
      "The smallest positive long-float E that satisfies
        (not (= (float 1 E) (- (float 1 E) E)))")
    ))

#+ieee-floating-point
(locally (declare (notinline -))
  (let ((bits (si::trap-fpe 'last nil)))
    (unwind-protect
         (progn
           (let ((a (/ (coerce 1 'short-float) (coerce 0.0 'short-float))))
             (defconstant short-float-positive-infinity a)
             (defconstant short-float-negative-infinity (- a)))
           (let ((a (/ (coerce 1 'single-float) (coerce 0.0 'single-float))))
             (defconstant single-float-positive-infinity a)
             (defconstant single-float-negative-infinity (- a)))
           (let ((a (/ (coerce 1 'double-float) (coerce 0.0 'double-float))))
             (defconstant double-float-positive-infinity a)
             (defconstant double-float-negative-infinity (- a)))
           (let ((a (/ (coerce 1 'long-float) (coerce 0.0 'long-float))))
             (defconstant long-float-positive-infinity a)
             (defconstant long-float-negative-infinity (- a))))
      (si::trap-fpe bits t))))

(defconstant imag-one #C(0.0 1.0))

(defun isqrt (i)
  "Args: (integer)
Returns the integer square root of INTEGER."
       (unless (and (integerp i) (>= i 0))
               (error 'type-error :datum i :expected-type 'unsigned-byte))
       (if (zerop i)
           0
           (let ((n (integer-length i)))
                (do ((x (ash 1 (ceiling n 2)))
                     (y))
                    (nil)
                    (setq y (floor i x))
                    (when (<= x y)
                          (return x))
                    (setq x (floor (+ x y) 2))))))

(defun phase (x)
  "Args: (number)
Returns the angle part (in radians) of the polar representation of NUMBER.
Returns zero for non-complex numbers."
  (if (zerop x)
    (if (eq x 0) 0.0 (float 0 (realpart x)))
    (atan (imagpart x) (realpart x))))

(defun signum (x)
  "Args: (number)
Returns a number that represents the sign of NUMBER.  Returns NUMBER If it is
zero.  Otherwise, returns the value of (/ NUMBER (ABS NUMBER))"
  (if (zerop x) x (/ x (abs x))))

(defun cis (x)
  "Args: (radians)
Returns a complex number whose realpart and imagpart are the values of (COS
RADIANS) and (SIN RADIANS) respectively."
  (exp (* imag-one x)))

#-ecl-min
(eval-when (:compile-toplevel)
  (defmacro c-num-op (name arg)
    #+long-float
    `(ffi::c-inline (,arg) (:long-double) :long-double
                    ,(format nil "~al(#0)" name)
                    :one-liner t)
    #-long-float
    `(ffi::c-inline (,arg) (:double) :double
                    ,(format nil "~a(#0)" name)
                    :one-liner t)))

(defun asin (x)
  "Args: (number)
Returns the arc sine of NUMBER."
  (if #+ecl-min t #-ecl-min (complexp x)
      (complex-asin x)
      #-ecl-min
      (let* ((x (float x))
             (xr (float x 1l0)))
        (declare (long-float xr))
        (if (and (<= -1.0 xr) (<= xr 1.0))
            (float (c-num-op "asin" xr) x)
            (complex-asin x)))))

;; Ported from CMUCL
(defun complex-asin (z)
  (declare (number z)
           (si::c-local))
  (let ((sqrt-1-z (sqrt (- 1 z)))
        (sqrt-1+z (sqrt (+ 1 z))))
    (complex (atan (realpart z) (realpart (* sqrt-1-z sqrt-1+z)))
             (asinh (imagpart (* (conjugate sqrt-1-z)
                                 sqrt-1+z))))))

(defun acos (x)
  "Args: (number)
Returns the arc cosine of NUMBER."
  (if #+ecl-min t #-ecl-min (complexp x)
      (complex-acos x)
      #-ecl-min
      (let* ((x (float x))
             (xr (float x 1l0)))
        (declare (long-float xr))
        (if (and (<= -1.0 xr) (<= xr 1.0))
            (float (c-num-op "acos" xr) (float x))
            (complex-acos x)))))

;; Ported from CMUCL
(defun complex-acos (z)
  (declare (number z)
           (si::c-local))
  (let ((sqrt-1+z (sqrt (+ 1 z)))
        (sqrt-1-z (sqrt (- 1 z))))
    (complex (* 2 (atan (realpart sqrt-1-z) (realpart sqrt-1+z)))
             (asinh (imagpart (* (conjugate sqrt-1+z)
                                 sqrt-1-z))))))

#+(and (not ecl-min) win32 (not mingw32))
(progn
  (ffi:clines "double asinh(double x) { return log(x+sqrt(1.0+x*x)); }")
  (ffi:clines "double acosh(double x) { return log(x+sqrt((x-1)*(x+1))); }")
  (ffi:clines "double atanh(double x) { return log((1+x)/(1-x))/2; }"))

#+(and long-float (not ecl-min) win32 (not mingw32))
(progn
  (ffi:clines "double asinhl(long double x) { return logl(x+sqrtl(1.0+x*x)); }")
  (ffi:clines "double acoshl(long double x) { return logl(x+sqrtl((x-1)*(x+1))); }")
  (ffi:clines "double atanhl(long double x) { return logl((1+x)/(1-x))/2; }"))

;; Ported from CMUCL
(defun asinh (x)
  "Args: (number)
Returns the hyperbolic arc sine of NUMBER."
  ;(log (+ x (sqrt (+ 1.0 (* x x)))))
  (if #+(or ecl-min) t #-(or ecl-min) (complexp x)
      (let* ((iz (complex (- (imagpart x)) (realpart x)))
             (result (complex-asin iz)))
        (complex (imagpart result)
                 (- (realpart result))))
      #-(or ecl-min)
      (float (c-num-op "asinh" x) (float x))))

;; Ported from CMUCL
(defun acosh (x)
  "Args: (number)
Returns the hyperbolic arc cosine of NUMBER."
  ;(log (+ x (sqrt (* (1- x) (1+ x)))))
  (if #+(or ecl-min) t #-(or ecl-min) (complexp x)
      (complex-acosh x)
      #-(or ecl-min)
      (let* ((x (float x))
             (xr (float x 1d0)))
        (declare (double-float xr))
        (if (<= 1.0 xr)
            (float (c-num-op "acosh" xr) (float x))
            (complex-acosh x)))))

(defun complex-acosh (z)
  (declare (number z) (si::c-local))
  (let ((sqrt-z-1 (sqrt (- z 1)))
        (sqrt-z+1 (sqrt (+ z 1))))
    (complex (asinh (realpart (* (conjugate sqrt-z-1)
                                 sqrt-z+1)))
             (* 2 (atan (imagpart sqrt-z-1) (realpart sqrt-z+1))))))

(defun atanh (x)
  "Args: (number)
Returns the hyperbolic arc tangent of NUMBER."
  ;(/ (- (log (1+ x)) (log (- 1 x))) 2)
  (if #+(or ecl-min) t #-(or ecl-min) (complexp x)
      (complex-atanh x)
      #-(or ecl-min)
      (let* ((x (float x))
             (xr (float x 1d0)))
        (declare (double-float xr))
        (if (and (<= -1.0 xr) (<= xr 1.0))
            (float (c-num-op "atanh" xr) (float x))
            (complex-atanh x)))))

(defun complex-atanh (z)
  (declare (number z) (si::c-local))
  (/ (- (log (1+ z)) (log (- 1 z))) 2))

(defun ffloor (x &optional (y 1))
  "Args: (number &optional (divisor 1))
Same as FLOOR, but returns a float as the first value."
  (multiple-value-bind (i r) (floor x y)
    (values (if (floatp r) (float i r) (float i)) r)))

(defun fceiling (x &optional (y 1.0f0))
  "Args: (number &optional (divisor 1))
Same as CEILING, but returns a float as the first value."
  (multiple-value-bind (i r) (ceiling x y)
    (values (if (floatp r) (float i r) (float i)) r)))

(defun ftruncate (x &optional (y 1.0f0))
  "Args: (number &optional (divisor 1))
Same as TRUNCATE, but returns a float as the first value."
  (multiple-value-bind (i r) (truncate x y)
    (values (if (floatp r) (float i r) (float i)) r)))

(defun fround (x &optional (y 1.0f0))
  "Args: (number &optional (divisor 1))
Same as ROUND, but returns a float as the first value."
  (multiple-value-bind (i r) (round x y)
    (values (if (floatp r) (float i r) (float i)) r)))

(defun logtest (x y)
  "Args: (integer1 integer2)
Equivalent to (NOT (ZEROP (LOGAND INTEGER1 INTEGER2)))."
  (not (zerop (logand x y))))


(defun byte (size position)
  "Args: (size position)
Returns a byte specifier of integers.  The value specifies the SIZE-bits byte
starting the least-significant-bit but POSITION bits of integers.  In ECL, a
byte specifier is represented by a dotted pair (SIZE . POSITION)."
  (cons size position))

(defun byte-size (bytespec)
  "Args: (byte)
Returns the size part (in ECL, the car part) of the byte specifier BYTE."
  (car bytespec))

(defun byte-position (bytespec)
  "Args: (byte)
Returns the position part (in ECL, the cdr part) of the byte specifier BYTE."
  (cdr bytespec))

(defun ldb (bytespec integer)
  "Args: (bytespec integer)
Extracts a byte from INTEGER at the specified byte position, right-justifies
the byte, and returns the result as an integer."
  (logand (ash integer (- (byte-position bytespec)))
          (lognot (ash -1 (byte-size bytespec)))))

(defun ldb-test (bytespec integer)
  "Args: (bytespec integer)
Returns T if at least one bit of the specified byte is 1; NIL otherwise."
  (not (zerop (mask-field bytespec integer))))

(defun mask-field (bytespec integer)
  "Args: (bytespec integer)
Extracts the specified byte from INTEGER and returns the result as an integer."
  (logand (ash (lognot (ash -1 (byte-size bytespec)))
               (byte-position bytespec))
          integer))

(defun dpb (newbyte bytespec integer)
  "Args: (newbyte bytespec integer)
Replaces the specified byte of INTEGER with NEWBYTE (an integer) and returns
the result."
  (let* ((pos (byte-position bytespec))
         (size (byte-size bytespec))
         (mask (ash (lognot (ash -1 size)) pos)))
    (logior (logandc2 integer mask)
            (logand (ash newbyte pos) mask))))

(defun deposit-field (newbyte bytespec integer)
  "Args: (integer1 bytespec integer2)
Returns an integer represented by the bit sequence obtained by replacing the
specified bits of INTEGER2 with the specified bits of INTEGER1."
  (let* ((pos (byte-position bytespec))
         (size (byte-size bytespec))
         (mask (ash (lognot (ash -1 size)) pos)))
    (logior (logandc2 integer mask)
            (logand newbyte mask))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/numlib.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/autoload.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.



;;; Program Development Environment

(in-package "SYSTEM")

(defun lisp-implementation-type ()
  "Args: ()
Returns the string \"ECL\"."
  "ECL")

;;; Compiler functions.

(defun autoload (pathname &rest function-names)
  (dolist (fname function-names)
    (let ((thename fname))
      (fset fname #'(lambda (&rest args)
                      (load pathname)
                      (apply thename args))))))

(unless (fboundp 'compile)
(defun proclaim (d)
  "Args: (decl-spec)
Gives a global declaration.  See DECLARE for possible DECL-SPECs."
  (when (eq (car d) 'SPECIAL) (mapc #'sys::*make-special (cdr d))))
)

(defmacro with-compilation-unit (options &rest body)
  (declare (ignore options))
  `(progn ,@body))

;;; Editor.

(defun ed (&optional filename)
  "Args: (&optional filename)
Invokes the editor.  The action depends on the version of ECL.  See the ECL
Report for details."
  (ext:system (format nil "~S ~A" (or (si::getenv "EDITOR") "vi") filename)))


;;; Allocator.

(defun room (&optional x)
  "Args: (&optional (x t))
Displays information about storage allocation in the following format.
        * for each type class
                * number of pages so-far allocated for the type class
                * maximum number of pages for the type class
                * percentage of used cells to cells so-far allocated
                * number of times the garbage collector has been called to
                  collect cells of the type class
                * implementation types that belongs to the type class
        * number of pages actually allocated for contiguous blocks
        * maximum number of pages for contiguous blocks
        * number of times the garbage collector has been called to collect
          contiguous blocks
        * number of pages in the hole
        * total number of pages allocated for cells
        * total number of pages allocated
        * number of available pages
        * number of pages ECL can use.
The number of times the garbage collector has been called is not shown, if the
number is zero.  The optional X is simply ignored."
  (declare (ignorable x))
  #+boehm-gc
  (progn
    (format t "
Unfortunately, when linked against the Boehm-Weiser garbage collector,
ECL has no means to find out the amount of memory used. Please use
some other routine (such as top in Unix or the Ctrl+Alt+Del combination
in Windows) to learn this.")
    (values))
  #-boehm-gc
  (let* (npage info-list link-alist)
    (multiple-value-bind
          (maxpage leftpage ncbpage maxcbpage ncb cbgbccount
                   holepage l)
        (sys::room-report)

      (do ((l l (nthcdr 5 l))
           (type-list '(cons
                       ;; fixnum Beppe
                        fixnum char
                        bignum ratio short-float long-float complex
                        symbol package hash-table
                        array vector string bit-vector
                        stream random-state readtable pathname
                        bytecodes cfun cclosure
                        #-clos structure #+clos instance #+clos generic-function
                        #+threads mp::process #+threads mp::lock
                        si::foreign))
           (tl type-list (cdr tl))
           (i 0 (+ i (if (nth 2 l) (nth 2 l) 0))))
          ((null l) (setq npage i))
        (let* ((typename (car tl))
               (nused (nth 0 l))
               (nfree (nth 1 l))
               (npage (nth 2 l))
               (maxpage (nth 3 l))
               (gbccount (nth 4 l)))
          (if nused
              (push (list typename npage maxpage
                          (if (zerop (+ nused nfree))
                              0
                              (/ nused 0.01 (+ nused nfree)))
                          (if (zerop gbccount) nil gbccount))
                    info-list)
              (let ((a (assoc (nth nfree type-list) link-alist)))
                (if a
                    (nconc a (list typename))
                    (push (list (nth nfree type-list) typename)
                          link-alist))))))
      (dolist (info (nreverse info-list))
        (apply #'format t "~4D/~D~10T~5,1F%~@[~3D~]~20T~{~A~^ ~}"
               (append (cdr info)
                       (if  (assoc (car info) link-alist)
                            (list (assoc (car info) link-alist))
                            (list (list (car info))))))
        (terpri)
        )
      (terpri)
      (format t "~4D/~D~16T~@[~3D~]~20Tcontiguous (~D blocks)~%"
              ncbpage maxcbpage (if (zerop cbgbccount) nil cbgbccount) ncb)
      (format t "~5T~D~20Thole~%" holepage)
      (format t "~5D pages for cells~%" npage)
      (format t "~5D total pages~%" (+ npage ncbpage holepage))
      (format t "~5D pages available~%" leftpage)
      (format t "~5D pages in heap but not gc'd + pages needed for gc marking~%"
              (- maxpage (+ npage ncbpage holepage leftpage)))
      (format t "~5D maximum pages~%" maxpage)
      (values)
      )))


;;; Help.

(autoload "sys:ecl-help" 'dump-help-file 'search-help-file)

(defun help (&optional (symbol 'help))
  "Args: (&optional symbol)
ECL specific.
Prints the documentation associated with SYMBOL.  With no args, prints the
greeting message to ECL beginners.

Welcome to ECL. Here are the few functions you should learn first.

        (HELP symbol) prints the online documentation associated with the
        symbol.  For example, (HELP 'CONS) will print the useful information
        about the CONS function, the CONS data type, and so on.

        (HELP* string) prints the online documentation associated with those
        symbols whose print-names have the string as substring.  For example,
        (HELP* \"PROG\") will print the documentation of the symbols such as
        PROG, PROGN, and MULTIPLE-VALUE-PROG1.

        (QUIT) ends the current ECL session.

For the precise language specification, refer to Guy Steele's \"Common Lisp,
the Language\" and our \"ECL Manual\".  \"ECL Dictionary\", the hard-copied
version of ECL online documentation, will be useful as a handbook.

Good luck!
"
  (print-doc symbol))

;;; Pretty-print-formats.
;;;
;;;     The number N as the property of a symbol SYMBOL indicates that,
;;;     in the form (SYMBOL f1 ... fN fN+1 ... fM), the subforms fN+1,...,fM
;;;     are the 'body' of the form and thus are treated in a special way by
;;;     the ECL pretty-printer.

;;; (At boot we don't have setf yet)

#-cmu-format
(mapc #'(lambda (x) (put-sysprop (first x) 'sys::pretty-print-format (second x)))
      '((block 1)
        (case 1)
        (catch 1)
        (ccase 1)
        (clines 0)
        (compiler-let 1)
        (cond 0)
        (ctypecase 1)
        (defcfun 2)
        (define-setf-method 2)
        (defla 2)
        (defmacro 2)
        (defsetf 3)
        (defstruct 1)
        (deftype 2)
        (defun 2)
        (do 2)
        (do* 2)
        (do-symbols 1)
        (do-all-symbols 1)
        (do-external-symbols 1)
        (dolist 1)
        (dotimes 1)
        (ecase 1)
        (etypecase 1)
        (eval-when 1)
        (flet 1)
        (labels 1)
        (lambda 1)
        (ext::lambda-block 2)
        (let 1)
        (let* 1)
        (locally 0)
        (loop 0)
        (macrolet 1)
        (multiple-value-bind 2)
        (multiple-value-prog1 1)
        (prog 1)
        (prog* 1)
        (prog1 1)
        (prog2 2)
        (progn 0)
        (progv 2)
        (return 0)
        (return-from 1)
        (tagbody 0)
        (the 1)
        (throw 1)
        (typecase 1)
        (unless 1)
        (unwind-protect 0)
        (when 1)
        (with-input-from-string 1)
        (with-open-file 1)
        (with-open-stream 1)
        (with-output-to-string 1)
#+clos  (defclass 2)
#+clos  (defmethod 2)
#+clos  (symbol-macrolet 2)
#+clos  (with-accessors 2)
#+clos  (with-slots 2)))

;;; Import functions which are useful for user interaction

(in-package "CL-USER")
(import '(sys::help sys::help* #-boehm-gc sys::room sys::gc sys::autoload ext::quit))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/autoload.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/evalmacros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "SYSTEM")

(defmacro unless (pred &rest body)
  "Syntax: (unless test {form}*)
If TEST evaluates to NIL, then evaluates FORMs and returns all values of the
last FORM.  If not, simply returns NIL."
  `(IF (NOT ,pred) (PROGN ,@body)))

(defmacro defmacro (&whole whole name vl &body body &aux doc-string)
  ;; Documentation in help.lsp
  (multiple-value-bind (function pprint doc-string)
      (sys::expand-defmacro name vl body)
    (setq function `(function ,function))
    (when *dump-defun-definitions*
      (print function)
      (setq function `(si::bc-disassemble ,function)))
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       ,(ext:register-with-pde whole `(si::fset ',name ,function t ,pprint))
       ,@(si::expand-set-documentation name 'function doc-string)
       ',name)))

(defmacro defvar (&whole whole var &optional (form nil form-sp) doc-string)
  "Syntax: (defvar name [form [doc]])
Declares the variable named by NAME as a special variable.  If the variable
does not have a value, then evaluates FORM and assigns the value to the
variable.  FORM defaults to NIL.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable)."
  `(LOCALLY (DECLARE (SPECIAL ,var))
    (SYS:*MAKE-SPECIAL ',var)
    ,@(when form-sp
          `((UNLESS (BOUNDP ',var)
              (SETQ ,var ,form))))
    ,@(si::expand-set-documentation var 'variable doc-string)
    ,(ext:register-with-pde whole)
    ,(if *bytecodes-compiler*
         `(eval-when (:compile-toplevel)
            (sys:*make-special ',var))
         `(eval-when (:compile-toplevel)
            (si::register-global ',var)))
    ',var))

(defmacro defparameter (&whole whole var form &optional doc-string)
  "Syntax: (defparameter name form [doc])
Declares the global variable named by NAME as a special variable and assigns
the value of FORM to the variable.  The doc-string DOC, if supplied, is saved
as a VARIABLE doc and can be retrieved by (documentation 'NAME 'variable)."
  `(LOCALLY (DECLARE (SPECIAL ,var))
    (SYS:*MAKE-SPECIAL ',var)
    (SETQ ,var ,form)
    ,@(si::expand-set-documentation var 'variable doc-string)
    ,(ext:register-with-pde whole)
    ,(if *bytecodes-compiler*
         `(eval-when (:compile-toplevel)
            (sys:*make-special ',var))
         `(eval-when (:compile-toplevel)
            (si::register-global ',var)))
    ',var))

(defmacro defconstant (&whole whole var form &optional doc-string)
  "Syntax: (defconstant symbol form [doc])

Declares that the global variable named by SYMBOL is a constant with the value
of FORM as its constant value.  The doc-string DOC, if supplied, is saved as a
VARIABLE doc and can be retrieved by (DOCUMENTATION 'SYMBOL 'VARIABLE)."
  `(PROGN
     (SYS:*MAKE-CONSTANT ',var ,form)
    ,@(si::expand-set-documentation var 'variable doc-string)
    ,(ext:register-with-pde whole)
    ,(if *bytecodes-compiler*
         `(eval-when (:compile-toplevel)
            (sys:*make-constant ',var ,form))
         `(eval-when (:compile-toplevel)
            (sys:*make-constant ',var ,form)
            (si::register-global ',var)))
    ',var))

(defparameter *defun-inline-hook* nil)

(defmacro defun (&whole whole name vl &body body &environment env &aux doc-string)
  ;; Documentation in help.lsp
  (multiple-value-setq (body doc-string) (remove-documentation body))
  (let* ((function `#'(ext::lambda-block ,name ,vl ,@body))
         (global-function `#'(ext::lambda-block ,name ,vl
                                                (declare (si::c-global))
                                                ,@body)))
    (when *dump-defun-definitions*
      (print function)
      (setq function `(si::bc-disassemble ,function)))
    `(progn
       ,(ext:register-with-pde whole `(si::fset ',name ,global-function))
       ,@(si::expand-set-documentation name 'function doc-string)
       ,(let ((hook *defun-inline-hook*))
          (and hook (funcall hook name global-function env)))
       ',name)))

;;;
;;; This is a no-op unless the compiler is installed
;;;
(defmacro define-compiler-macro (&whole whole name vl &rest body)
  (multiple-value-bind (function pprint doc-string)
      (sys::expand-defmacro name vl body 'cl:define-compiler-macro)
    (declare (ignore pprint))
    (setq function `(function ,function))
    (when *dump-defun-definitions*
      (print function)
      (setq function `(si::bc-disassemble ,function)))
    `(progn
       (put-sysprop ',name 'sys::compiler-macro ,function)
       ,@(si::expand-set-documentation name 'function doc-string)
       ,(ext:register-with-pde whole)
       ',name)))

(defun compiler-macro-function (name &optional env)
  (declare (ignorable env))
  (values (get-sysprop name 'sys::compiler-macro)))

;;; Each of the following macros is also defined as a special form,
;;; as required by CLtL. Some of them are used by the compiler (e.g.
;;; dolist), some not at all (e.g. defun).
;;; Thus their names need not be exported.

(let ()
  ;; We enclose the macro in a LET form so that it is no longer a
  ;; toplevel form. This solves the problem of this simple LOOP
  ;; replacing the more complex form in loop.lsp when evalmacros.lsp
  ;; gets compiled.
(defmacro loop (&rest body &aux (tag (gensym)))
  "Syntax: (loop {form}*)
Establishes a NIL block and executes FORMs repeatedly.  The loop is normally
terminated by a non-local exit."
  `(BLOCK NIL (TAGBODY ,tag (PROGN ,@body) (GO ,tag))))
)

(defmacro lambda (&rest body)
  `(function (lambda ,@body)))

(defmacro lambda-block (name lambda-list &rest lambda-body)
  (multiple-value-bind (decl body doc)
      (si::process-declarations lambda-body)
    (when decl (setq decl (list (cons 'declare decl))))
    `(lambda ,lambda-list ,@doc ,@decl
      (block ,(si::function-block-name name) ,@body))))

; assignment

(defmacro psetq (&rest args)
  "Syntax: (psetq {var form}*)
Similar to SETQ, but evaluates all FORMs first, and then assigns each value to
the corresponding VAR.  Returns NIL."
   (do ((l args (cddr l))
        (forms nil)
        (bindings nil))
       ((endp l) (list* 'LET* (nreverse bindings) (nreverse (cons nil forms))))
       (let ((sym (gensym)))
            (push (list sym (cadr l)) bindings)
            (push (list 'setq (car l) sym) forms)))
   )

; conditionals

(defmacro cond (&rest clauses &aux (form nil))
  "Syntax: (cond {(test {form}*)}*)
Evaluates TESTs in order until one evaluates to non-NIL.  Then evaluates FORMs
in order that follow the TEST and returns all values of the last FORM.  If no
forms follow the TEST, then returns the value of the TEST.  Returns NIL, if no
TESTs evaluates to non-NIL."
  (dolist (l (reverse clauses) form)    ; don't use nreverse here
    (if (endp (cdr l))
        (if (eq (car l) 't)
            (setq form 't)
            (let ((sym (gensym)))
              (setq form `(LET ((,sym ,(car l)))
;                          (DECLARE (:READ-ONLY ,sym)) ; Beppe
                           (IF ,sym ,sym ,form)))))
        (if (eq (car l) 't)
            (setq form (if (endp (cddr l))
                           (cadr l)
                           `(PROGN ,@(cdr l))))
            (setq form (if (endp (cddr l))
                           `(IF ,(car l) ,(cadr l) ,form)
                           `(IF ,(car l) (PROGN ,@(cdr l)) ,form))))))
  )

; program feature

(defmacro prog (vl &rest body &aux (decl nil))
  "Syntax: (prog ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) in parallel, and executes STATEMENTs.  Returns NIL."
  (multiple-value-setq (decl body)
    (find-declarations body))
  `(BLOCK NIL (LET ,vl ,@decl (TAGBODY ,@body)))
  )

(defmacro prog* (vl &rest body &aux (decl nil))
  "Syntax: (prog* ({var | (var [init])}*) {decl}* {tag | statement}*)
Establishes a NIL block, binds each VAR to the value of INIT (which defaults
to NIL) sequentially, and executes STATEMENTs.  Returns NIL."
  (multiple-value-setq (decl body)
    (find-declarations body))
  `(BLOCK NIL (LET* ,vl ,@decl (TAGBODY ,@body)))
  )

; sequencing

(defmacro prog1 (first &rest body &aux (sym (gensym)))
  "Syntax: (prog1 first-form {form}*)
Evaluates FIRST-FORM and FORMs in order.  Returns the value of FIRST-FORM."
  (if (null body) first
  `(LET ((,sym ,first))
;    (DECLARE (:READ-ONLY ,sym)) ; Beppe
    ,@body ,sym)))

(defmacro prog2 (first second &rest body &aux (sym (gensym)))
  "Syntax: (prog2 first-form second-form {forms}*)
Evaluates FIRST-FORM, SECOND-FORM, and FORMs in order.  Returns the value of
SECOND-FORM."
  `(PROGN ,first (LET ((,sym ,second))
;                      (DECLARE (:READ-ONLY ,sym)) ; Beppe
                       ,@body ,sym)))

; multiple values

(defmacro multiple-value-list (form)
  "Evaluates FORM and returns a list of all values FORM returns."
  `(MULTIPLE-VALUE-CALL 'LIST ,form))

(defmacro multiple-value-setq (vars form)
  "Syntax: (multiple-value-setq {var}* form)

Evaluates FORM and binds the N-th VAR to the N-th value of FORM or, if FORM
returns less than N values, to NIL.  Returns the first value of FORM or, if
FORM returns no value, NIL."
  (do ((vl vars (cdr vl))
       (sym (gensym))
       (forms nil)
       (n 0 (truly-the fixnum (1+ n))))
      ((endp vl) `(LET ((,sym (MULTIPLE-VALUE-LIST ,form))) ,@forms))
    (declare (fixnum n))
    (push `(SETQ ,(car vl) (NTH ,n ,sym)) forms)))

;; We do not use this macroexpanso, and thus we do not care whether
;; it is efficiently compiled by ECL or not.
(defmacro multiple-value-bind (vars form &rest body)
  "Syntax: (multiple-value-bind ({var}*) init {decl}* {form}*)

Evaluates INIT and binds the N-th VAR to the N-th value of INIT or, if INIT
returns less than N values, to NIL.  Then evaluates FORMs, and returns all
values of the last FORM.  If no FORM is given, returns NIL."
  (declare (notinline mapcar))
  `(multiple-value-call #'(lambda (&optional ,@(mapcar #'list vars)) ,@body) ,form))

(defun while-until (test body jmp-op)
  (declare (si::c-local))
  (let ((label (gensym))
        (exit (gensym)))
    `(TAGBODY
        (GO ,exit)
      ,label
        ,@body
      ,exit
        (,jmp-op ,test (GO ,label)))))

(defmacro sys::while (test &body body)
  (while-until test body 'when))

(defmacro sys::until (test &body body)
  (while-until test body 'unless))

(defmacro case (keyform &rest clauses)
  (let* ((last t)
         (form nil)
         (key (gensym)))
    (dolist (clause (reverse clauses)
             `(LET ((,key ,keyform))
                ;;(DECLARE (:READ-ONLY ,key)) ; Beppe
                ,form))
      (let ((selector (car clause)))
        (cond ((or (eq selector T) (eq selector 'OTHERWISE))
               (unless last
                 (si::signal-simple-error
                  'program-error nil
                  "CASE: The selector ~A can only appear at the last position."
                  (list selector)))
               (setq form `(PROGN ,@(cdr clause))))
              ((consp selector)
               (setq form `(IF (MEMBER ,key ',selector)
                               (PROGN ,@(cdr clause))
                               ,form)))
              (selector
               (setq form `(IF (EQL ,key ',selector)
                               (PROGN ,@(cdr clause))
                               ,form))))
        (setq last nil)))))

(defmacro return (&optional (val nil)) `(RETURN-FROM NIL ,val))

;; Declarations
(let ()
(defmacro declaim (&rest decl-specs)
  (if (cdr decl-specs)
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       (mapcar #'proclaim ',decl-specs))
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       (proclaim ',(car decl-specs)))))
)

(let ()
(defmacro c-declaim (&rest decl-specs)
  (if (cdr decl-specs)
    `(eval-when (:compile-toplevel)
       (mapcar #'proclaim ',decl-specs))
    `(eval-when (:compile-toplevel)
       (proclaim ',(car decl-specs)))))
)

(defmacro in-package (name)
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     (si::select-package ,(string name))))

(defmacro define-symbol-macro (&whole whole symbol expansion)
  (cond ((not (symbolp symbol))
         (error "DEFINE-SYMBOL-MACRO: ~A is not a symbol"
                symbol))
        ((specialp symbol)
         (error "DEFINE-SYMBOL-MACRO: cannot redefine a special variable, ~A"
                symbol))
        (t
         `(eval-when (:compile-toplevel :load-toplevel :execute)
           (put-sysprop ',symbol 'si::symbol-macro 
                        (lambda (form env) 
                          (declare (ignore form env))
                          ',expansion))
           ,(ext:register-with-pde whole)
           ',symbol))))

(defmacro nth-value (n expr)
  `(nth ,n (multiple-value-list ,expr)))

(defun maybe-unquote (form)
  (if (and (consp form) (eq (car form) 'quote))
      (second form)
      form))

(defun maybe-quote (form)
  ;; Quotes a form only if strictly required. This happens only when FORM is
  ;; either a symbol and not a keyword
  (if (if (atom form)
          (typep form '(and symbol (not keyword) (not boolean)))
          (not (eq (first form) 'quote)))
      (list 'quote form)
      form))

(defmacro ext:truly-the (&rest args)
  `(the ,@args))

(defmacro ext:checked-value (&rest args)
  `(the ,@args))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/evalmacros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/lsp/export.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;                    Exporting external symbols of LISP package

(eval-when (eval compile load)
  (si::select-package "SI"))

;;; ----------------------------------------------------------------------
;;;
(*make-special '*dump-defun-definitions*)
(setq *dump-defun-definitions* nil)
(*make-special '*dump-defmacro-definitions*)
(setq *dump-defmacro-definitions* *dump-defun-definitions*)

;; This is needed only when bootstrapping ECL using ECL-MIN
(eval-when (eval)
  (si::fset 'ext:register-with-pde
          #'(ext::lambda-block ext:register-with-pde (whole env)
               (let* ((definition (second whole))
                      (output-form (third whole)))
                 `(if ext:*register-with-pde-hook*
                      (funcall ext:*register-with-pde-hook*
                               (copy-tree *source-location*)
                               ,definition
                               ,output-form)
                      ,output-form)))
          t)
  (si::fset 'defun
          #'(ext::lambda-block defun (def env)
              (let* ((name (second def))
                     (function `#'(ext::lambda-block ,@(cdr def))))
                (when *dump-defun-definitions*
                  (print function)
                  (setq function `(si::bc-disassemble ,function)))
                (ext:register-with-pde def `(si::fset ',name ,function))))
          t)
 (si::fset 'in-package
          #'(ext::lambda-block in-package (def env)
              `(eval-when (eval compile load)
                (si::select-package ,(string (second def)))))
          t)
)

;;
;; This is also needed for booting ECL. In particular it is required in
;; defmacro.lsp.
;;
(defun filter-dolist-declarations (declarations)
  (declare (si::c-local))
  (let ((a nil))
    (mapc #'(lambda (clause)
              (when (not (and (consp clause)
                              (or (eq (car clause) 'type)
                                  (eq (car clause) 'ignore))))
                (setq a (cons clause a))))
          declarations)
    (nreverse a)))

(let ((f #'(ext::lambda-block dolist (whole env)
             (declare (ignore env))
             (let (body pop finished control var expr exit)
               (setq body (rest whole))
               (when (endp body)
                 (simple-program-error "Syntax error in ~A:~%~A" 'DOLIST whole))
               (setq control (first body) body (rest body))
               (when (endp control)
                 (simple-program-error "Syntax error in ~A:~%~A" 'DOLIST whole))
               (setq var (first control) control (rest control))
               (if (<= 1 (length control) 2)
                   (setq expr (first control) exit (rest control))
                   (simple-program-error "Syntax error in ~A:~%~A" 'DOLIST whole))
               (multiple-value-bind (declarations body)
                   (process-declarations body nil)
                 `(block nil
                    (let* ((%dolist-var ,expr))
                      (si::while %dolist-var
                        (let ((,var (car %dolist-var)))
                          (declare ,@declarations)
                          (tagbody ,@body)
                          (setq %dolist-var (cons-cdr %dolist-var))))
                      ,(when exit
                         `(let ((,var nil))
                            (declare (ignorable ,var)
                                     ,@(filter-dolist-declarations declarations))
                            ,@exit)))))))))
  (si::fset 'dolist f t))

(let ((f #'(ext::lambda-block dotimes (whole env)
           (declare (ignore env))
           (let (body pop finished control var expr exit)
             (setq body (rest whole))
             (when (endp body)
               (simple-program-error "Syntax error in ~A:~%~A" 'DOTIMES whole))
             (setq control (first body) body (rest body))
             (when (endp control)
               (simple-program-error "Syntax error in ~A:~%~A" 'DOTIMES whole))
             (setq var (first control) control (rest control))
             (if (<= 1 (length control) 2)
                 (setq expr (first control) exit (rest control))
                 (simple-program-error "Syntax error in ~A:~%~A" 'DOTIMES whole))
             (multiple-value-bind (declarations body)
                 (process-declarations body nil)
               (when (integerp expr)
                 (setq declarations
                       (cons `(type (integer 0 ,expr) ,var) declarations)))
               `(block nil
                 (let* ((%dotimes-var ,expr)
                        (,var 0))
                   (declare ,@declarations)
                   (si::while (< ,var %dotimes-var)
                     ,@body
                     (setq ,var (1+ ,var)))
                   ,@exit)))))))
  (si::fset 'dotimes f t))

(let ((f #'(ext::lambda-block do/do*-expand (whole env)
           (declare (ignore env))
           (let (do/do* control test result vl step let psetq body)
             (setq do/do* (first whole) body (rest whole))
             (if (eq do/do* 'do)
                 (setq let 'LET psetq 'PSETQ)
                 (setq let 'LET* psetq 'SETQ))
             (when (endp body)
               (simple-program-error "Syntax error in ~A:~%~A" do/do* whole))
             (setq control (first body) body (rest body))
             (when (endp body)
               (simple-program-error "Syntax error in ~A:~%~A" do/do* whole))
             (setq test (first body) body (rest body))
             (when (endp test)
               (simple-program-error "Syntax error in ~A:~%~A" do/do* whole))
             (setq result (rest test) test (first test))
             (dolist (c control)
               (when (symbolp c) (setq c (list c)))
               (case (length c)
                 ((1 2)
                  (setq vl (cons c vl)))
                 (3
                  (setq vl (cons (butlast c) vl)
                        step (list* (third c) (first c) step)))
                 (t
                  (simple-program-error "Syntax error in ~A:~%~A" do/do* whole))))
             (multiple-value-bind (declarations real-body)
                 (process-declarations body nil)
               `(BLOCK NIL
                 (,let ,(nreverse vl)
                   (declare ,@declarations)
                   (sys::until ,test
                      ,@real-body
                      ,@(when step (list (cons psetq (nreverse step)))))
                   ,@(or result '(nil)))))))))
  (si::fset 'do f t)
  (si::fset 'do* f t))

(defun eval-feature (x &aux operator)
  (declare (si::c-local))
  (cond ((symbolp x)
         (and (member x *features* :test #'eq) t))
        ((atom x) (error "~ is not allowed as a feature" x))
        ((not (symbolp (setq operator (first x))))
         (error "~S is not a valid feature expression." x))
        ((eql operator :AND)
         (dolist (x (cdr x) t) (when (not (eval-feature x)) (return nil))))
        ((eql operator :OR)
         (dolist (x (cdr x) nil) (when (eval-feature x) (return t))))
        ((eql operator :NOT)
         (not (eval-feature (second x))))
        (t (error "~S is not a valid feature expression." x))))

(defun do-read-feature (stream subchar arg test)
  (declare (si::c-local))
  (when arg
    (error "Reading from ~S: no number should appear between # and ~A"
           stream subchar))
  (let ((feature (let ((*package* (find-package "KEYWORD")))
                   (read stream t nil t))))
    (if (and (not *read-suppress*) (eq (eval-feature feature) test))
        (read stream t nil t)
        (let ((*read-suppress* t)) (read stream t nil t) (values)))))

(defun sharp-+-reader (stream subchar arg)
  (do-read-feature stream subchar arg T))

(defun sharp---reader (stream subchar arg)
  (do-read-feature stream subchar arg NIL))

(si::readtable-lock (si::standard-readtable) nil)
(set-dispatch-macro-character #\# #\+ 'sharp-+-reader)
(set-dispatch-macro-character #\# #\+ 'sharp-+-reader (sys::standard-readtable))
(set-dispatch-macro-character #\# #\- 'sharp---reader)
(set-dispatch-macro-character #\# #\- 'sharp---reader (sys::standard-readtable))
(si::readtable-lock (si::standard-readtable) t)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/lsp/export.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/doc/help.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;
;;;;    This program is free software; you can redistribute it and/or modify
;;;;    it under the terms of the GNU General Public License as published by
;;;;    the Free Software Foundation; either version 2 of the License, or
;;;;    (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;   setdoc.lsp
;;;;
;;;;                    Sets doc-strings for built-in symbols.

(in-package "COMPILER")                 ; in case it does not exist
(in-package "SYSTEM")

(defmacro docfun (symbol kind args doc)
  (do-docfun symbol kind args doc))

(defun do-docfun (symbol kind args doc)
  ;(print symbol)
  (assert (listp args))
  (ext:annotate symbol ':lambda-list nil args)
  (cond ((and doc (search "Syntax:" doc))
         (setf args nil))
        ((and doc (search "Args:" doc))
         (setf args nil))
        ((member kind '(macro special))
         (setf args (format nil "Syntax: ~A" args)))
        (t
         (setf args (format nil "Args: ~A" args))))
  (si::set-documentation
   symbol 'function
   (format nil "~A in ~A package:~@[~%~A~]~@[~%~A~]~%"
           (ecase kind
             (special "Special Form")
             (macro "Macro")
             (function "Function")
             (method "Generic function"))
           (package-name (symbol-package (si::function-block-name symbol)))
           args doc)))

(defmacro docvar (symbol kind doc)
  (do-docvar symbol kind doc))

(defun do-docvar (symbol kind doc)
  ;(print symbol)
  (si::set-documentation
   symbol 'variable
   (format nil "~@(~A~) in ~A package:~A~%"
           kind (package-name (symbol-package symbol)) doc)))

(defmacro doctype (symbol doc)
  (do-doctype symbol doc))

(defun do-doctype (symbol doc)
  ;(print symbol)
  (si::set-documentation symbol 'type doc))

(defun tree-search (tree x)
  (cond ((eq tree x)
         t)
        ((atom tree)
         nil)
        ((tree-search (car tree) x)
         t)
        (t
         (tree-search (cdr tree) x))))

(defun our-pde-hook (location definition output-form)
  (when (consp definition)
    (handler-case
        (let* ((documentation nil)
               (name (second definition)))
          (loop for i in (cddr definition)
             do (cond ((stringp i)
                       (setf documentation i)
                       (return))
                      ((and (consp i) (eq (first i) 'DECLARE))
                       ;; Produce no documentation for si::c-local functions
                       (when (tree-search i 'si::c-local)
                         (return-from our-pde-hook output-form)))
                      (t (return))))
          (case (first definition)
            (defun (do-docfun name 'function (third definition) documentation))
            (defmacro (do-docfun name 'macro (third definition) documentation))
            ((defvar defparameter) (when documentation (do-docvar name 'variable documentation)))
            (defconstant (when documentation (do-docvar name 'constant documentation)))
            (deftype (when documentation (do-doctype name documentation)))))
      (error (c) (princ c) (quit))))
  output-form)

(setf ext:*register-with-pde-hook* #'our-pde-hook)

#||
(defmacro docfun (symbol kind args string)
  `(progn (si::putprop ',symbol ,string 'si::function-documentation)
          (si::putprop ',symbol ',args 'arglist)
          ',symbol))

(defmacro docvar (symbol kind string)
          (declare (ignore kind))
  `(progn (si::putprop ',symbol ,string 'si::variable-documentation)
          ',symbol))

(defmacro doctype (symbol string)
  `(progn (si::putprop ',symbol ,string 'si::type-documentation)
          ',symbol))
||#

;;;----------------------------------------------------------------------
;;;     Ordered alphabetically for binary search
;;;----------------------------------------------------------------------

(docvar + variable "
The last top-level form.")

(docvar ++ variable "
The last-but-one top-level form.")

(docvar +++ variable "
The last-but-two top-level form.")

(docvar / variable "
The list of all values of the last top-level form.")

(docvar // variable "
The list of all values of the last-but-one top-level form.")

(docvar /// variable "
The list of all values of the last-but-two top-level form.")

(docvar - variable "
The top-level form ECL is currently evaluating.")

(docvar * variable "
The value of the last top-level form.")

(docfun * function (&rest numbers) "
Returns the product of the args.  With no args, returns 1.")

(docvar *debugger-hook* variable "
This is either NIL or a function of two arguments, a condition and the value
of *DEBUGGER-HOOK*. This function can either handle the condition or return
which causes the standard debugger to execute. The system passes the value
of this variable to the function because it binds *DEBUGGER-HOOK* to NIL
around the invocation.")

(docvar *debug-io* variable "
The stream used by the ECL debugger.  The initial value is a synonym stream to
*TERMINAL-IO*.")

(docvar *default-pathname-defaults* variable "
The default pathname used by some pathname-handling functions such as ENOUGH-
NAMESTRING.")

(docvar *error-output* variable "
The output stream to which error messages are output.  The initial value is an
synonym stream to *TERMINAL-IO*.")

(docvar *features* variable "
List of symbols that name features of the current version of ECL.  These
features are used in connection with the read macros #+ and #-.  When the
reader encounters
        #+ feature-spec form
it reads FORM in the usual manner if FEATURE-SPEC is satisfied.  Otherwise,
the reader just skips FORM.
        #- feature-spec form
is equivalent to
        #- (not feature-spec) form
A feature-spec may be a symbol, in which case the spec is satisfied iff the
symbol is an element of *FEATURES*.  Or else, a feature-spec must be one of
the following forms.
        (and {feature-spec}*)
                Satisfied iff all FEATURE-SPECs are satisfied
        (or {feature-spec}*)
                Satisfied iff at least one of FEATURE-SPECs is satisfied
        (not feature-spec)
                Satisfied iff FEATURE-SPEC is not satisfied")

#-boehm-gc
(docvar si::*gc-message* variable "
ECL specific.
If the value of SI::*GC-MESSAGE* is non-NIL, the garbage collector prints some
debugging information on the terminal.  Usually SI::*GC-MESSAGE* is set NIL.")

#-boehm-gc
(docvar si::*gc-verbose* variable "
ECL specific.
If the value of this variable is non-NIL, then the garbage collector notifies
that it begins to run whenever it is invoked.  Otherwise, garbage collection
begins silently.")

(docvar si::*ignore-eof-on-terminal-io* variable "
ECL specific.
If the value of this variable is non-NIL, ECL ignores the EOF-character
(usually ^D) on the terminal.  The initial value is NIL.")

#-boehm-gc
(docfun si::ignore-maximum-pages function (&optional (boolean t)) "
ECL specific.
Tells the ECL memory manager whether (non-NIL) or not (NIL) it should expand
memory when the maximum allocatable pages have been used up.  The initial
value is T. If no arguments are passed, returns the current value of the
flag.")

(docvar si::*indent-formatted-output* variable "
ECL specific.
The FORMAT directive ~~% indents the next line, if the value of this variable
is non-NIL.  If NIL, ~~% simply does Newline.")

(docvar si::*interrupt-enable* variable "
ECL specific.
If the value of SI::*INTERRUPT-ENABLE* is non-NIL, ECL signals an error on the
terminal interrupt (this is the default case).  If it is NIL, ECL ignores the
interrupt and assigns T to SI::*INTERRUPT-ENABLE*.")

(docvar ext::*invoke-debugger-hook* variable "
ECL specific.
This is either NIL or a designator for a function of two arguments,
to be run when the debugger is about to be entered.  The function is
run with *INVOKE-DEBUGGER-HOOK* bound to NIL to minimize recursive
errors, and receives as arguments the condition that triggered
debugger entry and the previous value of *INVOKE-DEBUGGER-HOOK*

This mechanism is an extension similar to the standard *DEBUGGER-HOOK*.
In contrast to *DEBUGGER-HOOK*, it is observed by INVOKE-DEBUGGER even when
called by BREAK.")

#-boehm-gc
(docvar si::*lisp-maxpages* variable "
ECL specific.
The current maximum number of pages (1 page = 2048 bytes) for the ECL process.
The result of changing the value of SI::*LISP-MAXPAGES* is unpredictable.")

(docvar *load-verbose* variable "
The default value for the :VERBOSE parameter of LOAD.
It initial value is T.")

(docvar *macroexpand-hook* variable "
The value of this variable must be a three-argument function object.
Each time a macro form is expanded, ECL calls that function with
        1. the macro expansion function (see MACRO-FUNCTION)
        2. the macro form to expand
        3. an environment (NIL in most case)
as three arguments, and uses the returned value as the expanded form.
The initial value of this variable is the function FUNCALL.")

(docfun si::*make-constant function (symbol value) "
ECL specific.
Declares that the global variable named by SYMBOL is a constant with VALUE as
its constant value.")

(docfun si::*make-special function (symbol) "
ECL specific.
Declares the variable named by NAME as a special variable.")

(docvar *package* variable "
The current package.  The initial value is the USER package.")

(docvar *print-array* variable "
Specifies whether ECL should print elements when it prints arrays other than
strings.  ECL uses the following abbreviation notations.
        #<bit-vector n>         for bit-vectors
        #<vector n>             for vectors other than strings and bit-vectors
        #<array n>              for arrays other than vectors
where N is a number that identifies the array.")

(docvar *print-base* variable "
The radix used to print integers and ratios.  The value must be an integer
from 2 to 36, inclusive.  The initial value is 10.")

(docvar *print-case* variable "
Specifies how to print ordinary symbols.  Possible values are:
        :UPCASE         in upper case
        :DOWNCASE       in lower case
        :CAPITALIZE     the first character in upper case, the rest in lower
The initial value is :UPCASE.")

(docvar *print-circle* variable "
Specifies whether the ECL printer should take care of circular lists.")

(docvar *print-escape* variable "
Specifies whether the ECL printer should output objects in the way that they
can be reread later if possible.")

(docvar *print-gensym* variable "
Specifies whether the ECL printer should prefix uninterned symbols with \"#:\".")

(docvar *print-length* variable "
Specifies how many elements the ECL printer should print when it prints a
list.  ECL printer prints all elements if the value of this variable is NIL.")

(docvar *print-level* variable "
Specifies how many levels of depth the ECL printer should print when it prints
a list.  ECL printer prints all levels if the value of this variable is NIL.")

(docvar *print-pretty* variable "
Specifies whether the ECL printer should pretty-print.  See PPRINT for more
information about pretty-printing.")

(docvar *print-radix* variable "
Specifies whether the ECL printer should print the radix when it prints
integers and ratios.")

#+profile
(docvar si::*profile-array* variable "
ECL specific.
Contains the profile histogram: two short integer counters are packed in each
value of this array of fixnums.")

(docvar *query-io* variable "
The query I/O stream. The initial value is a synonym stream to *TERMINAL-IO*.")

(docvar *random-state* variable "
The default random-state object used by RANDOM.")

(docvar *read-base* variable "
The radix used to read numbers.  The initial value is 10.")

(docvar *read-default-float-format* variable "
The default float format the ECL reader uses when reading floats.  Must be one
of the symbols SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, and LONG-FLOAT.")

(docvar *read-suppress* variable "
When the value of this variable is non-NIL, the ECL reader parses input
characters without most of the ordinary processings such as interning.  Used
to skip over forms.")

(docvar *readtable* variable "
The current readtable.")

(docvar *standard-input* variable "
The default input stream used by the ECL reader.  The initial value is a
synonym stream to *TERMINAL-IO*.")

(docvar *standard-output* variable "
The default output stream used by the ECL printer.  The initial value is a
synonym stream to *TERMINAL-IO*.")

(docvar *terminal-io* variable "
The terminal I/O stream.")

(docvar *trace-output* variable "
The stream used for trace output.  The initial value is a synonym stream to
*TERMINAL-IO*.")

(docfun + function (&rest numbers) "
Returns the sum of the args.  With no args, returns 0.")

(docfun - function (number &rest more-numbers) "
Returns the first arg subtracted by the rest of args.  With one arg, returns
- NUMBER.")

(docfun / function (number &rest more-numbers) "
Returns the first arg divided by the rest of args.  With one arg, returns
1/NUMBER.")

(docfun /= function (number &rest more-numbers) "
Returns T if no two of the args are numerically equal; NIL otherwise.")

(docfun 1+ function (number) "
Returns NUMBER plus one.")

(docfun 1- function (number) "
Returns NUMBER minus one.")

(docfun < function (number &rest more-numbers) "
Returns T if the args are in increasing order; NIL otherwise.")

(docfun <= function (number &rest more-numbers) "
Returns T if the args are in non-decreasing order; NIL otherwise.")

(docfun = function (number &rest more-numbers) "
Returns T if all args are numerically equal; NIL otherwise.")

(docfun > function (number &rest more-numbers) "
Returns T if the args are in decreasing order; NIL otherwise.")

(docfun >= function (number &rest more-numbers) "
Returns T if the args are in non-increasing order; NIL otherwise.")

(docfun abs function (number) "
Returns the absolute value of NUMBER.")

(docfun acons function (key datum alist) "
Equivalent to (CONS (CONS KEY DATUM) ALIST).")

(docfun adjoin function (item list &key (key '#'identity) (test '#'eql) test-not) "
Returns cons of ITEM and LIST unless ITEM is already an element of LIST.
Otherwise, returns LIST.")

(docfun adjustable-array-p function (array) "
Returns T if ARRAY is adjustable; NIL otherwise.")

#-boehm-gc
(docfun allocate function (type number &optional (really-allocate nil)) "
ECL specific.
Sets the maximum number of pages for the type class of the ECL implementation
type TYPE to NUMBER.  If REALLY-ALLOCATE is non-NIL, then the specified number
of pages will be allocated immediately.")

#-boehm-gc
(docfun si::allocate-contiguous-pages function (number &optional (really-allocate nil)) "
ECL specific.
Sets the maximum number of pages for contiguous blocks to NUMBER.  If REALLY-
ALLOCATE is non-NIL, then the specified number of pages will be allocated
immediately.")

#+clos
(docfun si::allocate-gfun function (name arity hash-table) "
ECL/CLOS specific.
Allocates a gfun object in which NAME is the generic function name, ARITY
is the number of arguments and HASH-TABLE is the hashtable for cashing
methods.")

#+clos
(docfun si::allocate-instance function (class length) "
ECL/CLOS specific.
Allocates an istance of CLASS with LENGTH slots.")

#-boehm-gc
(docfun si::allocated-contiguous-pages function () "
ECL specific.
Returns the number of pages currently allocated for contiguous blocks.")

#-boehm-gc
(docfun si::allocated-pages function (type) "
ECL specific.
Returns the number of pages currently allocated for the type class of the ECL
implementation type TYPE.")

(docfun alpha-char-p function (char) "
Returns T if CHAR is alphabetic; NIL otherwise.")

(docfun alphanumericp function (char) "
Returns T if CHAR is either numeric or alphabetic; NIL otherwise.")

(docfun and macro (&rest forms) "
Evaluates FORMs in order.  If any FORM evaluates to NIL, returns
immediately with the value NIL.  Otherwise, returns all values of the
last FORM.")

(docfun append function (&rest lists) "
Constructs and returns a new list by concatenating the args.")

(docfun apply function (function arg &rest more-args) "
Calls FUNCTION with all ARGs except the last and all elements of the last ARG
as the arguments to FUNCTION.  Returns all values that FUNCTION returns.")

(docfun applyhook function (function list evalhookfn applyhookfn &optional (env nil)) "
Calls FUNCTION with all elements of LIST as the arguments and with *EVALHOOK*
and *APPLYHOOK* bound to EVALHOOKFN and APPLYHOOKFN respectively.  Returns all
values that FUNCTION returns.")

(docfun aref function (array &rest indexes) "
Returns the element of ARRAY specified by INDEXES.")

(docfun si::argc function () "
ECL specific.
Returns the number of arguments given in the command line that invoked ECL.")

(docfun si::argv function (n) "
ECL specific.
Returns the N-th argument given in the command line that invoked ECL.")

(doctype array "
An array is a compound object whose elements are referenced by indexing.  One-
dimensional arrays are called vectors.  Other arrays are notated as
        #?a( ... )      or      #?A( ... )
where '?' is actually the rank of the array.
Arrays may be displaced to another array, may have a fill-pointer, or may be
adjustable.  Other arrays are called simple-arrays.  Only simple-arrays can be
input in the above format.")

(docfun array-dimension function (array n) "
Returns the length of the N-th dimension of ARRAY.")

(docvar array-dimension-limit constant "
The upper bound of the length of an array dimension.")

(docfun array-element-type function (array) "
Returns the element type ARRAY.")

(docfun array-has-fill-pointer-p function (array) "
Returns T if ARRAY has a fill-pointer; NIL otherwise.")

(docfun array-rank function (array) "
Returns the rank of ARRAY.")

(docvar array-rank-limit constant "
The upper bound of the rank of an array.")

(docfun array-total-size function (array) "
Returns the total number of elements of ARRAY.")

(docvar array-total-size-limit constant "
The upper bound of the total number of elements of an array.")

(docfun arrayp function (x) "
Returns T if X is an array; NIL otherwise.")

(docfun ash function (integer count) "
Returns the integer obtained by shifting the bits that represent INTEGER as
specified by COUNT.  Shifts left in COUNT bits if COUNT is positive.  Shifts
right in -COUNT bits if COUNT is negative.")

(docfun assoc function (item alist &key (test '#'eql) test-not (key '#'identity)) "
Returns the first pair in ALIST whose car is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.")

(docfun atan function (x &optional (y 1)) "
Returns the arc tangent of X/Y.")

(docfun atom function (x) "
Returns T if X is not a cons; NIL otherwise.")

(docfun si::bds-val function (n) "
ECL specific.
Returns the value of the N-th entity in the bind stack.")

(docfun si::bds-var function (n) "
ECL specific.
Returns the symbol of the N-th entity in the bind stack.")

(doctype bignum "
A bignum is an integer that is not a fixnum.")

(docfun bit-vector-p function (x) "
Returns T if X is a bit-vector; NIL otherwise.")

(docfun block special (name &body forms) "
Establishes a block named by NAME, evaluates FORMs in order, and returns all
values of the last FORM.  Returns NIL if no FORMs are given.
The scope of the established block is the body (i.e. the FORMs) of the BLOCK
form.  If (return-from name value-form) is evaluated within the scope, the
execution of the BLOCK form terminates immediately and all values of
VALUE-FORM will be returned as the values of the terminated BLOCK form.")

(docfun boole function (op integer1 integer2) "
Returns the integer produced by the logical operation specified by OP on the
two integers.  OP must be the value of one of the following constants.
        BOOLE-CLR       BOOLE-C1        BOOLE-XOR       BOOLE-ANDC1
        BOOLE-SET       BOOLE-C2        BOOLE-EQV       BOOLE-ANDC2
        BOOLE-1         BOOLE-AND       BOOLE-NAND      BOOLE-ORC1
        BOOLE-2         BOOLE-IOR       BOOLE-NOR       BOOLE-ORC2
Each logical operation on integers produces an integer represented by the bit
sequence obtained by a bit-wise logical operation on the bit sequences that
represent the integers.  Two's-complement representation is assumed to obtain
the bit sequence that represents an integer.  For example,
         2:  ...010
         1:  ...001
         0:  ...000
        -1:  ...111
        -2:  ...110
where each '...' represents either an infinite sequence of 0's (for non-
negative integers) or an infinite sequence of 1's (for negative integers).")

(docvar boole-1 constant "
Makes BOOLE return INTEGER1.")

(docvar boole-2 constant "
Makes BOOLE return INTEGER2.")

(docvar boole-and constant "
Makes BOOLE return the AND of INTEGER1 and INTEGER2.")

(docvar boole-andc1 constant "
Makes BOOLE return the AND of {the NOT of INTEGER1} and INTEGER2.")

(docvar boole-andc2 constant "
Makes BOOLE return the AND of INTEGER1 and {the NOT of INTEGER2}.")

(docvar boole-c1 constant "
Makes BOOLE return the NOT of INTEGER1.")

(docvar boole-c2 constant "
Makes BOOLE return the NOT of INTEGER2.")

(docvar boole-clr constant "
Makes BOOLE return 0.")

(docvar boole-eqv constant "
Makes BOOLE return the EQUIVALENCE of INTEGER1 and INTEGER2.")

(docvar boole-ior constant "
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and INTEGER2.")

(docvar boole-nand constant "
Makes BOOLE return the NOT of {the AND of INTEGER1 and INTEGER2}.")

(docvar boole-nor constant "
Makes BOOLE return the NOT of {the INCLUSIVE OR of INTEGER1 and INTEGER2}.")

(docvar boole-orc1 constant "
Makes BOOLE return the INCLUSIVE OR of {the NOT of INTEGER1} and INTEGER2.")

(docvar boole-orc2 constant "
Makes BOOLE return the INCLUSIVE OR of INTEGER1 and {the NOT of INTEGER2}.")

(docvar boole-set constant "
Makes BOOLE return -1.")

(docvar boole-xor constant "
Makes BOOLE return the EXCLUSIVE OR of INTEGER1 and INTEGER2.")

(docfun both-case-p function (char) "
Returns T if CHAR is an alphabetic character; NIL otherwise.  Equivalent to
ALPHA-CHAR-P.")

(docfun boundp function (symbol) "
Returns T if the global variable named SYMBOL has a value; NIL otherwise.")

#|
(docfun compiler:build-ecl function (program-name &rest components) "

Builds a standalone executable using the object files, libraries and flags
which follow PROGRAM-NAME, which is the name of the final executable.

Each argument in COMPONENTS can be either a symbol or a string. If it is a
string, it is passed as such to the C compiler when building the program. This
way you can specify FASL code (i.e. compiled lisp code) and additional
libraries or custom C code.

However, if the argument is a symbol, it is interpreted as the name of a lisp
library of FASL code. You should use symbols to call in optional parts of the
interpreter, such as the compiler 'CMP (not yet available)

For example:
        (compile-file \"my-code.lsp\" :system-p)
        (build-ecl \"my-ecl\" \"my-code.o\" \"-Bdynamic -lX11\" 'cmp)
builds an new interpreter with some custom lisp code given in \"my-code.o\" and
with the ECL compiler (You must explicitely mention the compiler if you want
it). Finally, the X-Windows dynamically linked libraries are also included
because \"my-code.lsp\" uses the foreign function interface to do some
graphics.")
|#

(docfun butlast function (list &optional (n 1)) "
Returns a copy of LIST with the last N elements removed.")

(docfun by function () "
ECL specific.
Exits from ECL.  Equivalent to BYE.")

(docfun bye function () "
ECL specific.
Exits from ECL.  Equivalent to BY.")

(docfun caaaar function (x) "
Equivalent to (CAR (CAR (CAR (CAR X)))).")

(docfun caaadr function (x) "
Equivalent to (CAR (CAR (CAR (CDR X)))).")

(docfun caaar function (x) "
Equivalent to (CAR (CAR (CAR X))).")

(docfun caadar function (x) "
Equivalent to (CAR (CAR (CDR (CAR X)))).")

(docfun caaddr function (x) "
Equivalent to (CAR (CAR (CDR (CDR X)))).")

(docfun caadr function (x) "
Equivalent to (CAR (CAR (CDR X))).")

(docfun caar function (x) "
Equivalent to (CAR (CAR X)).")

(docfun cadaar function (x) "
Equivalent to (CAR (CDR (CAR (CAR X)))).")

(docfun cadadr function (x) "
Equivalent to (CAR (CDR (CAR (CDR X)))).")

(docfun cadar function (x) "
Equivalent to (CAR (CDR (CAR X))).")

(docfun caddar function (x) "
Equivalent to (CAR (CDR (CDR (CAR X)))).")

(docfun cadddr function (x) "
Equivalent to (CAR (CDR (CDR (CDR X)))).")

(docfun caddr function (x) "
Equivalent to (CAR (CDR (CDR X))).")

(docfun cadr function (x) "
Equivalent to (CAR (CDR X)).")

(docvar call-arguments-limit constant "
The upper bound of the number of arguments to a function.  Ignore this value
since there is no such logical upper bound in ECL.")

(docfun car function (x) "
Returns the car of X if X is a cons.  Returns NIL if X is NIL.")

(docfun case macro (keyform &rest alternatives) "
Syntax: (case keyform {({key | ({key}*)} {form}*)}*)

Evaluates KEYFORM and searches a KEY that is EQL to the value of KEYFORM.  If
found, then evaluates FORMs in order that follow the KEY (or the key list that
contains the KEY) and returns all values of the last FORM.  Returns NIL if no
such key is found.  The symbols T and OTHERWISE may be used at the place of a
key list to specify the default case.")

(docfun catch special (tag-form &body forms) "
Syntax: (catch tag-form {form}*)

Sets up a catcher whose catch tag is the value of TAG-FORM.  Then evaluates
FORMs in order and returns all values of the last FORM.  During the evaluation
of FORMs, if a THROW form is evaluated that specifies a catch tag EQ to the
value of the TAG-FORM, then the execution of the CATCH form terminates
immediately and the values specified by the THROW form are returned as the
value of the CATCH form.")

(docfun cdaaar function (x) "
Equivalent to (CDR (CAR (CAR (CAR X)))).")

(docfun cdaadr function (x) "
Equivalent to (CDR (CAR (CAR (CDR X)))).")

(docfun cdaar function (x) "
Equivalent to (CDR (CAR (CAR X))).")

(docfun cdadar function (x) "
Equivalent to (CDR (CAR (CDR (CAR X)))).")

(docfun cdaddr function (x) "
Equivalent to (CDR (CAR (CDR (CDR X)))).")

(docfun cdadr function (x) "
Equivalent to (CDR (CAR (CDR X))).")

(docfun cdar function (x) "
Equivalent to (CDR (CAR X)).")

(docfun cddaar function (x) "
Equivalent to (CDR (CDR (CAR (CAR X)))).")

(docfun cddadr function (x) "
Equivalent to (CDR (CDR (CAR (CDR X)))).")

(docfun cddar function (x) "
Equivalent to (CDR (CDR (CAR X))).")

(docfun cdddar function (x) "
Equivalent to (CDR (CDR (CDR (CAR X)))).")

(docfun cddddr function (x) "
Equivalent to (CDR (CDR (CDR (CDR X)))).")

(docfun cdddr function (x) "
Equivalent to (CDR (CDR (CDR X))).")

(docfun cddr function (x) "
Equivalent to (CDR (CDR X)).")

(docfun cdr function (x) "
Returns the cdr of X if X is a cons.  Returns NIL if X is NIL.")

(docfun ceiling function (number &optional (divisor 1)) "
Returns the smallest integer not less than NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.")

(docfun cerror function (continue-format-string error-format-string &rest args) "
Signals a continuable error.")

(docfun char function (string index) "
Returns the INDEX-th character in STRING.")

(docfun char-bit function (char name) "
Returns T if the specified bit attribute of CHAR is 'on'; NIL otherwise.
In ECL the bit-attributes handled are :control :meta :super and :hyper")

(docfun char-bits function (char) "
Returns the bit attributes of CHAR as an integer. In ECL it returns a value
between 0 and 16, since ECL handle 4 bit attributes.")

(docvar char-bits-limit constant "
The upper bound of values returned by CHAR-BITS.  16 in ECL.")

(docfun char-code function (char) "
Returns the character code of CHAR as a fixnum.")

(docvar char-code-limit constant "
The upper bound of values returned by CHAR-CODE.")

(docvar char-control-bit constant "
The bit position indicating a control character.  1 in ECL.")

(docfun char-downcase function (char) "
Returns the lower-case character corresponding to CHAR, if CHAR is upper-case.
Otherwise, returns CHAR.")

(docfun char-equal function (char &rest more-chars) "
Returns T if all CHARs are the same; NIL otherwise.  Lower-case characters are
regarded the same as the corresponding upper-case characters.")

(docfun char-font function (char) "
Returns the font attribute of CHAR.  Returns always 0 in ECL, since ECL
characters have no font attributes.")

(docvar char-font-limit constant "
The upper bound of values returned by CHAR-FONT.  1 in ECL.")

(docfun char-greaterp function (char &rest more-chars) "
Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.")

(docvar char-hyper-bit constant "
The bit position indicating a hyper character.  8 in ECL.")

(docfun char-int function (char) "
Returns the font, bits, and code attributes as an integer.  Equivalent to
CHAR-CODE in ECL.")

(docfun char-lessp function (char &rest more-chars) "
Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.")

(docvar char-meta-bit constant "
The bit position indicating a meta character.  2 in ECL.")

(docfun char-name function (char) "
Returns the 'character name' of CHAR as a string; NIL if CHAR has no character
name.  Only #\\Backspace, #\\Tab, #\\Newline (or #\\Linefeed), #\\Page,
#\\Return, and #\\Rubout have character names in ECL.")

(docfun char-not-equal function (char &rest more-chars) "
Returns T if no two of CHARs are the same; NIL otherwise.  Lower-case
characters are regarded the same as the corresponding upper-case characters.")

(docfun char-not-greaterp function (char &rest more-chars) "
Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.")

(docfun char-not-lessp function (char &rest more-chars) "
Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.  For lower-case characters, codes of corresponding upper-case
characters are used.")

(docvar char-super-bit constant "
The bit position indicating a super character.  4 in ECL.")

(docfun char-upcase function (char) "
Returns the upper-case character of CHAR, if CHAR is lower-case.  Otherwise,
returns CHAR.")

(docfun char/= function (char &rest more-chars) "
Returns T if no two of CHARs are the same; NIL otherwise.")

(docfun char< function (char &rest more-chars) "
Returns T if the character codes of CHARs are in increasing order; NIL
otherwise.")

(docfun char<= function (char &rest more-chars) "
Returns T if the character codes of CHARs are in non-decreasing order; NIL
otherwise.")

(docfun char= function (char &rest more-chars) "
Returns T if all CHARs are the same; NIL otherwise.")

(docfun char> function (char &rest more-chars) "
Returns T if the character codes of CHARs are in decreasing order; NIL
otherwise.")

(docfun char>= function (char &rest more-chars) "
Returns T if the character codes of CHARs are in non-increasing order; NIL
otherwise.")

(doctype character "
A character represents a character that can be handled by the computer.
Characters have font, bits, and code attributes.  Font and bits attributes
are always 0 in ECL.  Most versions of ECL uses ASCII code:
  000 - 037     #\\^@  #\\^A  #^B ... #\\Z  #\\^[  #\\^\\  #\\^]  #\\^^  #\\^_
                except #\\Tab(011)     #\\Newline(012)     #\\Page(014)
                       #\\Return(015)  #\\Backspace(031)
  040 - 057     #\\Space  #\\!  #\\\"  #\\#  #\\$  #\\%  #\\&  #\\'  #\\(  #\\)  #\\*
                #\\+  #\\,  #\\-  #\\.  #\\/
  060 - 071     #\\0  #\\1  #\\2  #\\3  #\\4  #\\5  #\\6  #\\7  #\\8  #\\9
  072 - 100     #\\:  #\\;  #\\<  #\\=  #\\>  #\\?  #\\@
  101 - 132     #\\A ... #\\Z
  133 - 140     #\\[  #\\\\  #\\]  #\\^  #\\_  #\\`
  141 - 172     #\\a ... #\\z
  173 - 177     #\\{  #\\|  #\\}  #\\~~  #\\Rubout
Some versions of ECL support additional characters to represent Japanese
character set.")

(docfun character function (x) "
Coerces X into a character if possible.  Signals an error if not possible.")

(docfun characterp function (x) "
Returns T if X is a character; NIL otherwise.")

(docfun ext:getcwd function (&optional (update-lisp t)) "
Returns the current working directory of the C library. When UPDATE-LISP is
true, *DEFAULT-PATHNAME-DEFAULTS* is set to this value.")

(docfun ext:chdir function (filespec &optional (update-lisp t)) "
Changes the current working directory of the C library to the one specified by
FILESPEC.  FILESPEC may be a symbol, a string, or a pathname. UPDATE-LISP
determines whether the value of *DEFAULT-PATHNAME-DEFAULTS* is also to be
changed.")

(docfun clear-input function (&optional (stream *standard-input*)) "
Clears the input buffer of STREAM and returns NIL.  Contents of the buffer are
discarded.")

(docfun clear-output function (&optional (stream *standard-output*)) "
Clears the output buffer of STREAM and returns NIL.  Contents of the buffer
are discarded.")

(docfun ffi:clines special (&body c-strings) "
Syntax: (clines {string}*)
The ECL compiler embeds STRINGs into the intermediate C language code.  The
interpreter ignores this form.")

#|| eliminated. Beppe
(docfun cdeclaration macro "(cdeclaration {string}*)" "
ECL specific.
The ECL compiler embeds STRINGs into the intermediate H language code.
The interpreter ignores this form.")

(docfun cinitialization macro "(cinitialization {string}*)" "
ECL specific.
The ECL compiler embeds STRINGs into the intermediate C language init_code
function. This allows to perform initialization operations when the binary
file is loaded.
The interpreter ignores this form.")
||#

(docfun close function (stream &key (abort nil)) "
Closes STREAM.  Returns NIL if STREAM is closed successfully; non-NIL
otherwise.  A non-NIL value of ABORT indicates an abnormal termination but ECL
ignores it.")

(docfun clrhash function (hash-table) "
Removes all entries of HASH-TABLE and returns HASH-TABLE.")

(docfun code-char function (code &optional (bits 0) (font 0)) "
Returns a character with the specified character code, if any.  Returns NIL
if no such character exists.  BITS and FONT specify the bits and font
attributes of the returned character but are both ignored in ECL.")

(doctype common "
COMMON is the type of all Common Lisp data objects.")

(docfun commonp function (x) "
Returns T if X is a Common Lisp object; NIL otherwise.")

(doctype compiled-function "
A compiled function is an object that is created by compiling a function.  A
compiled function is notated in either of the following formats:
        #<compiled-function s>
        #<compiled-closure nil>
where S is actually the symbol that names the function.")

(docfun si::compiled-function-name function (compiled-function) "
ECL specific.
Returns the function name associated with COMPILED-FUNCTION.")

(docfun compiled-function-p function (x) "
Returns T if X is a compiled function object; NIL otherwise.")

(docfun compiler-let special (bindings &body forms)
        "Syntax: (compiler-let ({var | (var [value])}*) {form}*)

When interpreted, this form works just like a LET form with all VARs declared
special.  When compiled, FORMs are processed with the VARs bound at compile
time, but no bindings occur when the compiled code is executed.")

(doctype complex "
A complex number represents a complex number in mathematical sense, consisting
of a real part and an imaginary part.  A complex number is notated as
        #c( realpart  imagpart )  or  #C( realpart  imagpart )
where REALPART and IMAGPART are non-complex numbers.")

(docfun complex function (realpart &optional (imagpart 0)) "
Returns a complex number with the given realpart and imagpart.  Returns
REALPART if it is a rational and IMAGPART is 0.")

(docfun complexp function (x) "
Returns T if X is a complex number; NIL otherwise.")

(docfun conjugate function (number) "
Returns the complex conjugate of NUMBER.  Returns NUMBER if it is not a
complex number.")

(doctype cons "
A cons is a compound object consisting of two components car and cdr.")

(docfun cons function (x y) "
Returns a new cons whose car and cdr are X and Y respectively.")

(docfun consp function (x) "
Returns T if X is a cons; NIL otherwise.")

(docfun constantp function (x) "
Returns T if ECL is sure that X, when given as a form, always evaluates to a
same value.  Returns NIL otherwise.  Typically used to check whether a symbol
names a constant variable.")

(docfun copy-alist function (alist) "
Returns a new list consisting of copies of all pairs in ALIST.")

(docfun copy-list function (list) "
Returns a new list consisting of all elements in LIST.")

(docfun copy-readtable function (&optional (readtable *readtable*) (to-readtable nil)) "
Returns a new copy of READTABLE.  If TO-READTABLE is non-NIL, then copies the
contents of READTABLE into TO-READTABLE and returns TO-READTABLE.")

(docfun copy-seq function (sequence) "
Returns a new copy of SEQUENCE.")

(docfun copy-symbol function (symbol &optional (flag nil)) "
Returns a new uninterned symbol with the same print name as SYMBOL.  If FLAG
is NIL, the symbol property of the new symbol is empty.  Otherwise, the new
symbol gets a copy of the property list of SYMBOL.")

(docfun copy-tree function (tree) "
Returns a copy of TREE.  Defined as:
        (defun copy-tree (tree)
          (if (atom tree)
              tree
              (cons (copy-tree (car tree)) (copy-tree (cdr tree)))))")

(docfun cos function (radians) "
Returns the cosine of RADIANS.")

(docfun cosh function (number) "
Returns the hyperbolic cosine of NUMBER.")

(docfun count function (item sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil)) "
Returns the number of elements in SEQUENCE satisfying TEST with ITEM as the
first argument.")

(docfun count-if function (test sequence
       &key (key '#'identity)
            (start 0) (end (length sequence)) (from-end nil)) "
Returns the number of elements in SEQUENCE satisfying TEST.")

(docfun count-if-not function (test sequence
            (start 0) (end (length sequence)) (from-end nil)) "
Returns the number of elements in SEQUENCE not satisfying TEST.")

(docfun declare special (&rest declaration-specifiers)
"Syntax: (declare {decl-spec}*)

Gives declarations.  Possible DECL-SPECs are:
  (SPECIAL {var}*)
  (TYPE type {var}*)
  (type {var}*) where 'type' is one of the following symbols
        array           fixnum          package         simple-string
        atom            float           pathname        simple-vector
        bignum          function        random-state    single-float
        bit             hash-table      ratio           standard-char
        bit-vector      integer         rational        stream
        character       keyword         readtable       string
        common          list            sequence        string-char
        compiled-function  long-float   short-float     symbol
        complex         nil             signed-byte     t
        cons            null            simple-array    unsigned-byte
        double-float    number          simple-bit-vector  vector
  (OBJECT {var}*)
  (FTYPE type {function-name}*)
  (FUNCTION function-name ({arg-type}*) {return-type}*)
  (INLINE {function-name}*)
  (NOTINLINE {function-name}*)
  (IGNORE {var}*)
  (OPTIMIZE {({SPEED | SPACE | SAFETY | COMPILATION-SPEED} {0 | 1 | 2 | 3})}*)
  (DECLARATION {non-standard-decl-name}*)
  (:READ-ONLY {variable-name}*).")

(docfun decode-float function (float) "
Returns the significand F, the exponent E, and the sign S of FLOAT.  These
values satisfy
        1/B <= F < 1
and                      E
        FLOAT = S * F * B
where B is the radix used to represent FLOAT.  S and F are floats of the same
float format as FLOAT, and E is an integer.")

(docfun defun macro (name lambda-list &body)
        "Syntax: (defun name lambda-list {decl | doc}* {form}*)
Defines a global function named by NAME.
The complete syntax of a lambda-list is:
        ({var}*
         [&optional {var | (var [init [svar]])}*]
         [&rest var]
         [&key {var | ({var | (keyword var)} [init [svar]])}*
               [&allow-other-keys]]
         [&aux {var | (var [init])}*])
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (documentation 'NAME 'function).")

(docfun defmacro macro (name lambda-list &body body)
"Syntax: (defmacro name defmacro-lambda-list {decl | doc}* {form}*)
Defines a global macro named by NAME.  The complete syntax of DEFMACRO-LAMBDA-
LIST is:
        ( [&whole var] [&environment var] . pvar )
where PVAR may be a symbol,
        ( {pvar}* [&optional {var | (pvar [init [pvar]])}*] . var )
or
        ( {pvar}*
          [&optional {var | (pvar [init [pvar]])}*]
          [{&rest | &body} pvar]
          [&key {var | ({var | (keyword pvar)} [init [pvar]])}*
                [&allow-other-keys]]
          [&aux {var | (pvar [init])}*] )
The doc-string DOC, if supplied, is saved as a FUNCTION doc and can be
retrieved by (documentation 'NAME 'function).  See LIST for the backquote
macro useful for defining macros.")

(docfun delete function (item sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive REMOVE.  SEQUENCE may be destroyed.")

(docfun delete-file function (filespec) "
Deletes the specified file.  FILESPEC may be a symbol, a string, a pathname,
or a file stream.")

(docfun delete-if function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive REMOVE-IF.  SEQUENCE may be destroyed")

(docfun delete-if-not function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive REMOVE-IF-NOT.  SEQUENCE may be destroyed")

(docfun denominator function (rational) "
Returns the denominator of RATIONAL as a positive integer, if RATIONAL is a
ratio.  Returns RATIONAL if it is an integer.")

(docfun digit-char function (digit &optional (n 10) (font 0)) "
Returns a character that represents the DIGIT in radix N.  Returns NIL if no
such character exists.")

(docfun digit-char-p function (char &optional (n 10)) "
If CHAR represents a digit in radix N, then returns an integer represented by
that digit.  Otherwise, returns NIL.")

(docfun directory function (filespec &key (resolve-symlinks T)) "
Returns a list of full pathnames of all those files that match
FILESPEC.  FILESPEC may be a symbol, a string, a pathname, or a file
stream. If RESOLVE-SYMBOLS set to NIL then it doesn't follow
symlinks.")

(docfun directory-namestring function (filespec) "
Returns as a string the directory part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.")

(docfun si::displaced-array-p function (array) "
ECL specific.
Returns T if the ARRAY is displaced to another array; NIL otherwise.")

(docfun do macro (bindings (test &optional result) &body forms)
        "Syntax: (do ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Establishes a NIL block, binds each VAR to the value of the corresponding INIT
(which defaults to NIL), and then executes STATEMENTs repeatedly until TEST is
satisfied.  After each iteration, evaluates STEP and assigns the value to the
corresponding VAR.  No assignment occurs for those VARs to which STEP is not
given.  When TEST is satisfied, evaluates RESULTs as a PROGN and returns all
values of the last RESULT.  Performs variable bindings and assignments in
parallel, just as LET and PSETQ do.")

(docfun do* macro (bindings (test &optional result) &body forms)
        "Syntax: (do* ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)

Similar to DO, but performs variable bindings and assignments in serial, just
as LET* and SETQ do.")

(docfun dolist macro ((var form &optional result) &body forms)
        "Establishes a NIL block and executes STATEMENTs once for each member of the
list value of FORM, with VAR bound to the member.  Then evaluates RESULT
(which defaults to NIL) and returns all values.")

(doctype double-float "
A double-float is a double-precision floating point number.
DOUBLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL.")

(docfun dotimes macro ((var form &optional result) &body forms)
        "Establishes a NIL block and executes STATEMENTs once for each integer between
0 (inclusive) and the value of FORM (exclusive), with VAR bound to the
integer.  Then evaluates RESULT (which defaults to NIL) and returns all
values.")

(docfun eighth function (x) "
Equivalent to (CADDDR (CDDDDR X)).")

(docfun elt function (sequence n) "
Returns the N-th element of SEQUENCE.")

(docfun endp function (x) "
Returns T if X is NIL.  Returns NIL if X is a cons.  Otherwise, signals an
error.")

(docfun enough-namestring function (filespec &optional (defaults *default-pathname-defaults*)) "
Returns a string which uniquely identifies the file specified by FILESPEC,
with respect to DEFAULTS.  FILESPEC and DEFAULTS may be a symbol, a string, a
pathname, or a file stream.")

(docfun eq function (x y) "
Returns T if the args are identical; NIL otherwise.")

(docfun eql function (x y) "
Returns T if the args satisfy one of the following conditions.
        1. identical
        2. are numbers of the same type with the same value
        3. are characters that represent the same character
Returns NIL otherwise.")

(docfun equal function (x y) "
Returns T if the args satisfy one of the following conditions.
        1. EQL
        2. are conses with EQUAL cars and EQUAL cdrs
        3. are strings of the same length and element-wise EQL
        4. are bit-vectors of the same length and element-wise EQL
        5. are pathnames with EQUAL slots
Returns NIL otherwise.")

(docfun equalp function (x y) "
Returns T if the args satisfy one of the following conditions.
        1. EQUAL
        2. are characters that satisfy CHARACTER-EQUAL
        3. are numbers that satisfy =
        4. are conses with EQUALP cars and EQUALP cdrs
        5. are arrays of the same dimensions and element-wise EQUALP
Returns NIL otherwise.")

(docfun error function (format-string &rest args) "
Signals an error.  The args are FORMATed to *error-output*.")

(docfun eval function (form) "
Evaluates FORM and returns all values.")

(docfun eval-when special ((&rest situation) &body forms) "
Specifies when to evaluate FORMs.  Each SITUATION must be one of the following
symbols.
        COMPILE (compile-time)
        LOAD    (load-time of the fasl file)
        EVAL    (load-time of the source file)")

(docfun evalhook function (form fun1 fun2 &optional (env nil)) "
Evaluates FORM with *EVALHOOK* bound to FUN1 and *APPLYHOOK* bound to FUN2,
and returns all the values.")

(docfun evenp function (integer) "
Returns T if INTEGER is an even number; NIL otherwise.")

(docfun exp function (number) "
Returns E raised to the power NUMBER, where E is the base of natural
logarithms.")

(docfun export function (symbol &optional (package *package*)) "
Register SYMBOL as an external symbol of PACKAGE.  SYMBOL may be a list of
symbols.")

(docfun expt function (number1 number2) "
Returns NUMBER1 raised to the power NUMBER2.")

(docfun fboundp function (symbol) "
Returns T if SYMBOL names a special form, a global macro, or a global
function.  Returns NIL otherwise.")

(docfun fifth function (x) "
Equivalent to (CAR (CDDDDR X)).")

(docfun file-author function (filespec) "
Returns the author of the specified file, as a string.  Returns NIL if the
author is unknown.  FILESPEC may be a symbol, a string, a pathname, or a file
stream.")

(docfun file-length function (file-stream) "
Returns the length of the specified FILE-STREAM.  Returns NIL if the length is
unknown.")

(docfun file-namestring function (filespec) "
Returns as a string the name, type, and version parts of the specified
pathname.  FILESPEC may be a symbol, a string, a pathname, or a file stream.")

(docfun file-position function (file-stream &optional file-position) "
With one arg, returns the current position of FILE-STREAM's file pointer as a
non-negative integer.  Returns NIL if the position is unknown.  With two args,
resets the file pointer and returns T.  Returns NIL if the file pointer cannot
be reset.  FILE-POSITION may be a non-negative integer, :START, or :END.")

(docfun file-write-date function (filespec) "
Returns an integer that represents the last write day-and-time of the
specified file (See GET-DECODED-TIME).   Returns NIL if the last write day-
and-time is unknown.  FILESPEC may be a symbol, a string, a pathname, or a
file stream.")

(docfun fill function (sequence item &key (start 0) (end (length sequence))) "
Replaces the specified elements of SEQUENCE with ITEM.")

(docfun fill-pointer function (vector) "
Returns the fill-pointer of VECTOR as an integer.  VECTOR must have a fill-
pointer.")

(docfun find function (item sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil)) "
Returns the first element in SEQUENCE satisfying TEST with ITEM.  Returns NIL
if no such element exists.")

(docfun find-if function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence)) (from-end nil)) "
Returns the index of the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.")

(docfun find-if-not function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence)) (from-end nil)) "
Returns the index of the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.")

(docfun find-package function (name) "
Returns the package whose package name or nickname is NAME.  Returns NIL if no
such package exists.  NAME may be a string or a symbol.")

(docfun find-symbol function (string &optional (package *package*)) "
Searches PACKAGE for a symbol whose print name is NAME.  If such a symbol is
found, then returns the symbol as the first value and returns one of the
following symbols as the second value.
        :INTERNAL (internal symbol in PACKAGE)
        :EXTERNAL (external symbol in PACKAGE)
        :INHERITED (external symbol of a package that PACKAGE is using)
If no such symbol is found, returns NIL as the first and second values.")

(docfun finish-output function (&optional (stream *standard-output*)) "
Sends the contents of the output buffer for STREAM to the destination.  Waits
until the buffer becomes empty and then returns NIL.")

(docfun first function (x) "
Equivalent to CAR.")

(docfun si::fixnump function (x) "
ECL specific.
Returns T if the X is a fixnum; NIL otherwise.")

(docfun flet special ((&rest functions) &body forms) "
Introduces local functions and evaluates BODY as a PROGN.  BODY is the scope
of each local function but the local function definitions are not.  Thus each
local function can reference externally defined functions of the same name as
local functions.  Doc-strings for local functions are simply ignored.")

(doctype float "
A float (floating-point number) represents a real number or its approximation.
ECL supports two formats for floats.  One format is called SHORT-FLOAT and the
other format is called SINGLE-FLOAT, DOUBLE-FLOAT, or LONG-FLOAT.  Precisions
and exponent sizes of floats depends on the version of ECL.  See the ECL
Report at your hand for details.
The following syntax is used to notate a float.
        [+ | -] {digit}* . {digit}+ [exp]
        [+ | -] {digit}+ [. {digit}*}] exp
where DIGIT is a decimal digit (0,..,9) and EXP is
        marker [+ | -] {digit}+
with one of the following marker.
        e or E  the default float format
        s or S  short-float
        f or F  single-float
        d or D  double-float
        l or L  long-float
The default float format is single-float normally, but may be any other float
format.  See *READ-DEFAULT-FLOAT-FORMAT*.")

(docfun float function (number &optional float) "
With one arg, converts NUMBER to a single-float.  With two args, converts
NUMBER to a float of the same float format as FLOAT.")

(docfun float-digits function (float) "
Returns the number of radix-B digits used to represent the significand of
FLOAT, where B is the base number used in the representation of FLOAT.")

(docfun float-precision function (float) "
Returns the number of effective radix-B digits in the representation of the
significand of FLOAT, where B is the base number used in the representation
of FLOAT.")

(docfun float-radix function (float) "
Returns the base number used in the representation of FLOAT.")

(docfun float-sign function (float1 &optional (float2 (float 1 float1))) "
Returns a float with the same sign as FLOAT1 and with the same absolute value
as FLOAT2.")

(docfun floatp function (x) "
Returns T if X is a float; NIL otherwise.")

(docfun floor function (number &optional (divisor 1)) "
Returns the largest integer not larger than the NUMBER divided by DIVISOR.
Returns the value of (- NUMBER (* first-value DIVISOR)) as the second value.")

(docfun fmakunbound function (symbol) "
Removes the global function definition associated with SYMBOL.  Returns SYMBOL.")

(docfun force-output function (&optional (stream *standard-output*)) "
Sends the contents of the output buffer for STREAM to the destination.
Returns NIL without waiting until the buffer becomes empty.")

(docfun format function (destination format-string &rest args) "
Outputs ARGs to DESTINATION in the format specified by FORMAT-STRING.  FORMAT-
STRING is a string consisting of characters to output and format directives
which begin with '~~'.  Outputs to DESTINATION if it is a stream and to the
standard output if DESTINATION is T.  If DESTINATION is NIL, does not output
actually but returns the output as a string.  Here are some format directives:
        ~~A     PRINCs one arg
        ~~S     PRIN1s one arg
        ~~D     Prints one integer in decimal
        ~~B     Prints one integer in binary
        ~~O     Prints one integer in octal
        ~~X     Prints one integer in hexa
        ~~%     Does TERPRI
        ~~&     Does FRESH-LINE
        ~~|     Outputs #\\Page
        ~~~~    Outputs '~~'")

(docfun fourth function (x) "
Equivalent to CADDDR.")

(docfun fresh-line function (&optional (stream *standard-output*)) "
Outputs a newline character only if the current position of STREAM is not at
the beginning of a line.  Returns T if it outputs a newline; NIL otherwise.")

(docfun si::frs-bds function (n) "
ECL specific.
Returns the bind stack index of the N-th entity in the frame stack.")

(docfun si::frs-ihs function (n) "
ECL specific.
Returns the invocation history stack index of the N-th entity in the frame
stack.")

(docfun funcall function (function &rest args) "
Calls FUNCTION with the ARGs as the arguments and returns all values that the
call returns.")

(doctype function "
A function object specifies a function to be invoked by function-calling
functions such as FUNCALL or APPLY.  A function is either:
        1. a compiled function
        2. a list of one of the following form
                (lambda lambda-list . body)
                (lambda-block block-name lambda-list . body)
                (lambda-closure env1 env2 env3 lambda-list . body)
                (lambda-block-closure env1 env2 env3 block-name lambda-list
                                      . body)
           where ENV1, ENV2, and ENV3 respectively represent the variable
           environment, the function/macro environment, and the block/tagbody
           environment at the time of the function creation.
        3. a symbol that names a global function.")

(docfun function special (function-name) "
If X is a lambda expression, (function x) creates and returns a lexical closure
of X in the current lexical environment.  If X is a symbol that names a function,
returns that function definition.")

(docfun functionp function (x) "
Returns T if X is an object that can be used to specify a function to be
invoked by function-calling functions such as FUNCALL or APPLY.  Returns NIL
otherwise.")

(docfun gc function (x) "
ECL specific.
Starts garbage collection with the specified collection level.  If X is NIL,
collects only cells.  If X is T, collects everything.")

#-boehm-gc
(docfun si::gc-time function () "
ECL specific.
Returns the amount of time (in 1/100 seconds) spent during garbage collection.")

(docfun gcd function (&rest integers) "
Returns the greatest common divisor of the args.")

(docfun gensym function (&optional (x nil)) "
Creates and returns a new uninterned symbol whose print name begins with some
prefix (initially \"G\"), followed by a generation number.  The generation
number is incremented by one at each call to GENSYM.  If X is an integer, it
becomes the new generation number.  If X is a string, it becomes the new
prefix.")

(docfun gentemp function (&optional (string \"T\") (package *package*)) "
Creates a new symbol interned in PACKAGE with PREFIX and returns the symbol.
The symbol is given a print name beginning with PREFIX followed by some
generation number.")

(docfun get function (symbol property &optional (default nil)) "
Searches the symbol property of SYMBOL for a property that is EQ to PROPERTY.
If found, returns the value of the property.  Otherwise, returns DEFAULT.")

(docfun get-dispatch-macro-character function (char subchar &optional (readtable *readtable*)) "
Returns the read macro for SUBCHAR associated with the dispatch macro
character CHAR in READTABLE.")

#-boehm-gc
(docfun si::get-hole-size function () "
ECL specific.
Returns as a fixnum the size of the memory hole (in pages).")

(docfun get-internal-real-time function () "
Returns the time (in 1/100 seconds) since the invocation of ECL.")

(docfun get-internal-run-time function () "
Returns the CPU time (in 1/100 seconds) since the invocation of ECL.")

(docfun get-macro-character function (char &optional (readtable *readtable*)) "
Returns the read macro associated with the macro character CHAR in READTABLE.
Returns the non-terminating-p flag (see READTABLE) as the second value.
Returns NIL if CHAR is not a macro character.")

(docfun get-output-stream-string function (string-output-stream) "
Returns as a string all outputs to STRING-OUTPUT-STREAM since the last call of
GET-OUTPUT-STREAM-STRING for the same stream.")

(docfun get-properties function (plist list) "
Searches PLIST for a property that is EQ to one of the members of LIST.
Returns three values.  If such a property if found, returns the property, the
value of the property, and the rest of LIST.  If not, returns three NILs.")

(docfun get-universal-time function () "
Returns the current day-and-time as an integer.  See DECODE-UNIVERSAL-TIME.")

(docfun ext:getenv function (string) "
ECL/UNIX specific.
Returns the environment with the name STRING as a string.  Returns NIL, if the
specified environment is not found.")

(docfun getf function (plist property &optional (default nil)) "
Searches PLIST for a property that is EQ to PROPERTY.  If one is found,
returns the value of the property.  If not, returns DEFAULT.
The SETF form
        (setf (getf place property-form) value-form)
replaces the property value of the plist stored in PLACE, or adds a new
property if the plist does not have the property yet.")

(docfun gethash function (key hash-table &optional (default nil)) "
Searches HASH-TABLE for the entry of KEY.  If found, returns the value of the
entry and T, as two values.  If not, returns DEFAULT and NIL.")

#+clos
(docfun si::gfun-instance function (gfun) "
ECL/CLOS specific.
Returns the generic function instance associated with the GFUN
generic function object.")

#+clos
(docfun si::gfun-instance-set function (gfun instance) "
ECL/CLOS specific.
Sets to INSTANCE the generic function instance associated with the
FUN generic function object.")

#+clos
(docfun si::gfun-name function (gfun) "
ECL/CLOS specific.
Returns the name of the GFUN generic function object.")

#+clos
(docfun si::gfun-name-set function (gfun name) "
ECL/CLOS specific.
Sets to NAME the name of the GFUN generic function object.")

#+clos
(docfun si::gfun-method-ht function (gfun) "
ECL/CLOS specific.
Returns the hashtable for caching methods associated with the GFUN
generic function object.")

#+clos
(docfun si::gfun-method-ht-set function (gfun hash-table) "
ECL/CLOS specific.
Sets to HASH-TABLE the hashtable for caching methods associated with the
GFUN generic function object.")

#+clos
(docfun si::gfun-spec-how-ref function (gfun index) "
ECL/CLOS specific.
Returns the INDEX-th element of specialization list associated  with the
GFUN generic function object. The first element has INDEX equal to zero.")

#+clos
(docfun si::gfun-spec-how-set function (gfun index specializer) "
ECL/CLOS specific.
Sets to SPECIALIZER the INDEX-th element of specialization list associated
with the GFUN generic function object. The first element has INDEX
equal to zero.")

#+clos
(docfun si::gfunp function (object) "
ECL/CLOS specific.
Returns T if OBJECT is of gfun type.")

(docfun go special (tag) "
Jumps to TAG.  See TAGBODY.")

(docfun graphic-char-p function (char) "
Returns T if CHAR is a printing character, i.e., a standard character other
than #\\Newline.  Returns NIL otherwise.")

(doctype hash-table "
A hash-table is a table used to map from objects to objects efficiently by the
hashing technique.  A hash-table is notated as
        #<hash-table n>
where N is actually a number that identifies the hash-table.")

(docfun hash-table-count function (hash-table) "
Returns the number of entries in HASH-TABLE.")

(docfun hash-table-p function (x) "
Returns T if X is a hash-table object; NIL otherwise.")

(docfun host-namestring function (filespec) "
Returns as a string the host part of the pathname specified by FILESPEC.
FILESPEC may be a symbol, a string, a pathname, or a file stream.")

(docfun identity function (x) "
Returns X.")

(docfun if special (test true-form &optional false-form) "
If TEST evaluates to non-NIL, then evaluates FORM1 and returns all values.
Otherwise, evaluates FORM2 (which defaults to NIL) and returns all values.")

(docfun si::ihs-fun function (n) "
ECL specific.
Returns the function value of the N-th entity in the invocation history stack.")

(docfun imagpart function (number) "
Returns the imagpart of NUMBER if it is a complex.  Otherwise, returns zero of
the same type as NUMBER.")

(docfun import function (symbol &optional (package *package*)) "
Registers SYMBOL to PACKAGE as an internal symbol.  Does nothing if SYMBOL is
already registered in PACKAGE.  SYMBOL may be a list of symbols.")

(docfun in-package function (package-name &key (nicknames nil) (use '(lisp))) "
Makes the package named PACKAGE-NAME as the current package.  If such a
package does not exist, then creates one by passing all args to MAKE-PACKAGE.
Otherwise, adds the specified nicknames and packages to the nickname list and
use list of the package.  NICKNAMES must be a list consisting of strings and
symbols.  USE must be a list consisting of package objects and package names
(either string or symbol).")

(docfun input-stream-p function (stream) "
Returns T if STREAM can handle input operations; NIL otherwise.")

#+clos
(docfun si::instancep function (object) "
ECL/CLOS specific.
Returns T if OBJECT is of instance type.")

#+clos
(docfun si::instance-ref function (instance index) "
ECL/CLOS specific.
Returns the value of the INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.")

#+clos
(docfun si::instance-set function (instance index value) "
ECL/CLOS specific.
Sets to VALUE the value of INDEX-th slot of INSTANCE. The first slot has
INDEX equal to zero.")

#+clos
(docfun si::instance-class function (instance) "
ECL/CLOS specific.
Returns the class of which the given INSTANCE is an instance.")

#+clos
(docfun si::instance-class-set function (instance class) "
ECL/CLOS specific.
Makes INSTANCE an instance of CLASS class.")

(docfun int-char function (integer) "
Equivalent to CODE-CHAR.")

(doctype integer "
An integer object represents an integer in mathematical sense.  An integer may
be a fixnum, or else it is a bignum.  Normally, an integer is notated in radix
10 (see *PRINT-BASE* and *READ-BASE*) as
        [sign] {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
        # radix {r | R} [sign] {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
        Digits in radix 2 are '0' and '1'
        Digits in radix 8 are '0', ..., '7'
        Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
        # {b | B} [sign] {digit}+
        # {o | O} [sign] {digit}+
                  [sign] {digit}+ .
        # {x | X} [sign] {digit}+")

(docfun integer-decode-float function (float) "
Returns, as three values, the integer interpretation of significand F, the
exponent E, and the sign S of FLOAT, such that
        FLOAT = S * F * B^E
where B = (float-radix FLOAT).  F is a non-negative integer, E is an integer,
and S is either 1 or -1.")

(docfun integer-length function (integer) "
Returns the number of \"significant bits\" in the representation of INTEGER.
With positive arg, returns one plus the position of the most significant bit
that is 'on'.  With negative arg other than -1, returns one plus the position
of the most significant bit that is 'off'.  For 0 and -1, returns 0.")

(docfun integerp function (x) "
Returns T if X is an integer; NIL otherwise.")

(docfun intern function (string &optional (package *package*)) "
Searches PACKAGE for a symbol whose print name is STRING.  If such a symbol is
found, returns the symbol and, as the second value, one of the keywords
:INTERNAL, :EXTERNAL, and :INHERITED.  Otherwise, creates and returns a new
symbol and, as the second value, returns NIL.")

(docvar internal-time-units-per-second constant "
Gives the time unit used by GET-INTERNAL-REAL-TIME and GET-INTERNAL-RUN-TIME.
1000 in ECL.")

(doctype keyword "
A keyword is a symbol in the keyword package.")

(docfun keywordp function (x) "
Returns T if X is a symbol that belongs to the KEYWORD package; NIL otherwise.")

(docfun labels special ((&rest functions) &body forms) "
Introduces local functions and evaluates BODY as a PROGN.  The scope of each
local function include the local function definitions.  Thus self- and mutual-
recursive local functions can be defined.  Doc-strings for local functions are
simply ignored.")

(docvar lambda-list-keywords constant "
List of all lambda-list keywords, including
        &optional       &rest           &key
        &allow-other-keys               &aux
        &whole          &environment    &body")

(docvar lambda-parameters-limit constant "
The upper bound of the number of parameters specified by a lambda list.
Ignore this number; there is no such upper bound in ECL.")

(docfun last function (list) "
Returns the last cons that constitute LIST.  Returns NIL if LIST is NIL.")

(docfun lcm function (integer &rest more-integers) "
Returns the least common multiple of the args.  Returns 0 if at least one of
the args is 0.")

(docfun ldiff function (list x) "
If X is a cons that constitutes LIST, then returns a new list consisting of
those elements of LIST that appear before X.  Otherwise, returns a copy of
LIST.")

(docvar least-negative-double-float constant "
Same as LEAST-NEGATIVE-LONG-FLOAT.")

(docvar least-negative-long-float constant "
The negative long-float with the smallest absolute value.")

(docvar least-negative-short-float constant "
The negative short-float with the smallest absolute value.")

(docvar least-negative-single-float constant "
Same as LEAST-NEGATIVE-LONG-FLOAT.")

(docvar least-positive-double-float constant "
Same as LEAST-POSITIVE-LONG-FLOAT.")

(docvar least-positive-long-float constant "
The smallest positive long-float.")

(docvar least-positive-short-float constant "
The smallest positive short-float.")

(docvar least-positive-single-float constant "
Same as LEAST-POSITIVE-LONG-FLOAT.")

(docfun length function (sequence) "
Returns the length of SEQUENCE.")

(docfun let special ((&rest bindings) &body body) "
Evaluates all INITs (which defaults to NIL), binds the value of each INIT to
the corresponding VAR, evaluates FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.")

(docfun let* special ((&rest bindings) &body body) "
Evaluates INIT (which defaults to NIL) and binds the value to the
corresponding VAR, one by one for each pair of VAR and INIT.  Then evaluates
FORMs and returns all values of the last FORM.  Returns NIL if no FORM is
given.")

(docfun list function (&rest args) "
Returns a list of the args.")

(docfun list* function (arg &rest more-args) "
With one arg, simply returns it.  With n args (n > 1), conses the first arg to
the LIST* of the rest of args.")

(docfun list-all-packages function () "
Returns a list of all packages.")

(docfun list-length function (list) "
Returns the length of LIST.  Returns NIL if LIST is circular.")

(docfun listen function (&optional (stream *standard-input*)) "
Returns T if STREAM is ready to input a character from; NIL otherwise.  In
some versions of ECL, this function does not work correctly because the
underlying OS does not support such a mechanism.")

(docfun listp function (x) "
Returns T if X is either a cons or NIL.  Otherwise, returns NIL.")

(docfun load function (filespec
       &key (verbose *load-verbose*) (print nil) (if-does-not-exist :error)) "
Loads the contents of the specified file into ECL.
If the filetype is not specified, ECL first tries to load the fasl file with
filetype \".fasl\", then tries to load the source file with filetype \".lsp\",
and then tries to load the source file with no filetype.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  VERBOSE
specifies whether or not the loader prints a loading message.  PRINT specifies
whether or not the loader prints the values of the top-level forms.
IF-DOES-NOT-EXIST specifies the behavior of the loader when the specified file
is not found.  It may be :ERROR or NIL.
If the file was loaded successfully, returns the pathname of the file actually
loaded")

(docfun locally macro (&body forms) "
Gives DECLs locally while evaluating FORMs, and returns all values of the last
FORM.  Returns NIL if no FORM is given.")

(docfun log function (number1 &optional number2) "
With two args, returns the logarithm of NUMBER1 in base NUMBER2.  With one
arg, returns the natural logarithm of the arg.")

(docfun logand function (&rest integers) "
Returns the bit-wise AND of the args.")

(docfun logandc1 function (integer1 integer2) "
Equivalent to (LOGAND (LOGNOT INTEGER1) INTEGER2).")

(docfun logandc2 function (integer1 integer2) "
Equivalent to (LOGAND INTEGER1 (LOGNOT INTEGER2)).")

(docfun logbitp function (bit-position integer) "
Returns T if the specified bit of INTEGER is 1; NIL otherwise.  BIT-POSITION
must be a non-negative integer, with 0 representing the least significant bit.")

(docfun logcount function (integer) "
If INTEGER is negative, returns the number of 0 bits.  Otherwise, returns the
number of 1 bits.")

(docfun logeqv function (&rest integers) "
Returns the bit-wise EQUIVALENCE of the args.")

(docfun logior function (&rest integers) "
Returns the bit-wise INCLUSIVE OR of the args.")

(docfun lognand function (integer1 integer2) "
Equivalent to (LOGNOT (LOGAND INTEGER1 INTEGER2)).")

(docfun lognor function (integer1 integer2) "
Equivalent to (LOGNOT (LOGIOR INTEGER1 INTEGER2)).")

(docfun lognot function (integer) "
Returns the bit-wise logical NOT of the arg.")

(docfun logorc1 function (integer1 integer2) "
Equivalent to (LOGIOR (LOGNOT INTEGER1) INTEGER2).")

(docfun logorc2 function (integer1 integer2) "
Equivalent to (LOGIOR INTEGER1 (LOGNOT INTEGER2)).")

(docfun logxor function (&rest integers) "
Returns the bit-wise EXCLUSIVE OR of the args.")

(doctype long-float "
A long-float is a long-precision floating point number.")

(docfun lower-case-p function (char) "
Returns T if CHAR is a lower-case character; NIL otherwise.")

(docfun macro-function function (symbol) "
Returns the expansion function of the global macro named SYMBOL.  Returns NIL
if no such macro exists.  The expansion function receives a macro form and an
environment, and returns the expanded form.")

(docfun macroexpand function (form &optional (env nil)) "
If FORM is a macro form, then expands it repeatedly until the result is not a
macro any more, and returns the result as the first value and T as the second
value.  Otherwise, returns FORM and NIL as two values.")

(docfun macroexpand-1 function (form &optional (env nil)) "
If FORM is a macro form, then expands it once and returns the result as the
first value and T as the second value.  Otherwise, returns FORM and NIL as two
values.")

(docfun macrolet special ((&rest macros) &body forms)
"Syntax: (macrolet ({(name defmacro-lambda-list {decl | doc}* {form}*)}*)
          . body)
Introduces local macros and evaluates BODY as a PROGN.  See DEFMACRO for the
complete syntax of defmacro-lambda-list.  Doc-strings for local macros are
simply ignored.")

(docfun make-broadcast-stream function (&rest streams) "
Creates and returns a broadcast stream.  Outputs to this stream are output to
all STREAMs.  A broadcast stream is notated as
        #<broadcast stream n>
where N is a number that identify the stream.")

(docfun make-char function (char &optional (bits 0) (font 0)) "
Returns a character object with the same code as CHAR and with the specified
BITS and FONT attributes.  Returns NIL if no such character exists.")

(docfun make-concatenated-stream function (&rest streams) "
Creates and returns a concatenated stream.  Inputs from this stream are first
obtained from the first STREAM.  When the end of the first STREAM is reached,
then inputs are obtained from the second STREAM.  And so forth.
A concatenated stream is notated as
        #<concatenated stream n>
where N is a number that identifies the stream.")

(docfun make-dispatch-macro-character function (char &optional (non-terminating-p nil) (readtable *readtable*)) "
Register CHAR as a dispatch macro character in READTABLE.  NON-TERMINATING-P
specifies whether CHAR is non-terminating (see READTABLE).")

(docfun make-echo-stream function (stream1 stream2) "
Creates and returns an echo stream.  Inputs from this stream are obtained from
STREAM1 and outputs to this stream are output to STREAM2.  In addition, all
inputs from STREAM1 are output to STREAM2.
An echo stream is notated as
        #<echo stream n>
where N is a number that identifies the stream.")

(docfun make-hash-table function (&key (test 'eql) (size 1024) (rehash-size 1.5) (rehash-threshold 0.7)) "
Creates and returns a hash-table.
TEST specifies which predicate should be used to access hash-table entries.
It must be EQ, EQL, or EQUAL.  SIZE specifies the number of entries in the
hash-table.  REHASH-SIZE, if an integer, specifies how many entries should be
added when the hash-table becomes 'almost full'.  REHASH-SIZE, if a float,
specifies the ratio of the new size and the old size.  REHASH-THRESHOLD
specifies when to expand the hash-table.  If an integer, the hash-table is
expanded when REHASH-THRESHOLD / REHASH-SIZE entries have been used.  If a
float, the hash-table is expanded when REHASH-THRESHOLD times the whole
entries have been used.")

(docfun make-list function (length &key (initial-element nil)) "
Creates and returns a list of the specified LENGTH, whose elements are all the
value of INITIAL-ELEMENT.")

(docfun make-package function (package-name &key (nicknames nil) (use '(lisp))) "
Creates and returns a new package named PACKAGE-NAME.  PACKAGE-NAME must be a
string or a symbol.  The print name is used if PACKAGE-NAME is a symbol.
NICKNAMES gives the nicknames of the package.  It must be a list of strings
and symbols.  USE specifies the packages used by the created package.  It must
be a list of package objects, strings, and symbols.")

(docfun make-pathname function (&key (defaults (parse-namestring \"\"
                        (pathname-host *default-pathname-defaults*)))
            (host (pathname-host defaults))
            (device (pathname-device defaults))
            (directory (pathname-directory defaults))
            (name (pathname-name defaults))
            (type (pathname-type defaults))
            (version (pathname-version defaults))) "
Creates a pathname object with the slot values specified by HOST, DEVICE,
DIRECTORY, NAME, TYPE, and VERSION.")

(docfun make-random-state function (&optional (random-state nil)) "
Creates and returns a random-state object.  If RANDOM-STATE is NIL, copies the
value of *RANDOM-STATE*.  If RANDOM-STATE is a random-state, copies it.  If
RANDOM-STATE is T, creates a random-state randomly.")

(docfun ext:make-stream-from-fd function
        (fd direction &key buffering element-type (external-format :default) (name "FD-STREAM")) "
Creates and returns a new stream build on top of given FD file descriptor.

DIRECTION may be :INPUT, :OUTPUT and :IO. On Windows it may be
also :INPUT-WSOCK, :OUTPUT-WSOCK, :IO-WSOCK and :IO-WCON.

BUFFERING may be :NONE, :LINE and :FULL.")

(docfun make-string function (length &key (initial-element #\Space)) "
Creates and returns a new string of the given LENGTH, whose elements are all
INITIAL-ELEMENT.")

(docfun make-string-input-stream function (string &optional (start 0) (end (length string))) "
Creates and returns a string-input stream.  Inputs from this stream are
obtained form STRING.  A string-input stream is notated as
        #<string-input stream from s>
where S is a string.")

(docfun make-string-output-stream function () "
Creates and returns a string-output stream.  Outputs to this stream are
obtained as a string by GET-OUTPUT-STREAM-STRING.  A string-output stream
is notated as
        #<string-output stream n>
where N is a number that identifies the stream.")

(docfun si::make-string-output-stream-from-string function (string) "
ECL specific.
Creates and returns a string-output-stream to STRING.  STRING must have a
fill-pointer.")

(docfun make-symbol function (string) "
Creates and returns a new uninterned symbol whose print name is STRING.")

(docfun make-synonym-stream function (symbol) "
Creates and returns a synonym stream to SYMBOL.  Inputs from this stream are
obtained from, and outputs to this stream are sent to the stream that is the
value of the global variable named SYMBOL.  A synonym stream is notated as
        #<synonym stream to s>
where S is a symbol.")

(docfun make-two-way-stream function (stream1 stream2) "
Creates and returns a two-way stream.  Inputs from this stream are obtained
from STREAM1 and outputs to this stream are sent to STREAM2.  A two-way stream
is notated as
        #<two-way stream n>
where N is a number that identifies the stream.")

(docfun makunbound function (symbol) "
Makes the global variable named SYMBOL have no value.  Returns SYMBOL.")

(docfun mapc function (function list &rest more-lists) "
For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Returns the first
LIST.")

(docfun mapcan function (function list &rest more-lists) "
For each N (0 <= N < K), applies FUNCTION to the N-th elements of the given
LISTs, where K is the minimum length of the given LISTs.  Nconcs the values,
one for each call to FUNCTION, and returns the result.")

(docfun mapcar function (function list &rest more-lists) "
Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th elements of the given LISTs, where K
is the minimum length of the given LISTs.")

(docfun mapcon function (function list &rest more-lists) "
For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Nconcs the values, one for
each call to FUNCTION, and returns the result.")

(docfun maphash function (function hash-table) "
For each entry of HASH-TABLE, applies FUNCTION to the key and the value of the
entry.  Returns NIL.")

(docfun mapl function (function list &rest more-lists) "
For each N (0 <= N < K), applies FUNCTION to the N-th cdrs of the given LISTs,
where K is the minimum length of the given LISTs.  Returns the first LIST.")

(docfun maplist function (function list &rest more-lists) "
Creates and returns a list of K elements, with the N-th element being the
value of applying FUNCTION to the N-th cdrs of the given LISTs, where K is the
minimum length of the given LISTs.")

(docfun max function (number &rest more-numbers) "
Returns the largest arg.  The args must be non-complex numbers.")

(docfun maximum-allocatable-pages function (type) "
ECL specific.
Returns the current maximum number of pages for the type class of the ECL
implementation type TYPE.")

#-boehm-gc
(docfun si::maximum-contiguous-pages function () "
ECL specific.
Returns the current maximum number of pages for contiguous blocks.")

(docfun member function (item list &key (key '#'identity) (test '#'eql) test-not) "
Searches LIST for an element that is equal to ITEM in the sense of the TEST.
If found, returns the sublist of LIST that begins with the element.
Otherwise, returns NIL.")

(docfun merge-pathnames function (filespec
       &optional (defaults *default-pathname-defaults*) default-version) "
Fills in unspecified slots of the pathname specified by FILESPEC from the
pathname specified by DEFAULTS, and returns the result pathname.  DEFAULT-
VERSION is simply ignored in ECL.  FILESPEC and DEFAULTS may be a symbol, a
string, a pathname, or a file stream.")

(docfun min function (number &rest more-numbers) "
Returns the smallest arg.  The args must be non-complex numbers.")

(docfun minusp function (number) "
Returns T if NUMBER is negative; NIL otherwise.")

(docfun mod function (number divisor) "
Returns the second result of (FLOOR NUMBER DIVISOR), i.e. the value of
        (- NUMBER (* (FLOOR NUMBER DIVISOR) DIVISOR))")

(docvar most-negative-double-float constant "
Same as MOST-NEGATIVE-LONG-FLOAT.")

(docvar most-negative-fixnum constant "
The negative fixnum with the largest absolute value.  - 2^29 in ECL.")

(docvar most-negative-long-float constant "
The long-float with the largest absolute value.")

(docvar most-negative-short-float constant "
The short-float with the largest absolute value.")

(docvar most-negative-single-float constant "
Same as MOST-NEGATIVE-LONG-FLOAT.")

(docvar most-positive-double-float constant "
Same as MOST-POSITIVE-LONG-FLOAT.")

(docvar most-positive-fixnum constant "
The largest positive fixnum.  2^29 - 1 in ECL.")

(docvar most-positive-long-float constant "
The largest positive long-float.")

(docvar most-positive-short-float constant "
The largest positive short-float.")

(docvar most-positive-single-float constant "
Same as MOST-POSITIVE-LONG-FLOAT.")

(docfun multiple-value-call special (function-form &rest forms) "
Evaluates FUNCTION-FORM, whose value must be a function.  Then evaluates FORMs
and applies the function to all values of FORMs.  Unlike FUNCALL, all values
of each FORM are used as arguments.  Returns all values of the function.")

(docfun multiple-value-prog1 special (first-form &rest forms) "
Evaluates FIRST-FORM, saves all values it returns, and then evaluates FORMs.
Returns all the saved values of FIRST-FORM.")

(docvar multiple-values-limit constant "
The upper bound on the number of values that a function can return.  Actually,
however, there is no such upper bound in ECL.")

(docfun name-char function (name) "
Given an argument acceptable to string,
Returns a character object with the specified character name (see CHARACTER).
Returns NIL if no such character object exists.  NAME is typically a string
but may be any object that can be coerced to string.")

(docfun namestring function (filespec) "
Returns as a string all slots of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.")

(docfun nbutlast function (list &optional (n 1)) "
Destructive BUTLAST.  LIST may be destroyed.")

(docfun nconc function (&rest lists) "
Destructive APPEND.  The args except for the last may be destroyed.")

(doctype nil "
The type NIL is a subtype of every type.  No object belongs to this type.")

(docvar nil constant "
The value of NIL is NIL.")

(docfun ninth function (x) "
Equivalent to (CAR (CDDDDR (CDDDDR X))).")

(docfun not function (x) "
Returns T if X is NIL; NIL otherwise.")

(docfun nreconc function (x y) "
Equivalent to (NCONC (NREVERSE X) Y).")

(docfun nreverse function (sequence) "
Destructive REVERSE.  The arg may be destroyed.")

(docfun nstring-capitalize function (string &key (start 0) (end (length string))) "
Destructive STRING-CAPITALIZE.  STRING may be destroyed.")

(docfun nstring-downcase function (string &key (start 0) (end (length string))) "
Destructive STRING-DOWNCASE.  STRING may be destroyed.")

(docfun nstring-upcase function (string &key (start 0) (end (length string))) "
Destructive STRING-UPCASE.  STRING may be destroyed.")

(docfun nsublis function (alist tree &key (key '#'identity) (test '#'eql) test-not) "
Destructive SUBLIS.  TREE may be destroyed.")

(docfun nsubst function (new old tree &key (key '#'identity) (test '#'eql) test-not) "
Destructive SUBST.  TREE may be destroyed.")

(docfun nsubstitute function (new old sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive SUBSTITUTE.  SEQUENCE may be destroyed.")

(docfun nsubstitute-if function (new test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive SUBSTITUTE-IF.  SEQUENCE may be destroyed.")

(docfun nsubstitute-if-not function (new test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Destructive SUBSTITUTE-IF-NOT.  SEQUENCE may be destroyed.")

(docfun nth function (n list) "
Returns the N-th element of LIST, the first element of LIST being the zeroth.
Returns NIL if the length of LIST is less than N.  N must be a non-negative
integer.")

(docfun nthcdr function (n list) "
Returns the N-th cdr of LIST.  N must be a non-negative integer.")

(docfun null function (x) "
Returns T if X is NIL; NIL otherwise.")

(docfun si:null-pointer-p function (ptr) "
Return true if PTR is a null pointer.")

(doctype number "
A number is an integer, a ratio, a float, or a complex number.  Integers and
ratios are collectively called rationals.")

(docfun numberp function (x) "
Returns T if X is a number; NIL otherwise.")

(docfun numerator function (rational) "
Returns the numerator of RATIONAL as an integer, if RATIONAL is a ratio.
Returns RATIONAL if it is an integer.")

(docfun oddp function (integer) "
Returns T if INTEGER is an odd number; NIL otherwise.")

(docfun open function (filespec &key (direction :input) element-type
                     if-exists if-does-not-exist) "
Opens the specified file and returns a file stream to/from the file.

FILESPEC may be a symbol, a string, a pathname, or a file stream.

DIRECTION may be :INPUT, :OUTPUT, :IO, or :PROBE.

IF-EXISTS specifies what to do when DIRECTION is either :OUTPUT or :IO
and the specified file exists already.  It may be :ERROR (the
default), :NEW-VERSION, :RENAME, :RENAME-AND-DELETE, :OVERWRITE, :APPEND,
:SUPERSEDE, or NIL.

IF-DOES-NOT-EXIST specifies what to do when the specified file does
not exists.  It may be :ERROR (the default when DIRECTION
is :INPUT), :CREATE (the default when DIRECTION is either :OUTPUT
or :IO), or NIL.")

(docfun ext:make-pipe function ()
"Creates a pipe in the form of a two-way stream that can be used for
interprocess and interthread communication.")

(docfun or macro (&rest forms) "
Evaluates FORMs in order from left to right.  If any FORM evaluates to non-
NIL, quits and returns that (single) value.  If the last FORM is reached,
returns whatever values it returns.")

(docfun output-stream-p function (stream) "
Returns T if STREAM can handle output operations; NIL otherwise.")

(doctype package "
A package object serves as a name space of symbols.  A package is notated as
#<s package> where S is actually the name of the package.  ECL provides five
built-in packages:
        lisp     standard symbols of Common Lisp.
        user     the package that the user uses by default.
        keyword  keyword symbols.
        system   system internal symbols.  Has nicknames SYS and SI.
        compiler system internal symbols for the ECL compiler.")

(docfun ext:package-local-nicknames function
        (package-designator) "
Returns an alist of (LOCAL-NICKNAME . ACTUAL-PACKAGE)
describing the nicknames local to the designated package.")

(docfun ext:package-locally-nicknamed-by-list function
        (package-designator) "
Returns a list of packages which have a local nickname for the
designated package.")

(docfun ext:add-package-local-nickname function
        (local-nickname actul-package &optional package-designator) "
Adds LOCAL-NICKNAME for ACTUAL-PACKAGE in the designated package,
defaulting to current package. LOCAL-NICKNAME must be a string
designator, and ACTUAL-PACKAGE must be a package designator.")

(docfun ext:remove-package-local-nickname function
        (old-nickname &optional package-designator) "
If the designated package had OLD-NICKNAME as a local nickname
for another package, it is removed. Returns true if the nickname
existed and was removed, and NIL otherwise.")

(docfun package-name function (package) "
Returns the name of PACKAGE as a string.")

(docfun package-nicknames function (package) "
Returns the nicknames of PACKAGE as a list of strings.")

(docfun package-shadowing-symbols function (package) "
Returns, as a list, those symbols in PACKAGE that are shadowing symbols in
other packages.")

(docfun package-use-list function (package) "
Returns, as a list, those packages that PACKAGE uses.")

(docfun package-used-by-list function (package) "
Returns, as a list, those packages that use PACKAGE.")

(docfun packagep function (x) "
Returns T if X is a package object; NIL otherwise.")

(docfun pairlis function (keys items &optional (alist nil)) "
Conses each KEY and the corresponding ITEM, adds them to ALIST, and returns
the result.  KEYS and ITEMS must be of the same length.")

(docfun parse-integer function (string
       &key (start 0) (end (length string)) (radix 10) (junk-allowed nil)) "
Parses STRING for an integer and returns it.  As the second value, returns the
index to the character next to the last character that is parsed.  If JUNK-
ALLOWED is non-NIL, ignores white spaces before and after the number
representation in STRING and returns NIL even if STRING is not parsed
successfully.")

(docfun parse-namestring function (string &optional host defaults &key (start 0) end (junk-allowed nil)) "
Parses STRING and returns a pathname.  As the second value, returns the index
to the character next to the last character that has been parsed.  STRING is
usually a string object but it may be a symbol, a pathname, or a file stream.
START and END are meaningful only when STRING is a string or a symbol.  They
default to 0 and (length (string FILESPEC)) respectively.  When the parsing is
failed, signals an error (if JUNK-ALLOWED is NIL) or simply returns NIL.  HOST
and DEFAULTS are simply ignored in ECL.")

(doctype pathname "
A pathname object identifies an external file or a collection of external
files.  A pathname object consists of six slots, HOST, DEVICE, DIRECTORY,
NAME, and TYPE.  HOST, DEVICE, and VERSION slots are meaningless in ECL,
though they are harmless at all.
A pathname is notated as #\\\"...\", where '...' is actually some information
on the pathname.  This depends on the version of ECL.  Refer to the ECL Report
for details.")

(docfun pathname function (filespec) "
Returns a pathname specified by FILESPEC.  FILESPEC may be a symbol, a string,
a pathname, or a file stream.")

(docfun pathname-device function (filespec) "
Returns the device slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.")

(docfun pathname-directory function (filespec) "
Returns the directory slot of the pathname specified by FILESPEC.  FILESPEC
may be a symbol, a string, a pathname, or a file stream.")

(docfun pathname-host function (filespec) "
Returns the host slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.")

(docfun pathname-name function (filespec) "
Returns the name slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.")

(docfun pathname-type function (filespec) "
Returns the type slot of the pathname specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.")

(docfun pathname-version function (filespec) "
Returns the version slot of the pathname specified by FILESPEC.  FILESPEC may
be a symbol, a string, a pathname, or a file stream.")

(docfun pathnamep function (x) "
Returns T if X is a pathname object; NIL otherwise.")

(docfun peek-char function (&optional (char-spec nil) (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursive-p nil)) "
Reads characters from STREAM until the specified character is read.  Returns
the last character but leaves it in STREAM.  CHAR-SPEC may be a character
object, T (specifies non-whitespace characters), or NIL (specifies all
characters).")

(docvar pi constant "
The float that is approximately equal to the ratio of the circumference of the
circle to the diameter.")

(docfun si::pointer function (object) "
ECL specific.
Returns the address of the OBJECT as a fixnum.")

(docfun plusp function (number) "
Returns T if NUMBER is positive; NIL otherwise.")

(docfun position function (item sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence)) (from-end nil)) "
Returns the index to the first element in SEQUENCE that is equal to ITEM in
the sense of TEST.  Returns NIL if no such element exists.")

(docfun position-if function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence)) (from-end nil)) "
Returns the index to the first element in SEQUENCE that satisfies TEST.
Returns NIL if no such element exists.")

(docfun position-if-not function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence)) (from-end nil)) "
Returns the index to the first element in SEQUENCE that does not satisfy TEST.
Returns NIL if no such element exists.")

(docfun pprint function (object &optional (stream *standard-output*)) "
Pretty-prints OBJECT.  Returns no values.  Equivalent to
        (PROGN (WRITE OBJECT :STREAM STREAM :PRETTY T :ESCAPE T)
               (VALUES))
The SI::PRETTY-PRINT-FORMAT property N (which must be a non-negative integer)
of a symbol SYMBOL controls the pretty-printing of form
        (SYMBOL f1 ... fN fN+1 ... fM)
in such a way that the subforms fN+1, ..., fM are regarded as the 'body' of
the entire form.  For instance, the property value of 2 is initially given to
the symbol DO.")

(docfun prin1 function (object &optional (stream *standard-output*)) "
Prints OBJECT in the way that the output can be reread later if possible.
Returns OBJECT.  Equivalent to (WRITE OBJECT :STREAM STREAM :ESCAPE T).")

(docfun princ function (object &optional (stream *standard-output*)) "
Prints OBJECT without escape characters.  Returns OBJECT.  Equivalent to
(WRITE OBJECT :STREAM STREAM :ESCAPE NIL).")

(docfun print function (object &optional (stream *standard-output*)) "
Outputs a newline character, and then PRIN1s OBJECT.  Returns OBJECT.
Equivalent to
        (PROGN (TERPRI STREAM)
               (WRITE OBJECT :STREAM STREAM :ESCAPE T))")

(docfun probe-file function (filespec) "
Returns the full pathname of the specified file if it exists.  Returns NIL
otherwise.  FILESPEC may be a symbol, a string, a pathname, or a file stream.")

(docfun progn special (&body forms) "
Evaluates FORMs in order, and returns all values of the last FORM.  Returns
NIL if no FORM is given.")

(docfun progv special (symbols-form values-form &body forms) "
Evaluates SYMBOLS-FORM and VALUES-FORM.  The value of SYMBOLS-FORM must be a
list of symbols (S1 ... Sn) and the value of VALUES-FORM must be a list
(V1 ... Vm).  Binds each Si to Vi or to NIL if i > m.  Then evaluates FORMs
and returns all values of the last FORM.  Returns NIL if no FORM is given.")

(docfun quote special (x) "
Simply returns X without evaluating it.")

(docfun random function (number &optional (random-state *random-state*)) "
Creates and returns a random number by using RANDOM-STATE.  NUMBER must be
either a positive integer or a positive float.  If NUMBER is a positive
integer, returns a positive integer less than NUMBER.  If NUMBER is a positive
float, returns a positive float less than NUMBER in the same float format as
NUMBER.")

(doctype random-state "
A random-state object stores information used to generate random numbers.  A
random-state is notated as '#$' followed by a certain number.")

(docfun random-state-p function (x) "
Returns T if X is a random-state object; NIL otherwise.")

(docfun rassoc function (item alist &key (test '#'eql) test-not (key '#'identity)) "
Returns the first pair in ALIST whose cdr is equal (in the sense of TEST) to
ITEM.  Returns NIL if no such pair exists.
The function KEY is applied to extract the key for comparison.")

(doctype ratio "
A ratio is notated by its numerator and denominator, separated by a slash '/'.
Normally, a ratio is notated in radix 10 (see *PRINT-BASE* and *READ-BASE*) as
        [sign] {digit}+ / {digit}+
where DIGIT is a decimal digit ('0', ..., '9') and SIGN is either '+' or '-'.
Also, the following syntax is used to notate the radix explicitly.
        # radix {r | R} [sign] {digit}+ / {digit}+
where RADIX is one of '2', '3', ..., '36' and DIGIT is a digit in radix RADIX:
        Digits in radix 2 are '0' and '1'
        Digits in radix 8 are '0', ..., '7'
        Digits in radix 16 are '0', ..., '9', 'a', ..., 'f', and 'A', ..., 'F'
The following syntax is also available for radix 2, 8, 10, and 16.
        # {b | B} [sign] {digit}+ / {digit}+
        # {o | O} [sign] {digit}+ / {digit}+
        # {x | X} [sign] {digit}+ / {digit}+")

(docfun rational function (real) "
Converts REAL into rational accurately and returns the result.")

(docfun rationalize function (real) "
Converts REAL into rational approximately and returns the result.")

(doctype rational "
A ratio is either an integer or a ratio.")

(docfun rationalp function (x) "
Returns T if X is an integer or a ratio; NIL otherwise.")

(docfun read function (&optional (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursivep nil)) "
Reads an object from STREAM and returns the object.")

(docfun read-byte function (stream &optional (eof-error-p t) (eof-value nil)) "
Reads one byte from STREAM and returns it as an integer.")

(docfun read-char function (&optional (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursive-p nil)) "
Reads a character from STREAM and returns it.")

(docfun read-char-no-hang function (&optional (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursive-p nil)) "
Returns the next character from STREAM if one is available; NIL otherwise.")

(docfun read-delimited-list function (char &optional (stream *standard-input*) (recursive-p nil)) "
Reads objects from STREAM until the next character after an object's
representation is CHAR.  Returns all objects read, as a list.")

(docfun read-line function (&optional (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursive-p nil)) "
Reads a line of characters from STREAM and returns them as a string.  The
newline character at the end of the line will be discarded.")

(docfun read-preserving-whitespace function (&optional (stream *standard-input*)
                 (eof-error-p t) (eof-value nil) (recursive-p nil)) "
Reads an object from STREAM and returns the object.  Unlike READ, always
leaves the character next to the object's representation.")

(doctype readtable "
A readtable defines the syntax used to read objects.
Each readtable object remembers the syntactic class of each character.  The
following syntactic classes are supported.  The characters in parenthesis
below are those standard characters that belong to each syntactic class as
defined in the standard readtable.
        white-space (space and newline)
        single-escape ( \\ )
        multiple-escape ( | )
        macro-character ( \"  #  '  (  )  ,  ;  ` )
        constituent (the others)
For each macro-character, the readtable remembers the definition of the
associated read macro and the non-terminating-p flag.  In the standard
readtable, only single-quote is non-terminating.  Dispatch macro characters
are classified to macro-characters.  A readtable is notated as
        #<readtable n>
where N is actually a number that identifies the readtable.")

(docfun readtablep function (x) "
Returns T if X is a readtable object; NIL otherwise.")

(docfun realpart function (number) "
Returns the realpart of NUMBER if it is a complex.  Otherwise, returns NUMBER.")

(docfun reduce function (function sequence
       &key (from-end nil) (start 0) (end (length sequence)) initial-value) "
Combines all the elements of SEQUENCE using the binary operation FUNCTION.")

(docfun rem function (number divisor) "
Returns the second value of (TRUNCATE NUMBER DIVISOR), i.e. the value of
        (- NUMBER (* (TRUNCATE NUMBER DIVISOR) DIVISOR))")

(docfun remhash function (key hash-table) "
Removes the entry for KEY in HASH-TABLE.  Returns T if such an entry existed;
NIL otherwise.")

(docfun remove function (item sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with those elements equal to ITEM (in the sense of
TEST) removed.")

(docfun remove-if function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with elements satisfying TEST removed.")

(docfun remove-if-not function (test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with elements not satisfying TEST removed.")

(docfun remprop function (symbol indicator) "
Removes the specified property from the property list associated with SYMBOL.
Returns T if the property list had the specified property; NIL otherwise.")

(docfun rename-file function (filespec new-filespec &key (if-exists :error)) "
Renames the file specified by FILESPEC as specified by NEW-FILESPEC.  Returns
as three values the new pathname, the old full pathname, and the new full
pathname.  FILESPEC and NEW-FILESPEC may be a symbol, a string, a pathname, or
a file stream.

:IF-EXISTS is an ECL-specific extension that modifies the behavior of rename-file
if new-filespec already exists. It may be :ERROR (the default), NIL, :SUPERSEDE,
or T.")

(docfun rename-package function (package new-name &optional (new-nicknames nil)) "
Renames PACKAGE to NEW-NAME and replaces the nicknames with NEW-NICKNAMES.
See MAKE-PACKAGE.")

(docfun replace function (sequence1 sequence2
       &key (start1 0) (end1 (length sequence1))
            (start2 0) (end2 (length sequence2))) "
Replaces elements of SEQUENCE1 with the corresponding elements of SEQUENCE2.
SEQUENCE1 may be destroyed and is returned.")

#-boehm-gc
(docfun si::reset-gc-count function () "
ECL specific.
Resets the counter of the garbage collector that records how many times the
garbage collector has been called for each implementation type.")

(docfun rest function (x) "
Equivalent to CDR.")

(docfun return macro (&optional result) "
Terminates execution of the lexically surrounding NIL block and returns all
values of RESULT (which defaults to NIL) as the values of the terminated
block.")

(docfun return-from special (symbol &optional result) "
Terminates execution of the lexically surrounding block named SYMBOL and
returns all values of RESULT (which defaults to NIL) as the values of the
terminated block.")

(docfun revappend function (x y) "
Equivalent to (APPEND (REVERSE X) Y)")

(docfun reverse function (sequence) "
Returns a new sequence containing the same elements as SEQUENCE but in the
reverse order.")

(docfun round function (number &optional (divisor 1)) "
Returns the integer nearest to NUMBER/DIVISOR.  Returns the value of (- NUMBER
(* first-value DIVISOR)) as the second value.")

(docfun rplaca function (cons x) "
Replaces the car of CONS with X, and returns the modified CONS.")

(docfun rplacd function (cons x) "
Replaces the cdr of CONS with X, and returns the modified CONS.")

(docfun save function (filespec) "
ECL specific.
Saves the current ECL core image into a program file specified by PATHNAME.
FILESPEC may be a symbol, a string, a pathname, or a file stream.  This
function depends on the version of ECL.  See ECL Report for details.")

(docfun system function (command) "
ECL specific.
Executes a Shell command as if the string COMMAND is an input to the Shell.  
On return from the Shell command, it returns the exit code
of the command as an integer.")

(docfun scale-float function (float integer) "
Returns the value of (* FLOAT (expt (float-radix FLOAT) INTEGER)).")

(docfun schar function (simple-string n) "
Returns the character object representing the N-th character in SIMPLE-STRING.
This is faster than CHAR.")

(docfun second function (x) "
Equivalent to CADR.")

(docfun set function (symbol object) "
Assigns OBJECT to the global variable named SYMBOL.  Returns OBJECT.")

(docfun set-char-bit function (char bit-name flag) "
Returns a character with the same code and attributes as CHAR except the
bit specified by BIT-NAME is on (if FLAG is non-NIL) or off. In ECL, the
bit-attributes handled are :control :meta :super and :hyper")


(docfun set-dispatch-macro-character function (char subchar function &optional (readtable *readtable*)) "
Replaces FUNCTION for the read macro of SUBCHAR associated with the dispatch
macro character CHAR in READTABLE.  When the ECL reader reads an object that
begins with CHAR followed by SUBCHAR, it calls FUNCTION with the input stream,
SUBCHAR, and NIL as arguments.  When the ECL reader reads an object that
begins with CHAR, followed by a decimal representation of a number N, followed
by SUB-CHAR, it calls FUNCTION with N as the third argument.  In both cases,
if FUNCTION returns a single value, then that value is returned as the value
of the reader.  If FUNCTION returns no value, then the reader tries to read an
object again.  See MAKE-DISPATCH-MACRO-CHARACTER and GET-DISPATCH-MACRO-
CHARACTER.")

(docfun si::set-hole-size function (fixnum) "
ECL specific.
Sets the size of the memory hole (in pages).")

(docfun set-macro-character function (char function
       &optional (non-terminating-p nil) (readtable *readtable*)) "
Registers CHAR as a macro character in READTABLE and makes FUNCTION the read
macro associated with CHAR.  When the ECL reader reads an object that begins
with CHAR, it calls FUNCTION with the input stream and CHAR as arguments.  If
FUNCTION returns a single value, it is returned as the value of the reader.
If FUNCTION returns no value, then the reader tries to read an object again.
NON-TERMINATING-P specifies whether CHAR is non-terminating or not (see
READTABLE).
Use GET-MACRO-CHARACTER to get the read macro associated with a character.")

(docfun set-syntax-from-char function (to-char from-char
       &optional (to-readtable *readtable*) (from-readtable nil)) "
Replaces the information for TO-CHAR in TO-READTABLE with the information for
FROM-CHAR in FROM-READTABLE.  If FROM-READTABLE is NIL, then the standard
readtable is used.  TO-CHAR belongs to the same syntactic class as FROM-CHAR,
and if FROM-CHAR is a macro character, TO-CHAR inherits the read macro and
non-terminating-p flag of FROM-CHAR.  See READTABLE.")

(docfun setq special (&rest var-form-pairs) "
Syntax: (setq {var form}*)

Evaluates each FORM and assigns the value to VAR in order.  Returns the value
of the last FORM.")

(docfun seventh function (x) "
Equivalent to (CADDR (CDDDDR X)).")

(docfun shadow function (symbol &optional (package *package*)) "
If no symbol is registered in PACKAGE with the same name as SYMBOL, then
creates an internal symbol with the same name and registers it into PACKAGE.
The created symbol shadows external symbols of the same name in those packages
that PACKAGE uses.  SYMBOL may be a list of symbols.")

(docfun shadowing-import function (symbol &optional (package *package*)) "
Registers SYMBOL as an internal symbol of PACKAGE.  Does nothing if SYMBOL is
already registered in PACKAGE.  If there exists already a symbol in PACKAGE
with the same name, then uninterns the symbol first.  SYMBOL shadows external
symbols of the same name in those packages that PACKAGE uses.  SYMBOL may be a
list of symbols.")

(doctype short-float "
A short-float is a short-precision floating point number.")

(doctype simple-array "
A simple-array is an array that is not displaced to another array, has no
fill-pointer, and is not adjustable.")

(docfun simple-bit-vector-p function (x) "
Returns T if X is a simple-bit-vector; NIL otherwise.")

(docfun simple-string-p function (x) "
Returns T if X is a simple-string; NIL otherwise.")

(docfun simple-vector-p function (x) "
Returns T if X is a simple-vector; NIL otherwise.")

(docfun sin function (radians) "
Returns the sine of RADIANS.")

(doctype single-float "
A single-float is a single-precision floating point number.
SINGLE-FLOAT as a type specifier is equivalent to LONG-FLOAT in ECL.")

(docfun sinh function (number) "
Returns the hyperbolic sine of NUMBER.")

(docfun sixth function (x) "
Equivalent to (CADR (CDDDDR X)).")

(docfun sleep function (n) "
Suspends execution for N seconds.  N may be any non-negative, non-complex
number.")

#+clos
(docfun si::sl-boundp function (object) "
ECL/CLOS specific.
Returns nil if the OBJECT is not null.")

#+clos
(docfun si::sl-makunbound function (instance index) "
ECL/CLOS specific.
Removes the value associated with the INDEX-th slot of INSTANCE.")

(docfun special-operator-p function (symbol) "
Returns T if SYMBOL names a special form; NIL otherwise.
The special forms defined in Common Lisp are:
        block           if                      progv
        catch           labels                  quote
        compiler-let    let                     return-from
        declare         let*                    setq
        eval-when       macrolet                tagbody
        flet            multiple-value-call     the
        function        multiple-value-prog1    throw
        go              progn                   unwind-protect
In addition, ECL implements the following macros as special forms, though of
course macro-expanding functions such as MACROEXPAND work correctly for these
macros.
        and             incf                    prog1
        case            locally                 prog2
        cond            loop                    psetq
        decf            multiple-value-bind     push
        defmacro        multiple-value-list     return
        defun           multiple-value-set      setf
        do              or                      unless
        do*             pop                     when
        dolist          prog
        dotimes         prog*")

(docfun si::specialp function (symbol) "
ECL specific.
Returns T if the SYMBOL names a globally special variable; NIL otherwise.")

(docfun sqrt function (number) "
Returns the square root of the arg.")

(doctype standard-char "
A standard-char is a space character (#\\Space), a newline character
(#\\Newline,) or a character that represents one of the following letters.
        !  \"  #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4
        5  6  7  8  9  :  ;  <  =  >  ?  @  A  B  C  D  E  F  G  H
        I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\
        ]  ^  _  `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p
        q  r  s  t  u  v  w  x  y  z  {  |  }  ~~")

(docfun standard-char-p function (char) "
Returns T if CHAR is a standard-char; NIL otherwise.")

(doctype stream "
A stream is a source of input or a destination of output.  The following kinds
of streams are supported.
        file streams
        string-input streams
        string-output streams
        two-way streams
        echo streams
        synonym streams
        concatenated streams
        broadcast streams
Basically, file streams are created by OPEN and other kinds of streams are
created by MAKE-...-STREAM.  See these functions.")

(docfun stream-element-type function (stream) "
Returns the type specifier for the io unit of STREAM.")

(docfun streamp function (x) "
Returns T if X is a stream object; NIL otherwise.")

;;; CLOS Streams ------------------------------------------------------------

#+CLOS-STREAMS
(docfun stream-read-char method ((obj stream-class)) "
Reads the next character object from the CLOS stream OBJ.")

#+CLOS-STREAMS
(docfun stream-read-line method ((obj stream-class) &rest make-array-options) "
Reads character objects from the CLOS stream OBJ, up to and including the
next newline character, and returns them as a string (without the newline).
If given, the MAKE-ARRAY-OPTIONS arguments are passed to make-array
when the returned string is created.")

#+CLOS-STREAMS
(docfun stream-unread-char method ((obj stream-class) character) "
Unreads the character object.
CHARACTER will be the next character read by STREAM-READ-CHAR .")

#+CLOS-STREAMS
(docfun stream-peek-char method ((obj stream-class) peek-type) "
Returns the character object which would be returned by STREAM-READ-CHAR
but does not remove it from the input buffer.
If PEEK-TYPE is T, stream-peek-char skips over any whitespace characters,
removing them from the input buffer, and returns the next character.")

#+CLOS-STREAMS
(docfun stream-listen method ((obj stream-class)) "
Returns NIL if no character is immediately available from the CLOS stream.
Otherwise, the next character is returned, as if stream-peek-char
had been called.")

#+CLOS-STREAMS
(docfun stream-clear-input method ((obj stream-class)) "
Clears any buffered characters received from the CLOS stream OBJ.
Returns NIL.")

#+CLOS-STREAMS
(docfun stream-write-char method ((obj stream-class) character) "
Outputs the CHARACTER to the CLOS stream OBJ and returns the CHARACTER.")

#+CLOS-STREAMS
(docfun stream-write-string method ((obj stream-class) string &optional start end) "
Outputs characters in the STRING to the CLOS stream OBJ and returns the
STRING. The START and END arguments, if given, indicate a substring that
is to be output.")

#+CLOS-STREAMS
(docfun stream-fresh-line method ((obj stream-class)) "
Outputs a newline to the CLOS stream if and only if the CLOS stream OBJ
is not already at the beginning of a new line. Returns non-NIL if a
newline was output and NIL otherwise.")

#+CLOS-STREAMS
(docfun stream-clear-output method ((obj stream-class)) "
Aborts any outstanding output operation on the CLOS stream OBJ
and returns NIL .")

#+CLOS-STREAMS
(docfun stream-force-output method ((obj stream-class)) "
Initiates the emptying of internal buffers on the CLOS stream OBJ
and returns NIL.")

;;; end of CLOS streams ---------------------------------------------------

(docfun string function (x) "
Coerces X into a string.  If X is a string, then returns X itself.  If X is a
symbol, then returns its print name.  If X is a character, then returns a one
element string containing that character.  Signals an error if X cannot be
coerced into a string.")

(docfun string-capitalize function (string &key (start 0) (end (length string))) "
Returns a copy of STRING with the first character of each word converted to
upper case, and remaining characters converted to lower case.  Its destructive
version is NSTRING-CAPITALIZE.")

(doctype string-char "
A string-char is a character that can be stored in strings.  In ECL, every
character is a string-character.")

(docfun string-char-p function (char) "
Returns T if CHAR is a string-char, i.e. can be stored in strings; NIL
otherwise.  In ECL, this function always returns T.")

(docfun si::string-concatenate function (&rest strings) "
ECL specific.
Concatenates STRINGs and returns the result.")

(docfun string-downcase function (string &key (start 0) (end (length string))) "
Returns a copy of STRING with all upper case characters converted to lower
case.  Its destructive version is NSTRING-DOWNCASE.")

(docfun string-equal function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Returns T if STRING1 and STRING2 are character-wise CHAR-EQUAL; NIL otherwise.")

(docfun string-greaterp function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Similar to STRING>, but ignores cases.")

(docfun string-left-trim function (char-bag string) "
Returns a copy of STRING with the specified characters removed from the left
end.  CHAR-SPEC must be a sequence of characters.")

(docfun string-lessp function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Similar to STRING<, but ignores cases.")

(docfun string-not-equal function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Returns NIL if the strings are character-wise CHAR-EQUAL.  Otherwise, returns
the number of characters in the longest common prefix of the strings.")

(docfun string-not-greaterp function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Similar to STRING<=, but ignores cases.")

(docfun string-not-lessp function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Similar to STRING>=, but ignores cases.")

(docfun string-right-trim function (char-bag string) "
Returns a copy of STRING with the specified characters removed from the right
end.  CHAR-SPEC must be a sequence of characters.")

(docfun si::string-to-object function (string) "
ECL specific.
Equivalent to (READ-FROM-STRING STRING), but is much faster.")

(docfun string-trim function (char-spec string) "
Returns a copy of STRING with the specified characters removed from both ends.
CHAR-SPEC must be a sequence of characters.")

(docfun string-upcase function (string &key (start 0) (end (length string))) "
Returns a copy of STRING with all lower case characters converted to upper
cases.  Its destructive version is NSTRING-UPCASE.")

(docfun string/= function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Returns NIL if the strings are character-wise CHAR=.  Otherwise, returns the
number of characters in the longest common prefix of the strings.")

(docfun string< function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
If STRING1 comes before STRING2 in lexicographic order, then returns the
number of characters in the longest common prefix of the strings.  Otherwise,
returns NIL.")

(docfun string<= function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
If STRING1 comes before STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.")

(docfun string= function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
Returns T if STRING1 and STRING2 are character-wise CHAR=; NIL otherwise.")

(docfun string> function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.")

(docfun string>= function (string1 string2
       &key (start1 0) (end1 (length string1))
            (start2 0) (end2 (length string2))) "
If STRING1 comes after STRING2 in lexicographic order or if the strings are
character-wise CHAR=, then returns the number of characters in the longest
common prefix of the strings.  Otherwise, returns NIL.")

(docfun stringp function (x) "
Returns T if X is a string object; NIL otherwise.")

(docfun si::structurep function (x) "
ECL specific.
Returns T if X is a structure object defined by DEFSTRUCT; NIL otherwise.")

(docfun sublis function (alist tree &key (key '#'identity) (test '#'eql) test-not) "
Substitutes subtrees of TREE by using ALIST and returns the result.  The
original TREE is not destroyed.")

(docfun subseq function (sequence start &optional (end (length sequence))) "
Returns a copy of the subsequence of SEQUENCE between START (inclusive) and
END (exclusive).")

(docfun subst function (new old tree &key (key '#'identity) (test '#'eql) test-not) "
Substitutes NEW for subtrees of TREE that match OLD and returns the result.
The original TREE is not destroyed.")

(docfun substitute function (new old sequence
       &key (key '#'identity) (test '#'eql) test-not
            (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with all elements that match OLD replaced by NEW.
The original SEQUENCE is not destroyed.")

(docfun substitute-if function (new test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with all elements that satisfy TEST replaced by
NEW.  The original SEQUENCE is not destroyed.")

(docfun substitute-if-not function (new test sequence
       &key (key '#'identity) (start 0) (end (length sequence))
            (count most-positive-fixnum) (from-end nil)) "
Returns a copy of SEQUENCE with all elements that do not satisfy TEST replaced
by NEW.  The original SEQUENCE is not destroyed.")

(docfun svref function (simple-vector n) "
Returns the N-th element of SIMPLE-VECTOR.")

(docfun sxhash function (object) "
Returns the hash code for OBJECT as an integer.")

(doctype symbol "
Symbol objects.")

(docfun symbol-function function (symbol) "
Returns the global function definition named SYMBOL.")

(docfun symbol-name function (symbol) "
Returns the print name of SYMBOL.")

(docfun symbol-package function (symbol) "
Returns the home package of SYMBOL.  Returns NIL if SYMBOL is not interned.")

(docfun symbol-plist function (symbol) "
Returns the property list of SYMBOL.")

(docfun symbol-value function (symbol) "
Returns the value of the global variable named SYMBOL.")

(docfun symbolp function (x) "
Returns T if X is a symbol; NIL otherwise.")

(docfun ext:system function (string) "
Executes a Shell command as if STRING is an input to the Shell.")

(docfun ext:run-program function (command argv &key
                                          (input  :stream)
                                          (output :stream)
                                          (error  :output)
                                          (wait t) environ
                                          if-input-does-no-exist
                                          (if-output-exists :error)
                                          (if-error-exists  :error)
                                          (external-format  :default)) "
Creates external process with COMMAND given args ARGV, where INPUT,
OUTPUT and ERROR might be :STREAM, T, NIL, pathname designator or
stream (gray streams doesn't work). ERROR might be also :OUTPUT. If
WAIT is T, then process is ran asynchronously.

Returns two-way stream for communication, process status (or exit
code, depending on wait parameter) and EXTERNAL-PROCESS structure.")

(doctype t "
The type T is a supertype of every type.  Every object belongs to this type.")

(docvar t constant "
The value of T is T.")

(docfun tagbody special (&body forms)
"Syntax: (tagbody {tag | statement}*)

Executes STATEMENTs in order and returns NIL after the execution of the last
STATEMENT.  But, if a GO form causes a jump to one of the TAGs, then execution
continues at the point right after the TAG.  Lists are regarded as STATEMENTs
and other objects are regarded as TAGs.")

(docfun tailp function (x list) "
Returns T if X is identical to one of the conses that constitute LIST.
Returns NIL otherwise.")

(docfun tan function (radians) "
Returns the tangent of RADIANS.")

(docfun tanh function (number) "
Returns the hyperbolic tangent of NUMBER.")

(docfun tenth function (x) "
Equivalent to (CADR (CDDDDR (CDDDDR X))).")

(docfun terpri function (&optional (stream *standard-output*)) "
Outputs a newline character.")

(docfun the special (type form) "
Declares that FORM evaluates to a value of TYPE.  Evaluates FORM and checks if
the value belongs to TYPE.  If it does, returns the value.  Otherwise, signals
an error.")

(docfun third function (x) "
Equivalent to CADDR.")

(docfun throw special (tag form) "
Evaluates TAG and aborts the execution of the most recent CATCH form that
establishes a catcher with the same catch tag.  Returns all values of FORM as
the values of the CATCH form.")

(docfun tree-equal function (x y &key (test '#'eql) test-not) "
Returns T if X and Y have the same tree structures and corresponding leaves
are all the same in the sense of TEST.  Returns NIL otherwise.")

(docfun truename function (filespec) "
Returns the full pathname of the file specified by FILESPEC.  FILESPEC may be
a symbol, a string, a pathname, or a file stream.")

(docfun truncate function (number &optional (divisor 1)) "
Returns the integer obtained by truncating NUMBER/DIVISOR.  Returns the value
of (- NUMBER (* first-value DIVISOR)) as the second value.")

(docfun type-of function (x) "
Returns a type specifier of the type to which X belongs.")

(docfun unexport function (symbol &optional (package *package*)) "
Undoes the registration of SYMBOL as an external symbol of PACKAGE and makes
SYMBOL internal to PACKAGE.  SYMBOL may be a list of symbols.")

(docfun unintern function (symbol &optional (package *package*)) "
Removes SYMBOL from PACKAGE.  If PACKAGE is the home package of SYMBOL, then
makes SYMBOL uninterned.  Returns T if SYMBOL is actually registered in
PACKAGE; NIL otherwise.")

(docfun unread-char function (char &optional (stream *standard-input*)) "
Puts CHAR back on the front of the input stream STREAM.")

(docfun unuse-package function (package-spec &optional (package *package*)) "
Causes PACKAGE not to use packages specified by PACKAGE-SPEC.  PACKAGE-SPEC
may be a package object, a string, a symbol, or a list consisting of package
objects, strings, and, symbols.")

(docfun unwind-protect special (form &body cleanup-forms) "
Evaluates FORM and returns all its values.  Before returning, evaluates
CLEANUP-FORMs in order, whether FORM returns normally or abnormally by a non-
local exit.")

(docfun upper-case-p function (char) "
Returns T if CHAR is an upper-case character; NIL otherwise.")

(docfun use-package function (package-spec &optional (package *package*)) "
Causes PACKAGE to use packages specified by PACKAGE-SPEC, in addition to those
packages that PACKAGE already uses.  PACKAGE-SPEC may be a package object, a
string, a symbol, or a list consisting of package objects, strings, and
symbols.")

(docfun user-homedir-pathname function (&optional host) "
Returns a pathname the represents the user's home directory.  HOST is simply
ignored in ECL.")

(docfun values function (&rest args) "
Returns ARGs as multiple values, the N-th ARG being the N-th value.")

(docfun values-list function (list) "
Returns all elements of LIST as multiple values, the N-th element of LIST
being the N-th value.")

(docfun vectorp function (x) "
Returns T if X is a vector; NIL otherwise.")

(docfun vector-push function (new-element vector) "
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  Returns NIL if the new
value of the fill-pointer becomes too large.  Otherwise, returns the new fill-
pointer as the value.")

(docfun vector-push-extend function (new-element vector &optional (extension 1)) "
Replaces ITEM for the element of VECTOR that is pointed to by the fill-pointer
of VECTOR and then increments the fill-pointer by one.  If the new value of
the fill-pointer becomes too large, extends VECTOR for N more elements.
Returns the new value of the fill-pointer.")

(docfun when macro (test &body forms) "
If TEST evaluates to non-NIL, then evaluates FORMs and returns all values of
the last FORM.  If not, simply returns NIL.")

(docfun write function (object &key (stream *standard-output*) (escape *print-escape*)
                   (radix *print-radix*) (base *print-base*)
                   (circle *print-circle*) (pretty *print-pretty*)
                   (level *print-level*) (length *print-length*)
                   (case *print-case*) (array *print-array*)
                   (gensym *print-gensym*)) "
Prints OBJECT in the specified mode.  See the variable docs of *PRINT-...* for
the mode.")

(docfun write-byte function (integer stream) "
Outputs INTEGER to the binary stream STREAM.  Returns INTEGER.")

(docfun write-char function (char &optional (stream *standard-output*)) "
Outputs CHAR to STREAM.  Returns CHAR.")

(docfun write-line function (string &optional (stream *standard-output*)
              &key (start 0) (end (length string))) "
Outputs STRING and a newline character to STREAM.  Returns STRING.")

(docfun write-string function (string &optional (stream *standard-output*)
              &key (start 0) (end (length string))) "
Outputs STRING to STREAM.  Returns STRING.")

(docfun zerop function (number) "
Returns T if the arg is zero; NIL otherwise.")

;;; ----------------------------------------------------------------------
;;; Multi Processing (POSIX Threads)

#+threads
(progn
  (docfun mp:all-processes function () "
Returns a list of all running processes.")

  (docfun mp:make-process function (&key name) "
Allocates new process.")

  (docfun mp:process-yield function () "
Causes current process to yield the control.")

  (docfun mp:exit-process function () "
Exits current process.")

  (docfun mp:process-active-p function (process) "
Returns T if the process is active; NIL otherwise.")

  (docfun mp:process-enable function (process) "
Starts a process. If process is already enabled signals error.")

  (docfun mp:interrupt-process function (process function) "
Interrupts active PROCESS to call FUNCTION. When FUNCTION
finishes normal normal execution is resumed.")

  (docfun mp:process-kill function (process) "
Exits running PROCESS. If PROCESS is inactive signals error.")

  (docfun mp:process-suspend function (process) "
Stops running PROCESS. If PROCESS is inactive signals error.")

  (docfun mp:process-suspend function (process) "
Resumes running PROCESS. If PROCESS is inactive signals error.")

  (docfun mp:process-name function (process) "
Returns PROCESS name assigned on MP:MAKE-PROCESS call.")

  (docfun mp:process-preset function (process function &rest args) "
Initializes a process. When process is enabled it will call FUNCTION
with ARGS.")

  (docfun mp:process-whostate function (process) "
Reserved for future use. Returns empty string.")

  (docfun mp:process-join function (process) "
Waits until process stops its execution.")

  (docfun mp:process-run-function function (name function &rest args) "
Equivalent to creating a process with MP:MAKE-PROCESS, presetting it
with MP:PROCESS-PRESET and starting with MP:PROCESS-ENABLE. Returns
created process."))

#||
;;; ----------------------------------------------------------------------
;;; System Builder Tools

(unless (find-package 'sbt) (make-package 'sbt))

(docfun sbt::build-system macro "(system &optional op mode)" "
It allows to perform operations on a system defined with SBT:DEFSYSTEM.
The possible operations are: :LOAD, :COMPILE and :PRINT.
For the load operation, in alternative to the default of loading all the
binaries in the appropriate order, there are two modes of operation
specifiable via the optional parameter MODE, which can be
:QUERY and :SOURCE.
The latter option will load the sources of the system, while with :QUERY
the user will be prompted on each file to be loaded.

The default mode for compilation is to compile just the files which need
to be recompiled according to their dependencies.
With the :FORCE option, all the files are recompiled, while with the
:QUERY option, the user will be prompted.

By supplying \fCT\fP for the :PRINT option, the sequence of operations
to be performed to build the system will be printed.
")

(docfun sbt::defsystem macro
        "(name &key :modules :directory :pathname-types)" "
NAME should be a symbol which will be used to refer to the system.
The value of :MODULES should be a list of module dependencies of
the form:

        (file load-deps compile-deps recompilation-deps)

where load-deps compile-deps recompilation-deps are lists of module names.
If the value specified for :directory is a cons, then the CAR is used as
the source file directory and the CDR is used as the binary file directory.
The values specified for :PATHNAME-TYPES specifies the extensions for
LISP souce files and binaries.")

;;; ----------------------------------------------------------------------
;;; THREADS

(docfun %delay function (nsec) "
Stops the thread execution for a time interval of NSEC real seconds. The
thread status is set to suspended.")

(docfun %disable-scheduler function () "
Disables the scheduler, so that the execution of the current thread will not be
interrupted by the scheduler until the %enable-scheduler function is called")

(docfun %enable-scheduler function () "
Enables the scheduler, so that it will time-slice execution among all
running threads.")

(docfun %suspend function () "
Sets the current thread status to suspended and suspends its execution.")

(docfun %thread-wait function (predicate &rest args) "
Applies the PREDICATE to the ARGS, in the environment of the calling thread.
If the result is not nil the thread will continue its execution. Otherwise the
thread is suspended and its status set to waiting. The thread will be resumed
again when the condition will become true.")

(docfun %thread-wait-with-timeout function (nsec predicate &rest args) "
Applies the PREDICATE to the ARGS, in the environment of the calling thread.
If the result is not nil the thread will continue its execution. Otherwise the
thread is suspended and its status set to waiting.  The thread will be resumed
again when either the condition will become true or the timeout of NSEC 
seconds has expired.")

(docfun current-thread function (thread) "
Returns the THREAD within which this function was called.")

(docfun deactivate function (thread) "
Stops a running THREAD, setting its status to stopped. A stopped thread can
be resumed with reactivate function.")

(docfun kill-thread function (thread) "
Stops the THREAD execution and set its status to dead.")

(docfun make-continuation function (thread &key :cont) "
Creates a unique new continuation for resuming the THREAD. :CONT is an optional
continuation to be supplied to the thread.")

(docfun make-thread function (function) "
Creates a new thread ready to execute FUNCTION. The thread is in a suspended
status and can run only making a continuation for it and issuing a resume
to such continuation with a list of arguments.")

(docfun reactivate function (thread) "
Sets the THREAD status to running.")

(docfun resume function (continuation &rest args) "
Resumes execution of CONTINUATION and passes it the ARGS.")

(docfun spawn macro (function &rest args) "
Creates a new thread where FUNCTION is applied to the ARGS. Returns immediately
the new thread without waiting for the function to return.")

(docfun thread-list function (thread) "
Returns the full list of the not DEAD threads")

(docfun thread-status function (thread) "
Returns the THREAD status (this can be: running, suspended, stopped or dead)")

(docfun without-scheduling macro "({form}*)" "
Executes the FORMs in sequence within a critical region, ensuring that the
scheduler is disabled.")

;;; ----------------------------------------------------------------------
;;; Unify instructions

(docfun si::dereference function (locative) "
ECL specific.
Given LOCATIVE, it returns the object to which it points. If the
location is unbound, the value returned is OBJNULL.")

(docfun si::locativep function (object) "
ECL specific.
Returns true if OBJECT is bound to a locative.")

(docfun si::make-variable function (name) "
ECL specific. 
Creates a new logical variable with name name implemented as a cons. 
Name is used just for printing purposes.")

(docfun si::get-constant function (constant object) "
ECL specific.
The value of OBJECT is unified with the constant CONSTANT.
Returns T if successful, otherwise NIL.")

(docfun si::get-cons function (object) "
ECL specific.
The value of OBJECT is unified with a CONS cell.
Returns T if successful, otherwise NIL.")

(docfun si::get-instance function (object class arity) "
ECL specific.
The value of OBJECT is unified with an instance of class CLASS
with ARITY number of slots.
Returns T if successful, otherwise NIL.")

(docfun si::get-value function (variable object) "
ECL specific.
The value of VARIABLE and OBJECT are unified.
Returns T if successful, otherwise NIL.")

(docfun get-variable macro (variable object) "
ECL specific.
Identical to SETQ: assigns to the variable VARIABLE the value OBJECT.")

(docfun si::get-nil function (object) "
ECL specific.
The value of OBJECT is unified with the constant NIL.
Returns T if successful, otherwise NIL.")

(docfun si::trail-mark function () "
ECL specific.
Sets up a choice point by putting a mark on the trail stack for
backtracking.")

(docfun si::trail-restore function () "
ECL specific.
Unwinds the trail stack up to the latest choice point.")

(docfun si::trail-unmark function () "
ECL specific.
Does a TRAIL-RESTORE and also removes the latest choice point.")

(docfun si::unboundp function (locative) "
ECL specific.
Returns true if LOCATIVE is bound to OBJNULL.")

(docfun si::unify-constant function (constant) "
ECL specific.
Read mode: the next subterm is unified with the constant CONSTANT.
Write mode: the constant constant is stored as the next subterm.")

(docfun si::unify-nil function () "
ECL specific.
Read mode: the next subterm is unified with the constant NIL.
Write mode: the constant NIL is stored as the next subterm.")

(docfun si::unify-value function (variable) "
ECL specific.
Read mode: the value of VARIABLE is unified with the next subterm.
Write mode: the value of VARIABLE is stored as the next subterm.")

(docfun si::unify-variable macro (variable) "
ECL specific.
Read mode: VARIABLE is assigned the next subterm.
Write mode: a new variable is stored in VARIABLE as the next subterm.")

||#
;;;----------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/doc/help.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/cmp/proclamations.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: C -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;
;;; PROCLAMATIONS of ECL and ANSI Common Lisp functions
;;;
;;; Copyright (c) 2010, Juan Jose Garcia Ripoll
;;;    Copying of this file is authorized to users who have executed the true
;;;    and proper "License Agreement for ECL".
;;;
;;; The function proclamations are created with PROCLAIM-FUNCTION, as in
;;;
;;;     (PROCLAMATION function-name ([arg-type]*) return-type
;;;             &rest {:no-sp-change|:pure|:reader|:no-side-effects})
;;;
;;; with the following interpretation: ARG-TYPE and RETURN-TYPE denote the most
;;; general types for the input and output values of this function. If the
;;; compiler detects that some of the values passed to this function does not
;;; match these types, it will generate an error. In addition to this, ECL
;;; contemplates different function properties:
;;;
;;; :NO-SP-CHANGE indicates that the function does not change the value of any
;;;        special variable, and it is used to perform code transformations.
;;;
;;; :NO-SIDE-EFFECTS is slightly stronger, as it indicates that the function
;;;        does not change variables or the content of objects in the
;;;        thread environment. Note the following:
;;;
;;;    - Allocating memory, creating objects, etc is not considered a side
;;;      effect, as it does not affect the code flow.
;;;    - Similarly, signalling errors is not considered a side effect.
;;;    - The environment may be changed by other threads. This is taken
;;;      into account (see below).
;;;
;;; :READER indicates that the function not only has no side effects, but its
;;;        value depends only on its arguments. However, :READER specifies that
;;;        the arguments are mutable.
;;;
;;; :PURE is the strictest class of functions. They have no side effects, the
;;;        output only depends on the arguments, the arguments are immutable
;;;        objects and the function call can be optimized away when the
;;;        arguments are constant.
;;;

(in-package "C")

(defun parse-function-proclamation
    (name arg-types return-type &rest properties)
  (when (sys:get-sysprop name 'proclaimed-arg-types)
    (warn "Duplicate proclamation for ~A" name))
  (proclaim-function
   name (list arg-types return-type))
  (loop for p in properties
     do (case p
          (:no-sp-change
           (sys:put-sysprop name 'no-sp-change t))
          ((:predicate :pure)
           (sys:put-sysprop name 'pure t)
           (sys:put-sysprop name 'no-side-effects t))
          ((:no-side-effects :reader)
           (sys:put-sysprop name 'no-side-effects t))
          (otherwise
           (error "Unknown property ~S in function proclamation for ~S"
                  p name)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; AUXILIARY TYPES
;;

(deftype array-rank-index ()
  '(integer 0 #.(1- array-rank-limit)))
(deftype bit-array ()
  '(array bit *))
(deftype association-list ()
  'list
  #+(or)
  '(or null (cons cons association-list)))
(deftype byte-specifier ()
  "The type of the output of BYTE."
  '(cons integer-length integer-length))
(deftype character-code ()
  '(integer 0 #.(1- char-code-limit)))
(deftype character-designator ()
  '(or character string-designator))
(deftype external-file-format ()
  '(or symbol list))
(deftype declaration-specifier ()
  "Element that can appear in a DECLARE form"
  'list)
(deftype digit-weight ()
  '(integer 0 35))
(deftype environment ()
  "Environment used by compiler and interpreter"
  'list)
(deftype form ()
  "Valid lisp form"
  t)
(deftype format-control ()
  "Format control for FORMAT. It can be a string or a function returned by FORMATTER."
  '(or string function))
(deftype function-designator ()
  "An object that denotes a function and which can be a symbol or a function."
  '(or symbol function))
(deftype function-name ()
  "Valid name of a function, typically a symbol or (SETF symbol)"
  '(or list symbol))
(deftype gen-bool ()
  "Generalized boolean type"
  't)
(deftype integer-length ()
  "A type that fits maximum number of bits that an integer may have in this system"
  'ext:array-index)
(deftype natural ()
  "Non-negative number"
  '(integer 0 *))
(deftype package-designator ()
  '(or string-designator package))
(deftype pathname-designator ()
  '(or pathname string file-stream))
(deftype pathname-device ()
  '(or string (member nil :unspecific)))
(deftype pathname-directory ()
  '(or string list (member :wild :unspecific)))
(deftype pathname-host ()
  '(or string list (member nil :unspecific)))
(deftype pathname-name ()
  '(or string (member nil :wild :unspecific)))
(deftype pathname-type ()
  '(or string (member nil :wild :unspecific)))
(deftype pathname-version ()
  '(or unsigned-byte (member nil :wild :newest :unspecific)))
(deftype proper-list ()
  'list
  #+(or)
  '(or null (cons t proper-list)))
(deftype property-list ()
  'list
  #+(or)
  '(or null (cons t (cons t property-list))))
(deftype radix ()
  '(integer 2 36))
(deftype readtable-designator ()
  '(or null readtable))
(deftype restart-designator ()
  "Either a symbol naming a restart, or the restart object itself."
  '(or (and symbol (not null)) restart))
(deftype sequence-index ()
  '(integer 0 #.array-total-size-limit))
(deftype stream-designator ()
  '(or stream (member t nil)))
(deftype string-designator ()
  '(or symbol string character))
(deftype tree ()
  't)
(deftype type-specifier ()
  "Name or object representing a time."
  '(or symbol class list))
(deftype universal-time ()
  "Time represented as a non-negative number of seconds measured from the beginning of 1900."
  'unsigned-byte)
(deftype time-zone ()
  t)
(deftype ext:instance ()
  'standard-object)

(proclaim '(notinline ext:constantp-inner ext:constant-form-value))

(eval-when (:compile-toplevel :execute)
(defparameter +proclamations+ '(
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; ALL FUNCTION DECLARATIONS
;;;
;;;
;;; ANSI SECTIONS
;;;
;;; 3. EVALUATION AND COMPILATION
;;;

(proclamation compile (function-name &optional (or list function))
              (values (or function-name function) gen-bool gen-bool))
(proclamation compiler-macro-function (function-name &optional environment)
              function)
(proclamation constantp (t &optional environment) gen-bool)
(proclamation eval (form) (values &rest t))
(proclamation macro-function (symbol &optional environment) function)
(proclamation macroexpand (form &optional environment) (values form gen-bool))
(proclamation macroexpand-1 (form &optional environment) (values form gen-bool))
(proclamation proclaim (declaration-specifier) (values &rest t))
(proclamation special-operator-p (symbol) gen-bool :pure)

;; ECL extensions:
(proclamation si:specialp (symbol) gen-bool :predicate)
(proclamation si::do-defsetf (symbol (or symbol function) &optional list) t)
(proclamation si::do-define-setf-method (symbol function) t)
(proclamation ext:constant-form-value (t &optional environment) t)
(proclamation ext:constantp-inner (t &optional environment) gen-bool)

;;;
;;; 4. TYPES AND CLASSES
;;;

(proclamation coerce (t type-specifier) t)
(proclamation subtypep (type-specifier type-specifier &optional environment)
              (values gen-bool gen-bool))
(proclamation type-of (t) type-specifier)
(proclamation typep (t type-specifier &optional environment) gen-bool)

; Slot accessors:
; (proclamation type-error-datum (condition) t)
; (proclamation type-error-expected-type (condition) t)

;; ECL EXTENSIONS
(proclamation si::coerce-to-vector (t type-specifier t gen-bool) vector :no-side-effects)
(proclamation si::coerce-to-function (function-designator) function :no-side-effects)

;;;
;;; 5. DATA AND CONTROL FLOW
;;;

(proclamation apply (function-designator &rest t) (values &rest t))
(proclamation fdefinition (function-name) (or list function (member 'SPECIAL)) :reader)
(proclamation fboundp (function-name) gen-bool :reader)
(proclamation fmakunbound (function-name) function-name)
(proclamation funcall (function-designator &rest t) (values &rest t))
(proclamation function-lambda-expression (function) (values list gen-bool t) :pure)
(proclamation functionp (t) gen-bool :pure)
(proclamation compiled-function-p (t) gen-bool :pure)
(proclamation not (gen-bool) boolean :pure)
(proclamation eq (t t) gen-bool :pure)
(proclamation eql (t t) gen-bool :pure)
(proclamation equal (t t) gen-bool :pure)
(proclamation equalp (t t) gen-bool :pure)
(proclamation identity (t) t)
(proclamation complement (function) function)
(proclamation constantly (t) function)
(proclamation every (function-designator sequence &rest sequence) gen-bool)
(proclamation some (function-designator sequence &rest sequence) t)
(proclamation notevery (function-designator sequence &rest sequence) gen-bool)
(proclamation notany (function-designator sequence &rest sequence) gen-bool)
(proclamation values-list (list) (values &rest t))
(proclamation get-setf-expansion (t &optional environment) (values t t t t t))

;; ECL extensions

(proclamation si:fset (function-name function &optional gen-bool t) function)
(proclamation si:setf-definition (function-name createp) list)
(proclamation ext:compiled-function-name (function) (or null function-name))
(proclamation si:compiled-function-block (function) (or null si::codeblock))
(proclamation ext:compiled-function-file (function) (values t t))

(proclamation ext:constantly-t () function)

(proclamation si:ihs-top () si::index)
(proclamation si:ihs-fun (si::index) (or null function-designator))
(proclamation si:ihs-env (si::index) environment)
(proclamation si:frs-top () si::index)
(proclamation si:frs-bds (si::index) si::index)
(proclamation si:frs-tag (si::index) t)
(proclamation si:frs-ihs (si::index) si::index)
(proclamation si:bds-top () si::index)
(proclamation si:bds-var (si::index) symbol)
(proclamation si:bds-val (si::index) t)
(proclamation si:sch-frs-base (si::index si::index) (or null si::index))

(proclamation si::ccase-error (t t t) t)
(proclamation si::ecase-error (t t) t)
(proclamation si::etypecase-error (t t) t)
(proclamation si::ctypecase-error (t t t) t)
(proclamation si::do-check-type (t t t t) t)

(proclamation si::dm-too-many-arguments (t) t)
(proclamation si::dm-too-few-arguments (t) t)

;;;
;;; 7. OBJECTS
;;;

#+clos
(proclamation ensure-generic-function (function-name &rest t) generic-function)
#+clos
(proclamation slot-boundp (si::instance symbol) gen-bool)
#+clos
(proclamation slot-exists-p (si::instance symbol) gen-bool)
#+clos
(proclamation slot-makunbound (si::instance symbol) si::instance)
#+clos
(proclamation slot-value (si::instance symbol) t)
#+clos
(proclamation make-load-form-saving-slots (t &rest t) (values t t))
#+clos
(proclamation find-class (symbol &optional gen-bool environment)
                   (or class null))
#+clos
(proclamation class-of (t) class :no-side-effects)

;; Slot accessors:
; (proclamation unbound-slot-instance (condition) si::instance :predicate)

#+clos
(proclamation clos::standard-instance-set (t ext:instance t) t)
#+clos
(proclamation clos:std-compute-applicable-methods (generic-function list) list)
#+clos
(proclamation clos:std-compute-effective-method (generic-function method-combination list) function)
#+clos
(proclamation clos:compute-effective-method-function (generic-function method-combination list) function)
#+clos
(proclamation clos::update-instance (ext:instance) (values))
#+clos
(proclamation clos::slot-value-set (t si::instance symbol) t)
#+clos
(proclamation clos:extract-lambda-list (list) list)
#+clos
(proclamation clos:extract-specializer-names (list) list)

;;;
;;; 8. STRUCTURES
;;;

(proclamation copy-structure (t) t)

;; ECL extensions
(proclamation si:make-structure (t &rest t) structure-object)
(proclamation si:structure-name (structure-object) symbol :reader)
(proclamation si:structure-ref (structure-object t fixnum) t :reader)
(proclamation si:structure-set (structure-object t fixnum t) t)
(proclamation si:structurep (t) gen-bool :predicate)
(proclamation si:structure-subtype-p (t t) gen-bool :predicate)

;;;
;;; 9. CONDITIONS
;;;

(proclamation error (t &rest t) (values))
;; FIXME! It is not clear from the specification whether CERROR actually
;; returns values. However ECL is actually using the fact that it returns
;; the value from CONTINUE.
(proclamation cerror (format-control t &rest t) (values &rest t))
(proclamation invalid-method-error (method format-control &rest t) (values))
(proclamation method-combination-error (format-control &rest t) (values))
(proclamation signal (t &rest t) null)
(proclamation warn (t &rest t) null)
(proclamation invoke-debugger (condition) (values))
(proclamation break (&optional format-control &rest t) null)
(proclamation make-condition (type-specifier &rest t) condition)
(proclamation compute-restarts (&optional (or null condition)) list)
(proclamation find-restart
                   (restart-designator &optional (or null condition))
                   restart)
(proclamation invoke-restart (restart-designator &rest t)
                   (values &rest t))
(proclamation invoke-restart-interactively (restart-designator)
                   (values &rest t))
(proclamation abort (&optional (or null condition)) (values))
(proclamation continue (&optional (or null condition)) null)
(proclamation muffle-warning (&optional (or null condition)) (values))
(proclamation store-value (t &optional (or null condition)) null)
(proclamation use-value (t &optional (or null condition)) null)

;; Slot accessors:
;; (proclamation cell-error-name (cell-error) t)
;; (proclamation simple-condition-format-control (simple-condition) t)
;; (proclamation simple-condition-format-arguments (simple-condition) t)
;; (proclamation restart-name (restart) t)

;; ECL extensions
(proclamation ext:catch-signal (fixnum gen-bool &key) null)
(proclamation si:bind-simple-restarts (t t) list)
(proclamation si:bind-simple-handlers (t t) list)

;;;
;;; 10. SYMBOLS
;;;

(proclamation symbolp (t) gen-bool :pure)
(proclamation keywordp (t) gen-bool :reader)
(proclamation make-symbol (string) symbol)
(proclamation copy-symbol (symbol &optional gen-bool) symbol)
(proclamation gensym (&optional (or string natural)) symbol)
(proclamation gentemp (&optional string package-designator) symbol)
(proclamation symbol-function (symbol)
                   (or function list (member 'special))
                   :reader)
(proclamation symbol-name (symbol) string :pure)
(proclamation symbol-package (symbol) (or package null) :reader)
(proclamation symbol-plist (symbol) list :reader)
(proclamation symbol-value (symbol) t :reader)
(proclamation get (symbol t &optional t) t :no-side-effects)
(proclamation remprop (symbol t) gen-bool)
(proclamation boundp (symbol) gen-bool :reader)
(proclamation makunbound (symbol) symbol)
(proclamation set (symbol t) t)

;; ECL extensions:
(proclamation si:*make-special (symbol) symbol)
(proclamation si:*make-constant (symbol t) symbol)
(proclamation si:put-f (list t t) list)
(proclamation si:rem-f (list t) (values list boolean))
(proclamation si:set-symbol-plist (symbol list) list)
(proclamation si:putprop (symbol t t) t)
(proclamation si:put-sysprop (t t t) t)
(proclamation si:get-sysprop (t t) (values t boolean))
(proclamation si:rem-sysprop (t t) boolean)
(proclamation si:put-properties (symbol &rest t) symbol :no-sp-change)


;;;
;;; 11. PACKAGES
;;;

(proclamation export (list &optional package-designator) t)
(proclamation find-symbol (string &optional package-designator)
              (values symbol (member :inherited :external :internal nil)))
(proclamation find-package (package-designator) (or package null))
(proclamation find-all-symbols (string-designator) list)
(proclamation import (list &optional package-designator) t)
(proclamation list-all-packages () list)
(proclamation rename-package (package-designator package-designator
                              &optional list) package)
(proclamation shadow (list &optional package-designator) t)
(proclamation shadowing-import (list &optional package-designator) t)
(proclamation delete-package (package-designator) gen-bool)
(proclamation make-package (string-designator &rest t) package)
(proclamation unexport (list &optional package-designator) t)
(proclamation unintern (symbol &optional package-designator) gen-bool)
(proclamation unuse-package (list &optional package-designator) t)
(proclamation use-package (list &optional package-designator) t)
(proclamation intern (string &optional package-designator)
              (values symbol (member :inherited :external :internal nil)))
(proclamation package-name (package-designator) (or string null) :reader)
(proclamation package-nicknames (package-designator) list :reader)
(proclamation package-shadowing-symbols (package-designator) list :reader)
(proclamation package-use-list (package-designator) list :reader)
(proclamation package-used-by-list (package-designator) list :reader)
(proclamation packagep (t) gen-bool :pure)

;; Slot accessor:
;; (proclamation package-error-package (condition) package)

;; ECL extensions
(proclamation si:select-package (package-designator) package)
(proclamation si:package-hash-tables (package-designator)
                   (values hash-table hash-table list) :reader)
(proclamation ext:package-lock (package-designator gen-bool) package)
(proclamation ext:package-local-nicknames
 (package-designator) list :no-side-effects)
(proclamation ext:package-locally-nicknamed-by-list
 (package-designator) list :no-side-effects)
(proclamation si:%add-package-local-nickname
 (string-designator package-designator package-designator) package)
(proclamation si:%remove-package-local-nickname
 (string-designator package-designator) list)
(proclamation ext:add-package-local-nickname
 (string-designator package-designator &optional package-designator) package)
(proclamation ext:remove-package-local-nickname
 (string-designator &optional package-designator) list)

;;;
;;; 12. NUMBERS
;;;

(proclamation = (number &rest number) gen-bool :pure)
(proclamation /= (number &rest number) gen-bool :pure)
(proclamation < (real &rest real) gen-bool :pure)
(proclamation > (real &rest real) gen-bool :pure)
(proclamation <= (real &rest real) gen-bool :pure)
(proclamation >= (real &rest real) gen-bool :pure)
(proclamation max (real &rest real) real :pure)
(proclamation min (real &rest real) real :pure)
(proclamation minusp (real) gen-bool :pure)
(proclamation plusp (real) gen-bool :pure)
(proclamation zerop (number) gen-bool :pure)
(proclamation floor (real &optional real) (values integer real) :pure)
(proclamation ceiling (real &optional real) (values integer real) :pure)
(proclamation truncate (real &optional real) (values integer real) :pure)
(proclamation round (real &optional real) (values integer real) :pure)
(proclamation ffloor (real &optional real) (values float real) :pure)
(proclamation fceiling (real &optional real) (values float real) :pure)
(proclamation ftruncate (real &optional real) (values float real) :pure)
(proclamation fround (real &optional real) (values float real) :pure)
(proclamation cos (number) number :pure)
(proclamation sin (number) number :pure)
(proclamation tan (number) number :pure)
(proclamation cosh (number) number :pure)
(proclamation sinh (number) number :pure)
(proclamation tanh (number) number :pure)
(proclamation acos (number) number :pure)
(proclamation asin (number) number :pure)
(proclamation atan (number &optional real) number :pure)
(proclamation acosh (number) number :pure)
(proclamation asinh (number) number :pure)
(proclamation atanh (number) number :pure)
(proclamation * (&rest number) number :pure)
(proclamation + (&rest number) number :pure)
(proclamation - (&rest number) number :pure)
(proclamation / (number &rest number) number :pure)
(proclamation 1+ (number) number :pure)
(proclamation 1- (number) number :pure)
(proclamation abs (number) (real 0 *) :pure)
(proclamation evenp (integer) gen-bool :pure)
(proclamation oddp (integer) gen-bool :pure)
(proclamation exp (number) number :pure)
(proclamation expt (number number) number :pure)
(proclamation gcd (&rest integer) unsigned-byte :pure)
(proclamation lcm (&rest integer) unsigned-byte :pure)
(proclamation log (number &optional number) number :pure)
(proclamation mod (real real) real :pure)
(proclamation rem (real real) real :pure)
(proclamation signum (number) number :pure)
(proclamation sqrt (number) number :pure)
(proclamation isqrt (natural) natural :pure)
(proclamation make-random-state (&optional (or random-state (member nil t)))
              random-state :no-side-effects)
(proclamation random ((or (integer 0 *) (float 0 *)) &optional random-state)
              (or (integer 0 *) (float 0 *)))
(proclamation random-state-p (t) gen-bool :pure)
(proclamation numberp (t) gen-bool :pure)
(proclamation cis (real) complex :pure)
(proclamation complex (real &optional real) number :pure)
(proclamation complexp (t) gen-bool :pure)
(proclamation conjugate (number) number :pure)
(proclamation phase (number) (real #.(- pi) #.pi) :pure)
(proclamation realpart (number) real :pure)
(proclamation imagpart (number) real :pure)
(proclamation upgraded-complex-part-type
              (type-specifier &optional environment)
              type-specifier
              :no-side-effects)
(proclamation realp (t) gen-bool :pure)
(proclamation numerator (rational) integer :pure)
(proclamation denominator (rational) unsigned-byte :pure)
(proclamation rational (real) rational :pure)
(proclamation rationalize (real) rational :pure)
(proclamation rationalp (t) gen-bool :pure)
(proclamation ash (integer integer) integer :pure)
(proclamation integer-length (integer) integer-length :pure)
(proclamation integerp (t) gen-bool :pure)
(proclamation parse-integer (string &rest t)
              (values integer ext:array-index)
              :no-side-effects)
(proclamation boole ((integer 0 15) integer integer) integer :pure)
(proclamation logand (&rest integer) integer :pure)
(proclamation logandc1 (integer integer) integer :pure)
(proclamation logandc2 (integer integer) integer :pure)
(proclamation logeqv (&rest integer) integer :pure)
(proclamation logior (&rest integer) integer :pure)
(proclamation lognand (integer integer) integer :pure)
(proclamation lognor (integer integer) integer :pure)
(proclamation lognot (integer) integer :pure)
(proclamation logorc1 (integer integer) integer :pure)
(proclamation logorc2 (integer integer) integer :pure)
(proclamation logxor (&rest integer) integer :pure)
(proclamation logbitp (unsigned-byte integer) gen-bool :pure)
(proclamation logcount (integer) integer-length :pure)
(proclamation logtest (integer integer) gen-bool :pure)
(proclamation byte (unsigned-byte unsigned-byte) byte-specifier :pure)
(proclamation byte-size (byte-specifier) integer-length :pure)
(proclamation byte-position (byte-specifier) integer-length :pure)
(proclamation deposit-field (integer byte-specifier integer) integer :pure)
(proclamation dpb (integer byte-specifier integer) integer :pure)
(proclamation ldb (byte-specifier integer) unsigned-byte :pure)
(proclamation ldb-test (byte-specifier integer) gen-bool :pure)
(proclamation mask-field (byte-specifier integer) unsigned-byte :pure)
(proclamation decode-float (float) (values float integer float) :pure)
(proclamation scale-float (float integer) float :pure)
(proclamation float-radix (float) fixnum :pure)
(proclamation float-sign (float &optional float) float :pure)
(proclamation float-digits (float)
              (integer 0 #.(float-digits (coerce 1.0 'long-float)))
              :pure)
(proclamation float-precision (float)
              (integer 0 #.(float-digits (coerce 1.0 'long-float)))
              :pure)
(proclamation integer-decode-float (float)
              (values integer integer (member -1 1))
              :pure)
(proclamation float (number &optional float) float :pure)
(proclamation floatp (t) gen-bool :pure)

;; Slot accessors:
;; (proclamation arithmetic-error-operands (condition) t)
;; (proclamation arithmetic-error-operation (condition) t)

;; ECL extensions
(proclamation si:bit-array-op (t t t t) (array bit))
(proclamation ext:fixnump (t) gen-bool :pure)
(proclamation si:ratiop (t) gen-bool :pure)
(proclamation si:short-float-p (t) gen-bool :pure)
(proclamation si:single-float-p (t) gen-bool :pure)
(proclamation si:double-float-p (t) gen-bool :pure)
(proclamation si:long-float-p (t) gen-bool :pure)

;; Virtual functions added by the compiler
(proclamation shift>> (*) nil :pure)
(proclamation shift<< (*) nil :pure)
(proclamation c::ldb1 (fixnum fixnum fixnum) fixnum :no-side-effects)


;;;
;;; 13. CHARACTERS
;;;

(proclamation char= (character &rest character) gen-bool :pure)
(proclamation char/= (character &rest character) gen-bool :pure)
(proclamation char< (character &rest character) gen-bool :pure)
(proclamation char> (character &rest character) gen-bool :pure)
(proclamation char<= (character &rest character) gen-bool :pure)
(proclamation char>= (character &rest character) gen-bool :pure)
(proclamation char-equal (character &rest character) gen-bool :pure)
(proclamation char-not-equal (character &rest character) gen-bool :pure)
(proclamation char-lessp (character &rest character) gen-bool :pure)
(proclamation char-greaterp (character &rest character) gen-bool :pure)
(proclamation char-not-greaterp (character &rest character) gen-bool :pure)
(proclamation char-not-lessp (character &rest character) gen-bool :pure)
(proclamation character (character-designator) character)
(proclamation characterp (t) gen-bool :pure)
(proclamation alpha-char-p (character) gen-bool :pure)
(proclamation alphanumericp (character) gen-bool :pure)
(proclamation digit-char (digit-weight &optional radix) character :pure)
(proclamation digit-char-p (character &optional radix)
              (or digit-weight null)
              :pure)
(proclamation graphic-char-p (character) gen-bool :pure)
(proclamation standard-char-p (character) gen-bool :pure)
(proclamation char-upcase (character) character :pure)
(proclamation char-downcase (character) character :pure)
(proclamation upper-case-p (character) gen-bool :pure)
(proclamation lower-case-p (character) gen-bool :pure)
(proclamation both-case-p (character) gen-bool :pure)
(proclamation char-code (character) character-code :pure)
(proclamation char-int (character) character-code :pure)
(proclamation code-char (character-code) (or character null) :pure)
(proclamation char-name (character) (or string null) :pure)
(proclamation name-char (string-designator) (or character null) :pure)

;; ECL extensions
(proclamation si:base-char-p (t) gen-bool :predicate)

;;;
;;; 14. CONSES
;;;

(proclamation cons (t t) cons :no-side-effects)
(proclamation consp (t) gen-bool :pure)
(proclamation atom (t) gen-bool :pure)
(proclamation rplaca (cons t) cons)
(proclamation rplacd (cons t) cons)
(proclamation car (list) t :reader)
(proclamation cdr (list) t :reader)
(proclamation caar (list) t :reader)
(proclamation cadr (list) t :reader)
(proclamation cdar (list) t :reader)
(proclamation cddr (list) t :reader)
(proclamation caaar (list) t :reader)
(proclamation caadr (list) t :reader)
(proclamation cadar (list) t :reader)
(proclamation caddr (list) t :reader)
(proclamation cdaar (list) t :reader)
(proclamation cdadr (list) t :reader)
(proclamation cddar (list) t :reader)
(proclamation cdddr (list) t :reader)
(proclamation caaaar (list) t :reader)
(proclamation caaadr (list) t :reader)
(proclamation caadar (list) t :reader)
(proclamation caaddr (list) t :reader)
(proclamation cadaar (list) t :reader)
(proclamation cadadr (list) t :reader)
(proclamation caddar (list) t :reader)
(proclamation cadddr (list) t :reader)
(proclamation cdaaar (list) t :reader)
(proclamation cdaadr (list) t :reader)
(proclamation cdadar (list) t :reader)
(proclamation cdaddr (list) t :reader)
(proclamation cddaar (list) t :reader)
(proclamation cddadr (list) t :reader)
(proclamation cdddar (list) t :reader)
(proclamation cddddr (list) t :reader)
(proclamation copy-tree (tree) tree :no-side-effects)
(proclamation sublis (association-list tree &key) tree)
(proclamation nsublis (association-list tree &key) tree)
(proclamation subst (t t tree &key) tree)
(proclamation subst-if (t function-designator tree &key) tree)
(proclamation subst-if-not (t function-designator tree &key) tree)
(proclamation nsubst (t t tree &key) tree)
(proclamation nsubst-if (t function-designator tree &key) tree)
(proclamation nsubst-if-not (t function-designator tree &key) tree)
(proclamation tree-equal (tree tree &key) gen-bool :predicate)
(proclamation copy-list (list) list :no-side-effects)
(proclamation list (&rest t) list :no-side-effects)
(proclamation list* (&rest t) t :no-side-effects)
(proclamation list-length (list) (or null si::index) :no-side-effects)
(proclamation listp (t) gen-bool :pure)
(proclamation make-list (si::index &key) list :no-side-effects)
(proclamation first (list) t :reader)
(proclamation second (list) t :reader)
(proclamation third (list) t :reader)
(proclamation fourth (list) t :reader)
(proclamation fifth (list) t :reader)
(proclamation sixth (list) t :reader)
(proclamation seventh (list) t :reader)
(proclamation eighth (list) t :reader)
(proclamation ninth (list) t :reader)
(proclamation tenth (list) t :reader)
(proclamation nth (unsigned-byte list) t :reader)
(proclamation endp (list) gen-bool :predicate)
(proclamation null (t) gen-bool :predicate)
(proclamation nconc (&rest t) t)
(proclamation append (&rest t) t :no-side-effects)
(proclamation revappend (list t) t :no-side-effects)
(proclamation nreconc (list t) t)
(proclamation butlast (list &optional unsigned-byte) list :no-side-effects)
(proclamation nbutlast (list &optional unsigned-byte) list)
(proclamation last (list &optional unsigned-byte) t :reader)
(proclamation ldiff (list t) list :no-side-effects)
(proclamation tailp (t list) gen-bool :reader)
(proclamation nthcdr (fixnum list) t :reader)
(proclamation rest (list) t :no-side-effects)
(proclamation member (t proper-list &key) proper-list)
(proclamation member-if (function-designator proper-list &key) proper-list)
(proclamation member-if-not (function-designator proper-list &key)
              proper-list)
(proclamation mapc (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation mapcar (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation mapcan (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation mapl (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation maplist (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation mapcon (function-designator proper-list &rest proper-list)
              proper-list)
(proclamation acons (t t association-list) association-list :no-side-effects)
(proclamation assoc (t association-list &key) t)
(proclamation assoc-if (function-designator association-list &key) t)
(proclamation assoc-if-not (function-designator association-list &key) t)
(proclamation copy-alist (association-list) association-list :no-side-effects)
(proclamation pairlis (proper-list proper-list &optional association-list)
              association-list :no-side-effects)
(proclamation rassoc (t association-list &key) t)
(proclamation rassoc-if (function-designator association-list &key) t)
(proclamation rassoc-if-not (function-designator association-list &key) t)
(proclamation get-properties (property-list proper-list)
              (values t t list) :no-side-effects)
(proclamation getf (property-list t &optional t) t :reader)
(proclamation intersection (proper-list proper-list &key) proper-list)
(proclamation nintersection (proper-list proper-list &key) proper-list)
(proclamation adjoin (t proper-list &key) proper-list)
(proclamation set-difference (proper-list proper-list &key) proper-list)
(proclamation nset-difference (proper-list proper-list &key) proper-list)
(proclamation set-exclusive-or (proper-list proper-list &key) proper-list)
(proclamation nset-exclusive-or (proper-list proper-list &key) proper-list)
(proclamation subsetp (proper-list proper-list &key) gen-bool :predicate)
(proclamation union (proper-list proper-list &key) proper-list)
(proclamation nunion (proper-list proper-list &key) proper-list)

;; ECL extensions
(proclamation si:member1 (t proper-list t t t) list)
(proclamation si:memq (t proper-list) list)
(proclamation si:cons-car (cons) t :reader)
(proclamation si:cons-cdr (cons) t :reader)
(proclamation si::proper-list-p (t) gen-bool :predicate)

;;;
;;; 15. ARRAYS
;;;

(proclamation make-array ((or ext:array-index list) &key)
              array :no-side-effects)
(proclamation adjust-array (array (or ext:array-index list) &key) array)
(proclamation adjustable-array-p (array) gen-bool :pure)
(proclamation aref (array &rest ext:array-index) t :reader)
(proclamation array-dimension (array array-rank-index)
              ext:array-index :reader)
(proclamation array-dimensions (array) list :reader)
(proclamation array-element-type (array) type-specifier :pure)
(proclamation array-has-fill-pointer-p (array) gen-bool :pure)
(proclamation array-displacement (array)
              (values (or array null) ext:array-index)
              :reader)
(proclamation array-in-bounds-p (array &rest ext:array-index) gen-bool
              :no-side-effects)
(proclamation array-rank (array) array-rank-index :reader)
(proclamation array-row-major-index (array &rest ext:array-index)
              ext:array-index :no-side-effects)
(proclamation array-total-size (array) ext:array-index :reader)
(proclamation arrayp (t) gen-bool :pure)
(proclamation fill-pointer (vector) ext:array-index :reader)
(proclamation row-major-aref (array ext:array-index) t :reader)
(proclamation upgraded-array-element-type
              (type-specifier &optional environment)
              type-specifier :no-side-effects)
(proclamation simple-vector-p (t) gen-bool :pure)
(proclamation svref (simple-vector ext:array-index) t :reader)
(proclamation vector (&rest t) vector :no-side-effects)
(proclamation vector-pop (vector) t)
(proclamation vector-push (t vector) (or ext:array-index null))
(proclamation vector-push-extend (t vector &optional ext:array-index)
              ext:array-index)
(proclamation vectorp (t) gen-bool :pure)
(proclamation bit (bit-array &rest ext:array-index) bit :reader)
(proclamation sbit ((simple-array bit) &rest ext:array-index)
              bit :reader)
(proclamation bit-and (bit-array bit-array &optional
                       (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-andc1 (bit-array bit-array &optional
                         (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-andc2 (bit-array bit-array &optional
                         (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-eqv (bit-array bit-array &optional
                       (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-ior (bit-array bit-array &optional
                       (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-nand (bit-array bit-array &optional
                        (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-nor (bit-array bit-array &optional
                            (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-orc1 (bit-array bit-array &optional
                        (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-orc2 (bit-array bit-array &optional
                        (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-xor (bit-array bit-array &optional
                       (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-not (bit-array &optional (or bit-array (member t nil)))
              bit-array :no-side-effects)
(proclamation bit-vector-p (t) gen-bool :pure)
(proclamation simple-bit-vector-p (t) t :pure)

;; ECL extensions
(proclamation si:make-pure-array (t t t t t t) array)
(proclamation si:make-vector (t t t t t t) vector)
(proclamation si:aset (array t &rest t) t)
(proclamation si:row-major-aset (array ext:array-index t) t)
(proclamation si:svset (simple-vector ext:array-index t) t)
(proclamation si:fill-pointer-set (vector ext:array-index) ext:array-index)
(proclamation si:replace-array (array array) array)

;;;
;;; 16. STRINGS
;;;

(proclamation simple-string-p (t) gen-bool :pure)
(proclamation char (string ext:array-index) character :reader)
(proclamation schar (simple-string ext:array-index) character :reader)
(proclamation string (string-designator) string :no-side-effects)
(proclamation string-upcase (string-designator &key)
              string :no-side-effects)
(proclamation string-downcase (string-designator &key)
              string :no-side-effects)
(proclamation string-capitalize (string-designator &key)
              string :no-side-effects)
(proclamation nstring-upcase (string &key) string)
(proclamation nstring-downcase (string &key) string)
(proclamation nstring-capitalize (string &key) string)
(proclamation string-trim (sequence string-designator)
              string :no-side-effects)
(proclamation string-left-trim (sequence string-designator)
              string :no-side-effects)
(proclamation string-right-trim (sequence string-designator)
              string :no-side-effects)
(proclamation string= (string-designator string-designator &key)
              gen-bool :no-side-effects)
(proclamation string/= (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string< (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string> (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string<= (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string>= (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string-equal (string-designator string-designator &key)
              gen-bool :no-side-effects)
(proclamation string-not-equal (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string-lessp (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string-greaterp (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string-not-lessp (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation string-not-greaterp (string-designator string-designator &key)
              (or ext:array-index null) :no-side-effects)
(proclamation stringp (t) gen-bool :predicate)
(proclamation make-string (ext:array-index &key) string :no-side-effects)

;; ECL extensions:
(proclamation si:base-string-p (t) gen-bool :pure)
(proclamation si:char-set (string ext:array-index character) character)
(proclamation si:schar-set (string ext:array-index character) character)
(proclamation si:base-string-concatenate (&rest base-string) base-string)

;;;
;;; 17. SEQUENCES
;;;

(proclamation copy-seq (sequence) sequence :no-side-effects)
(proclamation elt (sequence sequence-index) t :no-side-effects)
(proclamation fill (sequence t &key) sequence)
(proclamation make-sequence (type-specifier sequence-index &key)
              sequence :no-side-effects)
(proclamation subseq (sequence sequence-index &optional (or sequence-index null))
              sequence :no-side-effects)
(proclamation map (type-specifier function-designator sequence &rest sequence)
              sequence)
(proclamation map-into (sequence function-designator &rest sequence)
              sequence)
(proclamation reduce (function-designator sequence &key) t)
(proclamation count (t sequence &key) sequence-index)
(proclamation count-if (function-designator sequence &key) sequence-index)
(proclamation count-if-not (function-designator sequence &key) sequence-index)
(proclamation length (sequence) sequence-index :no-side-effects)
(proclamation reverse (sequence) sequence :no-side-effects)
(proclamation nreverse (sequence) sequence)
(proclamation sort (sequence function-designator &key) sequence)
(proclamation stable-sort (sequence function-designator &key) sequence)
(proclamation find (t sequence &key) t :no-side-effects)
(proclamation find-if (function-designator sequence &key) t)
(proclamation find-if-not (function-designator sequence &key) t)
(proclamation position (t sequence &key) (or null sequence-index))
(proclamation position-if (function-designator sequence &key)
              (or null sequence-index))
(proclamation position-if-not (function-designator sequence &key)
              (or null sequence-index))
(proclamation search (sequence sequence &key)
              (or null sequence-index) :no-side-effects)
(proclamation mismatch (sequence sequence &key)
              (or null sequence-index) :no-side-effects)
(proclamation replace (sequence sequence &key) sequence)
(proclamation substitute (t t sequence &key) sequence)
(proclamation substitute-if (t function-designator sequence &key) sequence)
(proclamation substitute-if-not (t function-designator sequence &key) sequence)
(proclamation nsubstitute (t t sequence &key) sequence)
(proclamation nsubstitute-if (t function-designator sequence &key) sequence)
(proclamation nsubstitute-if-not (t function-designator sequence &key) sequence)
(proclamation concatenate (type-specifier &rest sequence) sequence
                   :no-side-effects)
(proclamation merge (type-specifier sequence sequence function-designator &key)
                   sequence)
(proclamation remove (t sequence &key) sequence)
(proclamation remove-if (function-designator sequence &key) sequence)
(proclamation remove-if-not (function-designator sequence &key) sequence)
(proclamation delete (t sequence &key) sequence)
(proclamation delete-if (function-designator sequence &key) sequence)
(proclamation delete-if-not (function-designator sequence &key) sequence)
(proclamation remove-duplicates (sequence &key) sequence)
(proclamation delete-duplicates (sequence &key) sequence)

;; ECL extensions:
(proclamation si:elt-set (sequence sequence-index t) t)
(proclamation si::make-seq-iterator (sequence &optional sequence-index)
              t :no-side-effects)
(proclamation si::seq-iterator-ref (sequence t) t :reader)
(proclamation si::seq-iterator-set (sequence t t) t :no-sp-change)
(proclamation si::seq-iterator-next (sequence t) t :reader)
(proclamation si::sequence-start-end
              (t sequence sequence-index (or null sequence-index))
              (values fixnum fixnum fixnum) :no-side-effects)
(proclamation si::sequence-count ((or null integer)) fixnum :no-side-effects)

;;;
;;; 18. HASH TABLES
;;;

(proclamation make-hash-table (&key) hash-table :no-side-effects)
(proclamation hash-table-p (t) gen-bool :pure)
(proclamation hash-table-count (hash-table) ext:array-index :reader)
(proclamation hash-table-rehash-size (hash-table)
              (or (integer 1 *) (float (1.0) *))
              :pure)
(proclamation hash-table-rehash-threshold (hash-table) (real 0 1) :pure)
(proclamation hash-table-size (hash-table) ext:array-index :reader)
(proclamation hash-table-test (hash-table) function-designator :pure)
(proclamation gethash (t hash-table &optional t) (values t gen-bool) :reader)
(proclamation remhash (t hash-table) gen-bool)
(proclamation maphash (function-designator hash-table) null)
(proclamation clrhash (hash-table) hash-table)
(proclamation sxhash (t) (integer 0 #.most-positive-fixnum) :no-side-effects)

;; ECL extensions
(proclamation si:hash-set (t hash-table t) t)

;;;
;;; 19. FILENAMES
;;;
;;; Note that the pathname interrogation functions could be pure, were it
;;; not for the fact that they depend on the environment, as they accept
;;; pathname designators, which include strings that should be parsed in
;;; that environment.

(proclamation pathname (pathname-designator) pathname :no-side-effects)
(proclamation make-pathname (&key) pathname :no-side-effects)
(proclamation pathnamep (t) gen-bool :pure)
(proclamation pathname-host (pathname-designator) pathname-host :no-side-effects)
(proclamation pathname-device (pathname-designator) pathname-device :no-side-effects)
(proclamation pathname-directory (pathname-designator) pathname-directory :no-side-effects)
(proclamation pathname-name (pathname-designator) pathname-name :no-side-effects)
(proclamation pathname-type (pathname-designator) pathname-type :no-side-effects)
(proclamation pathname-version (pathname-designator) pathname-version :no-side-effects)
(proclamation load-logical-pathname-translations (string) gen-bool)
(proclamation logical-pathname-translations (string) list)
(proclamation logical-pathname (pathname-designator) logical-pathname)
(proclamation namestring (pathname-designator) (or string null)
              :no-side-effects)
(proclamation file-namestring (pathname-designator) (or string null)
              :no-side-effects)
(proclamation directory-namestring (pathname-designator) (or string null)
              :no-side-effects)
(proclamation host-namestring (pathname-designator) (or string null)
              :no-side-effects)
(proclamation enough-namestring (pathname-designator &optional pathname-designator)
              (or string null)
              :no-side-effects)
(proclamation parse-namestring (pathname-designator &optional pathname-host
                                pathname-designator &key)
              (values (or pathname null) (or ext:array-index null))
              :no-side-effects)
(proclamation wild-pathname-p (pathname-designator
                               &optional (member :host :device :directory :name
                                                 :type :version nil))
              gen-bool :no-side-effects)
(proclamation pathname-match-p (pathname-designator pathname-designator)
              gen-bool :no-side-effects)
(proclamation translate-logical-pathname (pathname-designator &key) pathname
              :no-side-effects)
(proclamation translate-pathname (pathname-designator pathname-designator
                                                      pathname-designator &key)
              pathname :no-side-effects)
(proclamation merge-pathnames (pathname-designator
                               &optional pathname-designator
                               pathname-version)
              pathname :no-side-effects)

;;;
;;; 20. FILES
;;;

(proclamation directory (pathname-designator &key) list)
(proclamation probe-file (pathname-designator) (or pathname null))
(proclamation ensure-directories-exist (pathname-designator &key)
              (values pathname gen-bool))
(proclamation truename (pathname-designator) pathname)
(proclamation file-author (pathname-designator) (or string null))
(proclamation file-write-date (pathname-designator) (or universal-time null))
(proclamation rename-file (pathname-designator pathname-designator)
              (values pathname pathname pathname))
(proclamation delete-file (pathname-designator) t)

;; Slot accessors:
;; (proclamation file-error-pathname (condition) pathname-designator)

;; ECL extensions
(proclamation ext:file-kind (pathname-designator gen-bool) symbol)
(proclamation ext:chdir (pathname-designator &optional gen-bool) pathname)
(proclamation ext:getcwd (&optional gen-bool) pathname)
(proclamation ext:mkstemp (pathname-designator) (or null pathname))
(proclamation ext:copy-file (pathname-designator pathname-designator) gen-bool)

(proclamation si:mkdir (pathname-designator unsigned-byte) string)
(proclamation si:rmdir (pathname-designator) null)


;;;
;;; 21. STREAMS
;;;

(proclamation input-stream-p (stream) gen-bool :reader)
(proclamation output-stream-p (stream) gen-bool :reader)
(proclamation interactive-stream-p (stream) gen-bool :reader)
(proclamation open-stream-p (stream) gen-bool :reader)
(proclamation stream-element-type (stream) type-specifier :reader)
(proclamation streamp (t) gen-bool :pure)
(proclamation read-byte (stream &optional gen-bool t) t)
(proclamation write-byte (integer stream) integer)
(proclamation peek-char (&optional (or character boolean)
                                   stream-designator
                                   gen-bool
                                   t
                                   gen-bool)
              t)
(proclamation read-char (&optional stream-designator gen-bool t gen-bool) t)
(proclamation read-char-no-hang (&optional stream-designator gen-bool t gen-bool) t)
(proclamation terpri (&optional stream-designator) null)
(proclamation fresh-line (&optional stream-designator) gen-bool)
(proclamation unread-char (character &optional stream-designator) null)
(proclamation write-char (character &optional stream-designator) character)
(proclamation read-line (&optional stream-designator gen-bool t gen-bool)
              (values t gen-bool))
(proclamation write-string (string &optional stream-designator &key) string)
(proclamation write-line (string &optional stream-designator &key) string)
(proclamation read-sequence (sequence stream &key) sequence-index)
(proclamation write-sequence (sequence stream &key) sequence)
(proclamation file-length (stream) (or unsigned-byte null))
(proclamation file-position (stream &optional file-position-designator) t)
(proclamation file-string-length (stream (or string character))
              (or unsigned-byte null))
(proclamation open (pathname-designator &key) (or file-stream null))
(proclamation stream-external-format (stream) external-file-format :reader)
(proclamation close (stream &key) t)
(proclamation listen (&optional stream-designator) gen-bool)
(proclamation clear-input (&optional stream-designator) null)
(proclamation finish-output (&optional stream-designator) null)
(proclamation force-output (&optional stream-designator) null)
(proclamation clear-output (&optional stream-designator) null)
(proclamation y-or-n-p (&optional format-control &rest t) gen-bool)
(proclamation yes-or-no-p (&optional format-control &rest t) gen-bool)
(proclamation make-synonym-stream (symbol) synonym-stream)
(proclamation synonym-stream-symbol (synonym-stream) symbol)
(proclamation broadcast-stream-streams (broadcast-stream) list :pure)
(proclamation make-broadcast-stream (&rest stream) broadcast-stream)
(proclamation make-two-way-stream (stream stream) two-way-stream)
(proclamation two-way-stream-input-stream (two-way-stream) stream :pure)
(proclamation two-way-stream-output-stream (two-way-stream) stream :pure)
(proclamation echo-stream-output-stream (echo-stream) stream :pure)
(proclamation echo-stream-input-stream (echo-stream) stream :pure)
(proclamation make-echo-stream (stream stream) echo-stream)
(proclamation concatenated-stream-streams (concatenated-stream)
              list :reader)
(proclamation make-concatenated-stream (&rest stream)
              concatenated-stream)
(proclamation get-output-stream-string (string-stream) string :reader)
(proclamation make-string-input-stream (string &optional
                                               ext:array-index
                                               (or ext:array-index null))
              string-stream :reader)
(proclamation make-string-output-stream (&key) string-stream :reader)

;; Slot accessors:
;; (proclamation stream-error-stream (condition) stream)

;; ECL extensions:
(proclamation si:make-string-output-stream-from-string (string)
              string-stream :reader)
#+wants-sockets
(proclamation si:open-client-stream (t unsigned-byte) stream)
#+wants-sockets
(proclamation si:open-server-stream (unsigned-byte) stream)
#+wants-sockets
(proclamation si:open-unix-socket-stream (string) stream)
#+wants-sockets
(proclamation si:lookup-host-entry (t) (values (or null string) list list))
(proclamation si:copy-stream (stream stream wait) t)
(proclamation si:make-encoding (t) hash-table)
(proclamation si:load-encoding (t) t)

;;;
;;; 22. PRINT
;;;

(proclamation copy-pprint-dispatch (&optional (or si::pprint-dispatch-table null))
              si::pprint-dispatch-table
              :no-side-effects)
(proclamation pprint-dispatch (t &optional (or si::pprint-dispatch-table null))
              (values function-designator gen-bool))
(proclamation pprint-fill (stream-designator t &optional gen-bool gen-bool)
              null)
(proclamation pprint-linear (stream-designator t &optional gen-bool gen-bool)
              null)
(proclamation pprint-tabular (stream-designator t &optional gen-bool gen-bool
                                                unsigned-byte)
              null)
(proclamation pprint-indent ((member :block :current) real
                             &optional stream-designator)
              null)
(proclamation pprint-newline ((member :linear :fill :miser :mandatory)
                              &optional stream-designator)
              null)
(proclamation pprint-tab ((member :line :section :line-relative :section-relative)
                          unsigned-byte unsigned-byte &optional stream-designator)
              null)
(proclamation set-pprint-dispatch (type-specifier
                                   (or function-designator null)
                                   &optional real si::pprint-dispatch-table)
              null)
(proclamation write (t &key) t)
(proclamation prin1 (t &optional stream-designator) t)
(proclamation princ (t &optional stream-designator) t)
(proclamation print (t &optional stream-designator) t)
(proclamation pprint (t &optional stream-designator) (values))
(proclamation write-to-string (t &key) string)
(proclamation prin1-to-string (t) string)
(proclamation princ-to-string (t) string)
(proclamation format ((or stream-designator string)
                      format-control &rest t)
              (or null string))

;; Slot accessor:
;; (proclamation print-not-readable-object (condition) t)

;;;
;;; 23. READER
;;;

(proclamation copy-readtable (&optional readtable-designator (or readtable null))
              readtable :no-side-effects)
(proclamation make-dispatch-macro-character
              (character &optional gen-bool readtable)
              (member t))
(proclamation read (&optional stream-designator gen-bool t gen-bool) t)
(proclamation read-preserving-whitespace
              (&optional stream-designator gen-bool t gen-bool) t)
(proclamation read-delimited-list (character &optional stream-designator gen-bool)
              list)
(proclamation read-from-string (string &optional gen-bool t &key)
              (values t ext:array-index))
(proclamation readtable-case (readtable)
              (member :upcase :downcase :preserve :invert)
              :reader)
(proclamation readtablep (t) gen-bool :pure)
(proclamation get-dispatch-macro-character
              (character character &optional readtable-designator)
              (or function-designator null)
              :reader)
(proclamation set-dispatch-macro-character
              (character character function-designator
               &optional readtable-designator)
              (member t))
(proclamation get-macro-character
              (character &optional readtable-designator)
              (values (or function-designator null) gen-bool)
              :reader)
(proclamation set-macro-character
              (character function-designator
               &optional gen-bool readtable-designator)
              (member t))
(proclamation set-syntax-from-char
              (character character &optional readtable readtable-designator)
              (member t))

;; ECL extensions:
(proclamation si:string-to-object (string &optional t) t)
(proclamation si:standard-readtable () readtable)

;;;
;;; 24. SYSTEM CONSTRUCTION
;;;

(proclamation compile-file (pathname-designator &key)
              (values (or pathname null) gen-bool gen-bool))
(proclamation compile-file-pathname (pathname-designator &key)
              pathname :no-side-effects)
(proclamation load ((or stream pathname-designator) &key) gen-bool)
(proclamation provide (string-designator) t)
(proclamation require (string-designator &optional list) t)

;; ECL extensions
(proclamation si:clear-compiler-properties (symbol) t)


;;;
;;; 25. ENVIRONMENT
;;;

(proclamation decode-universal-time (universal-time &optional time-zone)
              (values (integer 0 59)
                      (integer 0 59)
                      (integer 0 23)
                      (integer 1 31)
                      (integer 1 12)
                      unsigned-byte
                      (integer 0 6)
                      gen-bool
                      time-zone)
              :pure)
(proclamation encode-universal-time ((integer 0 59)
                                     (integer 0 59)
                                     (integer 0 23)
                                     (integer 1 31)
                                     (integer 1 12)
                                     unsigned-byte
                                     &optional time-zone)
              universal-time
              :pure)
(proclamation get-universal-time () universal-time :no-side-effects)
(proclamation get-decoded-time ()
              (values (integer 0 59)
                      (integer 0 59)
                      (integer 0 23)
                      (integer 1 31)
                      (integer 1 12)
                      unsigned-byte
                      (integer 0 6)
                      gen-bool
                      time-zone)
              :no-side-effects)
(proclamation sleep ((real 0 *)) null)
(proclamation apropos (string-designator &optional (or null package-designator))
              (values))
(proclamation apropos-list
              (string-designator &optional (or null package-designator))
              list)
(proclamation describe (t &optional stream-designator) (values))
(proclamation get-internal-real-time () unsigned-byte :no-side-effects)
(proclamation get-internal-run-time () unsigned-byte :no-side-effects)
(proclamation disassemble ((or function-designator list)) null)
(proclamation room (&optional (member t nil :default)) (values &rest t))
(proclamation ed (&optional (or null pathname string function-name))
              (values &rest t))
(proclamation inspect (t) (values &rest t))
(proclamation dribble (&optional pathname-designator) (values &rest t))
(proclamation lisp-implementation-type () (or string null) :pure)
(proclamation lisp-implementation-version () (or string null) :pure)
(proclamation short-site-name () (or string null) :pure)
(proclamation long-site-name () (or string null) :pure)
(proclamation machine-instance () (or string null) :pure)
(proclamation machine-type () (or string null) :pure)
(proclamation machine-version () (or string null) :pure)
(proclamation software-type () (or string null) :pure)
(proclamation software-version () (or string null) :pure)
(proclamation user-homedir-pathname (&optional pathname-host)
              (or pathname null) :no-side-effects)

;; ECL extensions

(proclamation ext::lisp-implementation-vcs-id () string :pure)
(proclamation si::room-report () (values t t t t t t t t))
(proclamation si::reset-gbc-count () t)
(proclamation ext:gc (&optional gen-bool) t)
(proclamation ext:quit (&optional fixnum) t)
(proclamation ext:argc () sequence-index)
(proclamation ext:argv (unsigned-byte) base-string)
(proclamation ext:getenv (string) (or null string))
(proclamation ext:environ () list)
(proclamation ext:system (string) fixnum)
(proclamation ext:getpid () si::index)
(proclamation ext:make-pipe () (or two-way-stream null))
(proclamation ext:run-program (string list &key)
              (values (or null two-way-stream)
                      (or null integer)
                      ext:external-process))
(proclamation ext:file-stream-fd (stream) fixnum)
(proclamation ext:make-stream-from-fd (fixnum keyword &key) stream)

(proclamation si:waitpid (fixnum gen-bool) (values
                                            (or null keyword)
                                            (or null fixnum)
                                            (or null fixnum)))
(proclamation si:killpid (fixnum fixnum) fixnum)
(proclamation si:run-program-inner (string (or list string) list)
              (values file-stream integer))
(proclamation si:spawn-subprocess (string (or list string) list t t t)
              (values (or null integer) fixnum fixnum fixnum))
(proclamation ext:terminate-process (t &optional gen-bool) null)

(proclamation ext:make-weak-pointer (t) ext:weak-pointer :no-side-effects)
(proclamation ext:weak-pointer-value (ext:weak-pointer) t)

(proclamation si:unbound () t :pure)
(proclamation si:traced-old-definition (t) t :no-side-effects)

#+clos
(proclamation si:allocate-raw-instance (t t fixnum) ext:instance)
#+clos
(proclamation clos:safe-instance-ref (t fixnum) t)
#+clos
(proclamation si:instance-ref (t fixnum) t :reader)
#+clos
(proclamation si::instance-sig (standard-object) list :reader)
#+clos
(proclamation si:instance-set (t fixnum t) t)
#+clos
(proclamation si:instance-class (t) class :reader)
#+clos
(proclamation si:instance-class-set (t t) t)
#+clos
(proclamation si:instancep (t) t :pure)
#+clos
(proclamation si:sl-boundp (t) t :reader)
#+clos
(proclamation si:sl-makunbound (t fixnum) t)
#+clos
(proclamation clos:standard-instance-access (standard-object t) t :reader)
#+clos
(proclamation clos:funcallable-standard-instance-access
              (clos:funcallable-standard-object t)
              t :reader)
#+clos
(proclamation associate-methods-to-gfun (generic-function *)
              generic-function)
#+clos
(proclamation clos::need-to-make-load-form-p (t t) gen-bool :pure)

#+clos
(proclamation clos::load-defclass (t t t t) t)

;;;
;;; A. FFI
;;;

(proclamation si:pointer (t) unsigned-byte)
(proclamation si:foreign-data-p (t) gen-bool :pure)

;;;
;;; CDR-5 http://cdr.eurolisp.org/document/5/extra-num-types.html
;;;

(proclamation ext:negative-fixnum-p (t) gen-bool :pure) 
(proclamation ext:non-negative-fixnum-p (t) gen-bool :pure) 
(proclamation ext:non-positive-fixnum-p (t) gen-bool :pure) 
(proclamation ext:positive-fixnum-p (t) gen-bool :pure) 
(proclamation ext:array-index-p (t) gen-bool :pure) 

(proclamation ext:negative-integer-p (t) gen-bool :pure) 
(proclamation ext:non-negative-integer-p (t) gen-bool :pure) 
(proclamation ext:non-positive-integer-p (t) gen-bool :pure) 
(proclamation ext:positive-integer-p (t) gen-bool :pure) 

(proclamation ext:negative-rational-p (t) gen-bool :pure) 
(proclamation ext:non-negative-rational-p (t) gen-bool :pure) 
(proclamation ext:non-positive-rational-p (t) gen-bool :pure) 
(proclamation ext:positive-rational-p (t) gen-bool :pure) 

(proclamation ext:negative-ratio-p (t) gen-bool :pure) 
(proclamation ext:non-negative-ratio-p (t) gen-bool :pure) 
(proclamation ext:non-positive-ratio-p (t) gen-bool :pure) 
(proclamation ext:positive-ratio-p (t) gen-bool :pure) 

(proclamation ext:negative-real-p (t) gen-bool :pure) 
(proclamation ext:non-negative-real-p (t) gen-bool :pure) 
(proclamation ext:non-positive-real-p (t) gen-bool :pure) 
(proclamation ext:positive-real-p (t) gen-bool :pure) 

(proclamation ext:negative-float-p (t) gen-bool :pure) 
(proclamation ext:non-negative-float-p (t) gen-bool :pure) 
(proclamation ext:non-positive-float-p (t) gen-bool :pure) 
(proclamation ext:positive-float-p (t) gen-bool :pure) 

(proclamation ext:negative-short-float-p (t) gen-bool :pure) 
(proclamation ext:non-negative-short-float-p (t) gen-bool :pure) 
(proclamation ext:non-positive-short-float-p (t) gen-bool :pure) 
(proclamation ext:positive-short-float-p (t) gen-bool :pure) 

(proclamation ext:negative-single-float-p (t) gen-bool :pure) 
(proclamation ext:non-negative-single-float-p (t) gen-bool :pure) 
(proclamation ext:non-positive-single-float-p (t) gen-bool :pure) 
(proclamation ext:positive-single-float-p (t) gen-bool :pure) 

(proclamation ext:negative-double-float-p (t) gen-bool :pure) 
(proclamation ext:non-negative-double-float-p (t) gen-bool :pure) 
(proclamation ext:non-positive-double-float-p (t) gen-bool :pure) 
(proclamation ext:positive-double-float-p (t) gen-bool :pure) 

(proclamation ext:negative-long-float-p (t) gen-bool :pure) 
(proclamation ext:non-negative-long-float-p (t) gen-bool :pure) 
(proclamation ext:non-positive-long-float-p (t) gen-bool :pure) 
(proclamation ext:positive-long-float-p (t) gen-bool :pure) 

))) ; eval-when

(loop for i in '#.(mapcar #'rest +proclamations+)
   do (apply #'parse-function-proclamation i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/cmp/proclamations.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/cmp/sysfun.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: C -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;; CMPSYSFUN   Database for system functions.
;;;
;;; Copyright (c) 2003, Juan Jose Garcia Ripoll
;;; Copyright (c) 1991, Giuseppe Attardi. All rights reserved.
;;;    Copying of this file is authorized to users who have executed the true
;;;    and proper "License Agreement for ECoLisp".
;;;
;;; DATABASE OF INLINE EXPANSIONS
;;;
;;;     (DEF-INLINE function-name kind ([arg-type]*) return-rep-type
;;;             expansion-string)
;;;
;;; Here, ARG-TYPE is the list of argument types belonging to the lisp family,
;;; while RETURN-REP-TYPE is a representation type, i.e. the C type of the
;;; output expression. EXPANSION-STRING is a C/C++ expression template, like the
;;; ones used by C-INLINE. Finally, KIND can be :ALWAYS, :SAFE or :UNSAFE,
;;; depending on whether the inline expression should be applied always, in safe
;;; or in unsafe compilation mode, respectively.
;;;

(in-package "COMPILER")

(eval-when (:compile-toplevel :execute)
(defparameter +inline-forms+ '(
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; ALL FUNCTION DECLARATIONS AND INLINE FORMS
;;;

(def-inline aref :unsafe (t t t) t
 "@0;ecl_aref_unsafe(#0,ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2))")
(def-inline aref :unsafe ((array t) t t) t
 "@0;(#0)->array.self.t[ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2)]")
(def-inline aref :unsafe ((array bit) t t) :fixnum
 "@0;ecl_aref_bv(#0,ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2))")
(def-inline aref :unsafe ((array t) fixnum fixnum) t
 "@0;(#0)->array.self.t[#1*(#0)->array.dims[1]+#2]")
(def-inline aref :unsafe ((array bit) fixnum fixnum) :fixnum
 "@0;ecl_aref_bv(#0,(#1)*(#0)->array.dims[1]+#2)")
(def-inline aref :unsafe ((array base-char) fixnum fixnum) :unsigned-char
 "@0;(#0)->base_string.self[#1*(#0)->array.dims[1]+#2]")
(def-inline aref :unsafe ((array double-float) fixnum fixnum) :double
 "@0;(#0)->array.self.df[#1*(#0)->array.dims[1]+#2]")
(def-inline aref :unsafe ((array single-float) fixnum fixnum) :float
 "@0;(#0)->array.self.sf[#1*(#0)->array.dims[1]+#2]")
(def-inline aref :unsafe ((array fixnum) fixnum fixnum) :fixnum
 "@0;(#0)->array.self.fix[#1*(#0)->array.dims[1]+#2]")

(def-inline aref :always (t t) t "ecl_aref1(#0,ecl_to_size(#1))")
(def-inline aref :always (t fixnum) t "ecl_aref1(#0,#1)")
(def-inline aref :unsafe (t t) t "ecl_aref1(#0,ecl_fixnum(#1))")
(def-inline aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))")
(def-inline aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)")
#+unicode
(def-inline aref :unsafe ((array character) fixnum) :wchar
 "(#0)->string.self[#1]")
(def-inline aref :unsafe ((array base-char) fixnum) :unsigned-char
 "(#0)->base_string.self[#1]")
(def-inline aref :unsafe ((array double-float) fixnum) :double
 "(#0)->array.self.df[#1]")
(def-inline aref :unsafe ((array single-float) fixnum) :float
 "(#0)->array.self.sf[#1]")
(def-inline aref :unsafe ((array fixnum) fixnum) :fixnum
 "(#0)->array.self.fix[#1]")

(def-inline row-major-aref :always (t t) t "ecl_aref(#0,ecl_to_size(#1))")
(def-inline row-major-aref :always (t fixnum) t "ecl_aref(#0,#1)")
(def-inline row-major-aref :unsafe (t t) t "ecl_aref_unsafe(#0,ecl_fixnum(#1))")
(def-inline row-major-aref :unsafe (t fixnum) t "ecl_aref_unsafe(#0,#1)")
(def-inline row-major-aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))")
(def-inline row-major-aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)")
#+unicode
(def-inline row-major-aref :unsafe ((array character) fixnum) :wchar
 "(#0)->string.self[#1]")
(def-inline row-major-aref :unsafe ((array base-char) fixnum) :unsigned-char
 "(#0)->base_string.self[#1]")
(def-inline row-major-aref :unsafe ((array ext:byte8) fixnum) :uint8-t
 "(#0)->vector.self.b8[#1]")
(def-inline row-major-aref :unsafe ((array ext:integer8) fixnum) :int8-t
 "(#0)->vector.self.i8[#1]")
(def-inline row-major-aref :unsafe ((array ext:byte16) fixnum) :uint16-t
 "(#0)->vector.self.b16[#1]")
(def-inline row-major-aref :unsafe ((array ext:integer16) fixnum) :int16-t
 "(#0)->vector.self.i16[#1]")
(def-inline row-major-aref :unsafe ((array ext:byte32) fixnum) :uint32-t
 "(#0)->vector.self.b32[#1]")
(def-inline row-major-aref :unsafe ((array ext:integer32) fixnum) :int32-t
 "(#0)->vector.self.i32[#1]")
(def-inline row-major-aref :unsafe ((array ext:byte64) fixnum) :uint64-t
 "(#0)->vector.self.b64[#1]")
(def-inline row-major-aref :unsafe ((array ext:integer64) fixnum) :int64-t
 "(#0)->vector.self.i64[#1]")
(def-inline row-major-aref :unsafe ((array double-float) fixnum) :double
 "(#0)->array.self.df[#1]")
(def-inline row-major-aref :unsafe ((array single-float) fixnum) :float
 "(#0)->array.self.sf[#1]")
(def-inline row-major-aref :unsafe ((array fixnum) fixnum) :fixnum
 "(#0)->array.self.fix[#1]")

(def-inline si:row-major-aset :always (t t t) t "ecl_aset(#0,ecl_to_size(#1),#2)")
(def-inline si:row-major-aset :always (t fixnum t) t "ecl_aset(#0,#1,#2)")
(def-inline si:row-major-aset :unsafe (t t t) t "ecl_aset_unsafe(#0,ecl_fixnum(#1),#2)")
(def-inline si:row-major-aset :unsafe (t fixnum t) t "ecl_aset_unsafe(#0,#1,#2)")
(def-inline si:row-major-aset :unsafe ((array t) fixnum t) t
 "(#0)->vector.self.t[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array bit) fixnum t) :fixnum
 "ecl_aset_bv(#0,#1,ecl_fixnum(#2))")
(def-inline si:row-major-aset :unsafe ((array bit) fixnum fixnum) :fixnum
 "ecl_aset_bv(#0,#1,#2)")
(def-inline si:row-major-aset :unsafe ((array base-char) fixnum base-char) :unsigned-char
 "(#0)->base_string.self[#1]= #2")
#+unicode
(def-inline si:row-major-aset :unsafe ((array character) fixnum character) :wchar
 "(#0)->string.self[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:byte8) fixnum ext:byte8) :uint8-t
 "(#0)->vector.self.b8[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:integer8) fixnum ext:integer8) :int8-t
 "(#0)->vector.self.i8[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:byte16) fixnum ext:byte16) :uint16-t
 "(#0)->vector.self.b16[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:integer16) fixnum ext:integer16) :int16-t
 "(#0)->vector.self.i16[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:byte32) fixnum ext:byte32) :uint32-t
 "(#0)->vector.self.b32[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:integer32) fixnum ext:integer32) :int32-t
 "(#0)->vector.self.i32[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:byte64) fixnum ext:byte64) :uint64-t
 "(#0)->vector.self.b64[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array ext:integer64) fixnum ext:integer64) :int64-t
 "(#0)->vector.self.i64[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array double-float) fixnum double-float) :double
 "(#0)->array.self.df[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array single-float) fixnum single-float) :float
 "(#0)->array.self.sf[#1]= #2")
(def-inline si:row-major-aset :unsafe ((array fixnum) fixnum fixnum) :fixnum
 "(#0)->array.self.fix[#1]= #2")

(def-inline si:copy-subarray :always (array ext:array-index array ext:array-index
                                      ext:array-index) array
 "@0;(ecl_copy_subarray(#0,#1,#2,#3,#4),#0)")

(def-inline array-rank :unsafe (array) :fixnum
 "@0;(((#0)->d.t == t_array)?(#0)->array.rank:1)")
(def-inline array-rank :always (array) :fixnum
 "ecl_array_rank(#0)")

(def-inline array-dimension :always (t t) fixnum
 "ecl_array_dimension(#0,ecl_to_size(#1))")
(def-inline array-dimension :always (t fixnum) fixnum
 "ecl_array_dimension(#0,#1)")

(def-inline array-total-size :unsafe (t) :fixnum "((#0)->array.dim)")

(def-inline adjustable-array-p :always (t) :bool "@0;(ECL_ARRAYP(#0)? (void)0: FEtype_error_array(#0),ECL_ADJUSTABLE_ARRAY_P(#0))")
(def-inline adjustable-array-p :unsafe (array) :bool "ECL_ADJUSTABLE_ARRAY_P(#0)")

(def-inline svref :always (t t) t "ecl_aref1(#0,ecl_to_size(#1))")
(def-inline svref :always (t fixnum) t "ecl_aref1(#0,#1)")
(def-inline svref :unsafe (t t) t "(#0)->vector.self.t[ecl_fixnum(#1)]")
(def-inline svref :unsafe (t fixnum) t "(#0)->vector.self.t[#1]")

(def-inline si:svset :always (t t t) t "ecl_aset1(#0,ecl_to_size(#1),#2)")
(def-inline si:svset :always (t fixnum t) t "ecl_aset1(#0,#1,#2)")
(def-inline si:svset :unsafe (t t t) t "((#0)->vector.self.t[ecl_fixnum(#1)]=(#2))")
(def-inline si:svset :unsafe (t fixnum t) t "(#0)->vector.self.t[#1]= #2")

(def-inline array-has-fill-pointer-p :always (t) :bool "@0;(ECL_ARRAYP(#0)?(void)0:FEtype_error_array(#0),ECL_ARRAY_HAS_FILL_POINTER_P(#0))")
(def-inline array-has-fill-pointer-p :unsafe (array) :bool "ECL_ARRAY_HAS_FILL_POINTER_P(#0)")

(def-inline fill-pointer :unsafe (t) :fixnum "((#0)->vector.fillp)")


(def-inline si:fill-pointer-set :unsafe (t fixnum) :fixnum
 "((#0)->vector.fillp)=(#1)")

;; file character.d

(def-inline standard-char-p :always (character) :bool "ecl_standard_char_p(#0)")

(def-inline graphic-char-p :always (character) :bool "ecl_graphic_char_p(#0)")

(def-inline alpha-char-p :always (character) :bool "ecl_alpha_char_p(#0)")

(def-inline upper-case-p :always (character) :bool "ecl_upper_case_p(#0)")

(def-inline lower-case-p :always (character) :bool "ecl_lower_case_p(#0)")

(def-inline both-case-p :always (character) :bool "ecl_both_case_p(#0)")

(def-inline alphanumericp :always (character) :bool "ecl_alphanumericp(#0)")

(def-inline char= :always (t t) :bool "ecl_char_code(#0)==ecl_char_code(#1)")
(def-inline char= :always (character character) :bool "(#0)==(#1)")

(def-inline char/= :always (t t) :bool "ecl_char_code(#0)!=ecl_char_code(#1)")
(def-inline char/= :always (character character) :bool "(#0)!=(#1)")

(def-inline char< :always (character character) :bool "(#0)<(#1)")

(def-inline char> :always (character character) :bool "(#0)>(#1)")

(def-inline char<= :always (character character) :bool "(#0)<=(#1)")

(def-inline char>= :always (character character) :bool "(#0)>=(#1)")

(def-inline char-code :always (character) :fixnum "#0")

(def-inline code-char :always (fixnum) :wchar "#0")

(def-inline char-upcase :always (base-char) :unsigned-char "ecl_char_upcase(#0)")
(def-inline char-upcase :always (character) :wchar "ecl_char_upcase(#0)")

(def-inline char-downcase :always (base-char) :unsigned-char "ecl_char_downcase(#0)")
(def-inline char-downcase :always (character) :wchar "ecl_char_downcase(#0)")

(def-inline char-int :always (character) :fixnum "#0")

;; file ffi.d

(def-inline si:foreign-data-p :always (t) :bool "@0;ECL_FOREIGN_DATA_P(#0)")

;; file file.d

(def-inline input-stream-p :always (stream) :bool "ecl_input_stream_p(#0)")

(def-inline output-stream-p :always (stream) :bool "ecl_output_stream_p(#0)")

;; file hash.d

(def-inline gethash :always (t t t) t "ecl_gethash_safe(#0,#1,#2)" :multiple-values nil)
(def-inline gethash :always (t t) t "ecl_gethash_safe(#0,#1,ECL_NIL)" :multiple-values nil)
(def-inline hash-table-count :unsafe (hash-table) ext:array-index "ecl_hash_table_count(#0)")

;; file list.d

(def-inline car :unsafe (cons) t "ECL_CONS_CAR(#0)")
(def-inline car :unsafe (t) t "_ecl_car(#0)")

(def-inline si::cons-car :always (t) t "_ecl_car(#0)")
(def-inline si::cons-car :unsafe (t) t "ECL_CONS_CAR(#0)")

(def-inline cdr :unsafe (cons) t "ECL_CONS_CDR(#0)")
(def-inline cdr :unsafe (t) t "_ecl_cdr(#0)")

(def-inline si::cons-cdr :always (t) t "_ecl_cdr(#0)")
(def-inline si::cons-cdr :unsafe (t) t "ECL_CONS_CDR(#0)")

;; BEGIN-GENERATED (gen-cons-sysfun)

(def-inline car :always (t) t "ecl_car(#0)")
(def-inline car :unsafe (t) t "_ecl_car(#0)")
(def-inline cdr :always (t) t "ecl_cdr(#0)")
(def-inline cdr :unsafe (t) t "_ecl_cdr(#0)")
(def-inline caar :always (t) t "ecl_caar(#0)")
(def-inline caar :unsafe (t) t "_ecl_caar(#0)")
(def-inline cdar :always (t) t "ecl_cdar(#0)")
(def-inline cdar :unsafe (t) t "_ecl_cdar(#0)")
(def-inline cadr :always (t) t "ecl_cadr(#0)")
(def-inline cadr :unsafe (t) t "_ecl_cadr(#0)")
(def-inline cddr :always (t) t "ecl_cddr(#0)")
(def-inline cddr :unsafe (t) t "_ecl_cddr(#0)")
(def-inline caaar :always (t) t "ecl_caaar(#0)")
(def-inline caaar :unsafe (t) t "_ecl_caaar(#0)")
(def-inline cdaar :always (t) t "ecl_cdaar(#0)")
(def-inline cdaar :unsafe (t) t "_ecl_cdaar(#0)")
(def-inline cadar :always (t) t "ecl_cadar(#0)")
(def-inline cadar :unsafe (t) t "_ecl_cadar(#0)")
(def-inline cddar :always (t) t "ecl_cddar(#0)")
(def-inline cddar :unsafe (t) t "_ecl_cddar(#0)")
(def-inline caadr :always (t) t "ecl_caadr(#0)")
(def-inline caadr :unsafe (t) t "_ecl_caadr(#0)")
(def-inline cdadr :always (t) t "ecl_cdadr(#0)")
(def-inline cdadr :unsafe (t) t "_ecl_cdadr(#0)")
(def-inline caddr :always (t) t "ecl_caddr(#0)")
(def-inline caddr :unsafe (t) t "_ecl_caddr(#0)")
(def-inline cdddr :always (t) t "ecl_cdddr(#0)")
(def-inline cdddr :unsafe (t) t "_ecl_cdddr(#0)")
(def-inline caaaar :always (t) t "ecl_caaaar(#0)")
(def-inline caaaar :unsafe (t) t "_ecl_caaaar(#0)")
(def-inline cdaaar :always (t) t "ecl_cdaaar(#0)")
(def-inline cdaaar :unsafe (t) t "_ecl_cdaaar(#0)")
(def-inline cadaar :always (t) t "ecl_cadaar(#0)")
(def-inline cadaar :unsafe (t) t "_ecl_cadaar(#0)")
(def-inline cddaar :always (t) t "ecl_cddaar(#0)")
(def-inline cddaar :unsafe (t) t "_ecl_cddaar(#0)")
(def-inline caadar :always (t) t "ecl_caadar(#0)")
(def-inline caadar :unsafe (t) t "_ecl_caadar(#0)")
(def-inline cdadar :always (t) t "ecl_cdadar(#0)")
(def-inline cdadar :unsafe (t) t "_ecl_cdadar(#0)")
(def-inline caddar :always (t) t "ecl_caddar(#0)")
(def-inline caddar :unsafe (t) t "_ecl_caddar(#0)")
(def-inline cdddar :always (t) t "ecl_cdddar(#0)")
(def-inline cdddar :unsafe (t) t "_ecl_cdddar(#0)")
(def-inline caaadr :always (t) t "ecl_caaadr(#0)")
(def-inline caaadr :unsafe (t) t "_ecl_caaadr(#0)")
(def-inline cdaadr :always (t) t "ecl_cdaadr(#0)")
(def-inline cdaadr :unsafe (t) t "_ecl_cdaadr(#0)")
(def-inline cadadr :always (t) t "ecl_cadadr(#0)")
(def-inline cadadr :unsafe (t) t "_ecl_cadadr(#0)")
(def-inline cddadr :always (t) t "ecl_cddadr(#0)")
(def-inline cddadr :unsafe (t) t "_ecl_cddadr(#0)")
(def-inline caaddr :always (t) t "ecl_caaddr(#0)")
(def-inline caaddr :unsafe (t) t "_ecl_caaddr(#0)")
(def-inline cdaddr :always (t) t "ecl_cdaddr(#0)")
(def-inline cdaddr :unsafe (t) t "_ecl_cdaddr(#0)")
(def-inline cadddr :always (t) t "ecl_cadddr(#0)")
(def-inline cadddr :unsafe (t) t "_ecl_cadddr(#0)")
(def-inline cddddr :always (t) t "ecl_cddddr(#0)")
(def-inline cddddr :unsafe (t) t "_ecl_cddddr(#0)")
;; END-GENERATED

(def-inline cons :always (t t) t "CONS(#0,#1)")

(def-inline endp :safe (t) :bool "ecl_endp(#0)")
(def-inline endp :unsafe (t) :bool "#0==ECL_NIL")

(def-inline nth :always (t t) t "ecl_nth(ecl_to_size(#0),#1)")
(def-inline nth :always (fixnum t) t "ecl_nth(#0,#1)")
(def-inline nth :unsafe (t t) t "ecl_nth(ecl_fixnum(#0),#1)")
(def-inline nth :unsafe (fixnum t) t "ecl_nth(#0,#1)")

(def-inline nthcdr :always (t t) t "ecl_nthcdr(ecl_to_size(#0),#1)")
(def-inline nthcdr :always (fixnum t) t "ecl_nthcdr(#0,#1)")
(def-inline nthcdr :unsafe (t t) t "ecl_nthcdr(ecl_fixnum(#0),#1)")
(def-inline nthcdr :unsafe (fixnum t) t "ecl_nthcdr(#0,#1)")

(def-inline last :always (t) t "ecl_last(#0,1)")

(def-inline list :always nil t "ECL_NIL")
(def-inline list :always (t) t "ecl_list1(#0)")

(def-inline list* :always (t) t "#0")
(def-inline list* :always (t t) t "CONS(#0,#1)")

(def-inline append :always (t t) t "ecl_append(#0,#1)")

(def-inline nconc :always (t t) t "ecl_nconc(#0,#1)")

(def-inline butlast :always (t) t "ecl_butlast(#0,1)")

(def-inline nbutlast :always (t) t "ecl_nbutlast(#0,1)")

;; file num_arith.d

(def-inline 1+ :always (t) t "ecl_one_plus(#0)")
(def-inline 1+ :always (fixnum) t "ecl_make_integer((#0)+1)")
(def-inline 1+ :always (double-float) :double "(double)(#0)+1")
(def-inline 1+ :always (single-float) :float "(float)(#0)+1")
(def-inline 1+ :always (fixnum) :fixnum "(#0)+1" :exact-return-type t)

(def-inline 1- :always (t) t "ecl_one_minus(#0)")
(def-inline 1- :always (fixnum) t "ecl_make_integer((#0)-1)")
(def-inline 1- :always (double-float) :double "(double)(#0)-1")
(def-inline 1- :always (single-float) :float "(float)(#0)-1")
(def-inline 1- :always (fixnum) :fixnum "(#0)-1" :exact-return-type t)

;; file num_co.d

(def-inline float :always (t single-float) :float "ecl_to_float(#0)")
(def-inline float :always (t double-float) :double "ecl_to_double(#0)")
#+long-float
(def-inline float :always (t long-float) :long-double "ecl_to_long_double(#0)")
(def-inline float :always (fixnum-float) :double "((double)(#0))" :exact-return-type t)
(def-inline float :always (fixnum-float) :float "((float)(#0))" :exact-return-type t)

(def-inline numerator :unsafe (integer) integer "(#0)")
(def-inline numerator :unsafe (ratio) integer "(#0)->ratio.num")

(def-inline denominator :unsafe (integer) integer "ecl_make_fixnum(1)")
(def-inline denominator :unsafe (ratio) integer "(#0)->ratio.den")

(def-inline floor :always (t) (values &rest t) "ecl_floor1(#0)")
(def-inline floor :always (t t) (values &rest t) "ecl_floor2(#0,#1)")
#+(or) ; does not work well, no multiple values
(def-inline floor :always (fixnum fixnum) :fixnum
 "@01;(#0>=0&&#1>0?(#0)/(#1):ecl_ifloor(#0,#1))")

(def-inline ceiling :always (t) (values &rest t) "ecl_ceiling1(#0)")
(def-inline ceiling :always (t t) (values &rest t) "ecl_ceiling2(#0,#1)")

(def-inline truncate :always (t) (values &rest t) "ecl_truncate1(#0)")
(def-inline truncate :always (t t) (values &rest t) "ecl_truncate2(#0,#1)")
#+(or) ; does not work well, no multiple values
(def-inline truncate :always (fixnum-float) :fixnum "(cl_fixnum)(#0)")

(def-inline round :always (t) (values &rest t) "ecl_round1(#0)")
(def-inline round :always (t t) (values &rest t) "ecl_round2(#0,#1)")

(def-inline mod :always (t t) t "(ecl_floor2(#0,#1),cl_env_copy->values[1])")
(def-inline mod :always (fixnum fixnum) :fixnum
 "@01;(#0>=0&&#1>0?(#0)%(#1):ecl_imod(#0,#1))")

(def-inline rem :always (t t) t "(ecl_truncate2(#0,#1),cl_env_copy->values[1])")
(def-inline rem :always (fixnum fixnum) :fixnum "(#0)%(#1)")

(def-inline = :always (t t) :bool "ecl_number_equalp(#0,#1)")
(def-inline = :always (fixnum-float fixnum-float) :bool "(#0)==(#1)")

(def-inline /= :always (t t) :bool "!ecl_number_equalp(#0,#1)")
(def-inline /= :always (fixnum-float fixnum-float) :bool "(#0)!=(#1)")

(def-inline < :always (t t) :bool "ecl_number_compare(#0,#1)<0")
(def-inline < :always (fixnum-float fixnum-float) :bool "(#0)<(#1)")
(def-inline < :always (fixnum-float fixnum-float fixnum-float) :bool
            "@012;((#0)<(#1) && (#1)<(#2))")

(def-inline > :always (t t) :bool "ecl_number_compare(#0,#1)>0")
(def-inline > :always (fixnum-float fixnum-float) :bool "(#0)>(#1)")
(def-inline > :always (fixnum-float fixnum-float fixnum-float) :bool
            "@012;((#0)>(#1) && (#1)>(#2))")

(def-inline <= :always (t t) :bool "ecl_number_compare(#0,#1)<=0")
(def-inline <= :always (fixnum-float fixnum-float) :bool "(#0)<=(#1)")
(def-inline <= :always (fixnum-float fixnum-float fixnum-float) :bool
            "@012;((#0)<=(#1) && (#1)<=(#2))")

(def-inline >= :always (t t) :bool "ecl_number_compare(#0,#1)>=0")
(def-inline >= :always (fixnum-float fixnum-float) :bool "(#0)>=(#1)")
(def-inline >= :always (fixnum-float fixnum-float fixnum-float) :bool
            "@012;((#0)>=(#1) && (#1)>=(#2))")

(def-inline max :always (t t) t "@01;(ecl_number_compare(#0,#1)>=0?#0:#1)")
(def-inline max :always (fixnum fixnum) :fixnum "@01;(#0)>=(#1)?#0:#1")

(def-inline min :always (t t) t "@01;(ecl_number_compare(#0,#1)<=0?#0:#1)")
(def-inline min :always (fixnum fixnum) :fixnum "@01;(#0)<=(#1)?#0:#1")

;; file num_log.d

(def-inline logand :always nil t "ecl_make_fixnum(-1)")
(def-inline logand :always nil :fixnum "-1")
(def-inline logand :always (t t) t "ecl_boole(ECL_BOOLAND,(#0),(#1))")
(def-inline logand :always (fixnum fixnum) :fixnum "((#0) & (#1))")

(def-inline logandc1 :always (t t) t "ecl_boole(ECL_BOOLANDC1,(#0),(#1))")
(def-inline logandc1 :always (fixnum fixnum) :fixnum "(~(#0) & (#1))")

(def-inline logandc2 :always (t t) t "ecl_boole(ECL_BOOLANDC2,(#0),(#1))")
(def-inline logandc2 :always (fixnum fixnum) :fixnum "((#0) & ~(#1))")

(def-inline logeqv :always nil t "ecl_make_fixnum(-1)")
(def-inline logeqv :always nil :fixnum "-1")
(def-inline logeqv :always (t t) t "ecl_boole(ECL_BOOLEQV,(#0),(#1))")
(def-inline logeqv :always (fixnum fixnum) :fixnum "(~( (#0) ^ (#1) ))")

(def-inline logior :always nil t "ecl_make_fixnum(0)")
(def-inline logior :always nil :fixnum "0")
(def-inline logior :always (t t) t "ecl_boole(ECL_BOOLIOR,(#0),(#1))")
(def-inline logior :always (fixnum fixnum) :fixnum "((#0) | (#1))")

(def-inline lognand :always (t t) t "ecl_boole(ECL_BOOLNAND,(#0),(#1))")
(def-inline lognand :always (fixnum fixnum) :fixnum "(~( (#0) & (#1) ))")

(def-inline lognor :always (t t) t "ecl_boole(ECL_BOOLNOR,(#0),(#1))")
(def-inline lognor :always (fixnum fixnum) :fixnum "(~( (#0) | (#1) ))")

(def-inline lognot :always (t) t "ecl_boole(ECL_BOOLXOR,(#0),ecl_make_fixnum(-1))")
(def-inline lognot :always (fixnum) :fixnum "(~(#0))")

(def-inline logorc1 :always (t t) t "ecl_boole(ECL_BOOLORC1,(#0),(#1))")
(def-inline logorc1 :always (fixnum fixnum) :fixnum "(~(#0) | (#1))")

(def-inline logorc2 :always (t t) t "ecl_boole(ECL_BOOLORC2,(#0),(#1))")
(def-inline logorc2 :always (fixnum fixnum) :fixnum "((#0) | ~(#1))")

(def-inline logxor :always nil t "ecl_make_fixnum(0)")
(def-inline logxor :always nil :fixnum "0")
(def-inline logxor :always (t t) t "ecl_boole(ECL_BOOLXOR,(#0),(#1))")
(def-inline logxor :always (fixnum fixnum) :fixnum "((#0) ^ (#1))")

(def-inline boole :always (fixnum t t) t "ecl_boole((#0),(#1),(#2))")

(def-inline logbitp :always ((integer -29 29) fixnum) :bool "(#1 >> #0) & 1")

(def-inline integer-length :always (t) :cl-index "ecl_integer_length(#0)")

(def-inline zerop :always (t) :bool "ecl_zerop(#0)")
(def-inline zerop :always (fixnum-float) :bool "(#0)==0")

(def-inline plusp :always (t) :bool "ecl_plusp(#0)")
(def-inline plusp :always (fixnum-float) :bool "(#0)>0")

(def-inline minusp :always (t) :bool "ecl_minusp(#0)")
(def-inline minusp :always (fixnum-float) :bool "(#0)<0")

(def-inline oddp :always (t) :bool "ecl_oddp(#0)")
(def-inline oddp :always (fixnum fixnum) :bool "(#0) & 1")

(def-inline evenp :always (t) :bool "ecl_evenp(#0)")
(def-inline evenp :always (fixnum fixnum) :bool "~(#0) & 1")

(def-inline abs :always (t t) t "ecl_abs(#0,#1)")

(def-inline exp :always (t) t "ecl_exp(#0)")

(def-inline expt :always (t t) t "ecl_expt(#0,#1)")
(def-inline expt :always ((integer 2 2) (integer 0 29)) :fixnum "(1<<(#1))")
(def-inline expt :always ((integer 0 0) t) :fixnum "0")
(def-inline expt :always ((integer 1 1) t) :fixnum "1")

(def-inline log :always (fixnum-float) :double "log((double)(#0))" :exact-return-type t)
(def-inline log :always (fixnum-float) :float "(float)log((double)(#0))" :exact-return-type t)

(def-inline sqrt :always (number) number "ecl_sqrt(#0)")
(def-inline sqrt :always ((long-float 0.0 *)) :double "sqrt((double)(#0))")
(def-inline sqrt :always ((double-float 0.0 *)) :double "sqrt((double)(#0))")
(def-inline sqrt :always ((single-float 0.0 *)) :float "(float)sqrt((double)(#0))")
(def-inline sqrt :always ((short-float 0.0 *)) :float "(float)sqrt((double)(#0))")

(def-inline sin :always (number) number "ecl_sin(#0)")
(def-inline sin :always (fixnum-float) :double "sin((double)(#0))" :exact-return-type t)
(def-inline sin :always (fixnum-float) :float "(float)sin((double)(#0))" :exact-return-type t)

(def-inline cos :always (t) number "ecl_cos(#0)")
(def-inline cos :always (fixnum-float) :double "cos((double)(#0))" :exact-return-type t)
(def-inline cos :always (fixnum-float) :float "(float)cos((double)(#0))" :exact-return-type t)

(def-inline tan :always (t) number "ecl_tan(#0)")
(def-inline tan :always (fixnum-float) :double "tan((double)(#0))" :exact-return-type t)
(def-inline tan :always (fixnum-float) :float "(float)tan((double)(#0))" :exact-return-type t)

(def-inline sinh :always (t) number "ecl_sinh(#0)")
(def-inline sinh :always (fixnum-float) :double "sinh((double)(#0))" :exact-return-type t)
(def-inline sinh :always (fixnum-float) :float "(float)sinh((double)(#0))" :exact-return-type t)

(def-inline cosh :always (t) number "ecl_cosh(#0)")
(def-inline cosh :always (fixnum-float) :double "cosh((double)(#0))" :exact-return-type t)
(def-inline cosh :always (fixnum-float) :float "(float)cosh((double)(#0))" :exact-return-type t)

(def-inline tanh :always (t) number "ecl_tanh(#0)")
(def-inline tanh :always (fixnum-float) :double "tanh((double)(#0))" :exact-return-type t)
(def-inline tanh :always (fixnum-float) :float "(float)tanh((double)(#0))" :exact-return-type t)

;; file package.d

;; file pathname.d

(def-inline null :always (t) :bool "#0==ECL_NIL")

(def-inline symbolp :always (t) :bool "@0;ECL_SYMBOLP(#0)")

(def-inline atom :always (t) :bool "@0;ECL_ATOM(#0)")

(def-inline consp :always (t) :bool "@0;ECL_CONSP(#0)")

(def-inline listp :always (t) :bool "@0;ECL_LISTP(#0)")

(def-inline numberp :always (t) :bool "ecl_numberp(#0)")

(def-inline integerp :always (t) :bool "@0;ECL_FIXNUMP(#0)||ECL_BIGNUMP(#0)")

(def-inline floatp :always (t) :bool "floatp(#0)")

(def-inline characterp :always (t) :bool "ECL_CHARACTERP(#0)")

(def-inline base-char-p :always (character) :bool "ECL_BASE_CHAR_P(#0)")

(def-inline stringp :always (t) :bool "@0;ECL_STRINGP(#0)")

(def-inline base-string-p :always (t) :bool "@0;ECL_BASE_STRINGP(#0)")

(def-inline bit-vector-p :always (t) :bool "@0;ECL_BIT_VECTOR_P(#0)")

(def-inline vectorp :always (t) :bool "@0;ECL_VECTORP(#0)")

(def-inline arrayp :always (t) :bool "@0;ECL_ARRAYP(#0)")

(def-inline eq :always (t t) :bool "(#0)==(#1)")
(def-inline eq :always (fixnum fixnum) :bool "(#0)==(#1)")

(def-inline eql :always (t t) :bool "ecl_eql(#0,#1)")
(def-inline eql :always (character t) :bool "(ECL_CODE_CHAR(#0)==(#1))")
(def-inline eql :always (t character) :bool "((#0)==ECL_CODE_CHAR(#1))")
(def-inline eql :always (character character) :bool "(#0)==(#1)")
(def-inline eql :always ((not (or complex bignum ratio float)) t) :bool
 "(#0)==(#1)")
(def-inline eql :always (t (not (or complex bignum ratio float))) :bool
 "(#0)==(#1)")
(def-inline eql :always (fixnum fixnum) :bool "(#0)==(#1)")

(def-inline equal :always (t t) :bool "ecl_equal(#0,#1)")
(def-inline equal :always (fixnum fixnum) :bool "(#0)==(#1)")

(def-inline equalp :always (t t) :bool "ecl_equalp(#0,#1)")
(def-inline equalp :always (fixnum fixnum) :bool "(#0)==(#1)")

(def-inline not :always (t) :bool "(#0)==ECL_NIL")

;; file print.d, read.d

(def-inline clear-output :always (stream) NULL "(ecl_clear_output(#0),ECL_NIL)")

(def-inline finish-output :always (stream) NULL "(ecl_finish_output(#0),ECL_NIL)")

(def-inline finish-output :always (stream) NULL "(ecl_force_output(#0),ECL_NIL)")

(def-inline write-char :always (t) t "@0;(ecl_princ_char(ecl_char_code(#0),ECL_NIL),(#0))")

(def-inline clear-input :always (stream) NULL "(ecl_clear_input(#0),ECL_NIL)")

(def-inline copy-readtable :always (null null) t "standard_readtable")

(def-inline boundp :always (t) :bool "ecl_boundp(cl_env_copy,#0)")
(def-inline boundp :unsafe ((and symbol (not null))) :bool "ECL_SYM_VAL(cl_env_copy,#0)!=OBJNULL")

;; file unixsys.d

;; file sequence.d

(def-inline elt :always (t t) t "ecl_elt(#0,ecl_fixnum(#1))")
(def-inline elt :always (t fixnum) t "ecl_elt(#0,#1)")
(def-inline elt :always (vector t) t "ecl_aref1(#0,ecl_fixnum(#1))")
(def-inline elt :always (vector fixnum) t "ecl_aref1(#0,#1)")

(def-inline elt :unsafe (t t) t "ecl_elt(#0,ecl_fixnum(#1))")
(def-inline elt :unsafe (t fixnum) t "ecl_elt(#0,#1)")
(def-inline elt :unsafe (vector t) t "ecl_aref_unsafe(#0,ecl_fixnum(#1))")
(def-inline elt :unsafe (vector fixnum) t "ecl_aref_unsafe(#0,#1)")
(def-inline aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))")
(def-inline aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)")
#+unicode
(def-inline aref :unsafe ((array character) fixnum) :wchar
 "(#0)->string.self[#1]")
(def-inline aref :unsafe ((array base-char) fixnum) :unsigned-char
 "(#0)->base_string.self[#1]")
(def-inline aref :unsafe ((array double-float) fixnum) :double
 "(#0)->array.self.df[#1]")
(def-inline aref :unsafe ((array single-float) fixnum) :float
 "(#0)->array.self.sf[#1]")
(def-inline aref :unsafe ((array fixnum) fixnum) :fixnum
 "(#0)->array.self.fix[#1]")

(def-inline si:elt-set :always (t t t) t "ecl_elt_set(#0,ecl_to_size(#1),#2)")
(def-inline si:elt-set :always (t fixnum t) t "ecl_elt_set(#0,#1,#2)")
(def-inline si:elt-set :always (vector t t) t "ecl_aset1(#0,ecl_to_size(#1),#2)")
(def-inline si:elt-set :always (vector fixnum t) t "ecl_aset1(#0,#1,#2)")

(def-inline si:elt-set :unsafe (t t t) t "ecl_elt_set(#0,ecl_fixnum(#1),#2)")
(def-inline si:elt-set :unsafe (vector t t) t "ecl_aset_unsafe(#0,ecl_to_size(#1),#2)")
(def-inline si:elt-set :unsafe (vector fixnum t) t "ecl_aset_unsafe(#0,#1,#2)")

(def-inline length :always (t) :fixnum "ecl_length(#0)")
(def-inline length :unsafe (vector) :fixnum "(#0)->vector.fillp")

(def-inline copy-seq :always (t) t "ecl_copy_seq(#0)")

;; file character.d

(def-inline char :always (t fixnum) t "ecl_aref1(#0,#1)")
(def-inline char :always (t fixnum) :wchar "ecl_char(#0,#1)")
#-unicode
(def-inline char :unsafe (t t) t "ECL_CODE_CHAR((#0)->base_string.self[ecl_fixnum(#1)])")
#-unicode
(def-inline char :unsafe (t fixnum) :unsigned-char "(#0)->base_string.self[#1]")
(def-inline char :unsafe (base-string fixnum) :unsigned-char "(#0)->base_string.self[#1]")
#+unicode
(def-inline char :unsafe (ext:extended-string fixnum) :wchar "(#0)->string.self[#1]")

(def-inline si:char-set :always (t t t) t "si_char_set(#0,#1,#2)")
(def-inline si:char-set :always (t fixnum t) t "ecl_aset1(#0,#1,#2)")
(def-inline si:char-set :always (t fixnum character) :wchar "ecl_char_set(#0,#1,#2)")
#-unicode
(def-inline si:char-set :unsafe (t t t) t
 "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))")
#-unicode
(def-inline si:char-set :unsafe (t fixnum character) :unsigned-char
 "(#0)->base_string.self[#1]= #2")
(def-inline si:char-set :unsafe (base-string t t) t
 "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))")
(def-inline si:char-set :unsafe (base-string fixnum base-char) :unsigned-char
 "(#0)->base_string.self[#1]= #2")
(def-inline si:char-set :unsafe (ext:extended-string t t) t
 "@2;((#0)->string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))")
(def-inline si:char-set :unsafe (ext:extended-string fixnum character) :unsigned-char
 "(#0)->string.self[#1]= #2")

(def-inline schar :always (t t) t "ecl_elt(#0,ecl_to_size(#1))")
(def-inline schar :always (t fixnum) t "ecl_elt(#0,#1)")
(def-inline schar :always (t fixnum) :wchar "ecl_char(#0,#1)")
(def-inline schar :unsafe (base-string t) t "ECL_CODE_CHAR((#0)->base_string.self[ecl_fixnum(#1)])")
#-unicode
(def-inline schar :unsafe (t fixnum) :unsigned-char "(#0)->base_string.self[#1]")
(def-inline schar :unsafe (base-string fixnum) :unsigned-char "(#0)->base_string.self[#1]")
#+unicode
(def-inline schar :unsafe (ext:extended-string fixnum) :wchar "(#0)->string.self[#1]")

(def-inline si:schar-set :always (t t t) t "ecl_elt_set(#0,ecl_to_size(#1),#2)")
(def-inline si:schar-set :always (t fixnum t) t "ecl_elt_set(#0,#1,#2)")
(def-inline si:schar-set :always (t fixnum character) :wchar "ecl_char_set(#0,#1,#2)")
#-unicode
(def-inline si:schar-set :unsafe (t t t) t
 "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))")
#-unicode
(def-inline si:schar-set :unsafe (t fixnum base-char) :unsigned-char
 "(#0)->base_string.self[#1]= #2")
(def-inline si:schar-set :unsafe (base-string t t) t
 "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))")
(def-inline si:schar-set :unsafe (base-string fixnum base-char) :unsigned-char
 "(#0)->base_string.self[#1]= #2")
#+unicode
(def-inline si:schar-set :unsafe (ext:extended-string fixnum t) :wchar
 "@2;((#0)->string.self[#1]= ecl_char_code(#2),(#2))")
#+unicode
(def-inline si:schar-set :unsafe (ext:extended-string fixnum character) :wchar
 "(#0)->string.self[#1]= #2")

(def-inline string= :always (string string) :bool "ecl_string_eq(#0,#1)")

;; file structure.d

(def-inline si:structure-name :always (structure-object) symbol "ECL_STRUCT_NAME(#0)")

(def-inline si:structure-ref :always (t t fixnum) t "ecl_structure_ref(#0,#1,#2)")

(def-inline si:structure-set :always (t t fixnum t) t
 "ecl_structure_set(#0,#1,#2,#3)")

;; file symbol.d

(def-inline get :always (t t t) t "ecl_get(#0,#1,#2)")
(def-inline get :always (t t) t "ecl_get(#0,#1,ECL_NIL)")

(def-inline symbol-name :always (t) string "ecl_symbol_name(#0)")

;; Additions used by the compiler.
;; The following functions do not exist. They are always expanded into the
;; given C code. References to these functions are generated in the C1 phase.

(def-inline shift>> :always (fixnum fixnum) :fixnum "((#0) >> (- (#1)))")

(def-inline shift<< :always (fixnum fixnum) :fixnum "((#0) << (#1))")

(def-inline si:short-float-p :always (t) :bool "@0;ECL_SINGLE_FLOAT_P(#0)")

(def-inline si:single-float-p :always (t) :bool "@0;ECL_SINGLE_FLOAT_P(#0)")

(def-inline si:double-float-p :always (t) :bool "@0;ECL_DOUBLE_FLOAT_P(#0)")

#-long-float
(def-inline si:long-float-p :always (t) :bool "@0;ECL_DOUBLE_FLOAT_P(#0)")
#+long-float
(def-inline si:long-float-p :always (t) :bool "@0;ECL_LONG_FLOAT_P(#0)")

(def-inline ext:fixnump :always (t) :bool "ECL_FIXNUMP(#0)")
(def-inline ext:fixnump :always (fixnum) :bool "1")

;; Functions only available with threads
#+threads
(def-inline mp:lock-count :unsafe (mp:lock) fixnum "((#0)->lock.count)")

;; Functions only available with CLOS

#+clos
(def-inline si:instance-ref :always (t fixnum) t "ecl_instance_ref((#0),(#1))")
#+clos
(def-inline si:instance-ref :unsafe (standard-object fixnum) t
 "(#0)->instance.slots[#1]")

#+clos
(def-inline si::instance-sig :unsafe (standard-object) list
 "(#0)->instance.sig")

#+clos
(def-inline si:instance-set :unsafe (t fixnum t) t
 "ecl_instance_set((#0),(#1),(#2))")
#+clos
(def-inline si:instance-set :unsafe (standard-object fixnum t) t
 "(#0)->instance.slots[#1]=(#2)")

#+clos
(def-inline si:instance-class :always (standard-object) t "ECL_CLASS_OF(#0)")
#+clos
(def-inline class-of :unsafe (standard-object) t "ECL_CLASS_OF(#0)")

#+clos
(def-inline si::instancep :always (t) :bool "@0;ECL_INSTANCEP(#0)")
#+clos
(def-inline si:unbound :always nil t "ECL_UNBOUND")

#+clos
(def-inline si:sl-boundp :always (t) :bool "(#0)!=ECL_UNBOUND")

#+clos
(def-inline clos:standard-instance-access :always (t fixnum) t "ecl_instance_ref((#0),(#1))")
#+clos
(def-inline clos:standard-instance-access :unsafe (standard-object fixnum) t
 "(#0)->instance.slots[#1]")

#+clos
(def-inline clos:funcallable-standard-instance-access :always (t fixnum) t "ecl_instance_ref((#0),(#1))")
#+clos
(def-inline clos:funcallable-standard-instance-access :unsafe (clos:funcallable-standard-object fixnum) t
 "(#0)->instance.slots[#1]")

))) ; eval-when

(defun make-inline-information (*machine*)
  (let ((*inline-information* (make-hash-table :size 512 :test 'equal)))
    (loop for i in '#.(mapcar #'rest +inline-forms+)
       do (apply #'def-inline i))
    *inline-information*))

(defun inline-information (name safety)
  (gethash (list name safety) *inline-information*))

(defun (setf inline-information) (value name safety)
  (setf (gethash (list name safety) *inline-information*) value))

(defun def-inline (name safety arg-types return-rep-type expansion
                   &key (one-liner t) (exact-return-type nil) (inline-or-warn nil)
                   (multiple-values t)
                   &aux arg-rep-types)
  (setf safety
        (case safety
          (:unsafe :inline-unsafe)
          (:safe :inline-safe)
          (:always :inline-always)
          (t (error "In DEF-INLINE, wrong value of SAFETY"))))
  ;; Ensure we can inline this form. We only inline when the features are
  ;; there (checked above) and when the C types are part of this machine
  ;; (checked here).
  (loop for type in (list* return-rep-type arg-types)
     unless (or (eq type 'fixnum-float)
                (and (consp type) (eq (car type) 'values))
                (lisp-type-p type)
                (machine-c-type-p type))
     do (warn "Dropping inline form for ~A because of missing type ~A" name type)
       (return-from def-inline))
  (setf arg-rep-types
        (mapcar #'(lambda (x) (if (eq x '*) x (lisp-type->rep-type x)))
                arg-types))
  (when (eq return-rep-type t)
    (setf return-rep-type :object))
  (when inline-or-warn
    (setf (inline-information name 'should-be-inlined) t))
  (let* ((return-type (if (and (consp return-rep-type)
                               (eq (first return-rep-type) 'values))
                          t
                          (rep-type->lisp-type return-rep-type)))
         (inline-info
          (make-inline-info :name name
                            :arg-rep-types arg-rep-types
                            :return-rep-type return-rep-type
                            :return-type return-type
                            :arg-types arg-types
                            :exact-return-type exact-return-type
                            :multiple-values multiple-values
                            ;; :side-effects (not (si:get-sysprop name 'no-side-effects))
                            :one-liner one-liner
                            :expansion expansion)))
    #+(or)
    (loop for i in (inline-information name safety)
       when (and (equalp (inline-info-arg-types i) arg-types)
                 (not (equalp return-type (inline-info-return-type i))))
       do (format t "~&;;; Redundand inline definition for ~A~&;;; ~<~A~>~&;;; ~<~A~>"
                  name i inline-info))
    (push inline-info (gethash (list name safety) *inline-information*))))

(setf (machine-inline-information +default-machine+)
      (make-inline-information +default-machine+))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; FUNCTIONS WHICH CAN BE CALLED FROM C
;;;
;;; The following two lists contain all functions in the core library which do
;;; not belong to the C part of the library, but which should have an exported C
;;; name that users (and compiled code) can refer to. This means, for instance, that
;;; MAKE-ARRAY will be compiled to a function called cl_make_array, etc.
;;;

(in-package "SI")

(defvar c::*in-all-symbols-functions*
  `(;; arraylib.lsp
    make-array vector array-dimensions array-in-bounds-p array-row-major-index
    bit sbit bit-and bit-ior bit-xor bit-eqv bit-nand bit-nor bit-andc1
    bit-andc2 bit-orc1 bit-orc2 bit-not
    vector-pop adjust-array
    ;; assert.lsp
    si::do-check-type si::ecase-error si::etypecase-error
    si::wrong-type-argument si::ccase-error si::ctypecase-error
    ;; config.lsp
    short-site-name long-site-name machine-type machine-instance machine-version
    software-type software-version lisp-implementation-type lisp-implementation-version
    si::lisp-implementation-vcs-id
    ;; assignment.lsp
    si::setf-definition
    ;; conditions.lsp
    si::safe-eval abort continue muffle-warning store-value use-value
    si::bind-simple-restarts si::bind-simple-handlers
    si::assert-failure compute-restarts find-restart invoke-restart
    invoke-restart-interactively make-condition
    ;; describe.lsp
    describe inspect
    ;; iolib.lsp
    read-from-string write-to-string prin1-to-string princ-to-string
    y-or-n-p yes-or-no-p string-to-object dribble ext:make-encoding
    ext:make-encoding
    ext:load-encoding
    ;; listlib.lsp
    union nunion intersection nintersection set-difference nset-difference
    set-exclusive-or nset-exclusive-or subsetp rassoc-if rassoc-if-not
    assoc-if assoc-if-not member-if member-if-not subst-if subst-if-not
    nsubst-if nsubst-if-not
    ;; mislib.lsp
    logical-pathname-translations load-logical-pathname-translations decode-universal-time
    encode-universal-time get-decoded-time
    ensure-directories-exist si::simple-program-error si::signal-simple-error
    ;; module.lsp
    provide require
    ;; numlib.lsp
    isqrt phase signum cis
    asin acos asinh acosh atanh ffloor fceiling ftruncate fround
    logtest byte byte-size byte-position ldb ldb-test mask-field dpb
    deposit-field
    ;; packlib.lsp
    find-all-symbols apropos apropos-list
    ;; predlib.lsp
    upgraded-array-element-type upgraded-complex-part-type typep subtypep coerce
    do-deftype si::ratiop si::single-float-p si::short-float-p si::double-float-p
    si::long-float-p
    ;; seq.lsp
    make-sequence concatenate map some every notany notevery map-into
    complement
    ;; seqlib.lsp
    reduce fill replace
    remove remove-if remove-if-not delete delete-if delete-if-not
    count count-if count-if-not substitute substitute-if substitute-if-not
    nsubstitute nsubstitute-if nsubstitute-if-not find find-if find-if-not
    position position-if position-if-not remove-duplicates
    delete-duplicates mismatch search sort stable-sort merge constantly
    ;; setf.lsp
    si::do-defsetf si::do-define-setf-method
    ;; process.lsp
    ext:run-program
    ext:terminate-process
    ;; pprint.lsp
    pprint-fill copy-pprint-dispatch pprint-dispatch
    pprint-linear pprint-newline pprint-tab pprint-tabular
    set-pprint-dispatch pprint-indent

    #+clos
    ,@'(;; combin.lsp
     method-combination-error
     invalid-method-error
     clos:std-compute-applicable-methods
     clos:std-compute-effective-method
     clos:compute-effective-method-function
     ;; std-slot-value.lsp
     clos::standard-instance-access ;; alias clos:funcallable-standard-instance-access
     clos::standard-instance-set
     subclassp of-class-p
     ;; boot.lsp
     slot-boundp
     slot-makunbound
     slot-value
     clos::slot-value-set
     slot-exists-p
     clos::need-to-make-load-form-p
     ;; defclass
     clos:load-defclass
     ;; method
     clos:extract-lambda-list
     clos:extract-specializer-names
     )

    ;; cdr-5
    ext:array-index-p
    ext:negative-fixnum-p ext:non-negative-fixnum-p
    ext:non-positive-fixnum-p ext:positive-fixnum-p
    ext:negative-integer-p ext:non-negative-integer-p
    ext:non-positive-integer-p ext:positive-integer-p 
    ext:negative-rational-p ext:non-negative-rational-p
    ext:non-positive-rational-p ext:positive-rational-p 
    ext:negative-ratio-p ext:non-negative-ratio-p
    ext:non-positive-ratio-p ext:positive-ratio-p 
    ext:negative-real-p ext:non-negative-real-p
    ext:non-positive-real-p ext:positive-real-p 
    ext:negative-float-p ext:non-negative-float-p
    ext:non-positive-float-p ext:positive-float-p 
    ext:negative-short-float-p ext:non-negative-short-float-p
    ext:non-positive-short-float-p ext:positive-short-float-p 
    ext:negative-single-float-p ext:non-negative-single-float-p
    ext:non-positive-single-float-p ext:positive-single-float-p 
    ext:negative-double-float-p ext:non-negative-double-float-p
    ext:non-positive-double-float-p ext:positive-double-float-p 
    ext:negative-long-float-p ext:non-negative-long-float-p
    ext:non-positive-long-float-p ext:positive-long-float-p 
))

(proclaim
  `(si::c-export-fname #+ecl-min ,@c::*in-all-symbols-functions*
    typecase-error-string find-documentation find-declarations
    si::search-keyword si::check-keyword
    si::dm-too-many-arguments si::dm-too-few-arguments
    remove-documentation si::get-documentation
    si::set-documentation si::expand-set-documentation
    si::packages-iterator
    si::pprint-logical-block-helper si::pprint-pop-helper
    si::make-seq-iterator si::seq-iterator-ref
    si::seq-iterator-set si::seq-iterator-next
    si::sequence-count
    si::structure-type-error si::define-structure
    si::coerce-to-list si::coerce-to-vector
    si::traced-old-definition

    #+formatter
    ,@'(
    format-princ format-prin1 format-print-named-character
    format-print-integer
    format-print-cardinal format-print-ordinal format-print-old-roman
    format-print-roman format-fixed format-exponential
    format-general format-dollars
    format-relative-tab format-absolute-tab
    format-justification
        )
    #+clos
    ,@'(;; defclass.lsp
     clos::ensure-class
     clos::find-slot-definition
     ;; combin.lsp
     clos::simple-code-walker
     ;; kernel.lsp
     clos::install-method
     clos::default-initargs-of
     ;; clos::generic-function-lambda-list
     ;; clos::generic-function-argument-precedence-order
     ;; clos::generic-function-method-combination
     ;; clos::generic-function-method-class
     ;; clos::generic-function-methods
     ;; clos::method-generic-function
     ;; clos::method-lambda-list
     ;; clos::method-specializers
     ;; clos::method-qualifiers
     ;; clos::method-function
     ;; clos::method-plist
     clos::associate-methods-to-gfun
     ;; method.lsp
     clos::pop-next-method
     )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/cmp/sysfun.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/package.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(pushnew :cdr-1 *features*)

(defpackage "CLOS"
  (:use "CL" "EXT")
  (:import-from "SI" "UNBOUND" "GET-SYSPROP" "PUT-SYSPROP" "REM-SYSPROP"
                "SIMPLE-PROGRAM-ERROR"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/package.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/macros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(defmacro mapappend (fun &rest args)
  `(reduce #'append (mapcar ,fun ,@args)))

(defmacro ensure-up-to-date-instance (instance)
  ;; The up-to-date status of a class is determined by
  ;; instance.sig. This slot of the C structure contains a list of
  ;; slot definitions that was used to create the instance. When the
  ;; class is updated, the list is newly created. Structures are also
  ;; "instances" but keep ECL_UNBOUND instead of the list.
  `(let* ((i ,instance)
          (s (si::instance-sig i)))
     (declare (:read-only i s))
     (when (si:sl-boundp s)
       (unless (eq s (class-slots (si::instance-class i)))
         (update-instance i)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/macros.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/walk.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: WALKER
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;
;;; *************************************************************************
;;; Copyright (c) 1985, 1986, 1987, 1988, 1989, 1990 Xerox Corporation.
;;; All rights reserved.
;;;
;;; Use and copying of this software and preparation of derivative works
;;; based upon this software are permitted.  Any distribution of this
;;; software or derivative works must comply with all applicable United
;;; States export control laws.
;;; 
;;; This software is made available AS IS, and Xerox Corporation makes no
;;; warranty about the software, its performance or its conformity to any
;;; specification.
;;; 
;;; Any person obtaining a copy of this software is requested to send their
;;; name and post office or electronic mail address to:
;;;   CommonLoops Coordinator
;;;   Xerox PARC
;;;   3333 Coyote Hill Rd.
;;;   Palo Alto, CA 94304
;;; (or send Arpanet mail to CommonLoops-Coordinator.pa@Xerox.arpa)
;;;
;;; Suggestions, comments and requests for improvements are also welcome.
;;; *************************************************************************
;;; 
;;; A simple code walker, based IN PART on: (roll the credits)
;;;   Larry Masinter's Masterscope
;;;   Moon's Common Lisp code walker
;;;   Gary Drescher's code walker
;;;   Larry Masinter's simple code walker
;;;   .
;;;   .
;;;   boy, thats fair (I hope).
;;;
;;; For now at least, this code walker really only does what PCL needs it to
;;; do.  Maybe it will grow up someday.
;;;

;;;
;;; This code walker used to be completely portable.  Now it is just "Real
;;; easy to port".  This change had to happen because the hack that made it
;;; completely portable kept breaking in different releases of different
;;; Common Lisps, and in addition it never worked entirely anyways.  So,
;;; its now easy to port.  To port this walker, all you have to write is one
;;; simple macro and two simple functions.  These macros and functions are
;;; used by the walker to manipluate the macroexpansion environments of
;;; the Common Lisp it is running in.
;;;
;;; The code which implements the macroexpansion environment manipulation
;;; mechanisms is in the first part of the file, the real walker follows it.
;;; 

;;;
;;; The user entry points are walk-form and nested-walked-form.  In addition,
;;; it is legal for user code to call the variable information functions:
;;; variable-lexical-p, variable-special-p and variable-class.  Some users
;;; will need to call define-walker-template, they will have to figure that
;;; out for themselves.
;;; 

(pushnew :walker *features*)

(defpackage "WALKER"
  (:export define-walker-template
           walk-form
           walk-form-expand-macros-p
           #-ecl nested-walk-form
           variable-lexical-p
           variable-special-p
           *variable-declarations*
           variable-declaration
           macroexpand-all
           )
  (:import-from "SI" "GET-SYSPROP" "PUT-SYSPROP"))

(in-package "WALKER")
(declaim (notinline note-lexical-binding walk-bindings-1 walk-let/let*
                    walk-form-internal))


;;;
;;; On the following pages are implementations of the implementation specific
;;; environment hacking functions.
;;;
;;; This code just hacks 'macroexpansion environments'.  That is, it is only
;;; concerned with the function binding of symbols in the environment.  The
;;; walker needs to be able to tell if the symbol names a lexical macro or
;;; function, and it needs to be able to build environments which contain
;;; lexical macro or function bindings.  It must be able, when walking a
;;; macrolet, flet or labels form to construct an environment which reflects
;;; the bindings created by that form.  Note that the environment created
;;; does NOT have to be sufficient to evaluate the body, merely to walk its
;;; body.  This means that definitions do not have to be supplied for lexical
;;; functions, only the fact that that function is bound is important.  For
;;; macros, the macroexpansion function must be supplied.
;;;
;;; This code is organized in a way that lets it work in implementations that
;;; stack cons their environments.  That is reflected in the fact that the
;;; only operation that lets a user build a new environment is a with-body
;;; macro which executes its body with the specified symbol bound to the new
;;; environment.  No code in this walker or in PCL will hold a pointer to
;;; these environments after the body returns.  Other user code is free to do
;;; so in implementations where it works, but that code is not considered
;;; portable.
;;;
;;; There are 3 environment hacking tools.  One macro which is used for
;;; creating new environments, and two functions which are used to access the
;;; bindings of existing environments.
;;;
;;; WITH-AUGMENTED-ENVIRONMENT
;;;
;;; ENVIRONMENT-FUNCTION
;;;
;;; ENVIRONMENT-MACRO
;;; 

(defun unbound-lexical-function (&rest args)
  (declare (ignore args))
  (error "The evaluator was called to evaluate a form in a macroexpansion~%~
          environment constructed by the PCL portable code walker.  These~%~
          environments are only useful for macroexpansion, they cannot be~%~
          used for evaluation.~%~
          This error should never occur when using PCL.~%~
          This most likely source of this error is a program which tries to~%~
          to use the PCL portable code walker to build its own evaluator."))


;;;
;;; In Kyoto Common Lisp, the macroexpansion environment is a three element
;;; list.  The second element describes lexical functions and macros.  The 
;;; function entries in this list have the form 
;;;     (<name> FUNCTION <function-value>)
;;; The macro entries have the form
;;;     (<name> MACRO <macro-value>).
;;;
;;;

(defmacro with-augmented-environment
          ((new-env old-env &key functions macros) &body body)
          `(let ((,new-env (with-augmented-environment-internal ,old-env
                                                                ,functions
                                                                ,macros)))
             ,@body))

(defun with-augmented-environment-internal (env functions macros)
  (let* ((vars (car env))
         (funs (cdr env)))
    (dolist (f functions)
      (push `(,(car f) function ,#'unbound-lexical-function) funs))
    (dolist (m macros)
      (push `(,(car m) macro ,(second m)) funs))
    (cons vars funs)))

#+nil
(defun environment-function (env fn)
  (when env
        (let ((entry (assoc fn (cdr env))))
          (and entry
               (eq (second entry) 'FUNCTION)
               (third entry)))))

(defun environment-macro (env macro)
  (declare (si::c-local))
  (when env
        (let ((entry (assoc macro (cdr env))))
          (and entry
               (eq (second entry) 'MACRO)
               (third entry)))))



(defmacro with-new-definition-in-environment
          ((new-env old-env macrolet/flet/labels-form) &body body)
  (let* ((functions (make-symbol "Functions"))
         (macros (make-symbol "Macros")))
    `(let ((,functions ())
           (,macros ()))
       (ecase (car ,macrolet/flet/labels-form)
         ((FLET LABELS)
          (dolist (fn (second ,macrolet/flet/labels-form))
            (push fn ,functions)))
         ((MACROLET)
          (dolist (mac (second ,macrolet/flet/labels-form))
            (push (list (car mac)
                        (convert-macro-to-lambda (second mac)
                                                 (cddr mac)
                                                 (string (car mac))))
                  ,macros))))
       (with-augmented-environment
              (,new-env ,old-env :functions ,functions :macros ,macros)
         ,@body))))

(defun convert-macro-to-lambda (llist body &optional (name "Dummy Macro"))
  (declare (si::c-local))
  (let ((gensym (make-symbol name)))
    (eval `(defmacro ,gensym ,llist ,@body))
    (macro-function gensym)))

;;;
;;; Now comes the real walker.
;;;
;;; As the walker walks over the code, it communicates information to itself
;;; about the walk.  This information includes the walk function, variable
;;; bindings, declarations in effect etc.  This information is inherently
;;; lexical, so the walker passes it around in the actual environment the
;;; walker passes to macroexpansion functions.  This is what makes the
;;; nested-walk-form facility work properly.
;;;
(defmacro walker-environment-bind ((var env &rest key-args)
                                      &body body)
  `(with-augmented-environment
     (,var ,env :macros (walker-environment-bind-1 ,env ,.key-args))
     .,body))

(defvar *key-to-walker-environment* (gensym))

(defun env-lock (env)
  (declare (si::c-local))
  (environment-macro env *key-to-walker-environment*))

(defun walker-environment-bind-1 (env &key (walk-function nil wfnp)
                                           (walk-form nil wfop)
                                           (declarations nil decp)
                                           (lexical-variables nil lexp))
  (declare (si::c-local))
  (let ((lock (env-lock env)))
    (list
      (list *key-to-walker-environment*
            (list (if wfnp walk-function     (car lock))
                  (if wfop walk-form         (second lock))
                  (if decp declarations      (third lock))
                  (if lexp lexical-variables (fourth lock)))))))

(defun env-walk-function (env)
  (declare (si::c-local))
  (first (env-lock env)))

(defun env-walk-form (env)
  (declare (si::c-local))
  (second (env-lock env)))

(defun env-declarations (env)
  (declare (si::c-local))
  (third (env-lock env)))

(defun env-lexical-variables (env)
  (declare (si::c-local))
  (fourth (env-lock env)))


(defun note-declaration (declaration env)
  (declare (si::c-local))
  (push declaration (third (env-lock env))))

(defun note-lexical-binding (thing env)
  (push (list thing :LEXICAL-VAR) (fourth (env-lock env))))

(defun VARIABLE-LEXICAL-P (var env)
  (declare (si::c-local))
  (let ((entry (member var (env-lexical-variables env) :key #'car)))
    (when (eq (cadar entry) :LEXICAL-VAR)
      entry)))

(defun variable-symbol-macro-p (var env)
  (declare (si::c-local))
  (let ((entry (member var (env-lexical-variables env) :key #'car)))
    (when (eq (cadar entry) :macro)
      entry)))

(defvar *VARIABLE-DECLARATIONS* '(SPECIAL TYPE)) ; Beppe

(defun VARIABLE-DECLARATION (declaration var env)
  (if (not (member declaration *variable-declarations*))
      (error "~S is not a recognized variable declaration." declaration)
      (let ((id (or (variable-lexical-p var env) var)))
        (dolist (decl (env-declarations env))
          (when (and (eq (car decl) declaration)
                     (or (eq (second decl) id)
                         (and (eq 'TYPE (car decl))
                              (member var (cddr decl) :test #'eq)))) ; Beppe
            (return decl))))))

(defun VARIABLE-SPECIAL-P (var env)
  (or (not (null (variable-declaration 'SPECIAL var env)))
      (variable-globally-special-p var)))

;;;
;;; VARIABLE-GLOBALLY-SPECIAL-P is used to ask if a variable has been
;;; declared globally special.  Any particular CommonLisp implementation
;;; should customize this function accordingly and send their customization
;;; back.
;;;
;;; The default version of variable-globally-special-p is probably pretty
;;; slow, so it uses *globally-special-variables* as a cache to remember
;;; variables that it has already figured out are globally special.
;;;
;;; This would need to be reworked if an unspecial declaration got added to
;;; Common Lisp.
;;;
;;; Common Lisp nit:
;;;   variable-globally-special-p should be defined in Common Lisp.
;;;

(defun variable-globally-special-p (symbol) (si:specialp symbol))


  ;;   
;;;;;; Handling of special forms (the infamous 24).
  ;;
;;;
;;; and I quote...
;;; 
;;;     The set of special forms is purposely kept very small because
;;;     any program analyzing program (read code walker) must have
;;;     special knowledge about every type of special form. Such a
;;;     program needs no special knowledge about macros...
;;;
;;; So all we have to do here is a define a way to store and retrieve
;;; templates which describe how to walk the 24 special forms and we are all
;;; set...
;;;
;;; Well, its a nice concept, and I have to admit to being naive enough that
;;; I believed it for a while, but not everyone takes having only 24 special
;;; forms as seriously as might be nice.  There are (at least) 3 ways to
;;; lose:
;;
;;;   1 - Implementation x implements a Common Lisp special form as a macro
;;;       which expands into a special form which:
;;;         - Is a common lisp special form (not likely)
;;;         - Is not a common lisp special form (on the 3600 IF --> COND).
;;;
;;;     * We can safe ourselves from this case (second subcase really) by
;;;       checking to see if there is a template defined for something
;;;       before we check to see if we we can macroexpand it.
;;;
;;;   2 - Implementation x implements a Common Lisp macro as a special form.
;;;
;;;     * This is a screw, but not so bad, we save ourselves from it by
;;;       defining extra templates for the macros which are *likely* to
;;;       be implemented as special forms.  (DO, DO* ...)
;;;
;;;   3 - Implementation x has a special form which is not on the list of
;;;       Common Lisp special forms.
;;;
;;;     * This is a bad sort of a screw and happens more than I would like
;;;       to think, especially in the implementations which provide more
;;;       than just Common Lisp (3600, Xerox etc.).
;;;       The fix is not terribly staisfactory, but will have to do for
;;;       now.  There is a hook in get walker-template which can get a
;;;       template from the implementation's own walker.  That template
;;;       has to be converted, and so it may be that the right way to do
;;;       this would actually be for that implementation to provide an
;;;       interface to its walker which looks like the interface to this
;;;       walker.
;;;

(eval-when (#-cross compile load eval)

(defmacro get-walker-template-internal (x) ;Has to be inside eval-when because
  `(get-sysprop ,x 'WALKER-TEMPLATE))      ;Golden Common Lisp doesn't hack
                                           ;compile time definition of macros
                                           ;right for setf.

(defmacro define-walker-template
          (name &optional (template '(NIL REPEAT (EVAL))))
  `(eval-when (load eval)
     (put-sysprop ',name 'WALKER-TEMPLATE ',template)))
)

(defun get-walker-template (x)
  (cond ((symbolp x)
         (or (get-walker-template-internal x)
             (get-implementation-dependent-walker-template x)))
        ((and (listp x) (eq (car x) 'LAMBDA))
         '(LAMBDA REPEAT (EVAL)))
        (t
         (error "Can't get template for ~S" x))))

(defun get-implementation-dependent-walker-template (x)
  (declare (ignore x))
  ())


  ;;   
;;;;;; The actual templates
  ;;   

(define-walker-template BLOCK                (NIL NIL REPEAT (EVAL)))
(define-walker-template CATCH                (NIL EVAL REPEAT (EVAL)))
(define-walker-template COMPILER-LET         walk-compiler-let)
(define-walker-template DECLARE              walk-unexpected-declare)
(define-walker-template EVAL-WHEN            (NIL QUOTE REPEAT (EVAL)))
(define-walker-template FLET                 walk-flet)
(define-walker-template FUNCTION             (NIL CALL))
(define-walker-template GO                   (NIL QUOTE))
(define-walker-template IF                   walk-if)
(define-walker-template LABELS               walk-labels)
(define-walker-template LAMBDA               walk-lambda)
(define-walker-template LET                  walk-let)
(define-walker-template LET*                 walk-let*)
(define-walker-template LOCALLY              walk-locally)
(define-walker-template MACROLET             walk-macrolet)
(define-walker-template MULTIPLE-VALUE-CALL  (NIL EVAL REPEAT (EVAL)))
(define-walker-template MULTIPLE-VALUE-PROG1 (NIL RETURN REPEAT (EVAL)))
(define-walker-template MULTIPLE-VALUE-SETQ  walk-multiple-value-setq)
(define-walker-template MULTIPLE-VALUE-BIND  walk-multiple-value-bind)
(define-walker-template PROGN                (NIL REPEAT (EVAL)))
(define-walker-template PROGV                (NIL EVAL EVAL REPEAT (EVAL)))
(define-walker-template QUOTE                (NIL QUOTE))
(define-walker-template RETURN-FROM          (NIL QUOTE REPEAT (RETURN)))
(define-walker-template SETQ                 walk-setq)
(define-walker-template SYMBOL-MACROLET      walk-symbol-macrolet)
(define-walker-template TAGBODY              walk-tagbody)
(define-walker-template THE                  (NIL QUOTE EVAL))
(define-walker-template THROW                (NIL EVAL EVAL))
(define-walker-template UNWIND-PROTECT       (NIL RETURN REPEAT (EVAL)))

;;; The new special form.
;(define-walker-template pcl::LOAD-TIME-EVAL       (NIL EVAL))

;;;
;;; And the extra templates...
;;;
#+ecl
(define-walker-template DOTIMES walk-dotimes/dolist)
#+ecl
(define-walker-template DOLIST  walk-dotimes/dolist)
#+ecl
(define-walker-template WHEN    walk-when/unless)
#+ecl
(define-walker-template UNLESS  walk-when/unless)
(define-walker-template DO      walk-do)
(define-walker-template DO*     walk-do*)
(define-walker-template PROG    walk-prog)
(define-walker-template PROG*   walk-prog*)
(define-walker-template COND    (NIL REPEAT ((TEST REPEAT (EVAL)))))
(define-walker-template ext::lambda-block walk-named-lambda)    ;Not really right, but
                                                                ;we don't hack block
                                                                ;names anyways.
#+ecl
(define-walker-template ffi::c-inline walk-c-inline)


;;; Controls whether macros are expanded by walk-form
(defvar WALK-FORM-EXPAND-MACROS-P nil)

(defun macroexpand-all (form &optional environment)
  (let ((walk-form-expand-macros-p t))
    (walk-form form environment)))

(defun WALK-FORM (form
                  &optional environment
                            (walk-function
                              #'(lambda (subform context env)
                                  (declare (ignore context env))
                                  subform)))
  (walker-environment-bind (new-env environment :walk-function walk-function)
    (walk-form-internal form :eval new-env)))

;;;
;;; nested-walk-form provides an interface that allows nested macros, each
;;; of which must walk their body to just do one walk of the body of the
;;; inner macro.  That inner walk is done with a walk function which is the
;;; composition of the two walk functions.
;;;
;;; This facility works by having the walker annotate the environment that
;;; it passes to macroexpand-1 to know which form is being macroexpanded.
;;; If then the &whole argument to the macroexpansion function is eq to
;;; the env-walk-form of the environment, nested-walk-form can be certain
;;; that there are no intervening layers and that a nested walk is alright.
;;;
;;; There are some semantic problems with this facility.  In particular, if
;;; the outer walk function returns T as its walk-no-more-p value, this will
;;; prevent the inner walk function from getting a chance to walk the subforms
;;; of the form.  This is almost never what you want, since it destroys the
;;; equivalence between this nested-walk-form function and two seperate
;;; walk-forms.
;;;
#-ecl
(defun NESTED-WALK-FORM (whole
                         form
                         &optional environment
                                   (walk-function
                                     #'(lambda (subform context env)
                                         (declare (ignore context env))
                                         subform)))
  (if (eq whole (env-walk-form environment))
      (let ((outer-walk-function (env-walk-function environment)))
        (throw whole
          (walk-form
            form
            environment
            #'(lambda (f c e)
                ;; First loop to make sure the inner walk function
                ;; has done all it wants to do with this form.
                ;; Basically, what we are doing here is providing
                ;; the same contract walk-form-internal normally
                ;; provides to the inner walk function.
                (let*((inner-result nil)
                      (inner-no-more-p nil)
                      (outer-result nil)
                      (outer-no-more-p nil))
                  (loop
                    (multiple-value-setq (inner-result inner-no-more-p)
                                         (funcall walk-function f c e))
                    (cond (inner-no-more-p (return))
                          ((not (eq inner-result f)))
                          ((not (consp inner-result)) (return))
                          ((get-walker-template (car inner-result)) (return))
                          (t
                           (multiple-value-bind (expansion macrop)
                               (walker-environment-bind
                                     (new-env e :walk-form inner-result)
                                 (macroexpand-1 inner-result new-env))
                             (if macrop
                                 (setq inner-result expansion)
                                 (return)))))
                    (setq f inner-result))
                  (multiple-value-setq (outer-result outer-no-more-p)
                                       (funcall outer-walk-function
                                                inner-result
                                                c
                                                e))
                  (values outer-result
                          (and inner-no-more-p outer-no-more-p)))))))
      (walk-form form environment walk-function)))

;;;
;;; WALK-FORM-INTERNAL is the main driving function for the code walker. It
;;; takes a form and the current context and walks the form calling itself or
;;; the appropriate template recursively.
;;;
;;;   "It is recommended that a program-analyzing-program process a form
;;;    that is a list whose car is a symbol as follows:
;;;
;;;     1. If the program has particular knowledge about the symbol,
;;;        process the form using special-purpose code.  All of the
;;;        standard special forms should fall into this category.
;;;     2. Otherwise, if macro-function is true of the symbol apply
;;;        either macroexpand or macroexpand-1 and start over.
;;;     3. Otherwise, assume it is a function call. "
;;;     

(defun walk-form-internal (form context env
                           &aux fn template)
  ;; First apply the walk-function to perform whatever translation
  ;; the user wants to this form.  If the second value returned
  ;; by walk-function is T then we don't recurse...
  (catch form
    (multiple-value-bind (newform walk-no-more-p)
      (funcall (env-walk-function env) form context env)
      (catch newform
        (cond (walk-no-more-p newform)
              ((not (eq form newform))
               (walk-form-internal newform context env))
              ((not (consp newform))
               (let ((symmac (car (variable-symbol-macro-p newform env))))
                 (if symmac
                     (let ((newnewform (walk-form-internal (cddr symmac)
                                                           context env)))
                       (if (eq newnewform (cddr symmac))
                           (if walk-form-expand-macros-p newnewform newform)
                           newnewform))
                     newform)))
              ((setq template (get-walker-template (setq fn (car newform))))
               (if (symbolp template)
                   (funcall template newform context env)
                   (walk-template newform template context env)))
              (t
               (multiple-value-bind (newnewform macrop)
                 (walker-environment-bind (new-env env :walk-form newform)
                                          (macroexpand-1 newform new-env))
                 (cond
                   (macrop
                    (let ((newnewnewform
                           (walk-form-internal newnewform context env)))
                      (if (eq newnewnewform newnewform)
                          (if walk-form-expand-macros-p newnewform newform)
                          newnewnewform)))
                   ((and (symbolp fn)
                         (not (fboundp fn))
                         (special-operator-p fn))
                    (error
                     "~S is a special form, not defined in the CommonLisp.~%~
                       manual This code walker doesn't know how to walk it.~%~
                       Define a template for this special form and try again."
                     fn))
                   (t
                    ;; Otherwise, walk the form as if its just a standard 
                    ;; functioncall using a template for standard function
                    ;; call.
                    (walk-template
                     newnewform '(CALL REPEAT (EVAL)) context env))))))))))

(defun walk-template (form template context env)
  (declare (si::c-local))
  (if (atom template)
      (ecase template
        ((EVAL FUNCTION TEST EFFECT RETURN)
         (walk-form-internal form :EVAL env))
        ((QUOTE NIL) form)
        (SET
          (walk-form-internal form :SET env))
        ((LAMBDA CALL)
         (cond ((or (symbolp form)
                    (and (listp form)
                         (= (length form) 2)
                         (eq (car form) 'SETF))) form)
               (t (walk-form-internal form context env)))))
      (case (car template)
        (REPEAT
          (walk-template-handle-repeat form
                                       (cdr template)
                                       ;; For the case where nothing happens
                                       ;; after the repeat optimize out the
                                       ;; call to length.
                                       (if (null (cddr template))
                                           ()
                                           (nthcdr (- (length form)
                                                      (length
                                                        (cddr template)))
                                                   form))
                                       context
                                       env))
        (IF
          (walk-template form
                         (if (if (listp (second template))
                                 (eval (second template))
                                 (funcall (second template) form))
                             (third template)
                             (fourth template))
                         context
                         env))
        (REMOTE
          (walk-template form (second template) context env))
        (otherwise
          (cond ((atom form) form)
                (t (recons form
                           (walk-template
                             (car form) (car template) context env)
                           (walk-template
                             (cdr form) (cdr template) context env))))))))

(defun walk-template-handle-repeat (form template stop-form context env)
  (declare (si::c-local))
  (if (eq form stop-form)
      (walk-template form (cdr template) context env)
      (walk-template-handle-repeat-1 form
                                     template
                                     (car template)
                                     stop-form
                                     context
                                     env)))

(defun walk-template-handle-repeat-1 (form template repeat-template
                                           stop-form context env)
  (declare (si::c-local))
  (cond ((null form) ())
        ((eq form stop-form)
         (if (null repeat-template)
             (walk-template stop-form (cdr template) context env)       
             (error "While handling repeat:~%~
                     Ran into stop while still in repeat template.")))
        ((null repeat-template)
         (walk-template-handle-repeat-1
           form template (car template) stop-form context env))
        (t
         (recons form
                 (walk-template (car form) (car repeat-template) context env)
                 (walk-template-handle-repeat-1 (cdr form)
                                                template
                                                (cdr repeat-template)
                                                stop-form
                                                context
                                                env)))))

(defun walk-repeat-eval (form env)
  (and form
       (recons form
               (walk-form-internal (car form) :eval env)
               (walk-repeat-eval (cdr form) env))))

(defun recons (x car cdr)
  (if (or (not (eq (car x) car))
          (not (eq (cdr x) cdr)))
      (cons car cdr)
      x))

(defun relist (x &rest args)
  (declare (si::c-local))
  (if (null args)
      nil
      (relist-internal x args nil)))

(defun relist* (x &rest args)
  (declare (si::c-local))
  (relist-internal x args 'T))

(defun relist-internal (x args *p)
  (declare (si::c-local))
  (if (null (cdr args))
      (if *p (car args) (recons x (car args) nil))
      (recons x
              (car args)
              (relist-internal (cdr x) (cdr args) *p))))


  ;;   
;;;;;; Special walkers
  ;;

(defun walk-declarations (body fn env
                               &optional doc-string-p declarations old-body
                               &aux (form (car body)) macrop new-form)
  (declare (si::c-local))
  (cond ((and (stringp form)                    ;might be a doc string
              (cdr body)                        ;isn't the returned value
              (null doc-string-p)               ;no doc string yet
              (null declarations))              ;no declarations yet
         (recons body
                 form
                 (walk-declarations (cdr body) fn env t)))
        ((and (listp form) (eq (car form) 'DECLARE))
         ;; Got ourselves a real live declaration.  Record it, look for more.
         (dolist (declaration (cdr form))
           (let*((type (car declaration))
                 (name (second declaration))
                 (args (cddr declaration)))
             (if (member type *variable-declarations*)
                 (note-declaration `(,type
                                     ,(or (variable-lexical-p name env) name)
                                     ,.args)
                                   env)
                 (note-declaration declaration env))
             (push declaration declarations)))
         (recons body
                 form
                 (walk-declarations
                   (cdr body) fn env doc-string-p declarations)))
        ((and form
              (listp form)
              (null (get-walker-template (car form)))
              (progn
                (multiple-value-setq (new-form macrop)
                                     (macroexpand-1 form env))
                macrop))
         ;; This form was a call to a macro.  Maybe it expanded
         ;; into a declare?  Recurse to find out.
         (walk-declarations (recons body new-form (cdr body))
                            fn env doc-string-p declarations
                            (or old-body body)))
        (t
         ;; Now that we have walked and recorded the declarations,
         ;; call the function our caller provided to expand the body.
         ;; We call that function rather than passing the real-body
         ;; back, because we are RECONSING up the new body.
         (funcall fn (or old-body body) env))))


(defun walk-unexpected-declare (form context env)
  (declare (ignore context env)
           (si::c-local))
  (warn "Encountered declare ~S in a place where a declare was not expected."
        form)
  form)

(defun walk-arglist (arglist context env &optional (destructuringp nil)
                                         &aux arg)
  (declare (si::c-local))
  (cond ((null arglist) ())
        ((symbolp (setq arg (car arglist)))
         (or (member arg lambda-list-keywords)
             (note-lexical-binding arg env))
         (recons arglist
                 arg
                 (walk-arglist (cdr arglist)
                               context
                               env
                               (and destructuringp
                                    (not (member arg
                                                 lambda-list-keywords))))))
        ((consp arg)
         (prog1 (recons arglist
                        (if destructuringp
                            (walk-arglist arg context env destructuringp)
                            (relist* arg
                                     (car arg)
                                     (walk-form-internal (second arg) :eval env)
                                     (cddr arg)))
                                    (walk-arglist (cdr arglist) context env nil))
                (if (symbolp (car arg))
                    (note-lexical-binding (car arg) env)
                    (note-lexical-binding (cadar arg) env))
                (or (null (cddr arg))
                    (not (symbolp (third arg)))
                    (note-lexical-binding (third arg) env))))
          (t
           (error "Can't understand something in the arglist ~S" arglist))))

(defun walk-let (form context env)
  (walk-let/let* form context env nil))

(defun walk-let* (form context env)
  (walk-let/let* form context env t))

(defun walk-prog (form context env)
  (walk-prog/prog* form context env nil))

(defun walk-prog* (form context env)
  (walk-prog/prog* form context env t))

(defun walk-do (form context env)
  (walk-do/do* form context env nil))

(defun walk-do* (form context env)
  (walk-do/do* form context env t))

(defun walk-let/let* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)
    (let* ((let/let* (car form))
           (bindings (second form))
           (body (cddr form))
           (walked-bindings 
             (walk-bindings-1 bindings
                              old-env
                              new-env
                              context
                              sequentialp))
           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist*
        form let/let* walked-bindings walked-body))))

(defun walk-locally (form context env)
  (declare (ignore context))
  (let* ((locally (car form))
         (body (cdr form))
         (walked-body
          (walk-declarations body #'walk-repeat-eval env)))
    (relist*
     form locally walked-body)))

(defun walk-prog/prog* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)
    (let* ((possible-block-name (second form))
           (blocked-prog (and (symbolp possible-block-name)
                              (not (eq possible-block-name 'nil)))))
      (multiple-value-bind (let/let* block-name bindings body)
          (if blocked-prog
              (values (car form) (cadr form) (caddr form) (cdddr form))
              (values (car form) nil         (cadr  form) (cddr  form)))
        (let* ((walked-bindings 
                 (walk-bindings-1 bindings
                                  old-env
                                  new-env
                                  context
                                  sequentialp))
               (walked-body
                 (walk-declarations 
                   body
                   #'(lambda (real-body real-env)
                       (walk-tagbody-1 real-body context real-env))
                   new-env)))
          (if block-name
              (relist*
                form let/let* block-name walked-bindings walked-body)
              (relist*
                form let/let* walked-bindings walked-body)))))))

(defun walk-do/do* (form context old-env sequentialp)
  (walker-environment-bind (new-env old-env)
    (let* ((do/do* (car form))
           (bindings (second form))
           (end-test (third form))
           (body (cdddr form))
           (walked-bindings (walk-bindings-1 bindings
                                             old-env
                                             new-env
                                             context
                                             sequentialp))
           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form
               do/do*
               (walk-bindings-2 bindings walked-bindings context new-env)
               (walk-template end-test '(TEST REPEAT (EVAL)) context new-env)
               walked-body))))

#+ecl
(defun walk-dotimes/dolist (form context old-env)
  (walker-environment-bind (new-env old-env)
    (let* ((dotimes/dolist (car form))
           (bindings (second form))
           (body (cddr form))
           ; This is a hack. We tread BINDINGS as we
           ; would in a DO/DO* loop.
           (walked-bindings (walk-bindings-1 bindings
                                             old-env
                                             new-env
                                             context
                                             t))
           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form
               dotimes/dolist
               (walk-bindings-2 bindings walked-bindings context new-env)
               walked-body))))

(defun walk-multiple-value-setq (form context env)
  (let ((vars (cadr form)))
    (if (some #'(lambda (var)
                  (variable-symbol-macro-p var env))
              vars)
        (let* ((temps (mapcar #'(lambda (var) (declare (ignore var)) (gensym)) vars))
               (sets (mapcar #'(lambda (var temp) `(setq ,var ,temp)) vars temps))
               (expanded `(multiple-value-bind ,temps 
                               ,(caddr form)
                             ,@sets))
               (walked (walk-form-internal expanded context env)))
          (if (eq walked expanded)
              form
              walked))
        (walk-template form '(nil (repeat (set)) eval) context env))))

(defun walk-multiple-value-bind (form context old-env)
  (walker-environment-bind (new-env old-env)
    (let* ((mvb (car form))
           (bindings (second form))
           (mv-form (walk-template (third form) 'EVAL context old-env))
           (body (cdddr form))
           walked-bindings
           (walked-body
             (walk-declarations 
               body
               #'(lambda (real-body real-env)
                   (setq walked-bindings
                         (walk-bindings-1 bindings
                                          old-env
                                          new-env
                                          context
                                          nil))
                   (walk-repeat-eval real-body real-env))
               new-env)))
      (relist* form mvb walked-bindings mv-form walked-body))))

(defun walk-bindings-1 (bindings old-env new-env context sequentialp)
  (and bindings
       (let ((binding (car bindings)))
         (recons bindings
                 (if (symbolp binding)
                     (prog1 binding
                            (note-lexical-binding binding new-env))
                     (prog1 (relist* binding
                                     (car binding)
                                     (walk-form-internal (second binding)
                                                         context
                                                         (if sequentialp
                                                             new-env
                                                             old-env))
                                     (cddr binding))    ;save cddr for DO/DO*
                                                        ;it is the next value
                                                        ;form. Don't walk it
                                                        ;now though.
                            (note-lexical-binding (car binding) new-env)))
                 (walk-bindings-1 (cdr bindings)
                                  old-env
                                  new-env
                                  context
                                  sequentialp)))))

(defun walk-bindings-2 (bindings walked-bindings context env)
  (declare (si::c-local))
  (and bindings
       (let ((binding (car bindings))
             (walked-binding (car walked-bindings)))
         (recons bindings
                 (if (symbolp binding)
                     binding
                     (relist* binding
                              (car walked-binding)
                              (second walked-binding)
                              (walk-template (cddr binding)
                                             '(EVAL)
                                             context
                                             env)))              
                 (walk-bindings-2 (cdr bindings)
                                  (cdr walked-bindings)
                                  context
                                  env)))))

(defun walk-lambda (form context old-env)
  (walker-environment-bind (new-env old-env)
    (let* ((arglist (second form))
           (body (cddr form))
           (walked-arglist (walk-arglist arglist context new-env))
           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form
               (car form)
               walked-arglist
               walked-body))))

(defun walk-named-lambda (form context old-env)
  (walker-environment-bind (new-env old-env)
    (let* ((name (second form))
           (arglist (third form))
           (body (cdddr form))
           (walked-arglist (walk-arglist arglist context new-env))
           (walked-body
             (walk-declarations body #'walk-repeat-eval new-env)))
      (relist* form
               (car form)
               name
               walked-arglist
               walked-body))))  

(defun walk-setq (form context env)
  (if (cdddr form)
      (let* ((expanded (let* ((rforms nil)
                              (tail (cdr form)))
                         (loop (when (null tail) (return (nreverse rforms)))
                               (let ((var (pop tail)) (val (pop tail)))
                                 (push `(setq ,var ,val) rforms)))))
             (walked (walk-repeat-eval expanded env)))
        (if (eq expanded walked)
            form
            `(progn ,@walked)))
      (let* ((var (cadr form))
             (val (caddr form))
             (symmac (car (variable-symbol-macro-p var env))))
        (if symmac
            (let* ((expanded `(setf ,(cddr symmac) ,val))
                   (walked (walk-form-internal expanded context env)))
              (if (eq expanded walked)
                  form
                  walked))
            (relist form 'setq
                    (walk-form-internal var :set env)
                    (walk-form-internal val :eval env))))))

(defun walk-symbol-macrolet (form context old-env)
  (declare (ignore context))
  (let* ((bindings (second form)))
    (walker-environment-bind
        (new-env old-env
                 :lexical-variables
                 (append (mapcar #'(lambda (binding)
                                     `(,(first binding)
                                       :macro . ,(second binding)))
                                 bindings)
                         (env-lexical-variables old-env)))
      (relist* form 'SYMBOL-MACROLET bindings
               (walk-repeat-eval (cddr form) new-env)))))

(defun walk-tagbody (form context env)
  (recons form (car form) (walk-tagbody-1 (cdr form) context env)))

(defun walk-tagbody-1 (form context env)
  (declare (si::c-local))
  (and form
       (recons form
               (walk-form-internal (car form)
                                   (if (symbolp (car form)) 'QUOTE context)
                                   env)
               (walk-tagbody-1 (cdr form) context env))))

(defun walk-compiler-let (form context old-env)
  (declare (ignore context))
  (let* ((vars ())
         (vals ()))
    (dolist (binding (second form))
      (cond ((symbolp binding) (push binding vars) (push nil vals))
            (t
             (push (car binding) vars)
             (push (eval (second binding)) vals))))
    (relist* form
             (car form)
             (second form)
             (progv vars vals (walk-repeat-eval (cddr form) old-env)))))

(defun walk-macrolet (form context old-env)
  (walker-environment-bind (macro-env
                            nil
                            :walk-function (env-walk-function old-env))
    (labels ((walk-definitions (definitions)
               (and definitions
                    (let ((definition (car definitions)))
                      (recons definitions
                              (relist* definition
                                       (car definition)
                                       (walk-arglist (second definition)
                                                     context
                                                     macro-env
                                                     t)
                                       (walk-declarations (cddr definition)
                                                          #'walk-repeat-eval
                                                          macro-env))
                              (walk-definitions (cdr definitions)))))))
      (with-new-definition-in-environment (new-env old-env form)
        (relist* form
                 (car form)
                 (walk-definitions (second form))
                 (walk-declarations (cddr form)
                                    #'walk-repeat-eval
                                    new-env))))))

(defun walk-flet (form context old-env)
  (labels ((walk-definitions (definitions)
             (if (null definitions)
                 ()
                 (recons definitions
                         (walk-lambda (car definitions) context old-env)
                         (walk-definitions (cdr definitions))))))
    (recons form
            (car form)
            (recons (cdr form)
                    (walk-definitions (second form))
                    (with-new-definition-in-environment (new-env old-env form)
                      (walk-declarations (cddr form)
                                         #'walk-repeat-eval
                                         new-env))))))

(defun walk-labels (form context old-env)
  (with-new-definition-in-environment (new-env old-env form)
    (labels ((walk-definitions (definitions)
               (if (null definitions)
                   ()
                   (recons definitions
                           (walk-lambda (car definitions) context new-env)
                           (walk-definitions (cdr definitions))))))
      (recons form
              (car form)
              (recons (cdr form)
                      (walk-definitions (second form))
                      (walk-declarations (cddr form)
                                         #'walk-repeat-eval
                                         new-env))))))

(defun walk-if (form context env)
  (let*((predicate (second form))
        (arm1 (third form))
        (arm2 
          (if (cddddr form)
              (progn
                (warn "In the form:~%~S~%~
                       IF only accepts three arguments, you are using ~D.~%~
                       It is true that some Common Lisps support this, but ~
                       it is not~%~
                       truly legal Common Lisp.  For now, this code ~
                       walker is interpreting ~%~
                       the extra arguments as extra else clauses. ~
                       Even if this is what~%~
                       you intended, you should fix your source code."
                      form
                      (length (cdr form)))
                (cons 'PROGN (cdddr form)))
              (fourth form))))
    (relist form
            'IF
            (walk-form-internal predicate context env)
            (walk-form-internal arm1 context env)
            (walk-form-internal arm2 context env))))

#+ecl
(defun walk-when/unless (form context env)
  (relist* form
           (first form)
           (walk-form-internal (second form) context env) ; predicate
           (walk-repeat-eval (cddr form) env)))

#+ecl
(defun walk-c-inline (form context env)
  (declare (ignore context))
  (relist* form
           (first form)
           (walk-repeat-eval (second form) env) ; arguments
           (cddr form))) ; types and flags of the form

;;;
;;; Tests tests tests
;;;

#|
;;; 
;;; Here are some examples of the kinds of things you should be able to do
;;; with your implementation of the macroexpansion environment hacking
;;; mechanism.
;;; 
;;; with-lexical-macros is kind of like macrolet, but it only takes names
;;; of the macros and actual macroexpansion functions to use to macroexpand
;;; them.  The win about that is that for macros which want to wrap several
;;; macrolets around their body, they can do this but have the macroexpansion
;;; functions be compiled.  See the WITH-RPUSH example.
;;;
;;; If the implementation had a special way of communicating the augmented
;;; environment back to the evaluator that would be totally great.  It would
;;; mean that we could just augment the environment then pass control back
;;; to the implementations own compiler or interpreter.  We wouldn't have
;;; to call the actual walker.  That would make this much faster.  Since the
;;; principal client of this is defmethod it would make compiling defmethods
;;; faster and that would certainly be a win.
;;;
(defmacro with-lexical-macros (macros &body body &environment old-env)
  (with-augmented-environment (new-env old-env :macros macros)
    (walk-form (cons 'PROGN body) new-env)))

(defun expand-rpush (form env)
  `(push ,(third form) ,(second form)))

(defmacro with-rpush (&body body)
  `(with-lexical-macros ,(list (list 'RPUSH #'expand-rpush)) ,@body))


;;;
;;; Unfortunately, I don't have an automatic tester for the walker.  
;;; Instead there is this set of test cases with a description of
;;; how each one should go.
;;; 
(defmacro take-it-out-for-a-test-walk (form)
  `(progn 
     (terpri)
     (terpri)
     (let ((copy-of-form (copy-tree ',form))
           (result (walk-form ',form nil
                              '(lambda (x y env)
                                 (format t "~&Form: ~S ~3T Context: ~A" x y)
                                 (when (symbolp x)
                                   (let ((lexical (variable-lexical-p x env))
                                         (special (variable-special-p x env)))
                                     (when lexical
                                       (format t ";~3T")
                                       (format t "lexically bound"))
                                     (when special
                                       (format t ";~3T")
                                       (format t "declared special"))
                                     (when (boundp x)
                                       (format t ";~3T")
                                       (format t "bound: ~S " (eval x)))))
                                 x))))
       (cond ((not (equal result copy-of-form))
              (format t "~%Warning: Result not EQUAL to copy of start."))
             ((not (eq result ',form))
              (format t "~%Warning: Result not EQ to copy of start.")))
       (pprint result)
       result)))

(defmacro foo (&rest ignore) ''GLOBAL-FOO)

(defmacro bar (&rest ignore) ''GLOBAL-BAR)

(take-it-out-for-a-test-walk (list arg1 arg2 arg3))
(take-it-out-for-a-test-walk (list (cons 1 2) (list 3 4 5)))

(take-it-out-for-a-test-walk (progn (foo) (bar 1)))

(take-it-out-for-a-test-walk (block block-name a b c))
(take-it-out-for-a-test-walk (block block-name (list a) b c))

(take-it-out-for-a-test-walk (catch catch-tag (list a) b c))
;;;
;;; This is a fairly simple macrolet case.  While walking the body of the
;;; macro, x should be lexically bound. In the body of the macrolet form
;;; itself, x should not be bound.
;;; 
(take-it-out-for-a-test-walk
  (macrolet ((foo (x) (list x) ''INNER))
    x
    (foo 1)))

;;;
;;; A slightly more complex macrolet case.  In the body of the macro x
;;; should not be lexically bound.  In the body of the macrolet form itself
;;; x should be bound.  Note that THIS CASE WILL CAUSE AN ERROR when it
;;; tries to macroexpand the call to foo.
;;; 
(take-it-out-for-a-test-walk
     (let ((x 1))
       (macrolet ((foo () (list x) ''INNER))
         x
         (foo))))

;;;
;;; A truly hairy use of compiler-let and macrolet.  In the body of the
;;; macro x should not be lexically bound.  In the body of the macrolet
;;; itself x should not be lexically bound.  But the macro should expand
;;; into 1.
;;; 
(take-it-out-for-a-test-walk
  (compiler-let ((x 1))
    (let ((x 2))
      (macrolet ((foo () x))
        x
        (foo)))))


(take-it-out-for-a-test-walk
  (flet ((foo (x) (list x y))
         (bar (x) (list x y)))
    (foo 1)))

(take-it-out-for-a-test-walk
  (let ((y 2))
    (flet ((foo (x) (list x y))
           (bar (x) (list x y)))
      (foo 1))))

(take-it-out-for-a-test-walk
  (labels ((foo (x) (bar x))
           (bar (x) (foo x)))
    (foo 1)))

(take-it-out-for-a-test-walk
  (flet ((foo (x) (foo x)))
    (foo 1)))

(take-it-out-for-a-test-walk
  (flet ((foo (x) (foo x)))
    (flet ((bar (x) (foo x)))
      (bar 1))))

(take-it-out-for-a-test-walk (compiler-let ((a 1) (b 2)) (foo a) b))
(take-it-out-for-a-test-walk (prog () (declare (special a b))))
(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a b))
                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a) (special b))
                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a))
                               (declare (special b))
                               (foo a) b c))
(take-it-out-for-a-test-walk (let (a b c)
                               (declare (special a))
                               (declare (special b))
                               (let ((a 1))
                                 (foo a) b c)))
(take-it-out-for-a-test-walk (eval-when ()
                               a
                               (foo a)))
(take-it-out-for-a-test-walk (eval-when (eval when load)
                               a
                               (foo a)))

(take-it-out-for-a-test-walk (multiple-value-bind (a b) (foo a b) (list a b)))
(take-it-out-for-a-test-walk (multiple-value-bind (a b)
                                 (foo a b)
                               (declare (special a))
                               (list a b)))
(take-it-out-for-a-test-walk (progn (function foo)))
(take-it-out-for-a-test-walk (progn a b (go a)))
(take-it-out-for-a-test-walk (if a b c))
(take-it-out-for-a-test-walk (if a b))
(take-it-out-for-a-test-walk ((lambda (a b) (list a b)) 1 2))
(take-it-out-for-a-test-walk ((lambda (a b) (declare (special a)) (list a b))
                              1 2))
(take-it-out-for-a-test-walk (let ((a a) (b a) (c b)) (list a b c)))
(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b)) (list a b c)))
(take-it-out-for-a-test-walk (let ((a a) (b a) (c b))
                               (declare (special a b))
                               (list a b c)))
(take-it-out-for-a-test-walk (let* ((a a) (b a) (c b))
                               (declare (special a b))
                               (list a b c)))
(take-it-out-for-a-test-walk (let ((a 1) (b 2))
                               (foo bar)
                               (declare (special a))
                               (foo a b)))
(take-it-out-for-a-test-walk (multiple-value-call #'foo a b c))
(take-it-out-for-a-test-walk (multiple-value-prog1 a b c))
(take-it-out-for-a-test-walk (progn a b c))
(take-it-out-for-a-test-walk (progv vars vals a b c))
(take-it-out-for-a-test-walk (quote a))
(take-it-out-for-a-test-walk (return-from block-name a b c))
(take-it-out-for-a-test-walk (setq a 1))
(take-it-out-for-a-test-walk (setq a (foo 1) b (bar 2) c 3))
(take-it-out-for-a-test-walk (tagbody a b c (go a)))
(take-it-out-for-a-test-walk (the foo (foo-form a b c)))
(take-it-out-for-a-test-walk (throw tag-form a))
(take-it-out-for-a-test-walk (unwind-protect (foo a b) d e f))

(defmacro flet-1 (a b) ''OUTER)
(defmacro labels-1 (a b) ''OUTER)

(take-it-out-for-a-test-walk
  (flet ((flet-1 (a b) () (flet-1 a b) (list a b)))
    (flet-1 1 2)
    (foo 1 2)))
(take-it-out-for-a-test-walk
  (labels ((label-1 (a b) () (label-1 a b)(list a b)))
    (label-1 1 2)
    (foo 1 2)))
(take-it-out-for-a-test-walk (macrolet ((macrolet-1 (a b) (list a b)))
                               (macrolet-1 a b)
                               (foo 1 2)))

(take-it-out-for-a-test-walk (macrolet ((foo (a) `(inner-foo-expanded ,a)))
                               (foo 1)))

(take-it-out-for-a-test-walk (progn (bar 1)
                                    (macrolet ((bar (a)
                                                 `(inner-bar-expanded ,a)))
                                      (bar 2))))

(take-it-out-for-a-test-walk (progn (bar 1)
                                    (macrolet ((bar (s)
                                                 (bar s)
                                                 `(inner-bar-expanded ,s)))
                                      (bar 2))))

(take-it-out-for-a-test-walk (cond (a b)
                                   ((foo bar) a (foo a))))


(let ((the-lexical-variables ()))
  (walk-form '(let ((a 1) (b 2))
                #'(lambda (x) (list a b x y)))
             ()
             #'(lambda (form context env)
                 (when (and (symbolp form)
                            (variable-lexical-p form env))
                   (push form the-lexical-variables))
                 form))
  (or (and (= (length the-lexical-variables) 3)
           (member 'a the-lexical-variables)
           (member 'b the-lexical-variables)
           (member 'x the-lexical-variables))
      (error "Walker didn't do lexical variables of a closure properly.")))
    
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/walk.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/defclass.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; DEFCLASS

(defun parse-default-initargs (default-initargs)
  (declare (si::c-local))
  (do* ((output-list nil)
        (scan default-initargs (cddr scan))
        (already-supplied '()))
       ((endp scan) `(list ,@(nreverse output-list)))
    (when (endp (rest scan))
      (si::simple-program-error "Wrong number of elements in :DEFAULT-INITARGS option."))
    (let ((slot-name (first scan))
          (initform (second scan)))
      (if (member slot-name already-supplied)
          (si::simple-program-error "~S is duplicated in :DEFAULT-INITARGS form ~S"
                                    slot-name default-initargs)
          (push slot-name already-supplied))
      (push `(list ',slot-name ',initform ,(make-function-initform initform))
            output-list))))

(defmacro defclass (&whole form &rest args)
  (unless (>= (length args) 3)
    (si::simple-program-error "Illegal defclass form: the class name, the superclasses and the slots should always be provided"))
  (let* ((name (pop args))
         (superclasses (pop args))
         (slots (pop args))
         (options args))
    (unless (and (listp superclasses) (listp slots))
      (si::simple-program-error "Illegal defclass form: superclasses and slots should be lists"))
    (unless (and (symbolp name) (every #'symbolp superclasses))
      (si::simple-program-error "Illegal defclass form: superclasses and class name are not valid"))
    `(eval-when (compile load eval)
       ,(ext:register-with-pde
         form
         `(load-defclass ',name ',superclasses
                         ,(compress-slot-forms slots)
                         ,(process-class-options options))))))

(defun compress-slot-forms (slot-definitions)
  (declare (si::c-local))
  ;; Here we compose the final form. The slots list, and the default initargs
  ;; may contain object that need to be evaluated. Hence, it cannot be always
  ;; quoted.
  (let ((const '())
        (output '())
        (non-const nil))
    (dolist (slotd (parse-slots slot-definitions))
      (let* ((initfun (getf slotd :initfunction nil))
             (copy (copy-list slotd)))
        (remf copy :initfunction)
        (cond ((atom initfun)
               (push copy const)
               (push (ext:maybe-quote copy) output))
              ((eq (first initfun) 'constantly)
               (push copy const)
               (push (ext:maybe-quote copy) output))
              (t
               (push `(list* :initfunction ,initfun ,(ext:maybe-quote copy))
                     output)
               (setf non-const t)))))
    (if non-const
        `(list ,@(nreverse output))
        (ext:maybe-quote (nreverse const)))))

(defun uncompress-slot-forms (slot-definitions)
  (loop for slotd in slot-definitions
     for initform = (getf slotd :initform slotd)
     collect (if (eq initform slotd)
                 slotd
                 (if (getf slotd :initfunction)
                     slotd
                     (list* :initfunction (constantly (eval initform))
                            slotd)))))

(defun process-class-options (class-args)
  (let ((options '())
        (processed-options '()))
    (dolist (option class-args)
      (let ((option-name (first option))
            option-value)
        (if (member option-name processed-options)
            (si:simple-program-error
             "Option ~s for DEFCLASS specified more than once"
             option-name)
            (push option-name processed-options))
        (setq option-value
              (case option-name
                ((:metaclass :documentation)
                 (ext:maybe-quote (second option)))
                (:default-initargs
                 (setf option-name :direct-default-initargs)
                 (parse-default-initargs (rest option)))
                (otherwise
                 (ext:maybe-quote (rest option))))
              options (list* (ext:maybe-quote option-name)
                             option-value options))))
    (and options `(list ,@options))))
  
(defun load-defclass (name superclasses slot-definitions options)
  (apply #'ensure-class name :direct-superclasses superclasses
         :direct-slots (uncompress-slot-forms slot-definitions)
         options))

;;; ----------------------------------------------------------------------
;;; ENSURE-CLASS
;;;
(defun ensure-class (name &rest initargs)
  (let* ((old-class nil)
         new-class)
    ;; Only classes which have a PROPER name are redefined. If a class
    ;; with the same name is register, but the name of the class does not
    ;; correspond to the registered name, a new class is returned.
    ;; [Hyperspec 7.7 for DEFCLASS]
    (when name
      (when (and (setf old-class (find-class name nil))
                 (not (eq (class-name old-class) name)))
        (setf old-class nil)))
    (setf new-class (apply #'ensure-class-using-class old-class name initargs))
    new-class))

#+(or) ;#+cross
(eval-when (compile)
  (defun ensure-class (name &rest initargs)
    (warn "Ignoring definition for class ~S" name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/defclass.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/generic.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; DEFGENERIC
;;;

(defmacro defgeneric (&whole whole &rest args)
  (multiple-value-bind (function-specifier lambda-list options)
      (parse-defgeneric args)
    (parse-lambda-list lambda-list)
    ;; process options
    (multiple-value-bind (option-list method-list)
        (parse-generic-options options lambda-list)
      (let* ((output `(ensure-generic-function ',function-specifier
                       :delete-methods t ,@option-list)))
        (ext:register-with-pde
         whole
         (if method-list
             `(progn
                ,output
                (associate-methods-to-gfun
                 ',function-specifier
                 ,@(loop for m in method-list collect `(defmethod ,function-specifier ,@m))))
            output))))))

(defun parse-defgeneric (args)
  (declare (si::c-local))
  ;; (values function-specifier lambda-list options)
  (let (function-specifier)
    (unless args
      (simple-program-error "Illegal defgeneric form: missing generic function name"))
    (setq function-specifier (pop args))
    (unless args
      (simple-program-error "Illegal defgeneric form: missing lambda-list"))
    (values function-specifier (first args) (rest args))))

(defun parse-generic-options (options lambda-list)
  (declare (si::c-local))
  (let* ((processed-options '())
         (method-list '())
         (declarations '())
         arg-list)
    (dolist (option options)
      (let ((option-name (first option))
            option-value)
        (cond ((eq option-name :method)
               ;; We do not need to check the validity of this
               ;; because DEFMETHOD will do it.
               (push (rest option) method-list))
              ((eq option-name 'declare)
               (setf declarations (append (rest option) declarations)))
              ((member option-name processed-options)
               (simple-program-error "Option ~s specified more than once"
                                     option-name))
              (t
               (push option-name processed-options)
               ;; We leave much of the type checking for SHARED-INITIALIZE
               (setq option-value
                     (case option-name
                       (:argument-precedence-order
                        (rest option))
                       (:method-combination
                        (rest option))
                       ((:documentation :generic-function-class :method-class)
                        (unless (endp (cddr option))
                          (simple-program-error "Too many arguments for option ~A"
                                                option-name))
                        (second option))
                       (otherwise
                        (simple-program-error "~S is not a legal defgeneric option"
                                              option-name))))
               (setf arg-list `(',option-name ',option-value ,@arg-list))))))
    (values `(:lambda-list ',lambda-list ,@arg-list
              ,@(when declarations `(:declarations ',declarations)))
            method-list)))

(defun parse-lambda-list (lambda-list &optional post-keyword)
  (declare (si::c-local))
  (let ((arg (car lambda-list)))
    (cond ((null lambda-list))
          ((eq arg '&AUX)
           (simple-program-error "&aux is not allowed in a generic function lambda-list"))
          ((member arg lambda-list-keywords)
           (parse-lambda-list (cdr lambda-list) t))
          (post-keyword
           ;; After a lambda-list-keyword there can be no specializers.
           (parse-lambda-list (cdr lambda-list) t))
          (t
           (if (listp arg)
               (simple-program-error "the parameters cannot be specialized in generic function lambda-list")
               (parse-lambda-list (cdr lambda-list)))))))

(defun valid-declaration-p (decl)
  ;(declare (si::c-local))
  (and (eq (first decl) 'OPTIMIZE)
       (loop for item in decl
          always (or (atom item)
                     (and (consp item)
                          (member (first item)
                                  '(SPEED SPACE COMPILATION-SPEED DEBUG SAFETY)))))))

;;; ----------------------------------------------------------------------
;;; GENERIC FUNCTION (RE)INITIALIZATION PROTOCOL
;;

(defun lambda-list-required-arguments (lambda-list)
  (rest (si::process-lambda-list lambda-list t)))

(defmethod shared-initialize ((gfun generic-function) slot-names &rest initargs
                              &key (name nil)
                              (lambda-list nil l-l-p)
                              (argument-precedence-order nil a-o-p)
                              (documentation nil)
                              (declarations nil)
                              (method-class (find-class 'method))
                              &aux
                              (gfun-name (if (slot-boundp gfun 'name)
                                             (slot-value gfun 'name)
                                             (or name :anonymous)))
                              )
  (declare (ignore initargs slot-names))
  ;;
  ;; Check the validity of several fields.
  ;;
  (when a-o-p
    (unless l-l-p
      (simple-program-error "When defining generic function ~A~%Supplied :argument-precedence-order, but :lambda-list is missing"
                            gfun-name))
    (dolist (l (lambda-list-required-arguments lambda-list))
      (unless (= (count l argument-precedence-order) 1)
        (simple-program-error "When defining generic function ~A~%The required argument ~A does not appear exactly once in the ARGUMENT-PRECEDENCE-ORDER list ~A"
                              gfun-name l argument-precedence-order))))
  (unless (every #'valid-declaration-p declarations)
    (simple-program-error "When defining generic function ~A~%Not a valid declaration list: ~A"
                          gfun-name declarations))
  (unless (or (null documentation) (stringp documentation))
    (error 'simple-type-error
           :format-control "When defining generic function~A~%Not a valid documentation object ~"
           :format-arguments (list gfun-name documentation)
           :datum documentation
           :expected-type '(or null string)))
  (unless (si::subclassp method-class (find-class 'method))
    (error 'simple-type-error
           :format-control "When defining generic function~A~%Not a valid method class, ~A"
           :format-arguments (list gfun-name method-class)
           :datum method-class
           :expected-type 'method))
  ;;
  ;; When supplying a new lambda-list, ensure that it is compatible with
  ;; the old list of methods.
  ;;
  (when (and l-l-p (slot-boundp gfun 'methods))
    (unless (every #'(lambda (x)
                       (congruent-lambda-p lambda-list x))
                 (mapcar #'method-lambda-list (generic-function-methods gfun)))
      (simple-program-error "Cannot replace the lambda list of ~A with ~A because it is incongruent with some of the methods"
                            gfun lambda-list)))
  (call-next-method)
  (let ((combination (generic-function-method-combination gfun)))
    (unless (typep combination 'method-combination)
      (setf (generic-function-method-combination gfun)
            (find-method-combination gfun (first combination) (rest combination)))))
  (when (and l-l-p (not a-o-p))
    (setf (generic-function-argument-precedence-order gfun)
          (lambda-list-required-arguments lambda-list)))
  (set-generic-function-dispatch gfun)
  gfun)

(defmethod shared-initialize ((gfun standard-generic-function) slot-names
                              &rest initargs)
  (declare (ignore initargs slot-names))
  (call-next-method)
  (when (generic-function-methods gfun)
    (compute-g-f-spec-list gfun))
  (update-dependents gfun initargs)
  gfun)

(defun associate-methods-to-gfun (name &rest methods)
  (let ((gfun (fdefinition name)))
    (dolist (method methods)
      (setf (getf (method-plist method) :method-from-defgeneric-p) t))
    gfun))

(defmethod ensure-generic-function-using-class
    ((gfun generic-function) name &rest args &key
     (method-class 'STANDARD-METHOD method-class-p)
     (generic-function-class (class-of gfun))
     (delete-methods nil))
  ;; modify the existing object
  (setf args (copy-list args))
  (remf args :generic-function-class)
  (remf args :declare)
  (remf args :environment)
  (remf args :delete-methods)
  ;; FIXME! We should check that the class GENERIC-FUNCTION-CLASS is compatible
  ;; with the old one. In what sense "compatible" is ment, I do not know!
  ;; (See ANSI DEFGENERIC entry)
  (when (symbolp generic-function-class)
    (setf generic-function-class (find-class generic-function-class)))
  (unless (si::subclassp generic-function-class (find-class 'generic-function))
    (error "~A is not a valid :GENERIC-FUNCTION-CLASS argument for ENSURE-GENERIC-FUNCTION."
           generic-function-class))
  (when (and method-class-p (symbolp method-class))
    (setf args (list* :method-class (find-class method-class) args)))
  (when delete-methods
    (dolist (m (copy-list (generic-function-methods gfun)))
      (when (getf (method-plist m) :method-from-defgeneric-p)
        (remove-method gfun m))))
  (if (eq (class-of gfun) generic-function-class)
      (apply #'reinitialize-instance gfun args)
      (apply #'change-class gfun generic-function-class args)))

(defmethod ensure-generic-function-using-class
    ((gfun null) name &rest args &key
     (method-class 'STANDARD-METHOD method-class-p)
     (generic-function-class 'STANDARD-GENERIC-FUNCTION)
     (delete-methods nil))
  (declare (ignore delete-methods gfun))
  ;; else create a new generic function object
  (setf args (copy-list args))
  (remf args :generic-function-class)
  (remf args :declare)
  (remf args :environment)
  (remf args :delete-methods)
  (when (and method-class-p (symbolp generic-function-class))
    (setf args (list* :method-class (find-class method-class) args)))
  (apply #'make-instance generic-function-class :name name args))

(defun ensure-generic-function (name &rest args &key &allow-other-keys)
  (let ((gfun (si::traced-old-definition name)))
    (cond ((not (legal-generic-function-name-p name))
           (simple-program-error "~A is not a valid generic function name" name))
          ((not (fboundp name))
           (setf (fdefinition name)
                 (apply #'ensure-generic-function-using-class gfun name args)))
          ((si::instancep (or gfun (setf gfun (fdefinition name))))
           (apply #'ensure-generic-function-using-class gfun name args))
          ((special-operator-p name)
           (simple-program-error "The special operator ~A is not a valid name for a generic function" name))
          ((macro-function name)
           (simple-program-error "The symbol ~A is bound to a macro and is not a valid name for a generic function" name))
          ((not *clos-booted*)
           (setf (fdefinition name)
                 (apply #'ensure-generic-function-using-class nil name args))
           (fdefinition name))
          (t
           (simple-program-error "The symbol ~A is bound to an ordinary function and is not a valid name for a generic function" name)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/generic.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/kernel.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(defparameter *clos-booted* nil)

;;; ----------------------------------------------------------------------
;;;
;;; FIND-CLASS  naming classes.
;;;
;;;
;;; (FIND-CLASS <name>) returns the class named <name>.  setf can be used
;;; with find-class to set the class named <name>.  These are "extrinsic"
;;; names.  Neither find-class nor setf of find-class do anything with the
;;; name slot of the class, they only lookup and change the association from
;;; name to class.
;;; 
;;; This is only used during boot. The real one is in built-in.
(eval-when (compile)
  (defun setf-find-class (new-value class &optional errorp env)
    (warn "Ignoring class definition for ~S" class)))

(defun setf-find-class (new-value name &optional errorp env)
  (declare (ignore errorp env))
  (let ((old-class (find-class name nil)))
    (cond
      ((and old-class
            (or (typep old-class 'built-in-class)
                (member name '(class built-in-class) :test #'eq)))
       (unless (eq new-value old-class)
         (error "The class associated to the CL specifier ~S cannot be changed."
                name)))
      ((classp new-value)
       (setf (gethash name si:*class-name-hash-table*) new-value))
      ((null new-value) (remhash name si:*class-name-hash-table*))
      (t (error "~A is not a class." new-value))))
  new-value)

(defsetf find-class (&rest x) (v) `(setf-find-class ,v ,@x))

(defun classp (obj)
  (and (si:instancep obj)
       (let ((topmost (find-class 'CLASS nil)))
         ;; All instances can be classes until the class CLASS has
         ;; been installed. Otherwise, we check the parents.
         ;(print (list (class-id (class-of obj))topmost (and topmost (class-precedence-list topmost))))
         (or (null topmost)
             (si::subclassp (si::instance-class obj) topmost)))
       t))

;;; ----------------------------------------------------------------------
;;; Methods

(defun install-method (name qualifiers specializers lambda-list fun &rest options)
  (declare (notinline ensure-generic-function))
;  (record-definition 'method `(method ,name ,@qualifiers ,specializers))
  (let* ((gf (ensure-generic-function name))
         (fun (wrapped-method-function fun))
         (specializers (mapcar #'(lambda (x)
                                   (cond ((consp x) (intern-eql-specializer (second x)))
                                         ((typep x 'specializer) x)
                                         ((find-class x nil))
                                         (t
                                          (error "In method definition for ~A, found an invalid specializer ~A" name specializers))))
                               specializers))
         (method (make-method (generic-function-method-class gf)
                              qualifiers specializers lambda-list
                              fun options)))
    (add-method gf method)
    method))

(defun wrapped-method-function (method-function)
  #'(lambda (.combined-method-args. *next-methods*)
      (declare (special .combined-method-args. *next-methods*))
      (apply method-function .combined-method-args.)))

;;; ----------------------------------------------------------------------
;;;                                                         early versions

;;; early version used during bootstrap
(defun ensure-generic-function (name &key (lambda-list (si::unbound) l-l-p))
  (if (and (fboundp name) (si::instancep (fdefinition name)))
      (fdefinition name)
      ;; create a fake standard-generic-function object:
      (with-early-make-instance +standard-generic-function-slots+
        (gfun (find-class 'standard-generic-function)
              :name name
              :spec-list nil
              :method-combination (find-method-combination nil 'standard nil)
              :lambda-list lambda-list
              :argument-precedence-order
              (and l-l-p (rest (si::process-lambda-list lambda-list t)))
              :method-class (find-class 'standard-method)
              :docstring nil
              :methods nil
              :a-p-o-function nil
              :declarations nil
              :dependents nil)
        ;; create a new gfun
        (set-funcallable-instance-function gfun 'standard-generic-function)
        (setf (fdefinition name) gfun)
        gfun)))

(defun (setf generic-function-name) (new-name gf)
  (if *clos-booted*
      (reinitialize-instance gf :name new-name)
      (setf (slot-value gf 'name) new-name)))

(defun default-dispatch (generic-function)
  (cond ((null *clos-booted*)
         'standard-generic-function)
        ((eq (class-id (class-of generic-function))
             'standard-generic-function)
         'standard-generic-function)
        (t)))

(defun compute-discriminating-function (generic-function)
  (values #'(lambda (&rest args)
              (multiple-value-bind (method-list ok)
                  (compute-applicable-methods-using-classes
                   generic-function
                   (mapcar #'class-of args))
                (unless ok
                  (setf method-list
                        (compute-applicable-methods generic-function args))
                  (unless method-list
                    (apply #'no-applicable-method generic-function args)))
                (funcall (compute-effective-method-function
                          generic-function
                          (generic-function-method-combination generic-function)
                          method-list)
                         args
                         nil)))
          t))

(defun set-generic-function-dispatch (gfun)
  ;;
  ;; We have to decide which discriminating function to install:
  ;;    1* One supplied by the user
  ;;    2* One coded in C that follows the MOP
  ;;    3* One in C specialized for slot accessors
  ;;    4* One in C that does not use generic versions of compute-applicable-...
  ;; Respectively
  ;;    1* The user supplies a discriminating function, or the number of arguments
  ;;       is so large that they cannot be handled by the C dispatchers with
  ;;       with memoization.
  ;;    2* The generic function is not a s-g-f but takes less than 64 arguments
  ;;    3* The generic function is a standard-generic-function and all its slots
  ;;       are standard-{reader,writer}-slots
  ;;    4* The generic function is a standard-generic-function with less
  ;;       than 64 arguments
  ;;
  ;; This chain of reasoning uses the fact that the user cannot override methods
  ;; such as COMPUTE-APPLICABLE-METHODS, or COMPUTE-EFFECTIVE-METHOD, or
  ;; COMPUTE-DISCRIMINATING-FUNCTION acting on STANDARD-GENERIC-FUNCTION.
  ;;
  (declare (notinline compute-discriminating-function))
  (multiple-value-bind (default-function optimizable)
      ;;
      ;; If the class is not a standard-generic-function, we must honor whatever function
      ;; the user provides. However, we still recognize the case without user-computed
      ;; function, where we can replace the output of COMPUTE-DISCRIMINATING-FUNCTION with
      ;; a similar implementation in C
      (compute-discriminating-function gfun)
    (let ((methods (slot-value gfun 'methods)))
      (set-funcallable-instance-function
       gfun
       (cond
         ;; Case 1*
         ((or (not optimizable)
              (> (length (slot-value gfun 'spec-list))
                 si::c-arguments-limit))
          default-function)
         ;; Case 2*
         ((and (not (eq (slot-value (class-of gfun) 'name)
                        'standard-generic-function))
               *clos-booted*)
          t)
         ((null methods)
          'standard-generic-function)
         ;; Cases 3*
         ((loop with class = (find-class 'standard-optimized-reader-method nil)
             for m in methods
             always (eq class (class-of m)))
          'standard-optimized-reader-method)
         ((loop with class = (find-class 'standard-optimized-writer-method nil)
             for m in methods
             always (eq class (class-of m)))
          'standard-optimized-writer-method)
         ;; Case 4*
         (t
          'standard-generic-function))))))

;;; ----------------------------------------------------------------------
;;; COMPUTE-APPLICABLE-METHODS
;;;
;;; This part is a source of problems because we have to access slots of
;;; various objects, which could potentially lead to infinite recursion as
;;; those accessors require also some dispatch. The solution is to avoid
;;; calling then generic function that implement the accessors.
;;; This is possible because:
;;;   1. The user can only extend compute-applicable-methods if it
;;;      defines a method with a subclass of standard-generic-function
;;;   2. The user cannot extend slot-value and friends on standard-classes
;;;      due to the restriction "Any method defined by a portable program
;;;      on a specified generic function must have at least one specializer
;;;      that is neither a specified class nor an eql specializer whose
;;;      associated value is an instance of a specified class."
;;;   3. Subclasses of specified classes preserve the slot order in ECL.
;;;
(defun std-compute-applicable-methods (gf args)
  (sort-applicable-methods gf
                           (applicable-method-list gf args)
                           (mapcar #'class-of args)))

(setf (fdefinition 'compute-applicable-methods) #'std-compute-applicable-methods)

(defun applicable-method-list (gf args)
  (declare (optimize (speed 3))
           (si::c-local))
  (with-early-accessors (+standard-method-slots+
                         +standard-generic-function-slots+
                         +eql-specializer-slots+
                         +standard-class-slots+)
    (flet ((applicable-method-p (method args)
             (loop for spec in (method-specializers method)
                for arg in args
                always (if (eql-specializer-flag spec)
                           (eql arg (eql-specializer-object spec))
                           (si::of-class-p arg spec)))))
      (loop for method in (generic-function-methods gf)
         when (applicable-method-p method args)
         collect method))))

(defun std-compute-applicable-methods-using-classes (gf classes)
  (declare (optimize (speed 3)))
  (with-early-accessors (+standard-method-slots+ +eql-specializer-slots+ +standard-generic-function-slots+)
    (flet ((applicable-method-p (method classes)
             (loop for spec in (method-specializers method)
                for class in classes
                always (cond ((eql-specializer-flag spec)
                              ;; EQL specializer invalidate computation
                              ;; we return NIL
                              (when (si::of-class-p (eql-specializer-object spec) class)
                                (return-from std-compute-applicable-methods-using-classes
                                  (values nil nil)))
                              nil)
                             ((si::subclassp class spec))))))
      (values (sort-applicable-methods
               gf
               (loop for method in (generic-function-methods gf)
                  when (applicable-method-p method classes)
                  collect method)
               classes)
              t))))

(defun sort-applicable-methods (gf applicable-list args-specializers)
  (declare (optimize (safety 0) (speed 3)))
  (with-early-accessors (+standard-method-slots+ +standard-generic-function-slots+)
    (let ((f (generic-function-a-p-o-function gf)))
      ;; reorder args to match the precedence order
      (when f
        (setf args-specializers
              (funcall f (subseq args-specializers 0
                                 (length (generic-function-argument-precedence-order gf))))))
      ;; then order the list
      (do* ((scan applicable-list)
            (most-specific (first scan) (first scan))
            (ordered-list))
           ((null (cdr scan))
            (when most-specific
              ;; at least one method
              (nreverse
               (push most-specific ordered-list))))
        (dolist (meth (cdr scan))
          (when (eq (compare-methods most-specific
                                     meth args-specializers f) 2)
            (setq most-specific meth)))
        (setq scan (delete most-specific scan))
        (push most-specific ordered-list)))))

(defun compare-methods (method-1 method-2 args-specializers f)
  (declare (si::c-local))
  (with-early-accessors (+standard-method-slots+)
    (let* ((specializers-list-1 (method-specializers method-1))
           (specializers-list-2 (method-specializers method-2)))
      (compare-specializers-lists (if f (funcall f specializers-list-1) specializers-list-1)
                                  (if f (funcall f specializers-list-2) specializers-list-2)
                                  args-specializers))))

(defun compare-specializers-lists (spec-list-1 spec-list-2 args-specializers)
  (declare (si::c-local))
  (when (or spec-list-1 spec-list-2)
    (ecase (compare-specializers (first spec-list-1)
                                 (first spec-list-2)
                                 (first args-specializers))
      (1 '1)
      (2 '2)
      (= 
       (compare-specializers-lists (cdr spec-list-1)
                                   (cdr spec-list-2)
                                   (cdr args-specializers)))
      ((nil)
       (error "The type specifiers ~S and ~S can not be disambiguated~
                  with respect to the argument specializer: ~S"
              (or (car spec-list-1) t)
              (or (car spec-list-2) t)
              (car args-specializers)))))
  )

(defun fast-subtypep (spec1 spec2)
  (declare (si::c-local))
  ;; Specialized version of subtypep which uses the fact that spec1
  ;; and spec2 are either classes or of the form (EQL x)
  (with-early-accessors (+eql-specializer-slots+ +standard-class-slots+)
    (if (eql-specializer-flag spec1)
        (if (eql-specializer-flag spec2)
            (eql (eql-specializer-object spec1)
                 (eql-specializer-object spec2))
            (si::of-class-p (eql-specializer-object spec1) spec2))
        (if (eql-specializer-flag spec2)
            ;; There is only one class with a single element, which
            ;; is NULL = (MEMBER NIL).
            (and (null (eql-specializer-object spec2))
                 (eq (class-name spec1) 'null))
            (si::subclassp spec1 spec2)))))

(defun compare-specializers (spec-1 spec-2 arg-class)
  (declare (si::c-local))
  (with-early-accessors (+standard-class-slots+ +standard-class-slots+)
    (let* ((cpl (class-precedence-list arg-class)))
      (cond ((eq spec-1 spec-2) '=)
            ((fast-subtypep spec-1 spec-2) '1)
            ((fast-subtypep spec-2 spec-1) '2)
            ((eql-specializer-flag spec-1) '1) ; is this engough?
            ((eql-specializer-flag spec-2) '2) ; Beppe
            ((member spec-1 (member spec-2 cpl)) '2)
            ((member spec-2 (member spec-1 cpl)) '1)
            ;; This will force an error in the caller
            (t nil)))))

(defun compute-g-f-spec-list (gf)
  (with-early-accessors (+standard-generic-function-slots+
                         +eql-specializer-slots+
                         +standard-method-slots+)
    (flet ((nupdate-spec-how-list (spec-how-list specializers gf)
             ;; update the spec-how of the gfun 
             ;; computing the or of the previous value and the new one
             (setf spec-how-list (or spec-how-list
                                     (copy-list specializers)))
             (do* ((l specializers (cdr l))
                   (l2 spec-how-list (cdr l2))
                   (spec-how)
                   (spec-how-old))
                  ((null l))
               (setq spec-how (first l) spec-how-old (first l2))
               (setf (first l2)
                     (if (eql-specializer-flag spec-how)
                         (list* (eql-specializer-object spec-how)
                                (and (consp spec-how-old) spec-how-old))
                         (if (consp spec-how-old)
                             spec-how-old
                             spec-how))))
             spec-how-list))
      (let* ((spec-how-list nil)
             (function nil)
             (a-p-o (generic-function-argument-precedence-order gf)))
        (dolist (method (generic-function-methods gf))
          (setf spec-how-list
                (nupdate-spec-how-list spec-how-list (method-specializers method) gf)))
        (setf (generic-function-spec-list gf)
              (loop for type in spec-how-list
                 for i from 0
                 when type collect (cons type i)))
        (let* ((g-f-l-l (generic-function-lambda-list gf)))
          (when (consp g-f-l-l)
            (let ((required-arguments (rest (si::process-lambda-list g-f-l-l t))))
              (unless (equal a-p-o required-arguments)
                (setf function
                      (coerce `(lambda (%list)
                                 (destructuring-bind ,required-arguments %list
                                   (list ,@a-p-o)))
                              'function))))))
        (setf (generic-function-a-p-o-function gf) function)
        (si:clear-gfun-hash gf)))))

(defun print-object (object stream)
  (print-unreadable-object (object stream)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/kernel.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/method.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------

(defparameter *method-size* 32)         ; Size of methods hash tables

;;; This holds fake methods created during bootstrap.
;;; It is  an alist of:
;;;     (method-name {method}+)
(defparameter *early-methods* nil)

;;;
;;; This is used by combined methods to communicate the next methods to
;;; the methods they call.
;;;
(defparameter *next-methods* nil)

;;; Add type declarations for the arguments of a METHOD. This implies
;;; copying the method arguments because the arguments may be modified.
(defparameter *add-method-argument-declarations* nil)


;;; ----------------------------------------------------------------------
;;; DEFMETHOD
;;;

(defun generic-function-method-class (generic-function)
  (if *clos-booted*
      (slot-value generic-function 'method-class)
      (find-class 'standard-method)))

(defun method-prototype-for-gf (generic-function)
  (when *clos-booted*
    (class-prototype (generic-function-method-class generic-function))))

(defmacro defmethod (&whole whole name &rest args &environment env)
  (declare (notinline make-method-lambda))
  (multiple-value-bind (qualifiers specialized-lambda-list body)
      (parse-defmethod args)
    (multiple-value-bind (lambda-list required-parameters specializers)
        (parse-specialized-lambda-list specialized-lambda-list)
      (multiple-value-bind (lambda-form declarations documentation)
          (make-raw-lambda name lambda-list required-parameters specializers body env)
        (let* ((generic-function (ensure-generic-function name))
               (method (method-prototype-for-gf generic-function)))
          (multiple-value-bind (fn-form options)
              (make-method-lambda generic-function method lambda-form env)
            (when documentation
              (setf options (list* :documentation documentation options)))
            (ext:register-with-pde
             whole
             `(install-method ',name ',qualifiers
                              ,(specializers-expression specializers)
                              ',lambda-list
                              ,(maybe-remove-block (simplify-lambda fn-form))
                              ,@(mapcar #'si::maybe-quote options)))))))))

(defun specializers-expression (specializers)
  (declare (si::c-local))
  ;; The list of specializers contains either types or (EQL value)
  ;; expressions. The 'value' has to be obtained by evaluating a lisp form
  ;; We save some space/time by including directly the value of those
  ;; forms which do not involve any evaluations, such as literals or QUOTE
  ;; expressions. Note that we cannot use CONSTANTP because this would extract
  ;; the value of constant symbols, which would not be EQL to the value of
  ;; those same constants when the code is reloaded.
  (list 'si::quasiquote
        (loop for spec in specializers
           collect (if (atom spec)
                       spec
                       `(eql ,(let ((value (second spec)))
                                (if (if (atom value)
                                        (not (symbolp value))
                                        (eq (car value) 'quote))
                                    (ext:constant-form-value value)
                                    (list 'si::unquote value))))))))

(defun maybe-remove-block (method-lambda)
  (when (eq (first method-lambda) 'lambda)
    (multiple-value-bind (declarations body documentation)
        (si::find-declarations (cddr method-lambda))
      (let (block)
        (when (and (null (rest body))
                   (listp (setf block (first body)))
                   (eq (first block) 'block))
          (setf method-lambda `(ext:lambda-block ,(second block) ,(second method-lambda)
                                ,@declarations
                                ,@(cddr block)))
          ))))
  method-lambda)

(defun simplify-lambda (fn-form)
  (let ((aux fn-form))
    (if (and (eq (pop aux) 'lambda)
             (equalp (pop aux) '(.combined-method-args. *next-methods*))
             (equalp (pop aux) '(declare (special .combined-method-args. *next-methods*)))
             (null (rest aux))
             (= (length (setf aux (first aux))) 3)
             (eq (first aux) 'apply)
             (eq (third aux) '.combined-method-args.)
             (listp (setf aux (second aux)))
             (eq (first aux) 'lambda))
        aux
        (error "Unable to unwrap function"))))

(defun make-raw-lambda (name lambda-list required-parameters specializers body env)
  (declare (si::c-local)
           (ignore env))
  (multiple-value-bind (declarations real-body documentation)
      (sys::find-declarations body)
    ;; FIXME!! This deactivates the checking of keyword arguments
    ;; inside methods. The reason is that this checking must be
    ;; supplemented the knowledge of the keyword arguments of all
    ;; applicable methods (X3J13 7.6.5). Therefore, we should insert
    ;; that check, either in the method itself so that it is done
    ;; incrementally, or in COMPUTE-EFFECTIVE-METHOD.
    (when (and (member '&key lambda-list)
               (not (member '&allow-other-keys lambda-list)))
      (let ((x (position '&aux lambda-list)))
        (setf lambda-list
                (append (subseq lambda-list 0 x)
                        '(&allow-other-keys)
                        (and x (subseq lambda-list x))
                        nil))))
    (let* ((copied-variables '())
           (ignorable `(declare (ignorable ,@required-parameters)))
           (class-declarations
            (nconc (when *add-method-argument-declarations*
                     (loop for name in required-parameters
                        for type in specializers
                        when (and (not (eq type t)) (symbolp type))
                        do (push `(,name ,name) copied-variables) and
                        nconc `((type ,type ,name)
                                (si::no-check-type ,name))))
                   (list (list 'si::function-block-name name))
                   (cdar declarations)))
           (block `(block ,(si::function-block-name name) ,@real-body))
           (method-lambda
            ;; Remove the documentation string and insert the
            ;; appropriate class declarations.  The documentation
            ;; string is removed to make it easy for us to insert
            ;; new declarations later, they will just go after the
            ;; second of the method lambda.  The class declarations
            ;; are inserted to communicate the class of the method's
            ;; arguments to the code walk.
            `(lambda ,lambda-list
               ,@(and class-declarations `((declare ,@class-declarations)))
               ,ignorable
               ,(if copied-variables
                    `(let* ,copied-variables
                       ,ignorable
                       ,block)
                     block))))
      (values method-lambda declarations documentation))))

(defun make-method-lambda (gf method method-lambda env)
  (multiple-value-bind (call-next-method-p next-method-p-p in-closure-p)
      (walk-method-lambda method-lambda env)
    (values `(lambda (.combined-method-args. *next-methods*)
               (declare (special .combined-method-args. *next-methods*))
               (apply ,(if in-closure-p
                           (add-call-next-method-closure method-lambda)
                           method-lambda)
                      .combined-method-args.))
            nil)))

(defun add-call-next-method-closure (method-lambda)
  (multiple-value-bind (declarations real-body documentation)
      (si::find-declarations (cddr method-lambda))
    `(lambda ,(second method-lambda)
       ,@declarations
       (let* ((.closed-combined-method-args.
               (if (listp .combined-method-args.)
                   .combined-method-args.
                   (apply #'list .combined-method-args.)))
              (.next-methods. *next-methods*))
         (flet ((call-next-method (&rest args)
                  (unless .next-methods.
                    (error "No next method"))
                  (funcall (car .next-methods.)
                           (or args .closed-combined-method-args.)
                           (rest .next-methods.)))
                (next-method-p ()
                  .next-methods.))
           ,@real-body)))))

(defun environment-contains-closure (env)
  ;;
  ;; As explained in compiler.d (make_lambda()), we use a symbol with
  ;; name "FUNCTION-BOUNDARY" to mark the beginning of a function. If
  ;; we find that symbol twice, it is quite likely that this form will
  ;; end up in a closure.
  ;;
  (let ((counter 0))
    (declare (fixnum counter))
    (dolist (item (car env))
      (when (and (consp item)
                 (eq (first (the cons item)) 'si::function-boundary)
                 (> (incf counter) 1)) 
        (return t)))))

(defun walk-method-lambda (method-lambda env)
  (declare (si::c-local))
  (let ((call-next-method-p nil)
        (next-method-p-p nil)
        (in-closure-p nil))
    (flet ((code-walker (form env)
             (unless (atom form)
               (let ((name (first form)))
                 (case name
                   (CALL-NEXT-METHOD
                    (setf call-next-method-p
                          (or call-next-method-p T)
                          in-closure-p
                          (or in-closure-p (environment-contains-closure env))))
                   (NEXT-METHOD-P
                    (setf next-method-p-p t
                          in-closure-p (or in-closure-p (environment-contains-closure env))))
                   (FUNCTION
                    (when (eq (second form) 'CALL-NEXT-METHOD)
                      (setf in-closure-p t
                            call-next-method-p 'FUNCTION))
                    (when (eq (second form) 'NEXT-METHOD-P)
                      (setf next-method-p-p 'FUNCTION
                            in-closure-p t))))))
             form))
      (let ((si::*code-walker* #'code-walker))
        ;; Instead of (coerce method-lambda 'function) we use
        ;; explicitely the bytecodes compiler with an environment, no
        ;; stepping, compiler-env-p = t and execute = nil, so that the
        ;; form does not get executed.
        (si::eval-with-env method-lambda env nil t t)))
    (values call-next-method-p
            next-method-p-p
            in-closure-p)))

;;; ----------------------------------------------------------------------
;;;                                                                parsing

(defun legal-generic-function-name-p (name)
  (si::valid-function-name-p name))

;;; PARSE-DEFMETHOD is used by DEFMETHOD to parse the &REST argument
;;; into the 'real' arguments. This is where the syntax of DEFMETHOD
;;; is really implemented.
(defun parse-defmethod (cdr-of-form)
  (declare (si::c-local)
           (list cdr-of-form))
  (let ((qualifiers ())
        (spec-ll ()))
    (loop (if (and (car cdr-of-form) (atom (car cdr-of-form)))
              (push (pop cdr-of-form) qualifiers)
              (return (setq qualifiers (nreverse qualifiers)))))
    (setq spec-ll (pop cdr-of-form))
    (values qualifiers spec-ll cdr-of-form)))

(defun implicit-generic-lambda (lambda-list)
  "Implicit defgeneric declaration removes all &key arguments (preserving &key)"
  (when lambda-list
    (let (acc)
      (do* ((ll lambda-list (cdr ll))
            (elt (car ll) (car ll)))
           ((or (endp (rest ll))
                (eql elt '&key))
            (nreverse (cons elt acc)))
        (push elt acc)))))

(defun extract-lambda-list (specialized-lambda-list)
  (values (parse-specialized-lambda-list specialized-lambda-list)))

(defun extract-specializer-names (specialized-lambda-list)
  (nth-value 2 (parse-specialized-lambda-list specialized-lambda-list)))

(defun parse-specialized-lambda-list (specialized-lambda-list)
  "This function takes a method lambda list and outputs the list of required
arguments, the list of specializers and a new lambda list where the specializer
have disappeared."
  (declare (si::c-local))
  ;; SI:PROCESS-LAMBDA-LIST will ensure that the lambda list is
  ;; syntactically correct and will output as a first argument the
  ;; list of required arguments. We use this list to extract the
  ;; specializers and build a lambda list without specializers.
  (do* ((arglist (rest (si::process-lambda-list specialized-lambda-list 'METHOD))
                 (rest arglist))
        (lambda-list (copy-list specialized-lambda-list))
        (ll lambda-list (rest ll))
        (required-parameters '())
        (specializers '())
        arg variable specializer)
       ((null arglist)
        (values lambda-list
                (nreverse required-parameters)
                (nreverse specializers)))
    (setf arg (first arglist))
    (cond
      ;; Just a variable
      ((atom arg)
       (setf variable arg specializer T))
      ;; List contains more elements than variable and specializer
      ((not (endp (cddr arg)))
       (si::simple-program-error "Syntax error in method specializer ~A" arg))
      ;; Specializer is NIL
      ((null (setf variable (first arg)
                   specializer (second arg)))
       (si::simple-program-error
        "NIL is not a valid specializer in a method lambda list"))
      ;; Specializer is a class name
      ((atom specializer))
      ;; Specializer is (EQL value)
      ((and (eql (first specializer) 'EQL)
            (cdr specializer)
            (endp (cddr specializer))))
      ;; Otherwise, syntax error
      (t
       (si::simple-program-error "Syntax error in method specializer ~A" arg)))
    (setf (first ll) variable)
    (push variable required-parameters)
    (push specializer specializers)))

(defun declaration-specializers (arglist declarations)
  (declare (si::c-local))
  (do ((argscan arglist (cdr argscan))
       (declist (when declarations (cdr declarations))))
      ((or
        (null argscan)
        (member (first argscan) '(&OPTIONAL &REST &KEY &ALLOW-OTHER-KEYS &AUX)))
       `(DECLARE ,@declist))
      (when (listp (first argscan))
            (push `(TYPE ,(cadar argscan) ,(caar argscan)) declist))))


;;; ----------------------------------------------------------------------
;;;                                                             operations

(defun compute-method-keywords (lambda-list)
  (multiple-value-bind (reqs opts rest key-flag keywords allow-other-keys)
      (si::process-lambda-list lambda-list t)
    (declare (ignore reqs opts rest key-flag))
    (if allow-other-keys
        't
        (loop for k in (rest keywords) by #'cddddr
           collect k))))

(defun make-method (method-class qualifiers specializers lambda-list fun options)
  (declare (ignore options))
  (with-early-make-instance
      ;; We choose the largest list of slots
      +standard-accessor-method-slots+
    (method (if (si::instancep method-class)
                method-class
                (find-class method-class))
            :generic-function nil
            :lambda-list lambda-list
            :function fun
            :specializers specializers
            :qualifiers qualifiers
            :keywords (compute-method-keywords lambda-list))
    method))

;;; early version used during bootstrap
(defun method-p (x)
  (si::instancep x))

;;; early version used during bootstrap
(defun add-method (gf method)
  (with-early-accessors (+standard-method-slots+ +standard-generic-function-slots+ +standard-class-slots+)
    (let* ((name (slot-value gf 'name))
           (method-entry (assoc name *early-methods*)))
      (unless method-entry
        (setq method-entry (list name))
        (push method-entry *early-methods*))
      (push method (cdr method-entry))
      (push method (generic-function-methods gf))
      (setf (method-generic-function method) gf)
      (unless (si::sl-boundp (generic-function-lambda-list gf))
        (setf (generic-function-lambda-list gf) (implicit-generic-lambda
                                                 (method-lambda-list method)))
        (setf (generic-function-argument-precedence-order gf)
              (rest (si::process-lambda-list (method-lambda-list method) t))))
      (compute-g-f-spec-list gf)
      (set-generic-function-dispatch gf)
      method)))

(defun find-method (gf qualifiers specializers &optional (errorp t))
  (declare (notinline method-qualifiers))
  (flet ((filter-specializer (name)
           (cond ((typep name 'specializer)
                  name)
                 ((atom name)
                  (let ((class (find-class name nil)))
                    (unless class
                      (error "~A is not a valid specializer name" name))
                    class))
                 ((and (eq (first name) 'EQL)
                       (null (cddr name)))
                  (cdr name))
                 (t
                  (error "~A is not a valid specializer name" name))))
         (specializer= (cons-or-class specializer)
           (if (consp cons-or-class)
               (and (eql-specializer-flag specializer)
                    (eql (car cons-or-class)
                         (eql-specializer-object specializer)))
               (eq cons-or-class specializer))))
    (when (/= (length specializers)
              (length (generic-function-argument-precedence-order gf)))
      (error
       "The specializers list~%~A~%does not match the number of required arguments in ~A"
       specializers (generic-function-name gf)))
    (loop with specializers = (mapcar #'filter-specializer specializers)
       for method in (generic-function-methods gf)
       when (and (equal qualifiers (method-qualifiers method))
                 (every #'specializer= specializers (method-specializers method)))
       do (return-from find-method method))
    ;; If we did not find any matching method, then the list of
    ;; specializers might have the wrong size and we must signal
    ;; an error.
    (when errorp
      (error "There is no method on the generic function ~S that agrees on qualifiers ~S and specializers ~S"
             (generic-function-name gf)
             qualifiers specializers)))
  nil)

;;; ----------------------------------------------------------------------
;;;                                                         with-accessors

(defmacro with-accessors (slot-accessor-pairs instance-form &body body)
  (let* ((temp (gensym))
         (accessors (do ((scan slot-accessor-pairs (cdr scan))
                        (res))
                       ((null scan) (nreverse res))
                       (push `(,(caar scan) (,(cadar scan) ,temp)) res))))
    `(let ((,temp ,instance-form))
       (symbol-macrolet ,accessors ,@body))))

;;; Force the compiler into optimizing use of gethash inside methods:
(setf (symbol-function 'SLOT-INDEX) (symbol-function 'GETHASH))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/method.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/change.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; INSTANCE UPDATE PROTOCOL
;;;
;;;
;;; PART 1: CHANGING THE CLASS OF AN INSTANCE
;;;
;;; The method CHANGE-CLASS performs most of the work.
;;;
;;;     a) The structure of the instance is changed to match the new
;;;        number of local slots.
;;;     b) The new local slots are filled with the value of the old
;;;        slots. Only the name is used, so that a new local slot may
;;;        get the value of old slots that were eithe local or shared.
;;;     c) Finally, UPDATE-INSTANCE-FOR-DIFFERENT-CLASS is invoked
;;;        with a copy of the instance as it looked before the change,
;;;        the changed instance and enough information to perform any
;;;        extra processing.
;;;

(defmethod update-instance-for-different-class
    ((old-data standard-object) (new-data standard-object) &rest initargs)
  (let ((old-local-slotds (si::instance-sig old-data))
        (new-local-slotds (remove :instance (si::instance-sig new-data)
                                  :test-not #'eq :key #'slot-definition-allocation))
        added-slots)
    (setf added-slots (set-difference (mapcar #'slot-definition-name new-local-slotds)
                                      (mapcar #'slot-definition-name old-local-slotds)))
    (check-initargs (class-of new-data) initargs
                    (valid-keywords-from-methods
                     (compute-applicable-methods
                      #'update-instance-for-different-class
                      (list old-data new-data))
                     (compute-applicable-methods
                      #'shared-initialize (list new-data added-slots))))
    (apply #'shared-initialize new-data added-slots initargs)))

(defmethod change-class ((instance standard-object) (new-class std-class)
                         &rest initargs)
  (let* ((old-instance (si::copy-instance instance))
         (new-size (class-size new-class))
         (instance (si::allocate-raw-instance instance new-class new-size)))
    (si::instance-sig-set instance)
    ;; "The values of local slots specified by both the class Cto and
    ;; Cfrom are retained.  If such a local slot was unbound, it remains
    ;; unbound."
    ;; "The values of slots specified as shared in the class Cfrom and
    ;; as local in the class Cto are retained."
    (let* ((new-local-slotds (class-slots (class-of instance))))
      (dolist (new-slot new-local-slotds)
        ;; CHANGE-CLASS can only operate on the value of local slots.
        (when (eq (slot-definition-allocation new-slot) :INSTANCE)
          (let ((name (slot-definition-name new-slot)))
            (if (and (slot-exists-p old-instance name)
                     (slot-boundp old-instance name))
                (setf (slot-value instance name) (slot-value old-instance name))
                (slot-makunbound instance name))))))
    (apply #'update-instance-for-different-class old-instance instance
           initargs)
    instance))

(defmethod change-class ((instance class) new-class &rest initargs)
  (declare (ignore new-class initargs))
  (if (forward-referenced-class-p instance)
      (call-next-method)
      (error "The metaclass of a class metaobject cannot be changed.")))

;;;
;;; PART 2: UPDATING AN INSTANCE THAT BECAME OBSOLETE
;;;
;;; Each instance has a hidden field (readable with SI::INSTANCE-SIG), which
;;; contains the list of slots of its class. This field is updated every time
;;; the class is initialized or reinitialized. Generally
;;;     (EQ (SI::INSTANCE-SIG x) (CLASS-SLOTS (CLASS-OF x)))
;;; returns NIL whenever the class became obsolete.
;;;
;;; There are two circumstances under which a instance may become obsolete:
;;; either the class has been modified using REDEFINE-INSTANCE (and thus the
;;; list of slots changed), or MAKE-INSTANCES-OBSOLETE has been used.
;;;
;;; The function UPDATE-INSTANCE (hidden to the user) does the job of
;;; updating an instance that has become obsolete.
;;;
;;;     a) A copy of the instance is saved to check the old values.
;;;     b) The structure of the instance is changed to match the new
;;;        number of local slots.
;;;     c) The new local slots are filled with the value of the old
;;;        local slots.
;;;     d) Finally, UPDATE-INSTANCE-FOR-REDEFINED-CLASS is invoked
;;;        with enough information to perform any extra initialization,
;;;        for instance of new slots.
;;;
;;; It is not clear when the function UPDATE-INSTANCE is invoked. At least
;;; this will happen whenever the functions SLOT-VALUE, (SETF SLOT-VALUE),
;;; SLOT-BOUNDP or SLOT-EXISTS-P are used.
;;;

(defmethod update-instance-for-redefined-class
    ((instance standard-object) added-slots discarded-slots property-list
     &rest initargs)
  (check-initargs (class-of instance) initargs
                  (valid-keywords-from-methods
                   (compute-applicable-methods
                    #'update-instance-for-redefined-class
                    (list instance added-slots discarded-slots property-list))
                   (compute-applicable-methods
                    #'shared-initialize
                    (list instance added-slots))))
  (apply #'shared-initialize instance added-slots initargs))

(defmethod update-instance-for-redefined-class
    ((instance std-class) added-slots discarded-slots property-list
     &rest initargs)
  ;; If the metaclass of this class changed, so did probably that of its
  ;; subclasses. We need those subclasses to be up-to-date. This prevents
  ;; errors when loading twice the following
  ;;   (defclass metaclas ...)
  ;;   (defclass x () ... (:metaclas metaclas))
  ;;   (defclass y (y) ...)
  ;; because X might be redefined with Y not being up-to-date on the second
  ;; pass.
  (prog1
      (call-next-method)
    (dolist (class (class-direct-subclasses instance))
      (ensure-up-to-date-instance class))))

(defun update-instance (instance)
  (let* ((class (class-of instance))
         (old-slotds (si::instance-sig instance))
         (new-slotds (class-slots class))
         (old-instance (si::copy-instance instance))
         (discarded-slots '())
         (added-slots '())
         (property-list '()))
    (setf instance (si::allocate-raw-instance instance class (class-size class)))
    (si::instance-sig-set instance)
    (let* ((new-i 0)
           (old-local-slotds (remove :instance old-slotds :test-not #'eq
                                     :key #'slot-definition-allocation))
           (new-local-slotds (remove :instance new-slotds :test-not #'eq
                                     :key #'slot-definition-allocation)))
      (declare (fixnum new-i))
      (setq discarded-slots
            (set-difference (mapcar #'slot-definition-name old-local-slotds)
                            (mapcar #'slot-definition-name new-local-slotds)))
      (dolist (slot-name discarded-slots)
        (let* ((ndx (position slot-name old-local-slotds :key #'slot-definition-name)))
          (setf property-list
                (list* slot-name (si::instance-ref old-instance ndx) property-list))))
      (dolist (new-slot new-local-slotds)
        (let* ((name (slot-definition-name new-slot))
               (old-i (position name old-local-slotds :key #'slot-definition-name)))
          (if old-i
              (si::instance-set instance new-i
                                (si::instance-ref old-instance old-i))
              (push name added-slots))
          (incf new-i))))
    (update-instance-for-redefined-class instance added-slots
                                         discarded-slots property-list)))

;;; ----------------------------------------------------------------------
;;; CLASS REDEFINITION PROTOCOL

(ensure-generic-function 'reinitialize-instance
                         :lambda-list '(class &rest initargs))

(defmethod reinitialize-instance ((class class) &rest initargs
                                  &key (direct-superclasses () direct-superclasses-p)
                                       (direct-slots nil direct-slots-p))
  (let ((name (class-name class)))
    (when (member name '(CLASS BUILT-IN-CLASS) :test #'eq)
      (error "The kernel CLOS class ~S cannot be changed." name)))

  ;; remove previous defined accessor methods
  (when (class-finalized-p class)
    (remove-optional-slot-accessors class))

  (call-next-method)

  ;; the list of direct slots is converted to direct-slot-definitions
  (when direct-slots-p
    (setf (class-direct-slots class)
          (loop for s in direct-slots
                collect (canonical-slot-to-direct-slot class s))))

  ;; set up inheritance checking that it makes sense
  (when direct-superclasses-p
    (setf direct-superclasses 
          (check-direct-superclasses class direct-superclasses))
    (dolist (l (class-direct-superclasses class))
      (unless (member l direct-superclasses)
        (remove-direct-subclass l class)))
    (dolist (l (setf (class-direct-superclasses class)
                     direct-superclasses))
      (add-direct-subclass l class)))

  ;; if there are no forward references, we can just finalize the class here
  (setf (class-finalized-p class) nil)
  (finalize-unless-forward class)

  class)

(defmethod make-instances-obsolete ((class class))
  (setf (class-slots class) (copy-list (class-slots class)))
  class)

(defun remove-optional-slot-accessors (class)
  (declare (class class)
           (optimize (safety 0))
           (si::c-local))
  (dolist (slotd (class-slots class))
    ;; remove previous defined reader methods
    (dolist (reader (slot-definition-readers slotd))
      (let* ((gf-object (fdefinition reader))
             found)
        ;; primary method
        (when (setq found
                    (find-method gf-object nil (list class) nil))
          (remove-method gf-object found))
        ;; before method
        (when (setq found
                    (find-method gf-object ':before (list class) nil))
          (remove-method gf-object found))
        ;; after method
        (when (setq found
                    (find-method gf-object ':after (list class) nil))
          (remove-method gf-object found))
        (when (null (generic-function-methods gf-object))
          (fmakunbound reader))))

    ;; remove previous defined writer methods
    (dolist (writer (slot-definition-writers slotd))
      (let* ((gf-object (fdefinition writer))
             found)
        ;; primary method
        (when (setq found
                    (find-method gf-object nil (list 'T class) nil))
          (remove-method gf-object found))
        ;; before method
        (when (setq found
                    (find-method gf-object ':before (list 'T class) nil))
          (remove-method gf-object found))
        ;; after method
        (when (setq found
                    (find-method gf-object ':after (list 'T class) nil))
          (remove-method gf-object found))
        (when (null (generic-function-methods gf-object))
          (fmakunbound writer))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/change.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/hierarchy.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.o
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;
;;; COMMON LISP CLASSES HIERARCHY
;;;
;;; The following set of constants describe the slots, the names of
;;; the classes and their relation, including both standard Commmon Lisp
;;; and the MetaObject Protocol. This information is only loaded when
;;; bootstrapping and compiling ECL.
;;;

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; Class SPECIALIZER

(eval-when (:compile-toplevel :execute)
  (defparameter +specializer-slots+
    '((flag :initform nil :accessor eql-specializer-flag)
      (direct-methods :initform nil :accessor specializer-direct-methods)
      (direct-generic-functions :initform nil :accessor specializer-direct-generic-functions))))

(eval-when (:compile-toplevel :execute)
  (defparameter +eql-specializer-slots+
    '((flag :initform t :accessor eql-specializer-flag)
      (direct-methods :initform nil :accessor specializer-direct-methods)
      (direct-generic-functions :initform nil :accessor specializer-direct-generic-functions)
      (object :initarg :object :accessor eql-specializer-object))))

;;; ----------------------------------------------------------------------
;;; Class METHOD-COMBINATION

(eval-when (:compile-toplevel :execute)
  (defparameter +method-combination-slots+
    `((name :initarg :name :accessor method-combination-name)
      (compiler :initarg :compiler :accessor method-combination-compiler)
      (options :initarg :options :accessor method-combination-options))))

;;; ----------------------------------------------------------------------
;;; Class CLASS

(eval-when (:compile-toplevel :execute)
  (defparameter +class-slots+
    `(,@+specializer-slots+
      (name :initarg :name :initform nil :accessor class-id)
      (direct-superclasses :initarg :direct-superclasses
       :accessor class-direct-superclasses)
      (direct-subclasses :initform nil :accessor class-direct-subclasses)
      (slots :accessor class-slots)
      (precedence-list :accessor class-precedence-list)
      (direct-slots :initarg :direct-slots :accessor class-direct-slots)
      (direct-default-initargs :initarg :direct-default-initargs
       :initform nil :accessor class-direct-default-initargs)
      (default-initargs :accessor class-default-initargs)
      (finalized :initform nil :accessor class-finalized-p)
      (docstring :initarg :documentation :initform nil)
      (size :accessor class-size)
      (sealedp :initarg :sealedp :initform nil :accessor class-sealedp)
      (prototype)
      (dependents :initform nil :accessor class-dependents)
      (valid-initargs :accessor class-valid-initargs)
      (slot-table :accessor slot-table)
      (location-table :initform nil :accessor class-location-table)
      ))

  (defconstant +class-name-ndx+
    (position 'name +class-slots+ :key #'first))
  (defconstant +class-precedence-list-ndx+
    (position 'precedence-list +class-slots+ :key #'first)))

;;; ----------------------------------------------------------------------
;;; STANDARD-CLASS

(eval-when (:compile-toplevel :execute)
  (defparameter +standard-class-slots+
    (append +class-slots+
            '((optimize-slot-access)
              (forward)))))

;;; ----------------------------------------------------------------------
;;; STRUCTURE-CLASS

(eval-when (:compile-toplevel :execute)
  (defparameter +structure-class-slots+
    (append +class-slots+
            '((slot-descriptions)
              (initial-offset)
              (defstruct-form)
              (constructors)
              (documentation)
              (copier)
              (predicate)
              (print-function)))))

;;; ----------------------------------------------------------------------
;;; STANDARD-GENERIC-FUNCTION

(eval-when (:compile-toplevel :execute)
  (defparameter +standard-generic-function-slots+
    '((name :initarg :name :initform nil
       :reader generic-function-name)
      (spec-list :initform nil :accessor generic-function-spec-list)
      (method-combination 
       :initarg :method-combination :initform (find-method-combination (class-prototype (find-class 'standard-generic-function)) 'standard nil)
       :accessor generic-function-method-combination)
      (lambda-list :initarg :lambda-list
       :accessor generic-function-lambda-list)
      (argument-precedence-order 
       :initarg :argument-precedence-order
       :initform nil
       :accessor generic-function-argument-precedence-order)
      (method-class
       :initarg :method-class
       :initform (find-class 'standard-method))
      (docstring :initarg :documentation :initform nil)
      (methods :initform nil :accessor generic-function-methods)
      (a-p-o-function :initform nil :accessor generic-function-a-p-o-function)
      (declarations
       :initarg :declarations
       :initform nil
       :accessor generic-function-declarations)
      (dependents :initform nil :accessor generic-function-dependents))))

;;; ----------------------------------------------------------------------
;;; STANDARD-METHOD

(eval-when (:compile-toplevel :execute)
  (defparameter +standard-method-slots+
    '((the-generic-function :initarg :generic-function :initform nil
       :accessor method-generic-function)
      (lambda-list :initarg :lambda-list
       :accessor method-lambda-list)
      (specializers :initarg :specializers :accessor method-specializers)
      (qualifiers :initform nil :initarg :qualifiers :accessor method-qualifiers)
      (the-function :initarg :function :accessor method-function)
      (docstring :initarg :documentation :initform nil)
      (plist :initform nil :initarg :plist :accessor method-plist)
      (keywords :initform nil :accessor method-keywords)))

  (defparameter +standard-accessor-method-slots+
    (append +standard-method-slots+
            '((slot-definition :initarg :slot-definition
                    :initform nil 
               ;; FIXME! Should be a :reader
                    :accessor accessor-method-slot-definition)))))

;;; ----------------------------------------------------------------------
;;; SLOT-DEFINITION
;;;

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant +slot-definition-slots+
    '((name :initarg :name :initform nil :accessor slot-definition-name)
      (initform :initarg :initform :initform +initform-unsupplied+ :accessor slot-definition-initform)
      (initfunction :initarg :initfunction :initform nil :accessor slot-definition-initfunction)
      (declared-type :initarg :type :initform t :accessor slot-definition-type)
      (allocation :initarg :allocation :initform :instance :accessor slot-definition-allocation)
      (initargs :initarg :initargs :initform nil :accessor slot-definition-initargs)
      (readers :initarg :readers :initform nil :accessor slot-definition-readers)
      (writers :initarg :writers :initform nil :accessor slot-definition-writers)
      (docstring :initarg :documentation :initform nil :accessor slot-definition-documentation)
      (location :initarg :location :initform nil :accessor slot-definition-location)
      )))

;;; ----------------------------------------------------------------------
(eval-when (:compile-toplevel :execute)
  ;;
  ;; All changes to this are connected to the changes in 
  ;; the code of cl_class_of() in src/clos/instance.d
  ;;
  (defconstant +builtin-classes-list+
         '(;(t object)
            (sequence)
              (list sequence)
                (cons list)
            (array)
              (vector array sequence)
                (string vector)
                #+unicode
                (base-string string vector)
                (bit-vector vector)
            (stream)
              (ext:ansi-stream stream)
                (file-stream ext:ansi-stream)
                (echo-stream ext:ansi-stream)
                (string-stream ext:ansi-stream)
                (two-way-stream ext:ansi-stream)
                (synonym-stream ext:ansi-stream)
                (broadcast-stream ext:ansi-stream)
                (concatenated-stream ext:ansi-stream)
                (ext:sequence-stream ext:ansi-stream)
            (character)
            (number)
              (real number)
                (rational real)
                  (integer rational)
                    (fixnum integer)
                    (bignum integer)
                  (ratio rational)
                (float real)
                  (single-float float)
                  (double-float float)
              (complex number)
            (symbol)
              (null symbol list)
              (keyword symbol)
            (package)
            (function)
            (pathname)
              (logical-pathname pathname)
            (hash-table)
            (random-state)
            (readtable)
            (si::code-block)
            (si::foreign-data)
            (si::frame)
            (si::weak-pointer)
            #+threads (mp::process)
            #+threads (mp::lock)
            #+threads (mp::rwlock)
            #+threads (mp::condition-variable)
            #+threads (mp::semaphore)
            #+threads (mp::barrier)
            #+threads (mp::mailbox)
            #+sse2 (ext::sse-pack))))

;;; FROM AMOP:
;;;
;;;     Metaobject Class                Direct Superclasses
;;;     standard-object                 (t)
;;;     funcallable-standard-object     (standard-object function)
;;; *   metaobject                      (standard-object)
;;; *   generic-function                (metaobject funcallable-standard-object)
;;;     standard-generic-function       (generic-function)
;;; *   method                          (metaobject)
;;;     standard-method                 (method)
;;; *   standard-accessor-method        (standard-method)
;;;     standard-reader-method          (standard-accessor-method)
;;;     standard-writer-method          (standard-accessor-method)
;;; *   method-combination              (metaobject)
;;; *   slot-definition                 (metaobject)
;;; *   direct-slot-definition          (slot-definition)
;;; *   effective-slot-definition       (slot-definition)
;;; *   standard-slot-definition        (slot-definition)
;;;     standard-direct-slot-definition (standard-slot-definition direct-slot-definition)
;;;     standard-effective-slot-definition      (standard-slot-definition effective-slot-definition)
;;; *   specializer                     (metaobject)
;;;     eql-specializer                 (specializer)
;;; *   class                           (specializer)
;;;     built-in-class                  (class)
;;;     forward-referenced-class        (class)
;;;     standard-class                  (class)
;;;     funcallable-standard-class      (class)
;;;
(eval-when (eval)
  (defconstant +class-hierarchy+
    `((standard-class)
      (standard-effective-slot-definition)
      (standard-direct-slot-definition)
      (standard-class
       :metaclass nil ; Special-cased in boot.lsp
       :direct-slots #.+standard-class-slots+)
      (standard-direct-slot-definition
       :direct-slots #3=#.+slot-definition-slots+)
      (standard-effective-slot-definition
       :direct-slots #3#)
      (t
       :index 0)
      (standard-object
       :direct-superclasses (t))
      (metaobject
       :direct-superclasses (standard-object))
      (slot-definition
       :direct-superclasses (metaobject)
       :direct-slots #3#)
      (standard-slot-definition
       :direct-superclasses (slot-definition)
       :direct-slots #3#)
      (direct-slot-definition
       :direct-superclasses (slot-definition)
       :direct-slots #3#)
      (effective-slot-definition
       :direct-superclasses (slot-definition)
       :direct-slots #3#)
      (standard-direct-slot-definition
       :direct-superclasses (standard-slot-definition direct-slot-definition)
       :direct-slots #3#)
      (standard-effective-slot-definition
       :direct-superclasses (standard-slot-definition effective-slot-definition)
       :direct-slots #3#)
      (method-combination
       :direct-superclasses (metaobject)
       :direct-slots #.+method-combination-slots+)
      (specializer
       :direct-superclasses (metaobject)
       :direct-slots #.+specializer-slots+)
      (eql-specializer
       :direct-superclasses (specializer)
       :direct-slots #.+eql-specializer-slots+)
      (class
       :direct-superclasses (specializer)
       :direct-slots #.+class-slots+)
      (forward-referenced-class
       :direct-superclasses (class)
       :direct-slots #.+class-slots+)
      (built-in-class
       :direct-superclasses (class)
       :direct-slots #1=#.+standard-class-slots+)
      (std-class
       :direct-superclasses (class)
       :direct-slots #1#)
      (standard-class
       :direct-superclasses (std-class)
       :direct-slots #1#
       :metaclass standard-class)
      (funcallable-standard-class
       :direct-superclasses (std-class)
       :direct-slots #1#)
      ,@(loop for (name . rest) in +builtin-classes-list+
           for index from 1
           collect (list name :metaclass 'built-in-class
                         :index index
                         :direct-superclasses (or rest '(t))))
      (funcallable-standard-object
       :direct-superclasses (standard-object function))
      (generic-function
       :metaclass funcallable-standard-class
       :direct-superclasses (metaobject funcallable-standard-object))
      (standard-generic-function
       :direct-superclasses (generic-function)
       :direct-slots #.+standard-generic-function-slots+
       :metaclass funcallable-standard-class)
      (method
       :direct-superclasses (metaobject))
      (standard-method
       :direct-superclasses (method)
       :direct-slots #.+standard-method-slots+)
      (standard-accessor-method
       :direct-superclasses (standard-method)
       :direct-slots #2=#.+standard-accessor-method-slots+)
      (standard-reader-method
       :direct-superclasses (standard-accessor-method)
       :direct-slots #2#)
      (standard-writer-method
       :direct-superclasses (standard-accessor-method)
       :direct-slots #2#)
      (standard-optimized-reader-method
       :direct-superclasses (standard-reader-method)
       :direct-slots #2#)
      (standard-optimized-writer-method
       :direct-superclasses (standard-writer-method)
       :direct-slots #2#)
      (structure-class
       :direct-superclasses (class)
       :direct-slots #.+structure-class-slots+)
      (structure-object
       :metaclass structure-class
       :direct-superclasses (t))
      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/hierarchy.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/fixup.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;  Copyright (c) 2015, Daniel KochmaÅ„ski
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ---------------------------------------------------------------------
;;;                                                                 slots

#|
(defclass effective-slot-definition (slot-definition))

(defclass direct-slot-definition (slot-definition))

(defclass standard-slot-definition (slot-definition))

(defclass standard-direct-slot-definition
    (standard-slot-definition direct-slot-definition))

(defclass standard-effective-slot-definition
    (standard-slot-definition direct-slot-definition))
|#

(defmethod reader-method-class ((class std-class)
                                (direct-slot direct-slot-definition)
                                &rest initargs)
  (declare (ignore class direct-slot initargs))
  (find-class (if (member (class-name (class-of class))
                          '(standard-class
                            funcallable-standard-class
                            structure-class))
                  'standard-optimized-reader-method
                  'standard-reader-method)))

(defmethod writer-method-class ((class std-class)
                                (direct-slot direct-slot-definition)
                                &rest initargs)
  (declare (ignore class direct-slot initargs))
  (find-class (if (member (class-name (class-of class))
                          '(standard-class
                            funcallable-standard-class
                            structure-class))
                  'standard-optimized-writer-method
                  'standard-reader-method)))

;;; ---------------------------------------------------------------------
;;; Fixup

(defun register-method-with-specializers (method)
  (declare (si::c-local))
  (loop for spec in (method-specializers method)
     do (add-direct-method spec method)))

(dolist (method-info *early-methods* (makunbound '*EARLY-METHODS*))
  (let* ((method-name (car method-info))
         (gfun (fdefinition method-name))
         (standard-method-class (find-class 'standard-method)))
    (when (eq 'T (class-id (si:instance-class gfun)))
      ;; complete the generic function object
      (si:instance-class-set gfun
                             (find-class 'STANDARD-GENERIC-FUNCTION))
      (si::instance-sig-set gfun)
      (setf (slot-value gfun 'method-class) standard-method-class)
      (setf (slot-value gfun 'docstring) nil)
      )
    (dolist (method (cdr method-info))
      ;; complete the method object
      (let ((old-class (si::instance-class method)))
        (si::instance-class-set method
                                (cond ((null old-class)
                                       (find-class 'standard-method))
                                      ((symbolp old-class)
                                       (find-class (truly-the
                                                    symbol
                                                    old-class)))
                                      (t
                                       old-class))))
      (si::instance-sig-set gfun)
      (register-method-with-specializers method)
      )
    ))


;;; ---------------------------------------------------------------------
;;;                                                             redefined

(defun method-p (method) (typep method 'METHOD))

(defun make-method (method-class qualifiers specializers arglist
                    function options)
  (apply #'make-instance
         method-class
         :generic-function nil
         :qualifiers qualifiers
         :lambda-list arglist
         :specializers specializers
         :function function
         :allow-other-keys t
         options))

(defun all-keywords (l)
  (declare (si::c-local))
  (let ((all-keys '()))
    (do ((l (rest l) (cddddr l)))
        ((null l)
         all-keys)
      (push (first l) all-keys))))

(defun congruent-lambda-p (l1 l2)
  (multiple-value-bind (r1 opts1 rest1 key-flag1 keywords1 a-o-k1)
      (si::process-lambda-list l1 'FUNCTION)
    (declare (ignore a-o-k1))
    (multiple-value-bind (r2 opts2 rest2 key-flag2 keywords2 a-o-k2)
        (si::process-lambda-list l2 'FUNCTION)
        (and (= (length r2) (length r1))
             (= (length opts1) (length opts2))
             (eq (and (null rest1) (null key-flag1))
                 (and (null rest2) (null key-flag2)))
             ;; All keywords mentioned in the genericf function
             ;; must be accepted by the method.
             (or (null key-flag1)
                 (null key-flag2)
                 a-o-k2
                 (null (set-difference (all-keywords keywords1)
                                       (all-keywords keywords2))))
             t))))

(defun add-method (gf method)
  ;; during boot it's a structure accessor
  (declare (notinline method-qualifiers remove-method))
  ;;
  ;; 1) The method must not be already installed in another generic
  ;; function.
  ;;
  (let ((other-gf (method-generic-function method)))
    (unless (or (null other-gf) (eq other-gf gf))
      (error "The method ~A belongs to the generic function ~A ~
and cannot be added to ~A." method other-gf gf)))
  ;;
  ;; 2) The method and the generic function should have congruent
  ;;    lambda lists. That is, it should accept the same number of
  ;;    required and optional arguments, and only accept keyword
  ;;    arguments when the generic function does.
  ;;
  (let ((new-lambda-list (method-lambda-list method)))
    (if (slot-boundp gf 'lambda-list)
        (let ((old-lambda-list (generic-function-lambda-list gf)))
          (unless (congruent-lambda-p old-lambda-list new-lambda-list)
            (error "Cannot add the method ~A to the generic function ~A because ~
their lambda lists ~A and ~A are not congruent."
                   method gf old-lambda-list new-lambda-list)))
        (reinitialize-instance
         gf :lambda-list (implicit-generic-lambda new-lambda-list))))
  ;;
  ;; 3) Finally, it is inserted in the list of methods, and the method is
  ;;    marked as belonging to a generic function.
  ;;
  (when (generic-function-methods gf)
    (let* ((method-qualifiers (method-qualifiers method)) 
           (specializers (method-specializers method))
           (found (find-method gf method-qualifiers specializers nil)))
      (when found
        (remove-method gf found))))
  ;;
  ;; We install the method by:
  ;;  i) Adding it to the list of methods
  (push method (generic-function-methods gf))
  (setf (method-generic-function method) gf)
  ;;  ii) Updating the specializers list of the generic
  ;;  function. Notice that we should call add-direct-method for each
  ;;  specializer but specializer objects are not yet implemented
  #+(or)
  (dolist (spec (method-specializers method))
    (add-direct-method spec method))
  ;;  iii) Computing a new discriminating function... Well, since the
  ;;  core ECL does not need the discriminating function because we
  ;;  always use the same one, we just update the spec-how list of the
  ;;  generic function.
  (compute-g-f-spec-list gf)
  (set-generic-function-dispatch gf)
  ;;  iv) Update dependents.
  (update-dependents gf (list 'add-method method))
  ;;  v) Register with specializers
  (register-method-with-specializers method)
  gf)

(defun function-to-method (name signature)
  (let* ((aux-name 'temp-method)
         (method (eval `(defmethod ,aux-name ,signature)))
         (generic-function (fdefinition aux-name)))
    (setf (method-function method)
          (wrapped-method-function (fdefinition name)))
    (setf (fdefinition name) generic-function)
    (setf (generic-function-name generic-function) name)
    (fmakunbound aux-name)))

(defun remove-method (gf method)
  (setf (generic-function-methods gf)
        (delete method (generic-function-methods gf))
        (method-generic-function method) nil)
  (si:clear-gfun-hash gf)
  (loop for spec in (method-specializers method)
     do (remove-direct-method spec method))
  (compute-g-f-spec-list gf)
  (set-generic-function-dispatch gf)
  (update-dependents gf (list 'remove-method method))
  gf)

(function-to-method 'add-method
                    '((gf standard-generic-function)
                      (method standard-method)))
(function-to-method 'remove-method
                    '((gf standard-generic-function)
                      (method standard-method)))
(function-to-method 'find-method
                    '((gf standard-generic-function)
                      qualifiers specializers &optional error))

;;; COMPUTE-APPLICABLE-METHODS is used by the core in various places,
;;; including instance initialization. This means we cannot just
;;; redefine it.
;;; 
;;; Instead, we create an auxiliary function and move definitions from
;;; one to the other.
#+(or)
(defgeneric aux-compute-applicable-methods (gf args)
  (:method ((gf standard-generic-function) args)
    (std-compute-applicable-methods gf args)))

(defmethod aux-compute-applicable-methods
    ((gf standard-generic-function) args)
  (std-compute-applicable-methods gf args))
(let ((aux #'aux-compute-applicable-methods))
  (setf (generic-function-name aux) 'compute-applicable-methods
        (fdefinition 'compute-applicable-methods) aux))

(defmethod compute-applicable-methods-using-classes
    ((gf standard-generic-function) classes)
  (std-compute-applicable-methods-using-classes gf classes))

(function-to-method 'compute-effective-method
                    '((gf standard-generic-function)
                      method-combination
                      applicable-methods))

;;; ---------------------------------------------------------------------
;;; Error messages

(defmethod no-applicable-method (gf &rest args)
  (error "No applicable method for ~S with ~
          ~:[no arguments~;arguments of types ~:*~{~& ~A~}~]."
         (generic-function-name gf)
         (mapcar #'type-of args)))

(defmethod no-next-method (gf method &rest args)
  (declare (ignore gf))
  (error "In method ~A~%No next method given arguments ~A" method args))

(defun no-primary-method (gf &rest args)
  (error "Generic function: ~A. No primary method given arguments: ~S"
         (generic-function-name gf) args))

;;; Now we protect classes from redefinition:
(eval-when (compile load)
(defun setf-find-class (new-value name &optional errorp env)
  (declare (ignore errorp))
  (let ((old-class (find-class name nil env)))
    (cond
      ((typep old-class 'built-in-class)
       (error "The class associated to the CL specifier ~S cannot be changed."
              name))
      ((member name '(CLASS BUILT-IN-CLASS) :test #'eq)
       (error "The kernel CLOS class ~S cannot be changed." name))
      ((classp new-value)
       (setf (gethash name si:*class-name-hash-table*) new-value))
      ((null new-value) (remhash name si:*class-name-hash-table*))
      (t (error "~A is not a class." new-value))))
  new-value)
)

;;; ---------------------------------------------------------------------
;;; DEPENDENT MAINTENANCE PROTOCOL
;;;

(defmethod add-dependent ((c class) dep)
  (pushnew dep (class-dependents c)))

(defmethod add-dependent ((c generic-function) dependent)
  (pushnew dependent (generic-function-dependents c)))

(defmethod remove-dependent ((c class) dep)
  (setf (class-dependents c)
        (remove dep (class-dependents c))))

(defmethod remove-dependent ((c standard-generic-function) dep)
  (setf (generic-function-dependents c)
        (remove dep (generic-function-dependents c))))

(defmethod map-dependents ((c class) function)
  (dolist (d (class-dependents c))
    (funcall function d)))

(defmethod map-dependents ((c standard-generic-function) function)
  (dolist (d (generic-function-dependents c))
    (funcall function d)))

(defgeneric update-dependent (object dependent &rest initargs))

;; After this, update-dependents will work
(setf *clos-booted* 'map-dependents)

(defclass initargs-updater ()
  ())

(defun recursively-update-classes (a-class)
  (slot-makunbound a-class 'valid-initargs)
  (mapc #'recursively-update-classes
        (class-direct-subclasses a-class)))

(defmethod update-dependent ((object generic-function)
                             (dep initargs-updater)
                             &rest initargs)
  (declare (ignore dep initargs object))
  (recursively-update-classes +the-class+))

(let ((x (make-instance 'initargs-updater)))
  (add-dependent #'shared-initialize x)
  (add-dependent #'initialize-instance x)
  (add-dependent #'allocate-instance x))

(function-to-method 'make-method-lambda
                    '((gf standard-generic-function)
                      (method standard-method)
                      lambda-form
                      environment))

(function-to-method 'compute-discriminating-function
                    '((gf standard-generic-function)))
(function-to-method 'generic-function-method-class
                    '((gf standard-generic-function)))

(function-to-method 'find-method-combination
                    '((gf standard-generic-function)
                      method-combination-type-name
                      method-combination-options))

(function-to-method '(setf generic-function-name)
                    '((name t) (gf generic-function)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/fixup.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/slot.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(defconstant +initform-unsupplied+ '+initform-unsupplied+)

;;; ----------------------------------------------------------------------
;;; SLOT descriptors
;;;

(defun make-simple-slotd (class
                          &key name (initform +initform-unsupplied+) initfunction
                          (type 'T) (allocation :instance)
                          initargs readers writers documentation location)
  (when (and (eq allocation :class)
             (functionp initfunction))
    (setf initfunction (constantly (funcall initfunction))))
  (with-early-make-instance +slot-definition-slots+
    (slotd class
           :name name
           :initform initform
           :initfunction (if (listp initfunction) (eval initfunction) initfunction)
           :type type
           :allocation allocation
           :initargs initargs
           :readers readers
           :writers writers
           :documentation documentation
           :location location)
    slotd))

(defun freeze-class-slot-initfunction (slotd)
  (when (eq (getf slotd :allocation) :class)
    (let ((initfunc (getf slotd :initfunction)))
      (when initfunc
        (setf (getf slotd :initfunction)
              (constantly (funcall initfunc))))))
  slotd)

(defun canonical-slot-to-direct-slot (class slotd)
  ;; Class slot init functions must be called right away
  (setf slotd (freeze-class-slot-initfunction slotd))
  (if (find-class 'slot-definition nil)
      (apply #'make-instance
             (apply #'direct-slot-definition-class class
                    (freeze-class-slot-initfunction slotd))
             slotd)
      (apply #'make-simple-slotd class slotd)))

(defun direct-slot-to-canonical-slot (slotd)
  (list . #.(loop for (name . rest) in +slot-definition-slots+
               collect (getf rest :initarg)
               collect `(,(getf rest :accessor) slotd))))

;;; ----------------------------------------------------------------------
;;;
;;; (PARSE-SLOTS slot-definition-form) => slot-definition-object
;;;
;;; This routine is the one responsible for parsing the definition of
;;; a slot in DEFCLASS.
;;;

(defun make-function-initform (form)
  ;; INITFORM is a form that is to be evaluated at runtime. If it is a
  ;; constant value, we output simply a quoted form. If it is not,
  ;; we output a function that can be invoked at runtime to retrieve
  ;; the value.
  ;;
  ;; Output => (FUNCTION (LAMBDA () form))
  ;;        => (QUOTE ...)
  ;;
  (if (constantp form)
      `(constantly ,form)
      `#'(lambda () ,form)))

(defun parse-slot (slot &optional (full nil))
  (declare (si::c-local))
  (if (symbolp slot)
      (list* :name slot
             (when full (list :initform '+INITFORM-UNSUPPLIED+ :initfunction nil
                              :initargs nil :readers nil :writers nil
                              :allocation :instance :documentation nil
                              :type 'T)))
      (do* ((output (parse-slot (first slot) full))
            (options (rest slot))
            (value nil)
            (extra nil))
           ((null options)
            (nconc output extra))
        (let ((option (pop options)))
          (when (endp options)
            (si::simple-program-error
             "In the slot description ~S,~%the option ~S is missing an argument"
             slot option))
          (let ((value (pop options)))
            (when (and (member option '(:allocation :initform :type :documentation))
                       (getf options option))
              (si::simple-program-error
               "In the slot description ~S,~%the option ~S is duplicated"
               slot option))
            (case option
              (:initarg    (push value (getf output :initargs)))
              (:initform   (setf (getf output :initform) value
                                 (getf output :initfunction)
                                 (make-function-initform value)))
              (:accessor   (push value (getf output :readers))
                           (push `(setf ,value) (getf output :writers)))
              (:reader     (push value (getf output :readers)))
              (:writer     (push value (getf output :writers)))
              (:allocation (setf (getf output :allocation) value))
              (:type       (setf (getf output :type) value))
              (:documentation  (setf (getf output :documentation) value))
              (otherwise   (if (or (getf extra option)
                                   (getf options option))
                               (push value (getf extra option))
                               (setf (getf extra option) value)))))))))

(defun parse-slots (slots)
  (do ((scan slots (cdr scan))
       (collect))
      ((null scan) (nreverse collect))
    (let* ((slotd (parse-slot (first scan)))
           (name (getf slotd :name)))
      (dolist (other-slotd collect)
        (when (eq name (getf other-slotd :name))
          (si::simple-program-error
           "A definition for the slot ~S appeared twice in a DEFCLASS form"
           name)))
      (push slotd collect))))

;;; ----------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/slot.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/slotvalue.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.o
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(defmethod class-prototype ((class class))
  (unless (slot-boundp class 'prototype)
    (setf (slot-value class 'prototype) (allocate-instance class)))
  (slot-value class 'prototype))

(defun slot-makunbound (self slot-name)
  (let* ((class (class-of self))
         (slotd (find-slot-definition class slot-name)))
    (if slotd
        (slot-makunbound-using-class class self slotd)
        (slot-missing class self slot-name 'SLOT-MAKUNBOUND))
    self))

(defmethod slot-value-using-class ((class std-class) self slotd)
  (declare (ignore class))
  (let* ((location (slot-definition-location slotd))
         (value (standard-instance-access self location)))
    (if (si:sl-boundp value)
        value
        (values (slot-unbound class self (slot-definition-name slotd))))))

(defmethod slot-boundp-using-class ((class std-class) self slotd)
  (declare (ignore class))
  (si:sl-boundp (standard-instance-access self (slot-definition-location slotd))))

(defmethod (setf slot-value-using-class) (val (class std-class) self slotd)
  (declare (ignore class))
  (setf (standard-instance-access self (slot-definition-location slotd)) val))

(defmethod slot-makunbound-using-class ((class std-class) instance slotd)
  (declare (ignore class))
  (setf (standard-instance-access instance (slot-definition-location slotd)) (si:unbound))
  instance)

;;;
;;; 3) Error messages related to slot access
;;;

(defmethod slot-missing ((class t) object slot-name operation 
                         &optional new-value)
  (declare (ignore operation new-value class))
  (error "~A is not a slot of ~A" slot-name object))

(defmethod slot-unbound ((class t) object slot-name)
  (declare (ignore class))
  (error 'unbound-slot :instance object :name slot-name))

;;; This method is non-standard. It is used by clos:safe-instance-ref to
;;; signal an unbound slot error when only the index is known.
(defmethod slot-unbound ((class null) object slot-index)
  (declare (ignore class))
  (let* ((class (class-of object))
         (slotd (find slot-index (slot-value class 'slots)
                      :key #'slot-definition-location)))
    (values (slot-unbound class object (slot-definition-name slotd)))))

;;;
;;; For the next accessor we define a method.
;;;

(defmethod class-name ((class class))
  (class-id class))

(defmethod (setf class-name) (new-value (class class))
  (reinitialize-instance class :name new-value)
  new-value)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/slotvalue.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/cmpinit.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
(defvar std-compile (symbol-function 'compile-file))
(defun compile-file (file &key (output-file (make-pathname :type "o" :defaults file)))
  (funcall std-compile
           file
           :c-file t :h-file t :data-file t :system-p t
           :output-file nil))

;(setq compiler:*cc* (concatenate 'STRING compiler:*cc* " -I../h"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/cmpinit.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/init.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
(load "../util/system")
(load "defsys")
(load "cmpinit")
(setq compiler:*cc* (concatenate 'STRING compiler:*cc* " -I../h -I../../linux/h"))
(rename-package 'clos 'old-clos)
(setq si:*gc-verbose* nil)
(sbt:build-system clos :compile :force)
;(setq *print-circle* t)
;(allocate 'cons 800 t)
(quit)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/init.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/inspect.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; INTERACTIVE NAVIGATION THROUGH OBJECTS
;;;

(defmethod select-clos-N ((instance standard-object))
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class))
         (class-slotds (class-class-slots class)))
        (if local-slotds
            (progn
              (si::inspect-indent)
              (format t "The local slots are:~%")
              (incf si::*inspect-level*)
              (dolist (slotd local-slotds)
                (si::inspect-indent-1)
                (format t "name : ~S" (clos::slot-definition-name slotd))
                (if (slot-boundp instance (clos::slot-definition-name slotd))
                    (si::inspect-recursively "value:"
                       (slot-value instance (clos::slot-definition-name slotd))
                       (slot-value instance (clos::slot-definition-name slotd)))
                    (si::inspect-print "value: Unbound"
                       nil
                       (slot-value instance (clos::slot-definition-name slotd)))))
              (decf si::*inspect-level*))
            (progn
              (si::inspect-indent)
              (format t "It has no local slots.~%")))
        (if class-slotds
            (progn
              (si::inspect-indent)
              (format t "The class slots are:~%")
              (incf si::*inspect-level*)
              (dolist (slotd class-slotds)
                (si::inspect-indent-1)
                (format t "name : ~S" (clos::slot-definition-name slotd))
                (if (slot-boundp instance (clos::slot-definition-name slotd))
                    (si::inspect-recursively "value:"
                       (slot-value instance (clos::slot-definition-name slotd))
                       (slot-value instance (clos::slot-definition-name slotd)))
                    (si::inspect-print "value: Unbound"
                       nil
                       (slot-value instance (clos::slot-definition-name slotd)))))
              (decf si::*inspect-level*))
            (progn
              (si::inspect-indent)
              (format t "It has no class slots.~%")))))

(defun select-clos-N-inner-class (instance)
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class)))
        (if local-slotds
            (progn
              (si::inspect-indent)
              (format t "The (local) slots are:~%")
              (incf si::*inspect-level*)
              (dolist (slotd local-slotds)
                (si::inspect-indent-1)
                (format t "name : ~S" (clos::slot-definition-name slotd))
                (if (slot-boundp instance (clos::slot-definition-name slotd))
                    (si::inspect-recursively "value:"
                       (slot-value instance (clos::slot-definition-name slotd))
;                      (slot-value instance (clos::slot-definition-name slotd))
                       )
                    (si::inspect-print "value: Unbound"
                       nil
;                      (slot-value instance (clos::slot-definition-name slotd))
                       )))
              (decf si::*inspect-level*))
            (progn
              (si::inspect-indent)
              (format t "It has no (local) slots.~%")))))

(defmethod select-clos-N ((instance std-class))
  (select-clos-N-inner-class instance))

(defmethod select-clos-N ((instance t))
  (select-clos-N-inner-class instance))

(defmethod select-clos-L ((instance standard-object))
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class))
         (class-slotds (class-class-slots class)))
        (terpri)
        (if local-slotds
            (progn
              (format t "The names of the local slots are:~%")
              (dolist (slotd local-slotds)
                (format t "  ~S~%" (clos::slot-definition-name slotd))))
            (progn
              (format t "It has no local slots.~%")))
        (terpri)
        (if class-slotds
            (progn
              (format t "The names of the class slots are:~%")
              (dolist (slotd class-slotds)
                (format t "  ~S~%" (clos::slot-definition-name slotd))))
            (progn
              (format t "It has no class slots.~%")))
        (terpri)))

(defun select-clos-L-inner-class (instance)
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class)))
        (terpri)
        (if local-slotds
            (progn
              (format t "The names of the (local) slots are:~%")
              (dolist (slotd local-slotds)
                      (format t "  ~S~%" (clos::slot-definition-name slotd))))
            (progn
              (format t "It has no (local) slots.~%")))
        (terpri)))

(defmethod select-clos-L ((instance std-class))
  (select-clos-L-inner-class instance))

(defmethod select-clos-L ((instance t))
  (select-clos-L-inner-class instance))

(defmethod select-clos-J ((instance standard-object))
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class))
         (class-slotds (class-class-slots class))
         (slotd (car (member (prog1
                               (read-preserving-whitespace *query-io*)
                               (si::inspect-read-line))
                             (append local-slotds class-slotds)
                             :key #'clos::slot-definition-name
                             :test #'eq))))
        (if slotd
            (progn
              (incf si::*inspect-level*)
              (si::inspect-indent-1)
              (format t "name : ~S" (clos::slot-definition-name slotd))
              (if (slot-boundp instance (clos::slot-definition-name slotd))
                  (si::inspect-recursively "value:"
                     (slot-value instance (clos::slot-definition-name slotd))
                     (slot-value instance (clos::slot-definition-name slotd)))
                  (si::inspect-print "value: Unbound"
                     nil
                     (slot-value instance (clos::slot-definition-name slotd))))
              (decf si::*inspect-level*))
            (progn
              (terpri)
              (format t "~S is not a slot of the instance." (slot-definition-name slotd))
              (terpri)
              (terpri)))))

(defun select-clos-J-inner-class (instance)
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class))
         (slotd (car (member (prog1
                               (read-preserving-whitespace *query-io*)
                               (si::inspect-read-line))
                             local-slotds
                             :key #'clos::slot-definition-name
                             :test #'eq))))
        (if slotd
            (progn
              (incf si::*inspect-level*)
              (si::inspect-indent-1)
              (format t "name : ~S" (clos::slot-definition-name slotd))
              (if (slot-boundp instance (clos::slot-definition-name slotd))
                  (si::inspect-recursively "value:"
                     (slot-value instance (clos::slot-definition-name slotd))
;                    (slot-value instance (clos::slot-definition-name slotd))
                     )
                  (si::inspect-print "value: Unbound"
                     nil
;                    (slot-value instance (clos::slot-definition-name slotd))
                     ))
              (decf si::*inspect-level*))
            (progn
              (terpri)
              (format t "~S is not a slot of the instance." (slot-definition-name slotd))
              (terpri)
              (terpri)))))

(defmethod select-clos-J ((instance std-class))
  (select-clos-J-inner-class instance))

(defmethod select-clos-J ((instance t))
  (select-clos-J-inner-class instance))

(defun select-clos-? ()
  (declare (si::c-local))
  (terpri)
  (format t
          "Inspect commands for clos instances:~%~
n (or N or Newline):  inspects all slots of the class (recursively).~%~
s (or S):             skips the field.~%~
p (or P):             pretty-prints the field.~%~
a (or A):             aborts the inspection of the rest of the fields.~%~
e (or E) form:        evaluates and prints the form.~%~
l (or L):             show the names of all slots.~%~
j (or J) slot-name:   inspect the slot with the name requested.~%~
q (or Q):             quits the inspection.~%~
?:                    prints this.~%~%"
          ))

(defun class-local-slots (class)
  (remove :class (class-slots class) :key #'clos::slot-definition-allocation))

(defun class-class-slots (class)
  (remove :instance (class-slots class) :key #'clos::slot-definition-allocation))

(defmethod inspect-obj ((instance standard-object))
  (unless (let ((metaclass (si:instance-class (si:instance-class instance))))
            (or (eq metaclass (find-class 'STANDARD-CLASS))
                (eq metaclass (find-class 'FUNCALLABLE-STANDARD-CLASS))))
          (terpri)
          (format t "No applicable method CLOS::INSPECT-OBJ for an instance~%")
          (format t "of class ~S" (si:instance-class instance))
          (throw 'SI::ABORT-INSPECT nil))
  (decf si::*inspect-level*)
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class))
         (class-slotds (class-class-slots class)))
    (declare (type class class))
    (loop
      (format t "~S - clos object:" instance)
      (incf si::*inspect-level*)
      (si::inspect-indent)
      (format t "- it is an instance of class named ~S,"
              (class-name class))
      (si::inspect-indent)
      (format t "- it has ~A local slots and ~A class slots: "
              (length local-slotds) (length class-slotds))
      (force-output)
      (case (do ((char (read-char *query-io*) (read-char *query-io*)))
                ((and (char/= char #\Space) (char/= #\Tab)) char))
            ((#\Newline #\Return)
             (select-clos-N instance)
             (return nil))
            ((#\n #\N)
             (si::inspect-read-line)
             (select-clos-N instance)
             (return nil))
            ((#\s #\S)
             (si::inspect-read-line)
             (return nil))
            ((#\p #\P)
             (si::inspect-read-line)
             (si::select-P instance))
            ((#\a #\A)
             (si::inspect-read-line)
             (throw 'SI::ABORT-INSPECT nil))
            ((#\e #\E)
             (si::select-E))
            ((#\q #\Q)
             (si::inspect-read-line)
             (throw 'SI::QUIT-INSPECT nil))
            ((#\l #\L)
             (si::inspect-read-line)
             (select-clos-L instance))
            ((#\j #\J)
             (select-clos-J instance))
            ((#\?)
             (si::inspect-read-line)
             (select-clos-?))
            (t
             (si::inspect-read-line)))
      (decf si::*inspect-level*)
      (si::inspect-indent)))
  (incf si::*inspect-level*))

(defun inspect-obj-inner-class (instance)
  (decf si::*inspect-level*)
  (let* ((class (si:instance-class instance))
         (local-slotds (class-local-slots class)))
    (declare (type class class))
    (loop
      (format t "~S - clos object:" instance)
      (incf si::*inspect-level*)
      (si::inspect-indent)
      (format t "- it is an instance of class named ~S,"
              (class-name class))
      (si::inspect-indent)
      (format t "- it has ~A local slots: " (length local-slotds))
      (force-output)
      (case (do ((char (read-char *query-io*) (read-char *query-io*)))
                ((and (char/= char #\Space) (char/= #\Tab)) char))
            ((#\Newline #\Return)
             (select-clos-N instance)
             (return nil))
            ((#\n #\N)
             (si::inspect-read-line)
             (select-clos-N instance)
             (return nil))
            ((#\s #\S)
             (si::inspect-read-line)
             (return nil))
            ((#\p #\P)
             (si::inspect-read-line)
             (si::select-P instance))
            ((#\a #\A)
             (si::inspect-read-line)
             (throw 'SI::ABORT-INSPECT nil))
            ((#\e #\E)
             (si::select-E))
            ((#\q #\Q)
             (si::inspect-read-line)
             (throw 'SI::QUIT-INSPECT nil))
            ((#\l #\L)
             (si::inspect-read-line)
             (select-clos-L instance))
            ((#\j #\J)
             (select-clos-J instance))
            ((#\?)
             (si::inspect-read-line)
             (select-clos-?))
            (t
             (si::inspect-read-line)))
      (decf si::*inspect-level*)
      (si::inspect-indent)))
  (incf si::*inspect-level*))

(defmethod inspect-obj ((instance std-class))
  (inspect-obj-inner-class instance))

(defmethod inspect-obj ((instance t))
  (inspect-obj-inner-class instance))

;;; -------------------------------------------------------------------------
;;;
;;; Documentation
;;;

(defconstant +valid-documentation-types+
    '(compiler-macro function method-combination setf structure
      t type variable))

(defgeneric documentation (object doc-type))
(defgeneric (setf documentation) (new-value object doc-type))

(defmethod documentation ((object symbol) doc-type)
  (when (member doc-type +valid-documentation-types+)
    (case doc-type
      (type
       (let ((c (find-class object nil)))
         (if c
             (documentation c t)
             (si::get-documentation object doc-type))))
      (function
       (or (si::get-documentation object doc-type)
           (and (fboundp object)
                (documentation (or (macro-function object)
                                   (fdefinition object))
                               doc-type))))
      (otherwise
       (si::get-documentation object doc-type)))))

(defmethod (setf documentation) (new-value (object symbol) doc-type)
  (when (member doc-type +valid-documentation-types+)
    (case doc-type
      (type
       (let ((c (find-class object nil)))
         (if c
             (progn
               (si::set-documentation object 'type nil)
               (si::set-documentation object 'structure nil)
               (setf (documentation c t) new-value))
             (si::set-documentation object doc-type new-value))))
      (function
       (if (fboundp object)
           (let ((c (or (macro-function object) (fdefinition object))))
             (si::set-documentation c 'function nil)
             (setf (documentation c 'function) new-value))
           (si::set-documentation object doc-type new-value)))
      (otherwise
       (si::set-documentation object doc-type new-value))))
  new-value)

(defmethod documentation ((object package) doc-type)
  (when (member doc-type '(t package))
    (si::get-documentation object 'package)))

(defmethod (setf documentation) (new-value (object package) doc-type)
  (when (member doc-type '(t package))
    (si::set-documentation object 'package new-value)))

(defmethod documentation ((object class) doc-type)
  (when (and (member doc-type '(t type)) (slot-boundp object 'docstring))
    (slot-value object 'docstring)))

(defmethod (setf documentation) (new-value (object class) doc-type)
  (when (member doc-type '(t type))
    (setf (slot-value object 'docstring) new-value)))

(defmethod documentation ((object structure-class) doc-type)
  (when (member doc-type '(t type))
    (si::get-documentation (class-name object) 'structure)))

(defmethod (setf documentation) (new-value (object structure-class) doc-type)
  (when (member doc-type '(t type))
    (setf (documentation (class-name object) 'structure) new-value)))

(defmethod documentation ((object list) doc-type)
  (when (member doc-type '(function compiler-macro))
    (si::get-documentation object doc-type)))

(defmethod (setf documentation) (new-value (object list) doc-type)
  (when (member doc-type '(function compiler-macro))
    (si::set-documentation object doc-type new-value)))

(defmethod documentation ((object standard-generic-function) doc-type)
  (when (member doc-type '(t function))
    (slot-value object 'docstring)))

(defmethod (setf documentation) (new-value (object standard-generic-function) doc-type)
  (when (member doc-type '(t function))
    (setf (slot-value object 'docstring) new-value)))

(defmethod documentation ((object standard-method) doc-type)
  (when (member doc-type '(t function))
    (slot-value object 'docstring)))

(defmethod (setf documentation) (new-value (object standard-method) doc-type)
  (when (member doc-type '(t function))
    (setf (slot-value object 'docstring) new-value)))

(defmethod documentation ((object function) doc-type)
  (when (member doc-type '(t function))
    (si::get-documentation object doc-type)))

(defmethod (setf documentation) (new-value (object function) doc-type)
  (when (member doc-type '(t function))
    (si::set-documentation object doc-type new-value)))

(defmethod documentation ((object slot-definition) doc-type)
  (when (member doc-type '(t function))
    (slot-value object 'docstring)))

(defmethod (setf documentation) (new-value (object slot-definition) doc-type)
  (when (member doc-type '(t function))
    (setf (slot-value object 'docstring) new-value)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/inspect.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/combin.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    ECoLisp is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; COMPILING EFFECTIVE METHODS
;;;
;;; The following functions take care of transforming the forms
;;; produced by the method combinations into effective methods. In ECL
;;; effective methods are nothing but directly callable functions.
;;; Ideally, this compilation should just produce new compiled
;;; functions. However, we do not want to cons a lot of functions, and
;;; therefore we use closures.
;;;
;;; Formerly we used to keep a list of precompiled effective methods
;;; and made a structural comparison between the current method and
;;; the precompiled ones, so as to save memory. This only causes
;;; improvements in declarative combinations. For standard combinations
;;; it should be enough with a couple of different closures and hence
;;; the structural comparison is a loss of time.
;;;
;;; This is the core routine. It produces effective methods (i.e.
;;; functions) out of the forms generated by the method combinators.
;;; We consider the following cases:
;;;  1) Ordinary methods. The function of the method is extracted.
;;;  2) Functions. They map to themselves. This only happens
;;;     when these functions have been generated by previous calls
;;;     to EFFECTIVE-METHOD-FUNCTION.
;;;  3) (CALL-METHOD method rest-methods) A closure is
;;;     generated that invokes the current method while informing
;;;     it about the remaining methods.
;;;  4) (MAKE-METHOD form) A function is created that takes the
;;;     list of arguments of the generic function and evaluates
;;;     the forms in a null environment. This is the only form
;;;     that may lead to consing of new bytecodes objects. Nested
;;;     CALL-METHOD are handled via the global macro CALL-METHOD.
;;;  5) Ordinary forms are turned into lambda forms, much like
;;;     what happens with the content of MAKE-METHOD.
;;;
(defun effective-method-function (form &optional top-level &aux first)
  (cond ((functionp form)
         form)
        ((method-p form)
         (method-function form))
        ((atom form)
         (error "Malformed effective method form:~%~A" form))
        ((eq (setf first (first form)) 'MAKE-METHOD)
         (coerce `(lambda (.combined-method-args. *next-methods*)
                    (declare (special .combined-method-args. *next-methods*))
                    ,(second form))
                 'function))
        ((eq first 'CALL-METHOD)
         (combine-method-functions
          (effective-method-function (second form))
          (mapcar #'effective-method-function (third form))))
        (top-level
         (coerce `(lambda (.combined-method-args. no-next-methods)
                    (declare (ignorable no-next-methods))
                    ,form)
                 'function))
        (t
         (error "Malformed effective method form:~%~A" form))))

;;;
;;; This function is a combinator of effective methods. It creates a
;;; closure that invokes the first method while passing the information
;;; of the remaining methods. The resulting closure (or effective method)
;;; is the equivalent of (CALL-METHOD method rest-methods)
;;;
(defun combine-method-functions (method rest-methods)
  (declare (si::c-local))
  #'(lambda (.combined-method-args. no-next-methods)
      (declare (ignorable no-next-methods))
      (funcall method .combined-method-args. rest-methods)))

(defmacro call-method (method &optional rest-methods)
  `(funcall ,(effective-method-function method)
            .combined-method-args.
            ',(and rest-methods (mapcar #'effective-method-function rest-methods))))

(defun call-next-method (&rest args)
  (declare (special .combined-method-args. *next-methods*))
  (unless *next-methods*
    (error "No next method."))
  (funcall (car *next-methods*) (or args .combined-method-args.) (rest *next-methods*)))

(defun next-method-p ()
  (declare (special *next-methods*))
  *next-methods*)

(define-compiler-macro call-next-method (&rest args)
  `(if *next-methods*
       (funcall (car *next-methods*)
                ,(if args `(list ,@args) '.combined-method-args.)
                (rest *next-methods*))
       (error "No next method.")))

(define-compiler-macro next-method-p ()
  'clos::*next-methods*)

(defun error-qualifier (m qualifier)
  (declare (si::c-local))
  (error "Standard method combination allows only one qualifier ~
          per method, either :BEFORE, :AFTER, or :AROUND; while ~
          a method with ~S was found."
         m qualifier))

(defun standard-main-effective-method (before primary after)
  (declare (si::c-local))
  #'(lambda (.combined-method-args. no-next-method)
      (declare (ignorable no-next-method))
      (dolist (i before)
        (funcall i .combined-method-args. nil))
      (if after
          (multiple-value-prog1
           (funcall (first primary) .combined-method-args. (rest primary))
           (dolist (i after)
             (funcall i .combined-method-args. nil)))
        (funcall (first primary) .combined-method-args. (rest primary)))))

(defun standard-compute-effective-method (gf methods)
  (with-early-accessors (+standard-method-slots+)
    (let* ((before ())
           (primary ())
           (after ())
           (around ()))
      (dolist (m methods)
        (let* ((qualifiers (method-qualifiers m))
               (f (method-function m)))
          (cond ((null qualifiers) (push f primary))
                ((rest qualifiers) (error-qualifier m qualifiers))
                ((eq (setq qualifiers (first qualifiers)) :BEFORE)
                 (push f before))
                ((eq qualifiers :AFTER) (push f after))
                ((eq qualifiers :AROUND) (push f around))
                (t (error-qualifier m qualifiers)))))
      ;; When there are no primary methods, an error is to be signaled,
      ;; and we need not care about :AROUND, :AFTER or :BEFORE methods.
      (when (null primary)
        (return-from standard-compute-effective-method
          #'(lambda (&rest args)
              (apply 'no-primary-method gf args))))
      ;; PRIMARY, BEFORE and AROUND are reversed because they have to
      ;; be on most-specific-first order (ANSI 7.6.6.2), while AFTER
      ;; may remain as it is because it is least-specific-order.
      (setf primary (nreverse primary)
            before (nreverse before))
      (if around
          (let ((main (if (or before after)
                          (list
                           (standard-main-effective-method before primary after))
                          primary)))
            (setf around (nreverse around))
            (combine-method-functions (first around)
                                      (nconc (rest around) main)))
          (if (or before after)
              (standard-main-effective-method before primary after)
              (combine-method-functions (first primary) (rest primary))))
      )))

;; ----------------------------------------------------------------------
;; DEFINE-METHOD-COMBINATION
;;
;; METHOD-COMBINATION objects are just a list
;;      (name arg*)
;; where NAME is the name of the method combination type defined with
;; DEFINE-METHOD-COMBINATION, and ARG* is zero or more arguments.
;;
;; For each method combination type there is an associated function,
;; and the list of all known method combination types is kept in
;; *METHOD-COMBINATIONS* in the form of property list:
;;      (mc-type-name1 function1 mc-type-name2 function2 ....)
;;
;; FUNCTIONn is the function associated to a method combination. It
;; is of type (FUNCTION (generic-function method-list) FUNCTION),
;; and it outputs an anonymous function which is the effective method.
;;

#+threads
(defparameter *method-combinations-lock* (mp:make-lock :name 'find-method-combination))
(defparameter *method-combinations* (make-hash-table :size 32 :test 'eq))

(defun search-method-combination (name)
  (mp:with-lock (*method-combinations-lock*)
    (or (gethash name *method-combinations*)
        (error "~A does not name a method combination" name))))

(defun install-method-combination (name function)
  (mp:with-lock (*method-combinations-lock*)
    (setf (gethash name *method-combinations*) function))
  name)

(defun make-method-combination (name compiler options)
  (with-early-make-instance +method-combination-slots+
    (o (find-class 'method-combination)
       :name name
       :compiler compiler
       :options options)
    o))

(defun find-method-combination (gf method-combination-type-name method-combination-options)
  (make-method-combination method-combination-type-name
                           (search-method-combination method-combination-type-name)
                           method-combination-options
                           ))

(defun define-simple-method-combination (name &key documentation
                                         identity-with-one-argument
                                         (operator name))
  `(define-method-combination
     ,name (&optional (order :MOST-SPECIFIC-FIRST))
     ((around (:AROUND))
      (principal (,name) :REQUIRED t))
     ,documentation
     (let ((main-effective-method
            `(,',operator ,@(mapcar #'(lambda (x) `(CALL-METHOD ,x NIL))
                                    (if (eql order :MOST-SPECIFIC-LAST)
                                        (reverse principal)
                                        principal)))))
       (cond (around
              `(call-method ,(first around)
                (,@(rest around) (make-method ,main-effective-method))))
             (,(if identity-with-one-argument
                   '(rest principal)
                   t)
              main-effective-method)
             (t (second main-effective-method))))))

(defun define-complex-method-combination (form)
  (declare (si::c-local))
  (flet ((syntax-error ()
           (error "~S is not a valid DEFINE-METHOD-COMBINATION form"
                  form)))
    (destructuring-bind (name lambda-list method-groups &rest body &aux
                         (group-names '())
                         (group-checks '())
                         (group-after '())
                         (generic-function '.generic-function.)
                         (method-arguments '()))
        form
      (unless (symbolp name) (syntax-error))
      (let ((x (first body)))
        (when (and (consp x) (eql (first x) :ARGUMENTS))
          (error "Option :ARGUMENTS is not supported in DEFINE-METHOD-COMBINATION.")))
      (let ((x (first body)))
        (when (and (consp x) (eql (first x) :GENERIC-FUNCTION))
          (setf body (rest body))
          (unless (symbolp (setf generic-function (second x)))
            (syntax-error))))
      (dolist (group method-groups)
        (destructuring-bind (group-name predicate &key description
                                  (order :most-specific-first) (required nil))
            group
          (if (symbolp group-name)
              (push group-name group-names)
              (syntax-error))
          (let ((condition
                (cond ((eql predicate '*) 'T)
                      ((and predicate (symbolp predicate))
                       `(,predicate .METHOD-QUALIFIERS.))
                      ((and (listp predicate)
                            (let* ((q (last predicate 0))
                                   (p (copy-list (butlast predicate 0))))
                              (when (every #'symbolp p)
                                (if (eql q '*)
                                    `(every #'equal ',p .METHOD-QUALIFIERS.)
                                    `(equal ',p .METHOD-QUALIFIERS.))))))
                      (t (syntax-error)))))
            (push `(,condition (push .METHOD. ,group-name)) group-checks))
          (when required
            (push `(unless ,group-name
                    (error "Method combination: ~S. No methods ~
                            in required group ~S." ,name ,group-name))
                  group-after))
          (case order
            (:most-specific-first
             (push `(setf ,group-name (nreverse ,group-name)) group-after))
            (:most-specific-last)
            (otherwise
             (let ((order-var (gensym)))
               (setf group-names (append group-names (list (list order-var order)))
                     group-after (list* `(when (eq ,order-var :most-specific-first)
                                           (setf ,group-name (nreverse ,group-name)))
                                        group-after)))))))
      `(install-method-combination ',name
          (ext::lambda-block ,name (,generic-function .methods-list. ,@lambda-list)
            (let (,@group-names)
              (dolist (.method. .methods-list.)
                (let ((.method-qualifiers. (method-qualifiers .method.)))
                  (cond ,@(nreverse group-checks)
                        (t (invalid-method-error .method.
                             "Method qualifiers ~S are not allowed in the method~
                              combination ~S." .method-qualifiers. ,name)))))
              ,@group-after
              (effective-method-function (progn ,@body) t))))
      )))

(defmacro define-method-combination (name &body body)
  (if (and body (listp (first body)))
      (define-complex-method-combination (list* name body))
      (apply #'define-simple-method-combination name body)))

(defun method-combination-error (format-control &rest args)
  ;; FIXME! We should emit a more detailed error!
  (error "Method-combination error:~%~S"
         (apply #'format nil format-control args)))

(defun invalid-method-error (method format-control &rest args)
  (error "Invalid method error for ~A~%~S"
         method
         (apply #'format nil format-control args)))

;;; ----------------------------------------------------------------------
;;; COMPUTE-EFFECTIVE-METHOD
;;;

(eval-when (compile)
  (let* ((class (find-class 'method-combination)))
    (define-compiler-macro method-combination-compiler (o)
      `(si::instance-ref ,o ,(slot-definition-location (gethash 'compiler (slot-table class)))))
    (define-compiler-macro method-combination-options (o)
      `(si::instance-ref ,o ,(slot-definition-location (gethash 'options (slot-table class)))))))

(defun std-compute-effective-method (gf method-combination applicable-methods)
  (declare (type method-combination method-combination)
           (type generic-function gf)
           (optimize speed (safety 0)))
  (with-early-accessors (+method-combination-slots+)
    (let* ((compiler (method-combination-compiler method-combination))
           (options (method-combination-options method-combination)))
      (if options
          (apply compiler gf applicable-methods options)
          (funcall compiler gf applicable-methods)))))

(defun compute-effective-method-function (gf method-combination applicable-methods)
  ;; Cannot be inlined because it will be a method
  (declare (notinline compute-effective-method))
  (let ((form (compute-effective-method gf method-combination applicable-methods)))
    (let ((aux form) f)
      (if (and (listp aux)
                 (eq (pop aux) 'funcall)
                 (functionp (setf f (pop aux)))
                 (eq (pop aux) '.combined-method-args.)
                 (eq (pop aux) '*next-methods*))
          f
          (effective-method-function form t)))))

(defun compute-effective-method (gf method-combination applicable-methods)
  `(funcall ,(std-compute-effective-method gf method-combination applicable-methods)
            .combined-method-args. *next-methods*))

(install-method-combination 'standard 'standard-compute-effective-method)
(progn
  (define-method-combination progn :identity-with-one-argument t)
  (define-method-combination and :identity-with-one-argument t)
  (define-method-combination max :identity-with-one-argument t)
  (define-method-combination + :identity-with-one-argument t)
  (define-method-combination nconc :identity-with-one-argument t)
  (define-method-combination append :identity-with-one-argument nil)
  (define-method-combination list :identity-with-one-argument nil)
  (define-method-combination min :identity-with-one-argument t)
  (define-method-combination or :identity-with-one-argument t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/combin.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/conditions.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2001, Juan Jose Garcia-Ripoll
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;
;;; conditions.lsp
;;;
;;; Originally written by Kent M. Pitman of Symbolics, Inc. and
;;; distributed without any copyright.
;;; This is Version 18.
;;;
;;; KMP's disclaimer:
;;;
;;; This is a sample implementation. It is not in any way intended as the
;;; definition of any aspect of the condition system. It is simply an existence
;;; proof that the condition system can be implemented.
;;;

(in-package "SYSTEM")

;;; ----------------------------------------------------------------------
;;; Unique Ids

(defmacro unique-id (obj)
  "Generates a unique integer ID for its argument."
  `(sys:pointer ,obj))


;;; Restarts

(defparameter *restart-clusters* ())
(defparameter *condition-restarts* ())

;;; do we need copy-list if *restart-clusters* has only one element? Beppe
(defun compute-restarts (&optional condition)
  (let* ((assoc-restart ())
         (other ())
         (output ()))
    (when condition
      (dolist (i *condition-restarts*)
        (if (eq (first i) condition)
            (setq assoc-restart (append (rest i) assoc-restart))
            (setq other (append (rest i) other)))))
    (dolist (restart-cluster *restart-clusters*)
      (dolist (restart restart-cluster)
        (when (and (or (not condition)
                       (member restart assoc-restart)
                       (not (member restart other)))
                   (funcall (restart-test-function restart) condition))
          (push restart output))))
    (nreverse output)))

(defun restart-print (restart stream depth)
  (declare (ignore depth))
  (if *print-escape*
      (format stream "#<~s.~d>" (type-of restart) (unique-id restart))
      (restart-report restart stream))
  restart)

(defstruct (restart (:PRINT-FUNCTION restart-print))
  name
  function
  report-function
  interactive-function
  (test-function (constantly t)))

(defun restart-report (restart stream)
  (declare (si::c-local))
  (let ((fn (restart-report-function restart)))
    (if fn
        (funcall fn stream)
        (format stream "~s" (or (restart-name restart) restart)))))

(defun bind-simple-restarts (tag names)
  (flet ((simple-restart-function (tag code)
           #'(lambda (&rest args) (throw tag (values code args)))))
    (cons (loop for i from 1
             for n in (if (atom names) (list names) names)
             for f = (simple-restart-function tag i)
             collect (let ((v i))
                       (make-restart :name n
                                     :function f)))
          *restart-clusters*)))

(defun bind-simple-handlers (tag names)
  (flet ((simple-handler-function (tag code)
           #'(lambda (c) (throw tag (values code c)))))
    (cons (loop for i from 1
             for n in (if (atom names) (list names) names)
             for f = (simple-handler-function tag i)
             collect (cons n f))
          *handler-clusters*)))

(defmacro restart-bind (bindings &body forms)
  `(let ((*restart-clusters*
          (cons (list ,@(mapcar #'(lambda (binding)
                                    `(make-restart
                                      :NAME     ',(car binding)
                                      :FUNCTION ,(cadr binding)
                                      ,@(cddr binding)))
                                bindings))
                *restart-clusters*)))
     ,@forms))

(defun find-restart (name &optional condition)
  (dolist (restart (compute-restarts condition))
    (when (or (eq restart name) (eq (restart-name restart) name))
      (return-from find-restart restart))))

(defun find-restart-never-fail (restart &optional condition)
  (declare (si::c-local))
  (or (find-restart restart condition)
      (signal-simple-error 'control-error nil
             "Restart ~S is not active."
             (list restart))))

(defun invoke-restart (restart &rest values)
  (let ((real-restart (find-restart-never-fail restart)))
    (apply (restart-function real-restart) values)))

(defun invoke-restart-interactively (restart)
  (let ((real-restart (find-restart-never-fail restart)))
    (apply (restart-function real-restart)
           (let ((interactive-function
                   (restart-interactive-function real-restart)))
             (if interactive-function
                 (funcall interactive-function)
                 '())))))


(defmacro restart-case (expression &body clauses &environment env)
  (flet ((transform-keywords (&key report interactive test)
           (let ((keywords '()))
             (when test
               (setq keywords (list :TEST-FUNCTION `#',test)))                              
             (when interactive
               (setq keywords (list :INTERACTIVE-FUNCTION
                                    `#',interactive)))
             (when report
               (setq keywords (list* :REPORT-FUNCTION
                                     (if (stringp report)
                                         `#'(lambda (stream)
                                              (write-string ,report stream))
                                         `#',report)
                                     keywords)))
             keywords)))
    (let*((block-tag (gensym))
          (temp-var  (gensym))
          (data (mapcar #'(lambda (clause)
                            (let (keywords (forms (cddr clause)))
                              (do ()
                                  ((null forms))
                                (if (keywordp (car forms))
                                    (setq keywords (list* (car forms)
                                                          (cadr forms)
                                                          keywords)
                                          forms (cddr forms))
                                    (return)))
                              (list (car clause)                ;Name=0
                                    (gensym)                    ;Tag=1
                                    (apply #'transform-keywords ;Keywords=2
                                           keywords)
                                    (cadr clause)               ;BVL=3
                                    forms)))                    ;Body=4
                        clauses)))
      (let ((expression2 (macroexpand expression env)))
        (when (consp expression2)
          (let* ((condition-form nil)
                 (condition-var (gensym))
                 (name (first expression2)))
            (case name
              (SIGNAL
               (setq condition-form `(coerce-to-condition ,(second expression2)
                                      (list ,@ (cddr expression2))
                                      'simple-condition 'signal)))
              (ERROR
               (setq condition-form `(coerce-to-condition ,(second expression2)
                                      (list ,@(cddr expression2))
                                      'SIMPLE-ERROR 'ERROR)))
              (CERROR
               (setq condition-form `(coerce-to-condition ,(third expression2)
                                      (list ,@(cdddr expression2))
                                      'SIMPLE-ERROR 'CERROR)))
              (WARN
               (setq condition-form `(coerce-to-condition ,(second expression2)
                                      (list ,@(cddr expression2))
                                      'SIMPLE-WARNING 'WARN))))
            (when condition-form
              (setq expression
                    `(let ((,condition-var ,condition-form))
                      (with-condition-restarts ,condition-var
                        (first *restart-clusters*)
                        ,(if (eq name 'CERROR)
                             `(cerror ,(second expression2) ,condition-var)
                             (list name condition-var)))))
              ))))
      `(block ,block-tag
         (let ((,temp-var nil))
           (tagbody
             (restart-bind
               ,(mapcar #'(lambda (datum)
                            (let*((name (nth 0 datum))
                                  (tag  (nth 1 datum))
                                  (keys (nth 2 datum)))
                              `(,name #'(lambda (&rest temp)
                                          (setq ,temp-var temp)
                                          (go ,tag))
                                ,@keys)))
                        data)
               (return-from ,block-tag ,expression))
             ,@(mapcan #'(lambda (datum)
                           (let*((tag  (nth 1 datum))
                                 (bvl  (nth 3 datum))
                                 (body (nth 4 datum)))
                             (list tag
                                   `(return-from ,block-tag
                                      (apply #'(lambda ,bvl ,@body)
                                             ,temp-var)))))
                       data)))))))

(defmacro with-simple-restart ((restart-name format-control
                                             &rest format-arguments)
                               &body forms)
  `(restart-case (progn ,@forms)
     (,restart-name ()
        :REPORT (lambda (stream)
                  (format stream ,format-control ,@format-arguments))
      (values nil t))))

(defmacro with-condition-restarts (condition restarts &body forms)
  `(let ((*condition-restarts* (cons (cons ,condition ,restarts)
                                     *condition-restarts*)))
    ,@forms))


;;; ----------------------------------------------------------------------
;;; Condition Data Type

(defclass condition ()
  ((report-function :allocation :class :initform nil)))

(defmethod print-object ((c condition) stream)
  (if *print-escape*
      (call-next-method)
      (let ((reporter (slot-value c 'report-function)))
        (cond ((stringp reporter)
               (write-string reporter stream))
              ((null reporter)
               (call-next-method))
              (t
               (funcall reporter c stream))))))

(defmacro define-condition (name parent-list slot-specs &rest options)
  ;; CAUTION: ANSI states the equivalence between :REPORT and a method.
  ;; Does this mean that CALL-NEXT-METHOD should be available? SBCL does
  ;; not do it this way, and so don't we.
  (let* ((class-options nil))
    (dolist (option options)
      (case (car option)
        ((:DEFAULT-INITARGS :DOCUMENTATION)
         (push option class-options))
        (:REPORT
         (let ((report-function (cadr option)))
           (push `(report-function :initform ,(if (symbolp report-function)
                                                  (list 'quote report-function)
                                                  report-function))
                 slot-specs)))
        (otherwise (cerror "Ignore this DEFINE-CONDITION option."
                           "Invalid DEFINE-CONDITION option: ~S" option))))
    `(PROGN
      (DEFCLASS ,name ,(or parent-list '(CONDITION)) ,slot-specs ,@class-options)
      ',NAME)))

(defun find-subclasses-of-type (type class)
  ;; Find all subclasses of CLASS that are subtypes of the given TYPE.
  (declare (si::c-local))
  (if (subtypep class type)
      (list class)
      (loop for c in (clos::class-direct-subclasses class)
            nconc (find-subclasses-of-type type c))))

(defun make-condition (type &rest slot-initializations)
  (let ((class (or (and (symbolp type) (find-class type nil))
                   (first (last (sort (find-subclasses-of-type type (find-class 'condition))
                                      #'si::subclassp))))))
    (unless class
      (error 'SIMPLE-TYPE-ERROR
             :DATUM type
             :EXPECTED-TYPE 'CONDITION
             :FORMAT-CONTROL "Not a condition type: ~S"
             :FORMAT-ARGUMENTS (list type)))
    (apply #'make-instance class slot-initializations)))

#| For the moment, do not redefine these. Beppe.
(eval-when (eval compile load)

(defun accumulate-cases (macro-name cases list-is-atom-p)
  (do ((c cases (cdr c))
       (l '()))
      ((null c) (nreverse l))
    (let ((keys (caar c)))
      (cond ((atom keys)
             (cond ((null keys))
                   ((member keys '(OTHERWISE T))
                    (error "OTHERWISE is not allowed in ~S expressions."
                           macro-name))
                   (t (push keys l))))
            (list-is-atom-p
             (push keys l))
            (t (setq l (append keys l)))))))

);nehw-lave

(defmacro ecase (keyform &rest cases)
  (let ((keys (accumulate-cases 'ECASE cases nil)))
    `(case ,keyform
      ,@cases
      (otherwise
       (error 'CASE-FAILURE :name 'ECASE
        :datum ,keyform
        :expected-type '(MEMBER ,@keys)
        :possibilities ',keys))))))

(defmacro ccase (keyplace &rest cases)
  (let ((keys (accumulate-cases 'CCASE cases nil))
        (tag1 (gensym))
        (tag2 (gensym)))
    `(block ,tag1
       (tagbody ,tag2
         (return-from ,tag1
           (case ,keyplace
             ,@cases
             (otherwise
               (restart-case (error 'CASE-FAILURE
                                    :name 'CCASE
                                    :datum ,keyplace
                                    :expected-type '(MEMBER ,@keys)
                                    :possibilities ',keys)
                 (store-value (value)
                     :report (lambda (stream)
                               (format stream "Supply a new value of ~S."
                                       ',keyplace))
                     :interactive read-evaluated-form
                   (setf ,keyplace value)
                   (go ,tag2))))))))))



(defmacro etypecase (keyform &rest cases)
  (let ((types (accumulate-cases 'ETYPECASE cases t)))
    `(typecase ,keyform
      ,@cases
      (otherwise
       (error 'CASE-FAILURE :name 'ETYPECASE
        :datum ,keyform
        :expected-type '(OR ,@types)
        :possibilities ',types)))))

(defmacro ctypecase (keyplace &rest cases)
  (let ((types (accumulate-cases 'CTYPECASE cases t))
        (tag1 (gensym))
        (tag2 (gensym)))
    `(block ,tag1
       (tagbody ,tag2
         (return-from ,tag1
           (typecase ,keyplace
             ,@cases
             (otherwise
               (restart-case (error 'CASE-FAILURE
                                    :name 'CTYPECASE
                                    :datum ,keyplace
                                    :expected-type '(OR ,@types)
                                    :possibilities ',types)
                 (store-value (value)
                     :REPORT (lambda (stream)
                               (format stream "Supply a new value of ~S."
                                       ',keyplace))
                     :INTERACTIVE read-evaluated-form
                   (setf ,keyplace value)
                   (go ,tag2))))))))))

|#


(defparameter *handler-clusters* nil)

(defmacro handler-bind (bindings &body forms)
  (unless (every #'(lambda (x) (and (listp x) (= (length x) 2))) bindings)
    (error "Ill-formed handler bindings."))
  `(let ((*handler-clusters*
          (cons (list ,@(mapcar #'(lambda (x) `(cons ',(car x) ,(cadr x)))
                                bindings))
                *handler-clusters*)))
     ,@forms))

(defun signal (datum &rest arguments)
  (let* ((condition
           (coerce-to-condition datum arguments 'SIMPLE-CONDITION 'SIGNAL))
         (*handler-clusters* *handler-clusters*))
    (if (typep condition *break-on-signals*)
        (break "~A~%Break entered because of *BREAK-ON-SIGNALS*."
               condition))
    (loop (unless *handler-clusters* (return))
          (let ((cluster (pop *handler-clusters*)))
            (dolist (handler cluster)
              (when (typep condition (car handler))
                (funcall (cdr handler) condition)))))
    nil))



;;; COERCE-TO-CONDITION
;;;  Internal routine used in ERROR, CERROR, BREAK, and WARN for parsing the
;;;  hairy argument conventions into a single argument that's directly usable 
;;;  by all the other routines.

(defun coerce-to-condition (datum arguments default-type function-name)
  (cond ((typep datum 'CONDITION)
         (when arguments
           (cerror "Ignore the additional arguments."
                   'SIMPLE-TYPE-ERROR
                   :DATUM arguments
                   :EXPECTED-TYPE 'NULL
                   :FORMAT-CONTROL "You may not supply additional arguments ~
                                     when giving ~S to ~S."
                   :FORMAT-ARGUMENTS (list datum function-name)))
         datum)
        ((symbolp datum)                  ;roughly, (subtypep datum 'CONDITION)
         (apply #'make-condition datum arguments))
        ((or (stringp datum) (functionp datum))
         (make-condition default-type
                         :FORMAT-CONTROL datum
                         :FORMAT-ARGUMENTS arguments))
        (t
         (error 'SIMPLE-TYPE-ERROR
                :DATUM datum
                :EXPECTED-TYPE '(OR SYMBOL STRING)
                :FORMAT-CONTROL "Bad argument to ~S: ~S"
                :FORMAT-ARGUMENTS (list function-name datum)))))

(defun break (&optional (format-control "Break") &rest format-arguments)
  "Enters a break loop.  The execution of the program can be resumed by typing
:CONTINUE at the break loop.  Type :HELP to see the break-loop commands list.
If FORMAT-STRING is non-NIL, it is used as the format string to be output to
*ERROR-OUTPUT* before entering the break loop.  ARGs are arguments to the
format string."
  (let ((*debugger-hook* nil))
    (with-simple-restart (continue "Return from BREAK.")
      (invoke-debugger
       (make-condition 'SIMPLE-CONDITION
                       :FORMAT-CONTROL format-control
                       :FORMAT-ARGUMENTS format-arguments))))
  nil)

(defun warn (datum &rest arguments)
  "Args: (format-string &rest args)
Formats FORMAT-STRING and ARGs to *ERROR-OUTPUT* as a warning message.  Enters
a break level if the value of *BREAK-ON-WARNINGS* is non-NIL.  Otherwise,
returns with NIL."
  (let ((condition
          (coerce-to-condition datum arguments 'SIMPLE-WARNING 'WARN)))
    (check-type condition warning "a warning condition")
    (restart-case (signal condition)
      (muffle-warning ()
          :REPORT "Skip warning."
        (return-from warn nil)))
    (format *error-output* "~&;;; Warning: ~A~%" condition)
    nil))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ALL CONDITIONS
;;;
;;; Instead of compiling each condition definition, we store them in a
;;; list and evaluate them at run time. Besides, there are multiple
;;; SIMPLE-* conditions which inherit from SIMPLE-ERROR and which are
;;; only created when the error is signaled.
;;;

(define-condition warning () ())

(define-condition serious-condition () ())

(define-condition error (serious-condition) ())

(define-condition simple-condition ()
  ((format-control :INITARG :FORMAT-CONTROL :INITFORM ""
                   :ACCESSOR simple-condition-format-control)
   (format-arguments :INITARG :FORMAT-ARGUMENTS :INITFORM NIL
                     :ACCESSOR simple-condition-format-arguments))
  (:REPORT
   (lambda (condition stream)
     (format stream "~?" (simple-condition-format-control condition)
             (simple-condition-format-arguments condition)))))

(define-condition simple-warning (simple-condition warning) ())

(define-condition style-warning (warning) ())

(define-condition simple-style-warning (style-warning simple-condition) ())

(define-condition simple-error (simple-condition error) ())

(define-condition storage-condition (serious-condition) ())

(define-condition ext:segmentation-violation (storage-condition)
  ()
  (:REPORT "Detected access to an invalid or protected memory address."))

(define-condition ext:stack-overflow (storage-condition)
  ((size :initarg :size :initform 0 :reader ext:stack-overflow-size)
   (type :initarg :type :initform nil :reader ext:stack-overflow-type))
  (:REPORT
   (lambda (condition stream)
     (let* ((type (ext::stack-overflow-type condition))
            (size (ext::stack-overflow-size condition)))
       (if size
           (format stream "~A overflow at size ~D. Stack can probably be resized.
Proceed with caution."
                   type size)
           (format stream "~A stack overflow. Stack cannot grow any further. Either exit
or return to an outer frame, undoing all the function calls so far."
                   type))))))

(define-condition ext:storage-exhausted (storage-condition) ()
  (:REPORT "Memory limit reached. Please jump to an outer pointer, quit program and enlarge the
memory limits before executing the program again."))

(define-condition ext:illegal-instruction (serious-condition)
  ()
  (:REPORT "Illegal instruction."))

(define-condition ext:unix-signal-received ()
  ((code :type fixnum
         :initform 0
         :initarg :code
         :accessor ext:unix-signal-received-code))
  (:report (lambda (condition stream)
             (format stream "Serious signal ~D caught."
                     (ext:unix-signal-received-code condition)))))

(define-condition type-error (error)
  ((datum :INITARG :DATUM :READER type-error-datum)
   (expected-type :INITARG :EXPECTED-TYPE :READER type-error-expected-type))
  (:REPORT
   (lambda (condition stream)
     (format stream "~S is not of type ~S."
             (type-error-datum condition)
             (type-error-expected-type condition)))))

(define-condition simple-type-error (simple-condition type-error) ())

(define-condition case-failure (type-error)
  ((name :INITARG :NAME :READER case-failure-name)
   (possibilities :INITARG :POSSIBILITIES :READER case-failure-possibilities))
  (:REPORT
   (lambda (condition stream)
     (format stream "~S fell through ~S expression.~%Wanted one of ~:S."
             (type-error-datum condition)
             (case-failure-name condition)
             (case-failure-possibilities condition)))))

(define-condition program-error (error) ())

(define-condition control-error (error) ())

(define-condition stream-error (error)
  ((stream :initarg :stream :reader stream-error-stream)))

(define-condition end-of-file (stream-error)
  ()
  (:REPORT (lambda (condition stream)
             (format stream "Unexpected end of file on ~S."
                     (stream-error-stream condition)))))

(define-condition file-error (error)
  ((pathname :INITARG :PATHNAME :READER file-error-pathname))
  (:REPORT (lambda (condition stream)
             (format stream "Filesystem error with pathname ~S.~%Either
 1) the file does not exist, or
 2) we are not allowed to access the file, or
 3) the pathname points to a broken symbolic link."
                     (file-error-pathname condition)))))

(define-condition package-error (error)
  ((package :INITARG :PACKAGE :READER package-error-package)))

(define-condition cell-error (error)
  ((name :INITARG :NAME :READER cell-error-name)))

(define-condition unbound-variable (cell-error)
  ()
  (:REPORT (lambda (condition stream)
             (format stream "The variable ~S is unbound."
                     (cell-error-name condition)))))
  
(define-condition unbound-slot (cell-error)
  ((instance :INITARG :INSTANCE :READER unbound-slot-instance))
  (:REPORT (lambda (condition stream)
             (format stream "The slot ~S in the object ~S is unbound."
                     (cell-error-name condition)
                     (unbound-slot-instance condition)))))

(define-condition undefined-function (cell-error)
  ()
  (:REPORT (lambda (condition stream)
             (format stream "The function ~S is undefined."
                     (cell-error-name condition)))))

(define-condition arithmetic-error (error)
  ((operation :INITARG :OPERATION :READER arithmetic-error-operation)
   (operands :INITARG :OPERANDS :INITFORM '() :READER arithmetic-error-operands)))

(define-condition division-by-zero (arithmetic-error) ())

(define-condition floating-point-overflow (arithmetic-error) ())

(define-condition floating-point-underflow (arithmetic-error) ())

(define-condition floating-point-inexact (arithmetic-error) ())

(define-condition floating-point-invalid-operation (arithmetic-error) ())

(define-condition abort-failure (control-error) ()
  (:REPORT "Abort failed."))

(define-condition print-not-readable (error)
  ((object :INITARG :OBJECT :READER print-not-readable-object))
  (:REPORT (lambda (condition stream)
             (format stream "Cannot print object ~A readably."
                     (print-not-readable-object condition)))))

(define-condition parse-error (error) ())

(define-condition reader-error (parse-error stream-error) ())

(define-condition format-error (simple-error)
  ((format-control :initarg :complaint)
   (format-arguments :initarg :arguments)
   (control-string :reader format-error-control-string
                   :initarg :control-string
                   #+cmu-format :initform
                   #+cmu-format *default-format-error-control-string*) 
   (offset :reader format-error-offset :initarg :offset
           #+cmu-format :initform
           #+cmu-format *default-format-error-offset*)
   (print-banner :reader format-error-print-banner :initarg :print-banner
                 :initform t))
  (:report (lambda (condition stream)
             (cl:format stream
                        "~:[~;Error in format: ~]~
                         ~?~@[~%  ~A~%  ~V@T^~]"
                        (format-error-print-banner condition)
                        (simple-condition-format-control condition)
                        (simple-condition-format-arguments condition)
                        (format-error-control-string condition)
                        (format-error-offset condition)))))

(define-condition ext:interactive-interrupt (serious-condition)
  ()
  (:report "Console interrupt."))


(defun signal-simple-error (base-condition continue-message format-control format-args
                            &rest args)
  (let ((simple-error-name (intern (concatenate 'string "SIMPLE-" (string base-condition))
                                   (find-package "SI"))))
    (unless (find-class simple-error-name nil)
      (eval `(defclass ,simple-error-name (simple-error ,base-condition) ())))
    (if continue-message
        (apply #'cerror continue-message simple-error-name :format-control format-control
               :format-arguments format-args args)
        (apply #'error simple-error-name :format-control format-control
               :format-arguments format-args args))))
           


(defmacro handler-case (form &rest cases)
  (let ((no-error-clause (assoc ':NO-ERROR cases)))
    (if no-error-clause
        (let* ((normal-return (make-symbol "NORMAL-RETURN"))
               (error-return  (make-symbol "ERROR-RETURN")))
          `(block ,error-return
            (multiple-value-call #'(lambda ,@(cdr no-error-clause))
              (block ,normal-return
                (return-from ,error-return
                  (handler-case (return-from ,normal-return ,form)
                     ,@(remove no-error-clause cases)))))))
        (let* ((tag (gensym))
               (var (gensym))
               (annotated-cases (mapcar #'(lambda (case) (cons (gensym) case))
                                        cases)))
          `(block ,tag
             (let ((,var nil))
               (declare (ignorable ,var))
               (tagbody
                 (handler-bind ,(mapcar #'(lambda (annotated-case)
                                            (list (cadr annotated-case)
                                                  `#'(lambda (temp)
                                                       (declare (ignorable temp))
                                                       ,@(if (caddr annotated-case)
                                                             `((setq ,var temp)))
                                                       (go ,(car annotated-case)))))
                                        annotated-cases)
                               (return-from ,tag ,form))
                 ,@(mapcan #'(lambda (annotated-case)
                               (list (car annotated-case)
                                     (let ((body (cdddr annotated-case)))
                                       `(return-from ,tag
                                          ,(if (caddr annotated-case)
                                               `(let ((,(caaddr annotated-case)
                                                       ,var))
                                                 ,@body)
                                               ;; We must allow declarations!
                                               `(locally ,@body))))))
                           annotated-cases))))))))

(defmacro ignore-errors (&rest forms)
  `(handler-case (progn ,@forms)
     (error (condition) (values nil condition))))

(defun abort (&optional c)
  (invoke-restart (find-restart-never-fail 'ABORT c))
  (error 'ABORT-FAILURE))

(defun continue (&optional c)
  (let ((restart (find-restart 'CONTINUE c)))
    (and restart (invoke-restart restart))))

(defun muffle-warning (&optional c)
  (invoke-restart (find-restart-never-fail 'MUFFLE-WARNING c)))

(defun store-value (value &optional c)
  (let ((restart (find-restart 'STORE-VALUE c)))
    (and restart (invoke-restart restart value))))

(defun use-value (value &optional c)
  (let ((restart (find-restart 'USE-VALUE c)))
    (and restart (invoke-restart restart value))))

(defun assert-report (names stream)
  (declare (si::c-local))
  (format stream "Retry assertion")
  (if names
      (format stream " with new value~P for ~{~S~^, ~}."
              (length names) names)
      (format stream ".")))

(defun assert-prompt (name value)
  (declare (si::c-local))
  (if (y-or-n-p "The old value of ~S is ~S.~
                ~%Do you want to supply a new value? "
                name value)
      (flet ((read-it () (eval (read *query-io*))))
        (format *query-io* "~&Type a form to be evaluated:~%")
        (if (symbolp name) ;Help user debug lexical variables
            (progv (list name) (list value) (read-it))
            (read-it)))
      value))

(defun assert-failure (test-form &optional place-names values
                       &rest arguments)
  (unless arguments
    (setf arguments (list 'SIMPLE-TYPE-ERROR
                          :DATUM test-form
                          :EXPECTED-TYPE nil ; This needs some work in revision
                          :FORMAT-CONTROL "The assertion ~S failed"
                          :FORMAT-ARGUMENTS (list test-form))))
  (restart-case (error (si::coerce-to-condition (first arguments)
                                                (rest arguments)
                                                'simple-error
                                                'assert))
    (continue ()
      :REPORT (lambda (stream) (assert-report place-names stream))
      (return-from assert-failure
        (values-list (loop for place-name in place-names
                        for value in values
                        collect (assert-prompt place-name value)))))))

;;; ----------------------------------------------------------------------
;;; ECL's interface to the toplevel and debugger

(defun sys::universal-error-handler (continue-string datum args)
  "Args: (error-name continuable-p function-name
       continue-format-string error-format-string
       &rest args)
ECL specific.
Starts the error handler of ECL.
When an error is detected, ECL calls this function with the specified
arguments.  To change the error handler of ECL, redefine this function.
ERROR-NAME is the name of the error.  CONTINUABLE-P is T for a continuable
error and NIL for a fatal error.  FUNCTION-NAME is the name of the function
that caused the error.  CONTINUE-FORMAT-STRING and ERROR-FORMAT-STRING are the
format strings of the error message.  ARGS are the arguments to the format
strings."
  (declare (inline apply) ;; So as not to get bogus frames in debugger
           #-ecl-min
           (c::policy-debug-ihs-frame))
  (let ((condition (coerce-to-condition datum args 'simple-error 'error)))
    (cond
      ((eq t continue-string)
       ; from CEerror; mostly allocation errors
       (with-simple-restart (ignore "Ignore the error, and try the operation again")
         (signal condition)
         (invoke-debugger condition)))
      ((stringp continue-string)
       (with-simple-restart
         (continue "~A" (format nil "~?" continue-string args))
         (signal condition)
         (invoke-debugger condition)))
      ((and continue-string (symbolp continue-string))
       ; from CEerror
       (with-simple-restart (accept "Accept the error, returning NIL")
         (multiple-value-bind (rv used-restart)
           (with-simple-restart (ignore "Ignore the error, and try the operation again")
             (multiple-value-bind (rv used-restart)
               (with-simple-restart (continue "Continue, using ~S" continue-string)
                 (signal condition)
                 (invoke-debugger condition))

               (if used-restart continue-string rv)))
           (if used-restart t rv))))
      (t
        (progn
          (signal condition)
          (invoke-debugger condition))))))

(defun sys::stack-error-handler (continue-string datum args)
  (unwind-protect (universal-error-handler continue-string datum args)
    (si:reset-margin
     (getf args :type))))

(defun sys::tpl-continue-command (&rest any)
  (apply #'invoke-restart 'continue any))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/conditions.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/boot.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.o
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(defconstant +builtin-classes-pre-array+
  (make-array (1+ #.(length +builtin-classes-list+))))

;;; ----------------------------------------------------------------------
;;; Building the classes T, CLASS, STANDARD-OBJECT and STANDARD-CLASS.
;;;
;;; We cannot use the functions CREATE-STANDARD-CLASS and others because SLOTS,
;;; DIRECT-SLOTS, etc are empty and therefore SLOT-VALUE does not work.

(defun make-empty-standard-class (name &key (metaclass 'standard-class)
                                  direct-superclasses direct-slots index)
  (declare (optimize speed (safety 0)))
  (let* ((the-metaclass (and metaclass (gethash metaclass si::*class-name-hash-table*)))
         (class (or (gethash name si::*class-name-hash-table*)
                    (si:allocate-raw-instance nil the-metaclass
                                              #.(length +standard-class-slots+)))))
    (with-early-accessors (+standard-class-slots+)
      (when (eq name 'standard-class)
        (defconstant +the-standard-class+ class)
        (si:instance-class-set class class))
      (setf (class-id                  class) name
            (class-direct-subclasses   class) nil
            (class-direct-default-initargs class) nil
            (class-default-initargs    class) nil
            (class-finalized-p         class) t
            (eql-specializer-flag      class) nil
            (specializer-direct-methods class) nil
            (specializer-direct-generic-functions class) nil
            (gethash name si::*class-name-hash-table*) class
            (class-sealedp             class) nil
            (class-dependents          class) nil
            (class-valid-initargs      class) nil
            )
      (add-slots class direct-slots)
      (let ((superclasses (loop for name in direct-superclasses
                             for parent = (find-class name)
                             do (push class (class-direct-subclasses parent))
                             collect parent)))
        (setf (class-direct-superclasses class) superclasses
              (class-precedence-list class)
              (compute-clos-class-precedence-list class superclasses)))
      (when index
        (setf (aref +builtin-classes-pre-array+ index) class))
      class)))

(defun remove-accessors (slotds)
  (declare (optimize speed (safety 0)))
  (loop for i in slotds
     for j = (copy-list i)
     do (remf (cdr j) :accessor)
     collect j))

(defun add-slots (class slots)
  (declare (si::c-local)
           (optimize speed (safety 0)))
  ;; It does not matter that we pass NIL instead of a class object,
  ;; because CANONICAL-SLOT-TO-DIRECT-SLOT will make simple slots.
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (let* ((table (make-hash-table :size (if slots 24 0)))
           (location-table (make-hash-table :size (if slots 24 0)))
           (slots (parse-slots slots))
           (direct-slots (loop for slotd in slots
                            collect (apply #'make-simple-slotd
                                     (find-class 'standard-direct-slot-definition)
                                     slotd)))
           (effective-slots (loop for i from 0
                               for slotd in slots
                               for name = (getf slotd :name)
                               for s = (apply #'make-simple-slotd
                                        (find-class 'standard-effective-slot-definition)
                                        slotd)
                               do (setf (slot-definition-location s) i
                                        (gethash name location-table) i
                                        (gethash name table) s)
                               collect s)))
      (setf (class-slots class) effective-slots
            (class-direct-slots class) direct-slots
            (class-size class) (length slots)
            (slot-table class) table
            (class-location-table class) location-table))))

;; 1) Create the classes
;;
;; Notice that, due to circularity in the definition, STANDARD-CLASS has
;; itself as metaclass. MAKE-EMPTY-STANDARD-CLASS takes care of that.
;;
(let* ((class-hierarchy '#.+class-hierarchy+))
  (let ((all-classes (loop for c in class-hierarchy
                        for class = (apply #'make-empty-standard-class c)
                        collect class)))
    (defconstant +the-t-class+ (find-class 't nil))
    (defconstant +the-class+ (find-class 'class nil))
    (defconstant +the-std-class+ (find-class 'std-class nil))
    (defconstant +the-funcallable-standard-class+
      (find-class 'funcallable-standard-class nil))
    ;;
    ;; 2) Class T had its metaclass wrong. Fix it.
    ;;
    (si:instance-class-set (find-class 't) (find-class 'built-in-class))
    ;;
    ;; 3) Finalize
    ;;
    (mapc #'si::instance-sig-set all-classes)
    ;;
    ;; 4) This is needed for further optimization
    ;;
    (setf (slot-value (find-class 'method-combination) 'sealedp) t)
    ;;
    ;; 5) This is needed so that slot-definition objects are not marked
    ;;    obsolete and need to be updated
    ;;
    (with-early-accessors (+standard-class-slots+)
      (loop for c in all-classes
         do (loop for s in (class-direct-slots c)
               do (si::instance-sig-set s))
         do (loop for s in (class-slots c)
               do (si::instance-sig-set s))))
    ))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/boot.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/cpl.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; ORDERING OF CLASSES
;;;
;;; We have two implementations of the algorithm described in Sect. 4.3.5
;;; of the Common Lisp Hyperspec. The first implementation is a literal
;;; transcription of that algorithm. The second implementation does not
;;; create the list of pairs for describing the order, it is not recursive
;;; and conses less
#+(or)
(defun compute-clos-class-precedence-list (new-class superclasses)
  (labels ((pair-list (l)
             (if (or (null l) (endp (cdr l)))
                 nil
                 (cons (cons (first l) (second l))
                       (pair-list (rest l)))))
           (walk-supers (parent superclasses class-list precedence-alist)
             (let ((new-alist (pair-list (if parent
                                             (list* parent superclasses)
                                             superclasses))))
               (setf precedence-alist (nconc new-alist precedence-alist)
                     class-list (union superclasses class-list)))
             (dolist (c superclasses)
               (multiple-value-setq (class-list precedence-alist)
                 (walk-supers c (class-direct-superclasses c) class-list precedence-alist)))
             (values class-list precedence-alist))
           (cycle-error (new-class)
             (error "A cycle has been detected in the class precedence list for ~A."
                    (class-name new-class)))
           (free-elements (class-list precedence-alist)
             (set-difference class-list
                             (delete-duplicates (mapcar #'cdr precedence-alist))))
           (next-element (free-list cpl)
             (if (or (null cpl) (endp free-list) (endp (rest free-list)))
                 (first free-list)
                 (dolist (i cpl nil)
                   (dolist (j (class-direct-superclasses i))
                     (when (member j free-list)
                       (return-from next-element j)))))))
  (if (endp (rest superclasses))
      (let ((class (first superclasses)))
        (list* new-class (class-precedence-list class)))
      (multiple-value-bind (class-list precedence-alist)
          (walk-supers nil superclasses nil nil)
          (do ((cpl (list new-class)))
              ((null class-list)
               (if precedence-alist (cycle-error new-class) (nreverse cpl)))
            (let* ((candidates (free-elements class-list precedence-alist))
                   (next (next-element candidates cpl)))
              (unless next
                (cycle-error new-class))
              (setf precedence-alist (delete next precedence-alist :key #'car)
                    class-list (delete next class-list)
                    cpl (cons next cpl))))))))

(defun compute-clos-class-precedence-list (new-class superclasses)
  (labels ((walk-supers (superclasses)
             ;; Creates two lists, one with all the superclasses of a class to be created,
             ;; and a second list with lists (c1 c2 c3 ... cn) that represent a partial
             ;; ordering of the classes (c1 > c2), (c2 > c3), etc."
             (let ((class-list '())
                   (precedence-lists (list superclasses)))
               (loop (unless superclasses
                       (return (values class-list precedence-lists)))
                  (let ((next-class (pop superclasses)))
                    (unless (member next-class class-list :test 'eql)
                      (let ((more-classes (slot-value next-class 'direct-superclasses)))
                        (setf class-list (list* next-class class-list)
                              precedence-lists (list* (list* next-class more-classes)
                                                      precedence-lists)
                              superclasses (append more-classes superclasses))))))))
           (cycle-error (class)
             (error "A cycle has been detected in the class precedence list for ~A."
                    (class-name class)))
           (has-no-precedent (class precedence-lists)
             ;; Check if CLASS is not preceded by any other class in the partial order.
             (dolist (partial-order precedence-lists t)
               (when (member class (rest partial-order) :test 'eql)
                 (return nil))))
           (free-elements (class-list precedence-lists)
             ;; Return classes that are not preceded by anyone
             (let ((output '()))
               (dolist (class class-list)
                 (when (has-no-precedent class precedence-lists)
                   (push class output)))
               output))
           (next-element (free-list cpl)
             ;; Compute the next element that we will add to the class precedence list.
             (if (or (null cpl) (endp free-list) (endp (rest free-list)))
                 (first free-list)
                 (dolist (i cpl nil)
                   (dolist (j (slot-value i 'direct-superclasses))
                     (when (member j free-list :test 'eql)
                       (return-from next-element j))))))
           (delete-class (class precedence-lists)
             (do ((l precedence-lists (rest l)))
                 ((null l)
                  (delete nil precedence-lists))
               (let ((one-list (first l)))
                 (when (eq class (first one-list))
                   (setf (first l) (rest one-list)))))))
    (cond ((null superclasses)
           (list new-class))
          ((endp (rest superclasses))
           (let ((class (first superclasses)))
             (list* new-class (slot-value class 'precedence-list))))
          (t
           (multiple-value-bind (class-list precedence-lists)
               (walk-supers superclasses)
             (do ((cpl (list new-class)))
                 ((null class-list)
                  (if precedence-lists (cycle-error new-class) (nreverse cpl)))
               (let* ((candidates (free-elements class-list precedence-lists))
                      (next (next-element candidates cpl)))
                 (unless next
                   (cycle-error new-class))
                 (setf precedence-lists (delete-class next precedence-lists)
                       class-list (delete next class-list)
                       cpl (cons next cpl)))))))))

;;; ----------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/cpl.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/print.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; Load forms
;;;
;;; ECL extends the ANSI specification by allowing to use
;;; MAKE-LOAD-FORM on almost any kind of lisp object.
;;;

(defun make-load-form-saving-slots (object &key slot-names environment)
  (declare (ignore environment))
  (do* ((class (class-of object))
        (initialization (list 'progn))
        (slots (class-slots class) (cdr slots)))
      ((endp slots)
       (values `(allocate-instance ,class) (nreverse initialization)))
    (let* ((slot (first slots))
           (slot-name (slot-definition-name slot)))
      (when (or (and (null slot-names)
                     (eq (slot-definition-allocation slot) :instance))
                (member slot-name slot-names))
        (push (if (slot-boundp object slot-name)
                  `(setf (slot-value ,object ',slot-name)
                         ',(slot-value object slot-name))
                  `(slot-makunbound ,object ',slot-name))
              initialization)))))

(defun need-to-make-load-form-p (object env)
  "Return T if the object cannot be externalized using the lisp
printer and we should rather use MAKE-LOAD-FORM."
  (declare (ignore env))
  (let ((*load-form-cache* nil))
    (declare (special *load-form-cache*))
    (labels ((recursive-test (object)
               (loop
                ;; For simple, atomic objects we just return NIL. There is no need to
                ;; call MAKE-LOAD-FORM on them
                (when (typep object '(or character number symbol pathname string bit-vector))
                  (return nil))
                ;; For complex objects we set up a cache and run through the
                ;; objects content looking for data that might require
                ;; MAKE-LOAD-FORM to be externalized.  The cache is used to
                ;; solve the problem of circularity and of EQ references.
                (unless *load-form-cache*
                  (setf *load-form-cache* (make-hash-table :size 128 :test #'eq)))
                (when (gethash object *load-form-cache*)
                  (return nil))
                (setf (gethash object *load-form-cache*) t)
                (cond ((arrayp object)
                       (unless (subtypep (array-element-type object) '(or character number))
                         (dotimes (i (array-total-size object))
                           (recursive-test (row-major-aref object i))))
                       (return nil))
                      ((consp object)
                       (recursive-test (car object))
                       (setf object (rest object)))
                      ((compiled-function-p object)
                       (multiple-value-bind (lex code data name)
                           (si::bc-split object)
                         (when (or (null data)
                                   (null code)
                                   (recursive-test lex)
                                   (recursive-test code)
                                   (recursive-test name))
                           (throw 'need-to-make-load-form t))
                         (setf object data)))
                      (t
                       (throw 'need-to-make-load-form t))))))
      (catch 'need-to-make-load-form
        (recursive-test object)
        nil))))

(defmethod make-load-form ((object t) &optional env)
  (flet ((maybe-quote (object)
           (if (or (consp object) (symbolp object))
               (list 'quote object)
               object)))
    (unless (need-to-make-load-form-p object env)
      (return-from make-load-form (maybe-quote object)))
    (typecase object
      (compiled-function
       (multiple-value-bind (lex code data name)
           (si::bc-split object)
         (unless code
           (error "Cannot externalize object ~a" object))
         (values `(si::bc-join ,(make-load-form lex env)
                               ',code ; An specialized array, no load form
                               ,(make-load-form data env)
                               ,(make-load-form name env)))))
      (array
       (let ((init-forms '()))
         (values `(make-array ',(array-dimensions object)
                   :element-type ',(array-element-type object)
                   :adjustable ',(adjustable-array-p object)
                   :initial-contents
                   ',(loop for i from 0 below (array-total-size object)
                           collect (let ((x (row-major-aref object i)))
                                     (if (need-to-make-load-form-p x env)
                                         (progn (push `(setf (row-major-aref ,object ,i) ',x)
                                                      init-forms)
                                                0)
                                         x))))
                 (and init-forms `(progn ,@init-forms)))))
      (cons
       (values `(cons ,(maybe-quote (car object)) nil)
               (and (rest object) `(rplacd ,(maybe-quote object)
                                           ,(maybe-quote (cdr object))))))
      (hash-table
       (let* ((content (ext:hash-table-content object))
              (make-form `(make-hash-table
                           :size ,(hash-table-size object)
                           :rehash-size ,(hash-table-rehash-size object)
                           :rehash-threshold ,(hash-table-rehash-threshold object)
                           :test ',(hash-table-test object))))
         (if (need-to-make-load-form-p content env)
             (values
              make-form
              `(dolist (i ',(loop for key being each hash-key in object
                               using (hash-value obj)
                               collect (cons key obj)))
                 (setf (gethash (car i) ,object) (cdr i))))
             (values
              `(ext:hash-table-fill ,make-form ',content)
              nil))))
      (random-state
       (let ((state (ext:random-state-array object)))
         (values `(make-random-state ,state) nil)))
      (t
       (no-make-load-form object)))))

(defmethod make-load-form ((object standard-object) &optional environment)
  (no-make-load-form object))

(defmethod make-load-form ((object structure-object) &optional environment)
  (no-make-load-form object))

(defmethod make-load-form ((object condition) &optional environment)
  (no-make-load-form object))

(defun no-make-load-form (object)
  (declare (si::c-local))
  (error "No adequate specialization of MAKE-LOAD-FORM for an object type ~A"
         (type-of object)))

(defmethod make-load-form ((class class) &optional environment)
  (declare (ignore environment))
  (let ((name (class-name class)))
    (if (and name (eq (find-class name) class))
        `(find-class ',name)
        (error "Cannot externalize anonymous class ~A" class))))

(defmethod make-load-form ((package package) &optional environment)
  (declare (ignore environment))
  `(find-package ,(package-name package)))

;;; ----------------------------------------------------------------------
;;; Printing
;;; ----------------------------------------------------------------------

(defmethod print-object ((instance t) stream)
  (let ((*package* (find-package "CL")))
    (print-unreadable-object (instance stream)
      (format stream "~S"
              (class-name (si:instance-class instance)))))
  instance)

(defmethod print-object ((instance standard-object) stream)
  (print-unreadable-object (instance stream)
    (let ((*package* (find-package "CL")))
      (format stream "a ~S"
              (class-name (si:instance-class instance)))))
  instance)

(defmethod print-object ((class class) stream)
  (print-unreadable-object (class stream)
    (let ((*package* (find-package "CL")))
      (format stream "The ~S ~S"
              (class-name (si:instance-class class)) (class-name class))))
  class)

(defmethod print-object ((gf standard-generic-function) stream)
  (print-unreadable-object (gf stream :type t)
    (prin1 (generic-function-name gf) stream))
  gf)

(defmethod print-object ((m standard-method) stream)
  (print-unreadable-object (m stream :type t)
    (format stream "~A ~{~S ~}~S"
	    (let ((gf (method-generic-function m)))
	      (if gf
		  (generic-function-name gf)
		  'UNNAMED))
            (method-qualifiers m)
	    (loop for spec in (method-specializers m)
                  collect (cond ((and (classp spec)
                                      (class-name spec)))
                                ((typep spec 'eql-specializer)
                                 `(eql ,(eql-specializer-object spec)))
                                (t spec)))))
  m)

(defun ext::float-nan-string (x)
  (unless (ext:float-nan-p x)
    (signal 'type-error :datum x :expected-type 'float-nan))

  (cond
    ((null *print-readably*)
     (etypecase x
       (single-float "#<single-float quiet NaN>")
       (double-float "#<double-float quiet NaN>")
       (long-float   "#<long-float quiet NaN>")
       (short-float  "#<short-float quiet NaN>")))
    #+ieee-floating-point
    (*read-eval*
     (etypecase x
       (single-float "#.(coerce (si:nan) 'single-float)")
       (double-float "#.(coerce (si:nan) 'double-float)")
       (long-float   "#.(coerce (si:nan) 'long-float)")
       (short-float  "#.(coerce (si:nan) 'short-float)")))
    (t (error 'print-not-readable :object x))))

(defun ext::float-infinity-string (x)
  (unless (ext:float-infinity-p x)
    (signal 'type-error :datum x :expected-type 'float-infinity))

  (cond
    ((null *print-readably*)
     (etypecase x
       (ext:negative-single-float "#<single-float negative infinity>")
       (ext:positive-single-float "#<single-float positive infinity>")
       (ext:negative-double-float "#<double-float negative infinity>")
       (ext:positive-double-float "#<double-float positive infinity>")
       (ext:negative-long-float   "#<long-float negative infinity>")
       (ext:positive-long-float   "#<long-float positive infinity>")
       (ext:negative-short-float  "#<short-float negative infinity>")
       (ext:positive-short-float  "#<short-float positive infinity>")))
    #+ieee-floating-point
    (*read-eval*
     (etypecase x
       (ext:negative-single-float "#.ext::single-float-negative-infinity")
       (ext:positive-single-float "#.ext::single-float-positive-infinity")
       (ext:negative-double-float "#.ext::double-float-negative-infinity")
       (ext:positive-double-float "#.ext::double-float-positive-infinity")
       (ext:negative-long-float   "#.ext::long-float-negative-infinity")
       (ext:positive-long-float   "#.ext::long-float-positive-infinity")
       (ext:negative-short-float  "#.ext::short-float-negative-infinity")
       (ext:positive-short-float  "#.ext::short-float-positive-infinity")))
    (t (error 'print-not-readable :object x))))

;;; ----------------------------------------------------------------------
;;; Describe
;;; ----------------------------------------------------------------------

(defmethod describe-object ((obj t) (stream t))
  (let* ((class (class-of obj))
         (slotds (class-slots class)))
    (format stream "~%~A is an instance of class ~A"
            obj (class-name class))
    (do ((scan slotds (cdr scan))
         (i 0 (1+ i))
         (sv))
        ((null scan))
        (declare (fixnum i))
        (setq sv (si:instance-ref obj i))
        (print (slot-definition-name (car scan)) stream) (princ ":      " stream)
        (if (si:sl-boundp sv)
            (prin1 sv stream)
          (prin1 "Unbound" stream))))
  obj)

(defmethod describe-object ((obj class) (stream t))
  (let* ((class  (si:instance-class obj))
         (slotds (class-slots class)))
    (format stream "~%~A is an instance of class ~A"
            obj (class-name class))
    (do ((scan slotds (cdr scan))
         (i 0 (1+ i))
         (sv))
        ((null scan))
        (declare (fixnum i))
        (print (slot-definition-name (car scan)) stream) (princ ":      " stream)
        (case (slot-definition-name (car scan))
              ((superiors inferiors)
               (princ "(" stream)
               (do* ((scan (si:instance-ref obj i) (cdr scan))
                     (e (car scan) (car scan)))
                    ((null scan))
                    (prin1 (class-name e) stream)
                    (when (cdr scan) (princ " " stream)))
               (princ ")" stream))
              (otherwise 
               (setq sv (si:instance-ref obj i))
               (if (si:sl-boundp sv)
                   (prin1 sv stream)
                 (prin1 "Unbound" stream))))))
  obj)

;; ----------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/print.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/standard.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; INSTANCES INITIALIZATION AND REINITIALIZATION
;;;

(defmethod initialize-instance ((instance T) &rest initargs)
  (apply #'shared-initialize instance 'T initargs))

(defmethod reinitialize-instance ((instance T) &rest initargs)
  (check-initargs (class-of instance) initargs
                  (valid-keywords-from-methods
                   (compute-applicable-methods
                    #'reinitialize-instance (list instance))
                   (compute-applicable-methods
                    #'shared-initialize (list instance t))))
  (apply #'shared-initialize instance '() initargs))

(defmethod shared-initialize ((instance T) slot-names &rest initargs)
  ;;
  ;; initialize the instance's slots is a two step process
  ;;   1 A slot for which one of the initargs in initargs can set
  ;;      the slot, should be set by that initarg.  If more than
  ;;      one initarg in initargs can set the slot, the leftmost
  ;;      one should set it.
  ;;
  ;;   2 Any slot not set by step 1, may be set from its initform
  ;;      by step 2.  Only those slots specified by the slot-names
  ;;      argument are set.  If slot-names is:
  ;;       T
  ;;            any slot not set in step 1 is set from its
  ;;            initform
  ;;       <list of slot names>
  ;;            any slot in the list, and not set in step 1
  ;;            is set from its initform
  ;;
  ;;       ()
  ;;            no slots are set from initforms
  ;;
  (let* ((class (class-of instance)))
    ;; initialize-instance slots
    (dolist (slotd (class-slots class))
      (let* ((slot-initargs (slot-definition-initargs slotd))
             (slot-name (slot-definition-name slotd)))
        (or
         ;; Try to initialize the slot from one of the initargs.
         (do ((l initargs) initarg val)
             ((null l) nil)
           (setf initarg (pop l))
           (when (endp l)
             (simple-program-error "Wrong number of keyword arguments for SHARED-INITIALIZE, ~A"
                                   initargs))
           (unless (symbolp initarg)
             (simple-program-error "Not a valid initarg: ~A" initarg))
           (setf val (pop l))
           (when (member initarg slot-initargs :test #'eq)
             (setf (slot-value instance slot-name) val)
             (return t)))
         ;; Try to initialize the slot from its initform.
         (when (and slot-names
                    (or (eq slot-names 'T)
                        (member slot-name slot-names))
                    (not (slot-boundp instance slot-name)))
           (let ((initfun (slot-definition-initfunction slotd)))
             (when initfun
               (setf (slot-value instance slot-name) (funcall initfun))))))
        )))
  instance)

;;; ----------------------------------------------------------------------
;;; CLASSES INITIALIZATION AND REINITIALIZATION
;;;

(defun compute-instance-size (slots)
  (loop for slotd in slots
     with last-location = 0
     with num-slots = 0
     when (eq (slot-definition-allocation slotd) :instance)
     do (let ((new-loc (safe-slot-definition-location slotd)))
          (incf num-slots)
          (when (and new-loc (> new-loc last-location))
            (setf last-location new-loc)))
     finally (return (max num-slots (1+ last-location)))))

(defmethod allocate-instance ((class class) &rest initargs)
  (declare (ignore initargs))
  ;; FIXME! Inefficient! We should keep a list of dependent classes.
  (unless (class-finalized-p class)
    (finalize-inheritance class))
  (let ((x (si::allocate-raw-instance nil class (class-size class))))
    (si::instance-sig-set x)
    x))

(defmethod make-instance ((class class) &rest initargs)
  ;; Without finalization we can not find initargs.
  (unless (class-finalized-p class)
    (finalize-inheritance class))
  ;; We add the default-initargs first, because one of these initargs might
  ;; be (:allow-other-keys t), which disables the checking of the arguments.
  ;; (Paul Dietz's ANSI test suite, test CLASS-24.4)
  (setf initargs (add-default-initargs class initargs))
  (let ((keywords (if (slot-boundp class 'valid-initargs)
                      (class-valid-initargs class)
                      (precompute-valid-initarg-keywords class))))
    (check-initargs class initargs nil (class-slots class) keywords))
  (let ((instance (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance instance initargs)
    instance))

(defun delete-keyword (keyword list)
  (loop until (eq (getf list keyword list) list)
     do (remf list keyword))
  list)

(defun add-default-initargs (class initargs)
  (declare (si::c-local))
  ;; Here, for each slot which is not mentioned in the initialization
  ;; arguments, but which has a value associated with :DEFAULT-INITARGS,
  ;; we compute the value and add it to the list of initargs.
  (let ((output '()))
    (dolist (scan (class-default-initargs class))
      (let* ((initarg (first scan))
             (value (third scan))
             (supplied-value (si::search-keyword initargs initarg)))
        (when (or (eq supplied-value '+initform-unsupplied+)
                  (eq supplied-value 'si::missing-keyword))
          (when (eq supplied-value '+initform-unsupplied+)
            (setf initargs (delete-keyword initarg initargs)))
          (setf output (list* (funcall value) initarg output)))))
    (if output
        (append initargs (nreverse output))
        initargs)))

(defmethod direct-slot-definition-class ((class T) &rest canonicalized-slot)
  (declare (ignore class canonicalized-slot))
  (find-class 'standard-direct-slot-definition nil))

(defmethod effective-slot-definition-class ((class T) &rest canonicalized-slot)
  (declare (ignore class canonicalized-slot))
  (find-class 'standard-effective-slot-definition nil))

(defun has-forward-referenced-parents (class)
  (or (forward-referenced-class-p class)
      (and (not (class-finalized-p class))
           (some #'has-forward-referenced-parents
                 (class-direct-superclasses class)))))

(defun finalize-unless-forward (class)
  (unless (find-if #'has-forward-referenced-parents (class-direct-superclasses class))
    (finalize-inheritance class)))

(defmethod initialize-instance ((class class) &rest initargs &key direct-slots direct-superclasses)
  (declare (ignore sealedp))
  ;; convert the slots from lists to direct slots
  (apply #'call-next-method class
         :direct-slots
         (loop for s in direct-slots
            collect (canonical-slot-to-direct-slot class s))
         :direct-superclasses
         direct-superclasses
         initargs)
  (finalize-unless-forward class)
  class)

(defmethod shared-initialize ((class class) slot-names &rest initargs
                              &key (direct-superclasses nil direct-superclasses-p))
  (if direct-superclasses-p
      ;; verify that the inheritance list makes sense
      (let* ((class (apply #'call-next-method class slot-names
                           :direct-superclasses
                           (if (slot-boundp class 'direct-superclasses)
                               (slot-value class 'direct-superclasses)
                               nil)
                           initargs))
             (direct-superclasses (check-direct-superclasses class direct-superclasses)))
        (loop for c in (class-direct-superclasses class)
           unless (member c direct-superclasses :test #'eq)
           do (remove-direct-subclass c class))
        (setf (class-direct-superclasses class) direct-superclasses)
        (loop for c in direct-superclasses
           do (add-direct-subclass c class))
        class)
      (apply #'call-next-method class slot-names initargs)))

(defun precompute-valid-initarg-keywords (class)
  (setf (class-valid-initargs class)
        (loop with methods = (nconc
                              (compute-applicable-methods
                               #'allocate-instance (list class))
                              (compute-applicable-methods
                               #'initialize-instance (list (class-prototype class)))
                              (compute-applicable-methods
                               #'shared-initialize (list (class-prototype class) t)))
           for m in methods
           for k = (method-keywords m)
           when (eq k t)
           return t
           append k)))

(defun update-dependents (object initargs)
  (when *clos-booted*
    (map-dependents
     object
     #'(lambda (dep) (apply #'update-dependent object dep initargs)))))

(defmethod shared-initialize ((class std-class) slot-names &rest initargs &key
                              (optimize-slot-access (list *optimize-slot-access*))
                              sealedp)
  (declare (ignore initargs slot-names))
  (setf (slot-value class 'optimize-slot-access) (first optimize-slot-access)
        (slot-value class 'sealedp) (and sealedp t))
  (setf class (call-next-method))
  (update-dependents class initargs)
  class)

(defmethod add-direct-subclass ((parent class) child)
  (pushnew child (class-direct-subclasses parent)))

(defmethod remove-direct-subclass ((parent class) child)
  (setf (class-direct-subclasses parent)
        (remove child (class-direct-subclasses parent))))

(defun check-direct-superclasses (class supplied-superclasses)
  (if supplied-superclasses
      (loop for superclass in supplied-superclasses
         ;; Until we process streams.lsp there are some invalid combinations
         ;; using built-in-class, which here we simply ignore.
         unless (or (validate-superclass class superclass)
                    (not (eq *clos-booted* T)))
         do (error "Class ~A is not a valid superclass for ~A" superclass class))
      (setf supplied-superclasses
            (list (find-class (typecase class
                                (STANDARD-CLASS 'STANDARD-OBJECT)
                                (STRUCTURE-CLASS 'STRUCTURE-OBJECT)
                                (FUNCALLABLE-STANDARD-CLASS 'FUNCALLABLE-STANDARD-OBJECT)
                                (otherwise (error "No :DIRECT-SUPERCLASS ~
argument was supplied for metaclass ~S." (class-of class))))))))
  ;; FIXME!!! Here should come the invocation of VALIDATE-SUPERCLASS!
  ;; FIXME!!! We should check that structures and standard objects are
  ;; not mixed, and that STANDARD-CLASS, or STANDARD-GENERIC-FUNCTION,
  ;; etc, are the first classes.
  supplied-superclasses)

(defmethod validate-superclass ((class class) (superclass class))
  (or (eq superclass +the-t-class+)
      (let ((c1 (class-of class))
            (c2 (class-of superclass)))
        (or (eq c1 c2)
            (and (eq c1 +the-standard-class+) (eq c2 +the-funcallable-standard-class+))
            (and (eq c2 +the-standard-class+) (eq c1 +the-funcallable-standard-class+))
            ))
      (forward-referenced-class-p superclass)
      ))

;;; ----------------------------------------------------------------------
;;; FINALIZATION OF CLASS INHERITANCE
;;;
(defun forward-referenced-class-p (x)
  (let ((y (find-class 'FORWARD-REFERENCED-CLASS nil)))
    (and y (si::subclassp (class-of x) y))))

(defmethod finalize-inheritance ((class class))
  ;; FINALIZE-INHERITANCE computes the guts of what defines a class: the
  ;; slots, the list of parent class, etc. It is called when either the
  ;; class was not finalized before, or when one of the parents has been
  ;; modified.
  ;;
  (let ((cpl (compute-class-precedence-list class)))
    ;; A class cannot be finalized if any of its parents is either
    ;; a not yet defined class or it has not yet been finalized.
    ;; In the first case we can just signal an error...
    ;;
    (let ((x (find-if #'forward-referenced-class-p (rest cpl))))
      (when x
        (error "Cannot finish building the class~%  ~A~%~
because it contains a reference to the undefined class~%  ~A"
               (class-name class) (class-name x))))
    ;;
    ;; ... and in the second case we just finalize the top-most class
    ;; which is not yet finalized and rely on the fact that this
    ;; class will also try to finalize all of its children.
    ;;
    (let ((x (find-if-not #'class-finalized-p cpl :from-end t)))
      (unless (or (null x) (eq x class))
        (return-from finalize-inheritance
          (finalize-inheritance x))))
    (setf (class-precedence-list class) cpl)
    (let ((slots (compute-slots class)))
      (setf (class-slots class) slots
            (class-size class) (compute-instance-size slots)
            (class-default-initargs class) (compute-default-initargs class)
            (class-finalized-p class) t))
    ;;
    ;; When a class is sealed we rewrite the list of direct slots to fix
    ;; their locations. This may imply adding _new_ direct slots.
    ;;
    (when (class-sealedp class)
      (let* ((free-slots (delete-duplicates (mapcar #'slot-definition-name (class-slots class))))
             (all-slots (class-slots class)))
        ;;
        ;; We first search all slots that belonged to unsealed classes and which
        ;; therefore have no fixed position.
        ;;
        (loop for c in cpl
           do (loop for slotd in (class-direct-slots c)
                 when (safe-slot-definition-location slotd)
                 do (setf free-slots (delete (slot-definition-name slotd) free-slots))))
        ;;
        ;; We now copy the locations of the effective slots in this class to
        ;; the class direct slots.
        ;;
        (loop for slotd in (class-direct-slots class)
           do (let* ((name (slot-definition-name slotd))
                     (other-slotd (find name all-slots :key #'slot-definition-name)))
                (setf (slot-definition-location slotd)
                      (slot-definition-location other-slotd)
                      free-slots (delete name free-slots))))
        ;;
        ;; And finally we add one direct slot for each inherited slot that did
        ;; not have a fixed location.
        ;;
        (loop for name in free-slots
           with direct-slots = (class-direct-slots class)
           do (let* ((effective-slotd (find name all-slots :key #'slot-definition-name))
                     (def (direct-slot-to-canonical-slot effective-slotd)))
                (push (apply #'make-instance (direct-slot-definition-class class def)
                             def)
                      direct-slots))
           finally (setf (class-direct-slots class) direct-slots))))
    ;;
    ;; This is not really needed, because when we modify the list of slots
    ;; all instances automatically become obsolete (See change.lsp)
    ;(make-instances-obsolete class)
    ;;
    ;; But this is really needed: we have to clear the different type caches
    ;; for type comparisons and so on.
    ;;
    (si::subtypep-clear-cache)
    )
  ;; As mentioned above, when a parent is finalized, it is responsible for
  ;; invoking FINALIZE-INHERITANCE on all of its children. Obviously,
  ;; this only makes sense when the class has been defined.
  (dolist (subclass (reverse (class-direct-subclasses class)))
    (finalize-unless-forward subclass))
  ;;
  ;; We create various caches to more rapidly find the slot locations and
  ;; slot definitions.
  (std-create-slots-table class)
  )

(defmethod finalize-inheritance ((class std-class))
  (call-next-method)
  (std-class-generate-accessors class))

(defmethod compute-class-precedence-list ((class class))
  (compute-clos-class-precedence-list class (class-direct-superclasses class)))

(eval-when (:compile-toplevel :execute)
  (defmacro mapappend (fun &rest args)
    `(reduce #'append (mapcar ,fun ,@args))))

(defmethod compute-slots ((class class))
  ;; INV: for some classes ECL expects that the order of the inherited slots is
  ;; preserved. The following code ensures that, if C1 is after C2 in the
  ;; class precedence list, and the slot S1 appears both in C1 and C2,
  ;; the slot S1 will appear the new class before the slots of C2; and
  ;; whenever possible, in the same position as in C1.
  ;;
  (do* ((all-slots (mapappend #'class-direct-slots (reverse (class-precedence-list class))))
        (all-names (nreverse (mapcar #'slot-definition-name all-slots)))
        (output '())
        (scan all-names (cdr scan)))
       ((endp scan) output)
    (let ((name (first scan)))
      (unless (find name (rest scan))
        (push (compute-effective-slot-definition
               class name (delete name (reverse all-slots) :key #'slot-definition-name
                                  :test-not #'eq))
              output)))))

(defun slot-definition-to-plist (slotd)
  (list :name (slot-definition-name slotd)
        :initform (slot-definition-initform slotd)
        :initfunction (slot-definition-initfunction slotd)
        :type (slot-definition-type slotd)
        :allocation (slot-definition-allocation slotd)
        :initargs (slot-definition-initargs slotd)
        :readers (slot-definition-readers slotd)
        :writers (slot-definition-writers slotd)
        :documentation (slot-definition-documentation slotd)
        :location (slot-definition-location slotd)))

(defun safe-slot-definition-location (slotd &optional default)
  (if (or (listp slotd) (slot-boundp slotd 'location))
      (slot-definition-location slotd)
      default))

(defmethod compute-effective-slot-definition ((class class) name direct-slots)
  (flet ((direct-to-effective (old-slot)
           (if (consp old-slot)
               (copy-list old-slot)
               (let ((initargs (slot-definition-to-plist old-slot)))
                 (apply #'make-instance
                        (apply #'effective-slot-definition-class class initargs)
                        initargs))))
         (combine-slotds (new-slotd old-slotd)
           (let* ((new-type (slot-definition-type new-slotd))
                  (old-type (slot-definition-type old-slotd))
                  (loc1 (safe-slot-definition-location new-slotd))
                  (loc2 (safe-slot-definition-location old-slotd)))
             (when loc2
               (if loc1
                   (unless (eql loc1 loc2)
                     (error 'simple-error
                            :format-control "You have specified two conflicting slot locations:~%~D and ~F~%for slot ~A"
                            :format-arguments (list loc1 loc2 name)))
                   (progn
                     #+(or)
                     (format t "~%Assigning a default location ~D for ~A in ~A."
                             loc2 name (class-name class))
                     (setf (slot-definition-location new-slotd) loc2))))
             (setf (slot-definition-initargs new-slotd)
                   (union (slot-definition-initargs new-slotd)
                          (slot-definition-initargs old-slotd)))
             (unless (slot-definition-initfunction new-slotd)
               (setf (slot-definition-initform new-slotd)
                     (slot-definition-initform old-slotd)
                     (slot-definition-initfunction new-slotd)
                     (slot-definition-initfunction old-slotd)))
             (setf (slot-definition-readers new-slotd)
                   (union (slot-definition-readers new-slotd)
                          (slot-definition-readers old-slotd))
                   (slot-definition-writers new-slotd)
                   (union (slot-definition-writers new-slotd)
                          (slot-definition-writers old-slotd))
                   (slot-definition-type new-slotd)
                   ;; FIXME! we should be more smart then this:
                   (cond ((subtypep new-type old-type) new-type)
                         ((subtypep old-type new-type) old-type)
                         (T `(and ,new-type ,old-type))))
             new-slotd)))
    (reduce #'combine-slotds (rest direct-slots)
            :initial-value (direct-to-effective (first direct-slots)))))

(defmethod compute-default-initargs ((class class))
  (let ((all-initargs (mapappend #'class-direct-default-initargs
                                 (class-precedence-list class))))
    ;; We have to use this trick because REMOVE-DUPLICATES on
    ;; ((:foo x) (:faa y) (:foo z)) would produce ((:faa y) (:foo z))
    ;; and we want ((:foo x) (:faa y))
    (nreverse (remove-duplicates (reverse all-initargs) :key #'first))))

;;; ======================================================================
;;; STANDARD-CLASS specializations
;;;
;;; IMPORTANT: The following implementation of ENSURE-CLASS-USING-CLASS is
;;; shared by the metaclasses STANDARD-CLASS and STRUCTURE-CLASS.
;;;
(defmethod ensure-class-using-class ((class class) name &rest rest
                                     &key direct-slots direct-default-initargs)
  (declare (ignore direct-default-initargs direct-slots))
  (multiple-value-bind (metaclass direct-superclasses options)
      (apply #'help-ensure-class rest)
    (declare (ignore direct-superclasses))
    (cond ((forward-referenced-class-p class)
           (change-class class metaclass))
          ((not (eq (class-of class) metaclass))
           (error "When redefining a class, the metaclass can not change.")))
    (setf class (apply #'reinitialize-instance class :name name options))
    (when name
      (si:create-type-name name)
      (setf (find-class name) class))
    class))

(defun coerce-to-class (class-or-symbol &optional (fail nil))
  (cond ((si:instancep class-or-symbol) class-or-symbol)
        ((not (symbolp class-or-symbol))
         (error "~a is not a valid class specifier." class-or-symbol))
        ((find-class class-or-symbol fail))
        (t
         (warn 'si::simple-style-warning
               :format-control "Class ~A has been forward referenced."
               :format-arguments (list class-or-symbol))
         (ensure-class class-or-symbol
                       :metaclass 'forward-referenced-class
                       :direct-superclasses (list (find-class 'standard-object))
                       :direct-slots '()))))

(defun help-ensure-class (&rest options
                          &key (metaclass 'standard-class) direct-superclasses
                          &allow-other-keys)
  (remf options :metaclass)
  (remf options :direct-superclasses)
  (setf metaclass (coerce-to-class metaclass t)
        direct-superclasses (mapcar #'coerce-to-class direct-superclasses))
  (values metaclass direct-superclasses
          (list* :direct-superclasses direct-superclasses options)))

;;; ----------------------------------------------------------------------
;;; Around methods for COMPUTE-SLOTS which assign locations to each slot.
;;;

(defun class-compute-slots (class slots)
  ;; This an ECL extension. We are allowed to specify the location of
  ;; a direct slot. Consequently we have to first sort the ones which
  ;; have been predefined and then assign locations _after_ the last
  ;; assigned slot. Note the generalized comparison, which pushes all
  ;; slots without a defined location to the end of the list.
  (let* ((size (compute-instance-size slots))
         (instance-slots (remove :instance slots :key #'slot-definition-allocation
                                                 :test-not #'eq))
         (numbered-slots (remove-if-not #'safe-slot-definition-location instance-slots))
         (other-slots (remove-if #'safe-slot-definition-location instance-slots))
         (aux (make-array size :element-type 't :adjustable nil :initial-element nil)))
    (loop for i in numbered-slots
       do (let ((loc (slot-definition-location i)))
            (when (aref aux loc)
              (error 'simple-error
                     :format-control "Slots ~A and ~A are said to have the same location in class ~A."
                     :format-ars (list (aref aux loc) i class)))
            (setf (aref aux loc) i)))
    (loop for i in other-slots
       with index = 0
       do (loop while (aref aux index)
               do (incf index)
               finally (setf (aref aux index) i
                             (slot-definition-location i) index)))
    slots))

(defmethod compute-slots :around ((class class))
  (class-compute-slots class (call-next-method)))

(defun std-class-compute-slots (class slots)
  (declare (si::c-local))
  (let* ((direct-slots (class-direct-slots class)))
    (dolist (slotd slots)
      (let* ((name (slot-definition-name slotd))
             (allocation (slot-definition-allocation slotd)))
        (cond ((not (eq (slot-definition-allocation slotd) :class)))
              ((find name direct-slots :key #'slot-definition-name) ; new shared slot
               (let* ((initfunc (slot-definition-initfunction slotd))
                      (value (if initfunc (funcall initfunc) (unbound))))
                 (setf (slot-definition-location slotd) (list value))))
              (t                        ; inherited shared slot
               (dolist (c (class-precedence-list class))
                 (unless (eql c class)
                   (let ((other (find (slot-definition-name slotd)
                                      (class-slots c)
                                      :key #'slot-definition-name)))
                     (when (and other
                                (eq (slot-definition-allocation other) allocation)
                                (setf (slot-definition-location slotd)
                                      (slot-definition-location other)))
                       (return)))))))))
    slots))

(defmethod compute-slots :around ((class std-class))
  (std-class-compute-slots class (call-next-method)))

;;; ======================================================================
;;; STANDARD-OBJECT
;;;
;;; Standard-object has no slots and inherits only from t:
;;; (defclass standard-object (t) ())

(defmethod describe-object ((obj standard-object) (stream t))
  (let* ((class (si:instance-class obj))
         (slotds (class-slots class))
         slotname has-shared-slots)
    (format stream "~%~S is an instance of class ~A"
            obj (class-name class))
    (when slotds
      ;; print instance slots
      (format stream "~%it has the following instance slots")
      (dolist (slot slotds)
        (setq slotname (slot-definition-name slot))
        (case (slot-definition-allocation slot)
          (:INSTANCE
           (format stream "~%~A:~24,8T~A"
                   slotname
                   (if (slot-boundp obj slotname)
                       (slot-value obj slotname) "Unbound")))
          ;; :CLASS
          (T (setq has-shared-slots t))))
      (when has-shared-slots
        ;; print class slots
        (format stream "~%it has the following class slots")
        (dolist (slot slotds)
          (setq slotname (slot-definition-name slot))
          (unless (eq (slot-definition-allocation slot) :INSTANCE)
            (format stream "~%~A:~24,8T~A"
                    slotname
                    (if (slot-boundp obj slotname)
                        (slot-value obj slotname) "Unbound")))))))
  obj)

;;; ----------------------------------------------------------------------
;;; CHECK INITARGS
;;;
;;; There are different sets of initialization arguments. First we have
;;; those coming from the :INITARG option in the slots. Then we have
;;; all declared initargs which are keyword arguments to methods defined
;;; on SHARED-INITIALIZE, REINITIALIZE-INSTANCE, etc. (See ANSI 7.1.2)
;;;

(defun valid-keywords-from-methods (&rest method-lists)
  (loop for methods in method-lists
     when (member t methods :key #'method-keywords)
     return t
     nconc methods))

(defun check-initargs (class initargs &optional methods
                       (slots (class-slots class))
                       cached-keywords)
  ;; First get all initargs which have been declared in the given
  ;; methods, then check the list of initargs declared in the slots
  ;; of the class.
  (unless (or (eq methods t) (eq cached-keywords t))
    (do* ((name-loc initargs (cddr name-loc))
          (allow-other-keys nil)
          (allow-other-keys-found nil)
          (unknown-key nil))
         ((null name-loc)
          (when (and (not allow-other-keys) unknown-key)
            (simple-program-error "Unknown initialization option ~S for class ~A"
                                  unknown-key class)))
      (let ((name (first name-loc)))
        (cond ((null (cdr name-loc))
               (simple-program-error "No value supplied for the init-name ~S." name))
              ;; This check must be here, because :ALLOW-OTHER-KEYS is a valid
              ;; slot-initarg.
              ((and (eql name :ALLOW-OTHER-KEYS)
                    (not allow-other-keys-found))
               (setf allow-other-keys (second name-loc)
                     allow-other-keys-found t))
              ;; Check if the arguments is associated with a slot
              ((member name slots :test #'member :key #'slot-definition-initargs))
              ;; The initialization argument has been declared in some method
              ((member name cached-keywords))
              ((and methods (member name methods :test #'member :key #'method-keywords)))
              (t
               (setf unknown-key name)))))))

;;; ----------------------------------------------------------------------
;;; Methods

(defmethod describe-object ((obj std-class) (stream t))
  (let ((slotds (class-slots (si:instance-class obj))))
    (format stream "~%~A is an instance of class ~A"
            obj (class-name (si:instance-class obj)))
    (do ((scan slotds (cdr scan))
         (i 0 (1+ i)))
        ((null scan))
      (declare (fixnum i))
      (print (slot-definition-name (car scan)) stream)
      (princ ": " stream)
      (case (slot-definition-name (car scan))
            ((SUPERIORS INFERIORS PRECEDENCE-LIST)
             (princ "(" stream)
             (do* ((scan (si:instance-ref obj i) (cdr scan))
                   (e (car scan) (car scan)))
                  ((null scan))
                  (prin1 (class-name e) stream)
                  (when (cdr scan) (princ " " stream)))
             (princ ")"))
            (otherwise (prin1 (si:instance-ref obj i) stream)))))
  obj)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/standard.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/std-accessors.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.o
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; ACCESSOR / READER / WRITER METHOD CREATION
;;;
;;; The following code creates optimized and unoptimized versions of the
;;; slot accessors defined for a class. They are designed so that at least
;;; some varieties work at boot time.
;;; 

(defun safe-slot-definition-location (slotd &optional default)
  (cond ((listp slotd)
         (error "List instead of a slot definition object"))
        (t
         (slot-value slotd 'location))))

(defun std-class-sealed-accessors (index)
  (declare (si::c-local)
           (fixnum index))
  (values #'(lambda (self)
              (declare (optimize (safety 0) (speed 3) (debug 0))
                       (standard-object self))
              (ensure-up-to-date-instance self)
              (safe-instance-ref self index))
          #'(lambda (value self)
              (declare (optimize (safety 0) (speed 3) (debug 0))
                       (standard-object self))
              (ensure-up-to-date-instance self)
              (si:instance-set self index value))))

(defun std-class-accessors (slot-name)
  (declare (si::c-local))
  ;; The following are very slow. We do not optimize for the slot position.
  (values #'(lambda (self)
              (slot-value self slot-name))
          #'(lambda (value self)
              (setf (slot-value self slot-name) value))))

(defun safe-add-method (name method)
  ;; Adds a method to a function which might have been previously defined
  ;; as non-generic, without breaking the function
  (cond ((or *clos-booted*
             (not (fboundp name))
             (si::instancep (fdefinition name)))
         (add-method (ensure-generic-function name) method))
        (t
         (let* ((alt-name '#:foo)
                (gf (ensure-generic-function alt-name)))
           (add-method gf method)
           (setf (generic-function-name gf) name)
           (setf (fdefinition name) gf)
           (fmakunbound alt-name)))))

(defun std-class-generate-accessors (standard-class &optional (optimizable t))
  ;;
  ;; The accessors are closures, which are generated every time the
  ;; slots of the class change. The accessors are safe: they check that
  ;; the slot is bound after retreiving the value, and they may take
  ;; the liberty of using SI:INSTANCE-REF because they know the class of
  ;; the instance.
  ;;
  (dolist (slotd (slot-value standard-class 'direct-slots))
    (with-slots ((name name) (allocation allocation) (location location)
                 (readers readers) (writers writers))
        slotd
      ;; When a class is of a specified class in the MOP (such as
      ;; STANDARD-CLASS), then the user may not write any method
      ;; around SLOT-VALUE-USING-CLASS. This allows us to write
      ;; optimized versions of the accessors.
      (unless (member (slot-value standard-class 'name)
                      '(standard-class
                        funcallable-standard-class
                        structure-class))
        (setf optimizable nil))
      (multiple-value-bind (reader writer)
          (cond ((and optimizable
                      (eq allocation :instance)
                      ;; This is an extension by ECL in which a direct slot
                      ;; definition specifies the location of a slot. It
                      ;; only happens for sealed classes.
                      (typep location 'fixnum))
                 (std-class-sealed-accessors location))
                (t
                 (std-class-accessors name)))
        (let* ((options (list :slot-definition slotd))
               (reader-args (list* :function reader
                                   :generic-function nil
                                   :qualifiers nil
                                   :lambda-list '(object)
                                   :specializers `(,standard-class)
                                   options))
               (reader-class (if (boundp '*early-methods*)
                                 'standard-reader-method
                                 (apply #'reader-method-class standard-class slotd
                                        reader-args)))
               (writer-args (list* :function writer
                                   :generic-function nil
                                   :qualifiers nil
                                   :lambda-list '(value object)
                                   :specializers `(,(find-class t) ,standard-class)
                                   options))
               (writer-class (if (boundp '*early-methods*)
                                 'standard-writer-method
                                 (apply #'writer-method-class standard-class slotd
                                        writer-args))))
          (dolist (fname readers)
            (let ((method (make-method reader-class nil `(,standard-class) '(self)
                                       (wrapped-method-function reader)
                                       options)))
              (safe-add-method fname method)
              ;; This is redundant, but we need it at boot time because
              ;; the early MAKE-METHOD does not use the options field.
              (unless *clos-booted*
                (setf (slot-value method 'slot-definition) slotd))))
          (dolist (fname writers)
            (let ((method (make-method writer-class nil
                                       `(,(find-class t) ,standard-class) '(value self)
                                       (wrapped-method-function writer)
                                       options)))
              (safe-add-method fname method)
              ;; This is redundant, but we need it at boot time because
              ;; the early MAKE-METHOD does not use the options field.
              (unless *clos-booted*
                (setf (slot-value method 'slot-definition) slotd)))))))))

(defun reader-closure (index)
  (declare (si::c-local))
  (lambda (object) (si::instance-ref object index)))

(defun writer-closure (index)
  (declare (si::c-local))
  (lambda (value object) (si::instance-set object index value)))

(labels ((generate-accessors (class)
           (declare (optimize speed (safety 0)))
           (if (and (typep class 'std-class)
                    #+(or)
                    (not (member (slot-value class 'name)
                                 '(slot-definition
                                   direct-slot-definition
                                   effective-slot-definition
                                   standard-slot-definition
                                   standard-direct-slot-definition
                                   standard-effective-slot-definition))))
               (std-class-generate-accessors class t)
               (loop for slotd in (slot-value class 'slots)
                  for index = (slot-value slotd 'location)
                  do (loop for reader in (slot-value slotd 'readers)
                        do (setf (fdefinition reader) (reader-closure index)))
                  do (loop for writer in (slot-value slotd 'writers)
                        do (setf (fdefinition writer) (writer-closure index)))))
           (mapc #'generate-accessors (slot-value class 'direct-subclasses))))
  (generate-accessors +the-t-class+))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/std-accessors.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/stdmethod.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;;----------------------------------------------------------------------
;;; Method
;;; ----------------------------------------------------------------------

(defun function-keywords (method)
  (multiple-value-bind (reqs opts rest-var key-flag keywords)
      (si::process-lambda-list (slot-value method 'lambda-list) 'function)
    (declare (ignore reqs opts rest-var))
    (when key-flag
      (do* ((output '())
            (l (cdr keywords) (cddddr l)))
           ((endp l)
            output)
        (push (first l) output)))))

(defmethod shared-initialize ((method standard-method) slot-names &rest initargs
                              &key (specializers nil spec-supplied-p)
                              (lambda-list nil lambda-supplied-p)
                              generic-function)
  (declare (ignore initargs method slot-names))
  (when slot-names
    (unless spec-supplied-p
      (error "Specializer list not supplied in method initialization"))
    (unless lambda-supplied-p
      (error "Lambda list not supplied in method initialization"))
    (unless (= (first (si::process-lambda-list lambda-list 'method))
               (length specializers))
      (error "The list of specializers does not match the number of required arguments in the lambda list ~A"
             lambda-list)))
  (when spec-supplied-p
    (loop for s in specializers
       unless (typep s 'specializer)
       do (error "Object ~A is not a valid specializer" s)))
  (setf method (call-next-method)
        (method-keywords method) (compute-method-keywords (method-lambda-list method)))
  method)

#+threads
(defparameter *eql-specializer-lock* (mp:make-lock :name 'eql-specializer))
(defparameter *eql-specializer-hash*
  (make-hash-table :size 128 :test #'eql))

(defun intern-eql-specializer (object)
  (let ((table *eql-specializer-hash*))
    (mp:with-lock (*eql-specializer-lock*)
      (or (gethash object table nil)
          (setf (gethash object table)
                (make-instance 'eql-specializer :object object))))))

(defmethod add-direct-method ((spec specializer) (method method))
  (pushnew method (specializer-direct-methods spec))
  (let ((gf (method-generic-function method)))
    (pushnew gf (specializer-direct-generic-functions spec)))
  (values))

(defmethod remove-direct-method ((spec specializer) (method method))
  (let* ((gf (method-generic-function method))
         (methods (delete method (specializer-direct-methods spec))))
    (setf (specializer-direct-methods spec) methods)
    (unless (find gf methods :key #'method-generic-function)
      (setf (specializer-direct-generic-functions spec)
            (delete gf (specializer-direct-generic-functions spec))))
    (values)))

(defmethod remove-direct-method ((spec eql-specializer) (method method))
  (mp:with-lock (*eql-specializer-lock*)
    (call-next-method)
    (unless (specializer-direct-methods spec)
      (remhash spec *eql-specializer-hash*)))
  (values))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/stdmethod.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/std-slot-value.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.o
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

(eval-when (:compile-toplevel :execute)
  (load "src:clos;hierarchy.lsp"))

;;; ----------------------------------------------------------------------
;;; SLOTS READING AND WRITING
;;;
;;; Functional and macro interface for accessing the slots of an instance.
;;; This interface is defined with specialization for classes that ECL
;;; knows of such as standard classes and funcallable standard class.
;;; This is needed to avoid circularity in compute-applicable-methods,
;;; which needs the slot values and thus cannot go through a dispatch
;;; itself.
;;;
;;; Note that using SLOT-VALUE or specialized versions of it is not
;;; wrong because the MOP enforces various restrictions on portable
;;; code:
;;;  1) Accessors must behave as SLOT-VALUE
;;;  2) In particular, any method defined by the user must be
;;;     specialized on at least one non-specified class. This means
;;;     that the user cannot change the behavoir of SLOT-VALUE for
;;;     standard classes.
;;;
;;; First of all we define WITH-SLOTS because it is going to be useful
;;; for enforcing the use of SLOT-VALUE and not of accessors
;;; throughout the bootstrap code.
;;;
(defmacro with-slots (slot-entries instance-form &body body)
  (let* ((temp (gensym))
         (accessors
          (do ((scan slot-entries (cdr scan))
               (res))
              ((null scan) (nreverse res))
            (if (symbolp (first scan))
                (push `(,(first scan) (slot-value ,temp ',(first scan))) res)
                (push `(,(caar scan)
                         (slot-value ,temp ',(cadar scan))) res)))))
    `(let ((,temp ,instance-form))
       (symbol-macrolet ,accessors ,@body))))

;;;
;;; The following macro is a convenience that can be used to directly
;;; access the slots of a class based on their s-form description. It
;;; is used internally by ECL during bootstrap. Unlike WITH-SLOTS,
;;; the macros directly access the slots by index.
;;;
(eval-when (:compile-toplevel :execute)
  (defmacro with-early-accessors ((&rest slot-definitions) &rest body)
    `(macrolet
         ,(loop for slots in slot-definitions
             nconc (loop for (name . slotd) in (if (symbolp slots)
                                                   (symbol-value slots)
                                                   slots)
                      for index from 0
                      for accessor = (getf slotd :accessor)
                      when accessor
                      collect `(,accessor (object) `(si::instance-ref ,object ,,index))))
       ,@body)))

;;;
;;; The following macro is also used at bootstap for instantiating
;;; a class based only on the s-form description.
;;;
(eval-when (:compile-toplevel :execute)
  (defmacro with-early-make-instance (slots (object class &rest key-value-pairs)
                                      &rest body)
    (when (symbolp slots)
      (setf slots (symbol-value slots)))
    `(let* ((%class ,class)
            (,object (si::allocate-raw-instance nil %class
                                                ,(length slots))))
       (declare (type standard-object ,object))
       ,@(flet ((initializerp (name list)
                  (not (eq (getf list name 'wrong) 'wrong))))
               (loop for (name . slotd) in slots
                  for initarg = (getf slotd :initarg)
                  for initform = (getf slotd :initform (si::unbound))
                  for initvalue = (getf key-value-pairs initarg)
                  for index from 0
                  do (cond ((and initarg (initializerp initarg key-value-pairs))
                            (setf initform (getf key-value-pairs initarg)))
                           ((initializerp name key-value-pairs)
                            (setf initform (getf key-value-pairs name))))
                  when (si:sl-boundp initform)
                  collect `(si::instance-set ,object ,index ,initform)))
       (when %class
         (si::instance-sig-set ,object))
       (with-early-accessors (,slots)
         ,@body))))

;;;
;;; ECL classes store slots in a hash table for faster access. The
;;; following functions create the cache and allow us to locate the
;;; slots rapidly.
;;;
(defun std-create-slots-table (class)
  (with-slots ((all-slots slots)
               (slot-table slot-table)
               (location-table location-table))
      class
    (let* ((size (max 32 (* 2 (length all-slots))))
           (table (make-hash-table :size size)))
      (dolist (slotd all-slots)
        (setf (gethash (slot-definition-name slotd) table) slotd))
      (let ((metaclass (si::instance-class class))
            (locations nil))
        (when (or (eq metaclass (find-class 'standard-class))
                  (eq metaclass (find-class 'funcallable-standard-class))
                  (eq metaclass (find-class 'structure-class)))
          (setf locations (make-hash-table :size size))
          (dolist (slotd all-slots)
            (setf (gethash (slot-definition-name slotd) locations)
                  (slot-definition-location slotd))))
        (setf slot-table table
              location-table locations)))))

(defun find-slot-definition (class slot-name)
  (with-slots ((slots slots) (slot-table slot-table))
      class
    (if (or (eq (si:instance-class class) +the-standard-class+)
            (eq (si:instance-class class) +the-funcallable-standard-class+))
        (gethash slot-name slot-table nil)
        (find slot-name slots :key #'slot-definition-name))))

;;;
;;; INSTANCE UPDATE PREVIOUS
;;;
(eval-when (:compile-toplevel :execute)
  (defmacro ensure-up-to-date-instance (instance)
    ;; The up-to-date status of a class is determined by
    ;; instance.sig. This slot of the C structure contains a list of
    ;; slot definitions that was used to create the instance. When the
    ;; class is updated, the list is newly created. Structures are also
    ;; "instances" but keep ECL_UNBOUND instead of the list.
    `(let* ((i ,instance)
            (s (si::instance-sig i)))
       (declare (:read-only i s))
       (with-early-accessors (+standard-class-slots+)
         (when (si:sl-boundp s)
           (unless (eq s (class-slots (si::instance-class i)))
             (update-instance i)))))))

(defun update-instance (x)
  (si::instance-sig-set x))
(declaim (notinline update-instance))

;;;
;;; STANDARD-CLASS INTERFACE
;;;
;;; Specific functions for slot reading, writing, boundness checking, etc.
;;;

(defun standard-instance-access (instance location)
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (ensure-up-to-date-instance instance)
    (cond ((ext:fixnump location)
           ;; local slot
           (si:instance-ref instance (truly-the fixnum location)))
          ((consp location)
           ;; shared slot
           (car location))
          (t
           (invalid-slot-location instance location)))))

(defun standard-instance-set (instance location val)
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (ensure-up-to-date-instance instance)
    (cond ((ext:fixnump location)
           ;; local slot
           (si:instance-set instance (truly-the fixnum location) val))
          ((consp location)
           ;; shared slot
           (setf (car location) val))
          (t
           (invalid-slot-location instance location)))
    val))

(defsetf standard-instance-access standard-instance-set)
(defsetf funcallable-standard-instance-access standard-instance-set)

(defun slot-value (self slot-name)
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (let* ((class (class-of self))
           (location-table (class-location-table class)))
      (if location-table
          (let ((location (gethash slot-name location-table nil)))
            (if location
                (let ((value (standard-instance-access self location)))
                  (if (si:sl-boundp value)
                      value
                      (values (slot-unbound class self slot-name))))
                (slot-missing class self slot-name 'SLOT-VALUE)))
          (let ((slotd (find slot-name (class-slots class) :key #'slot-definition-name)))
            (if slotd
                (slot-value-using-class class self slotd)
                (values (slot-missing class self slot-name 'SLOT-VALUE))))))))

(defun slot-exists-p (self slot-name)
  (and (find-slot-definition (class-of self) slot-name)
       t))

(defun slot-boundp (self slot-name)
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (let* ((class (class-of self))
           (location-table (class-location-table class)))
      (if location-table
          (let ((location (gethash slot-name location-table nil)))
            (if location
                (si:sl-boundp (standard-instance-access self location))
                (values (slot-missing class self slot-name 'SLOT-BOUNDP))))
          (let ((slotd (find slot-name (class-slots class) :key #'slot-definition-name)))
            (if slotd
                (slot-boundp-using-class class self slotd)
                (values (slot-missing class self slot-name 'SLOT-BOUNDP))))))))

(defun clos::slot-value-set (value self slot-name)
  (with-early-accessors (+standard-class-slots+
                         +slot-definition-slots+)
    (let* ((class (class-of self))
           (location-table (class-location-table class)))
      (if location-table
          (let ((location (gethash slot-name location-table nil)))
            (if location
                (setf (standard-instance-access self location) value)
                (slot-missing class self slot-name 'SETF value)))
          (let ((slotd (find slot-name (class-slots class) :key #'slot-definition-name)))
            (if slotd
                (setf (slot-value-using-class class self slotd) value)
                (slot-missing class self slot-name 'SETF value))))))
  value)

(setf (fdefinition '(setf slot-value)) #'clos::slot-value-set)

;;;
;;; 2) Overloadable methods on which the previous functions are based
;;;

(defun invalid-slot-location (instance location)
  (declare (si::c-local)
           (ignore instance))
  (error "Invalid location ~A when accessing slot of class ~A"
         location (class-of location)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/std-slot-value.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/streams.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 2004, Juan Jose Garcia-Ripoll
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;        The CLOS IO library.

(in-package "GRAY")

(import 'ext:ansi-stream)

;;;
;;; This is the generic function interface for CLOS streams.
;;;
;;; The following is a port of SBCL's implementation of Gray
;;; Streams. Minor caveats with respect to the proposal are that we
;;; rather keep CLOSE, STREAM-ELEMENT-TYPE, INPUT-STREAM-P,
;;; OUTPUT-STREAM-P and OPEN-STREAM-P these as normal functions that
;;; call the user extensible EXT:STREAM-{CLOSE, ELT-TYPE, INPUT-P,
;;; OUTPUT-P, OPEN-P}.
;;;

(defgeneric stream-advance-to-column (stream column)
  (:documentation
   "Write enough blank space so that the next character will be
  written at the specified column. Returns true if the operation is
  successful, or NIL if it is not supported for this stream. This is
  intended for use by by PPRINT and FORMAT ~T. The default method uses
  STREAM-LINE-COLUMN and repeated calls to STREAM-WRITE-CHAR with a
  #\SPACE character; it returns NIL if STREAM-LINE-COLUMN returns
  NIL."))

(defgeneric stream-clear-input (stream)
  (:documentation
   "This is like CL:CLEAR-INPUT, but for Gray streams, returning NIL.
  The default method does nothing."))

(defgeneric stream-clear-output (stream)
  (:documentation
   "This is like CL:CLEAR-OUTPUT, but for Gray streams: clear the
  given output STREAM. The default method does nothing."))

(defgeneric close (stream &key abort)
  (:documentation
   "Close the given STREAM. No more I/O may be performed, but
  inquiries may still be made. If :ABORT is true, an attempt is made
  to clean up the side effects of having created the stream."))

(defgeneric stream-element-type (stream)
  (:documentation
   "Return a type specifier for the kind of object returned by the
  STREAM. The class FUNDAMENTAL-CHARACTER-STREAM provides a default
  method which returns CHARACTER."))

(defgeneric stream-finish-output (stream)
  (:documentation
   "Attempts to ensure that all output sent to the Stream has reached
  its destination, and only then returns false. Implements
  FINISH-OUTPUT. The default method does nothing."))

(defgeneric stream-force-output (stream)
  (:documentation
   "Attempts to force any buffered output to be sent. Implements
  FORCE-OUTPUT. The default method does nothing."))

(defgeneric stream-fresh-line (stream)
  (:documentation
   "Outputs a new line to the Stream if it is not positioned at the
  beginning of a line. Returns T if it output a new line, nil
  otherwise. Used by FRESH-LINE. The default method uses
  STREAM-START-LINE-P and STREAM-TERPRI."))

(defgeneric input-stream-p (stream)
  (:documentation "Can STREAM perform input operations?"))

(defgeneric stream-p (stream)
  (:documentation "Is this object a STREAM?"))

(defgeneric stream-interactive-p (stream)
  (:documentation "Is stream interactive (For instance, a tty)?"))

(defgeneric stream-line-column (stream)
  (:documentation
   "Return the column number where the next character will be written,
  or NIL if that is not meaningful for this stream.  The first column
  on a line is numbered 0. This function is used in the implementation
  of PPRINT and the FORMAT ~T directive. For every character output
  stream class that is defined, a method must be defined for this
  function, although it is permissible for it to always return NIL."))

(defgeneric stream-listen (stream)
  #+sb-doc
  (:documentation
   "This is used by LISTEN. It returns true or false. The default method uses
  STREAM-READ-CHAR-NO-HANG and STREAM-UNREAD-CHAR. Most streams should
  define their own method since it will usually be trivial and will
  always be more efficient than the default method."))

(defgeneric open-stream-p (stream)
  (:documentation
   "Return true if STREAM is not closed. A default method is provided
  by class FUNDAMENTAL-STREAM which returns true if CLOSE has not been
  called on the stream."))

(defgeneric output-stream-p (stream)
  (:documentation "Can STREAM perform output operations?"))

(defgeneric stream-peek-char (stream)
  (:documentation
   "This is used to implement PEEK-CHAR; this corresponds to PEEK-TYPE of NIL.
  It returns either a character or :EOF. The default method calls
  STREAM-READ-CHAR and STREAM-UNREAD-CHAR."))

(defgeneric stream-read-byte (stream)
  (:documentation
   "Used by READ-BYTE; returns either an integer, or the symbol :EOF
  if the stream is at end-of-file."))

(defgeneric stream-read-char (stream)
  (:documentation
   "Read one character from the stream. Return either a character
  object, or the symbol :EOF if the stream is at end-of-file.  Every
  subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM must define a method
  for this function."))

(defgeneric stream-read-char-no-hang (stream)
  (:documentation
   "This is used to implement READ-CHAR-NO-HANG. It returns either a
  character, or NIL if no input is currently available, or :EOF if
  end-of-file is reached. The default method provided by
  FUNDAMENTAL-CHARACTER-INPUT-STREAM simply calls STREAM-READ-CHAR;
  this is sufficient for file streams, but interactive streams should
  define their own method."))

(defgeneric stream-read-line (stream)
  (:documentation
   "This is used by READ-LINE. A string is returned as the first
  value. The second value is true if the string was terminated by
  end-of-file instead of the end of a line. The default method uses
  repeated calls to STREAM-READ-CHAR."))

(defgeneric stream-read-sequence (stream sequence &optional start end)
  (:documentation
   "This is like CL:READ-SEQUENCE, but for Gray streams."))

(defgeneric stream-start-line-p (stream)
  (:documentation
   "Is STREAM known to be positioned at the beginning of a line?
  It is permissible for an implementation to always return
  NIL. This is used in the implementation of FRESH-LINE. Note that
  while a value of 0 from STREAM-LINE-COLUMN also indicates the
  beginning of a line, there are cases where STREAM-START-LINE-P can be
  meaningfully implemented although STREAM-LINE-COLUMN can't be. For
  example, for a window using variable-width characters, the column
  number isn't very meaningful, but the beginning of the line does have
  a clear meaning. The default method for STREAM-START-LINE-P on class
  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses STREAM-LINE-COLUMN, so if
  that is defined to return NIL, then a method should be provided for
  either STREAM-START-LINE-P or STREAM-FRESH-LINE."))

(defgeneric stream-terpri (stream)
  (:documentation
   "Writes an end of line, as for TERPRI. Returns NIL. The default
  method does (STREAM-WRITE-CHAR stream #\NEWLINE)."))

(defgeneric stream-unread-char (stream character)
  (:documentation
   "Un-do the last call to STREAM-READ-CHAR, as in UNREAD-CHAR.
  Return NIL. Every subclass of FUNDAMENTAL-CHARACTER-INPUT-STREAM
  must define a method for this function."))

(defgeneric stream-write-byte (stream integer)
  (:documentation
   "Implements WRITE-BYTE; writes the integer to the stream and
  returns the integer as the result."))

(defgeneric stream-write-char (stream character)
  (:documentation
   "Write CHARACTER to STREAM and return CHARACTER. Every
  subclass of FUNDAMENTAL-CHARACTER-OUTPUT-STREAM must have a method
  defined for this function."))

(defgeneric stream-write-string (stream string &optional start end)
  (:documentation
   "This is used by WRITE-STRING. It writes the string to the stream,
  optionally delimited by start and end, which default to 0 and NIL.
  The string argument is returned. The default method provided by
  FUNDAMENTAL-CHARACTER-OUTPUT-STREAM uses repeated calls to
  STREAM-WRITE-CHAR."))

(defgeneric stream-write-sequence (stream sequence &optional start end)
  (:documentation
   "This is like CL:WRITE-SEQUENCE, but for Gray streams."))

(defgeneric stream-file-position (stream &optional position)
  (:documentation
   "This is like CL:FILE-POSITION, but for Gray streams."))

(defgeneric stream-file-descriptor (stream &optional direction)
  (:documentation
   "Return the file-descriptor underlaying STREAM, or NIL if not
   available. DIRECTION must be either :INPUT, or :OUTPUT and is
   supposed to discriminate in case STREAM is a bidirectional
   stream. DIRECTION is supposed to default to :INPUT.

   An error is signaled if DIRECTION is :INPUT (:OUTPUT), and STREAM
   is not an input (output) stream. A system-provided :BEFORE method
   handles this case; user methods do not need to take care of it.

   In case STREAM-FILE-DESCRIPTOR is not implemented for STREAM, an
   error is signaled. That is, users must add methods to explicitly
   decline by returning NIL."))


;;;
;;; Our class hierarchy looks like the one from Gray streams
;;;
;;; character output streams
;;;
;;; A character output stream can be created by defining a class that
;;; includes FUNDAMENTAL-CHARACTER-OUTPUT-STREAM and defining methods
;;; for the generic functions below.
;;;
;;; binary streams
;;;
;;; Binary streams can be created by defining a class that includes
;;; either FUNDAMENTAL-BINARY-INPUT-STREAM or
;;; FUNDAMENTAL-BINARY-OUTPUT-STREAM (or both) and defining a method
;;; for STREAM-ELEMENT-TYPE and for one or both of the following
;;; generic functions.
;;;

(defclass fundamental-stream (standard-object stream)
  ((open-p :initform t :accessor open-stream-p))
  (:documentation "the base class for all CLOS streams"))

(defclass fundamental-input-stream (fundamental-stream) nil)

(defclass fundamental-output-stream (fundamental-stream) nil)

(defclass fundamental-character-stream (fundamental-stream) nil)

(defclass fundamental-binary-stream (fundamental-stream) nil)

(defclass fundamental-character-input-stream
    (fundamental-input-stream fundamental-character-stream) nil)

(defclass fundamental-character-output-stream
    (fundamental-output-stream fundamental-character-stream) nil)

(defclass fundamental-binary-input-stream
    (fundamental-input-stream fundamental-binary-stream) nil)

(defclass fundamental-binary-output-stream
    (fundamental-output-stream fundamental-binary-stream) nil)


;;;
;;; The following methods constitute default implementations.
;;;

(defun bug-or-error (stream fun)
  (declare (si::c-local))
  (if (typep stream 'stream)
      (error "The stream ~S has no suitable method for ~S." stream fun)
      (error 'type-error :datum stream :expected-type 'stream)))

;; STREAM-ADVANCE-TO-COLUMN

(defmethod stream-advance-to-column ((stream fundamental-character-output-stream)
                                     column)
  (let ((current-column (stream-line-column stream)))
    (when current-column
      (let ((fill (- column current-column)))
        (dotimes (i fill)
          (stream-write-char stream #\Space)))
      T)))


;; CLEAR-INPUT

(defmethod stream-clear-input ((stream fundamental-character-input-stream))
  (declare (ignore stream))
  nil)

(defmethod stream-clear-input ((stream ansi-stream))
  (cl:clear-input stream))

(defmethod stream-clear-input ((stream t))
  (bug-or-error stream 'stream-clear-input))


;; CLEAR-OUTPUT

(defmethod stream-clear-output ((stream fundamental-output-stream))
  (declare (ignore stream))
  nil)

(defmethod stream-clear-output ((stream ansi-stream))
  (cl:clear-output stream))

(defmethod stream-clear-output ((stream t))
  (bug-or-error stream 'stream-clear-output))


;; CLOSE

(defmethod close ((stream fundamental-stream) &key abort)
  (declare (ignore abort))
  (setf (open-stream-p stream) nil)
  t)

(defmethod close ((stream ansi-stream) &key abort)
  (cl:close stream :abort abort))

(defmethod close ((stream stream) &key abort)
  (declare (ignore abort))
  (bug-or-error stream 'close))


;; STREAM-ELEMENT-TYPE

(defmethod stream-element-type ((stream fundamental-character-stream))
  (declare (ignore stream))
  'character)

(defmethod stream-element-type ((stream ansi-stream))
  (cl:stream-element-type stream))

(defmethod stream-element-type ((stream t))
  (bug-or-error stream 'stream-element-type))

;; FINISH-OUTPUT

(defmethod stream-finish-output ((stream fundamental-output-stream))
  (declare (ignore stream))
  nil)

(defmethod stream-finish-output ((stream ansi-stream))
  (cl:finish-output stream))

(defmethod stream-finish-output ((stream t))
  (bug-or-error stream 'stream-finish-output))


;; FORCE-OUTPUT

(defmethod stream-force-output ((stream fundamental-output-stream))
  (declare (ignore stream))
  nil)

(defmethod stream-force-output ((stream ansi-stream))
  (cl:force-output stream))

(defmethod stream-force-output ((stream t))
  (bug-or-error stream 'stream-force-output))


;; FRESH-LINE

(defmethod stream-fresh-line ((stream fundamental-character-output-stream))
  (unless (stream-start-line-p stream)
    (stream-terpri stream)
    t))

(defmethod stream-fresh-line ((stream ansi-stream))
  (cl:fresh-line stream))


;; INPUT-STREAM-P

(defmethod input-stream-p ((stream fundamental-stream))
  (declare (ignore stream))
  nil)

(defmethod input-stream-p ((stream fundamental-input-stream))
  (declare (ignore stream))
  t)

(defmethod input-stream-p ((stream ansi-stream))
  (cl:input-stream-p stream))

(defmethod input-stream-p ((stream t))
  (bug-or-error stream 'input-stream-p))


;; INTERACTIVE-STREAM-P

(defmethod stream-interactive-p ((stream ansi-stream))
  (cl:interactive-stream-p stream))

(defmethod stream-interactive-p ((stream t))
  (bug-or-error stream 'stream-interactive-p))


;; LINE-COLUMN

(defmethod stream-line-column ((stream fundamental-character-output-stream))
  (declare (ignore stream))
  nil)


;; LISTEN

(defmethod stream-listen ((stream fundamental-character-input-stream))
  (let ((char (stream-read-char-no-hang stream)))
    (when (characterp char)
      (stream-unread-char stream char)
      t)))

(defmethod stream-listen ((stream ansi-stream))
  (cl:listen stream))

(defmethod stream-listen ((stream t))
  (bug-or-error stream 'stream-listen))


;; OPEN-STREAM-P

(defmethod open-stream-p ((stream ansi-stream))
  (cl:open-stream-p stream))

(defmethod open-stream-p ((stream t))
  (bug-or-error stream 'open-stream-p))


;; OUTPUT-STREAM-P

(defmethod output-stream-p ((stream fundamental-stream))
  (declare (ignore stream))
  nil)

(defmethod output-stream-p ((stream fundamental-output-stream))
  (declare (ignore stream))
  t)

(defmethod output-stream-p ((stream ansi-stream))
  (cl:output-stream-p stream))

(defmethod output-stream-p ((stream t))
  (bug-or-error stream 'output-stream-p))


;; PEEK-CHAR

(defmethod stream-peek-char ((stream fundamental-character-input-stream))
  (let ((char (stream-read-char stream)))
    (unless (eq char :eof)
      (stream-unread-char stream char))
    char))

(defmethod stream-peek-char ((stream ansi-stream))
  (cl:peek-char stream))

(defmethod stream-peek-char ((stream t))
  (bug-or-error stream 'stream-peek-char))


;; READ-BYTE

(defmethod stream-read-byte ((stream ansi-stream))
  (cl:read-byte stream))

(defmethod stream-read-byte ((stream t))
  (bug-or-error stream 'stream-read-byte))


;; READ-CHAR

(defmethod stream-read-char ((stream ansi-stream))
  (cl:read-char stream))

(defmethod stream-read-char ((stream t))
  (bug-or-error stream 'stream-read-char))


;; UNREAD-CHAR

(defmethod stream-unread-char ((stream ansi-stream) character)
  (cl:unread-char character stream))

(defmethod stream-unread-char ((stream ansi-stream) character)
  (declare (ignore character))
  (bug-or-error stream 'stream-unread-char))


;; READ-CHAR-NO-HANG

(defmethod stream-read-char-no-hang ((stream fundamental-character-input-stream))
  (stream-read-char stream))

(defmethod stream-read-char-no-hang ((stream ansi-stream))
  (cl:read-char-no-hang stream))

(defmethod stream-read-char-no-hang ((stream t))
  (bug-or-error stream 'stream-read-char-no-hang))


;; READ-LINE

(defmethod stream-read-line ((stream fundamental-character-input-stream))
  (let ((res (make-string 80))
        (len 80)
        (index 0))
    (loop
     (let ((ch (stream-read-char stream)))
       (cond ((eq ch :eof)
              (return (values (if (zerop index)
                                  nil
                                  (si::shrink-vector res index))
                              t)))
             (t
              (when (char= ch #\newline)
                (return (values (si::shrink-vector res index) nil)))
              (when (= index len)
                (setq len (* len 2))
                (let ((new (make-string len)))
                  (replace new res)
                  (setq res new)))
              (setf (schar res index) ch)
              (incf index)))))))

(defmethod stream-read-line ((stream ansi-stream))
  (cl:read-line stream))

(defmethod stream-read-line ((stream t))
  (bug-or-error stream 'stream-read-line))


;; READ-SEQUENCE

(defmethod stream-read-sequence ((stream fundamental-character-input-stream)
                                 sequence &optional (start 0) (end nil))
  (si::do-read-sequence sequence stream start end))

(defmethod stream-read-sequence ((stream fundamental-binary-input-stream)
                                 sequence &optional (start 0) (end nil))
  (si::do-read-sequence sequence stream start end))

(defmethod stream-read-sequence ((stream ansi-stream) sequence
                                 &optional (start 0) (end nil))
  (si:do-read-sequence stream sequence start end))

(defmethod stream-read-sequence ((stream t) sequence &optional start end)
  (declare (ignore sequence start end))
  (bug-or-error stream 'stream-read-sequence))


;; START-LINE-P

(defmethod stream-start-line-p ((stream fundamental-character-output-stream))
  (eql (stream-line-column stream) 0))

;; FILE-POSITION

(defmethod stream-file-position ((stream ansi-stream) &optional position)
  (file-position stream position))

(defmethod stream-file-position ((stream t) &optional position)
  (declare (ignore stream position))
  nil)

;; STREAM-P

(defmethod streamp ((stream stream))
  (declare (ignore stream))
  t)

(defmethod streamp ((stream t))
  (declare (ignore stream))
  nil)


;; WRITE-BYTE

(defmethod stream-write-byte ((stream ansi-stream) integer)
  (cl:write-byte integer stream))

(defmethod stream-write-byte ((stream t) integer)
  (declare (ignore integer))
  (bug-or-error stream 'stream-write-byte))


;; WRITE-CHAR

(defmethod stream-write-char ((stream ansi-stream) character)
  (cl:write-char character stream))

(defmethod stream-write-char ((stream t) character)
  (declare (ignore character))
  (bug-or-error stream 'stream-write-char))


;; WRITE-SEQUENCE

(defmethod stream-write-sequence ((stream fundamental-character-output-stream) sequence
                                  &optional (start 0) end)
  (si::do-write-sequence sequence stream start end))

(defmethod stream-write-sequence ((stream fundamental-binary-output-stream) sequence
                                  &optional (start 0) end)
  (si::do-write-sequence sequence stream start end))

(defmethod stream-write-sequence ((stream ansi-stream) sequence
                                  &optional (start 0) end)
  (si::do-write-sequence sequence stream start end))

(defmethod stream-write-sequence ((stream t) sequence
                                  &optional start end)
  (declare (ignore sequence start end))
  (bug-or-error stream 'stream-write-sequence))


;; WRITE-STRING

(defmethod stream-write-string ((stream fundamental-character-output-stream)
                                string &optional (start 0) end)
  (declare (type t stream) ; check for c::stream-designator ignored
           (string string)
           (fixnum start)
           (ext:check-arguments-type))
  (let ((end (or end (length string))))
    (declare (fixnum end))
    (do ((pos start (1+ pos)))
        ((>= pos end))
      (declare (type si::index pos))
      (stream-write-char stream (aref string pos))))
  string)

(defmethod stream-write-string ((stream ansi-stream) string &optional (start 0) end)
  (cl:write-string string stream :start start :end end))

(defmethod stream-write-string ((stream t) string &optional start end)
  (declare (ignore string start end))
  (bug-or-error stream 'stream-write-string))


;; TERPRI

(defmethod stream-terpri ((stream fundamental-character-output-stream))
  (stream-write-char stream #\Newline))

(defmethod stream-terpri ((stream ansi-stream))
  (cl:terpri stream))

(defmethod stream-terpri ((stream t))
  (bug-or-error stream 'stream-terpri))


;;; FILE-DESCRIPTOR

(defmethod stream-file-descriptor :before (stream
                                           &optional (direction :input))
  (multiple-value-bind (predicate kind)     
      (case direction
        (:input  (values 'input-stream-p  "input"))
        (:output (values 'output-stream-p "output"))
        (t
         (error 'simple-type-error
                :format-control "Not a valid direction, ~S; must be one of ~
                                 :INPUT or :OUTPUT."
                :format-arguments (list direction)
                :datum direction
                :expected-type '(member :input :output))))
    (unless (funcall predicate stream)
      (error 'simple-type-error
             :format-control "Not an ~A stream, ~S, although ~S ~
                              was provided as DIRECTION."
             :format-arguments (list kind stream direction)
             :datum stream
             :expected-type `(satisfies ,predicate)))))

(defmethod stream-file-descriptor (stream &optional direction)
  (declare (ignore direction))
  (bug-or-error stream 'stream-file-descriptor))

(defmethod stream-file-descriptor ((stream two-way-stream)
                                   &optional (direction :input))
  (stream-file-descriptor
   (case direction
     (:input  (two-way-stream-input-stream stream))
     (:output (two-way-stream-output-stream stream)))
   direction))

(defmethod stream-file-descriptor ((stream file-stream)
                                   &optional (direction :input))
  (declare (ignore direction))
  (si:file-stream-fd stream))


;;; Setup

(eval-when (:compile-toplevel :execute)
  (defconstant +conflicting-symbols+
    '(cl:close cl:stream-element-type cl:input-stream-p
      cl:open-stream-p cl:output-stream-p cl:streamp)))

(let ((p (find-package "GRAY")))
  (export '(nil) p)
  (do-external-symbols (s (find-package "COMMON-LISP"))
    (unless (member s '#.+conflicting-symbols+)
      (export s p))))

;;; Redefining the IO functions
;;
;; I guess that because of efficiency reasons most of the IO functions
;; in CL are normal functions (ie. not generic functions); but that
;; doesn't work with packages like FLEXI-STREAMS that want to define
;; new stream types that work with the same symbols from CL.
;;
;; TRIVIAL-GRAY-STREAMS tries to unify that mess across different
;; implementations, by importing most of (for ECL) GRAY into
;; IMPL-SPECIFIC-GRAY, importing from I-S-G into T-G-S, and
;; overloading/extending there where necessary.
;;
;;
;; REDEFINE-CL-FUNCTIONS should now make the functions that are bound
;; to CL symbols generic functions.
;;
;;
;; So...
;;
;;    CL has a function
;;    GRAY has a function
;;    
;;    TRIVIAL-GRAY-STREAMS imports from GRAY
;;
;; But calling eg. CL:FILE-POSITION should make use of all the methods
;; defined on T-G-S:STREAMS-FILE-POSITION ...
;;

(defun %redefine-cl-functions (cl-symbol gray-symbol gray-package)
  (unless (typep (fdefinition cl-symbol) 'generic-function) 
    (let ((gf (fdefinition gray-symbol)))
      ;; Given a symbol in CL, and one in GRAY, we want to keep the CL
      ;; symbol (in case there are references to it stored somewhere),
      ;; but it shall get the generic-function ...
      (setf (fdefinition cl-symbol) gf)
      ;; and become EQ to the GRAY symbol.
      ;;
      ;; But: unintern/import removes the package from the symbol used
      ;; as name by the GF, making it equivalent to a GENSYM - and
      ;; then no new methods can be registered for it ...
      ;;
      ;; For same symbol-names, we can unintern/import/export;
      ;; for different symbol-names, we can only copy the fdefinition.
      (when (string= (symbol-name cl-symbol)
                    (symbol-name gray-symbol))
        (unintern gray-symbol gray-package)
        (import cl-symbol gray-package)
        (export cl-symbol gray-package))
      ;; so now make the GF accessible again
      (setf (slot-value gf 'clos::name)
            cl-symbol))))

(defun redefine-cl-functions ()
  "Some functions in CL package are expected to be generic. We make
them so."
  (let ((x (si::package-lock "COMMON-LISP" nil))
        (gray-package (find-package "GRAY")))
    (loop for cl-symbol in '#.+conflicting-symbols+
          for gray-symbol = (find-symbol (symbol-name cl-symbol)
                                         gray-package)
          do (%redefine-cl-functions cl-symbol
                                     gray-symbol
                                     gray-package))
    ;; things that are called differently
    (%redefine-cl-functions 'cl:file-position
                            'gray:stream-file-position
                            gray-package)
    (si::package-lock "COMMON-LISP" x)
    nil))

(setf *clos-booted* t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/streams.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./src/clos/builtin.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: CLOS -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1992, Giuseppe Attardi.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

(in-package "CLOS")

;;; ----------------------------------------------------------------------
;;; Methods

;;; ======================================================================
;;; Built-in classes
;;; ----------------------------------------------------------------------

(defmethod make-instance ((class built-in-class) &rest initargs)
  (declare (ignore initargs))
  (error "The built-in class (~A) cannot be instantiated" class))

;;;
;;; At this point we can activate the vector of builtin classes, which
;;; is used by class-of and other functions.
;;;
(si::*make-constant '+builtin-classes+ +builtin-classes-pre-array+)

(defmethod ensure-class-using-class ((class null) name &rest rest)
  (declare (ignore class))
  (multiple-value-bind (metaclass direct-superclasses options)
      (apply #'help-ensure-class rest)
    (declare (ignore direct-superclasses))
    (setf class (apply #'make-instance metaclass :name name options))
    (when name
      (si:create-type-name name)
      (setf (find-class name) class))))

(defmethod change-class ((instance t) (new-class symbol) &rest initargs)
  (apply #'change-class instance (find-class new-class) initargs))

(defmethod make-instances-obsolete ((class symbol))
  (make-instances-obsolete (find-class class))
  class)

(defmethod make-instance ((class-name symbol) &rest initargs)
  (apply #'make-instance (find-class class-name) initargs))

(defmethod slot-makunbound-using-class ((class built-in-class) self slotd)
  (declare (ignore class self slotd))
  (error "SLOT-MAKUNBOUND-USING-CLASS cannot be applied on built-in objects"))

(defmethod slot-boundp-using-class ((class built-in-class) self slotd)
  (declare (ignore class self slotd))
  (error "SLOT-BOUNDP-USING-CLASS cannot be applied on built-in objects"))

(defmethod slot-value-using-class ((class built-in-class) self slotd)
  (declare (ignore class self slotd))
  (error "SLOT-VALUE-USING-CLASS cannot be applied on built-in objects"))

(defmethod (setf slot-value-using-class) (val (class built-in-class) self slotd)
  (declare (ignore class self slotd val))
  (error "SLOT-VALUE-USING-CLASS cannot be applied on built-in objects"))

(defmethod slot-exists-p-using-class ((class built-in-class) self slotd)
  (declare (ignore class self slotd))
  nil)

;;; ======================================================================
;;; STRUCTURES
;;;

;;; structure-classes cannot be instantiated
(defmethod allocate-instance ((class structure-class) &rest initargs)
  (declare (ignore initargs))
  (apply #'si::make-structure class
         (make-list (class-size class) :initial-element (si::unbound))))

(defmethod finalize-inheritance ((class structure-class))
  (call-next-method)
  (dolist (slot (class-slots class))
    (unless (eq :INSTANCE (slot-definition-allocation slot))
      (error "The structure class ~S can't have shared slots" (class-name class)))))

(defmethod make-load-form ((object structure-object) &optional environment)
  (make-load-form-saving-slots object :key environment))

(defmethod print-object ((obj structure-object) stream)
  (let* ((class (si:instance-class obj))
         (slotds (class-slots class)))
    (declare (:read-only class))
    (when (and slotds
               ;; *p-readably* effectively disables *p-level*
               (not *print-readably*)
               *print-level*
               (zerop *print-level*))
      (write-string "#" stream)
      (return-from print-object obj))
    (write-string "#S(" stream)
    (prin1 (class-name class) stream)
    (do ((scan slotds (cdr scan))
         (i 0 (1+ i))
         (limit (or *print-length* most-positive-fixnum))
         (sv))
        ((null scan))
      (declare (fixnum i))
      (when (>= i limit)
        (write-string " ..." stream)
        (return))
      (setq sv (si:instance-ref obj i))
      (write-string " " stream)
      ;; 2.4.8.13 Sharpsign S: slots are keywords
      (prin1 (intern (symbol-name (slot-definition-name (car scan)))
                     (find-package 'keyword))
             stream)
      (write-string " " stream)
      (prin1 sv stream))
    (write-string ")" stream)
    obj))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./src/clos/builtin.lsp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




