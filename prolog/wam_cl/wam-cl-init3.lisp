
(defun (setf find-class) (new-class symbol &optional (errorp t) environment)
  (setf (gethash symbol *class-hash*) new-class)
  new-class)
(setf (find-class 'hash-table) *hash-table*)
(defparameter *structure-object* (makei 1 *standard-class*))
(setf (find-class 'structure-object) *structure-object*)
(defparameter *built-in-class* (makei 1 *standard-class*))
(setf (find-class 't)
      (let ((class (makei 1 *built-in-class* (makei 7 3 't))))
	(setf (iref (iref class 2) 5) (list class))
	(setf (iref (iref class 2) 7) (list *structure-object*))
	class))
(setf (iref *structure-object* 2)
      (makei 7 3 'structure-object (list (find-class 't)) nil
	     (list *structure-object* (find-class 't))))
(defun make-boa-constructor (length struct-class slots lambda-list)
  (eval `#'(lambda ,lambda-list
	     (let ((s (makei ,length ',struct-class
			     ,@(mapcar #'(lambda (arg)
					   (cadr arg))
				       slots))))
	       ,@(mapcar #'(lambda (argument)
			     (unless (member argument lambda-list-keywords)
			       (let ((arg (if (consp argument)
					      (car argument)
					      argument)))
				 `(setf (iref s ,(+ 2 (position arg slots
								:key #'car)))
				   ,arg))))
			 lambda-list)
	       s))))
(defun ensure-struct (name options documentation slots)
  (flet ((option (option-name default)
	   (let ((pair (assoc option-name options)))
	     (if pair (cdr pair) default)))
	 (make-getter (i)
	   #'(lambda (x) (iref x i)))
	 (make-setter (i)
	   #'(lambda (v x) (setf (iref x i) v))))
    (let* ((struct-class (makei 1 *structure-class* (makei 7 3)))
	   (conc-name (option :conc-name (conc-string name "-")))
	   (constructor (option :constructor nil))
	   (predicate (option :predicate t))
	   (include (option :include nil))
	   (super (if (car include)
		      (find-class (car include))
		      *structure-object*))
	   (effective-slots
	    (append (unless (eq super *structure-object*)
		      (mapcar #'(lambda (slot)
				  (let ((m (member (car slot) (cdr include)
						   :key #'car)))
				    (if m (car m) slot)))
			      (iref (iref super 2) 6)))
		    slots)))
      (when (eq predicate t)
	(setq predicate (list (intern (conc-string name "-P")))))
      (when predicate
	(setf (fdefinition (car predicate))
	      #'(lambda (object) (and (= (ldb '(2 . 0) (ival object)) 2)
				      (eq struct-class (iref object 1))))))
      (unless constructor
	(setq constructor (list (intern (conc-string "MAKE-" name)))))
      (dolist (slot-description (cdr include))
	(let ((slot (assoc (car slot-description) effective-slots)))
	  (setf (cdr slot) (cdr slot-description))))
      (setf (iref (iref struct-class 2) 2) name)
      (setf (iref (iref struct-class 2) 3) (list super))
      (setf (iref (iref struct-class 2) 4) (length effective-slots))
      (setf (iref (iref struct-class 2) 5)
	    (cons struct-class (iref (iref super 2) 5)))
      (setf (iref (iref struct-class 2) 6) effective-slots)
      (when (car constructor)
	(setf (fdefinition (car constructor))
	      (make-boa-constructor (length effective-slots)
				    struct-class effective-slots
				    (cadr constructor))))
      (let ((i 2))
	(dolist (slot effective-slots)
	  (let ((accessor (intern (conc-string conc-name (car slot)))))
	    (setf (fdefinition accessor) (make-getter i))
	    (setf (fdefinition `(setf ,accessor)) (make-setter i))
	    (setf i (+ 1 i)))))
      (setf (find-class name) struct-class)))
  name)
(defmacro defstruct (name-and-options &rest slot-descriptions)
  (let ((options nil)
	(documentation nil)
	(slots nil))
    (when (consp name-and-options)
      (setf options (cdr name-and-options))
      (setf name-and-options (car name-and-options)))
    (when (stringp (car slot-descriptions))
      (setf documentation (pop slot-descriptions)))
  `(ensure-struct ',name-and-options ',(mapcar #'designator-list options)
    ,documentation ',(mapcar #'designator-list slot-descriptions))))
(defun copy-structure (structure)
  (let* ((length (iref structure 0))
	 (i 0)
	 (copy (makei length (iref structure 1))))
    (tagbody
     start
       (when (< i length)
	 (setf (iref copy (+ 2 i)) (iref structure (+ 2 i)))
	 (incf i)
	 (go start)))
    copy))
'restart-report-function
(defstruct (restart
	     (:constructor make-restart (name function
					      &key interactive-function
					      report-function test-function))
	     (:predicate restartp))
  name
  function
  interactive-function
  report-function
  test-function)
(defun ansi-stream-read-bytes (stream string start)
  (funcall (stream-class-read-bytes (ansi-stream-stream-class stream))
	   stream string start))
(defun ansi-stream-write-bytes (stream string start end)
  (funcall (stream-class-write-bytes (ansi-stream-stream-class stream))
	   stream string start end))
(defun ansi-stream-listen (stream)
  (funcall (stream-class-listen (ansi-stream-stream-class stream))
	   stream))
(defun ansi-stream-finish (stream flag)
  (funcall (stream-class-finish (ansi-stream-stream-class stream))
	   stream flag))
(defun ansi-stream-close (stream)
  (funcall (stream-class-close (ansi-stream-stream-class stream))
	   stream))
(defun fd-stream-read-bytes (stream string start)
  (read-file-stream (fd-stream-file-stream stream) string start))
(defun fd-stream-write-bytes (stream string start end)
  (write-file-stream (fd-stream-file-stream stream) string start end))
(defun fd-stream-listen (stream)
  (listen-file-stream (fd-stream-file-stream stream)))
(defun fd-stream-finish (stream flag)
  (finish-file-stream (fd-stream-file-stream stream)))
(defun fd-stream-close (stream)
  (close-file-stream (fd-stream-file-stream stream)))
(defun string-stream-read-bytes (stream string start)
  (let* ((length (min (- (length string) start)
		      (- (string-stream-end stream)
			 (string-stream-start stream))))
	 (end (+ (string-stream-start stream) length)))
    (setf (subseq string start)
	  (subseq (string-stream-string stream)
		  (string-stream-start stream) end))
    (setf (string-stream-start stream) end)
    length))
(defun string-stream-write-bytes (stream string start end)
  (let ((write-length (- end start))
	(stream-length (length (string-stream-string stream))))
    (when (< (- stream-length (string-stream-end stream)) write-length)
      (let* ((new-length (max (* 2 stream-length)
			     (+ stream-length write-length)))
	     (new-string (make-string new-length)))
	(setf (subseq new-string 0 (string-stream-end stream))
	      (string-stream-string stream))
	(setf (string-stream-string stream) new-string)))
    (let ((new-end (+ (string-stream-end stream) write-length)))
      (setf (subseq (string-stream-string stream)
		    (string-stream-end stream) new-end)
	    (subseq string start end))
      (setf (string-stream-end stream) new-end))
    write-length))
(defun string-stream-listen (stream) t)
(defun string-stream-finish (stream flag) nil)
(defun string-stream-close (stream) nil)
(defun concatenated-stream-read-bytes (stream string start)
  (let ((streams (concatenated-stream-streams stream)))
    (if streams
	(ansi-stream-read-bytes (car streams) string start)
	0)))
(defun concatenated-stream-write-bytes (stream string start end)
  (let ((streams (concatenated-stream-streams stream)))
    (if streams
	(ansi-stream-write-bytes (car streams) string start end)
	0)))
(defun concatenated-stream-listen (stream)
  (let ((streams (concatenated-stream-streams stream)))
    (if streams
	(ansi-stream-listen (car streams))
	t)))
(defun concatenated-stream-finish (stream flag)
  (let ((streams (concatenated-stream-streams stream)))
    (if streams
	(ansi-stream-finish (car streams) flag)
	nil)))
(defun concatenated-stream-close (stream) nil)
(defun echo-stream-read-bytes (stream string start)
  (let ((length (ansi-stream-read-bytes (echo-stream-input-stream stream)
					string start)))
    (ansi-stream-write-bytes (echo-stream-output-stream stream)
			     string start (+ start length))
    length))
(defun echo-stream-write-bytes (stream string start end)
  (ansi-stream-write-bytes (echo-stream-output-stream stream)
			   string start end))
(defun echo-stream-listen (stream)
  (ansi-stream-listen (echo-stream-input-stream stream)))
(defun echo-stream-finish (stream flag)
  (ansi-stream-finish (echo-stream-output-stream stream) flag))
(defun echo-stream-close (stream) nil)
(defun two-way-stream-read-bytes (stream string start)
  (ansi-stream-read-bytes (two-way-stream-input-stream stream) string start))
(defun two-way-stream-write-bytes (stream string start end)
  (ansi-stream-write-bytes (two-way-stream-output-stream stream)
			   string start end))
(defun two-way-stream-listen (stream)
  (ansi-stream-listen (two-way-stream-input-stream stream)))
(defun two-way-stream-finish (stream flag)
  (ansi-stream-finish (two-way-stream-output-stream stream) flag))
(defun two-way-stream-close (stream) nil)
(defun broadcast-stream-read-bytes (stream string start)
  (error "cannot read from a broadcast stream"))
(defun broadcast-stream-write-bytes (stream string start end)
  (dolist (s (broadcast-stream-streams stream))
    (ansi-stream-write-bytes s string start end)))
(defun broadcast-stream-listen (stream)
  (error "cannot listen a broadcast stream"))
(defun broadcast-stream-finish (stream flag)
  (dolist (s (broadcast-stream-streams stream))
    (ansi-stream-finish s flag)))
(defun broadcast-stream-close (stream) nil)
(defun synonym-stream-read-bytes (stream string start)
  (ansi-stream-read-bytes (symbol-value (synonym-stream-symbol stream))
			  string start))
(defun synonym-stream-write-bytes (stream string start end)
  (ansi-stream-write-bytes (symbol-value (synonym-stream-symbol stream))
			   string start end))
(defun synonym-stream-listen (stream)
  (ansi-stream-listen (symbol-value (synonym-stream-symbol stream))))
(defun synonym-stream-finish (stream flag)
  (ansi-stream-finish (symbol-value (synonym-stream-symbol stream)) flag))
(defun synonym-stream-close (stream) nil)
(defun init-known-streams ()
  (setq *fd-stream-class* (make-stream-class #'fd-stream-read-bytes
					     #'fd-stream-write-bytes
					     #'fd-stream-listen
					     #'fd-stream-finish
					     #'fd-stream-close))
  (setq *string-stream-class* (make-stream-class #'string-stream-read-bytes
						 #'string-stream-write-bytes
						 #'string-stream-listen
						 #'string-stream-finish
						 #'string-stream-close))
  (setq *concatenated-stream-class*
	(make-stream-class #'concatenated-stream-read-bytes
			   #'concatenated-stream-write-bytes
			   #'concatenated-stream-listen
			   #'concatenated-stream-finish
			   #'concatenated-stream-close))
  (setq *echo-stream-class* (make-stream-class #'echo-stream-read-bytes
					       #'echo-stream-write-bytes
					       #'echo-stream-listen
					       #'echo-stream-finish
					       #'echo-stream-close))
  (setq *two-way-stream-class* (make-stream-class #'two-way-stream-read-bytes
						  #'two-way-stream-write-bytes
						  #'two-way-stream-listen
						  #'two-way-stream-finish
						  #'two-way-stream-close))
  (setq *broadcast-stream-class*
	(make-stream-class #'broadcast-stream-read-bytes
			   #'broadcast-stream-write-bytes
			   #'broadcast-stream-listen
			   #'broadcast-stream-finish
			   #'broadcast-stream-close))
  (setq *synonym-stream-class* (make-stream-class #'synonym-stream-read-bytes
						  #'synonym-stream-write-bytes
						  #'synonym-stream-listen
						  #'synonym-stream-finish
						  #'synonym-stream-close))
  (setq *standard-input* (make-fd-stream :input *standard-input*))
  (setq *standard-output* (make-fd-stream :output *standard-output*))
  (setq *error-output* (make-fd-stream :output *error-output*))
  (setq *debug-io* (make-two-way-stream *standard-input* *standard-output*))
  nil)
(defstruct (stream-class
	     (:constructor make-stream-class (read-bytes write-bytes listen
							 finish close)))
  read-bytes
  write-bytes
  listen
  finish
  close)
(defun input-stream-p (stream)
  (member (ansi-stream-direction stream) '(:input :io)))
(defun output-stream-p (stream)
  (member (ansi-stream-direction stream) '(:output :io)))
(defun interactive-stream-p (stream) "FIXME" t)
(defun open-stream-p (stream) (not (null (iref stream 3))))
(defun stream-element-type (stream) 'character)
(defun streamp (object)
  (member (find-class 'ansi-stream)
	  (class-precedence-list (class-of object))))
(defun read-byte (stream &optional (eof-error-p t) eof-value)
  (let ((c (prim-read-char stream)))
    (if c
	(char-code c)
	(if eof-error-p (error 'end-of-file :stream stream) eof-value))))
(defun write-byte (byte stream)
  (ansi-stream-write-bytes stream
			   (make-string 1 :initial-element (code-char byte))
			   0 1)
  (setf (ansi-stream-line-start stream) (= byte 10))
  byte)
(defun prim-read-char (stream)
  (if (ansi-stream-unread stream)
      (prog1 (ansi-stream-unread stream)
	(setf (ansi-stream-unread stream) nil))
      (let ((string (make-string 1)))
	(when (= (ansi-stream-read-bytes stream string 0) 1)
	  (aref string 0)))))
(defun make-fd-stream (direction file-stream)
  (construct-fd-stream *fd-stream-class* direction file-stream))
(defstruct ansi-stream
  stream-class
  direction
  unread
  (line-start t))
(defstruct (fd-stream
	     (:constructor construct-fd-stream
			   (stream-class direction file-stream))
	     (:include ansi-stream))
  file-stream)
(defstruct (string-stream
	     (:constructor construct-string-stream
			   (stream-class direction string start end))
	     (:include ansi-stream))
  string
  start
  end)
(defstruct (concatenated-stream
	     (:constructor construct-concatenated-stream (stream-class streams))
	     (:include ansi-stream (direction :input)))
  streams)
(defstruct (echo-stream
	     (:constructor make-echo-stream (input-stream output-stream))
	     (:include ansi-stream
		       (stream-class *echo-stream-class*)
		       (direction :io)))
  input-stream
  output-stream)
(defstruct (two-way-stream
	     (:constructor make-two-way-stream (input-stream output-stream))
	     (:include ansi-stream
		       (stream-class *two-way-stream-class*)
		       (direction :io)))
  input-stream
  output-stream)
(defstruct (broadcast-stream
	     (:constructor construct-broadcast-stream (streams))
	     (:include ansi-stream
		       (stream-class *broadcast-stream-class*)
		       (direction :output)))
  streams)
(defstruct (synonym-stream
	     (:constructor make-synonym-stream (symbol))
	     (:include ansi-stream (stream-class *synonym-stream-class*)))
  symbol)
(defun designator-input-stream (input-stream)
  (if (streamp input-stream)
      input-stream
      *standard-input*))
(defun designator-output-stream (output-stream)
  (if (streamp output-stream)
      output-stream
      *standard-output*))
(defun peek-char (&optional peek-type (input-stream *standard-input*)
		  (eof-error-p t) eof-value recursive-p)
  (setq input-stream (designator-input-stream input-stream))
  (tagbody
   start
     (let ((c (prim-read-char input-stream)))
       (unless c (if eof-error-p
		     (error 'end-of-file :stream input-stream)
		     (return-from peek-char eof-value)))
       (when (or (not peek-type)
		 (and (characterp peek-type) (char= c peek-type))
		 (not (eq (aref (readtable-function *readtable*) (char-code c))
			  :whitespace)))
	 (unread-char c input-stream)
	 (return-from peek-char c)))
     (go start)))
(defun read-char (&optional (input-stream *standard-input*) (eof-error-p t)
		  eof-value recursive-p)
  (setq input-stream (designator-input-stream input-stream))
  (or (prim-read-char input-stream)
      (if eof-error-p (error 'end-of-file :stream input-stream) eof-value)))
(defun read-char-no-hang (&optional (input-stream *standard-input*)
			  (eof-error-p t) eof-value recursive-p)
  (setq input-stream (designator-input-stream input-stream))
  (if (ansi-stream-unread input-stream)
      (prog1 (ansi-stream-unread input-stream)
	(setf (ansi-stream-unread input-stream) nil))
      (and (listen-file-stream input-stream)
	   (read-char input-stream eof-error-p eof-value recursive-p))))
(defun terpri (&optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (write-byte 10 output-stream)
  nil)
(defun fresh-line (&optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (and (not (ansi-stream-line-start output-stream))
       (write-byte 10 output-stream)))
(defun unread-char (character &optional (input-stream *standard-input*))
  (setq input-stream (designator-input-stream input-stream))
  (setf (ansi-stream-unread input-stream) character))
(defun write-char (character &optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (write-file-stream (make-string 1 :initial-character character) 0 1)
  (setf (ansi-stream-line-start output-stream) (= (char-code character) 10))
  character)
(defun read-line (&optional (input-stream *standard-input*) (eof-error-p t)
		  eof-value recursive-p)
  (setq input-stream (designator-input-stream input-stream))
  (let ((result nil)
	(end nil))
    (tagbody
     start
       (let ((c (read-char input-stream eof-error-p eof-value recursive-p)))
	 (unless c
	   (if eof-error-p
	       (error 'end-of-file :stream input-stream)
	       (return-from read-line
		 (values (when result (apply #'string result)) t))))
	 (unless (= (char-code c) 10)
	   (setf end (if end
			 (setf (cdr end) (list c))
			 (setf result (list c))))
	   (go start))))
    (apply #'string result)))
(defun write-string (string &optional (output-stream *standard-output*)
		     &key (start 0) (end nil))
  (setq output-stream (designator-output-stream output-stream))
  (unless end (setf end (length string)))
  (when (< start end)
    (ansi-stream-write-bytes output-stream string start end)
    (setf (ansi-stream-line-start output-stream)
	  (= (char-code (aref string (- end 1))) 10)))
  string)
(defun write-line (string &optional (output-stream *standard-output*)
		   &key (start 0) (end nil))
  (setq output-stream (designator-output-stream output-stream))
  (unless end (setf end (length string)))
  (ansi-stream-write-bytes output-stream string start end)
  (ansi-stream-write-bytes output-stream
			   (make-string 1 :initial-element (code-char 10))
			   0 1)
  (setf (ansi-stream-line-start output-stream) t)
  string)
(defun read-sequence (sequence stream &key (start 0) end)
  (if (eq (type-of sequence) 'string)
      (+ start (ansi-stream-read-bytes stream sequence start))
      (let ((index start))
	(tagbody
	 start
	   (when (< index end)
	     (let ((byte (read-byte stream nil nil)))
	       (when byte
		 (setf (aref sequence index) byte)
		 (setf index (+ 1 index))
		 (go start)))))
	index)))
(defun write-sequence (sequence stream &key (start 0) end)
  (if (eq (type-of sequence) 'string)
      (write-string sequence stream start end)
      (let ((index start))
	(unless end (setf end (length sequence)))
	(tagbody
	 start
	   (when (< index end)
	     (write-byte (aref sequence index) stream)
	     (setf index (+ 1 index))
	     (go start)))
	sequence)))
(defun file-length (stream)
  "FIXME"
  nil)
(defun file-position (stream &optional position-spec)
  "FIXME"
  nil)
(defun file-string-length (stream object)
  (if (stringp object)
      (length object)
      1))
(defun open (filespec &key (direction :input) (element-type 'character)
	     (if-exists :new-version) (if-does-not-exist "FIXME")
	     (external-format :default))
  (make-fd-stream direction
		  (make-file-stream filespec (eq direction :output))))
(defun stream-external-format (stream)
  :default)
(defmacro with-open-file ((stream filespec &rest options) &rest body)
  `(let ((,stream (open ,filespec ,@options)))
    (unwind-protect
	 (progn ,@body)
      (close ,stream))))
(defun close (stream &key abort)
  (ansi-stream-close stream)
  t)
(defmacro with-open-stream ((var stream) &rest body)
  `(let ((,var ,stream))
    (unwind-protect
	 (progn ,@body)
      (close ,var))))
(defun listen (&optional (input-stream *standard-input*))
  (setq input-stream (designator-input-stream input-stream))
  (ansi-stream-listen input-stream))
(defun clear-input (&optional (input-stream *standard-input*))
  (setq input-stream (designator-input-stream input-stream))
  (tagbody
   start
     (when (peek-char nil input-stream)
       (read-char input-stream)
       (go start))))
(defun finish-output (&optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (ansi-stream-finish output-stream :finish))
(defun force-output (&optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (ansi-stream-finish output-stream :force))
(defun clear-output (&optional (output-stream *standard-output*))
  (setq output-stream (designator-output-stream output-stream))
  (ansi-stream-finish output-stream :clear))
(defun y-or-n-p (&optional control &rest arguments)
  (when control
    (fresh-line *query-io*)
    (apply #'format *query-io* control arguments))
  (write-string " (Y or N) " *query-io*)
  (member (read-byte *query-io*) '(89 121)))
(defun yes-or-no-p (&optional control &rest arguments)
  (when control
    (fresh-line *query-io*)
    (apply #'format *query-io* control arguments))
  (write-string " (Yes or No) " *query-io*)
  (string= (read-line *query-io*) "yes"))
(defun make-broadcast-stream (&rest streams)
  (construct-broadcast-stream streams))
(defun make-concatenated-stream (&rest input-streams)
  (construct-concatenated-stream *concatenated-stream-class* input-streams))
(defun make-string-input-stream (string &optional (start 0) end)
  (unless end (setq end (length string)))
  (construct-string-stream *string-stream-class* :input string start end))
(defmacro with-input-from-string ((var string &key index (start 0) end)
				  &rest forms)
  `(let ((,var (make-string-input-stream ,string ,start ,end)))
    (unwind-protect
	 (progn ,@forms)
      ,@(when index `(setf ,place (string-stream-start ,var)))
      (close ,var))))
(defun make-string-output-stream (&key (element-type 'character))
  (let ((string (make-string 256)))
    (construct-string-stream *string-stream-class* :output string 0 0)))
(defun get-output-stream-string (string-output-stream)
  (prog1
      (subseq (string-stream-string string-output-stream)
	      0 (string-stream-end string-output-stream))
    (setf (string-stream-end string-output-stream) 0)))
(defmacro with-output-to-string ((var &optional string-form
				      &key (element-type 'character))
				 &rest forms)
  `(let ((,var (make-string-output-stream :element-type ',element-type)))
    (unwind-protect
	 (progn ,@forms)
      (close ,var))
    (get-output-stream-string ,var)))
(defun make-standard-pprint-dispatch ()
  nil)
(defparameter *standard-pprint-dispatch* (make-standard-pprint-dispatch))
(defparameter *print-array* t)
(defparameter *print-base* 10)
(defparameter *print-radix* nil)
(defparameter *print-case* :upcase)
(defparameter *print-circle* nil)
(defparameter *print-escape* t)
(defparameter *print-gensym* t)
(defparameter *print-level* nil)
(defparameter *print-length* nil)
(defparameter *print-lines* nil)
(defparameter *print-miser-width* 40)
(defparameter *print-pprint-dispatch* *standard-pprint-dispatch*)
(defparameter *print-pretty* nil)
(defparameter *print-readably* nil)
(defparameter *print-right-margin* nil)
(defun write (object &key (array *print-array*) (base *print-base*)
	      (case *print-case*) (circle *print-circle*)
	      (escape *print-escape*) (gensym *print-gensym*)
	      (length *print-length*) (level *print-level*)
	      (lines *print-lines*) (miser-width *print-miser-width*)
	      (pprint-dispatch *print-pprint-dispatch*) (pretty *print-pretty*)
	      (radix *print-radix*) (readably *print-readably*)
	      (right-margin *print-right-margin*) (stream *standard-output*))
  (let ((*print-array* array)
	(*print-base* base)
	(*print-case* case)
	(*print-circle* circle)
	(*print-escape* escape)
	(*print-gensym* gensym)
	(*print-length* length)
	(*print-level* level)
	(*print-lines* lines)
	(*print-miser-width* miser-width)
	(*print-pprint-dispatch* pprint-dispatch)
	(*print-pretty* pretty)
	(*print-radix* radix)
	(*print-readably* readably)
	(*print-right-margin* right-margin))
    (if *print-pretty*
	(error "pretty printer not implemented")
	(print-object object stream)))
  object)
(defun prin1 (object &optional (output-stream *standard-output*))
  (write object :stream output-stream :escape t))
(defun princ (object &optional (output-stream *standard-output*))
  (write object :stream output-stream :escape nil :readably nil))
(defun write-to-string (object &rest rest)
  (with-output-to-string (stream)
    (apply #'write object :stream stream rest)))
(defun prin1-to-string (object)
  (with-output-to-string (*standard-output*)
    (prin1 object)))
(defun princ-to-string (object)
  (with-output-to-string (*standard-output*)
    (princ object)))
(defun parse-control-string (control-string)
  (let ((result nil)
	(i 0)
	(j nil))
    (tagbody
     start
       (when (< i (length control-string))
	 (when (= (char-code (aref control-string i)) 126)
	   (when j (push (subseq control-string j i) result))
	   (setf i (+ 1 i))
	   (let ((code (char-code (char-upcase (aref control-string i))))
		 (colonp nil)
		 (atp nil)
		 (args nil))
	     (tagbody
	      next
		(case code
		  (39 (push (aref control-string (incf i)) args)
		      (incf i))
		  (44 (incf i))
		  (58 (setq colonp t)
		      (incf i))
		  (64 (setq atp t)
		      (incf i))
		  ((43 45 48 49 50 51 52 53 54 55 56 57)
		   (multiple-value-bind (integer pos)
		       (parse-integer control-string :start i :junk-allowed t)
		     (setq i pos)
		     (push integer args)))
		  (t
		   (push (list* code colonp atp (reverse args)) result)
		   (go end)))
		(setq code (char-code (char-upcase (aref control-string i))))
		(go next)
	      end))
	   (setf j (+ 1 i)))
	 (unless j (setf j i))
	 (setf i (+ 1 i))
	 (go start))
       (when (< j i)
	 (push (subseq control-string j i) result)))
    (reverse result)))
(defun format-function (control-string)
  #'(lambda (output-stream &rest arguments)
      (let ((program (parse-control-string control-string)))
	(dolist (elem program)
	  (if (stringp elem)
	      (write-string elem output-stream)
	      (let ((colonp (cadr elem))
		    (atp (caddr elem))
		    (params (cdddr elem)))
		(case (car elem)
		  (37 (dotimes (n (or (car params) 1))
			(terpri output-stream)))
		  (38 (fresh-line output-stream)
		      (dotimes (n (- (or (car params) 1) 1))
			(terpri output-stream)))
		  (65 (princ (pop arguments) output-stream))
		  (66 (let ((*print-radix* nil)
			    (*print-base* 2))
			(princ (pop arguments) output-stream)))
		  (67 (write-char (pop arguments) output-stream))
		  (68 (let ((*print-radix* nil)
			    (*print-base* 10))
			(princ (pop arguments) output-stream)))
		  (79 (let ((*print-radix* nil)
			    (*print-base* 8))
			(princ (pop arguments) output-stream)))
		  (82 (let ((*print-radix* nil)
			    (*print-base* (car params)))
			(princ (pop arguments) output-stream)))
		  (83 (prin1 (pop arguments) output-stream))
		  (87 (write (pop arguments) :stream output-stream))
		  (88 (let ((*print-radix* nil)
			    (*print-base* 16))
			(princ (pop arguments) output-stream)))
		  (124 (dotimes (n (or (car params) 1))
			 (write-byte 12 output-stream)))
		  (126 (dotimes (n (or (car params) 1))
			 (write-byte 126 output-stream)))
		  (t (error "unimplemented format character")))))))))
(defmacro formatter (control-string)
  `(format-function ,control-string))
(defmacro print-unreadable-object ((object stream &key type identity)
				   &rest forms)
  (let ((object-var (gensym))
	(stream-var (gensym))
	(typep (gensym))
	(identityp (gensym)))
    `(if *print-readably*
      (error 'print-not-readable :object object)
      (let ((,object-var ,object)
	    (,stream-var ,stream)
	    (,typep ,type)
	    (,identityp ,identity))
	(write-string "#<" ,stream-var)
	(when ,typep
	  (princ (type-of ,object-var) ,stream-var)
	  (write-byte 32 ,stream-var))
	,@forms
	(when ,identityp
	  (unless (and ,(not forms) ,typep)
	    (write-byte 32 ,stream-var))
	  (princ (ival ,object-var) ,stream-var))
	(write-string ">" ,stream-var)
	nil))))
(defun format (destination control-string &rest args)
  (if destination
      (progn (apply (formatter control-string) destination args) nil)
      (with-output-to-string (destination)
	(apply (formatter control-string) destination args))))
(defmacro with-standard-io-syntax (&rest forms)
  `(let ((*package* (find-package "CL-USER"))
	 (*print-array* t)
	 (*print-base* 10)
	 (*print-case* :upcase)
	 (*print-circle* nil)
	 (*print-escape* t)
	 (*print-gensym* t)
	 (*print-length* nil)
	 (*print-level* nil)
	 (*print-lines* nil)
	 (*print-miser-width* nil)
	 (*print-pprint-dispatch* *standard-pprint-dispatch*)
	 (*print-pretty* nil)
	 (*print-radix* nil)
	 (*print-readably* t)
	 (*print-right-margin* nil)
	 (*read-base* 10)
	 (*read-default-float-format* 'single-float)
	 (*read-eval* t)
	 (*read-suppress* nil)
	 (*readtable* *standard-readtable*))
    ,@forms))
(defun copy-readtable (&optional (from-readtable *readtable*) to-readtable)
  (unless to-readtable
    (setq to-readtable (make-readtable)))
  (setf (readtable-case to-readtable) (readtable-case from-readtable))
  (setf (readtable-function to-readtable)
	(copy-sequence (readtable-function from-readtable)))
  (let ((i 0))
    (tagbody
     start
       (when (< i 256)
	 (when (arrayp (aref (readtable-function to-readtable) i))
	   (setf (aref (readtable-function to-readtable) i)
		 (copy-sequence (aref (readtable-function to-readtable) i))))
	 (incf i)
	 (go start))))
  (setf (readtable-non-terminating-p to-readtable)
	(copy-sequence (readtable-non-terminating-p from-readtable)))
  to-readtable)
(defun make-dispatch-macro-character (char &optional non-terminating-p
				      (readtable *readtable*))
  (let ((code (char-code char)))
    (setf (aref (readtable-function readtable) code) (make-array 256))
    (setf (aref (readtable-non-terminating-p readtable) code)
	  non-terminating-p))
  t)
(defun parse-integer (string &key (start 0) end (radix 10) junk-allowed)
  (unless end (setq end (length string)))
  (let ((state :sign)
	(minusp nil)
	(digits nil))
    (flet ((finish ()
	     (return-from parse-integer
	       (values (let ((n 0))
			 (dolist (digit (reverse digits) (if minusp (- n) n))
			   (setq n (+ digit (* radix n)))))
		       start))))
      (tagbody
       start
	 (when (< start end)
	   (let* ((char (aref string start))
		  (c (char-code char)))
	     (case state
	       (:sign (setq state :integer-start)
		      (case c
			(45 (setq minusp t))
			(43)
			(t (go start))))
	       ((:integer-start :integer)
		(setq state :integer)
		(let ((w (digit-char-p char radix)))
		  (if w
		      (push w digits)
		      (if junk-allowed
			  (finish)
			  (error 'parse-error)))))))
	 (incf start)
	 (go start)))
      (when (member state '(:sign :integer-start))
	(error 'parse-error))
      (finish))))
(defun parse-number (string &key (start 0) end)
  (unless end (setq end (length string)))
  (let ((state :sign)
	(minusp nil)
	(digits nil)
	(exponent nil)
	(exponent-minusp nil)
	(exponent-digits nil)
	(fraction-digits nil))
    (tagbody
     start
       (when (< start end)
	 (let* ((char (aref string start))
		(c (char-code char)))
	   (case state
	     (:sign (setq state :integer-start)
		    (case c
		      (45 (setq minusp t))
		      (43)
		      (t (go start))))
	     (:integer-start (if (= c 46)
				 (setq state :after-point)
				 (progn
				   (setq state :integer)
				   (push (digit-char-p char *read-base*)
					 digits))))
	     (:integer (case c
			 (46 (setq state :after-point))
			 (47 (setq state :denominator))
			 ((68 100)
			  (setq exponent :double)
			  (setq state :exponent-sign))
			 ((69 101)
			  (setq exponent :float)
			  (setq state :exponent-sign))
			 ((70 102)
			  (setq exponent :single-float)
			  (setq state :exponent-sign))
			 ((76 108)
			  (setq exponent :long-float)
			  (setq state :exponent-sign))
			 ((83 115)
			  (setq exponent :short-float)
			  (setq state :exponent-sign))
			 (t (push (digit-char-p char *read-base*) digits))))
	     ((:after-point :fraction)
	      (setq state :fraction)
	      (case c
		((68 100)
		 (setq exponent :double)
		 (setq state :exponent-sign))
		((69 101)
		 (setq exponent :float)
		 (setq state :exponent-sign))
		((70 102)
		 (setq exponent :single-float)
		 (setq state :exponent-sign))
		((76 108)
		 (setq exponent :long-float)
		 (setq state :exponent-sign))
		((83 115)
		 (setq exponent :short-float)
		 (setq state :exponent-sign))
		(t (push (digit-char-p char *read-base*) fraction-digits))))
	     (:denominator (push (digit-char-p char *read-base*)
				 fraction-digits))
	     (:exponent-sign (setq state :exponent)
			     (case c
			       (45 (setq exponent-minusp t))
			       (43)
			       (t (go start))))
	     (:exponent (push (digit-char-p char *read-base*)
			      exponent-digits))))
	 (incf start)
	 (go start)))
    (case state
      ((:integer :after-point)
       (let ((n 0))
	 (dolist (digit (reverse digits) (if minusp (- n) n))
	   (setq n (+ digit (* *read-base* n))))))
      (:denominator (list :ratio (reverse digits) (reverse fraction-digits)))
      ((:fraction :exponent)
       (list exponent (reverse digits) (reverse fraction-digits)
	     (reverse exponent-digits)))
      (t (error 'reader-error)))))
(defun read (&optional input-stream (eof-error-p t) eof-value recursive-p)
  (let ((value (read-internal input-stream eof-error-p eof-value recursive-p
			      nil nil t)))
    (if *read-suppress* nil value)))
(defun read-internal (input-stream eof-error-p eof-value recursive-p
		      preserving-whitespace token-chars convertp)
  (let* ((function (readtable-function *readtable*))
	 (non-terminating-p (readtable-non-terminating-p *readtable*))
	 (case (readtable-case *readtable*))
	 (symbol nil)
	 (c nil)
	 (f nil))
    (tagbody
       (when token-chars (go even))
     start
       (setq c (read-char input-stream eof-error-p eof-value recursive-p))
       (setq f (aref function (char-code c)))
       (when (eq f :whitespace)
	 (go start))
       (when (or (arrayp f) (functionp f))
	 (let ((values (multiple-value-list
			(if (arrayp f)
			    (let ((infix nil))
			      (tagbody
			       start
				 (setq c (read-char input-stream t nil t))
				 (let ((w (digit-char-p c)))
				   (when w
				     (setq infix (+ (* 10 (or infix 0)) w))
				     (go start))))
			      (funcall (aref f (char-code c))
				       input-stream c infix))
			    (funcall f input-stream c)))))
	   (if values
	       (return-from read-internal (car values))
	       (go start))))
       (when (eq f :single-escape)
	 (push (read-char input-stream t nil recursive-p) token-chars)
	 (go even))
       (when (eq f :multiple-escape)
	 (go odd))
     push
       (push (case case
	       (:upcase (char-upcase c))
	       (:downcase (char-downcase c))
	       (t c))
	     token-chars)
     even
       (setq c (read-char input-stream nil nil recursive-p))
       (unless c
	 (go token))
       (setq f (aref function (char-code c)))
       (when (or (not f) (aref non-terminating-p (char-code c)))
	 (go push))
       (when (eq f :single-escape)
	 (setq symbol t)
	 (push (read-char input-stream t nil recursive-p) token-chars)
	 (go even))
       (when (eq f :multiple-escape)
	 (setq symbol t)
	 (go odd))
       (when (or preserving-whitespace (functionp f))
	 (unread-char c input-stream))
       (go token)
     odd
       (setq c (read-char input-stream t nil recursive-p))
       (setq f (aref function (char-code c)))
       (when (eq f :single-escape)
	 (push (read-char input-stream t nil recursive-p) token-chars)
	 (go odd))
       (when (eq f :multiple-escape)
	 (go even))
       (push c token-chars)
       (go odd)
     token
       (when (member (char-code (car token-chars)) '(43 45))
	 (setq symbol t))
       (let ((point nil)
	     (low-digit nil)
	     (high-digit nil)
	     (previous-alphabetic nil))
	 (dolist (char token-chars)
	   (when (= (char-code char) 46)
	     (setq point t))
	   (let ((weight (digit-char-p char *read-base*)))
	     (when weight
	       (if (< weight 10)
		   (setq low-digit t)
		   (setq high-digit t))))
	   (let ((alphabetic (alpha-char-p char)))
	     (when (and previous-alphabetic alphabetic)
	       (setq symbol t))
	     (setq previous-alphabetic alphabetic)))
	 (unless (or low-digit (and high-digit (not point)))
	   (setq symbol t)))
       (let ((string (apply #'string (reverse token-chars))))
	 (return-from read-internal
	   (if convertp
	       (if symbol
		   (let ((colon-position (position (char-code 58) string)))
		     (if colon-position
			 (if (= colon-position 0) (intern (subseq string 1) "KEYWORD")
			   (multiple-value-bind (symbol status)
			       (find-symbol (subseq string (+ 1 colon-position))
					    (subseq string 0 colon-position))
			     (if (eq status :external)
				 symbol
			       (error 'reader-error))))
		       (intern string)))
		 (parse-number string))
	     string))))))
(defun read-preserving-whitespace (&optional input-stream (eof-error-p t)
				   eof-value recursive-p)
  (let ((value (read-internal input-stream eof-error-p eof-value recursive-p
			      t nil t)))
    (if *read-suppress* nil value)))
(defun read-delimited-list (char &optional input-stream recursive-p)
  (let ((result nil))
    (tagbody
     start
       (let ((c (peek-char t input-stream t nil t)))
	 (when (char= c char)
	   (read-char input-stream)
	   (return-from read-delimited-list (reverse result))))
       (push (read input-stream t nil t) result)
       (go start))))
(defun read-from-string (string &optional (eof-error-p t) eof-value
			 &key (start 0) end preserve-whitespace)
  (let ((index nil))
    (values (with-input-from-string (stream string :index index
					    :start start :end end)
	      (if preserve-whitespace
		  (read-preserving-whitespace stream eof-error-p eof-value)
		  (read stream eof-error-p eof-value)))
	    index)))
(defun get-dispatch-macro-character (disp-char sub-char
				     &optional (readtable *readtable*))
  (aref (aref (readtable-function readtable) (char-code disp-char))
	(char-code sub-char)))
(defun set-dispatch-macro-character (disp-char sub-char new-function
				     &optional (readtable *readtable*))
  (setf (aref (aref (readtable-function readtable) (char-code disp-char))
	      (char-code sub-char))
	new-function)
  t)
(defun get-macro-character (char &optional (readtable *readtable*))
  (let* ((code (char-code char))
	 (value (aref (readtable-function readtable) code)))
    (if (functionp value)
	(values value (aref (readtable-non-terminating-p readtable) code))
	(values nil nil))))
(defun set-macro-character (char new-function &optional non-terminating-p
			    (readtable *readtable*))
  (let ((code (char-code char)))
    (setf (aref (readtable-function readtable) code) new-function)
    (setf (aref (readtable-non-terminating-p readtable) code)
	  non-terminating-p))
  t)
(defun set-syntax-from-char (to-char from-char
			     &optional (to-readtable *readtable*)
			     (from-readtable *standard-readtable*))
  (let* ((to-code (char-code to-char))
	 (from-code (char-code from-char))
	 (value (aref (readtable-function from-readtable) from-code)))
    (setf (aref (readtable-function to-readtable) to-code)
	  (if (arrayp value)
	      (copy-sequence value)
	      value))
    (setf (aref (readtable-non-terminating-p to-readtable) to-code)
	  (aref (readtable-non-terminating-p from-readtable) from-code)))
  t)
(defparameter *features*
  '(:ieee-floating-point :ansi-cl :common-lisp :lisp500))
(defun featurep (test)
  (when (consp test)
    (case (car test)
      (:not (return-from featurep (not (featurep (cadr test)))))
      (:and (return-from featurep (every #'featurep (cdr test))))
      (:or (return-from featurep (some #'featurep (cdr test))))))
  (member test *features*))
(defparameter *uname* (uname))
(let ((sysname (car *uname*)))
  (cond
    ((fixnump sysname) (push :windows *features*))
    ((string= sysname "Linux") (push :linux *features*))
    ((and (>= (length sysname) 6) (string= (subseq sysname 0 6) "CYGWIN"))
     (push :cygwin *features*))))
(defun make-standard-readtable ()
  (let ((readtable (make-readtable))
	(function (make-array 256))
	(non-terminating-p (make-array 256))
	(i 0))
    (setf (readtable-function readtable) function)
    (setf (readtable-non-terminating-p readtable) non-terminating-p)
    (tagbody
     start
       (when (< i 33)
	 (setf (aref function i) :whitespace)
	 (incf i)
	 (go start)))
    (setq i 128)
    (tagbody
     start
       (when (< i 160)
	 (setf (aref function i) :whitespace)
	 (incf i)
	 (go start)))
    (setf (aref function 8) nil)
    (setf (aref function 92) :single-escape)
    (setf (aref function 124) :multiple-escape)
    (set-macro-character (code-char 34)
			 #'(lambda (stream char)
			     (let ((result nil)
				   (function (readtable-function *readtable*)))
			       (tagbody
				start
				  (let ((c (read-char stream)))
				    (unless (char= c char)
				      (if (eq (aref function (char-code c))
					      :single-escape)
					  (push (read-char stream) result)
					  (push c result))
				      (go start))))
			       (apply #'string (reverse result))))
			 nil readtable)
    (set-macro-character (code-char 39)
			 #'(lambda (stream char)
			     (list 'quote (read stream t nil t)))
			 nil readtable)
    (set-macro-character (code-char 40)
			 #'(lambda (stream char)
			     (read-delimited-list (code-char 41) stream t))
			 nil readtable)
    (set-macro-character (code-char 41)
			 #'(lambda (stream char)
			     (error 'read-error))
			 nil readtable)
    (set-macro-character (code-char 59)
			 #'(lambda (stream char)
			     (when (peek-char (code-char 10) stream nil nil t)
			       (read-char stream))
			     (values))
			 nil readtable)
    (set-macro-character (code-char 96)
			 #'(lambda (stream char)
			     (list 'backquote (read stream t nil t)))
			 nil readtable)
    (set-macro-character (code-char 44)
			 #'(lambda (stream char)
			     (if (= (char-code (peek-char nil stream t nil t))
				    64)
				 (progn
				   (read-char stream)
				   (list 'unquote-splicing
					 (read stream t nil t)))
				 (list 'unquote (read stream t nil t))))
			 nil readtable)
    (make-dispatch-macro-character (code-char 35) t readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 39)
				  #'(lambda (stream sub-char infix)
				      (list 'function (read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 40)
     #'(lambda (stream sub-char infix)
	 (let* ((elements (read-delimited-list (code-char 41) stream t))
		(length (length elements))
		(vector (make-array (or infix length)
				    :initial-contents elements)))
	   (when (and infix (< length infix))
	     (fill vector (aref vector (- length 1)) :start length))
	   vector))
     readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 41)
				  #'(lambda (stream sub-char infix)
				      (error 'reader-error))
				  readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 42)
     #'(lambda (stream sub-char infix)
	 (let* ((char (read-char stream t nil t))
		(token (unless (eq :whitespace
				   (aref (readtable-function *readtable*)
					 (char-code char)))
			 (read-internal stream t nil t nil (list char) nil)))
		(length (length token))
		(vector (make-array (or infix length) :element-type 'bit
				    :initial-contents token)))
	   (when (and infix (< length infix))
	     (fill vector (aref vector (- length 1)) :start length))
	   vector))
     readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 43)
				  #'(lambda (stream sub-char infix)
				      (if (featurep (read stream t nil t))
					  (read stream t nil t)
					  (let ((*read-suppress* t))
					    (read stream t nil t)
					    (values))))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 45)
				  #'(lambda (stream sub-char infix)
				      (if (featurep (read stream t nil t))
					  (let ((*read-suppress* t))
					    (read stream t nil t)
					    (values))
					  (read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 46)
				  #'(lambda (stream sub-char infix)
				      (if *read-eval*
					  (eval (read stream t nil t))
					  (error 'reader-error)))
				  readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 58)
     #'(lambda (stream sub-char infix)
	 (make-symbol (read-internal stream t nil t nil nil nil)))
     readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 60)
				  #'(lambda (stream sub-char infix)
				      (error 'reader-error))
				  readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 65)
     #'(lambda (stream sub-char infix)
	 (let* ((initial-contents (read stream t nil t))
		(sequence initial-contents)
		(dimensions nil)
		(i 0))
	   (tagbody
	    start
	      (when (< i infix)
		(push (length sequence) dimensions)
		(setq sequence (elt sequence 0))
		(incf i)
		(go start)))
	   (make-array (reverse dimensions)
		       :initial-contents initial-contents)))
     readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 66)
				  #'(lambda (stream sub-char infix)
				      (let ((*read-base* 2))
					(read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 79)
				  #'(lambda (stream sub-char infix)
				      (let ((*read-base* 8))
					(read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 80)
				  #'(lambda (stream sub-char infix)
				      (parse-namestring (read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 82)
				  #'(lambda (stream sub-char infix)
				      (let ((*read-base* infix))
					(read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 83)
				  #'(lambda (stream sub-char infix)
				      (let ((list (read stream t nil t)))
					(apply (conc-string "make-" (car list))
					       (cdr list))))
				  readtable)
    (set-dispatch-macro-character (code-char 35) (code-char 88)
				  #'(lambda (stream sub-char infix)
				      (let ((*read-base* 16))
					(read stream t nil t)))
				  readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 92)
     #'(lambda (stream sub-char infix)
	 (let* ((c0 (read-char stream t nil t))
		(c1 (read-char stream t nil t)))
	   (if (eq (aref (readtable-function *readtable*) (char-code c1))
		   :whitespace)
	       c0
	       (progn
		 (unread-char c1 stream)
		 (name-char (read-internal stream t nil t nil
					   (list c0) nil))))))
     readtable)
    (set-dispatch-macro-character
     (code-char 35) (code-char 124)
     #'(lambda (stream sub-char infix)
	 (let* ((c0 (read-char stream t nil t))
		(c1 (read-char stream t nil t))
		(level 1))
	   (tagbody
	    start
	      (when (and (= (char-code c0) 35) (= (char-code c1) 124))
		(incf level))
	      (when (and (= (char-code c0) 124) (= (char-code c1) 35))
		(decf level))
	      (when (plusp level)
		(setq c0 c1)
		(setq c1 (read-char stream t nil t))
		(go start))))
	 (values))
     readtable)
    readtable))
(defstruct (readtable
	     (:predicate readtablep))
  (case :upcase)
  function
  non-terminating-p)
(defparameter *standard-readtable* (make-standard-readtable))
(defparameter *read-base* 10)
(defparameter *read-default-float-format* 'single-float)
(defparameter *read-eval* t)
(defparameter *read-suppress* nil)
(defparameter *readtable* *standard-readtable*)
(defun lisp-implementation-type () "lisp500")
(defun lisp-implementation-version () "0.2004.07.22.0")
(defun ensure-method-combination-long (name lambda-list method-group-specifiers
				       args-lambda-list generic-function-symbol
				       forms)
  (values name lambda-list method-group-specifiers args-lambda-list
	  generic-function-symbol forms))
(defmacro define-method-combination (name &rest options)
  (if (and options (listp (car options)))
      (do ((forms (cddr options) (cdr forms))
	   (args-lambda-list nil)
	   (generic-function-symbol nil))
	  ((not (member (caar forms) '(:arguments :generic-function)))
	   `(ensure-method-combination-long ',name ',(car options)
	     ',(cadr options) ',args-lambda-list ',generic-function-symbol
	     ',forms))
	(case (caar forms)
	  (:arguments (setq args-lambda-list (cdar forms)))
	  (:generic-function (setq generic-function-symbol (cdar forms)))))
      `(ensure-method-combination-short ',name ',options)))
(defmacro defclass (class-name superclass-names slot-specifiers
		    &rest class-options)
  `(ensure-class ',class-name :direct-superclasses ',superclass-names
    :direct-slots
    (list ,@(mapcar #'(lambda (slot)
			(setq slot (designator-list slot))
			(let* ((unbound (gensym))
			       (readers nil)
			       (writers nil)
			       (initargs nil)
			       (initform unbound)
			       (rest nil))
			  (do ((options (cdr slot) (cddr options)))
			      ((not options))
			    (case (car options)
			      (:reader (push (cadr options) readers))
			      (:writer (push (cadr options) writers))
			      (:accessor
			       (push (cadr options) readers)
			       (push `(setf ,(cadr options)) writers))
			      (:initarg (push (cadr options) initargs))
			      (:initform (setq initform (cadr options)))
			      (t (push `',(cadr options) rest)
				 (push `',(car options) rest))))
			  `(list :name ',(car slot)
			    ,@(when readers `(:readers ',readers))
			    ,@(when writers `(:writers ',writers))
			    ,@(when initargs `(:initargs ',initargs))
			    ,@(unless (eq initform unbound)
				      `(:initform ',initform
					:initfunction #'(lambda () ,initform)))
			    ,@rest)))
		    slot-specifiers))
    ,@(let* ((unbound (gensym))
	     (default-initargs unbound)
	     (rest nil))
	(dolist (option class-options)
	  (case (car option)
	    (:default-initargs (setq default-initargs (cdr option)))
	    (:metaclass (push `',(cadr option) rest)
			(push :metaclass rest))
	    (t (push `',(cdr option) rest)
	       (push `',(car option) rest))))
	`(,@(unless (eq default-initargs unbound)
	      `(:direct-default-initargs
		(list ,@(do ((initargs default-initargs (cddr initargs))
			     (result nil))
			    ((not initargs) (reverse result))
			  (push `(list ',(car initargs) ',(cadr initargs)
				  #'(lambda () ,(cadr initargs)))
				result)))))
	  ,@rest))))
(defmacro defmethod (&environment environment function-name &rest rest)
  (let* ((method-qualifiers (do ((qualifiers nil))
				((listp (car rest)) (reverse qualifiers))
			      (push (pop rest) qualifiers)))
	 (lambda-list (car rest))
	 (gf (gensym)))
    (let ((gfn (ensure-generic-function function-name)))
      (multiple-value-bind (lambda initargs)
	  (if (eq (iref gfn 1) *standard-generic-function*)
	      (make-standard-method-lambda
	       gfn `(lambda ,(extract-lambda-list lambda-list) ,@(cdr rest))
	       environment)
	      (make-method-lambda
	       gfn (class-prototype (generic-function-method-class gfn))
	       `(lambda ,(extract-lambda-list lambda-list) ,@(cdr rest))
	       environment))
	`(let ((,gf (ensure-generic-function ',function-name)))
	  (funcall (if (eq (iref ,gf 1) *standard-generic-function*)
		       #'add-standard-method
		       #'add-method)
	   ,gf (ensure-method ,gf
		:qualifiers ',method-qualifiers
		:lambda-list ',(extract-lambda-list lambda-list)
		:specializers
		(list ,@(mapcar #'(lambda (specializer)
				    `(find-class ',specializer))
				(extract-specializer-names lambda-list)))
		:function (function ,lambda)
		,@initargs)))))))
(defun class-of (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (let ((class-candidate (iref object 1)))
	 (if (= (ldb '(2 . 0) (ival class-candidate)) 2)
	     class-candidate
	     (case class-candidate
	       (0 (find-class 'symbol))
	       (3 (find-class 'vector))
	       (4 (find-class 'array))
	       (5 (find-class 'package))
	       (6 (find-class 'function))
	       (t (find-class 't))))))
    (0 (if (eq object nil)
	   (find-class 'null)
	   (if (= (ldb '(2 . 3) (ival object)) 2)
	       (find-class 'integer)
	       (find-class 'character))))
    (1 (find-class 'cons))
    (3 (case (jref object 1)
	 (20 (find-class 'string))
	 (84 (find-class 'real))
	 (116 (find-class 'bit-vector))
	 (t (find-class 't))))))
(defparameter *funcallable-standard-class* (makei 1 *standard-class*))
(defparameter *standard-direct-slot-definition* (makei 1 *standard-class*))
(defparameter *standard-effective-slot-definition*
  (makei 1 *standard-class*))
(defparameter *standard-method-combination* (makei 1 *standard-class*))
(defparameter *standard-method* (makei 1 *standard-class*))
(defparameter *standard-generic-function*
  (makei 1 *funcallable-standard-class*))
(defparameter *standard-reader-method* (makei 1 *standard-class*))
(defparameter *standard-writer-method* (makei 1 *standard-class*))
(setf (find-class 'standard-class) *standard-class*)
(setf (find-class 'built-in-class) *built-in-class*)
(setf (find-class 'funcallable-standard-class) *funcallable-standard-class*)
(setf (find-class 'structure-class) *structure-class*)
(setf (find-class 'standard-direct-slot-definition)
      *standard-direct-slot-definition*)
(setf (find-class 'standard-effective-slot-definition)
      *standard-effective-slot-definition*)
(setf (find-class 'standard-method-combination) *standard-method-combination*)
(setf (find-class 'standard-method) *standard-method*)
(setf (find-class 'standard-generic-function) *standard-generic-function*)
(defun extract-lambda-list (specialized-lambda-list)
  (do ((result nil))
      ((or (not specialized-lambda-list)
	   (member (car specialized-lambda-list) lambda-list-keywords))
       (revappend result specialized-lambda-list))
    (let ((arg (pop specialized-lambda-list)))
      (push (if (consp arg) (car arg) arg) result))))
(defun extract-specializer-names (specialized-lambda-list)
  (do ((result nil))
      ((or (not specialized-lambda-list)
	   (member (car specialized-lambda-list) lambda-list-keywords))
       (reverse result))
    (let ((arg (pop specialized-lambda-list)))
      (push (if (consp arg) (cadr arg) 't) result))))
(defun ensure-class (name &rest rest &key metaclass)
  (apply (if (member metaclass `(nil standard-class ,*standard-class*))
	     #'ensure-standard-class
	     #'ensure-class-using-class)
	 (find-class name nil) name rest))
(defun ensure-standard-class (class name &key direct-default-initargs
			      direct-slots direct-superclasses)
  (unless class (setq class (makei 1 *standard-class*)))
  (unless direct-superclasses (setq direct-superclasses '(standard-object)))
  (setq direct-superclasses (mapcar #'(lambda (super)
					(if (symbolp super)
					    (find-class super)
					    super))
				    direct-superclasses))
  (setf (iref class 2)
	(makei 9 3 name direct-superclasses
	       (mapcar #'(lambda (slot)
			   (apply #'make-standard-direct-slot slot))
		       direct-slots)
	       nil nil nil nil
	       direct-default-initargs))
  (setf (find-class name) class)
  (dolist (super direct-superclasses)
    (push class (iref (iref super 2) 7)))
  (dolist (slot (iref (iref class 2) 4))
    (dolist (reader (iref (iref slot 2) 8))
      (add-reader-method class reader slot))
    (dolist (writer (iref (iref slot 2) 9))
      (add-writer-method class writer slot)))
  (standard-finalize-inheritance class)
  class)
(defun standard-finalize-inheritance (class)
  (unless (iref (iref class 2) 5)
    (mapc #'standard-finalize-inheritance (iref (iref class 2) 3))
    (setf (iref (iref class 2) 5)
	  (standard-compute-class-precedence-list class))
    (setf (iref (iref class 2) 6)
	  (standard-compute-slots class)))
  (values))
(defun standard-compute-class-precedence-list (class)
  (let ((superclasses (cons class (reduce #'union
					  (mapcar #'(lambda (super)
						      (iref (iref super 2) 5))
						  (iref (iref class 2) 3)))))
	(dependencies (make-hash-table)))
    (dolist (super superclasses)
      (dolist (direct-super (iref (iref super 2) 3))
	(incf (gethash direct-super dependencies 0))))
    (do ((minimal (list class))
	 (result nil))
	((not minimal) (if (zerop (hash-table-count dependencies))
			   (reverse result)
			   (error "Incorrect dependency graph.")))
      (let ((next (if (cdr minimal)
		      (dolist (constituent result)
			(let ((common (intersection minimal
						    (iref (iref constituent 2) 3))))
			  (when common (return (car common)))))
		      (car minimal))))
	(setq minimal (remove next minimal))
	(push next result)
	(dolist (direct-super (iref (iref next 2) 3))
	  (when (zerop (decf (gethash direct-super dependencies)))
	    (remhash direct-super dependencies)
	    (push direct-super minimal)))))))
(defun standard-compute-slots (class)
  (let ((defs nil))
    (dolist (super (reverse (iref (iref class 2) 5)))
      (dolist (slot (iref (iref super 2) 4))
	(let* ((name (iref (iref slot 2) 2))
	       (cons (assoc name defs)))
	  (unless cons
	    (setq cons (list name))
	    (push cons defs))
	  (push slot (cdr cons)))))
    (mapcar #'(lambda (cons)
		(standard-compute-effective-slot-definition class (car cons)
							    (cdr cons)))
	    (reverse defs))))
(defun standard-compute-effective-slot-definition (class name
						   direct-slot-definitions)
  (let* ((init-slot (find-if #'(lambda (slot)
				 (iref (iref slot 2) 4))
			     direct-slot-definitions))
	 (init (and init-slot (iref init-slot 2)))
	 (allocation (iref (iref (car direct-slot-definitions) 2) 6)))
    (makei 1 *standard-effective-slot-definition*
	   (makei 7 3 name (and init (iref init 3)) (and init (iref init 4)) 't
		  allocation
		  (mapcan #'(lambda (slot)
			      (iref (iref slot 2) 7))
			  direct-slot-definitions)
		  (when (eq allocation :class)
		    (car direct-slot-definitions))))))
(defun make-standard-direct-slot (&key name initform initfunction (type t)
				  (allocation :instance) initargs readers
				  writers documentation)
  (makei 1 *standard-direct-slot-definition*
	 (makei 9 3 name initform initfunction type allocation initargs readers
		writers)))
(defun add-reader-method (class fn-name slot)
  (let ((slot-name (iref (iref slot 2) 2))
	(gf (ensure-generic-function fn-name :lambda-list '(object))))
    (add-standard-method gf (ensure-method
			     gf
			     :method-class *standard-reader-method*
			     :slot-definition slot
			     :lambda-list '(object)
			     :qualifiers nil
			     :specializers (list class)
			     :function
			     #'(lambda (args next)
				 (slot-value (car args) slot-name))))))
(defun add-writer-method (class fn-name slot)
  (let ((slot-name (iref (iref slot 2) 2))
	(gf (ensure-generic-function fn-name
				     :lambda-list '(new-value object))))
    (add-standard-method gf (ensure-method
			     gf
			     :method-class *standard-writer-method*
			     :slot-definition slot
			     :lambda-list '(new-value object)
			     :qualifiers nil
			     :specializers (list (find-class 't) class)
			     :function
			     #'(lambda (args next)
				 (setf (slot-value (cadr args) slot-name)
				       (car args)))))))
(defun slot-value (object slot-name)
  (let ((class (iref object 1)))
    (if (or (eq (iref class 1) *standard-class*)
	    (eq (iref class 1) *funcallable-standard-class*))
	(standard-slot-value class object slot-name)
	(slot-value-using-class class object
				(find slot-name (class-slots class)
				      :key #'slot-definition-name)))))
(defun standard-slot-value (class object slot-name)
  (let ((index 2))
    (dolist (slot (iref (iref class 2) 6))
      (cond
	((eq :instance (iref (iref slot 2) 6))
	 (when (eq slot-name (iref (iref slot 2) 2))
	   (unless (iboundp (iref object 2) index)
	     (write-line "unbound slot")
	     (write-line (symbol-name slot-name)))
	   (return (iref (iref object 2) index)))
	 (incf index))
	(t
	 (when (eq slot-name (iref (iref slot 2) 2))
	   (return (iref (iref (iref (iref slot 2) 8) 2) 10))))))))
(defun (setf slot-value) (new-value object slot-name)
  (let ((class (iref object 1)))
    (if (eq (iref class 1) *standard-class*)
	(setf (standard-slot-value class object slot-name) new-value)
	(setf (slot-value-using-class class object
				      (find slot-name (class-slots class)
					    :key #'slot-definition-name))))))
(defun (setf standard-slot-value) (new-value class object slot-name)
  (let ((index 2))
    (dolist (slot (iref (iref class 2) 6))
      (cond
	((eq :instance (iref (iref slot 2) 6))
	 (when (eq slot-name (iref (iref slot 2) 2))
	   (return (setf (iref (iref object 2) index) new-value)))
	 (incf index))
	(t
	 (when (eq slot-name (iref (iref slot 2) 2))
	   (return (setf (iref (iref (iref (iref slot 2) 8) 2) 10)
			 new-value))))))))
(defun ensure-generic-function (function-name &rest rest
				&key (generic-function-class
				      *standard-generic-function*))
  (apply (if (or (eq generic-function-class *standard-generic-function*)
		 (eq generic-function-class 'standard-generic-function))
	     #'ensure-standard-generic-function
	     #'ensure-generic-function-using-class)
	 (and (fboundp function-name) (fdefinition function-name))
	 function-name rest))
(defun ensure-standard-generic-function
    (generic-function function-name &key declarations documentation
     (method-combination *standard-method-combination*)
     (method-class *standard-method*) lambda-list argument-precedence-order)
  (or generic-function
      (let ((gf (makei 2 *standard-generic-function*
		       (makei 9 3 function-name lambda-list nil method-class
			      argument-precedence-order declarations
			      method-combination
			      (make-hash-table :test #'equal))
		       #'(lambda (&rest rest) (error "No methods defined.")))))
	(setf (iref gf 0) 16)
	(setf (fdefinition function-name) gf))))
(defun ensure-method (generic-function &key (method-class *standard-method*)
		      lambda-list qualifiers specializers function
		      slot-definition)
  (makei 2 method-class
	 (if (eq method-class *standard-method*)
	     (makei 5 3 function generic-function lambda-list specializers
		    qualifiers)
	     (makei 6 3 function generic-function lambda-list specializers
		    qualifiers slot-definition))))
(defun add-standard-method (generic-function method)
  (push method (iref (iref generic-function 2) 4))
  (setf (iref (iref method 2) 3) generic-function)
  (setf (iref (iref generic-function 2) 10)
	(length (iref (iref method 2) 5)))
  (let ((df (compute-standard-discriminating-function generic-function)))
    (set-funcallable-instance-function generic-function df)))
(defparameter *emf-args* (gensym))
(defun compute-standard-discriminating-function (generic-function)
  #'(lambda (&rest arguments)
      (let* ((classes (mapcar #'class-of
			      (subseq arguments
				      0 (iref (iref generic-function 2) 10))))
	     (emf (gethash classes (iref (iref generic-function 2) 9))))
	(if emf
	    (apply emf arguments)
	    (multiple-value-bind (methods memoizablep)
		(compute-standard-applicable-methods-using-classes
		 generic-function classes)
	      (unless memoizablep
		(setq methods (compute-standard-applicable-methods
			       generic-function arguments)))
	      (unless methods
		(apply #'no-applicable-method generic-function arguments))
	      (multiple-value-bind (effective-method effective-method-options)
		  (compute-standard-effective-method
		   generic-function (iref (iref generic-function 2) 8) methods)
		(let ((emf (coerce `(lambda (&rest ,*emf-args*)
				     ,effective-method)
				   'function)))
		  (when memoizablep
		    (setf (gethash classes (iref (iref generic-function 2) 9))
			  emf))
		  (apply emf arguments))))))))
(defun compute-standard-applicable-methods-using-classes
    (generic-function classes)
  (let ((applicable nil)
	(depths nil))
    (dolist (method (iref (iref generic-function 2) 4))
      (block method
	(do ((specializers (iref (iref method 2) 5) (cdr specializers))
	     (clss classes (cdr clss)))
	    ((not clss))
	  (let ((depth 0))
	    (dolist (class (iref (iref (car clss) 2) 5) (return-from method))
	      (when (eq (car specializers) class)
		(push depth depths)
		(return))
	      (incf depth))))
	(let ((prev nil)
	      (point applicable)
	      (depths (reverse depths)))
	  (do () ((or (not point)
		      (do ((dl depths (cdr dl))
			   (dr (cdr point) (cdr dr)))
			  ((not dl))
			(when (< (car dl) (car dr))
			  (return t))
			(when (> (car dl) (car dr))
			  (return)))))
	    (setq prev point)
	    (setq point (cdr point)))
	  (let ((new (cons (cons method depths) point)))
	    (if prev
		(setf (cdr prev) new)
		(setq applicable new))))))
    (values (mapcar #'car applicable) t)))
(defun compute-standard-effective-method (generic-function method-combination
					  methods)
  (let ((primary nil)
	(before nil)
	(after nil)
	(around nil))
    (dolist (method methods)
      (let ((qualifiers (iref (iref method 2) 6)))
	(cond
	  ((not qualifiers) (push method primary))
	  ((equal qualifiers '(:before)) (push method before))
	  ((equal qualifiers '(:after)) (push method after))
	  ((equal qualifiers '(:around)) (push method around))
	  (t (error "unknown qualifiers for standard-method-combination ~A"
		    qualifiers)))))
    (setq primary (reverse primary))
    (setq before (reverse before))
    (setq around (reverse around))
    (flet ((call-methods (methods)
	     (mapcar #'(lambda (method)
			 `(call-standard-method ,method))
		     methods)))
      (let ((form (if (or before after (rest primary))
		      `(multiple-value-prog1
			(progn ,@(call-methods before)
			       (call-standard-method ,(car primary)
						     ,(cdr primary)))
			,@(call-methods after))
		      `(call-standard-method ,(car primary)))))
	(if around
	    `(call-method ,(car around) (,@(cdr around) (make-method ,form)))
	    form)))))
(defmacro call-standard-method (method &optional next-method-list)
  `(funcall (if (consp ',method)
		(make-method-function (cadr ',method))
		(iref (iref ',method 2) 2))
    ,*emf-args* ',next-method-list))
(defmacro call-method (method &optional next-method-list)
  `(funcall (method-function ,method) ,*emf-args* ',next-method-list))
(defun set-funcallable-instance-function (funcallable-instance function)
  (setf (iref funcallable-instance 3) function))
(defun make-standard-method-lambda
    (generic-function lambda-expression environment)
  `(lambda (args next)
    (flet ((next-method-p ()
	     next)
	   (call-next-method (&rest next-args)
	     (if next
		 (funcall (if (consp (car next))
			      (make-method-function (cadar next))
			      (iref (iref (car next) 2) 2))
			  (or next-args args)
			  (cdr next))
		 (apply #'no-next-method ',generic-function nil next-args))))
      (apply (function ,lambda-expression) args))))
(defun make-method-function (form)
  (coerce (make-standard-method-lambda nil `(lambda (&rest ,*emf-args*) ,form) nil)
	  'function))
(defclass standard-object (t) ())
(defclass funcallable-standard-object (standard-object) ())
(defclass metaobject (standard-object) ())
(defclass generic-function (metaobject funcallable-standard-object) ())
(defclass standard-generic-function (generic-function)
  ((name :accessor generic-function-name)
   (lambda-list :accessor generic-function-lambda-list)
   (methods :accessor generic-function-methods)
   (method-class :accessor generic-function-method-class)
   (argument-precedence-order
    :accessor generic-function-argument-precedence-order)
   (declarations :accessor generic-function-declarations)
   (method-combination :accessor generic-function-method-combination)
   (classes-to-emf :accessor generic-function-classes-to-emf)
   (required-length :accessor generic-function-required-length)))
(defclass method (metaobject) ())
(defclass standard-method (method)
  ((function :accessor method-function
	     :initarg :function)
   (generic-function :accessor method-generic-function
		     :initarg :generic-function)
   (lambda-list :accessor method-lambda-list
		:initarg :lambda-list)
   (specializers :accessor method-specializers
		 :initarg :specializers)
   (qualifiers :accessor method-qualifiers
	       :initarg :qualifiers)))
(defclass standard-accessor-method (standard-method)
  (slot-definition :accessor accessor-method-slot-definition))
(defclass standard-reader-method (standard-accessor-method) ())
(defclass standard-writer-method (standard-accessor-method) ())
(defclass slot-definition (metaobject) ())
(defclass direct-slot-definition (slot-definition) ())
(defclass effective-slot-definition (slot-definition) ())
(defclass standard-slot-definition (slot-definition)
  ((name :accessor slot-definition-name
	 :initarg :name)
   (initform :accessor slot-definition-initform
	     :initarg :initform)
   (initfunction :accessor slot-definition-initfunction
		 :initarg :initfunction
		 :initform nil)
   (type :accessor slot-definition-type
	 :initarg :type
	 :initform t)
   (allocation :accessor slot-definition-allocation
	       :initarg :allocation
	       :initform :instance)
   (initargs :accessor slot-definition-initargs
	     :initarg :initargs
	     :initform nil)))
(defclass standard-direct-slot-definition
    (standard-slot-definition direct-slot-definition)
  ((readers :accessor slot-definition-readers
	    :initarg :readers
	    :initform nil)
   (writers :accessor slot-definition-writers
	    :initarg :writers
	    :initform nil)))
(defclass standard-effective-slot-definition
    (standard-slot-definition effective-slot-definition) ())
(defclass specializer (metaobject) ())
(defclass eql-specializer (specializer)
  ((object :accessor eql-specializer-object)))
(defclass class (specializer)
  ((name :accessor class-name)
   (direct-superclasses :accessor class-direct-superclasses
			:initarg :direct-superclasses)
   (direct-slots :accessor class-direct-slots)
   (precedence-list :accessor class-precedence-list
		    :initform nil)
   (slots :accessor class-slots)
   (direct-subclasses :accessor class-direct-subclasses
		      :initform nil)
   (direct-methods :accessor class-direct-methods)
   (direct-default-initargs :accessor class-direct-default-initargs
			    :initform nil)
   (default-initargs :accessor class-default-initargs)))
(defclass built-in-class (class) ())
(defclass forward-referenced-class (class) ())
(defclass standard-class (class) ())
(defclass funcallable-standard-class (class) ())
(defclass structure-class (class) ())
(dolist (built-in-def '((array (t))
			(sequence (t))
			(vector (array sequence))
			(bit-vector (vector))
			(character (t))
			(number (t))
			(complex (number))
			(list (sequence))
			(cons (list))
			(function (t))
			(real (number))
			(rational (real))
			(integer (rational))
			(symbol (t))
			(null (symbol list))
			(package (t))
			(ratio (rational))
			(real (number))
			(string (vector))
			(hash-table (structure-object))))
  (let* ((direct-superclasses (mapcar #'find-class (cadr built-in-def)))
	 (class (or (find-class (car built-in-def) nil)
		    (makei 1 *built-in-class*))))
    (setf (iref class 2) (makei 8 3 (car built-in-def) direct-superclasses))
    (setf (find-class (car built-in-def)) class)
    (dolist (super direct-superclasses)
      (push class (iref (iref super 2) 7)))
    (standard-finalize-inheritance class)))
(defmethod make-instance ((class standard-class) &rest initargs)
  (unless (class-finalized-p class)
    (finalize-inheritance class))
  (let ((additional-initargs nil))
    (dolist (default-initarg (class-direct-default-initargs class))
      (let ((default (getf initargs (car default-initarg))))
	(when default
	  (push (car default-initarg) additional-initargs)
	  (push (funcall (caddr default-initarg)) additional-initargs))))
    (setq initargs (append initargs (reverse additional-initargs))))
  (let ((instance (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance instance initargs)
    instance))
(defmethod make-instance ((class symbol) &rest initargs)
  (apply #'make-instance (find-class class) initargs))
(defmethod allocate-instance ((class standard-class) &rest initargs)
  (let* ((length (count :instance (class-slots class)
			:key #'slot-definition-allocation))
	 (slots (makei length 3)))
    (dotimes (i length)
      (imakunbound slots (+ 2 i)))
    (makei 1 class slots)))
(defmethod initialize-instance ((instance standard-object) &rest initargs)
  (apply #'shared-initialize instance t initargs))
(defmethod shared-initialize ((instance standard-object) slot-names
			      &rest initargs)
  (let ((class (iref instance 1))
	(i 2))
    (dolist (slot (class-slots class))
      (multiple-value-bind (indicator value tail)
	  (get-properties initargs (slot-definition-initargs slot))
	(when indicator
	  (if (eq :instance (slot-definition-allocation slot))
	      (setf (iref (iref instance 2) i) value)
	      (setf (iref (iref (iref (iref slot 2) 8) 2) 10) value))))
      (when (eq :instance (slot-definition-allocation slot))
	(incf i)))
    (setq i 2)
    (dolist (slot (class-slots class))
      (when (and (not (iboundp (iref instance 2) i))
		 (or (eq slot-names 't)
		     (member (slot-definition-name slot) slot-names))
		 (slot-definition-initfunction slot))
	(if (eq :instance (slot-definition-allocation slot))
	    (setf (iref (iref instance 2) i)
		  (funcall (slot-definition-initfunction slot)))
	    (setf (iref (iref (iref (iref slot 2) 8) 2) 10)
		  (funcall (slot-definition-initfunction slot)))))
      (when (eq :instance (slot-definition-allocation slot))
	(incf i))))
  instance)
(defmethod reinitialize-instance ((instance standard-object) &rest initargs)
  (apply #'shared-initialize instance nil initargs))
(defmethod ensure-class-using-class ((class null) name &rest rest
				     &key (metaclass *standard-class*)
				     direct-superclasses)
  (unless direct-superclasses (setq direct-superclasses '(standard-object)))
  (setq direct-superclasses (mapcar #'(lambda (super)
					(if (symbolp super)
					    (find-class super)
					    super))
				    direct-superclasses))
  (let ((class (apply #'make-instance metaclass rest)))
    (setf (find-class name) class)
    (setf (class-name class) name)
    class))
(defmethod shared-initialize :after
    ((class class) slot-names &key direct-slots direct-superclasses
     direct-default-initargs)
  (unless (class-direct-superclasses class)
    (setf (class-direct-superclasses class)
	  (list 'standard-object)))
  (setf (class-direct-superclasses class)
	(mapcar #'(lambda (super)
		    (if (symbolp super)
			(find-class super)
			super))
		(class-direct-superclasses class)))
  (setf (class-direct-slots class)
	(mapcar #'(lambda (slot)
		    (apply #'make-instance
			   (apply #'direct-slot-definition-class
				  class slot)
			   slot))
		direct-slots))
  (dolist (slot (class-direct-slots class))
    (dolist (reader (slot-definition-readers slot))
      (let* ((gf (ensure-generic-function reader :lambda-list '(object)))
	     (slot-name (slot-definition-name slot))
	     (initargs (list :slot-definition slot :lambda-list '(object)
			     :function #'(lambda (args next)
					   (slot-value (car args) slot-name))
			     :qualifiers nil :specializers (list class)))
	     (reader-method-class (reader-method-class class slot initargs)))
	(add-method gf (apply #'make-instance reader-method-class initargs))))
    (dolist (writer (slot-definition-writers slot))
      (let* ((gf (ensure-generic-function writer
					  :lambda-list '(new-value object)))
	     (slot-name (slot-definition-name slot))
	     (initargs (list :slot-definition slot :qualifiers nil
			     :lambda-list '(new-value object)
			     :specializers (list (find-class 't) class)
			     :function
			     #'(lambda (args next)
				 (setf (slot-value (cadr args) slot-name)
				       (car args)))))
	     (writer-method-class (writer-method-class class slot initargs)))
	(add-method gf (apply #'make-instance writer-method-class initargs)))))
  (dolist (super (class-direct-superclasses class))
    (add-direct-subclass super class)))
(defmethod add-method ((generic-function standard-generic-function)
		       (method standard-method))
  (add-standard-method generic-function method))
(defmethod add-direct-subclass ((superclass class) (subclass class))
  (push subclass (class-direct-subclasses superclass)))
(defmethod reader-method-class
    ((class standard-class) (direct-slot standard-direct-slot-definition)
     &rest initargs)
  (find-class 'standard-reader-method))
(defmethod reader-method-class
    ((class funcallable-standard-class)
     (direct-slot standard-direct-slot-definition) &rest initargs)
  (find-class 'standard-reader-method))
(defmethod writer-method-class
    ((class standard-class) (direct-slot standard-direct-slot-definition)
     &rest initargs)
  (find-class 'standard-writer-method))
(defmethod writer-method-class
    ((class funcallable-standard-class)
     (direct-slot standard-direct-slot-definition) &rest initargs)
  (find-class 'standard-writer-method))
(defmethod direct-slot-definition-class
    ((class standard-class) &rest initargs)
  (find-class 'standard-direct-slot-definition))
(defmethod direct-slot-definition-class
    ((class funcallable-standard-class) &rest initargs)
  (find-class 'standard-direct-slot-definition))
(defmethod finalize-inheritance ((class standard-class))
  (dolist (super (class-direct-superclasses class))
    (unless (class-finalized-p super)
      (finalize-inheritance super)))
  (setf (class-precedence-list class)
	(compute-class-precedence-list class))
  (setf (class-slots class)
	(compute-slots class))
  (setf (class-default-initargs class)
	(compute-default-initargs class)))
(defmethod class-finalized-p ((class class))
  (class-precedence-list class))
(defmethod compute-class-precedence-list ((class standard-class))
  (let ((superclasses
	 (cons class (reduce #'union
			     (mapcar #'class-precedence-list
				     (class-direct-superclasses class)))))
	(dependencies (make-hash-table)))
    (dolist (super superclasses)
      (dolist (direct-super (class-direct-superclasses super))
	(incf (gethash direct-super dependencies 0))))
    (do ((minimal (list class))
	 (result nil))
	((not minimal) (if (zerop (hash-table-count dependencies))
			   (reverse result)
			   (error "Incorrect dependency graph.")))
      (let ((next (if (cdr minimal)
		      (dolist (constituent result)
			(let ((common (intersection minimal
						    (class-direct-superclasses
						     constituent))))
			  (when common (return (car common)))))
		      (car minimal))))
	(setq minimal (remove next minimal))
	(push next result)
	(dolist (direct-super (class-direct-superclasses next))
	  (when (zerop (decf (gethash direct-super dependencies)))
	    (remhash direct-super dependencies)
	    (push direct-super minimal)))))))
(defmethod compute-slots ((class class))
  (let ((defs nil))
    (dolist (super (reverse (class-precedence-list class)))
      (dolist (slot (class-direct-slots super))
	(let* ((name (slot-definition-name slot))
	       (cons (assoc name defs)))
	  (unless cons
	    (setq cons (list name))
	    (push cons defs))
	  (push slot (cdr cons)))))
    (mapcar #'(lambda (cons)
		(compute-effective-slot-definition class (car cons)
						   (cdr cons)))
	    (reverse defs))))
(defmethod compute-effective-slot-definition
    ((class class) name direct-slot-definitions)
  (let* ((unbound (gensym))
	 (initfunction unbound)
	 (initform unbound)
	 (type 't)
	 (allocation :instance)
	 (initargs nil)
	 (readers nil)
	 (writers nil))
    (dolist (slot (reverse direct-slot-definitions))
      (let ((initfn (slot-definition-initfunction slot)))
	(when initfn
	  (setq initfunction initfn)
	  (setq initform (slot-definition-initform slot))))
      (setq type (slot-definition-type slot))
      (setq allocation (slot-definition-allocation slot))
      (setq initargs (append readers (slot-definition-initargs slot)))
      (setq readers (append readers (slot-definition-readers slot)))
      (setq writers (append writers (slot-definition-writers slot))))
    (let ((effective-initargs (list :name name :type type
				    :allocation allocation :initargs initargs
				    :readers readers :writers writers)))
      (unless (eq initfunction unbound)
	(setq effective-initargs
	      (list* :initfunction initfunction :initform initform
		     effective-initargs)))
      (apply #'make-instance
	     (apply #'effective-slot-definition-class class effective-initargs)
	     effective-initargs))))
(defmethod effective-slot-definition-class
    ((class standard-class) &rest initargs)
  (find-class 'standard-effective-slot-definition))
(defmethod effective-slot-definition-class
    ((class funcallable-standard-class) &rest initargs)
  (find-class 'standard-effective-slot-definition))
(defmethod compute-default-initargs ((class class))
  nil)
(defmethod slot-value-using-class
    ((class standard-class) object (slot standard-effective-slot-definition))
  (standard-slot-value class object (slot-definition-name slot)))
(defmethod slot-value-using-class ((class funcallable-standard-class) object
				   (slot standard-effective-slot-definition))
  (standard-slot-value class object (slot-definition-name slot)))
(defmethod no-applicable-method (generic-function &rest function-arguments)
  (error "no applicable method on ~A for ~A"
	 generic-function function-arguments))
(init-known-streams)
(defparameter *report-hash* (make-hash-table))
(defmacro define-condition (name parent-types slot-specifiers &rest options)
  (let* ((report (cadr (assoc :report options)))
	 (report-form (when report
			(if (stringp report)
			    `#'(lambda (condition stream)
				 (write-string ,report stream))
			    `#',report))))
    `(progn
      (defclass ,name ,(if parent-types parent-types '(condition))
	,slot-specifiers ,@(remove :report options :key #'car))
      (setf (gethash ',name *report-hash*) ,report-form)
      ',name)))
(define-condition condition (standard-object) ()
  (:report (lambda (condition stream)
	     (format stream "Condition ~A"
		     (class-name (class-of condition))))))
(define-condition serious-condition (condition) ())
(define-condition error (serious-condition) ()
  (:report (lambda (condition stream)
	     (format stream "Error ~A"
		     (class-name (class-of condition))))))
(define-condition arithmetic-error (error)
  ((operation :initarg :operation
	      :reader arithmetic-error-operation)
   (operands :initarg :operands
	     :reader arithmetic-error-operands)))
(define-condition cell-error (error)
  ((name :initarg :name
	 :reader cell-error-name))
  (:report (lambda (condition stream)
	     (format stream "Cell ~A not bound"
		     (cell-error-name condition)))))
(define-condition control-error (error) ())
(define-condition division-by-zero (arithmetic-error) ())
(define-condition stream-error (error)
  ((stream :initarg :stream
	   :reader stream-error-stream)))
(define-condition end-of-file (stream-error) ()
  (:report (lambda (condition stream)
	     (format stream "End of file"))))
(define-condition file-error (error)
  ((pathname :initarg :pathname
	     :reader file-error-pathname)))
(define-condition floating-point-inexact (arithmetic-error) ())
(define-condition floating-point-invalid-operation (arithmetic-error) ())
(define-condition floating-point-overflow (arithmetic-error) ())
(define-condition floating-point-underflow (arithmetic-error) ())
(define-condition package-error (error)
  ((package :initarg :package
	    :reader package-error-package)))
(define-condition parse-error (error) ())
(define-condition print-not-readable (error)
  ((object :initarg :object
	   :reader print-not-readable-object))
  (:report (lambda (condition stream)
	     (format stream "Cannot print ~A readably."
		     (print-not-readable-object condition)))))
(define-condition program-error (error) ())
(define-condition reader-error (parse-error) ())
(define-condition simple-condition (condition)
  ((format-control :initarg :format-control
		   :reader simple-condition-format-control)
   (format-arguments :initarg :format-arguments
		     :reader simple-condition-format-arguments))
  (:report (lambda (condition stream)
	     (apply #'format stream
		    (simple-condition-format-control condition)
		    (simple-condition-format-arguments condition)))))
(define-condition simple-error (simple-condition error) ())
(define-condition type-error (error)
  ((datum :initarg :datum
	  :reader type-error-datum)
   (expected-type :initarg :expected-type
		  :reader type-error-expected-type)))
(define-condition simple-type-error (simple-condition type-error) ())
(define-condition warning (condition) ())
(define-condition simple-warning (simple-condition warning) ())
(define-condition storage-condition (serious-condition) ())
(define-condition style-warning (warning) ())
(define-condition unbound-slot (cell-error)
  ((instance :initarg :instance
	     :reader unbound-slot-instance)))
(define-condition unbound-variable (cell-error) ())
(define-condition undefined-function (cell-error) ())
(defun make-condition (type &rest slot-initializations)
  (apply #'make-instance type slot-initializations))
(defmethod print-object (object stream)
  (case (ldb '(2 . 0) (ival object))
    (0 (if object
	   (if (= (ldb '(1 . 3) (ival object)) 0)
	       (write-string (integer-string object *print-base*) stream)
	       (let ((name (char-name object)))
		 (write-string "#\\" stream)
		 (write-string (or name (string object)) stream)))
	   (write-string "NIL" stream)))
    (1 (write-string "(" stream)
       (tagbody
	  (print-object (car object) stream)
	  (setq object (cdr object))
	start
	  (when (consp object)
	    (write-string " " stream)
	    (print-object (car object) stream)
	    (setq object (cdr object))
	    (go start)))
       (when object
	 (write-string " . " stream)
	 (print-object object stream))
       (write-string ")" stream))
    (2 (case (iref object 1)
	 (0 (write-string (symbol-name object) stream))
	 (3 (write-string "#(" stream)
	    (let ((i 0))
	      (tagbody
	       start
		 (when (< i (length object))
		   (when (< 0 i)
		     (write-string " " stream))
		   (print-object (aref object i) stream)
		   (setq i (+ 1 i))
		   (go start))))
	    (write-string ")" stream))
	 (4 (write-string "#<array>" stream))
	 (5 (write-string "#<package>" stream))
	 (6 (write-string "#<function>" stream))
	 (t (write-string "#<object " stream)
	    (let ((class (iref object 1)))
	      (if (= (ldb '(2 . 0) (ival class)) 2)
		  (print-object (class-name class) stream)
		  (print-object (iref object 1) stream)))
	    (write-string ">" stream))))
    (3 (case (jref object 1)
	 (20 (write-string object stream))
	 (84 (if (zerop (nth-value 1 (floor object)))
		 (write-string (integer-string object *print-base*) stream)
		 (write-string "#<double>" stream)))
	 (116 (write-string "#<file-stream>" stream))
	 (180 (write-string "" stream))
	 (t (write-string "#<bit object " stream)
	    (print-object (jref object 1) stream)
	    (write-string ">" stream)))))
  object)
(defmethod print-object ((condition condition) stream)
  (if *print-escape*
      (call-next-method)
      (dolist (super (class-precedence-list (class-of condition))
	       (call-next-method))
	(let ((report (gethash (class-name super) *report-hash*)))
	  (when report
	    (funcall report condition stream)
	    (return))))))
(defmethod print-object ((restart restart) stream)
  (if *print-escape*
      (call-next-method)
      (funcall (restart-report-function restart) stream)))
(defvar -)
(defvar +)
(defvar ++)
(defvar +++)
(defvar *)
(defvar **)
(defvar ***)
(defvar /)
(defvar //)
(defvar ///)
(defun read-eval-print-loop ()
  (tagbody
   start
     (with-simple-restart (abort "Return to lisp toplevel.")
       (format t "~%? ")
       (let* ((- (read))
	      (values (multiple-value-list (eval -)))
	      (count 0))
	 (when (boundp '++) (setq +++ ++))
	 (when (boundp '+) (setq ++ +))
	 (setq + -)
	 (when (boundp '//) (setq /// //))
	 (when (boundp '/) (setq // /))
	 (setq / values)
	 (when (boundp '**) (setq *** **))
	 (when (boundp '*) (setq ** *))
	 (setq * (car values))
	 (if values
	     (dolist (value values)
	       (format t ";~A: ~S~%" count value)
	       (incf count))
	     (format t ";No values.~%"))))
     (go start)))
(defun ierror (index args)
  (case index
    (0 (error 'unbound-variable :name args))
    (1 (error 'undefined-function :name args))
    (2 (error 'program-error))
    (3 (error 'program-error))
    (4 (error 'program-error))
    (5 (error 'control-error))
    (6 (error 'program-error))
    (7 (error 'program-error))
    (8 (error 'control-error))
    (9 (error 'control-error))
    (t (error "ierror ~A ~A~%" index args))))
(defvar *compilation*)
(defparameter *compiler-output* *standard-output*)
(defun start-compilation ()
  (let ((compilation (construct-compilation
		      (make-hash-table) (make-hash-table) (make-hash-table)
		      (make-hash-table)
		      (make-array 32 :adjustable t :fill-pointer 0
				  :initial-element 0)
		      (make-array 32 :adjustable t :fill-pointer 0
				  :initial-element 0)
		      *compiler-output*)))
    (format *compiler-output* "#include \"lisp500.h\"~%")
    (when (featurep :windows)
      (format *compiler-output* "#include <windows.h>~%"))
    (format *compiler-output* "lval *value, *opaque;~%")
    compilation))
(if (featurep :windows)
    (defun run-cc (basename)
      (run-program "c:/Program Files/Microsoft Visual Studio/VC98/bin/cl.exe"
		   (conc-string "cl /LD /Fe" basename ".dll " basename
				".c lisp500.lib")))
    (let ((end (if (featurep :cygwin) " lisp500.imp" "")))
      (defun run-cc (basename)
	(run-program "/bin/sh" "sh" "-c"
		     (conc-string "cc -fPIC -shared -g -o " basename ".so "
				  basename ".c" end)))))
(defun finish-compilation (&optional init)
  (let ((value-hash (compilation-value-hash *compilation*))
	(package-hash (compilation-package-hash *compilation*))
	(symbol-hash (compilation-symbol-hash *compilation*))
	(class-hash (compilation-class-hash *compilation*))
	(vals (compilation-values *compilation*))
	(opaques (compilation-opaques *compilation*)))
    (format *compiler-output* "lval package[] = {~%")
    (dolist (package (reverse (compilation-packages *compilation*)))
      (format *compiler-output* "~A,~%"
	      (gethash (package-name package) value-hash)))
    (format *compiler-output* "0~%};~%lval symbol[] = {~%")
    (dolist (symbol (reverse (compilation-symbols *compilation*)))
      (format *compiler-output* "~A, /* ~A */~%"
	      (gethash (symbol-name symbol) value-hash)
	      (symbol-name symbol)))
    (format *compiler-output* "0~%};~%lval symbol_package[] = {~%")
    (dolist (symbol (reverse (compilation-symbols *compilation*)))
      (format *compiler-output* "~A,~%"
	      (gethash (symbol-package symbol) package-hash)))
    (format *compiler-output* "0~%};~%lval klass[] = {~%")
    (dolist (class (reverse (compilation-classes *compilation*)))
      (format *compiler-output* "~A,~%"
	      (gethash (class-name class) symbol-hash)))
    (format *compiler-output* "0~%};~%lval value_data[] = {~%")
    (if (zerop (fill-pointer vals))
	(format *compiler-output* "0,~%0,~%")
	(dotimes (i (fill-pointer vals))
	  (format *compiler-output* "~A,~%" (aref vals i))))
    (format *compiler-output* "0~%};~%lval opaque_data[] = {~%")
    (if (zerop (fill-pointer opaques))
	(format *compiler-output* "0,~%0,~%")
	(dotimes (i (fill-pointer opaques))
	  (format *compiler-output* "~A,~%" (aref opaques i))))
    (format *compiler-output* "0~%};~%")
    (when (featurep :windows)
      (format *compiler-output* "__declspec(dllexport) "))
    (format *compiler-output* "lval init(lval *f) {~%")
    (format *compiler-output*
	    "fasr(f, package, ~A, symbol, symbol_package, ~A, klass, ~A, value_data, ~A, opaque_data, ~A, &value, &opaque);~%"
	    (hash-table-count package-hash)
	    (hash-table-count symbol-hash)
	    (hash-table-count class-hash)
	    (max (fill-pointer vals) 2)
	    (max (fill-pointer opaques) 2))
    (when init
      (format *compiler-output* "*++f = 0;~%")
      (write-string init *compiler-output*))
    (format *compiler-output* "return 0;~%")
    (format *compiler-output* "}~%")
    (when (featurep :windows)
      (format *compiler-output* "BOOL WINAPI DllMain() { return TRUE; }~%"))))
(defun intern-constant-string (value)
  (multiple-value-bind (index type)
      (intern-constant value)
    (case type
      (:package (conc-string "package[" (integer-string index 10) "]"))
      (:symbol (conc-string "symbol[" (integer-string index 10) "]"))
      (:class (conc-string "klass[" (integer-string index 10) "]"))
      (:immediate (integer-string index 10))
      (:cons (conc-string "(lval)value+"
			  (integer-string (+ 1 (* 4 index)) 10)))
      (:value (conc-string "(lval)value+"
			   (integer-string (+ 2 (* 4 index)) 10)))
      (:opaque (conc-string "(lval)opaque+"
			    (integer-string (+ 3 (* 4 index)) 10))))))
(defun intern-constant-lval (value)
  (multiple-value-bind (index type)
      (intern-constant value)
    (case type
      (:package (+ 3221225472 2 (* 4 index)))
      (:symbol (+ 2147483648 2 (* 4 index)))
      (:class (+ 1073741824 2 (* 4 index)))
      (:immediate index)
      (:cons (+ 1 (* 4 index)))
      (:value (+ 2 (* 4 index)))
      (:opaque (+ 3 (* 4 index))))))
(defun intern-constant (value)
  (cond
    ((= (ldb '(2 . 0) (ival value)) 0)
     (values (ival value) :immediate))
    ((packagep value)
     (let* ((hash (compilation-package-hash *compilation*))
	    (index (gethash value hash)))
       (unless index
	 (intern-constant (package-name value))
	 (setq index (setf (gethash value hash) (hash-table-count hash)))
	 (push value (compilation-packages *compilation*)))
       (values index :package)))
    ((symbolp value)
     (let* ((hash (compilation-symbol-hash *compilation*))
	    (index (gethash value hash)))
       (unless index
	 (intern-constant (symbol-package value))
	 (intern-constant (symbol-name value))
	 (setq index (setf (gethash value hash) (hash-table-count hash)))
	 (push value (compilation-symbols *compilation*)))
       (values index :symbol)))
    ((typep value 'class)
     (let* ((hash (compilation-class-hash *compilation*))
	    (index (gethash value hash)))
       (unless index
	 (intern-constant (class-name value))
	 (setq index (setf (gethash value hash) (hash-table-count hash)))
	 (push value (compilation-classes *compilation*)))
       (values index :class)))
    (t
     (let* ((hash (compilation-value-hash *compilation*))
	    (index (gethash value hash))
	    (tag (ldb '(2 . 0) (ival value))))
       (unless index
	 (let ((vals (if (= tag 3)
			 (compilation-opaques *compilation*)
			 (compilation-values *compilation*)))
	       (length (case tag
			 (1 2)
			 (2 (+ 2 (/ (ival (iref value 0)) 256)))
			 (3 (+ 2 (floor (jref value 0) 256))))))
	   (setq index (setf (gethash value hash) (fill-pointer vals)))
	   (let ((new-fill (+ (fill-pointer vals)
			      (if (oddp length) (+ 1 length) length))))
	     (when (> new-fill (array-dimension vals 0))
	       (adjust-array vals (* 2 new-fill) :initial-element 0))
	     (setf (fill-pointer vals) new-fill))
	   (case tag
	     (1 (setf (aref vals index) (intern-constant-lval (car value)))
		(setf (aref vals (+ 1 index))
		      (intern-constant-lval (cdr value))))
	     (2 (setf (aref vals index) (ival (iref value 0)))
		(setf (aref vals (+ 1 index))
		      (+ 4 (intern-constant-lval (iref value 1))))
		(dotimes (i (- length 2))
		  (setf (aref vals (+ index 2 i))
			(intern-constant-lval (iref value (+ 2 i))))))
	     (3 (dotimes (i length)
		  (setf (aref vals (+ index i)) (jref value i)))))))
       (values index (case tag
		       (1 :cons)
		       (2 :value)
		       (3 :opaque)))))))
(defparameter *control-obstacles*
  '(unwind-protect lambda block tagbody catch
    let-special let*-special))
(defparameter *stack-obstacles* '(lambda))
(defun binding (environment name &optional obstacle-names)
  (let ((obstacles nil))
    (dolist (bind environment)
      (when (equal name (car bind))
	(return (values (cdr bind) obstacles)))
      (when (and (consp (car bind)) (member (caar bind) obstacle-names))
	(push (cdr bind) obstacles)))))
(defun user-obstacle-p (user)
  (dolist (obstacle (aref user 2))
    (unless (member (aref obstacle 0) '(block-local tagbody-local))
      (return t))))
(defun binding-obstacle-p (binding)
  (some #'user-obstacle-p (binding-users binding)))
(defun binding-users (binding)
  (aref binding 3))
(defun (setf binding-users) (new-users binding)
  (setf (aref binding 3) new-users))
(defun binding-height (binding)
  (aref binding 4))
(defun (setf binding-height) (new-height binding)
  (setf (aref binding 4) new-height))
(defun user-obstacles (user)
  (aref user 2))
(defun function-upward-funarg-p (function)
  (aref function 4))
(defun user-upward-funarg-p (user)
  (some #'function-upward-funarg-p (user-obstacles user)))
(defun binding-upward-funarg-p (binding)
  (some #'user-upward-funarg-p (binding-users binding)))
(defun transform-function (lambda-list body environment)
  (let ((transformed-lambda-list nil))
    (dolist (elem lambda-list)
      (if (member elem lambda-list-keywords)
	  (push elem transformed-lambda-list)
	  (if (consp elem)
	      (let* ((initializer (transform (cadr elem) environment))
		     (binding (vector 'lambda-let initializer nil nil nil)))
		(push (list* (car elem) binding (cddr elem))
		      transformed-lambda-list)
		(push (cons (car elem) binding) environment)
		(when (cddr elem)
		  (push (caddr elem) environment)))
	      (let ((binding (vector 'lambda-let (vector 'constant nil)
				     nil nil nil)))
		(push (list elem binding) transformed-lambda-list)
		(push (cons elem binding) environment)))))
    (push (cons (list 'lambda) (vector 'lambda nil nil nil nil)) environment)
    (vector 'lambda (reverse transformed-lambda-list)
	    (transform-progn body environment)
	    nil nil (incf (compilation-label-counter *compilation*)))))
(defun transform-progn (forms environment)
  (mapcar #'(lambda (form)
	      (transform form environment))
	  forms))
(defparameter *transforms* (make-hash-table))
(defparameter *write-cs* (make-hash-table))
(defmacro deftransform (operator lambda-list &rest body)
  `(setf (gethash ',operator *transforms*)
    #'(lambda ,(cons 'environment lambda-list) ,@body)))
(defmacro defwrite-c (operator &rest body)
  `(setf (gethash ',operator *write-cs*)
    #'(lambda (intermediate stack-height frame-height receiver) ,@body)))
(deftransform block (tag &rest forms)
  (let* ((binding (vector 'block tag nil nil
			  (incf (compilation-label-counter *compilation*))
			  nil))
	 (new-env (acons (list 'block tag) binding environment)))
    (setf (aref binding 2) (transform-progn forms new-env))
    (unless (binding-obstacle-p binding)
      (setf (aref binding 0) 'block-local))
    binding))
(deftransform catch (tag-form &rest forms)
  (let* ((binding (vector 'catch (transform tag-form environment) nil nil))
	 (new-env (acons (list 'catch) binding environment)))
    (setf (aref binding 2) (transform-progn forms new-env))
    binding))
(deftransform flet (bindings &rest forms)
  (let ((binding (vector 'flet nil nil nil))
	(functions nil)
	(new-env environment))
    (dolist (bind bindings)
      (let* ((rest (cdr bind))
	     (function (transform-function (car rest) (cdr rest) environment)))
	(push function functions)
	(push (cons (list 'function (car bind)) function) new-env)))
    (setf (aref binding 1) (reverse functions))
    (setf (aref binding 2) (transform-progn forms new-env))
    binding))
(deftransform function (specifier)
  (if (and (consp specifier) (eq 'lambda (car specifier)))
      (let ((function (transform-function (cadr specifier) (cddr specifier)
					  environment)))
	(setf (aref function 4) t)
	function)
      (let ((binding (binding environment (list 'function specifier))))
	(if binding
	    (let ((reference (vector 'function-local binding)))
	      (push reference (aref binding 3))
	      reference)
	    (vector 'function-global specifier)))))
(deftransform go (tag)
  (multiple-value-bind (binding obstacles)
      (binding environment (list 'go tag) *control-obstacles*)
    (if binding
	(let ((reference (vector 'go binding obstacles)))
	  (push reference (aref (cdr binding) 3))
	  reference)
	(vector 'go-unbound tag))))
(deftransform if (if then else)
  (vector 'if (transform if environment)
	  (transform then environment)
	  (transform else environment)))
(deftransform labels (bindings &rest forms)
  (let ((binding (vector 'flet nil nil nil)))
    (dolist (bind bindings)
      (push (cons (list 'function (car bind))
		  (vector 'lambda nil nil nil nil))
	    environment))
    (setf (aref binding 1)
	  (mapcar #'(lambda (bind)
		      (transform-function (cadr bind) (cddr bind)
					  environment))))
    (do ((functions (reverse (aref binding 1)) (cdr functions))
	 (binds environment))
	((not functions))
      (let ((function (car functions))
	    (bind-fn (cdar binds)))
	(setf (aref function 3) (aref bind-fn 3))))
    (setf (aref binding 2) (transform-progn forms environment))
    binding))
(deftransform let (bindings &rest forms)
  (labels ((descend-bind (bindings new-env)
	     (if bindings
		 (let* ((bind (car bindings))
			(binding (vector 'let
					 (transform (cadr bind) environment)
					 nil nil nil)))
		   (setf (aref binding 2)
			 (descend-bind (cdr bindings)
				       (acons (car bind) binding new-env)))
		   binding)
		 (transform-progn forms new-env))))
    (descend-bind bindings environment)))
(deftransform let* (bindings &rest forms)
  (labels ((descend-bind (bindings new-env)
	     (if bindings
		 (let* ((bind (car bindings))
			(binding (vector 'let
					 (transform (cadr bind) new-env)
					 nil nil nil)))
		   (setf (aref binding 2)
			 (descend-bind (cdr bindings)
				       (acons (car bind) binding new-env)))
		   binding)
		 (transform-progn forms new-env))))
    (descend-bind bindings environment)))
(deftransform macrolet (bindings &rest forms)
  (dolist (bind bindings)
    (push (cons (car bind)
		(list (coerce `#'(lambda ,@(cdr arguments)) 'function)))
	  environment))
  (vector 'progn (transform-progn forms environment)))
(deftransform multiple-value-call (fn-form &rest forms)
  (vector 'multiple-value-call
	  (transform fn-form enviroment)
	  (transform-progn forms environment)))
(deftransform multiple-value-prog1 (form-1 &rest forms)
  (vector 'multiple-value-prog1
	  (transform form-1 environment)
	  (transform-progn forms environment)))
(deftransform progn (&rest forms)
  (vector 'progn (transform-progn forms environment)))
(deftransform progv (&rest forms)
  (vector 'progv (transform-progn forms environment)))
(deftransform quote (datum)
  (vector 'constant datum))
(deftransform return-from (tag &optional form)
  (multiple-value-bind (binding obstacles)
      (binding environment (list 'block tag) *control-obstacles*)
    (if binding
	(let ((reference (vector 'return-from binding obstacles
				 (transform form environment))))
	  (push reference (aref binding 3))
	  reference)
	(vector 'return-from-unbound tag))))
(deftransform setq (&rest arguments)
  (do ((pairs arguments (cddr pairs))
       (sets nil))
      ((not pairs) (vector 'progn (reverse sets)))
    (let ((symbol (car pairs))
	  (value (cadr pairs)))
      (multiple-value-bind (binding obstacles)
	  (binding environment symbol *stack-obstacles*)
	(if binding
	    (if (consp binding)
		(push (transform `(setf ,symbol ,value) environment) sets)
		(let ((set (vector 'setq binding obstacles
				   (transform value environment))))
		  (push set (binding-users binding))
		  (push set sets)))
	    (multiple-value-bind (symbol expandedp)
		(macroexpand-1 symbol)
	      (if expandedp
		  (push (transform `(setf ,symbol ,value) environment) sets)
		  (push (vector 'dynamic-setq symbol
				(transform value environment))
			sets))))))))
(deftransform symbol-macrolet (bindings &rest forms)
  (dolist (bind bindings)
    (push bind environment))
  (vector 'progn (transform-progn forms environment)))
(deftransform tagbody (&rest arguments)
  (let ((tags (remove-if #'consp arguments))
	(binding (vector 'tagbody nil nil nil))
	(label-counter (compilation-label-counter *compilation*)))
    (push (cons (list 'tagbody) binding) environment)
    (dolist (tag tags)
      (push (list* (list 'go tag)
		   (incf (compilation-label-counter *compilation*))
		   binding)
	    environment))
    (setf (aref binding 1)
	  (mapcar #'(lambda (form)
		      (if (consp form)
			  (transform form environment)
			  (vector 'tag (incf label-counter))))
		  arguments))
    (unless (binding-obstacle-p binding)
      (setf (aref binding 0) 'tagbody-local))
    binding))
(deftransform throw (&rest arguments)
  (vector 'throw (transform-progn arguments environment)))
(deftransform unwind-protect (form-1 &rest forms)
  (vector 'unwind-protect
	  (transform form-1 (acons (list 'unwind-protect) nil environment))
	  (transform-progn forms environment)))
(defun transform (form &optional environment)
  (if (consp form)
      (let* ((operator (car form))
	     (arguments (cdr form))
	     (transform (gethash operator *transforms*)))
	(if transform
	    (apply transform environment arguments)
	    (let ((binding (binding environment (list 'function operator)))
		  (targs (transform-progn arguments environment)))
	      (if binding
		  (if (consp binding)
		      (transform (funcall (car binding) form) environment)
		      (let ((reference (vector 'funcall-local binding targs
					       environment)))
			(push reference (binding-users binding))
			reference))
		  (multiple-value-bind (form expandedp)
		      (macroexpand-1 form)
		    (if expandedp
			(transform form environment)
			(vector 'funcall-global operator targs)))))))
      (if (symbolp form)
	  (multiple-value-bind (binding obstacles)
	      (binding environment form *stack-obstacles*)
	    (if binding
		(if (consp binding)
		    (transform (car binding) environment)
		    (let ((reference (vector 'reference binding obstacles)))
		      (push reference (aref binding 3))
		      reference))
		(multiple-value-bind (form expandedp)
		    (macroexpand-1 form)
		  (if expandedp
		      (transform form environment)
		      (vector 'dynamic-reference form)))))
	  (vector 'constant form))))
(defun write-c-progn (intermediate stack-height frame-height receiver)
  (do ((intermediate intermediate (cdr intermediate)))
      ((not (cdr intermediate))
       (write-c (if intermediate (car intermediate) (vector 'constant nil))
		stack-height frame-height receiver))
    (write-c (car intermediate) stack-height frame-height nil)))
(defun write-receive (receiver frame-height)
  (case receiver
    ((nil))
    ((t) (format *compiler-output* "return "))
    (t (format *compiler-output* "f[~A]=" (- receiver frame-height)))))
(defwrite-c block-local
  (setf (aref intermediate 5) receiver)
  (write-c-progn (aref intermediate 2) stack-height frame-height receiver)
  (format *compiler-output* "L~A: ;~%" (aref intermediate 4)))
(defwrite-c constant
    (when receiver
      (write-receive receiver frame-height)
      (format *compiler-output* "~A;~%"
	      (intern-constant-string (aref intermediate 1)))))
(defwrite-c dynamic-reference
    (when receiver
      (write-receive receiver frame-height)
      (format *compiler-output* "o2a(~A)[4];~%"
	      (intern-constant-string (aref intermediate 1)))))
(defwrite-c dynamic-setq
  (incf stack-height)
  (write-c (aref intermediate 2) stack-height frame-height stack-height)
  (write-receive receiver frame-height)
  (format *compiler-output* "o2a(~A)[4]=f[~A];~%"
	  (intern-constant-string (aref intermediate 1))
	  (- stack-height frame-height)))
(defwrite-c flet
  (dolist (function (aref intermediate 1))
    (setf (binding-height function) (incf stack-height))
    (write-receive stack-height frame-height)
    (format *compiler-output*
	    "ma(f,5,212,ms(f,3,212,F~A,0,-1),0,0,0,0);~%"
	    (aref function 5))
    (write-string
     (with-output-to-string (*compiler-output*)
       (format *compiler-output* "lval F~A(lval *f, lval *h) {~%"
	       (aref function 5))
       (let ((sh stack-height)
	     (frame-height stack-height))
	 (dolist (arg (aref function 1))
	   (let ((binding (cadr arg)))
	     (setf (binding-height binding) (incf sh))))
	 (write-c-progn (aref function 2) sh frame-height t))
       (format *compiler-output* "}~%"))
     (compilation-output *compilation*)))
  (write-c-progn (aref intermediate 2) stack-height frame-height receiver))
(defwrite-c funcall-global
  (unless (= frame-height stack-height)
    (incf stack-height)
    (format *compiler-output* "f[~A]=f[-1];~%"
	    (- stack-height frame-height)))
  (let ((arg-height (+ 2 stack-height)))
    (dolist (arg (aref intermediate 2))
      (write-c arg stack-height frame-height arg-height)
      (incf arg-height)))
  (write-receive receiver frame-height)
  (format *compiler-output* "call(f~A, ~A, ~A);~%"
	  (if (= frame-height stack-height)
	      ""
	      (conc-string "+"
			   (integer-string (- stack-height frame-height))))
	  (intern-constant-string (aref intermediate 1))
	  (length (aref intermediate 2))))
(defwrite-c funcall-local
  (unless (= frame-height stack-height)
    (incf stack-height)
    (format *compiler-output* "f[~A]=f[-1];~%"
	    (- stack-height frame-height)))
  (format *compiler-output* "f[~A]=f[~A];~%"
	  (+ 1 (- stack-height frame-height))
	  (- (binding-height (aref intermediate 1)) frame-height))
  (let ((arg-height (+ 2 stack-height)))
    (dolist (arg (aref intermediate 2))
      (write-c arg stack-height frame-height arg-height)
      (incf arg-height))
    (write-receive receiver frame-height)
    (format *compiler-output* "F~A(f+~A, f+~A);~%"
	    (aref (aref intermediate 1) 5)
	    (+ 1 (- stack-height frame-height))
	    (- arg-height frame-height))))
(defwrite-c function-global
  (when receiver
    (write-receive receiver frame-height)
    (let ((name (aref intermediate 1)))
      (if (consp name)
	  (format *compiler-output* "o2a(~A)[6];~%"
		  (intern-constant-string (cadr name)))
	  (format *compiler-output* "o2a(~A)[5];~%"
		  (intern-constant-string name))))))
(defwrite-c go
  (format *compiler-output* "goto L~A;~%" (car (aref intermediate 1))))
(defwrite-c go-unbound
  (format *compiler-output* "dbgr(f, 9, ~A, 0);~%"
	  (intern-constant-string (aref intermediate 1))))
(defwrite-c if
  (write-c (aref intermediate 1) stack-height frame-height
	   (+ 1 stack-height))
  (format *compiler-output* "if (f[~A]) {~%"
	  (- (+ 1 stack-height) frame-height))
  (write-c (aref intermediate 2) stack-height frame-height receiver)
  (format *compiler-output* "} else {~%")
  (write-c (aref intermediate 3) stack-height frame-height receiver)
  (format *compiler-output* "}~%"))
(defwrite-c lambda
  (write-string
   (with-output-to-string (*compiler-output*)
     (format *compiler-output* "lval F~A(lval *f, lval *h) {~%"
	     (aref intermediate 5))
     (let ((frame-height stack-height))
       "(incf stack-height)"
       (dolist (arg (aref intermediate 1))
	 (let ((binding (cadr arg)))
	   (setf (binding-height binding) (incf stack-height))))
       (write-c-progn (aref intermediate 2) stack-height frame-height t))
     (format *compiler-output* "}~%"))
   (compilation-output *compilation*))
  (write-receive receiver frame-height)
  (format *compiler-output* "ma(f,5,212,ms(f,3,212,F~A,0,-1),0,0,0,0);~%"
	  (aref intermediate 5)))
(defwrite-c let
  (incf stack-height)
  (setf (binding-height intermediate) stack-height)
  (write-c (aref intermediate 1) (- stack-height 1) frame-height
	   stack-height)
  (write-c-progn (aref intermediate 2) stack-height frame-height receiver))
(defwrite-c progn
  (write-c-progn (aref intermediate 1) stack-height frame-height receiver))
(defwrite-c reference
  (when receiver
    (write-receive receiver frame-height)
    (format *compiler-output* "f[~A];~%"
	    (- (binding-height (aref intermediate 1)) frame-height))))
(defwrite-c return-from
  (let ((binding (aref intermediate 1)))
    (write-c (aref intermediate 3) stack-height frame-height
	     (aref binding 5))
    (format *compiler-output* "goto L~A;~%" (aref binding 4))))
(defwrite-c return-from-unbound
  (format *compiler-output* "dbgr(f, 8, ~A, 0);~%"
	  (intern-constant-string (aref intermediate 1))))
(defwrite-c setq
  (write-c (aref intermediate 3) stack-height frame-height
	   (binding-height (aref intermediate 1))))
(defwrite-c tag
  (format *compiler-output* "L~A: ;~%" (aref intermediate 1)))
(defwrite-c tagbody-local
  (dolist (form (aref intermediate 1))
    (write-c form stack-height frame-height nil))
  (when receiver
    (write-receive receiver frame-height)
    (format *compiler-output* "0;~%")))
(defun write-c (intermediate &optional (stack-height 0) (frame-height 0)
		receiver)
  (let ((write-c (gethash (aref intermediate 0) *write-cs*)))
    (if write-c
	(funcall write-c intermediate stack-height frame-height receiver)
	(error))))
(defstruct (compilation
	     (:constructor construct-compilation
			   (package-hash symbol-hash class-hash value-hash
					 values opaques output)))
  package-hash
  symbol-hash
  class-hash
  value-hash
  (value-length 0)
  (packages nil)
  (symbols nil)
  (classes nil)
  values
  opaques
  output
  (label-counter 0))
(defun test-compilation (val)
  (let ((basename "test"))
    (with-open-file (*compiler-output* (conc-string basename ".c")
				       :direction :output)
      (let ((*compilation* (start-compilation)))
	(finish-compilation (with-output-to-string (*compiler-output*)
			      (write-c (transform val))))))
    (run-cc basename)))
(defun test-transform (val)
  (let ((*compilation* (start-compilation)))
    (transform val)))
(defun show-ascii-art ()
  (write-line "         ___     _,.--.,_")
  (write-line "      .-~   ~--\"~-.   ._ \"-.")
  (write-line "     /      ./_    Y    \"-. \\")
  (write-line "    Y       :~     !         Y")
  (write-line "    lq p    |     /         .|")
  (write-line " _   \\. .-, l    /          |j")
  (write-line "()\\___) |/   \\_/\";          !")
  (write-line " \\._____.-~\\  .  ~\\.      ./")
  (write-line "            Y_ Y_.\"vr\"~  T")
  (write-line "            (  (    |L    j")
  (write-line "            [nn[nn..][nn..]"))
(show-ascii-art)
(read-eval-print-loop)
