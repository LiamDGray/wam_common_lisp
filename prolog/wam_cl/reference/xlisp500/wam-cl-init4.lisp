(defun simple-string-p (object)
  (and (= (ldb '(2 . 0) (ival object)) 3) (= (jref object 1) 20)))
(defun char (string index)
  (aref string index))
(defun (setf char) (new-character string index)
  (setf (aref string index) new-character))
(defun schar (string index)
  (aref string index))
(defun (setf schar) (new-character string index)
  (setf (aref string index) new-character))
(defun string-upcase (string &key (start 0) end)
  (nstring-upcase (copy-seq string) :start start :end end))
(defun string-downcase (string &key (start 0) end)
  (nstring-downcase (copy-seq string) :start start :end end))
(defun string-capitalize (string &key (start 0) end)
  (nstring-capitalize (copy-seq string) :start start :end end))
(defun nstring-upcase (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (tagbody
   start
     (when (< start end)
       (setf (aref string start) (char-upcase (aref string start)))
       (incf start)
       (go start)))
  string)
(defun nstring-downcase (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (tagbody
   start
     (when (< start end)
       (setf (aref string start) (char-downcase (aref string start)))
       (incf start)
       (go start)))
  string)
(defun nstring-capitalize (string &key (start 0) end)
  (setq string (designator-string string))
  (unless end (setq end (length string)))
  (let ((word-start t))
    (tagbody
     start
       (when (< start end)
	 (setf (aref string start)
	       (let ((c (aref string start)))
		 (prog1
		     (if word-start
			 (char-upcase c)
			 (char-downcase c))
		   (setq word-start (not (alphanumericp c))))))
	 (incf start)
	 (go start))))
  string)
(defun string-trim (character-bag string)
  (let ((i 0)
	(j (length string)))
    (tagbody
     start
       (when (and (< i j) (position (aref string i) character-bag))
	 (incf i)
	 (go start)))
    (tagbody
     start
       (when (and (plusp j) (position (aref string (- j 1)) character-bag))
	 (decf j)
	 (go start)))
    (if (< i j)
	(subseq string i j)
	"")))
(defun string-left-trim (character-bag string)
  (let ((i 0))
    (tagbody
     start
       (when (and (< i (length string))
		  (position (aref string i) character-bag))
	 (incf i)
	 (go start)))
    (subseq string i)))
(defun string-right-trim (character-bag string)
  (let ((i (length string)))
    (tagbody
     start
       (when (and (plusp i) (position (aref string (- i 1)) character-bag))
	 (decf j)
	 (go start)))
    (subseq string 0 i)))


(flet ((string-mismatch (comparator string1 string2
				    &key (start1 0) end1 (start2 0) end2)
	 (setq string1 (designator-string string1))
	 (setq string2 (designator-string string2))
	 (unless end1 (setq end1 (length string1)))
	 (unless end2 (setq end2 (length string2)))
	 (tagbody
	  start
	    (when (and (< start1 end1) (< start2 end2))
	      (unless (funcall comparator
			       (aref string1 start1) (aref string2 start2))
		(return-from string-mismatch start1))
	      (incf start1)
	      (incf start2)
	      (go start)))
	 (if (or (< start1 end1) (< start2 end2))
	     start1
	     nil)))
  (defun string/= (&rest rest)
    (apply #'string-mismatch #'char= rest))
  (defun string-not-equal (&rest rest)
    (apply #'string-mismatch #'char-equal rest)))

(defun *string= (&rest rest)
  (not (apply #'string/= rest)))

(defun string-equal (&rest rest)
  (not (apply #'string-not-equal rest)))

(flet ((string-mismatch (exit continue default1 default2 default3
			 string1 string2 &key (start1 0) end1 (start2 0) end2)
	 (setq string1 (designator-string string1))
	 (setq string2 (designator-string string2))
	 (unless end1 (setq end1 (length string1)))
	 (unless end2 (setq end2 (length string2)))
	 (tagbody
	  start
	    (when (and (< start1 end1) (< start2 end2))
	      (let ((c1 (aref string1 start1))
		    (c2 (aref string2 start2)))
		(when (funcall exit c1 c2)
		  (return-from string-mismatch start1))
		(unless (funcall continue c1 c2)
		  (return-from string-mismatch)))
	      (incf start1)
	      (incf start2)
	      (go start)))
	 (when (cond
		 ((< start1 end1) default1)
		 ((< start2 end2) default2)
		 (t default3))
	   start1)))
  (defun string< (&rest rest)
    (apply #'string-mismatch #'char< #'char= nil t nil rest))
  (defun string<= (&rest rest)
    (apply #'string-mismatch #'char< #'char= nil t t rest))
  (defun string> (&rest rest)
    (apply #'string-mismatch #'char> #'char= t nil nil rest))
  (defun string>= (&rest rest)
    (apply #'string-mismatch #'char> #'char= t nil t rest))
  (defun string-lessp (&rest rest)
    (apply #'string-mismatch #'char-lessp #'char-equal nil t nil rest))
  (defun string-not-greaterp (&rest rest)
    (apply #'string-mismatch #'char-lessp #'char-equal nil t t rest))
  (defun string-greaterp (&rest rest)
    (apply #'string-mismatch #'char-greaterp #'char-equal t nil nil rest))
  (defun string-not-lessp (&rest rest)
    (apply #'string-not-lessp #'char-greaterp #'char-equal t nil t rest)))
(defun stringp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (and (member (iref object 1) '(4 7))
	    (atom (iref object 3))))
    (3 (= (jref object 1) 20))))
(defun make-string (size &key (initial-element (code-char 0))
		    (element-type 'character))
  (let* ((string (makej (+ 1 (* size 8)) 20))
	 (i 0)
	 (init-code (char-code initial-element))
	 (init (* 16843009 init-code)))
    (tagbody
     start
       (when (< i (/ size 4))
	 (setf (jref string (+ 2 i)) init)
	 (setf i (+ 1 i))
	 (go start)))
    (setf (jref string (+ 2 (/ size 4)))
	  (dpb init (cons (* 8 (ldb '(2 . 0) size)) 0) 0))
    string))

(defun reverse (sequence)
  (if (listp sequence)
      (let ((acc nil))
	(dolist (elem sequence)
	  (push elem acc))
	acc)
      "FIXME"))
(defun nreverse (sequence)
  (if (listp sequence)
      (let ((prev nil))
	(tagbody
	 start
	   (when sequence
	     (let ((next (cdr sequence)))
	       (setf (cdr sequence) prev)
	       (setf prev sequence)
	       (setf sequence next))
	     (go start)))
	prev)
      "FIXME"))

