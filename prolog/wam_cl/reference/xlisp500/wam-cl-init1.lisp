#|
(funcall #'(setf macro-function)
	 #'(lambda (name lambda-list &rest body)
	     (list 'progn
		   (list 'funcall '#'(setf macro-function)
			 (list 'function
			       (cons 'lambda (cons lambda-list body)))
			 (list 'quote name))
		   (list 'quote name)))
	 'defmacro)
|#

(defmacro defun500 (name lambda-list &rest body)
  (list 'progn
	(list 'funcall '#'(setf fdefinition)
	      (list 'function
		    (list 'lambda lambda-list
			  (cons 'block (cons (if (consp name)
						 (car (cdr name))
						 name)
					     body))))
	      (list 'quote name))
	(list 'quote name)))

(defmacro setf (place new-value)
  (if (consp place)
      (cons 'funcall (cons (list 'function (list 'setf (car place)))
			   (cons new-value (cdr place))))
      (list 'setq place new-value)))
(defun append (&rest lists)
  (if (cdr lists)
      (let ((list (car lists))
	    (result nil)
	    (end nil))
	(if list
	    (tagbody
	     start
	       (if list
		   (progn
		     (setf end (if end
				   (setf (cdr end) (list (car list)))
				   (setf result (list (car list)))))
		     (setf list (cdr list))
		     (go start)))
	       (setf (cdr end) (apply #'append (cdr lists)))
	       (return-from append result))
	    (apply #'append (cdr lists))))
      (car lists)))
(defun backquote-expand (list level)
  (if (consp list) 
      (if (eq 'backquote (car list)) 
	  (list 'list ''backquote 
		(backquote-expand (car (cdr list)) (+ level 1))) 
	  (if (eq 'unquote (car list)) 
	      (if (= level 0) 
		  (car (cdr list)) 
		  (list 'list ''unquote 
			(backquote-expand (car (cdr list)) (- level 1)))) 
	      (if (eq 'unquote-splicing (car list)) 
		  (if (= level 0) 
		      (values (car (cdr list)) t) 
		      (list 'list ''unquote-splicing 
			    (backquote-expand (car (cdr list)) (- level 1)))) 
		  (labels ((collect (list) 
			     (if (consp list) 
				 (cons (multiple-value-call 
					   #'(lambda (value 
						      &optional splicingp) 
					       (if splicingp 
						   value 
						   (list 'list value))) 
				       (backquote-expand (car list) level)) 
				     (collect (cdr list))) 
				 (list (list 'quote list))))) 
		    (cons 'append (collect list)))))) 
      (list 'quote list))) 
(defmacro backquote (form)
  (backquote-expand form 0))

(defun macro-function (symbol &optional environment)
  "(dolist (binding environment)
    (when (and (consp (car binding))
	       (= (floor (ival (cdar binding)) 16) 1)
	       (eq (caar binding) symbol))
      (return-from macro-function 
	(when (= (ldb '(1 . 4) (ival (cdr binding))) 1)
	  (cdr binding)))))"
  (if (= (ldb '(1 . 1) (iref symbol 8)) 1)
      (iref symbol 5)))

(defun macroexpand-1 (form &optional env)
  (if (consp form)
      (let ((definition (macro-function (car form) env)))
	(if definition
	    (values (apply definition (cdr form)) t)
	    (values form nil)))
      (if (and form (symbolp form) (= (ldb '(1 . 0) (iref form 8)) 1))
	  (values (iref form 4) t)
	  (values form nil))))

(defun macroexpand (form &optional env)
  (multiple-value-bind (form expanded-p)
      (macroexpand-1 form env)
    (if expanded-p
	(tagbody
	 start
	   (multiple-value-bind (expansion expanded-p)
	       (macroexpand-1 form env)
	     (if expanded-p
		 (progn
		   (setq form expansion)
		   (go start))
		 (return-from macroexpand (values expansion t)))))
	(values form nil))))
(defmacro define-symbol-macro (symbol expansion)
  `(progn
    (setf (iref ',symbol 4) ',expansion)
    (setf (iref ',symbol 8) (dpb 1 (cons 1 0) (iref ',symbol 8)))
    ',symbol))
(defun special-operator-p (symbol)
  (member symbol '(block catch eval-when flet function go if labels let let*
		   load-time-value locally macrolet multiple-value-call
		   multiple-value-prog1 progn progv quote return-from setq
		   symbol-macrolet tagbody the throw unwind-protect)))
(defun constantp (form &optional environment)
  (not (or (and (symbolp form)
		(zerop (ldb '(1 . 4) (iref form 8))))
	   (and (consp form)
		(not (eq (car form) 'quote))))))
(defun null (object) (if object nil t))
(defun not (object) (if object nil t))
(defun length (sequence)
  (let ((tag (ldb '(2 . 0) (ival sequence))))
    (if (= tag 0)
	0
	(if (= tag 1)
	    (let ((i 0)) (dolist (elem sequence i) (setf i (+ 1 i))))
	    (if (= tag 2)
		(let ((subtag (iref sequence 1)))
		  (if (= subtag 3)
		      (/ (ival (iref sequence 0)) 256)
		      (if (= subtag 4)
			  (let ((dimensions/fill (iref sequence 3)))
			    (if (consp dimensions/fill)
				(error "not a sequence")
				(or dimensions/fill
				    (length (iref sequence 4)))))
			  0)))
		(let ((subtag (jref sequence 1)))
		  (if (= subtag 20)
		      (- (/ (jref sequence 0) 64) 4)
		      (if (= subtag 116)
			  (- (/ (jref sequence 0) 8) 31)
			  (error "not a sequence")))))))))
(defun mod (x y) (multiple-value-call #'(lambda (q r) r) (floor x y)))
(defun functionp (object) (eq (type-of object) 'function))
(defun coerce (object result-type)
  (if (typep object result-type)
      object
      (case result-type
	((t) object)
	(character (character object))
	(function (if (and (consp object) (eq (car object) 'lambda))
		      (eval (list 'function object))
		      (if (fboundp object)
			  (fdefinition object))
			  (error 'type-error :datum object
				 :expected-type result-type)))
	(t (error 'type-error :datum object :expected-type result-type)))))
(defun ensure-type (name expander)
  (let ((cons (assoc name *type-expanders*)))
    (if cons
	(setf (cdr cons) expander)
	(push (cons name expander) *type-expanders*))
    name))
(defmacro deftype (name lambda-list &rest forms)
  `(ensure-type ',name #'(lambda ,lambda-list (block ,name ,@forms))))
(defun *= (cons number)
  (or (not cons) (eq (car cons) '*) (= (car cons) number)))
(defun typep (object type-specifier &optional environment)
  (let ((tag (ldb '(2 . 0) (ival object))))
    (case type-specifier
      ((nil extended-char) nil)
      ((t *) t)
      (null (not object))
      (list (or (not object) (= tag 1)))
      (fixnum (and (= tag 0) (= (ldb '(5 . 0) (ival object)) 16)))
      (package (and (= tag 2) (= (iref object 1) 5)))
      (symbol (or (not object) (and (= tag 2) (= (iref object 1) 0))))
      ((character base-char)
       (and (= tag 0) (= (ldb '(5 . 0) (ival object)) 24)))
      (standard-char (and (= tag 0)
			  (= (ldb '(5 . 0) (ival object)) 24)
			  (let ((code (char-code object)))
			    (or (= code 10)
				(< 31 code 127)))))
      (bit (member object '(0 1)))
      (t (setq type-specifier (designator-list type-specifier))
	 (case (car type-specifier)
	   (cons (and (= tag 1)
		      (or (not (cdr type-specifier))
			  (typep (car object) (cadr type-specifier)))
		      (or (not (cddr type-specifier))
			  (typep (car object) (caddr type-specifier)))))
	   ((string base-string) (and (stringp object)
				      (*= (cdr type-specifier)
					  (length object))))
	   (satisfies (funcall (cadr type-specifier) object))
	   (member (member object (cdr type-specifier)))
	   (not (not (typep object (cadr type-specifier))))
	   (and (every #'(lambda (spec) (typep object spec))
		       (cdr type-specifier)))
	   (or (some #'(lambda (spec) (typep object spec))
		     (cdr type-specifier)))
	   (eql (eql object (cadr type-specifier)))
	   (t (when (= tag 2)
		(let ((class (iref object 1)))
		  (when (= (ldb '(2 . 0) (ival class)) 2)
		    (member (car type-specifier)
			    (mapcar #'class-name
				    (class-precedence-list class))))))))))))
(defun fboundp (function-name)
  (if (consp function-name)
      (iboundp (cadr function-name) 6)
      (iboundp function-name 5)))
(defun fdefinition (function-name)
  (if (consp function-name)
      (if (iboundp (cadr function-name) 6)
	  (iref (cadr function-name) 6)
	  (error 'undefined-error :name function-name))
      (if (iboundp function-name 5)
	  (iref function-name 5)
	  (error 'undefined-error :name function-name))))
(defun function-lambda-expression (function)
  (values (list* 'lambda (iref function 4) (iref function 5))
	  (iref function 3)
	  (iref function 6)))
(defmacro defconstant (name initial-value &optional documentation)
  `(progn
    (setf (iref ',name 4) ,initial-value)
    (setf (iref ',name 8) (dpb 1 '(1 . 4) (iref ',name 8)))
    ',name))
(defmacro defparameter (name initial-value &optional documentation)
  `(progn
    (setf (iref ',name 4) ,initial-value)
    (setf (iref ',name 8) (dpb 1 (cons 1 2) (iref ',name 8)))
    ',name))

(defparameter *type-expanders* nil)
(defconstant call-arguments-limit 65536)
(defconstant lambda-parameters-limit 65536)
(defconstant multiple-values-limit 65536)
(defconstant lambda-list-keywords
  '(&allow-other-keys &aux &body &environment &key &optional &rest &whole))

(defmacro defvar (name &rest rest)
  `(progn
    (unless (or (iboundp ',name 4) ,(not rest))
      (setf (iref ',name 4) ,(car rest)))
    (setf (iref ',name 8) (dpb 1 (cons 1 2) (iref ',name 8)))
    ',name))
(defmacro psetq (&rest rest)
  (let ((inits nil)
	(sets nil)
	(list rest))
    (tagbody
     start
       (when (cddr list)
	 (push (list (gensym) (cadr list)) inits)
	 (setq list (cddr list))
	 (go start)))
    (setq list inits)
    (tagbody
     start
       (when (cddr rest)
	 (push (caar list) sets)
	 (push (car rest) sets)
	 (setq list (cdr list))
	 (setq rest (cddr rest))
	 (go start)))
    `(let ,(reverse inits)
      (setq ,@sets ,@rest))))
(defmacro return (&optional result)
  `(return-from nil ,result))
(defmacro when (test-form &rest forms)
  `(if ,test-form (progn ,@forms)))
(defmacro unless (test-form &rest forms)
  `(if (not ,test-form) (progn ,@forms)))
(defmacro and (&rest forms)
  (if forms
      (if (cdr forms)
	  `(when ,(car forms) (and ,@(cdr forms)))
	(car forms))
    `t))
(defmacro or (&rest forms)
  (if forms
      (if (cdr forms)
	  (let ((temp (gensym)))
	    `(let ((,temp ,(car forms)))
	      (if ,temp
		  ,temp
		(or ,@(cdr forms)))))
	(car forms))
    `nil))
(defmacro cond (&rest clauses)
  (when clauses
    (if (cdar clauses)
	`(if ,(caar clauses)
	     (progn ,@(cdar clauses))
	     (cond ,@(cdr clauses)))
	`(or ,(caar clauses)
	     (cond ,@(cdr clauses))))))
(defmacro case (keyform &rest clauses)
  (let ((temp (gensym)))
    (labels ((recur (clauses)
	       (when clauses
		 (if (member (caar clauses) '(otherwise t))
		     `(progn ,@(cdar clauses))
		     `(if ,(if (listp (caar clauses))
			       `(member ,temp ',(caar clauses))
			       `(eql ,temp ',(caar clauses)))
		          (progn ,@(cdar clauses))
		          ,(recur (cdr clauses)))))))
      `(let ((,temp ,keyform))
	,(recur clauses)))))

(defun type-of (object)
  (case (ldb (cons 2 0) (ival object))
    (0 (if (eq object nil)
	   'null
	   (if (= (ldb (cons 2 3) (ival object)) 2)
	       'fixnum
	       'character)))
    (1 'cons)
    (2 (case (iref object 1)
	 (0 'symbol)
	 (3 'simple-vector)
	 (4 'array)
	 (5 'package)
	 (6 'function)
	 (t (class-name (iref object 1)))))
    (3 (case (jref object 1)
	 (20 'simple-string)
	 (84 'double)
	 (116 'simple-bit-vector)
	 (t 'file-stream)))))

(defmacro ecase (keyform &rest clauses)
  (let ((temp (gensym)))
    `(let ((,temp ,keyform))
      (case ,temp ,@clauses
	    (error 'type-error :datum ,temp
		   :expected-type `(member ,@(mapcan #'(lambda (x)
							 (if (listp (car x))
							     (car x)
							     (list (car x))))
						     clauses)))))))
(defmacro multiple-value-bind (vars values-form &rest forms)
  `(multiple-value-call #'(lambda (&optional ,@vars &rest ,(gensym))
			    ,@forms)
                        ,values-form))
(defmacro multiple-value-list (form)
  `(multiple-value-call #'list ,form))
(defun values-list (list)
  (apply #'values list))
(defmacro nth-value (n form)
  `(nth ,n (multiple-value-list ,form)))
(defmacro prog (inits &rest forms)
  `(block nil
    (let ,inits
      (tagbody ,@forms))))
(defmacro prog* (inits &rest forms)
  `(block nil
    (let* ,inits
      (tagbody ,@forms))))
(defmacro prog1 (first-form &rest forms)
  (let ((temp (gensym)))
    `(let ((,temp ,first-form))
      ,@forms
      ,temp)))
(defmacro prog2 (first-form second-form &rest forms)
  (let ((temp (gensym)))
    `(progn
      ,first-form
      (let ((,temp ,second-form))
	,@forms
	,temp))))
(defun eql (a b)
  (or (eq a b)
      (and (= (ldb '(2 . 0) (ival a)) 3)
	   (= (ldb '(2 . 0) (ival b)) 3)
	   (= (jref a 1) 84)
	   (= (jref b 1) 84)
	   (= a b))))
(defun equal (a b)
  (or (eql a b)
      (cond
	((not a) nil)
	((consp a) (and (consp b)
			(equal (car a) (car b))
			(equal (cdr a) (cdr b))))
	((stringp a) (and (stringp b)
			  (string= a b)))
	((bit-vector-p a) (and (bit-vector-p b)
			       (= (length a) (length b))
			       (dotimes (i (length a) t)
				 (when (/= (aref a i) (aref b i))
				   (return))))))))
(defun equalp (a b)
  (or (eql a b)
      (cond
	((not a) nil)
	((characterp a) (and (characterp b)
			     (char-equal a b)))
	((consp a) (and (consp b)
			(equalp (car a) (car b))
			(equalp (cdr a) (cdr b))))
	((arrayp a) (and (arrayp b)
			 (equal (array-dimensions a) (array-dimensions b))
			 (dotimes (i (apply #'* (array-dimensions a)) t)
			   (unless (equalp (row-major-aref a i)
					   (row-major-aref b i))
			     (return)))))
	((= (ldb '(2 . 0) (ival a)) 2)
	 (and (= (ldb '(2 . 0) (ival b)) 2)
	      (eq (iref a 1) (iref b 1))
	      (= (ldb '(2 . 0) (ival (iref a 1))) 2)
	      (dotimes (i (iref a 0) t)
		(unless (equalp (iref a (+ 2 i)) (iref b (+ 2 i)))
		  (return))))))))
(defun identity (object) object)
(defun complement (function)
  #'(lambda (&rest rest) (not (apply function rest))))
(defun constantly (value) #'(lambda (&rest rest) value))
(defmacro do (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let ,(dolist (var vars (reverse inits))
	    (push (if (consp var)
		      (list (car var) (cadr var))
		      (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((psetq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))
(defmacro do* (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let* ,(dolist (var vars (reverse inits))
	     (push (if (consp var)
		       (list (car var) (cadr var))
		       (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((setq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))
(defmacro dotimes ((var count-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(count (gensym)))
    `(block nil
      (let ((,var 0)
	    (,count ,count-form))
	(tagbody
	   ,start
	   (when (< ,var ,count)
	     ,@forms
	     (incf ,var)
	     (go ,start)))
	,result-form))))
(defmacro dolist ((var list-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(list (gensym)))
    `(block nil
      (let ((,list ,list-form)
	    (,var nil))
	(tagbody
	   ,start
	   (unless ,list
	     (setf ,var nil)
	     (return-from nil ,result-form))
	   (setf ,var (car ,list))
	   (setf ,list (cdr ,list))
	   ,@forms
	   (go ,start))))))
(defmacro check-type (place typespec &optional string)
  `(tagbody
    start
    (unless (typep ,place ',typespec)
      (restart-case
	  (error 'type-error :datum ,place :expected-type ',typespec)
	(store-value (value)
	  (setf ,place value)))
      (go start))))
(defun designator-condition (default-type datum arguments)
  (if (symbolp datum)
      (apply #'make-condition datum arguments)
      (if (or (stringp datum) (functionp datum))
	  (make-condition default-type
			  :format-control datum
			  :format-arguments arguments)
	  datum)))
(defun error (datum &rest arguments)
  (let ((condition (designator-condition 'simple-error datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    (invoke-debugger condition)))
(defun cerror (continue-format-control datum &rest arguments)
  `(with-simple-restart (continue continue-format-control)
    (apply #'error datum arguments)))
(defun signal (datum &rest arguments)
  (let ((condition (designator-condition 'simple-condition datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    nil))
(defun warn (datum &rest arguments)
  (restart-case
      (let ((warning (if (symbolp datum)
			 (apply #'make-condition 'warning datum arguments)
			 datum)))
	(signal warning)
	(print-object warning *error-output*))
    (muffle-warning () nil))
  nil)
(defun show-frame (frame index)
  (let* ((length (fref (- frame 2)))
	 (fn (fref (- frame length 3))))
    (when (and (= (ldb '(2 . 0) (ival fn)) 2) (= (iref fn 1) 6))
      (format *debug-io* "~A: (~A" index (iref fn 6))
      (dotimes (i length)
	(format *debug-io* " ~A" (fref (+ i (- frame length 2)))))
      (format *debug-io* ")~%"))))
(defun next-frame (frame)
  (- frame (fref (- frame 2)) 3))
(defun next-function-frame (frame)
  (do* ((f (next-frame frame) (next-frame f)))
       ((or (< f 6)
	    (let ((fn (fref (- f (fref (- f 2)) 3))))
	      (and (= (ldb '(2 . 0) (ival fn)) 2) (= (iref fn 1) 6))))
	(and (> f 5) f))))
(defun invoke-debugger (condition)
  (let ((debugger-hook *debugger-hook*)
	(*debugger-hook* nil))
    (when debugger-hook
      (funcall debugger-hook condition debugger-hook))
    (format *debug-io* "Entering debugger.~%")
    (princ condition *debug-io*)
    (terpri *debug-io*)
    (let ((restarts (compute-restarts condition))
	  (stack (makef))
	  (frame-depth 0)
	  (active-frame nil))
      (let ((count 0))
	(dolist (restart restarts)
	  (format *debug-io* "~A: " count)
	  (princ restart *debug-io*)
	  (terpri *debug-io*)
	  (incf count)))
      (setq active-frame (next-function-frame (- stack 20)))
      (show-frame active-frame 0)
      (tagbody
       start
	 (format *debug-io* ";~A> " frame-depth)
	 (let ((form (read)))
	   (case form
	     (:help (format *debug-io* "Type :help to get help.~%")
		    (format *debug-io* "Type :continue <index> to invoke the indexed restart.~%"))
	     (:back (do ((frame (next-function-frame (- stack 20))
				(next-function-frame frame))
			 (index 0 (+ 1 index)))
			((not frame))
		      (show-frame frame index)))
	     (:up (if (plusp frame-depth)
		      (progn
			(decf frame-depth)
			(do ((frame (next-function-frame (- stack 20))
				    (next-function-frame frame))
			     (index 0 (+ 1 index)))
			    ((= index frame-depth) (setq active-frame frame)))
			(show-frame active-frame frame-depth))
		      (format *debug-io* "Top of stack.~%")))
	     (:down (let ((frame (next-function-frame active-frame)))
		      (if frame
			  (progn
			    (incf frame-depth)
			    (setq active-frame frame)
			    (show-frame active-frame frame-depth))
			  (format *debug-io* "Bottom of stack.~%"))))
	     (:locals (do ((env (fref (- active-frame 1)) (cdr env)))
			  ((not env))
			(when (symbolp (caar env))
			  (format *debug-io* "~A~%" (caar env)))))
	     (:continue (let ((index (read)))
			  (invoke-restart-interactively (nth index restarts))))
	     (t (let ((values (multiple-value-list
			       (eval form (fref (- active-frame 1)))))
		      (count 0))
		  (if values
		      (dolist (value values)
			(format *debug-io* ";~A: ~S~%" count value)
			(incf count))
		      (format *debug-io* ";No values.~%")))))
	   (go start))))))
(defun break (&optional format-control &rest format-arguments)
  (with-simple-restart (continue "Return from BREAK.")
    (let ((*debugger-hook* nil))
      (invoke-debugger (make-condition 'simple-condition
				       :format-control format-control
				       :format-arguments format-arguments))))
  nil)
(defparameter *debugger-hook* nil)
(defparameter *break-on-signals* nil)
(defparameter *handlers* nil)
(defun invoke-handler (condition)
  (dolist (handler *handlers*)
    (when (typep condition (car handler))
      (setq *handlers* (caddr handler))
      (funcall (cadr handler) condition))))
(defmacro handler-bind (bindings &rest forms)
  (let ((form '*handlers*)
	(handlers (gensym)))
    (dolist (binding (reverse bindings))
      (setq form
	    `(cons (list ',(car binding) ,(cadr binding) ',handlers) ,form)))
    `(let ((handlers *handlers*)
	   (*handlers* ,form))
      ,@forms)))
(defmacro handler-case (expression &rest clauses)
  (let ((tag (gensym))
	(bindings nil))
    `(handler-bind
      ,(dolist (clause clauses (reverse bindings))
	 (let ((typespec (car clause))
	       (var-list (cadr clause))
	       (forms (cddr clauses)))
	   (push `(typespec #'(lambda (,(if var-list (car var-list) (gensym)))
				(return-from tag (progn ,@forms))))
		 bindings)))
      ,expression)))
(defmacro ignore-errors (&rest forms)
  `(handler-case (progn ,@forms)
    (error (condition) (values nil condition))))
(defparameter *restarts* nil)
(defun compute-restarts (&optional condition)
  "FIXME restarts associated with conditions"
  (if condition
      *restarts*
      *restarts*))
(defun find-restart (identifier &optional condition)
  (dolist (restart *restarts*)
    (when (eq restart identifier)
      (return restart))
    (when (eq (restart-name restart) identifier)
      (return restart))))
(defun designator-restart (designator)
  (if (restartp designator)
      designator
      (dolist (restart *restarts* (error 'type-error :datum designator
					 :expected-type 'restart))
	(when (eq (restart-name restart) designator)
	  (return restart)))))
(defun invoke-restart (restart &rest arguments)
  (setq restart (designator-restart restart))
  (apply (restart-function restart) arguments))
(defun invoke-restart-interactively (restart)
  (setq restart (designator-restart restart))
  (apply (restart-function restart)
	 (funcall (restart-interactive-function restart))))
(defmacro restart-bind (restart-bindings &rest forms)
  (let ((form '*restarts*))
    (dolist (binding (reverse restart-bindings))
      (setq form
	    `(cons (make-restart ',(car binding) ,@(cdr binding)) ,form)))
    `(let ((*restarts* ,form))
      ,@forms)))
(defmacro restart-case (restartable-form &rest clauses)
  (let ((catch-tag (gensym))
	(bindings nil))
    `(catch ',catch-tag
      (restart-bind
	  ,(dolist (clause clauses (reverse bindings))
	     (let ((name (car clause))
		   (lambda-list (cadr clause))
		   (rest (cddr clause))
		   (interactive '#'(lambda () nil))
		   (report '#'(lambda (stream)
				(format stream "~A" (car clause))))
		   (test '#'(lambda (condition) t)))
	       (tagbody
		start
		  (when (member (car rest) '(:interactive :report :test))
		    (let ((value (cadr rest)))
		      (case (car rest)
			(:interactive (setq interactive `(function ,value)))
			(:report (setq report
				       (if (stringp value)
					   `#'(lambda (stream)
						(write-string ,value stream))
					   `(function ,value))))
			(:test (setq test `(function ,value)))))
		    (setq rest (cddr rest))
		    (go start)))
	       (push `(,(car clause)
		       #'(lambda ,(cadr clause)
			   (throw ',catch-tag (progn ,@rest)))
		       :interactive-function ,interactive
		       :report-function ,report
		       :test-function ,test)
		     bindings)))
	,restartable-form))))
(defmacro with-simple-restart ((name format-control &rest format-arguments)
			       &rest forms)
  (let ((tag (gensym)))
    `(block ,tag
      (restart-bind
	  ((,name
	    #'(lambda () (return-from ,tag (values nil t)))
	     :interactive-function #'(lambda () nil)
	     :report-function #'(lambda (stream)
				  (apply #'format stream ',format-control
					 ',format-arguments))
	     :test-function #'(lambda () t)))
	,@forms))))
(defun abort (&optional condition)
  (invoke-restart (find-restart 'abort condition))
  (error 'control-error))
(defun continue (&optional condition)
  (invoke-restart (find-restart 'continue condition)))
(defun muffle-warning (&optional condition)
  (invoke-restart (find-restart 'muffle-warning condition))
  (error 'control-error))
(defun store-value (value &optional condition)
  (invoke-restart (find-restart 'store-value condition) value))
(defun use-value (value &optional condition)
  (invoke-restart (find-restart 'use-value condition) value))
(defun integer-string (integer &optional (radix 10))
  (if (= integer 0)
      "0"
      (labels ((recur (i l)
		 (if (= i 0)
		     l
		     (multiple-value-bind (ni r)
			 (floor i radix)
		       (recur ni (cons (code-char (+ (if (< r 10) 48 55) r))
				       l))))))
	(apply #'string (if (< 0 integer)
			    (recur integer nil)
			    (cons (code-char 45) (recur (- integer) nil)))))))
(defun designator-symbol (designator)
  (if (symbolp designator)
      designator
      (find-symbol designator)))
(defun symbolp (object) (or (null object) (eq (type-of object) 'symbol)))
(defun keywordp (object)
  (and (symbolp object)
       (string= (package-name (symbol-package object)) "KEYwORD")))
(defun make-symbol (name)
  (let ((symbol (makei 9 0 name nil nil nil nil (- 1) 0)))
    (imakunbound symbol 4)
    (imakunbound symbol 5)
    (imakunbound symbol 6)
    symbol))
(defun copy-symbol (symbol &optional copy-properties)
  (let ((new-symbol (make-symbol (iref symbol 2))))
    (cond
      (copy-properties
       (setf (iref new-symbol 4) (iref symbol 4))
       (setf (iref new-symbol 5) (iref symbol 5))
       (setf (iref new-symbol 6) (iref symbol 6))
       (setf (iref new-symbol 10) (iref symbol 10)))
      (t
       (imakunbound new-symbol 4)
       (imakunbound new-symbol 5)
       (imakunbound new-symbol 6)))
    new-symbol))
(defun fixnump (object)
  (= (ldb '(5 . 0) (ival object)) 16))
(defvar *gensym-counter* 0)
(defun gen-sym (&optional x)
  (let ((prefix (if (stringp x) x "G"))
	(suffix (if (fixnump x)
		    x
		    (let ((x *gensym-counter*))
		      (setf *gensym-counter* (+ 1 *gensym-counter*))))))
    (make-symbol (conc-string prefix (integer-string suffix)))))
(let ((gentemp-counter 0))
  (defun gentemp (&optional (prefix "T") (package *package*))
    (setf gentemp-counter (+ 1 gentemp-counter))
    (intern (conc-string prefix (integer-string gentemp-counter))
	    package)))

(defun symbol-function (symbol)
  (if (iboundp symbol 5)
      (iref symbol 5)
      (error 'undefined-function :name symbol)))
(defun (setf symbol-function) (new-contents symbol)
  (setf (iref symbol 5) new-contents))
(defun symbol-name (symbol) (iref symbol 2))
(defun symbol-package (symbol) (iref symbol 9))
(defun symbol-plist (symbol) (iref symbol 10))
(defun (setf symbol-plist) (new-plist symbol)
  (setf (iref symbol 10) new-plist))
(defun symbol-value (symbol)
  (if (iboundp symbol 4)
      (iref symbol 4)
      (error 'unbound-variable :name symbol)))
(defun (setf symbol-value) (new-value symbol) (setf (iref symbol 4) new-value))
(defun get (symbol indicator &optional default)
  (getf (symbol-plist symbol) indicator default))
(defun (setf get) (new-value symbol indicator &optional default)
  (setf (getf (symbol-plist symbol) indicator default) new-value))

(defun remprop (symbol indicator) (remf (symbol-plist symbol) indicator))
(defun boundp (symbol) (iboundp symbol 4))
(defun makunbound (symbol) (imakunbound symbol 4))
(defun set (symbol value) (setf (symbol-value symbol) value))
(defun designator-string (designator)
  (if (stringp designator)
      designator
      (if (characterp designator)
	  (string designator)
	  (symbol-name designator))))
(defvar *package* (car (cdr *packages*)))
(defun find-package (name)
  (if (packagep name)
      name
      (let ((string (designator-string name)))
	(dolist (package *packages*)
	  (dolist (package-name (iref package 2))
	    (when (string= package-name string)
	      (return-from find-package package)))))))
(defun export (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (setf symbol (designator-symbol symbol))
    (dolist (using-package (iref package 7))
      (when (find-symbol (symbol-name symbol) using-package)
	(cerror 'package-error :package using-package)))
    (unless (atom (package-get (iref package 3) (symbol-name symbol)))
      (unless (atom (package-get (iref package 4) (symbol-name symbol)))
	(cerror 'package-error :package package))
      (package-rem (iref package 4) symbol)
      (package-put (iref package 3) symbol))))
(defun package-rehash (old-vector new-vector)
  (let ((old-length (length old-vector))
	(new-length (length new-vector))
	(i 0))
    (tagbody
     start
       (when (< i old-length)
	 (dolist (symbol (iref old-vector (+ 2 i)))
	   (push symbol (iref new-vector (+ 2 (mod (hash (symbol-name symbol))
						   new-length)))))
	 (incf i)
	 (go start)))
    new-vector))
(defun package-get (vector string)
  (dolist (symbol (iref vector (+ 2 (mod (hash string) (length vector))))
	   '(nil))
    (when (string= (symbol-name symbol) string)
      (return symbol))))
(defun package-put (vector symbol)
  (push symbol (iref vector (+ 2 (mod (hash (symbol-name symbol))
				      (length vector))))))
(defun package-rem (vector string)
  (let ((index (+ 2 (mod (hash string) (length vector)))))
    (setf (iref vector index)
	  (delete string (iref vector index) :key #'symbol-name))))
(defun find-symbol (string &optional (package *package*))
  (setq package (find-package package))
  (unless package
    (error "Package does not exist."))
  (let ((symbol (package-get (iref package 4) string)))
    (if (atom symbol)
	(values symbol :internal)
	(let ((symbol (package-get (iref package 3) string)))
	  (if (atom symbol)
	      (values symbol :external)
	      (dolist (used-package (package-use-list package)
		       (values nil nil))
		(let ((symbol (package-get (iref used-package 3) string)))
		  (when (atom symbol)
		    (values symbol :inherited)))))))))
(defun find-all-symbols (string)
  (let ((symbols nil))
    (dolist (package *packages*)
      (let ((symbol (package-get (iref package 4) string)))
	(when (atom symbol)
	  (push symbol symbols)))
      (let ((symbol (package-get (iref package 3) string)))
	(when (atom symbol)
	  (push symbol symbols))))
    symbols))
(defun import (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (multiple-value-bind (symbol status)
	(find-symbol (symbol-name symbol) package)
      (case status
	(:inherited
	 (cerror 'package-error :package package))
	((nil)
	 (package-put (iref package 4) symbol)
	 (unless (iref symbol 9)
	   (setf (iref symbol 9) package))))))
  t)
(defun list-all-packages ()
  (copy-list *packages*))
(defun rename-package (package new-name &optional new-nicknames)
  (setq package (find-package package))
  (when (packagep new-name) (setq new-name (package-name new-name)))
  (setf new-nicknames (mapcar #'designator-string new-nicknames))
  (setf (iref package 2) (cons new-name new-nicknames))
  package)
(defun shadow (symbol-names &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol-name symbol-names)
    (multiple-value-bind (symbol status)
	(find-symbol symbol-name package)
      (unless (member status '(:internal :external))
	(setq symbol (make-symbol string))
	(setf (iref symbol 9) package)
	(package-put (iref package 4) symbol))
      (pushnew symbol (iref package 5))))
  t)
(defun shadowing-import (symbols &optional package)
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (package-rem (iref package 3) (symbol-name symbol))
    (package-rem (iref package 4) (symbol-name symbol))
    (package-put (iref package 4) symbol)
    (push symbol (iref package 5)))
  t)
(defun delete-package (package)
  (setq package (find-package package))
  (when (iref package 7)
    (cerror 'package-error package))
  (prog1
      (package-name package)
    (setf (iref package 2) nil)))
(defun make-package (package-name &key nicknames (use '("cl")))
  (let ((all-names (cons package-name nicknames)))
    (mapc #'(lambda (name)
	      (when (find-package name)
		(cerror 'package-error :package name)))
	  all-names)
    (let ((package (makei 6 5 all-names (make-array 1021) (make-array 1021) nil
			  (mapcar #'find-package use))))
      (mapc #'(lambda (used-package)
		(push package (iref (find-package used-package) 7)))
	    use)
      (push package *packages*)
      package)))
(defun make-package-iterator (package symbol-types)
  (setq package (find-package package))
  (list nil package symbol-types))
(defun package-iterate (iterator)
  (unless (first iterator)
    (setf (first iterator)
	  (case (pop (third iterator))
	    (:internal (iref (second iterator) 4))
	    (:external (iref (second iterator) 3))
	    (:inherited "FIXME")
	    ((nil) (return-from package-iterate nil)))))
  (pop (first iterator)))
(defmacro with-package-iterator ((name package-list-form &rest symbol-types)
				 &rest forms)
  (let ((package (gensym))
	(iterator (gensym)))
    `(dolist (,package (designator-list ,package-list-form))
      (let ((,iterator (make-package-iterator ,package ',symbol-types)))
	(macrolet ((,name () (package-iterate ,iterator)))
	  ,@forms)))))
(defun unexport (symbols &optional (package *package*))
  (setq package (find-package package))
  (dolist (symbol (designator-list symbols))
    (setq symbol (designator-symbol symbol))
    (when symbol
      (when (atom (package-get (iref package 3) (symbol-name symbol)))
	(package-rem (iref package 3) (symbol-name symbol))
	(package-put (iref package 4) symbol))))
  t)
(defun unintern (symbol &optional (package *package*))
  (setq package (find-package package))
  (when (eq package (iref symbol 9))
    (setf (iref symbol 9) nil))
  (let* ((name (symbol-name symbol))
	 (present (or (atom (package-get (iref package 3) name))
		      (atom (package-get (iref package 4) name)))))
    (package-rem (iref package 3) name)
    (package-rem (iref package 4) name)
    (setf (iref package 5) (delete symbol (iref package 5)))
    present))
(defmacro in-package (name)
  `(setf *package* (find-package ',name)))
(defun unuse-package (packages-to-unuse &optional (package *package*))
  (setq package (find-package package))
  (dolist (package-to-unuse (designator-list packages-to-unuse))
    (setq package-to-unuse (find-package package-to-unuse))
    (setf (iref package 6) (delete package-to-unuse (iref package 6)))
    (setf (iref package-to-unuse 7)
	  (delete package (iref package-to-unuse 7))))
  t)
(defun use-package (packages-to-use &optional (package *package*))
  (setq package (find-package package))
  (dolist (package-to-use (designator-list packages-to-use))
    (setq package-to-use (find-package package-to-use))
    (push package-to-use (iref package 6))
    (push package (iref package-to-use 7)))
  t)
(defun ensure-package (name nicknames shadow shadowing-import-from use
		       import-from intern export)
  (let ((package (find-package name)))
    (unless package
      (setq package (make-package name :nicknames nicknames)))
    (shadow shadow package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(shadowing-import (mapcar #'(lambda (symbol-name)
					      (find-symbol symbol-name
							   imported-package))
					  symbol-names)
				  package)))
	  shadowing-import-from)
    (use-package use package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(import (mapcar #'(lambda (symbol-name)
				    (find-symbol symbol-name imported-package))
				symbol-names)
			package)))
	  import-from)
    (mapc #'(lambda (symbol-name) (intern symbol-name package)) intern)
    (export export package)
    package))
(defmacro defpackage (defined-package-name &rest options)
  (flet ((option (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (mapcar #'designator-string (cdr option))))
		   options))
	 (options (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (list (mapcar #'designator-string (cdr option)))))
		   options)))
    `(ensure-package ,(designator-string defined-package-name)
      ,(option :nicknames)
      ,(option :shadow) ,(options :shadowing-import-from) ,(option :use)
      ,(options :import-from) ,(option :intern) ,(option :export))))
(defmacro do-symbols ((var &optional (package *package*) result-form)
		      &rest forms)
  (let ((package-sym (gensym)))
    `(block nil
      (let ((,package-sym (find-package package))
	    (,var nil))
	(dolist (,var (iref ,package-sym 3))
	  ,@forms)
	(dolist (,var (iref ,pakcage-sym 4))
	  ,@forms)
	,result-form))))
(defmacro do-external-symbols ((var &optional (package *package*) result-form)
			       &rest forms)
  (let ((package-sym (gensym)))
    `(let ((,package-sym (find-package ,package)))
      (dolist (,var (iref ,package-sym 3) ,result-form)
	,@forms))))
(defmacro do-all-symbols ((var &optional result-form) &rest forms)
  (let ((package (gensym))
	(symbols (gensym))
	(first (gensym))
	(start-out (gensym))
	(start (gensym)))
    `(let ((,symbols nil)
	   (,first t))
      (dolist (,package *packages* ,result-form)
	,start-out
	(setq ,symbols (iref ,package (if ,first 3 4)))
	(setq ,first (not ,first))
	,start
	(when ,symbols
	  ,@forms
	  (go ,start))
	(when ,first
	  (go ,start-out))))))
(defun intern (string &optional (package *package*))
  (setq package (find-package package))
  (multiple-value-bind (symbol status)
      (find-symbol string package)
    (unless status
      (setq symbol (make-symbol string))
      (setf (iref symbol 9) package)
      (cond
	((string= (package-name package) "KEYWORD")
	 (package-put (iref package 3) symbol)
	 (setf (symbol-value symbol) symbol))
	(t
	 (package-put (iref package 4) symbol))))
    (values symbol status)))
(defun package-name (package) (car (iref (find-package package) 2)))
(defun package-nicknames (package) (cdr (iref (find-package package) 2)))
(defun package-shadowing-symbols (package) (iref (find-package package) 5))
(defun package-use-list (package) (iref (find-package package) 6))
(defun package-used-by-list (package) (iref (find-package package) 7))
(defun packagep (object) (eq (type-of object) 'package))
(defun /= (number &rest numbers)
  (tagbody
   start
     (when numbers
       (dolist (n numbers)
	 (when (= number n)
	   (return-from /=)))
       (setq number (pop numbers))
       (go start)))
  t)
(defun > (&rest numbers)
  (apply #'< (reverse numbers)))
(defun <= (number &rest numbers)
  (dolist (n numbers t)
    (when (< n number)
      (return-from <=))
    (setq number n)))
(defun >= (number &rest numbers)
  (dolist (n numbers t)
    (when (< number n)
      (return-from >=))
    (setq number n)))
(defun max (real &rest reals)
  (dolist (r reals real)
    (when (< real r)
      (setq real r))))
(defun min (real &rest reals)
  (dolist (r reals real)
    (when (< r real)
      (setq real r))))
(defun oddp (integer)
  (= (mod integer 2) 1))
(defun evenp (integer)
  (= (mod integer 2) 0))
(defun minusp (real)
  (< real 0))
(defun plusp (real)
  (< 0 real))
(defun zerop (real)
  (= real 0))
(defun abs (number)
  (if (< number 0)
      (- number)
      number))
(defmacro incf (place &optional (delta-form 1))
  `(setf ,place (+ ,place ,delta-form)))
(defmacro decf (place &optional (delta-form 1))
  `(setf ,place (- ,place ,delta-form)))
(defun byte (size position)
  (cons size position))
(defun byte-size (bytespec)
  (car bytespec))
(defun byte-position (bytespec)
  (cdr bytespec))
(defun char= (&rest characters)
  (apply #'= (mapcar #'char-code characters)))
(defun char/= (&rest characters)
  (apply #'/= (mapcar #'char-code characters)))
(defun char< (&rest characters)
  (apply #'< (mapcar #'char-code characters)))
(defun char> (&rest characters)
  (apply #'> (mapcar #'char-code characters)))
(defun char<= (&rest characters)
  (apply #'<= (mapcar #'char-code characters)))
(defun char>= (&rest characters)
  (apply #'>= (mapcar #'char-code characters)))
(defun char-equal (&rest characters)
  (apply #'char= (mapcar #'char-upcase characters)))
(defun char-not-equal (&rest characters)
  (apply #'char/= (mapcar #'char-upcase characters)))
(defun char-lessp (&rest characters)
  (apply #'char< (mapcar #'char-upcase characters)))
(defun char-greaterp (&rest characters)
  (apply #'char> (mapcar #'char-upcase characters)))
(defun char-not-greaterp (&rest characters)
  (apply #'char<= (mapcar #'char-upcase characters)))
(defun char-not-lessp (&rest characters)
  (apply #'char>= (mapcar #'char-upcase characters)))
(defun character (character)
  (if (characterp character)
      character
      (let ((string (designator-string character)))
	(if (= (length string) 1)
	    (aref string 0)
	    (error 'type-error :datum string :expected-type '(string 1))))))
(defun characterp (object) (= (ldb '(5 . 0) (ival object)) 24))
(defun alpha-char-p (character)
  (let ((code (char-code character)))
    (or (< 64 code 91)
	(< 96 code 123)
	(< 159 code))))
(defun alphanumericp (character)
  (let ((code (char-code character)))
    (or (< 47 code 58)
	(< 64 code 91)
	(< 96 code 123)
	(< 159 code))))
(defun digit-char (weight &optional (radix 10))
  (when (< weight radix)
    (if (< weight 10)
	(code-char (+ 48 weight))
	(code-char (+ 55 weight)))))
(defun digit-char-p (char &optional (radix 10))
  (let* ((code (char-code char))
	 (weight (if (< 47 code 58)
		     (- code 48)
		     (if (< 64 code 91)
			 (- code 55)
			 (when (< 96 code 123)
			   (- code 87))))))
    (and weight (< weight radix) weight)))
(defun standard-char-p (character)
  (let ((code (char-code character)))
    (or (= code 10)
	(< 31 code 127))))
(defun char-upcase (character)
  (let ((code (char-code character)))
    (if (< 96 code 123)
	(code-char (- code 32))
	character)))
(defun char-downcase (character)
  (let ((code (char-code character)))
    (if (< 64 code 91)
	(code-char (+ code 32))
	character)))
(defun upper-case-p (character)
  (< 64 (char-code character) 91))
(defun lower-case-p (character)
  (< 96 (char-code character) 123))
(defun both-case-p (character)
  (or (upper-case-p character) (lower-case-p character)))
(defun char-int (character)
  (char-code character))
(defconstant char-code-limit 256)
(let ((char-names '((0 . "Null")
		    (8 . "Backspace")
		    (9 . "Tab")
		    (10 . "Newline")
		    (12 . "Page")
		    (13 . "Return")
		    (32 . "Space")
		    (127 . "Rubout"))))
  (defun char-name (character)
    (let* ((code (char-code character))
	   (name (cdr (assoc code char-names))))
      (or name (when (< code 32)
		 (conc-string "U+" (integer-string code))))))
  (defun name-char (name)
    (setq name (designator-string name))
    (if (< (length name) 2)
	(aref name 0)
	(if (= (char-code (aref name 0)) 85)
	    (code-char (parse-integer name :start 2))
	    (let ((code (car (rassoc name char-names :test #'string-equal))))
	      (when code (code-char code)))))))
(defun atom (object) (not (consp object)))
(defun rplaca (cons object) (setf (car cons) object) cons)
(defun rplacd (cons object) (setf (cdr cons) object) cons)

(defun caar (x) (car (car x)))
(defun (setf caar) (new-object x) (setf (car (car x)) new-object))

(defun cadr (x) (car (cdr x)))
(defun (setf cadr) (new-object x) (setf (car (cdr x)) new-object))
(defun cdar (x) (cdr (car x)))
(defun (setf cdar) (new-object x) (setf (cdr (car x)) new-object))
(defun cddr (x) (cdr (cdr x)))
(defun (setf cddr) (new-object x) (setf (cdr (cdr x)) new-object))
(defun caaar (x) (car (car (car x))))
(defun (setf caaar) (new-object x) (setf (car (caar x)) new-object))
(defun caadr (x) (car (car (cdr x))))
(defun (setf caadr) (new-object x) (setf (car (cadr x)) new-object))
(defun cadar (x) (car (cdr (car x))))
(defun (setf cadar) (new-object x) (setf (car (cdar x)) new-object))
(defun caddr (x) (car (cdr (cdr x))))
(defun (setf caddr) (new-object x) (setf (car (cddr x)) new-object))
(defun cdaar (x) (cdr (car (car x))))
(defun (setf cdaar) (new-object x) (setf (cdr (caar x)) new-object))
(defun cdadr (x) (cdr (car (cdr x))))
(defun (setf cdadr) (new-object x) (setf (cdr (cadr x)) new-object))
(defun cddar (x) (cdr (cdr (car x))))
(defun (setf cddar) (new-object x) (setf (cdr (cdar x)) new-object))
(defun cdddr (x) (cdr (cdr (cdr x))))
(defun (setf cdddr) (new-object x) (setf (cdr (cddr x)) new-object))
(defun caaaar (x) (car (car (car (car x)))))
(defun (setf caaaar) (new-object x) (setf (car (caaar x)) new-object))
(defun caaadr (x) (car (car (car (cdr x)))))

(defun (setf caaadr) (new-object x) (setf (car (caadr x)) new-object))
(defun caadar (x) (car (car (cdr (car x)))))

(defun (setf caadar) (new-object x) (setf (car (cadar x)) new-object))
(defun caaddr (x) (car (car (cdr (cdr x)))))
(defun (setf caaddr) (new-object x) (setf (car (caddr x)) new-object))
(defun cadaar (x) (car (cdr (car (car x)))))
(defun (setf cadaar) (new-object x) (setf (car (cdaar x)) new-object))
(defun cadadr (x) (car (cdr (car (cdr x)))))
(defun (setf cadadr) (new-object x) (setf (car (cdadr x)) new-object))
(defun caddar (x) (car (cdr (cdr (car x)))))
(defun (setf caddar) (new-object x) (setf (car (cddar x)) new-object))
(defun cadddr (x) (car (cdr (cdr (cdr x)))))
(defun (setf cadddr) (new-object x) (setf (car (cdddr x)) new-object))
(defun cdaaar (x) (cdr (car (car (car x)))))
(defun (setf cdaaar) (new-object x) (setf (cdr (caaar x)) new-object))
(defun cdaadr (x) (cdr (car (car (cdr x)))))
(defun (setf cdaadr) (new-object x) (setf (cdr (caadr x)) new-object))
(defun cdadar (x) (cdr (car (cdr (car x)))))
(defun (setf cdadar) (new-object x) (setf (cdr (cadar x)) new-object))
(defun cdaddr (x) (cdr (car (cdr (cdr x)))))
(defun (setf cdaddr) (new-object x) (setf (cdr (caddr x)) new-object))
(defun cddaar (x) (cdr (cdr (car (car x)))))
(defun (setf cddaar) (new-object x) (setf (cdr (cdaar x)) new-object))
(defun cddadr (x) (cdr (cdr (car (cdr x)))))
(defun (setf cddadr) (new-object x) (setf (cdr (cdadr x)) new-object))
(defun cdddar (x) (cdr (cdr (cdr (car x)))))
(defun (setf cdddar) (new-object x) (setf (cdr (cddar x)) new-object))
(defun cddddr (x) (cdr (cdr (cdr (cdr x)))))
(defun (setf cddddr) (new-object x) (setf (cdr (cdddr x)) new-object))
(defun copy-tree (tree)
  (if (consp tree) (cons (copy-tree (car tree)) (copy-tree (cdr tree))) tree))
(defun sublis (alist tree &rest rest)
  (if (consp tree)
      (let ((a (apply #'sublis alist (car tree) rest))
	    (d (apply #'sublis alist (cdr tree) rest)))
	(if (and (eq a (car tree)) (eq d (cdr tree)))
	    tree
	    (cons a d)))
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))
(defun nsublis (alist tree &rest rest)
  (if (consp tree)
      (progn
	(setf (car tree) (apply #'nsublis alist (car tree) rest))
	(setf (cdr tree) (apply #'nsublis alist (cdr tree) rest))
	tree)
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))
(defun copy-list (list)
  (if (consp list) (cons (car list) (copy-list (cdr list))) list))
(defun make-list (size &key initial-element)
  (if (= size 0) nil
      (cons initial-element
	    (make-list (- size 1) :initial-element initial-element))))
(defun list* (&rest objects)
  (if (cdr objects)
      (cons (car objects) (apply #'list* (cdr objects)))
      (car objects)))
(defun list-length (list)
  (let ((slow list)
	(fast list)
	(odd nil)
	(len 0))
    (tagbody
     start
       (when (atom fast) (return-from list-length len))
       (setf fast (cdr fast))
       (setf len (+ 1 len))
       (when odd (setf slow (cdr slow)))
       (setf odd (not odd))
       (unless (eq slow fast) (go start)))))
(defun listp (object) (or (consp object) (eq object nil)))
(defmacro push (item place)
  `(setf ,place (cons ,item ,place)))
(defmacro pop (place)
  `(prog1 (car ,place) (setf ,place (cdr ,place))))
(defun first (list) (car list))
(defun (setf first) (new-object list) (setf (car list) new-object))
(defun second (list) (nth 1 list))
(defun (setf second) (new-object list) (setf (nth 1 list) new-object))
(defun third (list) (nth 2 list))
(defun (setf third) (new-object list) (setf (nth 2 list) new-object))
(defun fourth (list) (nth 3 list))
(defun (setf fourth) (new-object list) (setf (nth 3 list) new-object))
(defun fifth (list) (nth 4 list))
(defun (setf fifth) (new-object list) (setf (nth 4 list) new-object))
(defun sixth (list) (nth 5 list))
(defun (setf sixth) (new-object list) (setf (nth 5 list) new-object))
(defun seventh (list) (nth 6 list))
(defun (setf seventh) (new-object list) (setf (nth 6 list) new-object))
(defun eighth (list) (nth 7 list))
(defun (setf eighth) (new-object list) (setf (nth 7 list) new-object))
(defun ninth (list) (nth 8 list))
(defun (setf ninth) (new-object list) (setf (nth 8 list) new-object))
(defun tenth (list) (nth 9 list))
(defun (setf tenth) (new-object list) (setf (nth 9 list) new-object))
(defun nth (n list) (if (< n 1) (car list) (nth (- n 1) (cdr list))))
(defun (setf nth) (new-object n list)
  (if (< n 1)
      (setf (car list) new-object)
      (setf (nth (- n 1) (cdr list)) new-object)))
(defun endp (list) (not list))
(defun nconc (&rest lists)
  (if (cdr lists)
      (if (car lists)
	  (progn (setf (cdr (last (car lists))) (apply #'nconc (cdr lists)))
		 (car lists))
	  (apply #'nconc (cdr lists)))
      (car lists)))
(defun revappend (list tail)
  (if list
      (revappend (cdr list) (cons (car list) tail))
      tail))
(defun nreconc (list tail)
  (if list
      (let ((new-list (cdr list)))
	(setf (cdr list) tail)
	(nreconc new-list list))
      tail))
(defun butlast (list &optional (n 1))
  (let* ((r (cons nil nil))
	 (e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e r)
    (tagbody
     start
       (unless (consp list) (return-from butlast nil))
       (unless (< n 1)
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (setf n (- n 1))
	 (go start)))
    (cdr r)))
(defun nbutlast (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (unless (consp list) (return-from nbutlast nil))
       (unless (< n 2)
	 (setf e (cdr e))
	 (setf n (- n 1))
	 (go start)))
    (setf (cdr e) nil)
    list))
(defun last (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (when (< n 1) (return-from last e))
       (setf e (cdr e))
       (setf n (- n 1))
       (go start))))
(defun ldiff (list object)
  (let* ((r (cons nil nil))
	 (e r))
    (tagbody
     start
       (unless (or (eq object list) (atom list))
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (go start)))
    (cdr r)))
(defun tailp (object list)
  (tagbody
   start
     (when (eq object list) (return-from tailp t))
     (unless (consp list) (return-from tailp nil))
     (setf list (cdr list))
     (go start)))
(defun nthcdr (n list) (if (< n 1) list (nthcdr (- n 1) (cdr list))))
(defun rest (list) (cdr list))
(defun (setf rest) (new-tail list) (setf (cdr list) new-tail))

(labels ((all-end (lists)
	   (dolist (elem lists nil)
	     (unless elem (return-from all-end t))))
	 (all-car (lists)
	   (when lists (cons (caar lists) (all-car (cdr lists)))))
	 (all-cdr (lists)
	   (when lists (cons (cdar lists) (all-cdr (cdr lists))))))
  (defun mapc (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapc list-1))
	 (apply function (all-car lists))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapcar (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from mapcar result))
	 (let ((cons (cons (apply function (all-car lists)) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapl (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapl list-1))
	 (apply function lists)
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun maplist (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from maplist result))
	 (let ((cons (cons (apply function lists) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start)))))
(defun mapcan (function &rest lists)
  (apply #'nconc (apply #'mapcar function lists)))
(defun mapcon (function &rest lists)
  (apply #'nconc (apply #'maplist function lists)))
(defun acons (key datum alist) (cons (cons key datum) alist))
(defun copy-alist (alist)
  (when alist (cons (if (consp (car alist))
			(cons (caar alist) (cdar alist))
			(car alist))
		    (copy-alist (cdr alist)))))
(defun pairlis (keys data &optional alist)
  (tagbody
   start
     (when (and keys data)
       (setf alist (acons (car keys) (car data) alist))
       (setf keys (cdr keys))
       (setf data (cdr data))
       (go start)))
  alist)


(defun some-list-2 (predicate list1 list2)
  (tagbody
   start
     (when (and list1 list2)
       (when (funcall predicate (car list1) (car list2))
	 (return-from some-list-2 t))
       (pop list1)
       (pop list2)
       (go start))))

