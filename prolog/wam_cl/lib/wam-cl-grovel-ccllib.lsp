

\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/setf.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;Bootstrapping.
(defvar %setf-methods% (let ((a (make-hash-table :test #'eq)))
                         (do-all-symbols (s)
                           (let ((f (get s 'bootstrapping-setf-method)))
                             (when f
                               (setf (gethash s a) f)
                               (remprop s 'bootstrapping-setf-method))))
                         a))
(defun %setf-method (name)
  (gethash name %setf-methods%))

(defun store-setf-method (name fn &optional doc)
  (puthash name %setf-methods% fn)
  (when (structref-info name)
    (structref-set-r/o name))
  (set-documentation name 'setf doc) ;clears it if doc = nil.
  name)


;;; Note: The expansions for SETF and friends create needless LET-bindings of 
;;; argument values when using get-setf-method.
;;; That's why SETF no longer uses get-setf-method.  If you change anything
;;; here, be sure to make the corresponding change in SETF.

(defun get-setf-expansion (form &optional env)
  "Return five values needed by the SETF machinery: a list of temporary
   variables, a list of values with which to fill them, a list of temporaries
   for the new values, the setting function, and the accessing function."
  ;This isn't actually used by setf, but it has to be compatible.
  (get-setf-expansion-aux form env t))

(defun get-setf-expansion-aux (form environment multiple-store-vars-p)
  (let* ((temp nil) 
         (accessor nil))
    (if (atom form)
      (progn
        (unless (symbolp form) (signal-program-error $XNotSym form))
        (multiple-value-bind (symbol-macro-expansion expanded)
            (macroexpand-1 form environment)
          (if expanded
            (get-setf-expansion-aux symbol-macro-expansion environment
                                    multiple-store-vars-p)
            (let ((new-var (gensym)))
              (values nil nil (list new-var) `(setq ,form ,new-var) form)))))
      (multiple-value-bind (ftype local-p)
                           (function-information (setq accessor (car form)) environment)
        (if local-p
          (if (eq ftype :function)
            ;Local function or macro, so don't use global setf definitions.
            (default-setf-method form)
            (get-setf-expansion-aux (macroexpand-1 form environment) environment multiple-store-vars-p))
          (cond
           ((setq temp (gethash accessor %setf-methods%))
            (if (symbolp temp)
              (let ((new-var (gensym))
                    (args nil)
                    (vars nil)
                    (vals nil))
                (dolist (x (cdr form))
                  ;; Rebinding defeats optimizations, so avoid it if can.
                  (if (constantp x environment)
                    (push x args)
                    (let ((var (gensym)))
                      (push var vars)
                      (push var args)
                      (push x vals))))
                (setq args (nreverse args))
                (values (nreverse vars) 
                        (nreverse vals) 
                        (list new-var)
                        `(,temp ,@args ,new-var)
                        `(,accessor ,@args)))
              (multiple-value-bind (temps values storevars storeform accessform)
                                   (funcall temp form environment)
                (when (and (not multiple-store-vars-p) (not (= (length storevars) 1)))
                  (signal-program-error "Multiple store variables not expected in setf expansion of ~S" form))
                (values temps values storevars storeform accessform))))
           ((and (setq temp (structref-info accessor environment))
                 (accessor-structref-info-p temp)
                 (not (refinfo-r/o (structref-info-refinfo temp))))
            (let ((form (defstruct-ref-transform temp (%cdr form) environment t))
                  (type (defstruct-type-for-typecheck (structref-info-type temp) environment)))
              (if (eq type 't)
                (get-setf-method form environment)
                (multiple-value-bind (temps values storevars storeform accessform)
                                     (get-setf-method form environment)
                  (values temps values storevars
                          (let ((storevar (first storevars)))
                            `(the ,type
                                  (let ((,storevar (typecheck ,storevar ,type)))
                                    ,storeform)))
                          `(the ,type ,accessform))))))
	   (t
	    (multiple-value-bind (res win)
				 (macroexpand-1 form environment)
	      (if win
                (get-setf-expansion-aux res environment multiple-store-vars-p)
                (default-setf-method form))))))))))

(defun default-setf-method (form)
  (let ((new-value (gensym))
        (temp-vars ())
        (temp-args ())
        (temp-vals ()))
    (dolist (val (cdr form))
      (if (fixnump val)
        (push val temp-args)
        (let ((var (gensym)))
          (push var temp-vars)
          (push val temp-vals)
          (push var temp-args))))
    (setq temp-vars (nreverse temp-vars)
          temp-args (nreverse temp-args)
          temp-vals (nreverse temp-vals))
    (values temp-vars
	    temp-vals
	    (list new-value)
	    `(funcall #'(setf ,(car form)) ,new-value ,@temp-args)
	    `(,(car form) ,@temp-args))))

;;; The inverse for a generalized-variable reference function is stored in
;;; one of two ways:
;;;
;;; A SETF-INVERSE property corresponds to the short form of DEFSETF.  It is
;;; the name of a function takes the same args as the reference form, plus a
;;; new-value arg at the end.
;;;
;;; A SETF-METHOD-EXPANDER property is created by the long form of DEFSETF or
;;; by DEFINE-SETF-METHOD.  It is a function that is called on the reference
;;; form and that produces five values: a list of temporary variables, a list
;;; of value forms, a list of the single store-value form, a storing function,
;;; and an accessing function.

(eval-when (eval compile)
  (require 'defstruct-macros))
  
(defmacro set-get (symbol indicator value &optional (value1 () default-p))
  (if default-p
    `(put ,symbol ,indicator (progn ,value ,value1))
    `(put ,symbol ,indicator ,value)))

; (defsetf get set-get)
(store-setf-method 'get 'SET-GET)

; does this wrap a named block around the body yet ?
(defmacro define-setf-expander (access-fn lambda-list &body body)
  "Syntax like DEFMACRO, but creates a setf expander function. The body
  of the definition must be a form that returns five appropriate values."
  (unless (symbolp access-fn)
    (signal-program-error $xnotsym access-fn))
  (multiple-value-bind (lambda-form doc)
                       (parse-macro-1 access-fn lambda-list body)
    `(eval-when (load compile eval)
       (record-source-file ',access-fn 'setf-expander)
       (store-setf-method ',access-fn
                          (nfunction ,access-fn ,lambda-form)
                          ,@(when doc (list doc))))))

(defun rename-lambda-vars (lambda-list)
  (let* ((vars nil)
         (temps nil)
         (new-lambda nil)
         (state nil))
    (flet ((temp-symbol (s) (make-symbol (symbol-name s))))
      (declare (inline temp-symbol))
      (dolist (item lambda-list)
        (if (memq item lambda-list-keywords)
          (setq state item item (list 'quote item))
          (if (atom item)
            (progn
              (push item vars))
            (locally (declare (type cons item))
              (when (consp (cddr item))
                (push (caddr item) vars))
              (if (and (eq state '&key) (consp (car item)))
                (progn
                  (push (cadar item) vars)
                  (setq item `(list (list ,(list 'quote (caar item)) ,(cadar item)) ,@(cdr item))))
                (progn 
                  (push (car item) vars)
                  (setq item `(list ,(car item) ,@(cdr item))))))))
        (push item new-lambda))
      (setq temps (mapcar #'temp-symbol vars))
      (values `(list ,@(nreverse new-lambda)) (nreverse temps) (nreverse vars)))))

(defmacro defsetf (access-fn &rest rest &environment env)
  "Associates a SETF update function or macro with the specified access
  function or macro. The format is complex. See the manual for details."
  (unless (symbolp access-fn) (signal-program-error $xnotsym access-fn))
  (if (non-nil-symbol-p (%car rest))
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       (store-setf-method
        ',access-fn
        ',(%car rest)
        ,@(%cdr rest)))
    (destructuring-bind (lambda-list (store-var &rest mv-store-vars) &body body)
        rest
      (unless (verify-lambda-list lambda-list)
        (signal-program-error $XBadLambdaList lambda-list))
      (let* ((store-vars (cons store-var mv-store-vars)))
        (multiple-value-bind (lambda-list lambda-temps lambda-vars)
                             (rename-lambda-vars lambda-list)
          (multiple-value-bind (body decls doc)
                               (parse-body body env t)
            (setq body `((block ,access-fn ,@body)))
            (let* ((ignorable `((declare (ignorable ,@lambda-temps))))
                   (args (gensym))
                   (dummies (gensym))
                   (newval-vars (gensym))
                   (new-access-form (gensym))
                   (access-form (gensym))
                   (environment (gensym)))
              `(eval-when (:compile-toplevel :load-toplevel :execute)
                 (record-source-file ',access-fn 'setf-expander)
                 (store-setf-method 
                  ',access-fn
                  #'(lambda (,access-form ,environment)
                      (declare (ignore ,environment))
                      (do* ((,args (cdr ,access-form) (cdr ,args))
                            (,dummies nil (cons (gensym) ,dummies))
                            (,newval-vars (mapcar #'(lambda (v) (declare (ignore v)) (gensym)) ',store-vars))
                            (,new-access-form nil))
                           ((atom ,args)
                            (setq ,new-access-form 
                                  (cons (car ,access-form) ,dummies))
                            (destructuring-bind ,(append lambda-vars store-vars )
                                                `,(append ',lambda-temps ,newval-vars)
                              ,@decls
                              (values
                               ,dummies
                               (cdr ,access-form)
                               ,newval-vars
                               `((lambda ,,lambda-list
                                   ,',@ignorable
                                   ,,@body)
                                 ,@,dummies)
                               ,new-access-form))))))
                 ,@(if doc (list doc))
                 ',access-fn))))))))
  
(defmacro define-modify-macro (name lambda-list function &optional doc-string)
  "Creates a new read-modify-write macro like PUSH or INCF."
  (let ((other-args nil)
        (rest-arg nil)
        (env (gensym))
        (reference (gensym)))
    
    ;; Parse out the variable names and rest arg from the lambda list.
    (do ((ll lambda-list (cdr ll))
         (arg nil))
        ((null ll))
      (setq arg (car ll))
      (cond ((eq arg '&optional))
            ((eq arg '&rest)
             (if (symbolp (cadr ll))
               (setq rest-arg (cadr ll))
               (error "Non-symbol &rest arg in definition of ~S." name))
             (if (null (cddr ll))
               (return nil)
               (error "Illegal stuff after &rest arg in Define-Modify-Macro.")))
            ((memq arg '(&key &allow-other-keys &aux))
             (error "~S not allowed in Define-Modify-Macro lambda list." arg))
            ((symbolp arg)
             (push arg other-args))
            ((and (listp arg) (symbolp (car arg)))
             (push (car arg) other-args))
            (t (error "Illegal stuff in lambda list of Define-Modify-Macro."))))
    (setq other-args (nreverse other-args))
      `(defmacro ,name (,reference ,@lambda-list &environment ,env)
         ,doc-string
         (multiple-value-bind (dummies vals newval setter getter)
                                (get-setf-method ,reference ,env)
             (do ((d dummies (cdr d))
                  (v vals (cdr v))
                  (let-list nil (cons (list (car d) (car v)) let-list)))
                 ((null d)
                  (push 
                   (list (car newval)
                         ,(if rest-arg
                            `(list* ',function getter ,@other-args ,rest-arg)
                            `(list ',function getter ,@other-args)))
                   let-list)
                  `(let* ,(nreverse let-list)
                     ,setter)))))))

(defmacro incf (place &optional (delta 1) &environment env)
  "The first argument is some location holding a number.  This number is
incremented by the second argument, DELTA, which defaults to 1."
  (if (and (symbolp (setq place (%symbol-macroexpand place env)))
           (or (constantp delta)
               (and (symbolp delta)
                    (not (nth-value 1 (%symbol-macroexpand delta env))))))
    `(setq ,place (+ ,place ,delta))
    (multiple-value-bind (dummies vals newval setter getter)
        (get-setf-method place env)
      (let ((d (gensym)))
        `(let* (,@(mapcar #'list dummies vals)
                (,d ,delta)
                (,(car newval) (+ ,getter ,d)))
           ,setter)))))

(defmacro decf (place &optional (delta 1) &environment env)
  "The first argument is some location holding a number.  This number is
decremented by the second argument, DELTA, which defaults to 1."
  (if (and (symbolp (setq place (%symbol-macroexpand place env)))
           (or (constantp delta)
               (and (symbolp delta)
                    (not (nth-value 1 (%symbol-macroexpand delta env))))))
    `(setq ,place (- ,place ,delta))
    (multiple-value-bind (dummies vals newval setter getter)
        (get-setf-method place env)
      (let* ((d (gensym))
             ;; Doesn't propagate inferred types, but better than nothing.
             (d-type (cond ((constantp delta) (type-of delta))
                           ((and (consp delta) (eq (car delta) 'the)) (cadr delta))
                           (t t)))
             (v-type (if (and (consp place) (eq (car place) 'the)) (cadr place) t)))
        `(let* (,@(mapcar #'list dummies vals)
                (,d ,delta)
                (,(car newval) (- ,getter ,d)))
           (declare (type ,d-type ,d) (type ,v-type ,(car newval)))
           ,setter)))))
  
(defmacro psetf (&whole call &rest pairs &environment env)  ;same structure as psetq
  "This is to SETF as PSETQ is to SETQ. Args are alternating place
  expressions and values to go into those places. All of the subforms and
  values are determined, left to right, and only then are the locations
  updated. Returns NIL."
  (when pairs
    (if (evenp (length pairs))
      (let* ((places nil)
             (values nil)
             (tempsets nil)
             (the-progn (list 'progn))
             (place nil)
             (body the-progn)
             (valform nil))
        (loop
          (setq place (pop pairs) valform (pop pairs))
          (if (null pairs) (return))
          (push place places)
          (push valform values)
          (multiple-value-bind (temps vals newvals setter getter)
                               (get-setf-method-multiple-value place env)
            (push (list temps vals newvals setter getter) tempsets)))
        (dolist (temp tempsets)
          (destructuring-bind (temps vals newvals setter getter) temp
            (declare (ignore getter))
            (setq body
                  `(let
                     ,(let* ((let-list nil))
                        (dolist (x temps (nreverse let-list))
                          (push (list x (pop vals)) let-list)))
                     (multiple-value-bind ,newvals ,(pop values)
                       ,body)))
            (push setter (cdr the-progn))))
        (push `(setf ,place ,valform) (cdr the-progn))
        `(progn ,body nil))
      (error "Odd number of args in the call ~S" call))))

;;Simple Setf specializations



(defsetf cadr set-cadr)
(defsetf second set-cadr)


(defsetf cdar set-cdar)

(defsetf caar set-caar)

(defsetf cddr set-cddr)

(defsetf elt set-elt)
(defsetf aref aset)
(defsetf svref svset)
(defsetf char set-char)
(defsetf bit %bitset)

(defsetf schar set-schar)
(defsetf sbit %sbitset)
(defsetf symbol-value set)
(defsetf %schar %set-schar)


(defsetf symbol-plist set-symbol-plist)
(defsetf nth %setnth)

(defsetf nthcdr %set-nthcdr)

(defsetf fill-pointer set-fill-pointer)


(defsetf subseq (sequence start &optional (end nil)) (new-seq)
  `(progn (replace ,sequence ,new-seq :start1 ,start :end1 ,end)
	  ,new-seq))



(defsetf third set-caddr)
(defsetf fourth set-cadddr)
(defsetf fifth set-fifth)
(defsetf sixth set-sixth)
(defsetf seventh set-seventh)
(defsetf eighth set-eighth)
(defsetf ninth set-ninth)
(defsetf tenth set-tenth)


(defsetf caaar set-caaar)
(defsetf caadr set-caadr)
(defsetf cadar set-cadar)
(defsetf caddr set-caddr)
(defsetf cdaar set-cdaar)
(defsetf cdadr set-cdadr)
(defsetf cddar set-cddar)
(defsetf cdddr set-cdddr)




(defsetf caaaar set-caaaar)
(defsetf caaadr set-caaadr)
(defsetf caadar set-caadar)
(defsetf caaddr set-caaddr)
(defsetf cadaar set-cadaar)
(defsetf cadadr set-cadadr)
(defsetf caddar set-caddar)
(defsetf cadddr set-cadddr)


(defsetf cdaaar set-cdaaar)
(defsetf cdaadr set-cdaadr)
(defsetf cdadar set-cdadar)
(defsetf cdaddr set-cdaddr)
(defsetf cddaar set-cddaar)
(defsetf cddadr set-cddadr)
(defsetf cdddar set-cdddar)
(defsetf cddddr set-cddddr)

(defsetf %fixnum-ref %fixnum-set)
(defsetf %fixnum-ref-double-float %fixnum-set-double-float)

(define-setf-method the (typespec expr &environment env)
  (multiple-value-bind (dummies vals newval setter getter)
                       (get-setf-method expr env)
    (let ((store-var (gensym)))
      (values
       dummies
       vals
       (list store-var)
       `(let ((,(car newval) ,store-var))
                         ,setter)
       `(the ,typespec ,getter)))))

   
(define-setf-method apply (function &rest args &environment env)
  (if (and (listp function)
	   (= (list-length function) 2)
	   (eq (first function) 'function)
	   (symbolp (second function)))
      (setq function (second function))
      (error
       "Setf of Apply is only defined for function args of form #'symbol."))
  (multiple-value-bind (dummies vals newval setter getter)
		       (get-setf-expansion (cons function args) env)
    ;; Make sure the place is one that we can handle.
    ;;Mainly to insure against cases of ldb and mask-field and such creeping in.
    (let* ((last-arg (car (last args)))
           (last-val (car (last vals)))
           (last-dummy (car (last dummies)))
           (last-getter (car (last getter)))
           (last2-setter (car (last setter 2)))
           (last-setter (car (last setter))))
      (cond ((and (or (and (eq last-arg last-val)
                           (eq last-getter last-dummy))
                      (eq last-arg last-getter))
                  newval
                  (null (cdr newval))
                  (eq last-setter (car newval))
                  (or (and (eq last-arg last-val)
                           (eq last2-setter last-dummy))
                      (eq last-arg last2-setter)))
             ;; (setf (foo ... argn) bar) -> (set-foo ... argn bar)
             (values dummies vals newval
                     `(apply+ (function ,(car setter)) ,@(cdr setter))
                     `(apply (function ,(car getter)) ,@(cdr getter))))
            ((and (or (and (eq last-arg last-val)
                           (eq last-getter last-dummy))
                      (eq last-arg last-getter))
                  newval
                  (null (cdr newval))
                  (eq (car setter) 'funcall)
                  (eq (third setter) (car newval))
                  (or (and (eq last-arg last-val)
                           (eq last-setter last-dummy))
                      (eq last-arg last-setter)))
             ;; (setf (foo ... argn) bar) -> (funcall #'(setf foo) bar ... argn)  [with bindings for evaluation order]
             (values dummies vals newval
                     `(apply ,@(cdr setter))
                     `(apply (function ,(car getter)) ,@(cdr getter))))
            (t (error "Apply of ~S is not understood as a location for Setf."
                      function))))))

;;These are the supporting functions for the am-style hard-cases of setf.
(defun assoc-2-lists (list1 list2)
  "Not CL. Returns an assoc-like list with members taken by associating corresponding
   elements of each list. uses list instead of cons.
   Will stop when first list runs out."
  (do* ((lst1 list1 (cdr lst1))
        (lst2 list2 (cdr lst2))
        (result nil))
       ((null lst1) result)
       (setq result (cons (list (car lst1)
                                (car lst2))
                          result))))

(defun make-gsym-list (size)
  "Not CL. Returns a list with size members, each being a different gensym"
  (let ((temp nil))
        (dotimes (arg size temp)
          (declare (fixnum arg))
          (setq temp (cons (gensym) temp)))))
;;;;;;;

(define-setf-method getf (plist prop &optional (default () default-p)
                                     &aux (prop-p (not (constantp prop env)))
                                     &environment env)
 (multiple-value-bind (vars vals stores store-form access-form)
                      (get-setf-method plist env)
   (when default-p (setq default (list default)))
   (let ((prop-var (if prop-p (gensym) prop))
         (store-var (gensym))
         (default-var (if default-p (list (gensym)))))
     (values
      `(,@vars ,.(if prop-p (list prop-var)) ,@default-var)
      `(,@vals ,.(if prop-p (list prop)) ,@default)
      (list store-var)
      `(let* ((,(car stores) (setprop ,access-form ,prop-var ,store-var)))
         ,store-form
         ,store-var)
      `(getf ,access-form ,prop-var ,@default-var)))))

(define-setf-method getf-test (plist prop test &optional (default () default-p)
                                       &aux (prop-p (not (quoted-form-p prop)))
                                       &environment env)
 (multiple-value-bind (vars vals stores store-form access-form)
                      (get-setf-method plist env)
   (when default-p (setq default (list default)))
   (let ((prop-var (if prop-p (gensym) prop))
         (test-var (gensym))
         (store-var (gensym))
         (default-var (if default-p (list (gensym)))))
     (values
      `(,@vars ,.(if prop-p (list prop-var)) ,test-var ,@default-var)
      `(,@vals ,.(if prop-p (list prop)) ,test ,@default)
      (list store-var)
      `(let* ((,(car stores) (setprop-test ,access-form ,prop-var ,test-var ,store-var)))
         ,store-form
         ,store-var)
      `(getf-test ,access-form ,prop-var ,test-var ,@default-var)))))

(define-setf-method ldb (bytespec place &environment env)
  "The first argument is a byte specifier. The second is any place form
  acceptable to SETF. Replace the specified byte of the number in this
  place with bits from the low-order end of the new value."
  (multiple-value-bind (dummies vals newval setter getter)
		       (get-setf-method place env)
    (let ((btemp (gensym))
	  (gnuval (gensym)))
      (values (cons btemp dummies)
	      (cons bytespec vals)
	      (list gnuval)
	      `(let ((,(car newval) (dpb ,gnuval ,btemp ,getter)))
		 ,setter
		 ,gnuval)
	      `(ldb ,btemp ,getter)))))


(define-setf-method mask-field (bytespec place &environment env)
  "The first argument is a byte specifier. The second is any place form
  acceptable to SETF. Replaces the specified byte of the number in this place
  with bits from the corresponding position in the new value."
  (multiple-value-bind (dummies vals newval setter getter)
		       (get-setf-method place env)
    (let ((btemp (gensym))
	  (gnuval (gensym)))
      (values (cons btemp dummies)
	      (cons bytespec vals)
	      (list gnuval)
	      `(let ((,(car newval) (deposit-field ,gnuval ,btemp ,getter)))
		 ,setter
		 ,gnuval)
	      `(mask-field ,btemp ,getter)))))

(defmacro shiftf (arg1 arg2 &rest places-&-nuval &environment env)
  "One or more SETF-style place expressions, followed by a single
   value expression. Evaluates all of the expressions in turn, then
   assigns the value of each expression to the place on its left,
   returning the value of the leftmost."
  (setq places-&-nuval (list* arg1 arg2 places-&-nuval))
  (let* ((nuval (car (last places-&-nuval)))
         (places (cdr (reverse places-&-nuval)))  ; not nreverse, since &rest arg shares structure with &whole.
         (setters (list 'progn))
         (last-getter nuval)
         last-let-list
         let-list
         (body setters))
    (dolist (place places)
      (multiple-value-bind (vars values storevars setter getter)
                           (get-setf-method-multiple-value place env)
        (dolist (v vars)
          (push (list v (pop values)) let-list))
        (push setter (cdr setters))
        (setq body
              (if last-let-list
                `(let* ,(nreverse last-let-list)
                   (multiple-value-bind ,storevars ,last-getter
                     ,body))
                `(multiple-value-bind ,storevars ,last-getter
                   ,body))
              last-let-list let-list
              let-list nil
              last-getter getter)))
    (if last-let-list
      `(let* ,(nreverse last-let-list)
         (multiple-value-prog1 ,last-getter
           ,body))
      `(multiple-value-prog1 ,last-getter
         ,body))))

;(shiftf (car x)(cadr x) 3)

#|
(defmacro rotatef (&rest args &environment env)
  (let* ((setf-result nil)
         (let-result nil)
         (last-store nil)
         (fixpair nil))
    (dolist (arg args)
      (multiple-value-bind (vars vals storevars setter getter) 
                           (get-setf-method arg env)
        (dolist (var vars)
          (push (list var (pop vals)) let-result))
        (push (list last-store getter) let-result)
        (unless fixpair (setq fixpair (car let-result)))
        (push setter setf-result)
        (setq last-store (car storevars))))
    (rplaca fixpair last-store)
    `(let* ,(nreverse let-result) ,@(nreverse setf-result) nil)))


;(rotatef (blob x)(blob y))
(defun blob (x) (values (car x)(cadr x)))
(define-setf-method blob (x)
    (let ((v1 (gensym))(v2 (gensym))(v3 (gensym)))
    (values
     (list v1)
     (list x)
     (list v2 v3)      
     `(progn (setf (car ,v1) ,v2)
             (setf (cadr ,v1) ,v3))     
     `(values (car ,v1)(cadr ,v1)))))
|#

(defmacro rotatef (&rest args &environment env)
  "Takes any number of SETF-style place expressions. Evaluates all of the
   expressions in turn, then assigns to each place the value of the form to
   its right. The rightmost form gets the value of the leftmost.
   Returns NIL."
  (when args
    (let* ((places (reverse args))  ; not nreverse, since &rest arg shares structure with &whole.
           (final-place (pop places))
           (setters (list 'progn nil))
           last-let-list
           let-list
           (body setters))
      (multiple-value-bind (final-vars final-values final-storevars
                                       final-setter last-getter)
                           (get-setf-method-multiple-value final-place env)
        (dolist (v final-vars)
          (push (list v (pop final-values)) last-let-list))
        (push final-setter (cdr setters))
        (dolist (place places)
          (multiple-value-bind (vars values storevars setter getter)
                               (get-setf-method-multiple-value place env)
            (dolist (v vars)
              (push (list v (pop values)) let-list))
            (push setter (cdr setters))
            (setq body
                  (if last-let-list
                    `(let* ,(nreverse last-let-list)
                       (multiple-value-bind ,storevars ,last-getter
                         ,body))
                    `(multiple-value-bind ,storevars ,last-getter
                       ,body))
                  last-let-list let-list
                  let-list nil
                  last-getter getter)))
        (if last-let-list
          `(let* ,(nreverse last-let-list)
             (multiple-value-bind ,final-storevars ,last-getter
               ,body))
          `(multiple-value-bind ,final-storevars ,last-getter
             ,body))))))



(defmacro push (value place &environment env)
  "Takes an object and a location holding a list. Conses the object onto
  the list, returning the modified list. OBJ is evaluated before PLACE."
  (if (not (consp place))
    `(setq ,place (cons ,value ,place))
    (multiple-value-bind (dummies vals store-var setter getter)
                         (get-setf-method place env)
      (let ((valvar (gensym)))
        `(let* ((,valvar ,value)
                ,@(mapcar #'list dummies vals)
                (,(car store-var) (cons ,valvar ,getter)))
           ,@dummies
           ,(car store-var)
           ,setter)))))

(defmacro pushnew (value place &rest keys &environment env)
  "Takes an object and a location holding a list. If the object is
  already in the list, does nothing; otherwise, conses the object onto
  the list. Returns the modified list. If there is a :TEST keyword, this
  is used for the comparison."
  (if (not (consp place))
    `(setq ,place (adjoin ,value ,place ,@keys))
    (let ((valvar (gensym)))
      (multiple-value-bind (dummies vals store-var setter getter)
                           (get-setf-method place env)
        `(let* ((,valvar ,value)
                ,@(mapcar #'list dummies vals)
                (,(car store-var) (adjoin ,valvar ,getter ,@keys)))
           ,@dummies
           ,(car store-var)
           ,setter)))))

(defmacro pop (place &environment env &aux win)
  "The argument is a location holding a list. Pops one item off the front
  of the list and returns it."
  (while (atom place)
    (multiple-value-setq (place win) (macroexpand-1 place env))
    (unless win
      (return-from pop
        `(prog1 (car ,place) (setq ,place (cdr (the list ,place)))))))
  (let ((value (gensym)))
    (multiple-value-bind (dummies vals store-var setter getter)
                         (get-setf-method place env)
      `(let* (,@(mapcar #'list dummies vals)
              (,value ,getter)
              (,(car store-var) (cdr ,value)))
         ,@dummies
         ,(car store-var)
         (prog1
           (%car ,value)
           ,setter)))))

(defmacro %pop (symbol)
  `(prog1 (%car ,symbol) (setq ,symbol (%cdr ,symbol))))

#|
(defmacro push (item place)
  (if (not (consp place))
    `(setq ,place (cons ,item ,place))
    (let* ((arg-num (1- (length place)))
           (place-args (make-gsym-list arg-num)))
      `(let ,(cons (list 'nu-item item)
                   (reverse (assoc-2-lists place-args (cdr place))))
         (setf (,(car place) ,@place-args)
               (cons nu-item (,(car place) ,@place-args)))))))

(defmacro pushnew (item place &rest key-args)
  (let ((item-gsym (gensym)))
    (if (not (consp place))
      `(let ((,item-gsym ,item))
         (setq ,place (adjoin ,item-gsym ,place ,@key-args)))
      (let* ((arg-num (1- (length place)))
             (place-args (make-gsym-list arg-num)))
        `(let ,(cons (list item-gsym item)
                     (reverse (assoc-2-lists place-args (cdr place))))
           (setf (,(car place) ,@place-args)
                 (adjoin ,item-gsym (,(car place) ,@place-args)
                         ,@key-args)))))))
(defmacro pop (place)
  (if (not (consp place))               ;  screw: symbol macros.
    `(prog1 (car ,place) (setq ,place (%cdr ,place)))
    (let* ((arg-num (1- (length place)))
           (place-args (make-gsym-list arg-num)))
      `(let ,(reverse (assoc-2-lists place-args (cdr place)))
         (prog1 (car (,(car place) ,@place-args))
           (setf (,(car place) ,@place-args)
                 (cdr (,(car place) ,@place-args))))))))
|#

(defmacro remf (place indicator &environment env)
  "Place may be any place expression acceptable to SETF, and is expected
  to hold a property list or (). This list is destructively altered to
  remove the property specified by the indicator. Returns T if such a
  property was present, NIL if not."
  (multiple-value-bind (dummies vals newval setter getter)
                       (get-setf-method place env)
    (do* ((d dummies (cdr d))
          (v vals (cdr v))
          (let-list nil)
          (ind-temp (gensym))
          (local1 (gensym))
          (local2 (gensym)))
         ((null d)
          (push (list ind-temp indicator) let-list)
          (push (list (car newval) getter) let-list)
          `(let* ,(nreverse let-list)
             (do ((,local1 ,(car newval) (cddr ,local1))
                  (,local2 nil ,local1))
                 ((atom ,local1) nil)
               (cond ((atom (cdr ,local1))
                      (error "Odd-length property list in REMF."))
                     ((eq (car ,local1) ,ind-temp)
                      (cond (,local2
                             (rplacd (cdr ,local2) (cddr ,local1))
                             (return t))
                            (t (setq ,(car newval) (cddr ,(car newval)))
                               ,setter
                               (return t))))))))
      (push (list (car d) (car v)) let-list))))

(defmacro remf-test (place indicator test &environment env)
  "Place may be any place expression acceptable to SETF, and is expected
  to hold a property list or ().  This list is destructively altered to
  remove the property specified by the indicator.  Returns T if such a
  property was present, NIL if not."
  (multiple-value-bind (dummies vals newval setter getter)
                       (get-setf-method place env)
    (do* ((d dummies (cdr d))
          (v vals (cdr v))
          (let-list nil)
          (ind-temp (gensym))
          (test-temp (gensym))
          (local1 (gensym))
          (local2 (gensym)))
         ((null d)
          (push (list (car newval) getter) let-list)
          (push (list ind-temp indicator) let-list)
          (push (list test-temp test) let-list)
          `(let* ,(nreverse let-list)
             (do ((,local1 ,(car newval) (cddr ,local1))
                  (,local2 nil ,local1))
                 ((atom ,local1) nil)
               (cond ((atom (cdr ,local1))
                      (error "Odd-length property list in REMF."))
                     ((funcall ,test-temp (car ,local1) ,ind-temp)
                      (cond (,local2
                             (rplacd (cdr ,local2) (cddr ,local1))
                             (return t))
                            (t (setq ,(car newval) (cddr ,(car newval)))
                               ,setter
                               (return t))))))))
      (push (list (car d) (car v)) let-list))))

(define-setf-expander values (&rest places &environment env) 
  (let* ((setters ())
	 (getters ())
	 (all-dummies ()) 
	 (all-vals ()) 
	 (newvals ())) 
    (dolist (place places) 
      (multiple-value-bind (dummies vals newval setter getter) 
	  (get-setf-expansion place env) 
	(setf all-dummies (append all-dummies dummies (cdr newval))) 
	(setf all-vals (append all-vals vals (mapcar (constantly nil) (cdr newval)))) 
	(setf newvals (append newvals (list (car newval)))) 
	(push setter setters)
	(push getter getters))) 
      (values all-dummies all-vals newvals 
              `(values ,@(nreverse setters)) `(values ,@(nreverse getters)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/setf.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/sequences.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;
;; utility functions
;;
;;  these probably want to be in-line

(defun make-sequence-like (sequence length)
  (seq-dispatch 
   sequence
   (make-list length)
   (make-array length :element-type (array-element-type sequence))))

(defun adjust-test-args (item test test-not)
  ;; after running this "test" is the real test, a null test means "eq"
  ;; and "test-not" is used as a flag
  (when test-not
    (if test 
      (error "Both ~s and ~s keywords supplied" :test :test-not)
      (setq test test-not)))
  (if test
    (if (or (eq test #'eq)
            (eq test 'eq)
            (and (or (eq test #'equal) (eq test 'equal))
                 (or (fixnump item) (symbolp item))))
      (setq test nil)
      (if (eq test #'funcall)
        (setq test 'funcall)))
    (if (or (macptrp item) (and (not (fixnump item)) (numberp item)))
      (setq test #'eql)))
  (values test test-not))

(defun adjust-key (key)
  (and (neq key 'identity) 
       (neq key #'identity)
       key))

(defun matchp2 (item elt test test-not key)
  (if key
    (setq elt (funcall key elt)))
  (let ((res (if test
               (if (eq test 'funcall)
                 (funcall item elt)
                 (funcall test item elt))
               (eq item elt))))
    (if test-not
      (not res)
      res)))

;;; CTYPE is a recognizable subtype of VECTOR, which means that it's either
;;; a) an ARRAY-CTYPE
;;; b) a UNION-CTYPE whose leaves are ARRAY-CTYPE
;;; c) the NIL type, which is trivially a subtype of VECTOR but isn't really
;;;    worth considering here
;;; d) a MEMBER-CTYPE whose members are all vectors and which therefore have
;;;    corresponding ARRAY-CTYPEs.
;;; Try to find the interesection of all ARRAY-CTYPEs referenced in CTYPE and
;;;  return it.
;;; Note that this intersection may be the null type.
(defun simplify-vector-ctype (ctype)
  (typecase ctype
    (array-ctype
     (make-array-ctype :complexp nil
                       :element-type (array-ctype-element-type ctype)
                       :specialized-element-type (array-ctype-specialized-element-type ctype)
                       :dimensions '(*)))
                                      
    (named-ctype ctype)
    (member-ctype
     (apply #'type-intersection (mapcar #'(lambda (x)
                                            (simplify-vector-ctype
                                             (ctype-of x)))
                                        (member-ctype-members ctype))))
    (union-ctype
     (apply #'type-intersection (mapcar #'simplify-vector-ctype (union-ctype-types ctype))))))
    
(defun make-sequence (type length &key (initial-element nil initial-element-p))
  "Return a sequence of the given TYPE and LENGTH, with elements initialized
  to INITIAL-ELEMENT."
  (setq length (require-type length 'fixnum))
  (let* ((ctype (specifier-type type)))
    (declare (fixnum length))
    (if (< length 0) (report-bad-arg length '(and fixnum unsigned-byte)))
    (let ((tlength (array-ctype-length ctype)))
      (if (and tlength (neq tlength length))
        (error 'invalid-subtype-error
               :datum type
               :expected-type `(vector ,(type-specifier (array-ctype-element-type ctype)) ,length))))
    (cond 
          ((csubtypep ctype (specifier-type 'base-string))
           (if initial-element-p
             (make-string length 
                          :element-type 'base-char
                          :initial-element initial-element)
             (make-string length
                          :element-type 'base-char)))
          ((csubtypep ctype (specifier-type 'vector))
           (let* ((atype (simplify-vector-ctype ctype)))
             (unless (typep atype 'array-ctype)
               (error "Can't determine vector element-type of ~s" (type-specifier ctype)))
             (let* ((element-type (type-specifier (array-ctype-element-type atype))))
               (if (eq element-type '*) (setq element-type t))
               (if initial-element-p
                 (make-array (the fixnum length)
                             :element-type element-type
                             :initial-element initial-element)
                 (make-array (the fixnum length)
                             :element-type element-type)))))
          ((csubtypep ctype (specifier-type 'null))
           (unless (zerop length)
             (error 'invalid-subtype-error :datum type :expected-type 'cons)))
          ((csubtypep ctype (specifier-type 'cons))
           (if (zerop length)
             (error 'invalid-subtype-error :datum type :expected-type 'null)
             (make-list length :initial-element initial-element)))
          ((csubtypep ctype (specifier-type 'list))
           (make-list length :initial-element initial-element))
          (t (error 'invalid-subtype-error :datum  type
                    :expected-type 'sequence)))))



;;; Subseq:

;;; SRC is a (SIMPLE-ARRAY * (*)), TYPECODE is its ... typecode,
;;; START and END are fixnums and sanity-checked.
(defun simple-1d-array-subseq (src typecode start end)
  (declare (fixnum start end typecode))
  (let* ((n (- end start))
	 (dest (%alloc-misc n typecode)))
    (declare (fixnum n))
    (if (= typecode target::subtag-simple-vector)
      (%copy-gvector-to-gvector src start dest 0 n)
      (ecase typecode
	((#.target::subtag-s8-vector
	  #.target::subtag-u8-vector)
	 (%copy-ivector-to-ivector src start dest 0 n))
	((#.target::subtag-s16-vector
	  #.target::subtag-u16-vector)
	 (%copy-ivector-to-ivector src
				   (the fixnum (+ start start))
				   dest
				   0
				   (the fixnum (+ n n))))
	((#.target::subtag-s32-vector
	  #.target::subtag-u32-vector
	  #.target::subtag-single-float-vector
          #+32-bit-target #.target::subtag-fixnum-vector
          #.target::subtag-simple-base-string)
	 (%copy-ivector-to-ivector src
				   (the fixnum (ash start 2))
				   dest
				   0
				   (the fixnum (ash n 2))))
	;; DOUBLE-FLOAT vectors have extra alignment padding on ppc32/x8632.
	#+32-bit-target
	(#.target::subtag-double-float-vector
	 (%copy-ivector-to-ivector src
				   (the fixnum (+ (the fixnum (ash start 3))
						  (- target::misc-dfloat-offset
						     target::misc-data-offset)))
				   dest
				   (- target::misc-dfloat-offset
						     target::misc-data-offset)
				   (the fixnum (ash n 3))))
	#+64-bit-target
	((#.target::subtag-double-float-vector
	  #.target::subtag-s64-vector
	  #.target::subtag-u64-vector
          #.target::subtag-fixnum-vector)
	 (%copy-ivector-to-ivector src
				   (the fixnum (ash start 3))
				   dest
				   0
				   (the fixnum (ash n 3))))
        (#.target::subtag-complex-single-float-vector
         (%copy-ivector-to-ivector src
                                   (the fixnum (+ (- target::complex-single-float.realpart target::misc-data-offset)
                                                  (the fixnum (ash start 3))))
                                   dest
                                   (- target::complex-single-float.realpart target::misc-data-offset)
                                   (the fixnum (ash n 3))))
        (#.target::subtag-complex-double-float-vector
         (%copy-ivector-to-ivector src
                                   (the fixnum (+ (- target::complex-double-float.realpart target::misc-data-offset)
                                                  (the fixnum (ash start 4))))
                                   dest
                                   (- target::complex-double-float.realpart target::misc-data-offset)
                                   (the fixnum (ash n 4))))
	(#.target::subtag-bit-vector
	 ;; We can probably do a byte at a time if (not (logtest start 7))
	 (if (not (logtest start 7))
	   (%copy-ivector-to-ivector src
				     (the fixnum (ash (the fixnum (+ start 7))
						      -3))
				     dest
				     0
				     (the fixnum (ash (the fixnum (+ n 7))
						      -3)))
	   ;; Harder to optimize this case.
	   (locally  (declare (simple-bit-vector src dest)
			      (optimize (speed 3) (safety 0)))
	     (do* ((i start (1+ i))
		   (j 0 (1+ j)))
		  ((= i end) dest)
	       (declare (fixnum i j))
	       (setf (sbit dest j) (sbit src i))))))))))


(defun nthcdr-error (index list &aux (copy list))
 "If index > length, error"
 (dotimes (i index copy)
   (declare (fixnum i))
   (if copy
     (setq copy (cdr copy))
     (%err-disp $XACCESSNTH index list))))

; slisp didn't error if end > length, or if start > end.
(defun list-subseq* (sequence start end)
  (declare (fixnum start end))
  (if (= start end)
    nil
    (let* ((groveled (nthcdr-error start sequence))
           (result (list (car groveled))))
      (when groveled
        (do ((list (cdr groveled) (cdr list))
             (splice result (cdr (rplacd splice (list (car list)))))
             (index (1+ start) (1+ index)))
             ((= index end) result)
          (declare (fixnum index))
           ())))))

; This ensures that start & end will be non-negative FIXNUMS ...
; This implies that the address space is < 2^31 bytes, i.e., no list
; can have a length > most-positive fixnum.  Let them report it as a
; bug ...

(defun subseq (sequence start &optional end)
  "Return a copy of a subsequence of SEQUENCE starting with element number
   START and continuing to the end of SEQUENCE or the optional END."
  (setq end (check-sequence-bounds sequence start end))
  (locally 
      (declare (fixnum start end))
      (seq-dispatch 
       sequence
       (list-subseq* sequence start end)
       (let* ((typecode (typecode sequence)))
	 (declare (fixnum typecode))
	 (when (= typecode target::subtag-vectorH)
	   (multiple-value-bind (data offset)
	       (array-data-and-offset sequence)
	     (declare (fixnum offset))
	     (incf start offset)
	     (incf end offset)
	     (setq sequence data typecode (typecode data))))
	 (simple-1d-array-subseq sequence typecode start end)))))
	 

;;; Copy-seq:

(defun copy-seq (sequence)
  "Return a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ."
  (seq-dispatch 
   sequence
   (copy-list sequence)
   (let* ((length (length sequence))
          (subtype (element-type-subtype (array-element-type sequence)))
          (result  (%alloc-misc length subtype))
          )
     (multiple-value-bind (src offset) (array-data-and-offset sequence)
       (declare (fixnum offset))                          
       (dotimes (i length result)
         (declare (fixnum i))
         (setf (uvref result i) (uvref src offset))
         (incf offset))))))



;;; Fill:

(defun fill (sequence item &key (start 0) end)
  "Replace the specified elements of SEQUENCE with ITEM.
   !$ could be sped up by calling iv-fill, sv-fill to avoid aref overhead."
  (setq end (check-sequence-bounds sequence start end))
  (seq-dispatch 
   sequence
   (do* ((current (nthcdr start sequence) (cdr (the list current)))
         (index start (1+ index)))
        ((or (atom current) (= index end)) sequence)
     (rplaca (the cons current) item))
   (if (and (typep sequence 'ivector)
            (eql start 0)
            (eql end (uvsize sequence)))
     (%init-misc item sequence)
     (do ((index start (1+ index)))
         ((= index end) sequence)
       (aset sequence index item)))))

;;; Replace:

(defun replace (target-sequence source-sequence &key
                                ((:start1 target-start) 0)
                                ((:end1 target-end))
                                ((:start2 source-start) 0)
                                ((:end2 source-end)))
  "The target sequence is destructively modified by copying successive
   elements into it from the source sequence."
  (setq target-end (check-sequence-bounds target-sequence target-start
                                          target-end))
  (setq source-end (check-sequence-bounds source-sequence source-start
                                          source-end))
  (locally (declare (fixnum target-start target-end source-start source-end))
    (let* ((typecode (typecode source-sequence))
           (n (- source-end source-start)))
      (if (and (not (listp source-sequence))
               (simple-array-p source-sequence)
               (= (the fixnum (- target-end target-start)) n)
               (= typecode (typecode target-sequence)))
        (%uvector-replace target-sequence target-start source-sequence source-start n typecode)
        
    (seq-dispatch 
     target-sequence
     (seq-dispatch 
      source-sequence
      (if (and (eq target-sequence source-sequence) 
               (> target-start source-start))
        (let ((new-elts (subseq source-sequence source-start
                                (+ source-start
                                   (min (- target-end target-start)
                                        (- source-end source-start))))))
          (do ((n new-elts (cdr n))
               (o (nthcdr target-start target-sequence) (cdr o)))
              ((null n) target-sequence)
            (rplaca o (car n))))
        (do ((target-index target-start (1+ target-index))
             (source-index source-start (1+ source-index))
             (target-sequence-ref (nthcdr target-start target-sequence)
                                  (cdr target-sequence-ref))
             (source-sequence-ref (nthcdr source-start source-sequence)
                                  (cdr source-sequence-ref)))
            ((or (= target-index target-end) (= source-index source-end)
                 (null target-sequence-ref) (null source-sequence-ref))
             target-sequence)
          (declare (fixnum target-index source-index))
          (rplaca target-sequence-ref (car source-sequence-ref))))
      (do ((target-index target-start (1+ target-index))
           (source-index source-start (1+ source-index))
           (target-sequence-ref (nthcdr target-start target-sequence)
                                (cdr target-sequence-ref)))
          ((or (= target-index target-end) (= source-index source-end)
               (null target-sequence-ref))
           target-sequence)
        (declare (fixnum target-index source-index))
        (rplaca target-sequence-ref (aref source-sequence source-index))))
     (seq-dispatch 
      source-sequence
      (do ((target-index target-start (1+ target-index))
           (source-index source-start (1+ source-index))
           (source-sequence (nthcdr source-start source-sequence)
                            (cdr source-sequence)))
          ((or (= target-index target-end) (= source-index source-end)
               (null source-sequence))
           target-sequence)
        (declare (fixnum target-index source-index))
        (aset target-sequence target-index (car source-sequence)))
      ;; If we are copying around in the same vector, be careful not
      ;; to copy the same elements over repeatedly.  We do this by
      ;; copying backwards.
      (if (and (eq target-sequence source-sequence) 
               (> target-start source-start))
        (let ((nelts (min (- target-end target-start) 
                          (- source-end source-start))))
          (do ((target-index (+ target-start nelts -1) (1- target-index))
               (source-index (+ source-start nelts -1) (1- source-index)))
              ((= target-index (1- target-start)) target-sequence)
            (aset target-sequence target-index
                  (aref source-sequence source-index))))
        (do ((target-index target-start (1+ target-index))
             (source-index source-start (1+ source-index)))
            ((or (= target-index target-end) (= source-index source-end))
             target-sequence)
          (declare (fixnum target-index source-index))
          (aset target-sequence target-index
                (aref source-sequence source-index))))))))))

;;; Concatenate:


(defun concatenate (output-type-spec &rest sequences)
  "Return a new sequence of all the argument sequences concatenated together
  which shares no structure with the original argument sequences of the
  specified OUTPUT-TYPE-SPEC."
  (declare (dynamic-extent sequences))
  (if (memq output-type-spec '(string simple-string))
    (setq output-type-spec 'base-string)
    (unless (memq output-type-spec '(string simple-string base-string list vector
                                     simple-base-string
                                     bit-vector simple-bit-vector))
      (setq output-type-spec (type-expand output-type-spec))))
  (case (if (atom output-type-spec) output-type-spec (car output-type-spec))
    (list (apply #'concat-to-list* sequences))
    ((simple-vector simple-string simple-base-string base-string vector string array
                    bit-vector simple-bit-vector)
     (apply #'concat-to-simple* output-type-spec sequences))
    (t
     (if (subtypep output-type-spec 'vector)
       (apply #'concat-to-simple* output-type-spec sequences)
       (if (subtypep output-type-spec 'list)
         (apply #'concat-to-list* sequences)
         (error "~S: invalid output type specification." output-type-spec))))))

;;; Internal Frobs:

(defun concat-to-list* (&rest sequences)
  (declare (dynamic-extent sequences))
  (let* ((result (list nil))
         (splice result))
    (dolist (sequence sequences (%cdr result))
      (seq-dispatch
       sequence
       (dolist (item sequence)
         (setq splice (%cdr (%rplacd splice (list item)))))
       (dotimes (i (length sequence))
         (setq splice (%cdr (%rplacd splice (list (aref sequence i))))))))))
             

(defun concat-to-simple* (output-type-spec &rest arg-sequences)
  (declare (dynamic-extent arg-sequences))
  (do ((seqs arg-sequences (cdr seqs))
        (total-length 0)
        ;(lengths ())
        )
      ((null seqs)
       (do ((sequences arg-sequences (cdr sequences))
            ;(lengths lengths (cdr lengths))
            (index 0)
            (result (make-sequence output-type-spec total-length)))
           ((= index total-length) result)
         (let ((sequence (car sequences)))
           (seq-dispatch
            sequence
            (do ((sequence sequence (cdr sequence)))
                ((atom sequence))
              (aset result index (car sequence))
              (setq index (1+ index)))
            (let ((len (length sequence)))
              (do ((jndex 0 (1+ jndex)))
                  ((= jndex len))
                (aset result index (aref sequence jndex))
                (setq index (1+ index))))))))
     (let ((length (length (car seqs))))
       ;(setq lengths (nconc lengths (list length))) ; if itsa list, we dont care about its length, if itsan array, length twice is cheap
       (setq total-length (+ total-length length)))))

(defun concat-to-string (&rest sequences)
  (declare (dynamic-extent sequences))
  (let* ((size 0))
    (declare (fixnum size))
    (dolist (seq sequences)
      (setq size (+ size (the fixnum (length seq)))))
    (let* ((result (make-string size))
           (out 0))
      (declare (simple-string result) (fixnum out))
      (dolist (seq sequences result)
        (etypecase seq
          (simple-string
           (let* ((n (length seq)))
             (declare (fixnum n))
             (%copy-ivector-to-ivector seq
                                       0
                                       result
                                       (the fixnum (ash out 2))
                                       (the fixnum (ash n 2)))
             (incf out n)))
          (string
           (let* ((n (length seq)))
             (declare (fixnum n))
             (multiple-value-bind (data offset) (array-data-and-offset seq)
               (declare (fixnum offset))
               (%copy-ivector-to-ivector data
                                         (the fixnum (ash offset 2))
                                         result
                                         (the fixnum (ash out 2))
                                         (the fixnum (ash n 2)))
               (incf out n))))
          (vector
           (dotimes (i (length seq))
             (setf (schar result out) (aref seq i))
             (incf out)))
          (list
           (dolist (elt seq)
             (setf (schar result out) elt)
             (incf out))))))))

;This one doesn't choke on circular lists, doesn't cons as much, and is
;about 1/8K smaller to boot.
(defun map (type function sequence &rest more-sequences)
  (declare (dynamic-extent more-sequences))
  (let* ((sequences (cons sequence more-sequences))
         (arglist (make-list (length sequences)))
         (index 0)
         args seq p (ans ()))
    (declare (dynamic-extent sequences arglist))
    (unless (or (null type)
                (eq type 'list)
                (memq (if (consp type) (%car type) type)
                      '(simple-vector simple-string vector string array
                        simple-array bit-vector simple-bit-vector))
                (subtypep type 'sequence))
      (report-bad-arg type 'sequence))
    (loop
      (setq p sequences args arglist)
      (while p
        (cond ((null (setq seq (%car p))) (return))
              ((consp seq)
               (%rplaca p (%cdr seq))
               (%rplaca args (%car seq)))
              ((eq index (length seq)) (return))
              (t (%rplaca args (elt seq index))))
        (setq args (%cdr args) p (%cdr p)))
      (setq p (apply function arglist))
      (if type (push p ans))
      (setq index (%i+ index 1)))
    (when type
      (setq ans (nreverse ans))
      (if (eq type 'list) ans (coerce ans type)))))

;;;;;;;;;;;;;;;;;
;;
;; some, every, notevery, notany
;;
;; these all call SOME-XX-MULTI or SOME-XX-ONE
;; SOME-XX-MULTI should probably be coded in lap
;;
;; these should be transformed at compile time
;;
;; we may want to consider open-coding when
;; the predicate is a lambda
;; 

(eval-when (:execute :compile-toplevel)
  (defmacro negating-quantifier-p (quantifier-constant)
    `(%i> ,quantifier-constant $notany))
  )

; Vector is guaranteed to be simple; new-size is guaranteed <= (length vector).
; Return vector with its size adjusted and extra doublewords zeroed out.
; Should only be called on freshly consed vectors...

    
    
(defun some (predicate one-seq &rest sequences)
  "Apply PREDICATE to the 0-indexed elements of the sequences, then 
   possibly to those with index 1, and so on. Return the first 
   non-NIL value encountered, or NIL if the end of any sequence is reached."
  (declare (dynamic-extent sequences))
  (if sequences
      (some-xx-multi $some nil predicate one-seq sequences)
      (some-xx-one $some nil predicate one-seq)))

(defun notany (predicate one-seq &rest sequences)
  "Apply PREDICATE to the 0-indexed elements of the sequences, then 
   possibly to those with index 1, and so on. Return NIL as soon
   as any invocation of PREDICATE returns a non-NIL value, or T if the end
   of any sequence is reached."
  (declare (dynamic-extent sequences))
  (if sequences
      (some-xx-multi $notany t predicate one-seq sequences)
      (some-xx-one $notany t predicate one-seq)))

(defun every (predicate one-seq &rest sequences)
  "Apply PREDICATE to the 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return NIL as soon
   as any invocation of PREDICATE returns NIL, or T if every invocation
   is non-NIL."
  (declare (dynamic-extent sequences))
  (if sequences
      (some-xx-multi $every t predicate one-seq sequences)
      (some-xx-one $every t predicate one-seq)))

(defun notevery (predicate one-seq &rest sequences)
  "Apply PREDICATE to 0-indexed elements of the sequences, then
   possibly to those with index 1, and so on. Return T as soon
   as any invocation of PREDICATE returns NIL, or NIL if every invocation
   is non-NIL."
  (declare (dynamic-extent sequences))
  (if sequences
      (some-xx-multi $notevery nil predicate one-seq sequences)
      (some-xx-one $notevery nil predicate one-seq)))

(defun some-xx-multi (caller at-end predicate first-seq sequences)
  (let* ((sequences (cons first-seq sequences))
         (min-vector-length target::target-most-positive-fixnum)
         (arg-slice (make-list (list-length sequences)))
         (cur-slice arg-slice)
         (not-result (negating-quantifier-p caller))
         result)
  (declare (fixnum min-vector-length)
           (list sequences arg-slice cur-slice)
           (dynamic-extent sequences arg-slice))
  (dolist (seq sequences)
    (seq-dispatch seq
                  nil
                  (setq min-vector-length (min min-vector-length
                                               (length seq)))))
  (dotimes (index min-vector-length)
    (do* ((sequences sequences (cdr sequences))
          (one-seq (car sequences) (car sequences)))
         ((null sequences))
      (declare (list sequences))
      (%rplaca cur-slice
               (if (vectorp one-seq)
                   (aref one-seq index)
                   (if one-seq
                       (progn
                         (setf (car sequences) (cdr one-seq))
                         (%car one-seq))
                       (return-from some-xx-multi at-end))))
      (setq cur-slice (%cdr cur-slice)))
    (setq result (apply predicate arg-slice)
          cur-slice arg-slice)
    (if not-result
        (when (not result)
          (return-from some-xx-multi
                       (if (eq caller $every) nil t)))
        (when result
          (return-from some-xx-multi
                       (if (eq caller $some) result nil)))))
  at-end))


(defun some-xx-one (caller at-end predicate seq
                           &aux (not-result (negating-quantifier-p caller))
                           result)
  (if (vectorp seq)
      (if (simple-vector-p seq)
        (locally (declare (type simple-vector seq))
          (dovector (element seq)
            (setq result (funcall predicate element))
            (if not-result
              (when (not result)
                (return-from some-xx-one
                  (if (eq caller $every) nil t)))
              (when result
                (return-from some-xx-one
                  (if (eq caller $some ) result nil))))))
        (dovector (element seq)
          (setq result (funcall predicate element))
          (if not-result
            (when (not result)
              (return-from some-xx-one
                (if (eq caller $every) nil t)))
            (when result
              (return-from some-xx-one
                (if (eq caller $some ) result nil))))))
      (dolist (element seq)
        (setq result (funcall predicate element))
        (if not-result
            (when (not result)
              (return-from some-xx-one
                           (if (eq caller $every) nil t)))
            (when result
              (return-from some-xx-one
                           (if (eq caller $some ) result nil))))))
      at-end)

;;; simple positional versions of find, position

(defun find-positional-test-key (item sequence test key)
  (if sequence
    (seq-dispatch
     sequence
     (let ((cons (member item sequence :test test :key key)))
       (and cons (%car cons)))
     (let ((pos (vector-position-1 item sequence nil test nil 0 nil key)))
       (and pos (aref sequence pos))))))

(defun find-positional-test-not-key (item sequence test-not key)
  (if sequence
    (seq-dispatch
     sequence
     (let ((cons (member item sequence :test-not test-not :key key)))
       (and cons (%car cons)))
     (let ((pos (vector-position-1 item sequence nil nil test-not 0 nil key)))
       (and pos (aref sequence pos))))))

(defun position-positional-test-key (item sequence test key)
  (if sequence
    (seq-dispatch
     sequence
     (progn
       (setq key (adjust-key key))
       (setq test
             (adjust-test-args item test nil))
       (if (or test key)
         (list-position/find-complex nil item sequence 0 nil test nil key)
         (list-position/find-simple nil item sequence 0 nil)))
     (vector-position-1 item sequence nil test nil 0 nil key))))

(defun position-positional-test-not-key (item sequence test-not key)
  (if sequence
    (seq-dispatch
     sequence
     (progn
       (setq key (adjust-key key))
       (multiple-value-bind (test test-not)
                            (adjust-test-args item nil test-not)
         (list-position/find-complex nil item sequence 0 nil test test-not key)))
     (vector-position-1 item sequence nil nil test-not 0 nil key))))


;;; Reduce:

(eval-when (:execute :compile-toplevel)
  
  (defmacro list-reduce (function sequence start end initial-value ivp key)
    (let ((what `(if ,key (funcall ,key (car sequence)) (car sequence))))
      `(let ((sequence (nthcdr ,start ,sequence)))
         (do ((count (if ,ivp ,start (1+ ,start)) (1+ count))
              (sequence (if ,ivp sequence (cdr sequence))
                        (cdr sequence))
              (value (if ,ivp ,initial-value ,what)
                     (funcall ,function value ,what)))
             ((= count ,end) value)))))
  
  (defmacro list-reduce-from-end (function sequence start end 
                                           initial-value ivp key)
    (let ((what `(if ,key (funcall ,key (car sequence)) (car sequence))))
      `(let ((sequence (nthcdr (- (length ,sequence) ,end) (reverse ,sequence))))
         (do ((count (if ,ivp ,start (1+ ,start)) (1+ count))
              (sequence (if ,ivp sequence (cdr sequence))
                        (cdr sequence))
              (value (if ,ivp ,initial-value ,what)
                     (funcall ,function ,what value)))
             ((= count ,end) value)))))
  
  ) ;; end eval-when

(defun reduce (function sequence &key from-end (start 0)
                        end (initial-value nil ivp) key)
  "The specified Sequence is ``reduced'' using the given Function.
  See manual for details."
  (unless end (setq end (length sequence)))
  (if (= end start)
    (if ivp initial-value (funcall function))
    (seq-dispatch
     sequence
     (if from-end
       (list-reduce-from-end  function sequence start end initial-value ivp key)
       (list-reduce function sequence start end initial-value ivp key))
     (let* ((disp (if from-end -1 1))
            (index (if from-end (1- end) start))
            (terminus (if from-end (1- start) end))
            (value (if ivp initial-value
                       (let ((elt (aref sequence index)))
                         (setq index (+ index disp))
                         (if key (funcall key elt) elt))))
            (element nil))
       (do* ()
            ((= index terminus) value)
         (setq element (aref sequence index)
               index (+ index disp)
               element (if key (funcall key element) element)
               value (funcall function (if from-end element value) (if from-end value element))))))))

(defun map-into (result-sequence function &rest sequences)
  (declare (dynamic-extent sequences))
  (let* ((nargs (list-length sequences))
         (temp (make-list (length sequences)))
         (maxcnt (seq-dispatch result-sequence (length result-sequence) (array-total-size result-sequence)))
         (rseq result-sequence))
    (declare (fixnum nargs maxcnt))
    (declare (dynamic-extent temp))
    ; this declaration is maybe bogus
    (dolist (seq sequences)
      (let ((len (length seq)))
        (declare (fixnum len))
        (if (< len maxcnt)(setq maxcnt len))))
    (dotimes (cnt maxcnt)
      (let ((args temp)(seqs sequences))
        (dotimes (i nargs)
          (let ((seq (%car seqs)))
            (cond ((listp seq)
                   (%rplaca seqs (%cdr seq))
                   (%rplaca args (%car seq)))
                  (t (%rplaca args (aref seq cnt)))))
          (setq args (%cdr args))
          (setq seqs (%cdr seqs))))
      (let ((res (apply function temp)))
        (cond ((consp rseq)
               (%rplaca rseq res)
               (setq rseq (%cdr rseq)))
              (t (setf (aref result-sequence cnt) res)))))
    (when (and (not (listp result-sequence))
               (array-has-fill-pointer-p result-sequence))
      (setf (fill-pointer result-sequence) maxcnt))
    result-sequence))
          
    
;;; Coerce:

#|
; don't know if this is always right
; It's almost never right: the "type-spec" could be something
; defined with DEFTYPE, whose last element (if it has one) has
; nothing to do with the "length" of the specified type.
(defun specifier-length (type-spec)
  (if (consp type-spec)
    (let ((len? (car (last type-spec))))
      (if (fixnump len?) len?))))
|#


(defun array-ctype-length (ctype)
  (if (typep ctype 'array-ctype)
    (let* ((dims (array-ctype-dimensions ctype)))
      (if (listp dims)
        (if (null (cdr dims))
          (let* ((dim0 (car dims)))
            (unless (eq dim0 '*) dim0)))))))




; from optimizer - just return object if type is OK


;If you change this, remember to change the transform.
(defun coerce (object output-type-spec)
  "Coerce the Object to an object of type Output-Type-Spec."
  (let* ((type (specifier-type output-type-spec)))
    (if (%typep object type)
      object
      (cond
        ((csubtypep type (specifier-type 'character))
         (character object))
        ((eq output-type-spec 'standard-char)
         (let ((char (character object)))
           (unless (standard-char-p char) (%err-disp $xcoerce object 'standard-char))
           char))
        ((eq output-type-spec 'compiled-function)
         (coerce-to-compiled-function object))
        ((csubtypep type (specifier-type 'function))
         (coerce-to-function-1 object))
        ((csubtypep type (specifier-type 'cons))
         (if object
           (coerce-to-list object)
           (report-bad-arg object 'cons)))
        ((csubtypep type (specifier-type 'list))
         (coerce-to-list object))
        ((csubtypep type (specifier-type 'string))
         (let ((length (array-ctype-length type)))
           (if (and length (neq length (length object)))
             (report-bad-arg (make-string length) `(string ,(length object)))))
         (coerce-to-uarray object #.(type-keyword-code :simple-string)
                           t))
        ((csubtypep type (specifier-type 'vector))
         (let ((length (array-ctype-length type)))
           (if (and length (neq length (length object)))
             (error 'invalid-subtype-error
                    :datum output-type-spec
                    :expected-type `(vector * ,(length object)))))
         (let* ((atype (simplify-vector-ctype type)))
           (unless (typep atype 'array-ctype)
             (error "Can't determine vector type of ~s" output-type-spec))
           (let* ((element-type (type-specifier (array-ctype-element-type atype))))
             (let ((length (array-ctype-length atype)))
               (if (and length (neq length (length object)))
                 (report-bad-arg (make-array length :element-type element-type)
                                 `(vector ,element-type ,(length object))))
               (coerce-to-uarray object (element-type-subtype element-type) t)))))
        ((csubtypep type (specifier-type 'array))
         (let* ((dims (array-ctype-dimensions type)))
           (when (consp dims)
             (when (not (null (cdr dims)))(error "~s is not a sequence type." output-type-spec))))
         (let ((length (array-ctype-length type)))
           (if (and length (neq length (length object)))
             (error "Length of ~s is not ~s." object length)))
         (coerce-to-uarray object (element-type-subtype (type-specifier 
                                                         (array-ctype-element-type type))) t))
        ((numberp object)
         (let ((res
                (cond
                  ((csubtypep type (specifier-type 'double-float))
                   (float object 1.0d0))
                  ((csubtypep type (specifier-type 'float))
                   (float object 1.0s0))                		
                  ((csubtypep type (specifier-type 'complex))
                   (coerce-to-complex object  (type-specifier type))))))
           (unless res                  ;(and res (%typep res type))
             (error "~S can't be coerced to type ~S." object output-type-spec))
           res))
        (t (error "~S can't be coerced to type ~S." object output-type-spec))))))

(defun %coerce-to-string (seq)
   (let* ((len (length seq))
          (string (make-string len)))
     (declare (fixnum len) (simple-base-string string))
     (if (typep seq 'list)
       (do* ((l seq (cdr l))
             (i 0 (1+ i)))
            ((null l) string)
         (declare (list l) ; we know that it's a proper list because LENGTH won
                  (fixnum i))
         (setf (schar string i) (car l)))
       (dotimes (i len string)
         (setf (schar string i) (aref seq i))))))

(defun %coerce-to-vector (seq subtype)
   (let* ((len (length seq))
          (vector (%alloc-misc len subtype)))
     (declare (fixnum len) (type (simple-array * (*)) vector))
     (if (typep seq 'list)
       (do* ((l seq (cdr l))
             (i 0 (1+ i)))
            ((null l) vector)
         (declare (list l) ; we know that it's a proper list because LENGTH won
                  (fixnum i))
         (setf (uvref vector i) (car l)))
       (dotimes (i len vector)
         (setf (uvref vector i) (aref seq i))))))

(defun %coerce-to-list (seq)
  (if (typep seq 'list)
    seq
    (collect ((result))
      (dotimes (i (length seq) (result))
        (result (aref seq i))))))




(defun coerce-to-complex (object  output-type-spec)
  (if (consp output-type-spec)
      (let ((type2 (cadr output-type-spec)))     
        (if (complexp object)
	    (complex (coerce (realpart object) type2)(coerce (imagpart object) type2))
	    (complex (coerce object type2) 0)))
      (complex object)))
        

(defun coerce-to-function-1 (thing)
  (if (functionp thing)
    thing
    (if (symbolp thing)
      (%function thing)
      (if (lambda-expression-p thing)
        (%make-function nil thing nil)
        (%err-disp $xcoerce thing 'function)))))

;;; Internal Frobs:
;(coerce object '<array-type>)
(defun coerce-to-uarray (object subtype simple-p)
  (if (typep object 'array)
    (if (and (or (not simple-p) (typep object 'simple-array))
             (or (null subtype) (eq (array-element-subtype object) subtype)))
      object
      ;Make an array of the same shape as object but different subtype..
      (%copy-array subtype object))
    (if (typep object 'list)
      (%list-to-uvector subtype object)
      (%err-disp $xcoerce object 'array))))

;(coerce object 'list)
(defun coerce-to-list (object)
  (seq-dispatch 
   object
   object
   (let* ((n (length object)))
     (declare (fixnum n))
     (multiple-value-bind (data offset) (array-data-and-offset object)
       (let* ((head (cons nil nil))
              (tail head))
         (declare (dynamic-extent head)
                  (cons head tail))
         (do* ((i 0 (1+ i))
               (j offset (1+ j)))
              ((= i n) (cdr head))
           (declare (fixnum i j))
           (setq tail (cdr (rplacd tail (cons (uvref data j) nil))))))))))
 

(defun %copy-array (new-subtype array)
  ;To be rewritten once make-array disentangled (so have a subtype-based entry
  ;point)
  (make-array (if (eql 1 (array-rank array))
                (length array)
                (array-dimensions array))
              :element-type (element-subtype-type new-subtype)
              :initial-contents array ;***** WRONG *****
              ))

(defun check-count (c)
  (if c
    (min (max (require-type c 'integer) 0) target::target-most-positive-fixnum)
    target::target-most-positive-fixnum))

;;; Delete:

(defun list-delete-1 (item list from-end test test-not start end count key 
                           &aux (temp list)  revp)
  (unless end (setq end target::target-most-positive-fixnum))
  (when (and from-end count)
    (let ((len (length temp)))
      (if (not (%i< start len))
        (return-from list-delete-1 temp))
      (setq temp (nreverse temp) revp t)
      (psetq end (%i- len start)
             start (%i- len (%imin len end)))))
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not)
                       (adjust-test-args item test test-not))
  (setq temp
        (if (or test key test-not)
          (list-delete-moderately-complex item temp start end count test test-not key)
          (list-delete-very-simple item temp start end count)))
   (if revp
    (nreverse temp)
    temp))


(defun list-delete-very-simple (item list start end count)
  (unless start (setq start 0))
  (unless end (setq end target::target-most-positive-fixnum))
  (setq count (check-count count))
  (do* ((handle (cons nil list))
        (splice handle)
        (numdeleted 0)
        (i 0 (1+ i)))
       ((or (eq i end) (null (%cdr splice)) (eq numdeleted count))
        (%cdr handle))
    (declare (fixnum i start end count numdeleted)  ; declare-type-free !!
             (dynamic-extent handle) 
             (list splice handle))
    (if (and (%i>= i start) (eq item (car (%cdr splice))))
        (progn
          (%rplacd splice (%cddr splice))
          (setq numdeleted (%i+ numdeleted 1)))
        (setq splice (%cdr splice)))))

(defun list-delete-moderately-complex (item list start end count test test-not key)
  (unless start (setq start 0))
  (unless end (setq end target::target-most-positive-fixnum))
  (setq count (check-count count))
  (do* ((handle (cons nil list))
        (splice handle)
        (numdeleted 0)
        (i 0 (1+ i)))
       ((or (= i end) (null (cdr splice)) (= numdeleted count))
        (cdr handle))
    (declare (fixnum i start end count numdeleted)
             (dynamic-extent handle)
             (list splice))
    (if (and (>= i start) (matchp2 item (cadr splice) test test-not key))
      (progn
        (rplacd splice (cddr splice))
        (setq numdeleted (1+ numdeleted)))
      (setq splice (cdr splice)))))

; The vector will be freshly consed & nothing is displaced to it,
; so it's legit to destructively truncate it.
; Likewise, it's ok to access its components with UVREF.

(defun simple-vector-delete (item vector test test-not key start end inc count
                                  &aux (length (length vector)) 
                                  subtype pos fill)
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not) (adjust-test-args item test test-not))
  (setq end (check-sequence-bounds vector start end))
  (setq fill start)
  (if (%i< inc 0) (psetq start (%i- end 1) end (%i- start 1)))
  (let* ((bv (make-array (the fixnum (length vector)) :element-type 'bit :Initial-element 0))
         offset)    
    (declare (dynamic-extent bv)
             (type (simple-array bit (*)) bv))
    (multiple-value-setq (vector offset)(array-data-and-offset vector))
    (setq subtype (typecode vector))
    (setq pos start)
    (loop
      (when (or (eq count 0) (eq pos end))
        (unless (eq pos end)
          (incf fill (abs (- pos end))))
        (return))
      (if (matchp2 item (uvref  vector (%i+ pos offset))
                   test test-not key)
        (progn (setf (aref bv pos) 1)
               (setq count (%i- count 1)))
        (setq fill (%i+ fill 1)))
      (setq pos (%i+ pos inc)))
    (when (%i< inc 0)
      (psetq start (%i+ end 1) end (%i+ start 1)))
    (let* ((tail (- length end))
           (size (+ fill tail))
           (new-vect (%alloc-misc size subtype))
           (fill-end fill))
      (declare (fixnum tail size))
      (when (neq 0 start)
        (dotimes (i start)
          (setf (uvref new-vect i) (uvref  vector (%i+ offset i)))
          ))
      (setq fill start)
      (setq pos start)
      (loop
        (if (eq fill fill-end) (return))
        (if (neq 1 (aref bv pos))
          (progn
            (setf (uvref new-vect fill) (uvref vector (%i+ offset pos)))
            (setq fill (%i+ fill 1))))
        (setq pos (%i+ pos 1)))
      (setq pos end)
      (loop
        (when (eq fill size) (return))
          (setf (uvref  new-vect fill) (uvref  vector (%i+ offset pos)))
          (setq fill (%i+ fill 1)
                pos (%i+ pos 1)))
      new-vect)))


; When a vector has a fill pointer & it can be "destructively modified" by adjusting
; that fill pointer.
(defun vector-delete (item vector test test-not key start end inc count
                           &aux (length (length vector)) pos fill val)
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not) (adjust-test-args item test test-not))
  (setq end (check-sequence-bounds vector start end))
  (if (%i< inc 0) (psetq start (%i- end 1) end (%i- start 1)))
  (setq fill (setq pos start))
  (loop
    (if (or (eq count 0) (eq pos end)) (return))
    (if (matchp2 item (setq val (aref vector pos)) test test-not key)
      (setq count (%i- count 1))
      (progn
        (if (neq fill pos) (setf (aref vector fill) val))
        (setq fill (%i+ fill inc))))
    (setq pos (%i+ pos inc)))
  (if (%i> fill pos) (psetq fill (%i+ pos 1) pos (%i+ fill 1)))
  (loop
    (if (eq pos length) (return))
    (setf (aref vector fill) (aref vector pos))
    (setq fill (%i+ fill 1) pos (%i+ pos 1)))
  (when (eq t (array-element-type vector))
    (let ((old-fill (fill-pointer vector))
          (i fill))
      (declare (fixnum i old-fill))
      (loop
        (when (>= i old-fill) (return))
        (setf (aref vector i) nil)
        (incf i))))
  (setf (fill-pointer vector) fill)
  vector)

(defun delete (item sequence &key from-end test test-not (start 0)
                    end count key)
  "Return a sequence formed by destructively removing the specified ITEM from
  the given SEQUENCE."
  (setq count (check-count count))
  (if sequence
    (seq-dispatch
     sequence
     (list-delete-1 item 
                  sequence 
                  from-end
                  test 
                  test-not
                  start 
                  end 
                  count
                  key)
     (if (array-has-fill-pointer-p sequence)
       (vector-delete item sequence test test-not key start end (if from-end -1 1) count)
       (simple-vector-delete item
                            sequence
                             test test-not key start end (if from-end -1 1) count)))))

(defun delete-if (test sequence &key from-end (start 0)                       
                       end count key)
  "Return a sequence formed by destructively removing the elements satisfying
  the specified PREDICATE from the given SEQUENCE."
  (delete test sequence
          :test #'funcall
          :from-end from-end 
          :start start 
          :end end 
          :count count 
          :key key))

(defun delete-if-not (test sequence &key from-end (start 0) end count key)
  "Return a sequence formed by destructively removing the elements not
  satisfying the specified PREDICATE from the given SEQUENCE."
  (delete test sequence 
          :test-not #'funcall 
          :from-end from-end 
          :start start 
          :end end 
          :count count 
          :key key))



;;; Remove:

(defun list-remove (item sequence test test-not start end count from-end key)
  (collect ((new))
    (dotimes (i start)
      (new (pop sequence)))
    (let* ((i start)
           (removed 0))
      (declare (fixnum i removed))
      (if key
        (cond (test
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (funcall test item (funcall key element))
                     (incf removed)
                     (new element)))
                 (incf i)))
              (test-not
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (not (funcall test-not item (funcall key element)))
                     (incf removed)
                     (new element)))
                 (incf i)))
              (t
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (eql item (funcall key element))
                     (incf removed)
                     (new element)))
                 (incf i))))
        (cond (test
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (funcall test item element)
                     (incf removed)
                     (new element)))
                 (incf i)))
              (test-not
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (not (funcall test-not item element))
                     (incf removed)
                     (new element)))
                 (incf i)))
              (t
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (eql item element)
                     (incf removed)
                     (new element)))
                 (incf i)))))
      (do* ()
           ((null sequence)
            (if from-end
              (nreverse (new))
              (new)))
        (new (pop sequence))))))

(defun list-remove-conditional (sequence test test-not start end count from-end key)
  (collect ((new))
    (dotimes (i start)
      (new (pop sequence)))
    (let* ((i start)
           (removed 0))
      (declare (fixnum i removed))
      (if key
        (cond (test
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (funcall test (funcall key element))
                     (incf removed)
                     (new element)))
                 (incf i)))
              (test-not
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (not (funcall test-not (funcall key element)))
                     (incf removed)
                     (new element)))
                 (incf i))))
        (cond (test
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (funcall test element)
                     (incf removed)
                     (new element)))
                 (incf i)))
              (test-not
               (do* ()
                    ((or (= i end) (= removed count)))
                 (let* ((element (pop sequence)))
                   (if (not (funcall test-not element))
                     (incf removed)
                     (new element)))
                 (incf i)))))
      (do* ()
           ((null sequence)
            (if from-end
              (nreverse (new))
              (new)))
        (new (pop sequence))))))




(defun remove (item sequence &key from-end test test-not (start 0)
                    end count key)
  "Return a copy of SEQUENCE with elements satisfying the test (default is
   EQL) with ITEM removed."
  (if (or (eq test 'identity)
          (eq test #'identity))
    (setq key nil))
  (setq count (check-count count))

  (seq-dispatch
   sequence
   (let* ((len (length sequence))
          (reversed nil))
     (setq end (check-sequence-bounds sequence start end len))
     (when (and (< count len) from-end)
       (psetq sequence (reverse sequence)
              reversed t
              start (- len end)
              end (- len start)))
     (if test
       (if test-not
         (error "Both ~s and ~s keywords supplied" :test :test-not)
         (setq test (coerce-to-function test)))
       (if test-not
         (setq test-not (coerce-to-function test-not))
         (setq test #'eql)))
     (list-remove item
                  sequence
                  test 
                  test-not
                  start 
                  end
                  count
                  reversed
                  key))
  (simple-vector-delete item
                        sequence
                        test
                        test-not
                        key
                        start
                        end
                        (if from-end -1 1)
                        count)))




(defun remove-if (test sequence &key from-end (start 0)
                       end count key)
  "Return a copy of sequence with elements such that predicate(element)
   is non-null removed"
  (setq count (check-count count))
  (seq-dispatch
   sequence
   (let* ((len (length sequence))
          (reversed nil))
     (setq end (check-sequence-bounds sequence start end len))
     (when (and (< count len) from-end)
       (psetq sequence (reverse sequence)
              reversed t
              start (- len end)
              end (- len start)))
     (list-remove-conditional sequence
                              (coerce-to-function test )
                              nil
                              start 
                              end
                              count
                              reversed
                              key))
   (remove test sequence
           :test #'funcall
           :from-end from-end
           :start start
           :end end
           :count count
           :key key)))

(defun remove-if-not (test sequence &key from-end (start 0)
                           end count key)
  "Return a copy of sequence with elements such that predicate(element)
   is null removed"
  (setq count (check-count count))
  (seq-dispatch
   sequence
   (let* ((len (length sequence))
          (reversed nil))
     (setq end (check-sequence-bounds sequence start end len))
     (when (and (< count len) from-end)
       (psetq sequence (reverse sequence)
              reversed t
              start (- len end)
              end (- len start)))
     (list-remove-conditional sequence
                              nil
                              (coerce-to-function test)
                              start 
                              end
                              count
                              reversed
                              key))
   (remove test sequence
           :test-not #'funcall
           :from-end from-end
           :start start
           :end end
           :count count
           :key key)))

;;; Remove-Duplicates:

;;; Remove duplicates from a list. If from-end, remove the later duplicates,
;;; not the earlier ones. Thus if we check from-end we don't copy an item
;;; if we look into the already copied structure (from after :start) and see
;;; the item. If we check from beginning we check into the rest of the 
;;; original list up to the :end marker (this we have to do by running a
;;; do loop down the list that far and using our test.
; test-not is typically NIL, but member doesn't like getting passed NIL
; for its test-not fn, so I special cased the call to member. --- cfry

(defun remove-duplicates (sequence &key (test #'eql) test-not (start 0) 
      from-end end key)
  "The elements of SEQUENCE are compared pairwise, and if any two match,
   the one occurring earlier is discarded, unless FROM-END is true, in
   which case the one later in the sequence is discarded. The resulting
   sequence is returned.

   The :TEST-NOT argument is deprecated."
  (setq end (check-sequence-bounds sequence start end))
  (delete-duplicates (copy-seq sequence) :from-end from-end :test test
                     :test-not test-not :start start :end end :key key))

;;; Delete-Duplicates:

(defparameter *delete-duplicates-hash-threshold*  200)

(defun list-delete-duplicates* (list test test-not key from-end start end)
  ;;(%print "test:" test "test-not:" test-not "key:" key)
  (let* ((len (- end start))
	 (handle (cons nil list))
	 (previous (nthcdr start handle)))
    (declare (dynamic-extent handle))
    (if (and (> len *delete-duplicates-hash-threshold*)
	     (or (eq test 'eq) (eq test 'eql) (eq test 'equal) (eq test 'equalp)
		 (eq test #'eq) (eq test #'eql) (eq test #'equal) (eq test #'equalp)))
      (let ((hash (make-hash-table :size len :test test :shared nil)))
        (loop for i from start below end as obj in (cdr previous)
          do (incf (gethash (funcall key obj) hash 0)))
        (loop for i from start below end while (cdr previous)
          do (let* ((current (cdr previous))
                    (obj (car current))
                    (obj-key (funcall key obj)))
               (if (if from-end
                     ;; Keep first ref
                     (prog1 (gethash obj-key hash) (setf (gethash obj-key hash) nil))
                     ;; Keep last ref
                     (eql (decf (gethash obj-key hash)) 0))
                 (setq previous current)
                 (rplacd previous (cdr current))))))
      (do ((current (cdr previous) (cdr current))
           (index start (1+ index)))
          ((or (= index end) (null current)))
        ;;(%print "outer loop top current:" current "previous:" previous)
        (if (do ((x (if from-end 
                      (nthcdr (1+ start) handle)
                      (cdr current))
                    (cdr x))
                 (i (1+ index) (1+ i)))
                ((or (null x) 
                     (and (not from-end) (= i end)) 
                     (eq x current)) 
                 nil)
              ;;(%print "inner loop top x:" x "i:" i)
              (if (list-delete-duplicates*-aux current x test test-not key)
                (return t)))
          (rplacd previous (cdr current))
          (setq previous (cdr previous)))))
    (cdr handle)))

(defun list-delete-duplicates*-aux (current x test test-not key)
  (if test-not
    (not (funcall test-not 
                  (funcall key (car current))
                  (funcall key (car x))))
    (funcall test 
             (funcall key (car current)) 
             (funcall key (car x)))))


(defun vector-delete-duplicates* (vector test test-not key from-end start end 
					 &optional (length (length vector)))
  (declare (vector vector))
  (let* ((len (- end start))
	 (index start)
	 (jndex start))
    (if (and (not test-not)
	     (> len *delete-duplicates-hash-threshold*)
	     (or (eq test 'eq) (eq test 'eql) (eq test 'equal) (eq test 'equalp)
		 (eq test #'eq) (eq test #'eql) (eq test #'equal) (eq test #'equalp)))
	(let ((hash (make-hash-table :size len :test test :shared nil)))
	  (loop for i from start below end as obj = (aref vector i)
	     do (incf (gethash (funcall key obj) hash 0)))
	  (loop while (< index end) as obj = (aref vector index) as obj-key = (funcall key obj)
	     do (incf index)
	     do (when (if from-end
			  (prog1 (gethash obj-key hash) (setf (gethash obj-key hash) nil))
			  (eql (decf (gethash obj-key hash)) 0))
		  (aset vector jndex obj)
		  (incf jndex))))
	(loop while (< index end) as obj = (aref vector index)
	   do (incf index)
	   do (unless (position (funcall key obj) vector :key key
				:start (if from-end start index) :test test
				:end (if from-end jndex end) :test-not test-not)
		(aset vector jndex obj)
		(incf jndex))))
    (do ((index index (1+ index))	; copy the rest of the vector
	 (jndex jndex (1+ jndex)))
	((= index length)
	 (setq vector (shrink-vector vector jndex)))
      (aset vector jndex (aref vector index)))))


(defun delete-duplicates (sequence &key (test #'eql) test-not (start 0) from-end end key)
  "The elements of SEQUENCE are examined, and if any two match, one is
   discarded.  The resulting sequence, which may be formed by destroying the
   given sequence, is returned.
   Sequences of type STR have a NEW str returned."
  (setq end (check-sequence-bounds sequence start end))
  (unless key (setq key #'identity))
  (seq-dispatch sequence
    (if sequence
      (list-delete-duplicates* sequence test test-not key from-end start end))
    (vector-delete-duplicates* sequence test test-not key from-end start end)))

(defun list-substitute* (pred new list start end count key 
                              test test-not old)
  ;(print-db pred new list start end count key test test-not old)
  (let* ((result (list nil))
         elt
         (splice result)
         (list list))           ; Get a local list for a stepper.
    (do ((index 0 (1+ index)))
        ((= index start))
      (setq splice (cdr (rplacd splice (list (car list)))))
      (setq list (cdr list)))
    (do ((index start (1+ index)))
        ((or (and end (= index end)) (null list) (= count 0)))
      (setq elt (car list))
      (setq splice
            (cdr (rplacd splice
                         (list
                          (cond ((case pred
                                   (normal
                                    (if test-not
                                      (not (funcall test-not  old
                                                    ;fry mod to slisp, which had arg order of OLD and ELT reversed.
                                                    (funcall key elt)))
                                      (funcall test old
                                               (funcall key elt))))
                                   (if (funcall test (funcall key elt)))
                                   (if-not (not (funcall test 
                                                         (funcall key elt)))))
                                 (setq count (1- count))
                                 new)
                                (t elt))))))
      (setq list (cdr list)))
    (do ()
        ((null list))
      (setq splice (cdr (rplacd splice (list (car list)))))
      (setq list (cdr list)))
    (cdr result)))

;;; Replace old with new in sequence moving from left to right by incrementer
;;; on each pass through the loop. Called by all three substitute functions.
(defun vector-substitute* (pred new sequence incrementer left right length
                                start end count key test test-not old)
  (let ((result (make-sequence-like sequence length))
        (index left))
    (do ()
        ((= index start))
      (aset result index (aref sequence index))
      (setq index (+ index incrementer)))
    (do ((elt))
        ((or (= index end) (= count 0)))
      (setq elt (aref sequence index))
      (aset result index 
            (cond ((case pred
                     (normal
                      (if test-not
                        (not (funcall test-not old (funcall key elt))) ;cfry mod
                        (funcall test old (funcall key elt)))) ;cfry mod
                     (if (funcall test (funcall key elt)))
                     (if-not (not (funcall test (funcall key elt)))))
                   (setq count (1- count))
                   new)
                  (t elt)))
      (setq index (+ index incrementer)))
    (do ()
        ((= index right))
      (aset result index (aref sequence index))
      (setq index (+ index incrementer)))
    result))

;;; Substitute:

(defun substitute (new old sequence &key from-end (test #'eql) test-not
                       (start 0) count
                       end (key #'identity))
  "Return a sequence of the same kind as SEQUENCE with the same elements,
  except that all elements equal to OLD are replaced with NEW. See manual
  for details."
  (setq count (check-count count))
  (let ((length (length sequence))        )
    (setq end (check-sequence-bounds sequence start end))
    (seq-dispatch 
     sequence
     (if from-end
       (nreverse (list-substitute* 'normal new (reverse sequence) (- length end)
                                   (- length start) count key test test-not old))
       (list-substitute* 'normal new sequence start end count key test test-not
                         old))
     (if from-end
       (vector-substitute* 'normal new sequence -1 (1- length) -1 length 
                           (1- end) (1- start) count key test test-not old)
       (vector-substitute* 'normal new sequence 1 0 length length
                           start end count key test test-not old)))))


(defun substitute-if (new test sequence &key from-end (start 0)
                          (end (length sequence))
                          count (key #'identity))
  "Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements satisfying the PRED are replaced with NEW. See
  manual for details."
  (substitute new test sequence
              :from-end from-end
              :test #'funcall
              :start start
              :end end
              :from-end from-end
              :count count
              :key key))

(defun substitute-if-not (new test sequence &key from-end (start 0)
                              (end (length sequence))
                              count (key #'identity))
  "Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements not satisfying the PRED are replaced with NEW.
  See manual for details."
  (substitute new test sequence
              :from-end from-end
              :test-not #'funcall
              :start start
              :end end
              :from-end from-end
              :count count
              :key key))

;;; NSubstitute:

(defun nsubstitute (new old sequence &key from-end (test #'eql) test-not 
                        end 
                        (count target::target-most-positive-fixnum) (key #'identity) (start 0))
  "Return a sequence of the same kind as SEQUENCE with the same elements
  except that all elements equal to OLD are replaced with NEW. The SEQUENCE
  may be destructively modified. See manual for details."
  (setq count (check-count count))
  (let ((incrementer 1)
	(length (length sequence)))
    (setq end (check-sequence-bounds sequence start end))
    (seq-dispatch
     sequence
      (if from-end
        (nreverse (nlist-substitute*
                   new old (nreverse (the list sequence))
                   test test-not 
                   (- length end) 
                   (- length start)
                   count key))
        (nlist-substitute* new old sequence
                           test test-not start end count key))
      (progn 
        (if from-end
          (psetq start (1- end)
                 end (1- start)
                 incrementer -1))
        (nvector-substitute* new old sequence incrementer
                             test test-not start end count key)))))

(defun nlist-substitute* (new old sequence test test-not start end count key)
  (do ((list (nthcdr start sequence) (cdr list))
       (index start (1+ index)))
      ((or (and end (= index end)) (null list) (= count 0)) sequence)
    (when (if test-not
            (not (funcall test-not  old (funcall key (car list)))) ;cfry mod
            (funcall test  old (funcall key (car list)))) ;cfry mod
      (rplaca list new)
      (setq count (1- count)))))

(defun nvector-substitute* (new old sequence incrementer
                                test test-not start end count key)
  (do ((index start (+ index incrementer)))
      ((or (= index end) (= count 0)) sequence)
    (when (if test-not
            (not (funcall test-not  old (funcall key (aref sequence index))))
            ;above cfry mod. both order of argss to test-not and paren error
            ; between the funcall key and the funcall test-not
            (funcall test old (funcall key (aref sequence index)))) ;cfry mod
      (aset sequence index new)
      (setq count (1- count)))))

;;; NSubstitute-If:

(defun nsubstitute-if (new test sequence &key from-end (start 0)
                           end  
                           (count target::target-most-positive-fixnum) (key #'identity))
  "Return a sequence of the same kind as SEQUENCE with the same elements
   except that all elements satisfying the PRED are replaced with NEW. 
   SEQUENCE may be destructively modified. See manual for details."
  (nsubstitute new test sequence
               :from-end from-end
               :test #'funcall
               :start start
               :end end
               :count count
               :key key))


;;; NSubstitute-If-Not:

(defun nsubstitute-if-not (new test sequence &key from-end (start 0)
                               end (count target::target-most-positive-fixnum) (key #'identity))
  "Return a sequence of the same kind as SEQUENCE with the same elements
   except that all elements not satisfying the TEST are replaced with NEW.
   SEQUENCE may be destructively modified. See manual for details."
  (nsubstitute new test sequence
                 :from-end from-end
                 :test-not #'funcall
                 :start start
                 :end end
                 :count count
                 :key key))


;;; Position:

(defun list-position/find-1 (eltp item list from-end test test-not start end key &aux hard)
  ;;if eltp is true, return element, otherwise return position
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not)
                       (adjust-test-args item test test-not))
  (setq end (check-sequence-bounds list start end)
        hard (or test key test-not))
  (if from-end
    (if hard
      (list-position/find-from-end-complex eltp item list start end test test-not key)
      (list-position/find-from-end-simple eltp item list start end))
    (if hard
      (list-position/find-complex eltp item list start end test test-not key)
      (list-position/find-simple eltp item list start end))))

(defun position (item sequence &key from-end test test-not (start 0) end key)
  (if sequence
    (seq-dispatch 
     sequence
     (list-position/find-1 nil item sequence from-end test test-not start end key)
     (vector-position-1 item sequence from-end test test-not start end key))))

;Is it really necessary for these internal functions to take keyword args?
(defun list-position/find (eltp item list &key from-end test test-not (start 0) end key &aux hard)
  ;;if eltp is true, return element, otherwise return position
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not)
                       (adjust-test-args item test test-not))
  (setq end (check-sequence-bounds list start end)
        hard (or test key test-not))
  (if from-end
    (if hard
      (list-position/find-from-end-complex eltp item list start end test test-not key)
      (list-position/find-from-end-simple eltp item list start end))
    (if hard
      (list-position/find-complex eltp item list start end test test-not key)
      (list-position/find-simple eltp item list start end))))

;;; make these things positional



;;; add a simple-vector case

(defun vector-position-1 (item vector from-end test test-not start end key
                        &aux (inc (if from-end -1 1)) pos)
  (setq end (check-sequence-bounds vector start end))
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not) (adjust-test-args item test test-not))
  (if from-end (psetq start (%i- end 1) end (%i- start 1)))
  (setq pos start)
  (if (simple-vector-p vector)
    (locally (declare (type simple-vector vector)
                      (optimize (speed 3) (safety 0)))
      (loop
        (if (eq pos end) (return))
        (if (matchp2 item (aref vector pos) test test-not key) (return pos))
        (setq pos (%i+ pos inc))))
    (loop
      (if (eq pos end) (return))
      (if (matchp2 item (aref vector pos) test test-not key) (return pos))
      (setq pos (%i+ pos inc)))))

(defun list-position/find-simple (eltp item list start end &aux (pos 0))
  (loop
    (if (or (eq pos start) (null list))
      (return)
      (setq list (cdr list) pos (%i+ pos 1))))
  (loop
    (if (and list (neq end pos))
      (if (eq item (car list))
        (return (if eltp item pos))
        (setq list (%cdr list) pos (%i+ pos 1)))
      (return))))

(defun list-position/find-complex (eltp item list start end test test-not key &aux (pos 0))
  (loop
    (if (or (eq pos start) (null list))
      (return)
      (setq list (cdr list) pos (%i+ pos 1))))
  (loop
    (if (and list (neq end pos))
      (progn
        (if (matchp2 item (car list) test test-not key)
          (return (if eltp (%car list) pos))
          (setq list (%cdr list) pos (%i+ pos 1))))
      (return))))

(defun list-position/find-from-end-simple (eltp item list start end &aux (pos 0) ret)
  (loop
    (if (or (eq pos start) (null list))
      (return)
      (setq list (cdr list) pos (%i+ pos 1))))
  (loop
    (if (and list (neq end pos))
      (progn
        (if (eq item (car list)) (setq ret pos))
        (setq list (%cdr list) pos (%i+ pos 1)))
      (return (if eltp (if ret item) ret)))))

(defun list-position/find-from-end-complex (eltp item list start end test test-not key 
                                            &aux (pos 0) ret val)
  (loop
    (if (or (eq pos start) (null list))
      (return)
      (setq list (cdr list) pos (%i+ pos 1))))
  (loop
    (if (and list (neq end pos))
      (progn
        (if (matchp2 item (setq val (car list)) test test-not key)
          (setq ret (if eltp val pos)))
        (setq list (%cdr list) pos (%i+ pos 1)))
      (return ret))))

(defun vector-position (item vector &key from-end test test-not (start 0) end key
                        &aux (inc (if from-end -1 1)) pos)
  (setq end (check-sequence-bounds vector start end))
  (setq key (adjust-key key))
  (multiple-value-setq (test test-not) (adjust-test-args item test test-not))
  (if from-end (psetq start (%i- end 1) end (%i- start 1)))
  (setq pos start)
  (loop
    (if (eq pos end) (return))
    (if (matchp2 item (aref vector pos) test test-not key) (return pos))
    (setq pos (%i+ pos inc))))

;;; Position-if:

(defun position-if (test sequence &key from-end (start 0) end key)
  (position test sequence
            :test #'funcall
            :from-end from-end
            :start start
            :end end
            :key key))


;;; Position-if-not:

(defun position-if-not (test sequence &key from-end (start 0) end key)
  (position test sequence
            :test-not #'funcall
            :from-end from-end
            :start start
            :end end
            :key key))

;;; Count:

(defun vector-count-from-start (test item sequence start end key)
  (declare (fixnum start end))
  (do* ((index start (1+ index))
        (count 0))
       ((= index end) count)
    (declare (fixnum index count))
    (when (funcall test item  (funcall key (aref sequence index)))
      (incf count))))

(defun vector-count-from-end (test item sequence start end key)
  (declare (fixnum start end))
  (do* ((index (1- end) (1- index))
        (count 0)
        (limit (1- start)))
       ((= index limit) count)
    (declare (fixnum index count limit))
    (when (funcall test item (funcall key (aref sequence index)))
      (incf count))))

(defun vector-count-not-p-from-start (test-not item sequence start end key)
  (declare (fixnum start end))
  (do* ((index start (1+ index))
        (count 0))
       ((= index end) count)
    (declare (fixnum index count))
    (unless (funcall test-not item (funcall key (aref sequence index)))
      (incf count))))

(defun vector-count-not-p-from-end (test-not item sequence start end key)
  (declare (fixnum start end))
  (do* ((index (1- end) (1- index))
        (count 0)
        (limit (1- start)))
       ((= index limit) count)
    (declare (fixnum index count limit))
    (unless (funcall test-not item (funcall key (aref sequence index)))
      (incf count))))

(defun list-count-from-start (test item sequence start end key)
  (declare (fixnum start end) (list sequence))
  (do* ((seq (nthcdr start sequence) (cdr seq))
        (element (car seq) (car seq))
        (index start (1+ index))
        (count 0))
       ((or (= index end) (null seq)) count)
    (declare (fixnum index count) (list seq))
    (when (funcall test item (funcall key element))
      (incf count))))

(defun list-count-from-end (test item sequence start end key)
  (declare (fixnum start end))
  (let* ((len (length sequence)))
    (declare (fixnum len))
    (list-count-from-start test item (reverse sequence) (- len end) (- len start) key)))

(defun list-count-not-p-from-start (test-not item sequence start end key)
  (declare (fixnum start end) (list sequence))
  (do* ((seq (nthcdr start sequence) (cdr seq))
        (element (car seq) (car seq))
        (index start (1+ index))
        (count 0))
       ((or (= index end) (null seq)) count)
    (declare (fixnum index count) (list seq))
    (unless (funcall test-not item  (funcall key element))
      (incf count))))

(defun list-count-not-p-from-end (test-not item sequence start end key)
  (declare (fixnum start end))
  (let* ((len (length sequence)))
    (declare (fixnum len))
    (list-count-not-p-from-start test-not item (reverse sequence) (- len end) (- len start) key)))

(defun count (item sequence &key from-end (test #'eql testp)
                   (test-not nil notp) (start 0) end key)
  "Return the number of elements in SEQUENCE satisfying a test with ITEM,
   which defaults to EQL."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key
    (setq key #'identity))
  (setq end (check-sequence-bounds sequence start end))
  (if sequence
    (seq-dispatch
     sequence
     (if notp
       (if from-end
         (list-count-not-p-from-end test-not item  sequence start end key)
         (list-count-not-p-from-start test-not item sequence start end key))
       (if from-end
         (list-count-from-end test item sequence start end key)
         (list-count-from-start test item sequence start end key)))
     (if notp
       (if from-end
         (vector-count-not-p-from-end test-not item sequence start end key)
         (vector-count-not-p-from-start test-not item sequence start end key))
       (if from-end
         (vector-count-from-end test item sequence start end key)
         (vector-count-from-start test item sequence start end key))))
    0))


;;; Count-if:

(defun count-if (test sequence &key from-end (start 0) end key)
  "Return the number of elements in SEQUENCE satisfying PRED(el)."
  (count test sequence
         :test #'funcall
         :from-end from-end
         :start start
         :end end
         :key key))

;;; Count-if-not:

(defun count-if-not (test sequence &key from-end (start 0) end key)
  "Return the number of elements in SEQUENCE not satisfying TEST(el)."
  (count test sequence
         :test-not #'funcall
         :from-end from-end
         :start start
         :end end
         :key key))


;;; Find:

(defun find (item sequence &key from-end test test-not (start 0) end key &aux temp)
  (if sequence
    (seq-dispatch
     sequence
     (list-position/find-1 t item sequence from-end test test-not start end key)
     (if (setq temp (vector-position-1 item sequence from-end test test-not start end key))
       (aref sequence temp)))))

(defun find-if (test sequence &key from-end (start 0) end key)
  (find test sequence
        :test #'funcall
        :from-end from-end
        :start start
        :end end
        :key key))

(defun find-if-not (test sequence &key from-end (start 0) end key)
  (find test sequence
        :test-not #'funcall
        :from-end from-end
        :start start
        :end end
        :key key))


;;; Mismatch:

(defun mismatch (seq1 seq2 &key (from-end nil)
                                  (test #'eql)
                                  (test-not nil)
                                  (key #'identity)
                                  (start1 0)
                                  (start2 0)
                                  (end1 nil)
                                  (end2 nil)
                             &aux (length1 (length seq1))
                                  (length2 (length seq2))
                                  (vectorp1 (vectorp seq1))
                                  (vectorp2 (vectorp seq2)))
  "The specified subsequences of SEQUENCE1 and SEQUENCE2 are compared
   element-wise. If they are of equal length and match in every element, the
   result is NIL. Otherwise, the result is a non-negative integer, the index
   within SEQUENCE1 of the leftmost position at which they fail to match; or,
   if one is shorter than and a matching prefix of the other, the index within
   SEQUENCE1 beyond the last position tested is returned. If a non-NIL
   :FROM-END argument is given, then one plus the index of the rightmost
   position in which the sequences differ is returned."
  ;seq type-checking is done by length
  ;start/end type-cheking is done by <= (below)
  ;test/key type-checking is done by funcall
  ;no check for both test and test-not
  (or end1 (setq end1 length1))
  (or end2 (setq end2 length2))
  (unless (and (<= start1 end1 length1)
               (<= start2 end2 length2))
    (error "Sequence arg out of range"))
  (unless vectorp1
    (setq seq1 (nthcdr start1 seq1))
    (if from-end
      (do* ((s1 ())
            (i start1 (1+ i)))
           ((= i end1) (setq seq1 s1))
        (push (pop seq1) s1))))
  (unless vectorp2
    (setq seq2 (nthcdr start2 seq2))
    (if from-end
      (do* ((s2 ())
            (i start2 (1+ i)))
           ((= i end2) (setq seq2 s2))
        (push (pop seq2) s2))))
  (when test-not (setq test test-not))
  (if from-end
      ;from-end
      (let* ((count1 end1)
             (count2 end2)
             (elt1)
             (elt2))
        (loop
          (if (or (eq count1 start1)
                  (eq count2 start2))
              (return-from mismatch
                           (if (and (eq count1 start1)
                                    (eq count2 start2))
                               nil
                               count1)))
          
          (setq count1 (%i- count1 1)
                count2 (%i- count2 1))

          (setq elt1 (funcall key (if vectorp1
                                      (aref seq1 count1)
                                      (prog1
                                        (%car seq1)
                                        (setq seq1 (%cdr seq1)))))
                elt2 (funcall key (if vectorp2
                                      (aref seq2 count2)
                                      (prog1
                                        (%car seq2)
                                        (setq seq2 (%cdr seq2))))))

          (when (if test-not
                    (funcall test elt1 elt2)
                    (not (funcall test elt1 elt2)))
            (return-from mismatch (%i+ count1 1)))))
      ;from-start
      (let* ((count1 start1)
             (count2 start2)
             (elt1)
             (elt2))
        (loop
          (if (or (eq count1 end1)
                  (eq count2 end2))
              (return-from mismatch
                           (if (and (eq count1 end1)
                                    (eq count2 end2))
                               nil
                               count1)))
          (setq elt1 (funcall key (if vectorp1
                                      (aref seq1 count1)
                                      (prog1
                                        (%car seq1)
                                        (setq seq1 (%cdr seq1)))))
                elt2 (funcall key (if vectorp2
                                      (aref seq2 count2)
                                      (prog1
                                        (%car seq2)
                                        (setq seq2 (%cdr seq2))))))
          
          (when (if test-not
                    (funcall test elt1 elt2)
                    (not (funcall test elt1 elt2)))
            (return-from mismatch count1)) 
          (setq count1 (%i+ count1 1)
                count2 (%i+ count2 1))
          
          ))))


;;; Search comparison functions:

(eval-when (:execute :compile-toplevel)
  
  ;;; Compare two elements
  
  (defmacro xcompare-elements (elt1 elt2)
    `(if (not key)
       (if test-not
         (not (funcall test-not ,elt1 ,elt2))
         (funcall test ,elt1 ,elt2))
       (let* ((e1 (funcall key ,elt1))
              (e2 (funcall key ,elt2)))
         (if test-not
           (not (funcall test-not  e1 e2))
           (funcall test e1 e2)))))  
  
  (defmacro vector-vector-search (sub main)
    `(let ((first-elt (aref ,sub start1))
           (last-one nil))
       (do* ((index2 start2 (1+ index2))
             (terminus (%i- end2 (%i- end1 start1))))
            ((> index2 terminus))
         (declare (fixnum index2 terminus))
         (if (xcompare-elements first-elt (aref ,main index2))
           (if (do* ((subi1 (1+ start1)(1+ subi1))
                     (subi2 (1+ index2) (1+ subi2)))
                    ((eq subi1 end1) t)
                 (declare (fixnum subi1 subi2))
                 (if (not (xcompare-elements (aref ,sub subi1) (aref ,main subi2)))
                   (return nil)))
             (if from-end
               (setq last-one index2)
               (return-from search index2)))))
       last-one))

  (defmacro list-list-search (sub main)
    `(let* ((sub-sub (nthcdr start1 ,sub))
            (first-elt (%car sub-sub))
            (last-one nil))
       (do* ((index2 start2 (1+ index2))
             (sub-main (nthcdr start2 ,main) (%cdr sub-main))
             (terminus (%i- end2 (%i- end1 start1))))
            ((> index2 terminus))
         (declare (fixnum index2 terminus))
         (if (xcompare-elements first-elt (car sub-main))
           (if (do* ((ss (%cdr sub-sub) (%cdr ss))
		     (pos (1+ start1) (1+ pos))
                     (sm (%cdr sub-main) (cdr sm)))
                    ((or (null ss) (= pos end1))  t)
		 (declare (fixnum pos))
                 (if (not (xcompare-elements (%car ss) (%car sm)))
                     (return nil)))
              (if from-end
               (setq last-one index2)
               (return-from search index2)))))
       last-one))
  
  (defmacro list-vector-search (sub main)
    `(let* ((sub-sub (nthcdr start1 ,sub))
              (first-elt (%car sub-sub))
              (last-one nil))
         (do* ((index2 start2 (1+ index2))
               (terminus (%i- end2 (%i- end1 start1))))
              ((> index2 terminus))
           (declare (fixnum index2 terminus))
           (if (xcompare-elements first-elt (aref ,main index2))
             (if (do* ((ss (%cdr sub-sub) (%cdr ss))
		       (pos (1+ start1) (1+ pos))
                       (subi2 (1+ index2) (1+ subi2)))
                      ((or (null ss) (= pos end1))  t)
                   (declare (fixnum subi2 pos))
                   (if (not (xcompare-elements (%car ss) (aref ,main subi2)))
                     (return nil)))
               (if from-end
                 (setq last-one index2)
                 (return-from search index2)))))
         last-one))

  (defmacro vector-list-search (sub main)
    `(let ((first-elt (aref ,sub start1))
           (last-one nil))
       (do* ((index2 start2 (1+ index2))
             (sub-main (nthcdr start2 ,main) (%cdr sub-main))
             (terminus (%i- end2 (%i- end1 start1))))
            ((> index2 terminus))
         (declare (fixnum index2 terminus))
         (if (xcompare-elements first-elt (car sub-main))
           (if (do* ((subi1 (1+ start1)(1+ subi1))
                     (sm (%cdr sub-main) (cdr sm)))
                    ((eq subi1 end1) t)
                 (declare (fixnum subi1))
                 (if (not (xcompare-elements (aref ,sub subi1) (car sm)))
                   (return nil)))
             (if from-end
               (setq last-one index2)
               (return-from search index2)))))
       last-one))
                 
    
  )



(defun search (sequence1 sequence2 &key from-end (test #'eql) test-not 
                          (start1 0) end1 (start2 0) end2 (key #'identity))
  (setq end1 (check-sequence-bounds sequence1 start1 end1))
  (setq end2 (check-sequence-bounds sequence2 start2 end2))
  (setq key (adjust-key key))
  (locally (declare (fixnum start1 end1 start2 end2))
    (if (eq 0 (%i- end1 start1))(if from-end end2 start2)
    (seq-dispatch sequence1
                  (seq-dispatch sequence2
                                (list-list-search sequence1 sequence2)
                                (list-vector-search sequence1 sequence2))
                  (seq-dispatch sequence2
                                (vector-list-search sequence1 sequence2)
                                (vector-vector-search sequence1 sequence2))))))

(defun make-string (size &key (initial-element () initial-element-p) (element-type 'character element-type-p))
  "Given a character count and an optional fill character, makes and returns
   a new string COUNT long filled with the fill character."
  (declare (optimize (speed 1) (safety 1)))
  (when (and initial-element-p (not (typep initial-element 'character)))
    (report-bad-arg initial-element 'character))
  (when (and element-type-p
             (not (or (member element-type '(character base-char standard-char))
                      (subtypep element-type 'character))))
    (error ":element-type ~S is not a subtype of CHARACTER" element-type))
  (if initial-element-p
      (make-string size :element-type 'base-char :initial-element initial-element)
      (make-string size :element-type 'base-char)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/sequences.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/setf-runtime.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode: Lisp; Package: CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;
; setf-runtime.lisp - runtime support for setf expressions

(in-package "CCL")

(defun set-cadr (list new-value)
  (set-car (cdr list) new-value))

(defun set-cdar (list new-value)
  (set-cdr (car list) new-value))

(defun set-caar (list new-value)
  (set-car (car list) new-value))

(defun set-cddr (list new-value)
  (set-cdr (cdr list) new-value))

(defun %set-nthcdr (index list new-value)
  "If INDEX is 0, just return NEW-VALUE."
  (if (not (zerop index))
    (rplacd (nthcdr (1- index) list)
            new-value))
  new-value)

(defun set-fifth (list new-value)
  (set-car (cddddr list) new-value))

(defun set-sixth (list new-value)
  (set-car (cdr (cddddr list)) new-value))

(defun set-seventh (list new-value)
  (set-car (cddr (cddddr list)) new-value))

(defun set-eighth (list new-value)
  (set-car (cdddr (cddddr list)) new-value))

(defun set-ninth (list new-value)
  (set-car (cddddr (cddddr list)) new-value))

(defun set-tenth (list new-value)
  (set-car (cdr (cddddr (cddddr list))) new-value))

(defun set-caaar (list new-value)
  (set-car (caar list) new-value))

(defun set-caadr (list new-value)
  (set-car (cadr list) new-value))

(defun set-cadar (list new-value)
  (set-car (cdar list) new-value))

(defun set-caddr (list new-value)
  (set-car (cddr list) new-value))

(defun set-cdaar (list new-value)
  (set-cdr (caar list) new-value))

(defun set-cdadr (list new-value)
  (set-cdr (cadr list) new-value))

(defun set-cddar (list new-value)
  (set-cdr (cdar list) new-value))

(defun set-cdddr (list new-value)
  (set-cdr (cddr list) new-value))

(defun set-caaaar (list new-value)
  (set-car (caaar list) new-value))

(defun set-caaadr (list new-value)
  (set-car (caadr list) new-value))

(defun set-caadar (list new-value)
  (set-car (cadar list) new-value))

(defun set-caaddr (list new-value)
  (set-car (caddr list) new-value))

(defun set-cadaar (list new-value)
  (set-car (cdaar list) new-value))

(defun set-cadadr (list new-value)
  (set-car (cdadr list) new-value))

(defun set-caddar (list new-value)
  (set-car (cddar list) new-value))

(defun set-cadddr (list new-value)
  (set-car (cdddr list) new-value))

(defun set-cdaaar (list new-value)
  (set-cdr (caaar list) new-value))

(defun set-cdaadr (list new-value)
  (set-cdr (caadr list) new-value))

(defun set-cdadar (list new-value)
  (set-cdr (cadar list) new-value))

(defun set-cdaddr (list new-value)
  (set-cdr (caddr list) new-value))

(defun set-cddaar (list new-value)
  (set-cdr (cdaar list) new-value))

(defun set-cddadr (list new-value)
  (set-cdr (cdadr list) new-value))

(defun set-cdddar (list new-value)
  (set-cdr (cddar list) new-value))

(defun set-cddddr (list new-value)
  (set-cdr (cdddr list) new-value))



; End of setf-runtime.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/setf-runtime.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Macros (and functions/constants used at macroexpand-time) ONLY.

(in-package "CCL")

(eval-when (eval compile)
  (require "LEVEL-2")
  (require "BACKQUOTE")
  (require "DEFSTRUCT-MACROS"))

;; Constants

(defmacro defconstant (sym val &optional (doc () doc-p) &environment env)
  "Define a global constant, saying that the value is constant and may be
  compiled into code. If the variable already has a value, and this is not
  EQL to the new value, the code is not portable (undefined behavior). The
  third argument is an optional documentation string for the variable."
  (setq sym (require-type sym 'symbol)
        doc (if doc-p (require-type doc 'string)))
  `(progn
     (eval-when (:compile-toplevel)
       (define-compile-time-constant ',sym ',val ,env))
     (eval-when (:load-toplevel :execute)
       (%defconstant ',sym ,val ,@(if doc-p (list doc))))))

;; Lists

(defmacro %car (x)
  `(car (the list ,x)))

(defmacro set-%car (x y)
  `(setf (car (the cons ,x)) ,y))

(defmacro %cdr (x)
  `(cdr (the list ,x)))

(defmacro set-%cdr (x y)
  `(setf (cdr (the cons ,x)) ,y))

(defmacro %caar (x)
 `(%car (%car ,x)))

(defmacro %cadr (x)
 `(%car (%cdr ,x)))

(defmacro %cdar (x)
 `(%cdr (%car ,x)))

(defmacro %cddr (x)
 `(%cdr (%cdr ,x)))

(defmacro %caaar (x)
 `(%car (%car (%car ,x))))

(defmacro %caadr (x)
 `(%car (%car (%cdr ,x))))

(defmacro %cadar (x)
 `(%car (%cdr (%car ,x))))

(defmacro %caddr (x)
 `(%car (%cdr (%cdr ,x))))

(defmacro %cdaar (x)
 `(%cdr (%car (%car ,x))))

(defmacro %cdadr (x)
 `(%cdr (%car (%cdr ,x))))

(defmacro %cddar (x)
 `(%cdr (%cdr (%car ,x))))

(defmacro %cdddr (x)
 `(%cdr (%cdr (%cdr ,x))))

(defmacro %rplaca (x y)
  `(rplaca (the cons ,x) ,y))

(defmacro %rplacd (x y)
  `(rplacd (the cons ,x) ,y))

; These are open-coded by the compiler to isolate platform
; dependencies.

(defmacro %unbound-marker-8 ()
  `(%unbound-marker))

(defmacro %slot-missing-marker ()
  `(%illegal-marker))




(defmacro %null-ptr () '(%int-to-ptr 0))

;;;Assorted useful macro definitions

(defmacro def-accessors (ref &rest names)
  (define-accessors ref names))

(defmacro def-accessor-macros (ref &rest names)
  (define-accessors ref names t))

(defun define-accessors (ref names &optional no-constants
                             &aux (arg (gensym)) (index 0) progn types)
  (when (listp ref)
    (setq types ref
          ref (pop names)))
  (dolist (name names)
    (when name
      (unless (listp name) (setq name (list name)))
      (dolist (sym name)
        (when sym
          (push `(defmacro ,sym (,arg) (list ',ref ,arg ,index)) progn)
          (unless no-constants
	    (push `(defconstant ,sym ,index) progn)))))
    (setq index (1+ index)))
 `(progn
    ,.(nreverse progn)
    ,@(if types `((add-accessor-types ',types ',names)))
    ,index))

(defmacro specialv (var)
  `(locally (declare (special ,var)) ,var))


(defmacro prog1 (valform &rest otherforms)
 (let ((val (gensym)))
 `(let ((,val ,valform))
   ,@otherforms
   ,val)))

(defmacro prog2 (first second &rest others)
 `(progn ,first (prog1 ,second ,@others)))

(defmacro prog (inits &body body &environment env)
  (multiple-value-bind (forms decls) (parse-body body env nil)
    `(block nil
       (let ,inits
         ,@decls
         (tagbody ,@forms)))))

(defmacro prog* (inits &body body &environment env)
  (multiple-value-bind (forms decls) (parse-body body env nil)
    `(block nil
       (let* ,inits
         ,@decls
         (tagbody ,@forms)))))


(defmacro %stack-block ((&rest specs) &body forms &aux vars lets)
  (dolist (spec specs)
    (destructuring-bind (var ptr &key clear) spec
      (push var vars)
      (push `(,var (%new-ptr ,ptr ,clear)) lets)))
  `(let* ,(nreverse lets)
     (declare (dynamic-extent ,@vars))
     (declare (type macptr ,@vars))
     (declare (unsettable ,@vars))
     ,@forms))

(defmacro %vstack-block (spec &body forms)
  `(%stack-block (,spec) ,@forms))

(eval-when (:compile-toplevel :load-toplevel :execute)
(defun extract-bound-decls-for-dolist-var (var decls env)
  (if (null decls)
    (values nil nil)
      (collect ((var-decls)
                (other-decls))
        (dolist (declform decls
                 (let* ((vdecls (var-decls))
                        (others (other-decls)))
                   (values (if vdecls `((declare ,@vdecls)))
                           (if others `((declare ,@others))))))
          ;; (assert (eq (car declform) 'declare))
          (dolist (decl (cdr declform))
            (if (atom decl)
              (other-decls decl)
              (let* ((spec (car decl)))
                (if (specifier-type-if-known spec env)
                  (setq spec 'type
                        decl `(type ,@decl)))
                (case spec
                  (type
                   (destructuring-bind (typespec &rest vars) (cdr decl)
                     (cond ((member var vars :test #'eq)
                            (setq vars (delete var vars))
                            (var-decls `(type ,typespec ,var))
                            (when vars
                              (other-decls `(type ,typespec ,@vars))))
                           (t (other-decls decl)))))
                   ((special ingore ignorable ccl::ignore-if-unused)
                    (let* ((vars (cdr decl)))
                      (cond ((member var vars :test #'eq)
                             (setq vars (delete var vars))
                             (var-decls `(,spec ,var))
                             (when vars
                               (other-decls `(,spec ,@vars))))
                            (t (other-decls decl)))))
                   (t (other-decls decl))))))))))
)



(defmacro dolist ((varsym list &optional ret) &body body &environment env)
  (if (not (symbolp varsym)) (signal-program-error $XNotSym varsym))
    (multiple-value-bind (forms decls) (parse-body body env nil)
      (multiple-value-bind (var-decls other-decls)
          (extract-bound-decls-for-dolist-var varsym decls env)
        (let* ((lstsym (gensym)))
        `(do* ((,lstsym ,list (cdr (the list ,lstsym))))
              ((null ,lstsym)
               ,@(if ret `((let* ((,varsym ()))
                             (declare (ignorable ,varsym))
                             ,ret))))
          ,@other-decls
          (let* ((,varsym (car ,lstsym)))
            ,@var-decls
            (tagbody ,@forms)))))))

(defmacro dovector ((varsym vector &optional ret) &body body &environment env)
  (if (not (symbolp varsym))(signal-program-error $XNotSym varsym))
  (let* ((toplab (gensym))
         (tstlab (gensym))
         (lengthsym (gensym))
         (indexsym (gensym))
         (vecsym (gensym)))
    (multiple-value-bind (forms decls) (parse-body body env nil)
     `(let* ((,vecsym ,vector)
             (,lengthsym (length ,vecsym))
             (,indexsym 0)
             ,varsym)
        ,@decls
        ,@(let ((type (nx-form-type vector env)))
            (unless (eq type t)
              `((declare (type ,type ,vecsym)))))
        (block nil
          (tagbody
            (go ,tstlab)
            ,toplab
            (setq ,varsym (locally (declare (optimize (speed 3) (safety 0)))
                            (aref ,vecsym ,indexsym))
                  ,indexsym (%i+ ,indexsym 1))
            ,@forms
            ,tstlab
            (if (%i< ,indexsym ,lengthsym) (go ,toplab)))
          ,@(if ret `((progn (setq ,varsym nil) ,ret))))))))

(defmacro report-bad-arg (&whole w thing typespec &environment env)
  (when (quoted-form-p typespec)
    (unless (ignore-errors (specifier-type-if-known (cadr typespec) env))
      (warn "Unknown type specifier ~s in ~s." (cadr typespec) w)))
  `(values (%badarg ,thing ,typespec)))

(defmacro %cons-restart (name action report interactive test)
 `(%istruct 'restart ,name ,action ,report ,interactive ,test))

(defmacro restart-bind (clauses &body body)
  "Executes forms in a dynamic context where the given restart bindings are
   in effect. Users probably want to use RESTART-CASE. When clauses contain
   the same restart name, FIND-RESTART will find the first such clause."
  (let* ((restarts (mapcar #'(lambda (clause) 
                               (list (make-symbol (symbol-name (require-type (car clause) 'symbol)))
                                     `(%cons-restart nil nil nil nil nil)))
                           clauses))
         (bindings (mapcar #'(lambda (clause name)
                              `(make-restart ,(car name) ',(car clause)
                                             ,@(cdr clause)))
                           clauses restarts))
        (cluster (gensym)))
    `(let* (,@restarts)
       (declare (dynamic-extent ,@(mapcar #'car restarts)))
       (let* ((,cluster (list ,@bindings))
              (%restarts% (cons ,cluster %restarts%)))
         (declare (dynamic-extent ,cluster %restarts%))
         (progn
           ,@body)))))

(defmacro handler-bind (clauses &body body)
  "(HANDLER-BIND ( {(type handler)}* )  body)
   Executes body in a dynamic context where the given handler bindings are
   in effect. Each handler must take the condition being signalled as an
   argument. The bindings are searched first to last in the event of a
   signalled condition."
  (let* ((fns)
         (decls)         
         (bindings (mapcan #'(lambda (clause)
                               (destructuring-bind (condition handler) clause
                                 (if (and (consp handler)(eq (car handler) 'function)
                                          (consp (cadr handler))(eq (car (cadr handler)) 'lambda))
                                   (let ((fn (gensym)))
                                     (push `(,fn ,handler) fns)
                                     (push `(declare (dynamic-extent ,fn)) decls)
                                     `(',condition ,fn))
                                   (list `',condition
                                         `,handler))))
                           clauses))
        (cluster (gensym)))    
    (if (null bindings)
      `(progn ,@body)
      `(let* (,@fns
              (,cluster (list ,@bindings))
              (%handlers% (cons ,cluster %handlers%)))
         (declare (dynamic-extent ,cluster %handlers%))
         ,@decls
         ,@body))))

(defmacro restart-case (&environment env form &rest clauses)
  "(RESTART-CASE form
   {(case-name arg-list {keyword value}* body)}*)
   The form is evaluated in a dynamic context where the clauses have special
   meanings as points to which control may be transferred (see INVOKE-RESTART).
   When clauses contain the same case-name, FIND-RESTART will find the first
   such clause. If Expression is a call to SIGNAL, ERROR, CERROR or WARN (or
   macroexpands into such) then the signalled condition will be associated with
   the new restarts."
  (let ((cluster nil))
    (when clauses (setq cluster (gensym) form (restart-case-form form env cluster)))
    (flet ((restart-case-1 (name arglist &rest forms)
             (let (interactive report test)
               (loop
                 (case (car forms)
                   (:interactive (setq interactive (cadr forms)))
                   (:report (setq report (cadr forms)))
                   (:test (setq test (cadr forms)))
                   (t (return nil)))
                 (setq forms (cddr forms)))
               (when (and report (not (stringp report)))
                 (setq report `#',report))
               (when interactive
                 (setq interactive `#',interactive))
               (when test
                 (setq test `#',test))
               (values (require-type name 'symbol) arglist report interactive test forms))))
      (cond ((null clauses) form)
            ((and (null (cdr clauses)) (null (cadr (car clauses))))
             (let ((block (gensym)) 
                   (restart-name (gensym)))
               (multiple-value-bind (name arglist report interactive test body)
                                    (apply #'restart-case-1 (car clauses))
                 (declare (ignore arglist))
                 `(block ,block
                    (let* ((,restart-name (%cons-restart ',name () ,report ,interactive ,test))
                           (,cluster (list ,restart-name)))
                      (declare (dynamic-extent ,restart-name ,cluster))
                      (catch ,cluster
                        (let ((%restarts% (cons ,cluster %restarts%)))
                          (declare (dynamic-extent %restarts%))
                          (return-from ,block ,form))))
                    ,@body))))
            (t
             (let ((block (gensym)) (val (gensym))
                   (index -1) restarts restart-names restart-name cases)
               (while clauses
                 (setq index (1+ index))
                 (multiple-value-bind (name arglist report interactive test body)
                                      (apply #'restart-case-1 (pop clauses))
                   (push (setq restart-name (make-symbol (symbol-name name))) restart-names)
                   (push (list restart-name `(%cons-restart ',name ,index ,report ,interactive ,test))
                         restarts)
                   (when (null clauses) (setq index t))
                   (push `(,index (apply #'(lambda ,arglist ,@body) ,val))
                         cases)))
               `(block ,block
                  (let ((,val (let* (,@restarts
                                     (,cluster (list ,@(reverse restart-names))))
                                (declare (dynamic-extent ,@restart-names ,cluster))
                                (catch ,cluster
                                  (let ((%restarts% (cons ,cluster %restarts%)))
                                    (declare (dynamic-extent %restarts%))
                                    (return-from ,block ,form))))))
                    (case (pop ,val)
                      ,@(nreverse cases))))))))))


; Anything this hairy should die a slow and painful death.
; Unless, of course, I grossly misunderstand...
(defun restart-case-form (form env clustername)
  (let ((expansion (macroexpand form env))
        (head nil))
    (if (and (listp expansion)          ; already an ugly hack, made uglier by %error case ...
             (memq (setq head (pop expansion)) '(signal error cerror warn %error)))
      (let ((condform nil)
            (signalform nil)
            (cname (gensym)))
        (case head
          (cerror
           (destructuring-bind 
             (continue cond &rest args) expansion
             (setq condform `(condition-arg ,cond (list ,@args) 'simple-error)
                   signalform `(cerror ,continue ,cname ,@args))))
          ((signal error warn)
           (destructuring-bind
             (cond &rest args) expansion
             (setq condform `(condition-arg ,cond (list ,@args) ,(if (eq head 'warn)
                                                                   ''simple-warning
                                                                   (if (eq head 'error)
                                                                     ''simple-error
                                                                     ''simple-condition)))
                   signalform `(,head ,cname))))
          (t ;%error
           (destructuring-bind (cond args fp) expansion
             (setq condform `(condition-arg ,cond ,args 'simple-error)
                   signalform `(%error ,cname nil ,fp)))))
        `(let ((,cname ,condform))
           (with-condition-restarts ,cname ,clustername
             ,signalform)))
      form)))
      

(defmacro handler-case (form &rest clauses)
  "(HANDLER-CASE form
   { (type ([var]) body) }* )
   Execute FORM in a context with handlers established for the condition
   types. A peculiar property allows type to be :NO-ERROR. If such a clause
   occurs, and form returns normally, all its values are passed to this clause
   as if by MULTIPLE-VALUE-CALL.  The :NO-ERROR clause accepts more than one
   var specification."
  (let* ((no-error-clause (assoc :no-error clauses)))
    (if no-error-clause
      (let* ((normal-return (gensym))
             (error-return (gensym)))
        `(block ,error-return
          (multiple-value-call #'(lambda ,@(cdr no-error-clause))
            (block ,normal-return
              (return-from ,error-return
                (handler-case (return-from ,normal-return ,form)
                  ,@(remove no-error-clause clauses)))))))
      (flet ((handler-case-aux (type var &rest body)
               (when (eq type :no-error)
                 (signal-program-error "Duplicate :no-error clause. "))
           (values type var body)))
        (cond ((null clauses) form)
          ((null (cdr clauses))
           (let ((block   (gensym))
                 (cluster (gensym)))
             (multiple-value-bind (type var body)
                                  (apply #'handler-case-aux (car clauses))
               (if var
                 `(block ,block
                    ((lambda ,var ,@body)
                      (let* ((,cluster (list ',type)))
                        (declare (dynamic-extent ,cluster))
                        (catch ,cluster
                          (let ((%handlers% (cons ,cluster %handlers%)))
                            (declare (dynamic-extent %handlers%))
                            (return-from ,block ,form))))))
                 `(block ,block
                    (let* ((,cluster (list ',type)))
                      (declare (dynamic-extent ,cluster))
                      (catch ,cluster
                        (let ((%handlers% (cons ,cluster %handlers%)))
                          (declare (dynamic-extent %handlers%))
                          (return-from ,block ,form)))
                      (locally ,@body)))))))
          (t (let ((block (gensym)) (cluster (gensym)) (val (gensym))
                   (index -1) handlers cases)
               (while clauses
                 (setq index (1+ index))
                 (multiple-value-bind (type var body)
                                      (apply #'handler-case-aux (pop clauses))                   
                   (push `',type handlers)
                   (push index handlers)
                   (when (null clauses) (setq index t))
                   (push (if var
                           `(,index ((lambda ,var ,@body) ,val))
                           `(,index (locally ,@body))) cases)))
               `(block ,block
                  (let ((,val (let* ((,cluster (list ,@(nreverse handlers))))
                                (declare (dynamic-extent ,cluster))
                                (catch ,cluster
                                  (let ((%handlers% (cons ,cluster %handlers%)))
                                    (declare (dynamic-extent %handlers%))
                                    (return-from ,block ,form))))))
                    (case (pop ,val)
                      ,@(nreverse cases)))))))))))

(defmacro with-simple-restart ((restart-name format-string &rest format-args)
                               &body body
                               &aux (cluster (gensym)) (temp (make-symbol (symbol-name restart-name))))
  "(WITH-SIMPLE-RESTART (restart-name format-string format-arguments)
   body)
   If restart-name is not invoked, then all values returned by forms are
   returned. If control is transferred to this restart, it immediately
   returns the values NIL and T."
  (unless (and (stringp format-string)
               (null format-args)
               (not (%str-member #\~ (ensure-simple-string format-string))))
    (let ((stream (gensym)))
      (setq format-string `#'(lambda (,stream) (format ,stream ,format-string ,@format-args)))))
  `(let* ((,temp (%cons-restart ',restart-name
                                'simple-restart
                                ,format-string
                                nil
                                nil))
          (,cluster (list ,temp)))
     (declare (dynamic-extent ,temp ,cluster))
     (catch ,cluster
       (let ((%restarts% (cons ,cluster %restarts%)))
         (declare (dynamic-extent %restarts%))
         ,@body))))

;Like with-simple-restart but takes a pre-consed restart.  Not CL.
(defmacro with-restart (restart &body body &aux (cluster (gensym)))
  `(let* ((,cluster (list ,restart)))
     (declare (dynamic-extent ,cluster))
     (catch ,cluster
       (let ((%restarts% (cons ,cluster %restarts%)))
         (declare (dynamic-extent %restarts%))
         ,@body))))

(defmacro ignore-errors (&rest forms)
  "Execute FORMS handling ERROR conditions, returning the result of the last
  form, or (VALUES NIL the-ERROR-that-was-caught) if an ERROR was handled."
  `(handler-case (progn ,@forms)
     (error (condition) (values nil condition))))

(defmacro def-kernel-restart (&environment env errno name arglist &body body)
  (multiple-value-bind (body decls)
                       (parse-body body env)
    `(let* ((fn (nfunction ,name (lambda ,arglist ,@decls (block ,name ,@body))))
            (pair (assq ,errno ccl::*kernel-restarts*)))
       (if pair
         (rplacd pair fn)
         (push (cons ,errno fn) ccl::*kernel-restarts*))
       fn)))


;;; Setf.

;  If you change anything here, be sure to make the corresponding change
;  in get-setf-method.
(defmacro setf (&rest args &environment env)
  "Takes pairs of arguments like SETQ. The first is a place and the second
  is the value that is supposed to go into that place. Returns the last
  value. The place argument may be any of the access forms for which SETF
  knows a corresponding setting form."
  (let ((temp (length args))
        (accessor nil))
    (cond ((eq temp 2)
           (let* ((form (car args)) 
                  (value (cadr args)))
             ;This must match get-setf-method .
             (cond ((atom form)
                    (progn
                      (unless (symbolp form)(signal-program-error $XNotSym form))
                      `(setq ,form ,value)))
                   ((eq (car form) 'the)
                    (unless (eql (length form) 3)
                      (error "Bad THE place form in (SETF ~S ~S)" form value))
                    (destructuring-bind (type place) (cdr form)
                      `(setf ,place (the ,type ,value))))
                   (t
                    (multiple-value-bind (ftype local-p)
                        (function-information (setq accessor (car form)) ENV)
                      (if local-p
                        (if (eq ftype :function)
                          ;;Local function, so don't use global setf
                          ;;definitions.
                          (default-setf form value env)
                          `(setf ,(macroexpand-1 form env) ,value))
                        (cond
                          ((setq temp (%setf-method accessor))
                           (if (symbolp temp)
                             `(,temp ,@(cdar args) ,value)
                             (multiple-value-bind (dummies vals storevars setter #|getter|#)
                                 (funcall temp form env)
                               (do* ((d dummies (cdr d))
                                     (v vals (cdr v))
                                     (let-list nil))
                                    ((null d)
                                     (setq let-list (nreverse let-list))
                                     `(let* ,let-list
                                       (declare (ignorable ,@dummies))
                                       (multiple-value-bind ,storevars ,value
                                         #|,getter|#
                                         ,setter)))
                                 (push (list (car d) (car v)) let-list)))))
                          ((and (setq temp (structref-info accessor env))
                                (accessor-structref-info-p temp)
                                (not (refinfo-r/o (structref-info-refinfo temp))))
                           (let* ((nargs (length (%cdar args))))
                             (unless (eql nargs 1)
                               (signal-simple-program-error
                                "In ~s, structure accessor ~s requires exactly 1 argument but is being called with ~d arguments." `(setf ,@args) accessor nargs)))
                           (let ((form (defstruct-ref-transform temp (%cdar args) env t))
                                 (type (defstruct-type-for-typecheck (structref-info-type temp) env)))
                             (if (eq type t)
                               `(setf ,form ,value)
                               ;; strip off type, but add in a typecheck
                               `(the ,type (setf ,form (typecheck ,value ,type))))))

                          (t
                           (multiple-value-bind (res win)
                               (macroexpand-1 form env)
                             (if win
                               `(setf ,res ,value)
                               (default-setf form value env)))))))))))
          ((oddp temp)
	   (signal-program-error "Odd number of args to SETF : ~s." args))
          (t (do* ((a args (cddr a)) (l nil))
                  ((null a) `(progn ,@(nreverse l)))
               (push `(setf ,(car a) ,(cadr a)) l))))))


(defun default-setf (setter value &optional env)
  (let* ((reader (car setter))
         (args (cdr setter))
         (gensyms (mapcar #'(lambda (sym) (declare (ignore sym)) (gensym)) args))
         types declares)
    (flet ((form-type (form)
             (nx-form-type form env)))
      (declare (dynamic-extent #'form-type))
      (setq types (mapcar #'form-type args)))
    (dolist (sym gensyms)
      (let ((sym-type (pop types)))
        (unless (eq sym-type t)
          (push `(type ,sym-type ,sym) declares))))
    `(let ,(mapcar #'list gensyms args)
       ,@(and declares (list `(declare ,@(nreverse declares))))
       (funcall #'(setf ,reader) ,value ,@gensyms))))

;; Establishing these setf-inverses is something that should
;; happen at compile-time
(defsetf elt set-elt)
(defsetf car set-car)
(defsetf %car set-%car)
(defsetf first set-car)
(defsetf cdr set-cdr)
(defsetf %cdr set-%cdr)
(defsetf rest set-cdr)
(defsetf uvref uvset)
(defsetf aref aset)
(defsetf svref svset)
(defsetf %svref %svset)
(defsetf char set-char)
(defsetf schar set-schar)
(defsetf %scharcode %set-scharcode)
(defsetf symbol-value set)
(defsetf symbol-plist set-symbol-plist)
(defsetf fill-pointer set-fill-pointer)

; This sux; it calls the compiler twice (once to shove the macro in the
; environment, once to dump it into the file.)
(defmacro defmacro  (name arglist &body body &environment env)
  (unless (symbolp name)(signal-program-error $XNotSym name))
  (unless (listp arglist) (signal-program-error "~S is not a list." arglist))
  (multiple-value-bind (lambda-form doc)
                       (parse-macro-1 name arglist body env)
    (let* ((normalized (normalize-lambda-list arglist t t))
           (body-pos (position '&body normalized))
           (argstring (let ((temp nil))
                        (dolist (arg normalized)
                          (if (eq arg '&aux)
                            (return)
                            (push arg temp)))
                        (let ((*package* (find-package "KEYWORD")))
                          (format nil "~:S" (nreverse temp))))))
      (if (and body-pos (memq '&optional normalized)) (decf body-pos))
      `(progn
         (eval-when (:compile-toplevel)
           (define-compile-time-macro ',name ',lambda-form ',env))
         (eval-when (:load-toplevel :execute)
           (%macro 
            (nfunction ,name ,lambda-form)
            '(,doc ,body-pos . ,argstring))
           ',name)))))

(defmacro define-symbol-macro (name expansion &environment env)
  (unless (symbolp name)(signal-program-error $XNotSym name))
  `(progn
    (eval-when (:compile-toplevel)
      (define-compile-time-symbol-macro ',name ',expansion ',env))
    (eval-when (:load-toplevel :execute)
      (%define-symbol-macro ',name ',expansion))))

;; ---- allow inlining setf functions
(defmacro defun (spec args &body body &environment env &aux global-name inline-spec)
  "Define a function at top level."
  (when (null spec)
    (signal-program-error "Using ~s as a function name is silly." nil))
  (validate-function-name spec)
  (setq args (require-type args 'list))
  (setq body (require-type body 'list))
  (multiple-value-bind (forms decls doc) (parse-body body env t)
    (cond ((symbolp spec)
           (setq global-name spec)
           (setq inline-spec spec)
           (setq body `(block ,spec ,@forms)))
          ((setf-function-name-p spec)
           (setq inline-spec spec)
           (setq body `(block ,(cadr spec) ,@forms)))
          (t (setq body `(progn ,@forms))))
    (let* ((lambda-expression `(lambda ,args 
                                ,@(if global-name
                                    `((declare (global-function-name ,global-name))))
                                ,@decls ,body))
           (info (if (and inline-spec
                          (binding-free-environment-p env)
                          (nx-declared-inline-p inline-spec env)
                          (not (and (symbolp inline-spec)
                                    (gethash inline-spec *NX1-ALPHATIZERS*))))
                   (cons doc lambda-expression)
                   doc)))
      `(progn
         (%defun (nfunction ,spec ,lambda-expression) ',info)
         ',spec))))

(defmacro %defvar-init (var initform doc)
  `(unless (%defvar ',var ,doc)
    (set ',var ,initform)))

(defmacro defvar (&environment env var &optional (value () value-p) doc)
  "Define a global variable at top level. Declare the variable
  SPECIAL and, optionally, initialize it. If the variable already has a
  value, the old value is not clobbered. The third argument is an optional
  documentation string for the variable."
  (if (and doc (not (stringp doc))) (report-bad-arg doc 'string))
  (if (and (compile-file-environment-p env) (not *fasl-save-doc-strings*))
    (setq doc nil))
 `(progn
    (eval-when (:compile-toplevel)
      (note-variable-info ',var ,value-p ,env))
    ,(if value-p
       `(%defvar-init ,var ,value ,doc)
       `(%defvar ',var))
    ',var))
         
(defmacro def-standard-initial-binding (name &optional (form name) (doc nil doc-p) &environment env)
  `(progn
    (eval-when (:compile-toplevel)
      (note-variable-info ',name t ,env))    
    (define-standard-initial-binding ',name #'(lambda () ,form))
    ,@(when doc-p
           `((set-documentation ',name 'variable ,doc)))
    ',name))

(defmacro defparameter (&environment env var value &optional doc)
  "Define a parameter that is not normally changed by the program,
  but that may be changed without causing an error. Declare the
  variable special and sets its value to VAL, overwriting any
  previous value. The third argument is an optional documentation
  string for the parameter."
  (if (and doc (not (stringp doc))) (signal-program-error "~S is not a string." doc))
  (if (and (compile-file-environment-p env) (not *fasl-save-doc-strings*))
    (setq doc nil))
  `(progn
     (eval-when (:compile-toplevel)
       (note-variable-info ',var t ,env))
     (%defparameter ',var ,value ,doc)))


(defmacro defstatic (&environment env var value &optional doc)
  "Syntax is like DEFPARAMETER.  Proclaims the symbol to be special,
but also asserts that it will never be given a per-thread dynamic
binding.  The value of the variable can be changed (via SETQ, etc.),
but since all threads access the same static binding of the variable,
such changes should be made with care."
  (if (and doc (not (stringp doc))) (signal-program-error "~S is not a string." doc))
  (if (and (compile-file-environment-p env) (not *fasl-save-doc-strings*))
    (setq doc nil))
  `(progn
     (eval-when (:compile-toplevel)
       (note-variable-info ',var :global ,env))
     (%defglobal ',var ,value ,doc)))

(defmacro defstaticvar (&environment env var value &optional doc)
  "Syntax is like DEFVAR.  Proclaims the symbol to be special,
but also asserts that it will never be given a per-thread dynamic
binding.  The value of the variable can be changed (via SETQ, etc.),
but since all threads access the same static binding of the variable,
such changes should be made with care.  Like DEFVAR, the initial value
form is not evaluated if the variable is already BOUNDP."
  (if (and doc (not (stringp doc))) (signal-program-error "~S is not a string." doc))
  (if (and (compile-file-environment-p env) (not *fasl-save-doc-strings*))
    (setq doc nil))
  `(progn
     (eval-when (:compile-toplevel)
       (note-variable-info ',var :global ,env))
      (%symbol-bits ',var (logior (ash 1 $sym_vbit_global) (the fixnum (%symbol-bits ',var))))
     (%defvar-init ,var ,value ,doc)))


(defmacro defglobal (&rest args)
  "Synonym for DEFSTATIC."
  `(defstatic ,@args))


(defmacro defloadvar (var value &optional doc)
  `(progn
     (defstaticvar ,var ,nil ,@(if doc `(,doc)))
     (def-ccl-pointers ,var ()
       (setq ,var ,value))
     ',var))




(defmacro qlfun (name args &body body)
  `(nfunction ,name (lambda ,args ,@body)))

(defmacro lfun-bits-known-function (f)
  (let* ((temp (gensym)))
    `(let* ((,temp (function-to-function-vector ,f)))
      (%svref ,temp (the fixnum (1- (the fixnum (uvsize ,temp))))))))

(defmacro lfunloop (for var in function &body loop-body)
  "Loop over immediates in function"
  (assert (and (or (equal (symbol-name for) "FOR") (equal (symbol-name for) "AS"))
               (equal (symbol-name in) "IN")))
  (let ((fn (gensym))
	(lfv (gensym))
	(i (gensym)))
    `(loop with ,fn = ,function
           with ,lfv = (function-to-function-vector ,fn)
           for ,i from #+ppc-target 1 #+x86-target (%function-code-words ,fn) #+arm-target 2  below (%i- (uvsize  ,lfv) 1)
           as ,var = (%svref ,lfv ,i)
           ,@loop-body)))

(defmacro cond (&rest args &aux clause)
  (when args
     (setq clause (car args))
     (if (cdr clause)         
         `(if ,(car clause) (progn ,@(cdr clause)) (cond ,@(cdr args)))
       (if (cdr args) `(or ,(car clause) (cond ,@(cdr args)))
                      `(values ,(car clause))))))

(defmacro and (&rest args)
  "And Form*
AND evaluates each form in sequence, from left to right.  If any form
returns NIL, AND returns NIL; otherwise, AND returns the values(s) returned
by the last form.  If there are no forms, AND returns T."
  (if (null args) t
    (if (null (cdr args)) (car args)
      `(if ,(car args) (and ,@(cdr args))))))

(defmacro or (&rest args)
  "Or Form*
OR evaluates each Form, in sequence, from left to right.
If any Form but the last returns a non-NIL value, OR returns that
single value (without evaluating any subsequent Forms.)  If OR evaluates
the last Form, it returns all values returned by that Form.  If there
are no Forms, OR returns NIL."
  (if args
    (if (cdr args)
      (do* ((temp (gensym))
            (handle (list nil))
            (forms `(let ((,temp ,(pop args)))
                     (if ,temp ,temp ,@handle))))
           ((null (cdr args))
            (%rplaca handle (%car args))
            forms)
        (%rplaca handle `(if (setq ,temp ,(%car args)) 
                          ,temp 
                          ,@(setq handle (list nil))))
        (setq args (%cdr args)))
      (%car args))))

(defmacro case (key &body forms)
  "CASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If a singleton key is T then the clause is a default clause."
   (let ((key-var (gensym)))
     `(let ((,key-var ,key))
        (declare (ignorable ,key-var))
        (cond ,@(case-aux forms key-var nil nil)))))

(defmacro ccase (keyplace &body forms)
  "CCASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then a correctable error is
  signalled."
  (let* ((key-var (gensym))
         (tag (gensym)))
    `(prog (,key-var)
       ,tag
       (setq ,key-var ,keyplace)
       (return (cond ,@(case-aux forms key-var tag keyplace))))))

(defmacro ecase (key &body forms)
  "ECASE Keyform {({(Key*) | Key} Form*)}*
  Evaluates the Forms in the first clause with a Key EQL to the value of
  Keyform. If none of the keys matches then an error is signalled."
  (let* ((key-var (gensym)))
    `(let ((,key-var ,key))
       (declare (ignorable ,key-var))
       (cond ,@(case-aux forms key-var 'ecase nil)))))
       
(defun case-aux (clauses key-var e-c-p placename &optional (used-keys (list (list '%case-core))))
  (if clauses
    (let* ((key-list (caar clauses))
           (stype (if e-c-p (if (eq e-c-p 'ecase) e-c-p 'ccase) 'case))
           (test (cond ((and (not e-c-p)
                             (or (eq key-list 't)
                                 (eq key-list 'otherwise)))
                        t)
                       (key-list
                        (cons 'or
                              (case-key-testers key-var used-keys key-list stype)))))
           (consequent-list (or (%cdar clauses) '(nil))))
      (if (eq test t)
        (progn
          (when (%cdr clauses) (warn "~s or ~s clause in the middle of a ~s statement.  Subsequent clauses ignored."
                                     't 'otherwise 'case))
          (cons (cons t consequent-list) nil))
        (cons (cons test consequent-list)
              (case-aux (%cdr clauses) key-var e-c-p placename used-keys))))
    (when e-c-p
      (setq used-keys `(member ,@(mapcar #'car (cdr used-keys))))
      (if (eq e-c-p 'ecase)
        `((t (values (%err-disp #.$XWRONGTYPE ,key-var ',used-keys))))
        `((t (setf ,placename (ensure-value-of-type ,key-var ',used-keys ',placename))
           (go ,e-c-p)))))))


;;; We don't want to descend list structure more than once (like this has
;;; been doing for the last 18 years or so.)
(defun case-key-testers (symbol used-keys atom-or-list statement-type &optional recursive)
  (if (or recursive (atom atom-or-list))
    (progn
      (if (assoc atom-or-list used-keys)
        (warn "Duplicate keyform ~s in ~s statement." atom-or-list statement-type)
        (setq used-keys (nconc used-keys (list (cons atom-or-list t)))))
      `((eql ,symbol ',atom-or-list)))
    (nconc (case-key-testers symbol used-keys (car atom-or-list) statement-type t)
           (when (cdr atom-or-list)
             (case-key-testers symbol used-keys (%cdr atom-or-list) statement-type nil)))))


; generate the COND body of a {C,E}TYPECASE form
(defun typecase-aux (key-var clauses &optional e-c-p keyform)
  (let* ((construct (if e-c-p (if (eq e-c-p 'etypecase) e-c-p 'ctypecase) 'typecase))
         (types ())
         (body ())
         otherwise-seen-p)
    (flet ((bad-clause (c) 
             (signal-program-error "Invalid clause ~S in ~S form." c construct)))
      (dolist (clause clauses)
        (if (atom clause)
            (bad-clause clause))
        (if otherwise-seen-p
            (signal-program-error "OTHERWISE must be final clause in ~S form." construct))
        (destructuring-bind (typespec &body consequents) clause
          (when (eq construct 'typecase)
            (if (eq typespec 'otherwise)
                (progn (setq typespec t)
                       (setq otherwise-seen-p t))))
          (unless
              (dolist (already types nil)
                (when (subtypep typespec already)
                  (warn 'shadowed-typecase-clause
                        :construct construct
                        :clause clause
                        :by (assq already clauses))
                  (return t)))
            (push typespec types)
            (setq typespec `(typep ,key-var ',typespec))
            (push `(,typespec nil ,@consequents) body))))
      (when e-c-p
        (setq types `(or ,@(nreverse types)))
        (if (eq construct 'etypecase)
            (push `(t (values (%err-disp #.$XWRONGTYPE ,key-var ',types))) body)
            (push `(t (setf ,keyform (ensure-value-of-type  ,key-var ',types ',keyform))
                      (go ,e-c-p)) body))))
    `(cond ,@(nreverse body))))

(defmacro typecase (keyform &body clauses)
  "TYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true."
  (let ((key-var (gensym)))
    `(let ((,key-var ,keyform))
       (declare (ignorable ,key-var))
       ,(typecase-aux key-var clauses))))

(defmacro etypecase (keyform &body clauses)
  "ETYPECASE Keyform {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then an error is signalled."
  (let ((key-var (gensym)))
    `(let ((,key-var ,keyform))
       (declare (ignorable ,key-var))
       ,(typecase-aux key-var clauses 'etypecase))))

(defmacro ctypecase (keyplace &body clauses)
  "CTYPECASE Key {(Type Form*)}*
  Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
  is true. If no form is satisfied then a correctable error is signalled."
  (let ((key-var (gensym))
        (tag (gensym)))
    `(prog (,key-var)
       ,tag
       (setq ,key-var ,keyplace)
       (return ,(typecase-aux key-var clauses tag keyplace)))))

(defmacro destructuring-bind (lambda-list expression &body body)
  "Bind the variables in LAMBDA-LIST to the contents of ARG-LIST."
  (multiple-value-bind (bindings decls)
      (%destructure-lambda-list  lambda-list expression nil nil)
    `(let* ,(nreverse bindings)
      ,@(when decls `((declare ,@decls)))
      ,@body)))


; This is supposedly ANSI CL.
(defmacro lambda (&whole lambda-expression (&rest paramlist) &body body)
  (declare (ignore paramlist body))
  (unless (lambda-expression-p lambda-expression)
    (warn "Invalid lambda expression: ~s" lambda-expression))
  `(function ,lambda-expression))

; This isn't
(defmacro nlambda (name (&rest arglist) &body body)
  `(nfunction ,name (lambda ,arglist ,@body)))

(defmacro when (test &body body)
  "If the first argument is true, the rest of the forms are
  evaluated as a PROGN."
 `(if ,test
   (progn ,@body)))

(defmacro unless (test &body body)
  "If the first argument is not true, the rest of the forms are
  evaluated as a PROGN."
 `(if (not ,test)
   (progn ,@body)))

(defmacro return (&optional (form nil form-p))
  `(return-from nil ,@(if form-p `(,form))))

; since they use tagbody, while & until BOTH return NIL
(defmacro while (test &body body)
  (let ((testlab (gensym))
        (toplab (gensym)))
    `(tagbody
       (go ,testlab)
      ,toplab
      (progn ,@body)
      ,testlab
      (when ,test (go ,toplab)))))

(defmacro until (test &body body)
  (let ((testlab (gensym))
        (toplab (gensym)))
    `(tagbody
       (go ,testlab)
      ,toplab
      (progn ,@body)
      ,testlab
      (if (not ,test)
        (go ,toplab)))))

(defmacro psetq (&whole call &body pairs &environment env)
  "PSETQ {var value}*
   Set the variables to the values, like SETQ, except that assignments
   happen in parallel, i.e. no assignments take place until all the
   forms have been evaluated."
  (when pairs
   (if (evenp (length pairs))
     (do* ((l pairs (%cddr l))
           (sym (%car l) (%car l)))
          ((null l) (%pset pairs))
       (unless (symbolp sym) (report-bad-arg sym 'symbol))
       (when (nth-value 1 (macroexpand-1 sym env))
         (return `(psetf ,@pairs))))
     (signal-program-error "Uneven number of args in the call ~S" call))))

; generates body for psetq.
; "pairs" is a proper list whose length is not odd.
(defun %pset (pairs)
 (when pairs
   (let (vars vals gensyms let-list var val sets)
      (loop
        (setq var (pop pairs)
              val (pop pairs))
        (if (null pairs) (return))
        (push var vars)
        (push val vals)
        (push (gensym) gensyms))
      (dolist (g gensyms)
        (push g sets)
        (push (pop vars) sets)
        (push (list g (pop vals)) let-list))
      (push val sets)
      (push var sets)
      `(progn
         (let* ,let-list
           (setq ,@sets))
         nil))))


(eval-when (:compile-toplevel :load-toplevel :execute)
(defun do-loop (binder setter env var-init-steps end-test result body)
  (let ((toptag (gensym))
        (testtag (gensym)))
    (multiple-value-bind (forms decls) (parse-body body env nil)
      `(block nil
         (,binder ,(do-let-vars var-init-steps)
                  ,@decls
                  (tagbody ; crocks-r-us.
                    (go ,testtag)
                    ,toptag
                    (tagbody
                      ,@forms)
                    (,setter ,@(do-step-vars var-init-steps))
                    ,testtag
                    (unless ,end-test
                      (go ,toptag)))
                  ,@result)))))
)

(defmacro do (&environment env var-init-steps (&optional end-test &rest result) &body body)
  "DO ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*
  Iteration construct. Each Var is initialized in parallel to the value of the
  specified Init form. On subsequent iterations, the Vars are assigned the
  value of the Step form (if any) in parallel. The Test is evaluated before
  each evaluation of the body Forms. When the Test is true, the Exit-Forms
  are evaluated as a PROGN, with the result being the value of the DO. A block
  named NIL is established around the entire expansion, allowing RETURN to be
  used as an alternate exit mechanism."
  (do-loop 'let 'psetq env var-init-steps end-test result body))

(defmacro do* (&environment env var-init-steps (&optional end-test &rest result) &body body)
  "DO* ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*
  Iteration construct. Each Var is initialized sequentially (like LET*) to the
  value of the specified Init form. On subsequent iterations, the Vars are
  sequentially assigned the value of the Step form (if any). The Test is
  evaluated before each evaluation of the body Forms. When the Test is true,
  the Exit-Forms are evaluated as a PROGN, with the result being the value
  of the DO. A block named NIL is established around the entire expansion,
  allowing RETURN to be used as an laternate exit mechanism."
  (do-loop 'let* 'setq env var-init-steps end-test result body))


(defun do-let-vars (var-init-steps)
  (if var-init-steps
      (cons (list (do-let-vars-var (car var-init-steps))
                  (do-let-vars-init (car var-init-steps)))
             (do-let-vars (cdr var-init-steps)))))

(defun do-let-vars-var (var-init-step)
  (if (consp var-init-step)
       (car var-init-step)
       var-init-step))

(defun do-let-vars-init (var-init-step)
   (if (consp var-init-step)
        (cadr var-init-step)
        nil))

(defun do-step-vars (var-init-steps)
    (if var-init-steps
        (if (do-step-vars-step? (car var-init-steps))
             (append (list (do-let-vars-var (car var-init-steps))
                           (do-step-vars-step (car var-init-steps)))
                     (do-step-vars (cdr var-init-steps)))
             (do-step-vars (cdr var-init-steps)))))

(defun do-step-vars-step? (var-init-step)
  (if (consp var-init-step)
       (cddr var-init-step)))

(defun do-step-vars-step (var-init-step)
  (if (consp var-init-step)
       (caddr var-init-step)))


(defmacro dotimes ((i n &optional result) &body body &environment env)
  (multiple-value-bind (forms decls)
                       (parse-body body env)
    (if (not (symbolp i))(signal-program-error $Xnotsym i))
    (let* ((toptag (gensym))
           (limit (gensym)))
      `(block nil
        (let ((,limit ,n) (,i 0))
         ,@decls
         (declare (unsettable ,i))
           (if (int>0-p ,limit)
             (tagbody
               ,toptag
               ,@forms
               (locally
                (declare (settable ,i))
                (setq ,i (1+ ,i)))
               (unless (eql ,i ,limit) (go ,toptag))))
           ,result)))))
  
(defun do-syms-result (var resultform)
  (unless (eq var resultform)
    (if (and (consp resultform) (not (quoted-form-p resultform)))
      `(progn (setq ,var nil) ,resultform)
      resultform)))

(defun expand-package-iteration-macro (iteration-function var pkg-spec resultform body env)
  (multiple-value-bind (body decls) (parse-body body env nil)
    (let* ((ftemp (gensym))
           (vtemp (gensym))
           (ptemp (gensym))
           (result (do-syms-result var resultform)))
      `(block nil
        (let* ((,var nil)
               (,ptemp ,pkg-spec))
          ,@decls
           (flet ((,ftemp (,vtemp) (declare (debugging-function-name nil)) (setq ,var ,vtemp) (tagbody ,@body)))
             (declare (dynamic-extent #',ftemp))
             (,iteration-function ,ptemp #',ftemp))
           ,@(when result `(,result)))))))

(defmacro do-symbols ((var &optional pkg result) &body body &environment env)
  "DO-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs at least once for each symbol accessible in the given
   PACKAGE with VAR bound to the current symbol."
  (expand-package-iteration-macro 'iterate-over-accessable-symbols var pkg result body env))

(defmacro do-present-symbols ((var &optional pkg result) &body body &environment env)
  (expand-package-iteration-macro 'iterate-over-present-symbols var pkg result body env))

(defmacro do-external-symbols ((var &optional pkg result) &body body &environment env)
  "DO-EXTERNAL-SYMBOLS (VAR [PACKAGE [RESULT-FORM]]) {DECL}* {TAG | FORM}*
   Executes the FORMs once for each external symbol in the given PACKAGE with
   VAR bound to the current symbol."
  (expand-package-iteration-macro 'iterate-over-external-symbols var pkg result body env))

(defmacro do-all-symbols ((var &optional resultform)
                          &body body &environment env)
  "DO-ALL-SYMBOLS (VAR [RESULT-FORM]) {DECLARATION}* {TAG | FORM}*
   Executes the FORMs once for each symbol in every package with VAR bound
   to the current symbol."
  (multiple-value-bind (body decls) (parse-body body env nil)
    (let* ((ftemp (gensym))
           (vtemp (gensym))
           (result (do-syms-result var resultform)))
      `(block nil
        (let* ((,var nil))
         ,@decls
           (flet ((,ftemp (,vtemp) (declare (debugging-function-name nil)) (setq ,var ,vtemp) (tagbody ,@body)))
             (declare (dynamic-extent #',ftemp))
             (iterate-over-all-symbols #',ftemp))
           ,@(when result `(,result)))))))

(defmacro multiple-value-list (form)
  `(multiple-value-call #'list ,form))




(defmacro %i> (x y)
  `(> (the fixnum ,x) (the fixnum ,y)))

(defmacro %i< (x y)
  `(< (the fixnum ,x) (the fixnum ,y)))

(defmacro %i<= (x y)
 `(not (%i> ,x ,y)))

(defmacro %i>= (x y)
 `(not (%i< ,x ,y)))

(defmacro bitset (bit number)
  `(logior (ash 1 ,bit) ,number))

(defmacro bitclr (bit number)
  `(logand (lognot (ash 1 ,bit)) ,number))

(defmacro bitopf ((op bit place) &environment env)
  (multiple-value-bind (vars vals stores store-form access-form)
                       (get-setf-method place env)
    (let* ((constant-bit-p (constantp bit))
           (bitvar (if constant-bit-p bit (gensym))))
      `(let ,(unless constant-bit-p `((,bitvar ,bit)))          ; compiler isn't smart enough
         (let* ,(mapcar #'list `(,@vars ,@stores) `(,@vals (,op ,bitvar ,access-form)))
           ,store-form)))))

(defmacro bitsetf (bit place)
  `(bitopf (bitset ,bit ,place)))

(defmacro bitclrf (bit place)
  `(bitopf (bitclr ,bit ,place)))

(defmacro %svref (v i)
  (let* ((vtemp (make-symbol "VECTOR"))
           (itemp (make-symbol "INDEX")))
      `(let* ((,vtemp ,v)
              (,itemp ,i))
         (locally (declare (optimize (speed 3) (safety 0)))
           (svref ,vtemp ,itemp)))))

(defmacro %svset (v i new)
  (let* ((vtemp (make-symbol "VECTOR"))
         (itemp (make-symbol "INDEX"))
         (ntemp (make-symbol "NEW")))
    `(let* ((,vtemp ,v)
            (,itemp ,i)
            (,ntemp ,new))
      (locally (declare (optimize (speed 3) (safety 0)))
        (setf (svref ,vtemp ,itemp) ,ntemp)))))


(defmacro %schar (v i)
  (let* ((vtemp (make-symbol "STRING"))
         (itemp (make-symbol "INDEX")))
    `(let* ((,vtemp ,v)
            (,itemp ,i))
       (locally (declare (optimize (speed 3) (safety 0)))
         (schar ,vtemp ,itemp)))))

(defmacro %set-schar (v i new)
  (let* ((vtemp (make-symbol "STRING"))
         (itemp (make-symbol "INDEX"))
         (ntemp (make-symbol "NEW")))
      `(let* ((,vtemp ,v)
              (,itemp ,i)
              (,ntemp ,new))
         (locally (declare (optimize (speed 3) (safety 0)))
           (setf (schar ,vtemp ,itemp) ,ntemp)))))


(defmacro %char-code (c) `(char-code (the character ,c)))
;;; %CODE-CHAR is used internally.  It can sometimes exploit the
;;; assertion that the character code is an (UNSIGNED-BYTE 8) to
;;; generate better compiled code (partly because all such character
;;; codes denote characters.)
;;; Confusingly, it's not just the inverse of %CHAR-CODE.  It's
;;; almost always going to be open-coded, so this macro definition
;;; is mostly just a kind of documentation.
(defmacro %code-char (i) `(code-char (the (mod 256) ,i)))

(defmacro %izerop (x) `(eq ,x 0))
(defmacro %iminusp (x) `(< (the fixnum ,x) 0))
(defmacro %i+ (&rest (&optional (n0 0) &rest others))
  (if others
    `(the fixnum (+ (the fixnum ,n0) (%i+ ,@others)))
    `(the fixnum ,n0)))
(defmacro %i- (x y &rest others) 
  (if (not others)
    `(the fixnum (- (the fixnum ,x) (the fixnum ,y)))
    `(the fixnum (- (the fixnum ,x) (the fixnum (%i+ ,y ,@others))))))


(defmacro %i* (x y) `(the fixnum (* (the fixnum ,x) (the fixnum ,y))))

(defmacro %ilogbitp (b i)
  (target-word-size-case
   (32
    `(logbitp (the (integer 0 29) ,b) (the fixnum ,i)))
   (64
    `(logbitp (the (integer 0 60) ,b) (the fixnum ,i)))))

;;; Seq-Dispatch does an efficient type-dispatch on the given Sequence.

(defmacro seq-dispatch (sequence list-form array-form)
  `(if (sequence-type ,sequence)
       ,list-form
       ,array-form))


(defsetf %get-byte %set-byte)
(defsetf %get-unsigned-byte %set-unsigned-byte)
(defsetf %get-signed-byte %set-byte)
(defsetf %get-word %set-word)
(defsetf %get-signed-word %set-word)
(defsetf %get-unsigned-word %set-unsigned-word)
(defsetf %get-long %set-long)
(defsetf %get-signed-long %set-long)
(defsetf %get-unsigned-long %set-unsigned-long)
(defsetf %get-full-long %set-long)
(defsetf %get-point %set-long)
(defsetf %get-ptr %set-ptr)
(defsetf %get-double-float %set-double-float)
(defsetf %get-single-float %set-single-float)
(defsetf %get-bit %set-bit)
(defsetf %get-unsigned-long-long %set-unsigned-long-long)
(defsetf %%get-unsigned-longlong %%set-unsigned-longlong)
(defsetf %get-signed-long-long %set-signed-long-long)
(defsetf %%get-signed-longlong %%set-signed-longlong)
(defsetf %get-bitfield %set-bitfield)

(defmacro %ilognot (int) `(%i- -1 ,int))

(defmacro %ilogior2 (x y) 
  `(logior (the fixnum ,x) (the fixnum ,y)))

(defmacro %ilogior (body &rest args)
   (while args
     (setq body (list '%ilogior2 body (pop args))))
   body)

(defmacro %ilogand2 (x y)
  `(logand (the fixnum ,x) (the fixnum ,y)))

(defmacro %ilogand (body &body args)
   (while args
     (setq body (list '%ilogand2 body (pop args))))
   body)

(defmacro %ilogxor2 (x y)
  `(logxor (the fixnum ,x) (the fixnum ,y)))

(defmacro %ilogxor (body &body args)
   (while args
     (setq body (list '%ilogxor2 body (pop args))))
   body)

(defmacro with-macptrs (varlist &rest body &environment env)
  (multiple-value-bind (body other-decls) (parse-body body env)
    (collect ((temp-bindings)
              (temp-decls)
              (bindings)
              (our-decls)
              (inits))
      (dolist (var varlist)
        (let* ((temp (gensym)))
          (temp-decls temp)
        (if (consp var)
          (progn
            (our-decls (car var))
            (temp-bindings `(,temp (%null-ptr)))
            (bindings `(,(car var) ,temp))
            (if (cdr var)
              (inits `(%setf-macptr ,temp ,@(cdr var)))))
          (progn
            (our-decls var)
            (temp-bindings  `(,temp  (%null-ptr)))
            (bindings `(,var ,temp))))))
  `(let* ,(temp-bindings)
    (declare (dynamic-extent ,@(temp-decls)))
    (declare (type macptr ,@(temp-decls)))
    ,@(inits)
    (let* ,(bindings)
      (declare (type macptr ,@(our-decls)))
      ,@other-decls
      ,@body)))))


(defmacro with-loading-file (filename &rest body)
   `(let ((*loading-files* (cons ,filename (locally (declare (special *loading-files*))
                                                    *loading-files*))))
      (declare (special *loading-files*))
      ,@body))

(defmacro with-input-from-string ((var string &key index start end) &body forms &environment env)
  "Create an input string stream, provide an opportunity to perform
operations on the stream (returning zero or more values), and then close
the string stream.

STRING is evaluated first, and VAR is bound to a character input string
stream that supplies characters from the subsequence of the resulting
string bounded by start and end. BODY is executed as an implicit progn."
  (multiple-value-bind (forms decls) (parse-body forms env nil)
    `(let ((,var
	    ,(cond ((null end)
		    `(make-string-input-stream ,string ,(or start 0)))
		   ((symbolp end)
		    `(if ,end
		      (make-string-input-stream ,string ,(or start 0) ,end)
		      (make-string-input-stream ,string ,(or start 0))))
		   (t
		    `(make-string-input-stream ,string ,(or start 0) ,end)))))
      ,@decls
      (unwind-protect
           (multiple-value-prog1
               (progn ,@forms)
             ,@(if index `((setf ,index (string-input-stream-index ,var)))))
        (close ,var)))))

(defmacro with-input-from-vector ((var vector &key index (start 0) end external-format) &body forms &environment env)
  (multiple-value-bind (forms decls) (parse-body forms env nil)
    `(let ((,var (%make-vector-input-stream ,vector ,start ,end ,external-format)))
      ,@decls
      (unwind-protect
           (multiple-value-prog1
               (progn ,@forms)
             ,@(if index `((setf ,index (vector-input-stream-index ,var)))))
        (close ,var)))))

(defmacro with-output-to-string ((var &optional string &key (element-type 'base-char element-type-p))
                                 &body body 
                                 &environment env)
  "Create a character output stream, perform a series of operations that
may send results to this stream, and then close the stream.  BODY is
executed as an implicit progn with VAR bound to an output string stream.
All output to that string stream is saved in a string."
  (let* ((string-p (not (null string))))
    (multiple-value-bind (forms decls) (parse-body body env nil)
      `(let* ((,var ,@(if string-p
                          `(,@(if element-type-p
                                   `((progn
                                       ,element-type
                                       (%make-string-output-stream ,string)))
                                   `((%make-string-output-stream ,string))))
                          `(,@(if element-type-p
                                   `((make-string-output-stream :element-type ,element-type))
                                   `((make-string-output-stream)))))))
        ,@decls
        (unwind-protect
             (progn
               ,@forms
               ,@(if string-p () `((get-output-stream-string ,var))))
          (close ,var))))))

(defmacro with-output-to-vector ((var &optional vector
				      &key (external-format :default))
				 &body body
				 &environment env)
  (let* ((vector-p (not (null vector))))
    (multiple-value-bind (forms decls) (parse-body body env nil)
      `(let* ((,var ,@(if vector-p
                          `((%make-vector-output-stream ,vector ,external-format))
                          `((make-vector-output-stream :external-format ,external-format)))))
         ,@decls
         (unwind-protect
              (progn
                ,@forms
                ,@(if vector-p () `((get-output-stream-vector ,var))))
           (close ,var))))))

(defmacro with-output-to-truncating-string-stream ((var len) &body body
						   &environment env)
  (multiple-value-bind (forms decls) (parse-body body env nil)
    `(let* ((,var (make-truncating-string-stream ,len)))
      ,@decls
      (unwind-protect
	   (progn
	     ,@forms
	     (values (get-output-stream-string ,var)
                     (truncating-string-output-stream-truncated-p ,var)))
	(close ,var)))))

(defmacro with-open-file ((var filename . args) &body body &aux (stream (gensym))(done (gensym)))
  "Use open to create a file stream to file named by filename. Filename is
the name of the file to be opened. Options are used as keyword arguments
to open."
  `(let (,stream ,done)
     (unwind-protect
       (multiple-value-prog1
         (let ((,var (setq ,stream (open ,filename ,@args))))
           ,@body)
         (setq ,done t))
       (when ,stream (close ,stream :abort (null ,done))))))

(defmacro with-compilation-unit ((&key override) &body body)
  "WITH-COMPILATION-UNIT ({Key Value}*) Form*
  This form affects compilations that take place within its dynamic extent. It
  is intended to be wrapped around the compilation of all files in the same
  system. These keywords are defined:
    :OVERRIDE Boolean-Form
        One of the effects of this form is to delay undefined warnings
        until the end of the form, instead of giving them at the end of each
        compilation. If OVERRIDE is NIL (the default), then the outermost
        WITH-COMPILATION-UNIT form grabs the undefined warnings. Specifying
        OVERRIDE true causes that form to grab any enclosed warnings, even if
        it is enclosed by another WITH-COMPILATION-UNIT."
  `(flet ((with-compilation-unit-body ()
            ,@body))
     (declare (dynamic-extent #'with-compilation-unit-body))
     (call-with-compilation-unit #'with-compilation-unit-body :override ,override)))

; Yow! Another Done Fun.
(defmacro with-standard-io-syntax (&body body &environment env)
  "Bind the reader and printer control variables to values that enable READ
   to reliably read the results of PRINT. These values are:
       *PACKAGE*                        the COMMON-LISP-USER package
       *PRINT-ARRAY*                    T
       *PRINT-BASE*                     10
       *PRINT-CASE*                     :UPCASE
       *PRINT-CIRCLE*                   NIL
       *PRINT-ESCAPE*                   T
       *PRINT-GENSYM*                   T
       *PRINT-LENGTH*                   NIL
       *PRINT-LEVEL*                    NIL
       *PRINT-LINES*                    NIL
       *PRINT-MISER-WIDTH*              NIL
       *PRINT-PRETTY*                   NIL
       *PRINT-RADIX*                    NIL
       *PRINT-READABLY*                 T
       *PRINT-RIGHT-MARGIN*             NIL
       *READ-BASE*                      10
       *READ-DEFAULT-FLOAT-FORMAT*      SINGLE-FLOAT
       *READ-EVAL*                      T
       *READ-SUPPRESS*                  NIL
       *READTABLE*                      the standard readtable"
  (multiple-value-bind (decls body) (parse-body body env)
    `(let ((*package* (pkg-arg "COMMON-LISP-USER"))
           (*print-array* t)
           (*print-base* 10.)
           (*print-case* :upcase)
           (*print-circle* nil)
           (*print-escape* t)
           (*print-gensym* t)
           (*print-length* nil)
           (*print-level* nil)
           (*print-lines* nil)
           (*print-miser-width* nil)
           (*print-pprint-dispatch* *standard-pprint-dispatch-table*)
           (*print-pretty* nil)
           (*print-radix* nil)
           (*print-readably* t)
           (*print-right-margin* nil)
           (*read-base* 10.)
           (*read-default-float-format* 'single-float)
           (*read-eval* t)
           (*read-suppress* nil)
           (*readtable* %standard-readtable%)
	   ;; ccl extensions (see l1-io.lisp)
	   (*print-abbreviate-quote* nil)
	   (*print-structure* t)
	   (*print-simple-vector* nil)
	   (*print-simple-bit-vector* nil)
	   (*print-string-length* nil))
      (declare (special *standard-pprint-dispatch-table*))
       ,@decls
       ,@body)))

(defmacro with-self-bound-io-control-vars (&body body)
  `(let (
         (*print-array* *print-array*)
         (*print-base* *print-base*)
         (*print-case* *print-case*)
         (*print-circle* *print-circle*)
         (*print-escape* *print-escape*)
         (*print-gensym* *print-gensym*)
         (*print-length* *print-length*)
         (*print-level* *print-level*)
         (*print-lines* *print-lines*)
         (*print-miser-width* *print-miser-width*)
         (*print-pprint-dispatch* *print-pprint-dispatch*)
         (*print-pretty* *print-pretty*)
         (*print-radix* *print-radix*)
         (*print-readably* *print-readably*)
         (*print-right-margin* *print-right-margin*)
         (*read-base* *read-base*)
         (*read-default-float-format* *read-default-float-format*)
         (*read-eval* *read-eval*)
         (*read-suppress* *read-suppress*)
         (*readtable* *readtable*))
     ,@body))

(defmacro print-unreadable-object (&environment env (object stream &key type identity) &body forms)
  "Output OBJECT to STREAM with \"#<\" prefix, \">\" suffix, optionally
  with object-type prefix and object-identity suffix, and executing the
  code in BODY to provide possible further output."
  (multiple-value-bind (body decls) (parse-body forms env)
    (if body
      (let ((thunk (gensym)))
        `(let ((,thunk #'(lambda () ,@decls ,@body)))
           (declare (dynamic-extent ,thunk))
          (%print-unreadable-object ,object ,stream ,type ,identity ,thunk)))
      `(%print-unreadable-object ,object ,stream ,type ,identity nil))))
;; Pointers and Handles

;;Add function to lisp system pointer functions, and run it if it's not already
;; there.
(defmacro def-ccl-pointers (name arglist &body body &aux (old (gensym)))
  `(flet ((,name ,arglist ,@body))
     (let ((,old (member ',name *lisp-system-pointer-functions* :key #'function-name)))
       (if ,old
         (rplaca ,old #',name)
         (progn
           (push #',name *lisp-system-pointer-functions*)
           (,name))))))

(defmacro def-load-pointers (name arglist &body body &aux (old (gensym)))
  `(flet ((,name ,arglist ,@body))
     (let ((,old (member ',name *lisp-user-pointer-functions* :key #'function-name)))
       (if ,old
         (rplaca ,old #',name)
         (progn
           (push #',name *lisp-user-pointer-functions*)
           (,name))))))

;Queue up some code to run after ccl all loaded up, or, if ccl is already
;loaded up, just run it right now.
(defmacro queue-fixup (&rest body &aux (fn (gensym)))
  `(let ((,fn #'(lambda () ,@body)))
     (if (eq %lisp-system-fixups% T)
       (funcall ,fn)
       (push (cons ,fn (or *loading-toplevel-location* *loading-file-source-file*)) %lisp-system-fixups%))))

(defmacro %incf-ptr (p &optional (by 1))
  (if (symbolp p)  ;once-only
    `(%setf-macptr (the macptr ,p) (%inc-ptr ,p ,by))
    (let ((var (gensym)))
      `(let ((,var ,p)) (%setf-macptr (the macptr ,var) (%inc-ptr ,var ,by))))))

(defmacro with-string-from-cstring ((s ptr) &body body)
  (let* ((len (gensym))
	 (p (gensym)))
    `(let* ((,p ,ptr)
	    (,len (%cstrlen ,p))
	    (,s (make-string ,len)))
      (declare (fixnum ,len))
      (%copy-ptr-to-ivector ,p 0 ,s 0 ,len)
      (locally
	  ,@body))))


(defmacro with-cstr ((sym str &optional start end) &rest body &environment env)
  (multiple-value-bind (body decls) (parse-body body env nil)
    (if (and (base-string-p str) (null start) (null end))
      (let ((strlen (%i+ (length str) 1)))
        `(%stack-block ((,sym ,strlen))
           ,@decls
           (%cstr-pointer ,str ,sym)
           ,@body))
      (let ((strname (gensym))
            (start-name (gensym))
            (end-name (gensym)))
        `(let ((,strname ,str)
               ,@(if (or start end)
                   `((,start-name ,(or start 0))
                     (,end-name ,(or end `(length ,strname))))))
           (%vstack-block (,sym
                           (the fixnum
                             (1+
                              (the fixnum
                                ,(if (or start end)
                                     `(byte-length
                                       ,strname ,start-name ,end-name)
                                     `(length ,strname))))))
             ,@decls
             ,(if (or start end)
                `(%cstr-segment-pointer ,strname ,sym ,start-name ,end-name)
                `(%cstr-pointer ,strname ,sym))
             ,@body))))))

(defmacro with-utf-8-cstr ((sym str) &body body)
  (let* ((data (gensym))
         (offset (gensym))
         (string (gensym))
         (len (gensym))
         (noctets (gensym))
         (end (gensym)))
    `(let* ((,string ,str)
            (,len (length ,string)))
      (multiple-value-bind (,data ,offset) (array-data-and-offset ,string)
        (let* ((,end (+ ,offset ,len))
               (,noctets (utf-8-octets-in-string ,data ,offset ,end)))
          (%stack-block ((,sym (1+ ,noctets)))
            (utf-8-memory-encode ,data ,sym 0 ,offset ,end)
            (setf (%get-unsigned-byte ,sym ,noctets) 0)
            ,@body))))))



(defmacro with-native-utf-16-cstr ((sym str) &body body)
  (let* ((data (gensym))
         (offset (gensym))
         (string (gensym))
         (len (gensym))
         (noctets (gensym))
         (end (gensym)))
    `(let* ((,string ,str)
            (,len (length ,string)))
      (multiple-value-bind (,data ,offset) (array-data-and-offset ,string)
        (let* ((,end (+ ,offset ,len))
               (,noctets (utf-16-octets-in-string ,data ,offset ,end)))
          (%stack-block ((,sym (1+ ,noctets)))
            (native-utf-16-memory-encode ,data ,sym 0 ,offset ,end)
            (setf (%get-unsigned-word ,sym ,noctets) 0)
            ,@body))))))

(defmacro with-encoding-problems-as-errors (&body body)
  `(handler-bind ((encoding-problem #'error))
    ,@body))

(defmacro with-decoding-problems-as-errors (&body body)
  `(handler-bind ((decoding-problem #'error))
    ,@body))

(defmacro with-pointers (speclist &body body)
   (with-specs-aux 'with-pointer speclist body))



(defmacro with-cstrs (speclist &body body)
   (with-specs-aux 'with-cstr speclist body))

(defmacro with-utf-8-cstrs (speclist &body body)
   (with-specs-aux 'with-utf-8-cstr speclist body))

(defmacro with-native-utf-16-cstrs (speclist &body body)
  (with-specs-aux 'with-native-utf-16-cstr speclist body))

(defmacro with-encoded-cstr ((encoding-name (sym string &optional start end))
                             &rest body &environment env)
  (let* ((encoding (gensym))
         (str (gensym)))
      (multiple-value-bind (body decls) (parse-body body env nil)
        `(let* ((,str ,string)
                (,encoding (get-character-encoding ,encoding-name)))
          (%stack-block ((,sym (cstring-encoded-length-in-bytes ,encoding ,str ,start ,end) :clear t))
            ,@decls
            (encode-string-to-memory ,encoding ,sym 0 ,str ,start ,end)
            ,@body)))))

(defmacro with-encoded-cstrs (encoding-name bindings &body body)
  (with-specs-aux 'with-encoded-cstr (mapcar #'(lambda (b)
                                                 `(,encoding-name ,b))
                                             bindings) body))

(defmacro with-filename-cstrs (&rest rest)
  (case (target-os-name)
    (:darwin `(with-utf-8-cstrs ,@rest))
    (:windows `(with-native-utf-16-cstrs ,@rest))
    (t `(with-encoded-cstrs (pathname-encoding-name) ,@rest))))


(defun with-specs-aux (name spec-list original-body)
  (multiple-value-bind (body decls) (parse-body original-body nil)
    (when decls (signal-program-error "declarations not allowed in ~s" original-body))
    (setq body (cons 'progn body))
    (dolist (spec (reverse spec-list))
      (setq body (list name spec body)))
    body))


(defmacro type-predicate (type)
  `(get-type-predicate ,type))

(defsetf type-predicate set-type-predicate)

(defun adjust-defmethod-lambda-list (ll)
  ;; If the lambda list contains &key, ensure that it also contains
  ;; &allow-other-keys
  (if (or (not (memq '&key ll))
          (memq '&allow-other-keys ll))
    ll
    (if (memq '&aux ll)
      (let* ((ll (copy-list ll))
             (aux (memq '&aux ll)))
        (setf (car aux) '&allow-other-keys
              (cdr aux) (cons '&aux (cdr aux)))
        ll)
      (append ll '(&allow-other-keys)))))

(defmacro defmethod (name &rest args &environment env)
  (let* ((method (gensym)))
    (multiple-value-bind (function-form specializers-form qualifiers lambda-list documentation specializers)
        (parse-defmethod name args env)
      `(progn
        (eval-when (:compile-toplevel)
          (record-function-info ',(maybe-setf-function-name name)
                                ',(multiple-value-bind (bits keyvect) (encode-lambda-list lambda-list t)
                                                       (unless bits;; verify failed
                                                         (signal-program-error "Invalid lambda list ~s"
                                                                               (find-if #'listp args)))
                                                       (%cons-def-info 'defmethod bits keyvect nil specializers qualifiers))
                                ,env))
        (compiler-let ((*nx-method-warning-name* '(,name ,@qualifiers ,specializers)))
          (let* ((,method (ensure-method ',name ,specializers-form
                                         :function ,function-form
                                         :qualifiers ',qualifiers
                                         :lambda-list ',lambda-list
                                         ,@(if documentation `(:documentation ,documentation)))))
            (record-source-file ,method 'method)
            ,method))))))


(defun seperate-defmethod-decls (decls)
  (let (outer inner)
    (dolist (decl decls)
      (if (neq (car decl) 'declare)
        (push decl outer)
        (let (outer-list inner-list)
          (dolist (d (cdr decl))
            (if (and (listp d) (eq (car d) 'dynamic-extent))
              (let (in out)
                (dolist (fspec (cdr d))
                  (if (and (listp fspec)
                           (eq (car fspec) 'function)
                           (listp (cdr fspec))
                           (null (cddr fspec))
                           (memq (cadr fspec) '(call-next-method next-method-p)))
                    (push fspec in)
                    (push fspec out)))
                (when out
                  (push `(dynamic-extent ,@(nreverse out)) outer-list))
                (when in
                  (push `(dynamic-extent ,@(nreverse in)) inner-list)))
              (push d outer-list)))
          (when outer-list
            (push `(declare ,@(nreverse outer-list)) outer))
          (when inner-list
            (push `(declare ,@(nreverse inner-list)) inner)))))
    (values (nreverse outer) (nreverse inner))))
		   

(defvar *warn-about-unreferenced-required-args-in-methods* t)

(defun parse-defmethod (name args env)
  (validate-function-name name)
  (let (qualifiers lambda-list parameters specializers specializers-form refs types temp)
    (until (listp (car args))
      (push (pop args) qualifiers))
    (setq lambda-list (pop args))
    (while (and lambda-list (not (memq (car lambda-list) lambda-list-keywords)))
      (let ((p (pop lambda-list)))
        (cond ((consp p)
               (unless (and (consp (%cdr p)) (null (%cddr p)))
                 (signal-program-error "Illegal arg ~S" p))
               (push (%car p) parameters)
               (push (%car p) refs)
               (setq p (%cadr p))
               (cond ((and (consp p) (eq (%car p) 'eql)
                           (consp (%cdr p)) (null (%cddr p)))
                      (push `(list 'eql ,(%cadr p)) specializers-form)
                      (push p specializers))
                     ((or (setq temp (non-nil-symbol-p p))
                          (specializer-p p))
                      (push `',p specializers-form)
                      (push p specializers)
                      (unless (or (eq p t) (not temp))
                        ;Should be `(guaranteed-type ...).
                        (push `(type ,p ,(%car parameters)) types)))
                     (t (signal-program-error "Illegal arg ~S" p))))
              (t
               (push p parameters)
               (unless *warn-about-unreferenced-required-args-in-methods*
                 (push p refs))
               (push t specializers-form)
               (push t specializers)))))
    (setq lambda-list (nreconc parameters lambda-list))
    (multiple-value-bind (body decls doc) (parse-body args env t)
      (multiple-value-bind (outer-decls inner-decls) 
                           (seperate-defmethod-decls decls)
        (let* ((methvar (make-symbol "NEXT-METHOD-CONTEXT"))
               (cnm-args (gensym))
               (lambda-form `(lambda ,(list* '&method methvar lambda-list)
                               (declare ;,@types
                                (ignorable ,@refs))
                               ,@outer-decls
                               (block ,(if (consp name) (cadr name) name)
                                 (flet ((call-next-method (&rest ,cnm-args)
                                          (declare (dynamic-extent ,cnm-args))
                                          (if ,cnm-args
                                            (apply #'%call-next-method-with-args ,methvar ,cnm-args)
                                            (%call-next-method ,methvar)))
                                        (next-method-p () (%next-method-p ,methvar)))
                                   (declare (inline call-next-method next-method-p))
                                   (declare (ftype (function (&rest t)) ,name))
                                   ,@inner-decls
                                   ,@body)))))
          (values
           (if name `(nfunction ,name ,lambda-form) `(function ,lambda-form))
           `(list ,@(nreverse specializers-form))
           (nreverse qualifiers)
	   lambda-list
           doc
           (nreverse specializers)))))))

(defmacro anonymous-method (name &rest args &environment env)
  (multiple-value-bind (function-form specializers-form qualifiers method-class documentation)
                       (parse-defmethod name args env)
    
    `(%anonymous-method
      ,function-form
      ,specializers-form
      ',qualifiers
      ,@(if (or method-class documentation) `(',method-class))
      ,@(if documentation `(,documentation)))))



(defmacro defclass (class-name superclasses slots &rest class-options &environment env)
  (flet ((duplicate-options (where) (signal-program-error "Duplicate options in ~S" where))
         (illegal-option (option) (signal-program-error "Illegal option ~s" option))
         (make-initfunction (form)
           (cond ((or (eq form 't)
                      (equal form ''t))
                  '(function true))
                 ((or (eq form 'nil)
                      (equal form ''nil))
                  '(function false))
                 (t
                  `(function (lambda () ,form))))))
    (setq class-name (require-type class-name '(and symbol (not null))))
    (setq superclasses (mapcar #'(lambda (s) (require-type s 'symbol)) superclasses))
    (let* ((options-seen ())
           (signatures ())
           (slot-names ()))
      (flet ((canonicalize-defclass-option (option)
               (let* ((option-name (car option)))
                 (if (member option-name options-seen :test #'eq)
                   (duplicate-options class-options)
                   (push option-name options-seen))
                 (case option-name
                   (:default-initargs
                       (let ((canonical ())
                             (initargs-seen ()))
                         (let (key val (tail (cdr option)))
                           (loop (when (null tail) (return nil))
                              (setq key (pop tail)
                                    val (pop tail))
                              (when (memq key initargs-seen)
                                (SIGNAL-PROGRAM-error "Duplicate initialization argument name ~S in :DEFAULT-INITARGS of DEFCLASS ~S" key class-name))
                              (push key initargs-seen)
                              (push ``(,',key ,',val  ,,(make-initfunction val)) canonical))
                           `(':direct-default-initargs (list ,@(nreverse canonical))))))
                   (:metaclass
                    (unless (and (cadr option)
                                 (typep (cadr option) 'symbol))
                      (illegal-option option))
                    `(:metaclass  ',(cadr option)))
                   (:documentation
                    `(:documentation ',(cadr option)))
                   (t
                     (list `',option-name `',(cdr option))))))
             (canonicalize-slot-spec (slot)
               (if (null slot) (signal-program-error "Illegal slot NIL"))
               (if (not (listp slot)) (setq slot (list slot)))
               (let* ((slot-name (require-type (car slot) 'symbol))
		      (initargs nil)
                      (other-options ())
		      (initform nil)
		      (initform-p nil)
		      (initfunction nil)
		      (type nil)
		      (type-p nil)
		      (allocation nil)
		      (allocation-p nil)
		      (documentation nil)
		      (documentation-p nil)
                      (readers nil)
		      (writers nil)
                      (reader-info (%cons-def-info 'defmethod (dpb 1 $lfbits-numreq 0) nil nil (list class-name)))
                      (writer-info (%cons-def-info 'defmethod (dpb 2 $lfbits-numreq 0) nil nil (list t class-name))))
                 (when (memq slot-name slot-names)
                   (signal-program-error "Multiple slots named ~S in DEFCLASS ~S" slot-name class-name))
                 (push slot-name slot-names)
                 (do ((options (cdr slot) (cddr options))
                      name)
                     ((null options))
                   (when (null (cdr options)) (signal-program-error "Illegal slot spec ~S" slot))
                   (case (car options)
                     (:reader
                      (setq name (cadr options))
                      (unless (memq name readers)
                        (push (cons name reader-info) signatures)
                        (push name readers)))
                     (:writer                      
                      (setq name (cadr options))
                      (unless (member name writers :test 'equal)
                        (push (cons name writer-info) signatures)
                        (push name writers)))
                     (:accessor
                      (setq name (cadr options))
                      (unless (memq name readers)
                        (push (cons name reader-info) signatures)
                        (push name readers))
                      (let ((setf-name `(setf ,name)))
                        (unless (member setf-name writers :test 'equal)
                          (push (cons (setf-function-name name) writer-info) signatures)
                          (push setf-name writers))))
                     (:initarg
		      (push (require-type (cadr options) 'symbol) initargs))
                     (:type
                      (if type-p
			(duplicate-options slot)
			(setq type-p t))
                      (setq type (cadr options))
                      ;; complain about illegal typespecs and continue
                      (handler-case (specifier-type type env)
                        (program-error ()
                          (warn "Invalid type ~s in ~s slot definition ~s" type class-name slot))))
                     (:initform
                      (if initform-p
			(duplicate-options slot)
			(setq initform-p t))
                      (let ((option (cadr options)))
                        (setq initform `',option
                              initfunction
                              (if (constantp option)
                                `(constantly ,option)
                                `#'(lambda () ,option)))))
                     (:allocation
                      (if allocation-p
			(duplicate-options slot)
			(setq allocation-p t))
                      (setq allocation (cadr options)))
                     (:documentation
                      (if documentation-p
			(duplicate-options slot)
			(setq documentation-p t))
                      (setq documentation (cadr options)))
                     (t
                      (let* ((pair (or (assq (car options) other-options)
                                       (car (push (list (car options)) other-options)))))
                        (push (cadr options) (cdr pair))))))
                 `(list :name ',slot-name
		   ,@(when allocation `(:allocation ',allocation))
		   ,@(when initform-p `(:initform ,initform
					:initfunction ,initfunction))
		   ,@(when initargs `(:initargs ',initargs))
		   ,@(when readers `(:readers ',readers))
		   ,@(when writers `(:writers ',writers))
		   ,@(when type-p `(:type ',type))
		   ,@(when documentation-p `(:documentation ,documentation))
                   ,@(mapcan #'(lambda (opt)
                                 `(',(car opt) ',(if (null (cddr opt))
                                                     (cadr opt)
                                                     (cdr opt)))) other-options)))))
	(let* ((direct-superclasses superclasses)
	       (direct-slot-specs (mapcar #'canonicalize-slot-spec slots))
	       (other-options (apply #'append (mapcar #'canonicalize-defclass-option class-options )))
	       (keyvect (class-keyvect class-name other-options)))
	  (when (vectorp keyvect)
	    (let ((illegal (loop for arg in other-options by #'cddr
			      as key = (if (quoted-form-p arg) (%cadr arg) arg)
			      unless (or (eq key :metaclass) (find key keyvect)) collect key)))
	      (when illegal
		(signal-program-error "Class option~p~{ ~s~} is not one of ~s"
				      (length illegal) illegal (coerce keyvect 'list)))))
	  `(progn
	     (when (memq ',class-name *nx-known-declarations*)
	       (check-declaration-redefinition ',class-name 'defclass))
	    (eval-when (:compile-toplevel)
	      (%compile-time-defclass ',class-name ,env)
	      (progn
		,@(mapcar #'(lambda (sig) `(record-function-info ',(car sig) ',(cdr sig) ,env))
			  signatures)))
	      (ensure-class-for-defclass ',class-name
			    :direct-superclasses ',direct-superclasses
			    :direct-slots ,`(list ,@direct-slot-specs)
			    ,@other-options)))))))

(defmacro define-method-combination (name &rest rest &environment env)
  (setq name (require-type name 'symbol))
  (cond ((or (null rest) (and (car rest) (symbolp (car rest))))
         `(short-form-define-method-combination ',name ',rest))
        ((listp (car rest))
         (destructuring-bind (lambda-list method-group-specifiers . forms) rest
           (long-form-define-method-combination 
            name lambda-list method-group-specifiers forms env)))
        (t (%badarg (car rest) '(or (and null symbol) list)))))

(defmacro defgeneric (function-name lambda-list &rest options-and-methods &environment env)
  (fboundp function-name)             ; type-check
  (multiple-value-bind (method-combination generic-function-class options methods)
      (parse-defgeneric function-name t lambda-list options-and-methods)
    (let ((gf (gensym)))
      `(progn
         (eval-when (:compile-toplevel)
           (record-function-info ',(maybe-setf-function-name function-name)
                                 ',(multiple-value-bind (bits keyvect) (encode-lambda-list lambda-list t)
                                     (%cons-def-info 'defgeneric bits keyvect))
                                 ,env))
         (let ((,gf (%defgeneric
                     ',function-name ',lambda-list ',method-combination ',generic-function-class 
                     ',(apply #'append options))))
           (%set-defgeneric-methods ,gf ,@methods)
           ,gf)))))



(defun parse-defgeneric (function-name global-p lambda-list options-and-methods)
  (check-generic-function-lambda-list lambda-list)
  (let ((method-combination '(standard))
        (generic-function-class 'standard-generic-function)
        options declarations methods option-keywords method-class)
    (flet ((bad-option (o)
             (signal-program-error "Bad option: ~s to ~s." o 'defgeneric)))
      (dolist (o options-and-methods)
        (let ((keyword (car o))
              (defmethod (if global-p 'defmethod 'anonymous-method)))
          (if (eq keyword :method)
	    (let ((defn `(,defmethod ,function-name ,@(%cdr o))))
	      (note-source-transformation o defn)
	      (push defn methods))
            (cond ((and (not (eq keyword 'declare))
			(memq keyword (prog1 option-keywords (push keyword option-keywords))))		   
                   (signal-program-error "Duplicate option: ~s to ~s" keyword 'defgeneric))
                  ((eq keyword :method-combination)
                   (unless (symbolp (cadr o))
                     (bad-option o))
                   (setq method-combination (cdr o)))
                  ((eq keyword :generic-function-class)
                   (unless (and (cdr o) (symbolp (cadr o)) (null (%cddr o)))
                     (bad-option o))
                   (setq generic-function-class (%cadr o)))
                  ((eq keyword 'declare)
		   (push (cadr o) declarations))
                  ((eq keyword :argument-precedence-order)
                   (dolist (arg (cdr o))
                     (unless (and (symbolp arg) (memq arg lambda-list))
                       (bad-option o)))
                   (push (list keyword (cdr o)) options))
                  ((eq keyword :method-class)
                   (push o options)
                   (when (or (cddr o) (not (symbolp (setq method-class (%cadr o)))))
                     (bad-option o)))
                  ((eq keyword :documentation)
                   (push o options)
                   (when (or (cddr o) (not (stringp (%cadr o))))
                     (bad-option o)))
                  (t (bad-option o)))))))
    (when method-class
      (dolist (m methods)
        (push `(:method-class ,method-class) (cddr m))))
    (when declarations
      (setq options `((:declarations ,declarations) ,@options)))
    (values method-combination generic-function-class options methods)))

                 
(defmacro def-aux-init-functions (class &rest functions)
  `(set-aux-init-functions ',class (list ,@functions)))






;;; A powerful way of defining REPORT-CONDITION...
;;; Do they really expect that each condition type has a unique method on PRINT-OBJECT
;;; which tests *print-escape* ?  Scary if so ...

(defmacro define-condition (name (&rest supers) (&rest slots) &body options)
  ;; If we could tell what environment we're being expanded in, we'd
  ;; probably want to check to ensure that all supers name conditions
  ;; in that environment.
  (let ((classopts nil)
        (duplicate nil)
        (docp nil)
	(default-initargs-p nil)
        (reporter nil))
    (dolist (option options)
      (unless (and (consp option)
                   (consp (%cdr option)))
        (signal-program-error "Invalid option ~s ." option))
      (ecase (%car option)
	(:default-initargs 
	    (unless (plistp (cdr option)) 
	      (signal-program-error "~S is not a plist." (%cdr option))) 
	    (if default-initargs-p 
	      (setq duplicate t) 
	      (push (setq default-initargs-p option) classopts))) 
        (:documentation 
	 (unless (null (%cddr option)) 
	   (signal-program-error "Invalid option ~s ." option)) 
	 (if docp
	   (setq duplicate t)
           (push (setq docp option) classopts)))
        (:report 
	 (unless (null (%cddr option)) 
	   (signal-program-error "Invalid option ~s ." option)) 
         (if reporter
           (setq duplicate t)
           (progn
             (if (or (lambda-expression-p (setq reporter (%cadr option)))
                     (symbolp reporter))
               (setq reporter `(function ,reporter))
               (if (stringp reporter)
                 (setq reporter `(function (lambda (c s) (declare (ignore c)) (write-string ,reporter s))))
                 (signal-program-error "~a expression is not a string, symbol, or lambda expression ." (%car option))))
             (setq reporter `((defmethod report-condition ((c ,name) s)
                                (funcall ,reporter c s))))))))
      (if duplicate (signal-program-error "Duplicate option ~s ." option)))
    `(progn
      ,@(when supers `((eval-when (:load-toplevel :execute)
                         (check-condition-superclasses ',name ',supers))))
      (defclass ,name ,(or supers '(condition)) ,slots ,@classopts)
      ,@reporter
      ',name)))

(defmacro with-condition-restarts (&environment env condition restarts &body body)
  "Evaluates the BODY in a dynamic environment where the restarts in the list
   RESTARTS-FORM are associated with the condition returned by CONDITION-FORM.
   This allows FIND-RESTART, etc., to recognize restarts that are not related
   to the error currently being debugged. See also RESTART-CASE."
  (multiple-value-bind (body decls)
                       (parse-body body env)
    (let ((cond (gensym))
          (r (gensym)))
          `(let* ((*condition-restarts* *condition-restarts*))
             ,@decls
             (let ((,cond ,condition))
               (dolist (,r ,restarts) (push (cons ,r ,cond) *condition-restarts*))
               ,@body)))))
  
(defmacro setf-find-class (name arg1 &optional (arg2 () 2-p) (arg3 () 3-p))
  (cond (3-p ;might want to pass env (arg2) to find-class someday?
         `(set-find-class ,name (progn ,arg1 ,arg2 ,arg3)))
        (2-p
         `(set-find-class ,name (progn ,arg1 ,arg2)))
        (t `(set-find-class ,name ,arg1))))

(defsetf find-class setf-find-class)

(defmacro restoring-interrupt-level (var &body body)
  `(unwind-protect
    (progn ,@body)
    (restore-interrupt-level ,var)
    (%interrupt-poll)))

(defmacro without-interrupts (&body body)
  "Evaluate its body in an environment in which process-interrupt
requests are deferred."
  `(let* ((*interrupt-level* -1))
    ,@body))

(defmacro with-interrupts-enabled (&body body)
  "Evaluate its body in an environment in which process-interrupt
has immediate effect."
  `(let* ((*interrupt-level* 0))
    ,@body))

;;; undoes the effect of one enclosing without-interrupts during execution of body.
(defmacro ignoring-without-interrupts (&body body)
  `(let* ((*interrupt-level* 0))
    ,@body))



(defmacro error-ignoring-without-interrupts (format-string &rest format-args)
  `(ignoring-without-interrupts
    (error ,format-string ,@format-args)))


;init-list-default: if there is no init pair for <keyword>,
;    add a <keyword> <value> pair to init-list
(defmacro init-list-default (the-init-list &rest args)
  (let ((result)
       (init-list-sym (gensym)))
   (do ((args args (cddr args)))
       ((not args))
     (setq result 
           (cons `(if (eq '%novalue (getf ,init-list-sym ,(car args) 
                                          '%novalue))
                    (setq ,init-list-sym (cons ,(car args) 
                                               (cons ,(cadr args) 
                                                     ,init-list-sym))))
                 result)))                                                                                
   `(let ((,init-list-sym ,the-init-list))
      (progn ,@result)
      ,init-list-sym)
   ))

; This can only be partially backward-compatible: even if only
; the "name" arg is supplied, the old function would create the
; package if it didn't exist.
; Should see how well this works & maybe flush the whole idea.

(defmacro in-package (name)
  (let ((form nil))
    (when (quoted-form-p name)
      (warn "Unquoting argument ~S to ~S." name 'in-package )
      (setq name (cadr name)))    
    (setq form `(set-package ,(string name)))
    `(eval-when (:execute :load-toplevel :compile-toplevel)
      ,form)))

(defmacro defpackage (name &rest options)
  "Defines a new package called PACKAGE. Each of OPTIONS should be one of the 
   following: 
    (:NICKNAMES {package-name}*)
    (:SIZE <integer>)
    (:EXTERNAL-SIZE <integer>)
    (:SHADOW {symbol-name}*)
    (:SHADOWING-IMPORT-FROM <package-name> {symbol-name}*)
    (:USE {package-name}*)
    (:IMPORT-FROM <package-name> {symbol-name}*)
    (:INTERN {symbol-name}*)
    (:EXPORT {symbol-name}*)
    (:DOCUMENTATION doc-string)
   All options except SIZE and DOCUMENTATION can be used multiple 
   times."
  (let* ((size nil)
         (all-names-size 0)
         (intern-export-size 0)
         (shadow-etc-size 0)
	 (documentation nil)
         (all-names-hash (let ((all-options-alist nil))
                           (dolist (option options)
                             (let ((option-name (car option)))
                               (when (memq option-name
                                           '(:nicknames :shadow :shadowing-import-from
                                             :use :import-from :intern :export))
                                 (let ((option-size (length (cdr option)))
                                       (cell (assq option-name all-options-alist)))
                                   (declare (fixnum option-size))
                                   (if cell
                                     (incf (cdr cell) option-size)
                                     (push (cons option-name option-size) all-options-alist))
                                   (when (memq option-name '(:shadow :shadowing-import-from :import-from :intern))
                                     (incf shadow-etc-size option-size))
                                   (when (memq option-name '(:export :intern))
                                     (incf intern-export-size option-size))))))
                           (dolist (cell all-options-alist)
                             (let ((option-size (cdr cell)))
                               (when (> option-size all-names-size)
                                 (setq all-names-size option-size))))
                           (when (> all-names-size 0)
                             (make-hash-table :test 'equal :size all-names-size))))
         (intern-export-hash (when (> intern-export-size 0)
                               (make-hash-table :test 'equal :size intern-export-size)))
         (shadow-etc-hash (when (> shadow-etc-size 0)
                            (make-hash-table :test 'equal :size shadow-etc-size)))
         (external-size nil)
         (nicknames nil)
         (shadow nil)
         (shadowing-import-from-specs nil)
         (use :default)
         (import-from-specs nil)
         (intern nil)
         (export nil))
    (declare (fixnum all-names-size intern-export-size shadow-etc-size))
    (labels ((string-or-name (s) (string s))
             (duplicate-option (o)
               (signal-program-error "Duplicate ~S option in ~S ." o options))
             (duplicate-name (name option-name)
               (signal-program-error "Name ~s, used in ~s option, is already used in a conflicting option ." name option-name))
             (all-names (option-name tail already)
               (when (eq already :default) (setq already nil))
               (when all-names-hash
                 (clrhash all-names-hash))
               (dolist (name already)
                 (setf (gethash (string-or-name name) all-names-hash) t))
               (dolist (name tail already)
                 (setq name (string-or-name name))
                 (unless (gethash name all-names-hash)          ; Ok to repeat name in same option.
                   (when (memq option-name '(:shadow :shadowing-import-from :import-from :intern))
                     (if (gethash name shadow-etc-hash)
                       (duplicate-name name option-name))
                     (setf (gethash name shadow-etc-hash) t))
                   (when (memq option-name '(:export :intern))
                     (if (gethash name intern-export-hash)
                       (duplicate-name name option-name))
                     (setf (gethash name intern-export-hash) t))
                   (setf (gethash name all-names-hash) t)
                   (push name already)))))
      (dolist (option options)
        (let ((args (cdr option)))
          (ecase (%car option)
                 (:size 
                  (if size 
                    (duplicate-option :size) 
                    (setq size (car args))))		 
                 (:external-size 
                  (if external-size 
                    (duplicate-option :external-size) 
                    (setq external-size (car args))))
                 (:nicknames (setq nicknames (all-names nil args nicknames)))
                 (:shadow (setq shadow (all-names :shadow args shadow)))
                 (:shadowing-import-from
                  (destructuring-bind (from &rest shadowing-imports) args
                    (push (cons (string-or-name from)
                                (all-names :shadowing-import-from shadowing-imports nil))
                          shadowing-import-from-specs)))
                 (:use (setq use (all-names nil args use)))
                 (:import-from
                  (destructuring-bind (from &rest imports) args
                    (push (cons (string-or-name from)
                                (all-names :import-from imports nil))
                          import-from-specs)))
                 (:intern (setq intern (all-names :intern args intern)))
                 (:export (setq export (all-names :export args export)))
		 (:documentation
		  (if documentation
		    (duplicate-option :documentation)
		    (setq documentation (cadr option)))))))
      `(eval-when (:execute :compile-toplevel :load-toplevel)
         (%define-package ',(string-or-name name)
	  ',size 
	  ',external-size 
	  ',nicknames
	  ',shadow
	  ',shadowing-import-from-specs
	  ',use
	  ',import-from-specs
	  ',intern
	  ',export
	  ',documentation)))))



(defmacro with-package-iterator ((mname package-list first-type &rest other-types)
                                 &body body)
  "Within the lexical scope of the body forms, MNAME is defined via macrolet
   such that successive invocations of (MNAME) will return the symbols,
   one by one, from the packages in PACKAGE-LIST. SYMBOL-TYPES may be
   any of :INHERITED :EXTERNAL :INTERNAL."
  (setq mname (require-type mname 'symbol))
  (let ((state (make-symbol "WITH-PACKAGE-ITERATOR_STATE")))
    (dolist (type (push first-type other-types))
      (ecase type
        ((:external :internal :inherited))))
    `(let ((,state (%setup-pkg-iter-state ,package-list ',other-types)))
       (macrolet ((,mname () `(%pkg-iter-next ,',state)))
         ,@body))))

; Does NOT evaluate the constructor, but DOES evaluate the destructor & initializer
(defmacro defresource (name &key constructor destructor initializer)
  `(defparameter ,name (make-resource #'(lambda () ,constructor)
                                      ,@(when destructor
                                          `(:destructor ,destructor))
                                      ,@(when initializer
                                          `(:initializer ,initializer)))))

(defmacro using-resource ((var resource) &body body)
  (let ((resource-var (gensym)))
  `(let ((,resource-var ,resource)
         ,var)
     (unwind-protect
       (progn
         (setq ,var (allocate-resource ,resource-var))
         ,@body)
       (when ,var
         (free-resource ,resource-var ,var))))))

;;; Bind per-thread specials which help with lock accounting.
(defmacro with-lock-context (&body body)
  `(progn ,@body))

(defmacro with-lock-grabbed ((lock &optional
                                   (whostate "Lock"))
                             &body body)
  "Wait until a given lock can be obtained, then evaluate its body with
the lock held."
  (declare (ignore whostate))
  (let* ((locked (gensym))
         (l (gensym)))
    `  (with-lock-context
         (let ((,locked (make-lock-acquisition))
               (,l ,lock))
           (declare (dynamic-extent ,locked))
           (unwind-protect
                (progn
                  (%lock-recursive-lock-object ,l ,locked )
                  ,@body)
             (when (lock-acquisition.status ,locked) (%unlock-recursive-lock-object ,l)))))))

 
(defmacro with-exception-lock (&body body)
  `(with-lock-grabbed (*kernel-exception-lock*)
    ,@body))


(defmacro with-lock-grabbed-maybe ((lock &optional
					 (whostate "Lock"))
				   &body body)
  (declare (ignore whostate))
  (let* ((l (gensym)))
    `(with-lock-context
      (let* ((,l ,lock))
        (when (%try-recursive-lock-object ,l)
          (unwind-protect
               (progn ,@body)
            (%unlock-recursive-lock-object ,l)))))))

(defmacro with-standard-abort-handling (abort-message &body body)
  (let ((stream (gensym)))
    `(restart-case
       (catch :abort
         (catch-cancel
           ,@body))
       (abort () ,@(when abort-message
                     `(:report (lambda (,stream)
                                 (write-string ,abort-message ,stream)))))
       (abort-break ()))))
       



(defmacro %lexpr-count (l)
  `(%lisp-word-ref ,l 0))

(defmacro %lexpr-ref (lexpr count i)
  `(%lisp-word-ref ,lexpr (%i- ,count ,i)))

;;; args will be list if old style clos
(defmacro apply-with-method-context (magic function args)
  (let ((m (gensym))
        (f (gensym))
        (as (gensym)))
      `((lambda (,m ,f ,as)
          (if (listp ,as)
            (%apply-with-method-context ,m ,f ,as)
            (%apply-lexpr-with-method-context ,m ,f ,as))) ,magic ,function ,args)))

(defmacro defcallback (name arglist &body body &environment env)
  "Proclaim name to be a special variable; sets its value to a MACPTR which,
when called by foreign code, calls a lisp function which expects foreign
arguments of the specified types and which returns a foreign value of the
specified result type. Any argument variables which correspond to foreign
arguments of type :ADDRESS are bound to stack-allocated MACPTRs.

If name is already a callback function pointer, its value is not changed;
instead, it's arranged that an updated version of the lisp callback function
will be called. This feature allows for callback functions to be redefined
incrementally, just like Lisp functions are.

defcallback returns the callback pointer, e.g., the value of name."
  (define-callback name arglist body env))

(declare-arch-specific-macro %get-single-float-from-double-ptr)

(declare-arch-specific-macro lfun-vector)
(declare-arch-specific-macro lfun-vector-lfun)

(declare-arch-specific-macro symptr->symvector)
(declare-arch-specific-macro symvector->symptr)

(declare-arch-specific-macro function-to-function-vector)
(declare-arch-specific-macro function-vector-to-function)

(declare-arch-specific-macro with-ffcall-results)

(defvar *trace-print-functions* nil)
(defun %trace-print-arg (stream arg val type)
  (format stream " ")
  (let ((fn (assoc type *trace-print-functions*)))
    (if fn
      (funcall (cdr fn) stream arg val)
      (progn
      (when arg
        (format stream "~A = " arg))
      (if (and type (not (eq type :void)))
          (format stream "[:~A] ~A~%" type val)
        (format stream ":VOID~%"))))))

(defun def-trace-print-function (type fn)
  (push (cons type fn) *trace-print-functions*))

(defun define-callback (name args body env)
  (let* ((stack-word (gensym))
         (stack-ptr (gensym))
         (fp-args-ptr (gensym))
         (result-type-spec :void)
         (args args)
         (discard-stack-args nil)	;only meaningful on win32
	 (discard-hidden-arg nil)	;only meaningful on x8632
	 (info nil)
         (woi nil)
         (need-struct-arg)
         (struct-return-arg-name)
         (error-return nil)
         (propagate-throw nil))
    (collect ((arg-names)
              (arg-specs))
      (let* ((spec (car (last args)))
             (rtype (ignore-errors (parse-foreign-type spec))))
        (setq need-struct-arg (typep rtype 'foreign-record-type))
	(when need-struct-arg
	  (setq discard-hidden-arg
		(funcall (ftd-ff-call-struct-return-by-implicit-arg-function
			  *target-ftd*) rtype)))
        (if rtype
          (setq result-type-spec spec args (butlast args))))
      (loop
        (when (null args) (return))
        (if (eq (car args) :without-interrupts)
          (setq woi (cadr args) args (cddr args))
          (if (eq (car args) :discard-stack-args)
            (setq discard-stack-args (eq (backend-target-os *target-backend*) :win32) args (cdr args))
            (if (eq (car args) :error-return)
              (setq error-return
                    (cadr args)                  
                    args (cddr args))
              (if (eq (car args) :propagate-throw)
                (setq propagate-throw (cadr args)
                      args (cddr args))
                (if need-struct-arg
                  (setq struct-return-arg-name (pop args) need-struct-arg nil)
                  (progn
                    (arg-specs (pop args))
                    (arg-names (pop args)))))))))
      (when (and error-return propagate-throw)
        (error "Can't specify both :ERROR-RETURN and :PROPAGATE-THROW in callback definition for ~s." name))
      (multiple-value-bind (rlets lets dynamic-extent-names inits foreign-return-type fp-args-form error-return-offset num-arg-bytes)
          (funcall (ftd-callback-bindings-function *target-ftd*)
                   stack-ptr fp-args-ptr (arg-names) (arg-specs) result-type-spec struct-return-arg-name)
	;; x8632 hair
	(when discard-hidden-arg
	  (if discard-stack-args
	    ;; We already have to discard some number of args, so just
	    ;; discard the extra hidden arg while we're at it.
	    (incf num-arg-bytes 4)
	    ;; Otherwise, indicate that we'll need to discard the
	    ;; hidden arg.
	    (setq info (ash 1 23))))
	(when discard-stack-args
	  (setq info 0)
	  ;; put number of words to discard in high-order byte
	  (setf (ldb (byte 8 24) info)
		(ash num-arg-bytes (- target::word-shift))))
        (multiple-value-bind (body decls doc) (parse-body body env t)
          `(progn
            (declaim (special ,name))
            (define-callback-function
                (nfunction ,name
                 (lambda (,stack-word)
                   (declare (ignorable ,stack-word))
                   (block ,name
                     (with-macptrs ((,stack-ptr))
                       (%setf-macptr-to-object ,stack-ptr ,stack-word)
                       (with-macptrs (,@(when fp-args-form
                                              `((,fp-args-ptr ,fp-args-form))))
                         ,(defcallback-body stack-ptr
                                            fp-args-ptr
                                            lets
                                            rlets
                                            inits
                                            `(declare (dynamic-extent ,@dynamic-extent-names))
                                            decls
                                            body
                                            foreign-return-type
                                            struct-return-arg-name
                                            error-return
                                            error-return-offset
                                            propagate-throw
                                            ))))))
                ,doc
              ,woi
              ,info)))))))


(defun defcallback-body (&rest args)
  (declare (dynamic-extent args))
  (destructuring-bind (stack-ptr fp-args-ptr lets rlets inits dynamic-extent-decls other-decls body return-type struct-return-arg error-return error-delta propagate-throw) args
    (declare (ignorable dynamic-extent-decls))
    (let* ((condition-name (if (atom error-return) 'error (car error-return)))
           (error-return-function (if (atom error-return) error-return (cadr error-return)))
           (result (if struct-return-arg (gensym)))
           (body
            `(rlet ,rlets
              (let* ,lets
                ,dynamic-extent-decls
                ,@other-decls
                ,@inits
                ,(if result
                     `(let* ((,result ,@body))
                       (declare (dynamic-extent ,result)
                                (ignorable ,result))
                       ,(funcall (ftd-callback-return-value-function *target-ftd*)
                              stack-ptr
                              fp-args-ptr
                              result
                              return-type
                              struct-return-arg))
                     (if (eq return-type *void-foreign-type*)
                       `(progn ,@body)
                       (funcall (ftd-callback-return-value-function *target-ftd*)
                                stack-ptr
                                fp-args-ptr
                                `(progn ,@body)
                                return-type
                                struct-return-arg)))
                nil))))
      (if error-return
        (let* ((cond (gensym))
               (block (gensym))
               (handler (gensym)))
          `(block ,block
            (let* ((,handler (lambda (,cond)
                               (,error-return-function ,cond ,stack-ptr (%inc-ptr ,stack-ptr ,error-delta))
                               (return-from ,block
                                 nil))))
              (declare (dynamic-extent ,handler))
              (handler-bind ((,condition-name ,handler))
                (values ,body)))))
        (if propagate-throw
          (let* ((throw-context (gensym))
                 (block (gensym)))
            `(block ,block
              (unwind-protect
                   (progn ,body)
                (let* ((,throw-context (%throwing-through-cleanup-p)))
                  (when ,throw-context
                    (,propagate-throw ,throw-context ,stack-ptr (%inc-ptr ,stack-ptr ,error-delta))
                    (return-from ,block nil))))))
          body)))))


(defmacro define-toplevel-command (group-name name arglist &body body &environment env)
  (let* ((key (make-keyword name)))
    (multiple-value-bind (body decls doc) (parse-body body env)
      `(%define-toplevel-command ',group-name ,key ',name 
	(nfunction ,name (lambda ,arglist
			   ,@decls
			   (block ,name
			     ,@body)))
	,doc
        ',(mapcar #'symbol-name arglist)))))

(defmacro with-toplevel-commands (group-name &body body)
  `(let* ((*active-toplevel-commands* *active-toplevel-commands*))
    (progn
      (%use-toplevel-commands ',group-name)
      ,@body)))

(defmacro assert (test-form &optional (places ()) string &rest args)
  "ASSERT Test-Form [(Place*) [String Arg*]]
  If the Test-Form is not true, then signal a correctable error.  If Places
  are specified, then new values are prompted for when the error is proceeded.
  String and Args are the format string and args to the error call."
  (let* ((TOP (gensym))
         (setf-places-p (not (null places))))
    `(without-compiling-code-coverage
      (tagbody
       ,TOP
       (unless ,test-form
         (%assertion-failure ,setf-places-p ',test-form ,string ,@args)
         ,@(if places
             `((write-line "Type expressions to set places to, or nothing to leave them alone."
                           *query-io*)
               ,@(mapcar #'(lambda (place &aux (new-val (gensym))
                                          (set-p (gensym)))
                             `(multiple-value-bind
                                (,new-val ,set-p)
                                (assertion-value-prompt ',place)
                                (when ,set-p (setf ,place (values-list ,new-val)))))
                         places)))
         (go ,TOP))))))


(defmacro check-type (place typespec &optional string)
  "CHECK-TYPE Place Typespec [String]
  Signal a restartable error of type TYPE-ERROR if the value of PLACE is
  not of the specified type. If an error is signalled and the restart is
  used to return, this can only return if the STORE-VALUE restart is
  invoked. In that case it will store into PLACE and start over."
  (let* ((val (gensym)))
    `(without-compiling-code-coverage
      (do* ((,val ,place ,place))
          ((typep ,val ',typespec))
       (setf ,place (%check-type ,val ',typespec ',place ,string))))))

(defmacro typecheck (object typespec &environment env)
  (cond ((eq typespec 't)
         object)
        ((nx-inhibit-safety-checking env)
         `(the ,typespec ,object))
        (t
        `(require-type ,object ',(nx1-typespec-for-typep typespec env
							  :whine nil)))))

(defmacro structure-typecheck (struct typespec &environment env)
  (if (nx-strict-structure-typechecking env)
    `(require-type ,struct ',(nx1-typespec-for-typep typespec env
							  :whine nil))
    `(the ,typespec ,struct)))
      

(defmacro with-hash-table-iterator ((mname hash-table) &body body)
  "WITH-HASH-TABLE-ITERATOR ((function hash-table) &body body)
   provides a method of manually looping over the elements of a hash-table.
   FUNCTION is bound to a generator-macro that, within the scope of the
   invocation, returns one or three values. The first value tells whether
   any objects remain in the hash table. When the first value is non-NIL,
   the second and third values are the key and the value of the next object."
  (let* ((hash (gensym))
         (keys (gensym))
         (values (gensym))
         (count (gensym))
         (state (gensym)))
    `(let* ((,hash ,hash-table)
            (,count (hash-table-count ,hash))
            (,keys (make-array ,count))
            (,values (make-array ,count))
            (,state (vector ,hash 0 ,keys ,values (enumerate-hash-keys-and-values ,hash ,keys ,values))))
      (declare (dynamic-extent ,keys ,state)
               (fixnum ,count))
      (macrolet ((,mname () `(next-hash-table-iteration-1 ,',state)))
        ,@body))))


(eval-when (compile load eval)
(defmacro pprint-logical-block ((stream-symbol list
				 &key (prefix "" prefixp)
                                      (per-line-prefix "" per-line-prefix-p)
				      (suffix ""))
				&body body)
  (cond ((eq stream-symbol nil) (setq stream-symbol '*standard-output*))
	((eq stream-symbol T) (setq stream-symbol '*terminal-io*)))
  (when (not (symbolp stream-symbol))
    (warn "STREAM-SYMBOL arg ~S to PPRINT-LOGICAL-BLOCK is not a bindable symbol"
	  stream-symbol)
    (setq stream-symbol '*standard-output*))
  (when (and prefixp per-line-prefix-p)
    (warn "prefix ~S and per-line-prefix ~S cannot both be specified ~
           in PPRINT-LOGICAL-BLOCK" prefix per-line-prefix)
    (setq per-line-prefix nil))
  `(let ((*logical-block-p* t))
     (maybe-initiate-xp-printing
      #'(lambda (,stream-symbol)
          (let ((+l ,list)
                (+p (or (and ,prefixp
                             (require-type ,prefix 'string))
                        (and ,per-line-prefix-p
                             (require-type ,per-line-prefix 'string))))
                (+s (require-type ,suffix 'string)))
            (pprint-logical-block+
                (,stream-symbol +l +p +s ,per-line-prefix-p T nil)
              ,@ body nil)))
      (decode-stream-arg ,stream-symbol))))


;Assumes var and args must be variables.  Other arguments must be literals or variables.

(defmacro pprint-logical-block+ ((var args prefix suffix per-line? circle-check? atsign?)
				 &body body)
  "Group some output into a logical block. STREAM-SYMBOL should be either a
   stream, T (for *TERMINAL-IO*), or NIL (for *STANDARD-OUTPUT*). The printer
   control variable *PRINT-LEVEL* is automatically handled."
  (when (and circle-check? atsign?)
    (setq circle-check? 'not-first-p))
  `(let ((*current-level* (1+ *current-level*))
	 (*current-length* -1)
	 ;(*parents* *parents*)
	 ,@(if (and circle-check? atsign?) `((not-first-p (plusp *current-length*)))))
     (unless (check-block-abbreviation ,var ,args ,circle-check?)
       (start-block ,var ,prefix ,per-line? ,suffix)
       (when
         (catch 'line-limit-abbreviation-exit
           (block logical-block
             (macrolet ((pprint-pop () `(pprint-pop+ ,',args ,',var))
                        (pprint-exit-if-list-exhausted ()
                          `(if (null ,',args) (return-from logical-block nil))))
               ,@ body))
           (end-block ,var ,suffix)
           nil)
         (end-block ,var ,suffix)
         (throw 'line-limit-abbreviation-exit T)))))
) ; eval-when

(defmacro %old-class-local-shared-slotds (class &optional default)
  (if default                           ; so setf works
    `(%class-get ,class '%old-class-local-shared-slotds ,default)
    `(%class-get ,class '%old-class-local-shared-slotds)))

(defmacro with-slot-values (slot-entries instance-form &body body)
; Simplified form of with-slots.  Expands into a let instead of a symbol-macrolet
; Thus, you can access the slot values, but you can't setq them.
  (let ((instance (gensym)) var slot-name bindings)
    (dolist (slot-entry slot-entries)
      (cond ((symbolp slot-entry)
             (setq var slot-entry slot-name slot-entry))
            ((and (listp slot-entry) (cdr slot-entry) (null (cddr slot-entry))
                  (symbolp (car slot-entry)) (symbolp (cadr slot-entry)))
             (setq var (car slot-entry) slot-name (cadr slot-entry)))
            (t (signal-program-error "Malformed slot-entry: ~a to with-slot-values.~@
                                      Should be a symbol or a list of two symbols."
				     slot-entry)))
      (push `(,var (slot-value ,instance ',slot-name)) bindings))
    `(let ((,instance ,instance-form))
       (let ,(nreverse bindings)
         ,@body))))

(defmacro with-slots (slot-entries instance-form &body body)
  "Establish a lexical environment for referring to the slots in the
instance named by the given slot-names as though they were variables.
Within such a context the value of the slot can be specified by using
its slot name, as if it were a lexically bound variable. Both setf and
setq can be used to set the value of the slot."
  (let ((instance (gensym)) var slot-name bindings)
    (dolist (slot-entry slot-entries)
      (cond ((symbolp slot-entry)
             (setq var slot-entry slot-name slot-entry))
            ((and (listp slot-entry) (cdr slot-entry) (null (cddr slot-entry))
                  (symbolp (car slot-entry)) (symbolp (cadr slot-entry)))
             (setq var (car slot-entry) slot-name (cadr slot-entry)))
            (t (signal-program-error "Malformed slot-entry: ~a to with-slots.~@
                                      Should be a symbol or a list of two symbols."
				     slot-entry)))
      (push `(,var (slot-value ,instance ',slot-name)) bindings))
    `(let ((,instance ,instance-form))
       ,@(if bindings 
             (list `(declare (ignorable ,instance)))
             (list `(declare (ignore ,instance))))
       (symbol-macrolet ,(nreverse bindings)
         ,@body))))

(defmacro with-accessors (slot-entries instance-form &body body)
  "Create a lexical environment in which the slots specified by slot-entry
are lexically available through their accessors as if they were variables.
The appropriate accessors are invoked to access the slots specified by
slot-entry. Both setf and setq can be used to set the value of the slot."
  (let ((instance (gensym)) var reader bindings)
    (dolist (slot-entry slot-entries)
      (cond ((and (listp slot-entry) (cdr slot-entry) (null (cddr slot-entry))
                  (symbolp (car slot-entry)) (symbolp (cadr slot-entry)))
             (setq var (car slot-entry) reader (cadr slot-entry)))
            (t (signal-program-error "Malformed slot-entry: ~a to with-accessors.~@
                                     Should be a list of two symbols."
				     slot-entry)))
      (push `(,var (,reader ,instance)) bindings))
    `(let ((,instance ,instance-form))
       ,@(if bindings 
             (list `(declare (ignorable ,instance)))
             (list `(declare (ignore ,instance))))
       (symbol-macrolet ,(nreverse bindings)
         ,@body))))

; I wanted to call this ":method"
(defmacro reference-method (gf &rest qualifiers-and-specializers)
  (let ((qualifiers (butlast qualifiers-and-specializers))
        (specializers (car (last qualifiers-and-specializers))))
    (if (null specializers) (report-bad-arg qualifiers-and-specializers '(not null)))
    `(find-method #',gf ',qualifiers (mapcar #'find-specializer ',specializers))))

(defmacro time (form)
  "Execute FORM and print timing information on *TRACE-OUTPUT*."
  `(report-time ',form #'(lambda () (progn ,form))))

(defmacro with-error-reentry-detection (&body body)
  (let ((thunk (gensym)))
    `(let ((,thunk #'(lambda () ,@body)))
       (declare (dynamic-extent ,thunk))
       (funcall-with-error-reentry-detection ,thunk))))

(defmacro without-duplicate-definition-warnings (&body body)
  `(compiler-let ((*compiler-warn-on-duplicate-definitions* nil))
     ,@body))


#+ppc-target
(defmacro scan-for-instr (mask opcode fn pc-index &optional (tries *trap-lookup-tries*))
  `(%scan-for-instr ,mask ,opcode ,fn ,pc-index ,tries))


(declare-arch-specific-macro codevec-header-p)

#+ppc-target
(defmacro match-instr (instr mask bits-to-match)
  `(eql (logand ,instr ,mask) ,bits-to-match))

(defmacro with-xp-stack-frames ((xp trap-function &optional stack-frame) &body body)
  (let ((thunk (gensym))
        (sf (or stack-frame (gensym))))
    `(let ((,thunk #'(lambda (&optional ,sf)
                       ,@(unless stack-frame `((declare (ignore ,sf))))
                       ,@body)))
       (declare (dynamic-extent ,thunk))
       (funcall-with-xp-stack-frames ,xp ,trap-function ,thunk))))

(defmacro signal-eof-error (stream)
  `(error 'end-of-file :stream ,stream))

(defmacro check-eof (valform stream eof-error-p eof-value)
  (let* ((val (gensym)))
    `(let ((,val ,valform))
      (if (eq ,val :eof)
        (if ,eof-error-p
          (signal-eof-error ,stream)
          ,eof-value)
        ,val))))

(defmacro designated-input-stream (input-stream)
  `(if ,input-stream
    (if (eq t ,input-stream)
      *terminal-io*
      ,input-stream)
    *standard-input*))

(defmacro pref (pointer accessor)
  "Reference an instance of a foreign type (or a component of a foreign
type) accessible via ptr.

Expand into code which references the indicated scalar type or component,
or returns a pointer to a composite type."
  (let* ((*target-ftd* (backend-target-foreign-type-data *target-backend*)))
    (destructuring-bind (type-name &rest accessors) (decompose-record-accessor accessor)
      (%foreign-access-form pointer (%foreign-type-or-record type-name) 0 accessors))))

(defmacro paref (pointer type-name index)
  (let* ((*target-ftd* (backend-target-foreign-type-data *target-backend*)))
    (%foreign-array-access-form  pointer (%foreign-type-or-record type-name) index)))

;;; Shorter versions for paref of :double, :float arrays
(defmacro dparef (pointer index)
  `(paref ,pointer :double ,index))

(defmacro sparef (pointer index)
  `(paref ,pointer :float ,index))

(defmacro rref (pointer accessor &key (storage :pointer storage-p))
  (when storage-p
    (warn "Use of :storage option ignored: ~a" storage))
  `(pref ,pointer ,accessor))

(defmacro rlet (spec &body body)
  "Execute body in an environment in which each var is bound to a MACPTR
encapsulating the address of a stack-allocated foreign memory block,
allocated and initialized from typespec and initforms as per make-record.
Return whatever value(s) body returns."
  (let* ((*target-ftd* (backend-target-foreign-type-data *target-backend*)))
    `(%stack-block ,(rlet-sizes spec)
      ,@(rlet-inits spec)
      ,@body)))

(defmacro rletz (spec &body body)
  "Execute body in an environment in which each var is bound to a MACPTR
encapuslating the address of a stack-allocated foreign memory block,
allocated and initialized from typespec and initforms as per make-record.
Return whatever value(s) body returns.

Unlike rlet, record fields that aren't explicitly initialized are set
to binary 0."
  (let* ((*target-ftd* (backend-target-foreign-type-data *target-backend*)))
    `(%stack-block ,(rlet-sizes spec t)
      ,@(rlet-inits spec)
      ,@body)))

(defun rlet-sizes (inits &optional clear-p &aux result)
  (dolist (item inits (nreverse result))
    (push `(,(car item)
            ,(%foreign-type-or-record-size (cadr item) :bytes)
            ,@(if clear-p '(:clear t)))
          result)))

(defun rlet-inits (inits &aux result)
  (dolist (item inits result)
    (let* ((name (car item))
           (record-name (cadr item))
           (inits (cddr item))
           (ftype (%foreign-type-or-record record-name))
           (ordinal (foreign-type-ordinal ftype))
           (ordinal-form (if (< ordinal max-canonical-foreign-type-ordinal)
                           ordinal
                           `(foreign-type-ordinal (load-time-value (%foreign-type-or-record ',record-name))))))
      (when (eq *host-backend* *target-backend*)
        (setq result (nconc result `((setf (uvref ,name target::macptr.type-cell) ,ordinal-form)))))
      (if (typep ftype 'foreign-record-type)
        (setq result
              (nconc result (%foreign-record-field-forms name ftype record-name inits)))
        (progn
          (when inits
            (if (and ftype (null (cdr inits)))
              (setq result
                    (nconc result
                           `((setf ,(%foreign-access-form name ftype 0 nil)
                              ,(car inits)))))
              (signal-program-error "Unexpected or malformed initialization forms: ~s in field type: ~s"
				    inits record-name))))))))

(defun %foreign-record-field-forms (ptr record-type record-name inits)
  (unless (evenp (length inits))
    (signal-program-error "Unexpected or malformed initialization forms: ~s in field type: ~s"
			  inits record-name))
  (let* ((result ()))
    (do* ()
	 ((null inits)
	  `((progn
	      ;(%assert-macptr-ftype ,ptr ,record-type)
	      ,@(nreverse result))))
      (let* ((accessor (decompose-record-accessor (pop inits)))
	     (valform (pop inits)))
	(push `(setf ,(%foreign-access-form ptr record-type 0  accessor) ,valform)
	      result)))))
  
(defmacro get-field-offset (accessor)
  (destructuring-bind (type-name field-name) (decompose-record-accessor accessor)
    (let* ((record-type (require-type (%foreign-type-or-record type-name) 'foreign-record-type))
           (field (%find-foreign-record-type-field record-type field-name))
           (bit-offset (foreign-record-field-offset field)))
      `(values ,(floor bit-offset 8) ,(foreign-record-field-type field) ,bit-offset))))

(defmacro record-length (recname)
  (%foreign-type-or-record-size recname :bytes))

(defun make-record-form (record-name allocator &rest initforms)
  (let* ((ftype (%foreign-type-or-record record-name))
         (ordinal (foreign-type-ordinal ftype))
         (ordinal-form (if (< ordinal max-canonical-foreign-type-ordinal)
                         ordinal
                         `(foreign-type-ordinal (load-time-value (%foreign-type-or-record ',record-name)))))
         (bits (ensure-foreign-type-bits ftype))
	 (bytes (if bits
		  (ceiling bits 8)
		  (signal-program-error "Unknown size for foreign type ~S."
					(unparse-foreign-type ftype))))
	 (p (gensym))
	 (memset (read-from-string "#_memset")))    
    `(let* ((,p (,allocator ,bytes)))
      ,@(when (eq *host-backend* *target-backend*)
              `((%set-macptr-type ,p ,ordinal-form)))
      (,memset ,p 0 ,bytes)
      ,@(%foreign-record-field-forms p ftype record-name initforms)
      ,p)))
  
(defmacro make-record (record-name &rest initforms)
  "Expand into code which allocates and initalizes an instance of the type
denoted by typespec, on the foreign heap. The record is allocated using the
C function malloc, and the user of make-record must explicitly call the C
function free to deallocate the record, when it is no longer needed."
  (apply 'make-record-form record-name 'malloc initforms))

(defmacro make-gcable-record (record-name &rest initforms)
  "Like MAKE-RECORD, only advises the GC that the foreign memory can
   be deallocated if the returned pointer becomes garbage."
  (apply 'make-record-form record-name '%new-gcable-ptr initforms))

(defmacro copy-record (type source dest)
  (let* ((size (* (%foreign-type-or-record-size type :words) #+64-bit-target 1 #+32-bit-target 2))
         (src (gensym "SRC"))
         (dst (gensym "DST"))
         (accessor #+64-bit-target '%get-unsigned-long #+32-bit-target '%get-unsigned-word)
         (i (gensym "I"))
         (j (gensym "J")))
    `(with-macptrs ((,src ,source)
                    (,dst ,dest))
      (do* ((,i 0 (+ ,i #+64-bit-target 4 #+32-bit-target 2))
            (,j 0 (+ ,j 1)))
           ((= ,j ,size))
        (declare (fixnum ,i))
        (setf (,accessor ,dst ,i) (,accessor ,src ,i))))))

(defmacro assert-pointer-type (pointer type)
  "Assert that the pointer points to an instance of the specified foreign type.
Return the pointer."
  (let* ((ptr (gensym)))
    `(let* ((,ptr ,pointer))
      (%set-macptr-type ,ptr (foreign-type-ordinal (load-time-value (parse-foreign-type ',type))))
      ,ptr)))

(defun with-constrained-values (type specs body env)
  (multiple-value-bind (body decls) (parse-body body env)
    (collect ((inits))
      (dolist (spec specs)
        (when (cdr spec)
          (inits `(setq ,(car spec) ,(cadr spec)))))        
  (let* ((vector (gensym))
         (idx -1))
    `(let* ((,vector (make-array ,(length specs) :element-type ',type)))
      (declare (dynamic-extent ,vector))
      (symbol-macrolet ,(mapcar (lambda (spec) `(,(car spec) (aref ,vector ,(incf idx)))) specs)
        ,@decls
        ,@(inits)
        ,@body))))))  

(defmacro with-constrained-double-floats (specs &body body &environment env)
  (with-constrained-values 'double-float specs body env))


(defmacro with-constrained-single-floats (specs &body body &environment env)
  (with-constrained-values 'single-float specs body env))

(defmacro with-terminal-input (&body body)
  "Execute body in an environment with exclusive read access to the terminal."
  (let* ((got-it (gensym)))
    `(let* ((,got-it (%request-terminal-input)))
      (unwind-protect
	   (progn ,@body)
	(%restore-terminal-input ,got-it)))))


(defmacro with-process-whostate ((whostate) &body body)
  (let* ((cell (gensym))
         (old (gensym)))
    `(let* ((,cell (process-whostate-cell *current-process*))
            (,old (car ,cell)))
      (unwind-protect
           (progn
             (setf (car ,cell) ,whostate)
             ,@body)
        (setf (car ,cell) ,old)))))


(defmacro with-read-lock ((lock) &body body)
  "Wait until a given lock is available for read-only access, then evaluate
its body with the lock held."
  (let* ((locked (gensym))
         (p (gensym)))
    `(with-lock-context
       (let* ((,locked (make-lock-acquisition))
              (,p ,lock))
         (declare (dynamic-extent ,locked))
         (unwind-protect
              (progn
                (read-lock-rwlock ,p ,locked)
                ,@body)
           (when (lock-acquisition.status ,locked) (unlock-rwlock ,p)))))))

(defmacro with-write-lock ((lock) &body body)
  "Wait until the given lock is available for write access, then execute
its body with the lock held."
  (let* ((locked (gensym))
         (p (gensym)))
    `(with-lock-context
       (let* ((,locked (make-lock-acquisition))
              (,p ,lock))
         (declare (dynamic-extent ,locked))
         (unwind-protect
              (progn
                (write-lock-rwlock ,p ,locked)
                ,@body)
           (when (lock-acquisition.status ,locked) (unlock-rwlock ,p)))))))

(defmacro without-gcing (&body body)
  `(unwind-protect
    (progn
      (%lock-gc-lock)
      ,@body)
    (%unlock-gc-lock)))

(defmacro with-deferred-gc (&body body)
  "Execute BODY without responding to the signal used to suspend
threads for GC.  BODY must be very careful not to do anything which
could cause an exception (note that attempting to allocate lisp memory
may cause an exception.)"
  `(let* ((*interrupt-level* -2))
    ,@body))

(defmacro allowing-deferred-gc (&body body)
  "Within the extent of a surrounding WITH-DEFERRED-GC, allow GC."
  `(let* ((*interrupt-level* -1))
    (%check-deferred-gc)
    ,@body))

(defmacro defer-gc ()
  `(setq *interrupt-level* -2))


(defmacro with-pointer-to-ivector ((ptr ivector) &body body)
  "Executes BODY with PTR bound to a pointer to the first byte of data
in IVECTOR.  The GC is disabled during execution of BODY; PTR has
has dynamic-extent (and the address it references may become invalid
after the BODY exits.)  IVECTOR should be a (SIMPLE-ARRAY (*)) whose
element-type is numeric."
  (let* ((v (gensym)))
    `(let* ((,v ,ivector))
       (unless (typep ,v 'ivector) (report-bad-arg ,v 'ivector))
       (without-gcing
         (with-macptrs ((,ptr))
           (%vect-data-to-macptr ,v ,ptr)
           ,@body)))))
      


(defmacro with-other-threads-suspended (&body body)
  `(unwind-protect
    (progn
      (%suspend-other-threads)
      ,@body)
    (%resume-other-threads)))

(defmacro with-package-read-lock ((p) &body body)
  `(with-read-lock ((pkg.lock ,p)) ,@body))

(defmacro with-package-write-lock ((p) &body body)
  `(with-write-lock ((pkg.lock ,p)) ,@body))

(defmacro with-package-lock ((p) &body body)
  `(with-package-write-lock (,p) ,@body))

;;; Lock %all-packages-lock%, for shared read access to %all-packages%

(defmacro with-package-list-read-lock (&body body)
  `(with-read-lock (%all-packages-lock%) ,@body))

;;; Lock %all-packages-lock%, to allow modification to %all-packages%
(defmacro with-package-list-write-lock (&body body)
  `(with-write-lock (%all-packages-lock%) ,@body))

(defmacro atomic-incf-decf (place delta &environment env)
  (setq place (macroexpand place env))
  (if (consp place)
    (let* ((sym (car place))
	   (struct-transform (structref-info sym env)))
      (if struct-transform
        (setq place (defstruct-ref-transform struct-transform (cdr place) env)
              sym (car place)))
      (ecase sym
	(the `(the ,(cadr place) (atomic-incf-decf ,(caddr place) ,delta)))
         ;; Needed so can handle %svref (which macroexpands into a LET*)
         ((let let*) (multiple-value-bind (body decls) (parse-body (cddr place) env t)
                       (unless (eql (length body) 1)
                         (error "~S is not a valid atomic-incf/decf place" place))
                       `(,sym ,(cadr place) ,@decls (atomic-incf-decf ,@body ,delta))))
         ;; Ditto
         (locally (multiple-value-bind (body decls) (parse-body (cdr place) env t)
                    (unless (eql (length body) 1)
                      (error "~S is not a valid atomic-incf/decf place" place))
                    `(,sym ,@decls (atomic-incf-decf ,@body ,delta))))
	(car `(%atomic-incf-car ,(cadr place) ,delta))
	(cdr `(%atomic-incf-cdr ,(cadr place) ,delta))
	((svref struct-ref) `(%atomic-incf-gvector ,@(cdr place) ,delta))))
    (if (and (symbolp place) (eq :special (variable-information place env)))
      (let* ((base (gensym))
             (offset (gensym)))
        `(multiple-value-bind (,base ,offset)
          (%symbol-binding-address ',place)
          (%atomic-incf-node ,delta ,base ,offset)))
      (signal-program-error "~S is not a special variable"  place))))
    
(defmacro atomic-incf (place)
  `(atomic-incf-decf ,place 1))

(defmacro atomic-decf (place)
  `(atomic-incf-decf ,place -1))

; Some of these macros were stolen from CMUCL.  Sort of ...

(defmacro iterate (name binds &body body)
  "Iterate Name ({(Var Initial-Value)}*) Declaration* Form*
  This is syntactic sugar for Labels.  It creates a local function Name with
  the specified Vars as its arguments and the Declarations and Forms as its
  body.  This function is then called with the Initial-Values, and the result
  of the call is return from the macro."
  (dolist (x binds)
    (unless (and (listp x)
                 (= (length x) 2))
      (signal-program-error "Malformed iterate variable spec: ~S." x)))

  `(labels ((,name ,(mapcar #'first binds) ,@body))
     (,name ,@(mapcar #'second binds))))

;;;; The Collect macro:

;;; Collect-Normal-Expander  --  Internal
;;;
;;;    This function does the real work of macroexpansion for normal collection
;;; macros.  N-Value is the name of the variable which holds the current
;;; value.  Fun is the function which does collection.  Forms is the list of
;;; forms whose values we are supposed to collect.
;;;
(eval-when (:compile-toplevel :load-toplevel :execute)


(defun collect-normal-expander (n-value fun forms)
  `(progn
     ,@(mapcar #'(lambda (form) `(setq ,n-value (,fun ,form ,n-value))) forms)
     ,n-value))


)

(defmacro once-only (specs &body body)
  "Once-Only ({(Var Value-Expression)}*) Form*
  Create a Let* which evaluates each Value-Expression, binding a temporary
  variable to the result, and wrapping the Let* around the result of the
  evaluation of Body.  Within the body, each Var is bound to the corresponding
  temporary variable."
  (iterate frob
           ((specs specs)
            (body body))
    (if (null specs)
      `(progn ,@body)
      (let ((spec (first specs)))
        (when (/= (length spec) 2)
          (signal-program-error "Malformed ~s binding spec: ~S." 'once-only spec))
        (let ((name (first spec))
              (exp-temp (gensym)))
          `(let ((,exp-temp ,(second spec))
                 (,name (gensym)))
             `(let ((,,name ,,exp-temp))
                ,,(frob (rest specs) body))))))))

(eval-when (:compile-toplevel :load-toplevel :execute)
(defun form-symbol (first &rest others)
  (intern (apply #'concatenate 'simple-base-string (string first) (mapcar #'string others))))
)


;;; Collect-List-Expander  --  Internal
;;;
;;;    This function deals with the list collection case.  N-Tail is the pointer
;;; to the current tail of the list, which is NIL if the list is empty.
;;;
(defun collect-list-expander (n-value n-tail forms)
  (let ((n-res (gensym)))
    `(progn
       ,@(mapcar #'(lambda (form)
                     `(let ((,n-res (cons ,form nil)))
                        (cond (,n-tail
                               (setf (cdr ,n-tail) ,n-res)
                               (setq ,n-tail ,n-res))
                              (t
                               (setq ,n-tail ,n-res  ,n-value ,n-res)))))
                 forms)
       ,n-value)))

;;;
;;;    The ultimate collection macro...
;;;

(defmacro collect (collections &body body)
  "Collect ({(Name [Initial-Value] [Function])}*) {Form}*
  Collect some values somehow.  Each of the collections specifies a bunch of
  things which collected during the evaluation of the body of the form.  The
  name of the collection is used to define a local macro, a la MACROLET.
  Within the body, this macro will evaluate each of its arguments and collect
  the result, returning the current value after the collection is done.  The
  body is evaluated as a PROGN; to get the final values when you are done, just
  call the collection macro with no arguments.

  Initial-Value is the value that the collection starts out with, which
  defaults to NIL.  Function is the function which does the collection.  It is
  a function which will accept two arguments: the value to be collected and the
  current collection.  The result of the function is made the new value for the
  collection.  As a totally magical special-case, the Function may be Collect,
  which tells us to build a list in forward order; this is the default.  If an
  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto the
  end.  Note that Function may be anything that can appear in the functional
  position, including macros and lambdas."
  
  
  (let ((macros ())
        (binds ()))
    (dolist (spec collections)
      (unless (<= 1 (length spec) 3)
        (signal-program-error "Malformed collection specifier: ~S." spec))
      (let ((n-value (gensym))
            (name (first spec))
            (default (second spec))
            (kind (or (third spec) 'collect)))
        
        (push `(,n-value ,default) binds)
        (if (eq kind 'collect)
          (let ((n-tail (gensym)))
            (if default
              (push `(,n-tail (last ,n-value)) binds)
              (push n-tail binds))
            (push `(,name (&rest args)
                          (collect-list-expander ',n-value ',n-tail args))
                  macros))
          (push `(,name (&rest args)
                        (collect-normal-expander ',n-value ',kind args))
                macros))))
    `(macrolet ,macros (let* ,(nreverse binds) (declare (ignorable ,@binds)) ,@body))))


;;; DEFENUM -- Internal Interface.
;;;
(defmacro defenum ((&key (prefix "") (suffix "") (start 0) (step 1))
                   &rest identifiers)
  (let ((results nil)
        (index 0)
        (start (eval start))
        (step (eval step)))
    (dolist (id identifiers)
      (multiple-value-bind
        (root docs)
        (if (consp id)
          (values (car id) (cdr id))
          (values id nil))
        (push `(defconstant ,(intern (concatenate 'simple-base-string
                                                  (string prefix)
                                                  (string root)
                                                  (string suffix)))
                 ,(+ start (* step index))
                 ,@docs)
              results))
      (incf index))
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       ,@(nreverse results))))


;;; This does something like special binding, but the "bindings" established
;;; aren't thread-specific.

(defmacro let-globally ((&rest vars) &body body &environment env)
  (multiple-value-bind (body decls) (parse-body body env)
    (let* ((initforms nil)
           (psetform nil)
           (specvars nil)
           (restoreform nil))
      (flet ((pair-name-value (p)
               (if (atom p)
                 (values (require-global-symbol p env) nil)
                 (if (and (consp (%cdr p)) (null (%cddr p)))
                   (values (require-global-symbol (%car p) env) (%cadr p))
                   (signal-program-error "Invalid variable initialization form : ~s")))))
        (declare (inline pair-name-value))
        (dolist (v vars)
          (let* ((oldval (gensym))
                 (newval (gensym)))
            (multiple-value-bind (var valueform) (pair-name-value v)
              (push var specvars)
              (push var restoreform)
              (push oldval restoreform)
              (push `(,oldval (uvref (symptr->symvector ',var) #.target::symbol.vcell-cell)) initforms)
              (push `(,newval ,valueform) initforms)
              (push var psetform)
              (push newval psetform))))
        `(let ,(nreverse initforms)
           ,@decls
           (locally (declare (special ,@(nreverse specvars)))
             (unwind-protect
               (progn (psetq ,@(nreverse psetform)) ,@body)
               (psetq ,@(nreverse restoreform)))))))))
;;; From CLX.

;;; The good news is that this uses an interlocked load/store sequence
;;; and is fairly efficient.
;;; The bad news is that it only handles a few types of "place" forms.
;;; The good news is that CLX only uses a few types of "place" forms.

(defmacro conditional-store (place old-value new-value &environment env)
  (setq place (macroexpand place env))
  (if (atom place)
    ;; CLX uses special variables' value cells as place forms.
    (if (and (symbolp place)
             (eq :special (ccl::variable-information place env)))
      (let* ((base (gensym))
             (offset (gensym)))
        `(multiple-value-bind (,base ,offset)
          (ccl::%symbol-binding-address ',place)
          (ccl::%store-node-conditional ,offset ,base ,old-value ,new-value)))
      (signal-program-error "~s is not a special variable ." place))
    (let* ((sym (car place))
           (struct-transform (structref-info sym env)))
      (if struct-transform
        (setq place (defstruct-ref-transform struct-transform (cdr place) env)
              sym (car place)))
      (if (member  sym '(svref ccl::%svref ccl::struct-ref))
        (let* ((v (gensym)))
          `(let* ((,v ,(cadr place)))
            (ccl::store-gvector-conditional ,(caddr place)
             ,v ,old-value ,new-value)))
        (signal-program-error "Don't know how to do conditional store to ~s" place)))))

(defmacro step (form)
  "The form is evaluated with single stepping enabled. Function calls
outside the lexical scope of the form can be stepped into only if the
functions in question have been compiled with sufficient DEBUG policy
to be at least partially steppable."
  form)

(defmacro target-arch-case (&rest clauses)
  `(case (backend-target-arch-name *target-backend*)
    ,@clauses))

(defmacro target-os-case (&rest clauses)
  `(ecase (backend-target-os *target-backend*)
    ,@clauses))

(defmacro target-word-size-case (&rest clauses)
  `(ecase (arch::target-nbits-in-word (backend-target-arch *target-backend*))
    ,@clauses))

(defmacro %get-natural (&body body)
  "A free copy of the next OpenMCL release to anyone who remembers Flakey Foont"
  (target-word-size-case
   (32 `(%get-unsigned-long ,@body))
   (64 `(%%get-unsigned-longlong ,@body))))

(defmacro %get-signed-natural (&body body)
  "And that's my final offer."
  (target-word-size-case
   (32 `(%get-signed-long ,@body))
   (64 `(%%get-signed-longlong ,@body))))

(declare-arch-specific-macro %target-kernel-global)

;;; This behaves like a function, but looks up the kernel global
;;; at compile time if possible. Probably should be done as a function
;;; and a compiler macro, but we can't define compiler macros yet,
;;; and I don't want to add it to "ccl:compiler;optimizers.lisp"
(declare-arch-specific-macro %get-kernel-global)

(declare-arch-specific-macro %get-kernel-global-ptr)

(declare-arch-specific-macro area-code)

(declare-arch-specific-macro nth-immediate)

(declare-arch-specific-macro set-nth-immediate)

(defsetf nth-immediate set-nth-immediate)

(defmacro do-consing-areas ((area) &body body)
  (let ((code (gensym)))
  `(do-gc-areas (,area)
     (let ((,code (%fixnum-ref ,area  (area-code))))
       (when (or (eql ,code area-readonly)
		 (eql ,code area-watched)
                 (eql ,code area-managed-static)
                 (eql ,code area-static)
                 (eql ,code area-dynamic))
         ,@body)))))

(declare-arch-specific-macro area-succ)


(defmacro do-gc-areas ((area) &body body)
  (let ((initial-area (gensym)))
    `(let* ((,initial-area (%get-kernel-global 'all-areas))
            (,area ,initial-area))
       (declare (fixnum ,initial-area ,area))
       (loop
         (setq ,area (%fixnum-ref ,area (area-succ)))
         (when (eql ,area ,initial-area)
           (return))
         ,@body))))

(defmacro with-ioblock-input-lock-grabbed ((ioblock) &body body)
  (let* ((i (gensym)))
    `(let* ((,i ,ioblock))
      (with-lock-grabbed ((ioblock-inbuf-lock ,i))
        (cond ((ioblock-device ,i)
               ,@body)
              (t (stream-is-closed (ioblock-stream ,i))))))))

(defmacro with-ioblock-output-lock-grabbed ((ioblock) &body body)
  (let* ((i (gensym)))
    `(let* ((,i ,ioblock))
      (with-lock-grabbed ((ioblock-outbuf-lock ,i))
        (cond ((ioblock-device ,i)
               ,@body)
              (t (stream-is-closed (ioblock-stream ,i))))))))
  

(defmacro with-stream-ioblock-input ((ioblock stream &key
                                             speedy)
                                  &body body)
  `(let ((,ioblock (stream-ioblock ,stream t)))
     ,@(when speedy `((declare (optimize (speed 3) (safety 0)))))
     (with-ioblock-input-locked (,ioblock) ,@body)))

(defmacro with-stream-ioblock-output ((ioblock stream &key
                                             speedy)
                                  &body body)
  `(let ((,ioblock (stream-ioblock ,stream t)))
     ,@(when speedy `((declare (optimize (speed 3) (safety 0)))))
     (with-ioblock-output-locked (,ioblock) ,@body)))

(defmacro with-stream-ioblock-output-maybe ((ioblock stream &key
						     speedy)
					    &body body)
  `(let ((,ioblock (stream-ioblock ,stream t)))
    ,@(when speedy `((declare (optimize (speed 3) (safety 0)))))
    (with-ioblock-output-locked-maybe (,ioblock) ,@body)))

(defmacro with-ioblock-input-locked ((ioblock) &body body)
  (let* ((lock (gensym)))
    `(let* ((,lock (locally (declare (optimize (speed 3) (safety 0)))
                                  (ioblock-inbuf-lock ,ioblock))))
      (if ,lock
        (with-lock-grabbed (,lock)
          (cond ((ioblock-device ,ioblock)
                 ,@body)
                (t (stream-is-closed (ioblock-stream ,ioblock)))))
        (progn
          (check-ioblock-owner ,ioblock)
          ,@body)))))

(defmacro with-ioblock-output-locked ((ioblock) &body body)
  (let* ((lock (gensym)))
    `(let* ((,lock (locally (declare (optimize (speed 3) (safety 0)))
                                  (ioblock-outbuf-lock ,ioblock))))
      (if ,lock
        (with-lock-grabbed (,lock)
          (cond ((ioblock-device ,ioblock)
                 ,@body)
                (t (stream-is-closed (ioblock-stream ,ioblock)))))
        (progn
          (check-ioblock-owner ,ioblock)
          ,@body)))))



(defmacro with-ioblock-output-locked-maybe ((ioblock) &body body)
  (let* ((lock (gensym)))
    `(let* ((,lock (locally (declare (optimize (speed 3) (safety 0)))
                     (ioblock-outbuf-lock ,ioblock))))
      (if ,lock
        (with-lock-grabbed (,lock)
          (cond ((ioblock-device ,ioblock)
                 ,@body)
                (t (stream-is-closed (ioblock-stream ,ioblock)))))
        (progn
          (check-ioblock-owner ,ioblock)
          ,@body)))))

;;; Use this when it's possible that the fd might be in
;;; a non-blocking state.  Body must return a negative of
;;; the os error number on failure.
;;; The use of READ-FROM-STRING below is certainly ugly, but macros
;;; that expand into reader-macros don't generally trigger the reader-macro's
;;; side-effects.  (Besides, the reader-macro might return a different
;;; value when the macro function is expanded than it did when the macro
;;; function was defined; this can happen during cross-compilation.)
(defmacro with-eagain (fd direction &body body)
  (let* ((res (gensym))
	 (eagain (symbol-value (read-from-string "#$EAGAIN"))))
   `(loop
      (let ((,res (progn ,@body)))
	(if (eql ,res (- ,eagain))
          (progn
            (setq ,res
                  (,(ecase direction
                           (:input 'process-input-would-block)
                           (:output 'process-output-would-block))
                    ,fd))
            (unless (eq ,res t) (return ,res)))
	  (return ,res))))))

(defmacro ignoring-eintr (&body body)
  (let* ((res (gensym))
         (eintr (symbol-value (read-from-string "#$EINTR"))))
    `(loop
       (let* ((,res (progn ,@body)))
         (unless (eql ,res (- ,eintr))
           (return ,res))))))

(defmacro ff-call-ignoring-eintr (&body body)
  (let* ((res (gensym))
         (eintr (symbol-value (read-from-string "#$EINTR"))))
    `(loop
       (let* ((,res (progn ,@body)))
         (declare (fixnum ,res))
         (when (< ,res 0)
           (setq ,res (%get-errno)))
         (unless (eql ,res (- ,eintr))
           (return ,res))))))

(defmacro basic-stream-ioblock (s)
  `(or (basic-stream.state ,s)
    (stream-is-closed ,s)))

(defsetf interrupt-level set-interrupt-level)

(defmacro %swap-u16 (val)
  (let* ((arg (gensym)))
    `(let* ((,arg ,val))
      (declare (type (unsigned-byte 16) ,arg))
      (logand #xffff (the fixnum (logior (the fixnum (ash ,arg -8))
                                         (the fixnum (ash ,arg 8))))))))

(defmacro %swap-u32 (val)
  (let* ((arg (gensym)))
    `(let ((,arg ,val))
      (declare (type (unsigned-byte 32) ,arg))
      (the (unsigned-byte 32) (logior (the (unsigned-byte 32)
                                        (ash (logand #xff ,arg) 24))
                                      (the (unsigned-byte 24)
                                        (logior
                                         (the (unsigned-byte 24) (ash (logand #xff00 ,arg) 8))
                                         (the (unsigned-byte 16)
                                           (logior
                                            (the (unsigned-byte 16) (ash (logand #xff0000 ,arg) -8))
                                            (the (unsigned-byte 8) (ash ,arg -24)))))))))))
    

(defmacro multiple-value-bind (varlist values-form &body body &environment env)
  (multiple-value-bind (body decls)
                       (parse-body body env)
    (let ((ignore (make-symbol "IGNORE")))
      `(multiple-value-call #'(lambda (&optional ,@varlist &rest ,ignore)
                                (declare (ignore ,ignore))
                                ,@decls
                                ,@body)
                            ,values-form))))

(defmacro multiple-value-setq (vars val)
  (if vars
    `(values (setf (values ,@(mapcar #'(lambda (s) (require-type s 'symbol)) vars))  ,val))
    `(prog1 ,val)))

(defmacro nth-value (n form)
  "Evaluate FORM and return the Nth value (zero based). This involves no
  consing when N is a trivial constant integer."
  `(car (nthcdr ,n (multiple-value-list ,form))))



(defmacro with-input-timeout (((stream-var &optional (stream-form stream-var)) timeout) &body body)
  "Execute body with STREAM-VAR bound to STREAM-FORM and with that stream's
stream-input-timeout set to TIMEOUT."
  (let* ((old-input-timeout (gensym))
         (stream (gensym)))
    `(let* ((,stream ,stream-form)
            (,stream-var ,stream)
            (,old-input-timeout (stream-input-timeout ,stream)))
      (unwind-protect
           (progn
             (setf (stream-input-timeout ,stream) ,timeout)
             ,@body)
        (setf (stream-input-timeout ,stream) ,old-input-timeout)))))

(defmacro with-output-timeout (((stream-var &optional (stream-form stream-var)) timeout) &body body)
  "Execute body with STREAM-VAR bound to STREAM-FORM and with that stream's
stream-output-timeout set to TIMEOUT."
  (let* ((old-output-timeout (gensym))
         (stream (gensym)))
    `(let* ((,stream ,stream-form)
            (,stream-var ,stream)
            (,old-output-timeout (stream-output-timeout ,stream)))
      (unwind-protect
           (progn
             (setf (stream-output-timeout ,stream) ,timeout)
             ,@body)
        (setf (stream-output-timeout ,stream) ,old-output-timeout)))))

;;; FORM returns a signed integer.  If it's non-negative, return that
;;; value, otherwise, return the (negative) errnor value returned by
;;; %GET-ERRNO
(defmacro int-errno-call (form)
  (let* ((value (gensym)))
    `(let* ((,value ,form))
      (if (< ,value 0)
        (%get-errno)
        ,value))))

(defmacro int-errno-ffcall (entry &rest args)
  `(int-errno-call (ff-call ,entry ,@args)))

(defmacro with-initial-bindings (bindings &body body)
  (let* ((syms (gensym))
         (values (gensym)))
    `(multiple-value-bind (,syms ,values)
        (initial-bindings ,bindings)
      (progv ,syms ,values ,@body))))

(defmacro with-standard-initial-bindings (&body body)
  `(with-initial-bindings (standard-initial-bindings) ,@body))

;;; True if TYPECODE denotes some sort of CL array.
(defmacro array-typecode-p (code)
  (let* ((typecode (gensym)))
    `(let* ((,typecode ,code))
      (or
       (>= (the (unsigned-byte 8) (ivector-typecode-p ,typecode))
        ,(nx-lookup-target-uvector-subtag :min-cl-ivector-subtag))
       (>= (the (unsigned-byte 8) (gvector-typecode-p ,typecode))
           ,(nx-lookup-target-uvector-subtag :array-header))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/mcl-compat.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;; mcl-compat.lisp - (some) backwards-compatibility with traditional MCL
;;;  (CLtL2/ANSI, etc.)

;;;  Gratuitous name changes, for the most part:

(deftype base-character () 'base-char)
(deftype extended-character () 'extended-char)

(defmacro define-setf-method (access-fn lambda-list &body body)
  `(define-setf-expander ,access-fn ,lambda-list ,@body))

(defun get-setf-method (form &optional environment)
  (get-setf-expansion-aux form environment nil))

(defun get-setf-method-multiple-value (form &optional environment)
  "Like Get-Setf-Method, but may return multiple new-value variables."
  (get-setf-expansion-aux form environment t))

;;; Traditional MCL I/O primitives:

(defun tyi (stream)
  (let* ((ch (stream-read-char stream)))
    (unless (eq ch :eof) ch)))

(defun untyi (ch &optional stream)
  (stream-unread-char (designated-input-stream stream) ch))

(defun tyo (ch &optional stream)
  (stream-write-char (real-print-stream stream) ch))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/mcl-compat.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/misc.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (eval compile)
  (require 'defstruct-macros))

(defun short-site-name  ()
  "Return a string with the abbreviated site name, or NIL if not known."
  (or *short-site-name* "unspecified"))

(defun long-site-name   ()
  "Return a string with the long form of the site name, or NIL if not known."
  (or *long-site-name* "unspecified"))

(defun machine-instance ()
  "Return a string giving the name of the local machine."
  #-windows-target (%uname 1)
  #+windows-target
  (rlet ((nsize #>DWORD 0))
    (if (eql 0 (#_GetComputerNameExW #$ComputerNameDnsFullyQualified
                                     (%null-ptr)
                                     nsize))
      (%stack-block ((buf (* 2 (pref nsize #>DWORD))))
        (#_GetComputerNameExW #$ComputerNameDnsFullyQualified
                              buf
                              nsize)
        (%get-native-utf-16-cstring buf))
      "localhost"))
  )


(defun machine-type ()
  "Returns a string describing the type of the local machine."
  #-windows-target (%uname 4)
  #+windows-target
  (rlet ((info #>SYSTEM_INFO))
    (#_GetSystemInfo info)
    (case (pref info #>SYSTEM_INFO.nil.nil.wProcessorArchitecture)
      (#.#$PROCESSOR_ARCHITECTURE_AMD64 "x64")
      (#.#$PROCESSOR_ARCHITECTURE_INTEL "x86")
      (t "unknown")))
  )



(defloadvar *machine-version* nil)

(defun machine-version ()
  "Return a string describing the version of the computer hardware we
are running on, or NIL if we can't find any useful information."
  (or *machine-version*
      (setq *machine-version*
            #+darwin-target
            (block darwin-machine-version
              (%stack-block ((mib 8))
                (setf (%get-long mib 0) #$CTL_HW
                      (%get-long mib 4) #$HW_MODEL)
                (%stack-block ((res 256)
                               (reslen target::node-size))
                  (setf (%get-byte res 0) 0
                        (%get-natural reslen 0) 256)
                  (if (zerop (#_sysctl mib 2 res reslen (%null-ptr) 0))
                    (return-from darwin-machine-version (%get-cstring res))))))
            #+linux-target
            (with-open-file (f "/proc/cpuinfo" :if-does-not-exist nil)
              (when f
                (flet ((cpu-info-match (target line)
                         (let* ((targetlen (length target))
                                (linelen (length line)))
                           (if (and (> linelen targetlen)
                                    (string= target line
                                             :end2 targetlen))
                           (let* ((colonpos (position #\: line)))
                             (when colonpos
                               (string-trim " "
                                            (subseq line (1+ colonpos)))))))))
                  (do* ((line (read-line f nil nil)
                              (read-line f nil nil))
                        (target #+ppc-target "machine"
                                #+x86-target "model name"
                                #+arm-target "Hardware"))
                       ((null line))
                    (let* ((matched (cpu-info-match target line)))
                      (when matched (return matched)))))))
            #+freebsd-target
            (%stack-block ((ret 512)
                           (mib (* (record-length :uint))))
              (setf (%get-unsigned-long mib 0)
                    #$CTL_HW
                    (%get-unsigned-long mib (record-length :uint))
                    #$HW_MODEL)
              (rlet ((oldsize :uint 512))
                (if (eql 0 (#_sysctl mib 2 ret oldsize (%null-ptr) 0))
                  (%get-cstring ret)
                  1)))
            #+solaris-target
            (rlet ((info :processor_info_t))
              (do* ((i 0 (1+ i)))
                   ((and (= 0 (#_processor_info i info))
                         (= (pref info :processor_info_t.pi_state)
                            #$P_ONLINE))
                    (%get-cstring (pref info :processor_info_t.pi_processor_type)))))
            #+windows-target
            (getenv "PROCESSOR_IDENTIFIER")
            )))


(defun software-type ()
  "Return a string describing the supporting software."
  #-windows-target (%uname 0)
  #+windows-target "Microsoft Windows")


(defun software-version ()
  "Return a string describing version of the supporting software, or NIL
   if not available."
  #-windows-target (%uname 2)
  #+windows-target
  (rletZ ((info #>OSVERSIONINFOEX))
    (setf (pref info #>OSVERSIONINFOEX.dwOSVersionInfoSize)
          (record-length #>OSVERSIONINFOEX))
    (#_GetVersionExA info)
    (format nil "~d.~d Build ~d (~a)"
            (pref info #>OSVERSIONINFOEX.dwMajorVersion)
            (pref info #>OSVERSIONINFOEX.dwMinorVersion)
            (pref info #>OSVERSIONINFOEX.dwBuildNumber)
            (if (eql (pref info #>OSVERSIONINFOEX.wProductType)
                     #$VER_NT_WORKSTATION)
              "Workstation"
              "Server")))
  )







;;; Yawn.



(defmethod documentation (thing doc-id)
  (%get-documentation thing doc-id))

(defmethod (setf documentation) (new thing doc-id)
  (%put-documentation thing doc-id new))


(defmethod documentation ((symbol symbol) (doc-type (eql 'function)))
  (let* ((def (fboundp symbol)))	; FBOUNDP returns info about definition
    (when def
      (%get-documentation def t))))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'function)))
  (let* ((def (fboundp symbol)))	; FBOUNDP returns info about definition
    (when def
      (%put-documentation def
                          t
                          new))
    new))

(defmethod documentation ((symbol symbol) (doc-type (eql 'setf)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'setf)))
  (call-next-method))


(defmethod documentation ((symbol symbol) (doc-type (eql 'variable)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'variable)))
  (call-next-method))

(defmethod documentation ((symbol symbol) (doc-type (eql 'compiler-macro)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'compiler-macro)))
  (call-next-method))

(defmethod documentation ((symbol symbol) (doc-type (eql 'type)))
  (let* ((class (find-class symbol nil)))
    (if class
      (documentation class doc-type)
      (call-next-method))))

(defmethod (setf documentation) (new (symbol symbol) (doc-type (eql 'type)))
  (let* ((class (find-class symbol nil)))
    (if class
      (setf (documentation class doc-type) new)
      (call-next-method))))

(defmethod documentation ((symbol symbol) (doc-type (eql 'method-combination)))
  (let* ((mci (method-combination-info symbol)))
    (if mci
      (documentation mci doc-type))))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'method-combination)))
  (let* ((mci (method-combination-info symbol)))
    (if mci
      (setf (documentation mci doc-type) new))))


(defmethod documentation ((symbol symbol) (doc-type (eql 'structure)))
  (let* ((class (find-class symbol nil)))
    (if (typep class 'structure-class)
      (documentation class 'type)
      (call-next-method))))

(defmethod (setf documentation) ((new t)
				 (symbol symbol)
				 (doc-type (eql 'structure)))
  (let* ((class (find-class symbol nil)))
    (if (typep class 'structure-class)
      (setf (documentation class 'type) new)
      (call-next-method))))

(defmethod documentation ((p package) (doc-type (eql 't)))
  (call-next-method))

(defmethod (setf documentation) ((new t) (p package) (doc-type (eql 't)))
  (call-next-method))

(defmethod documentation ((f function) (doc-type (eql 't)))
  (call-next-method))

(defmethod (setf documentation) ((new t) (f function) (doc-type (eql 't)))
  (call-next-method))

(defmethod documentation ((f function) (doc-type (eql 'function)))
  (documentation f t))

(defmethod documentation ((slot slot-definition) (doc-type t))
   (when (or (eq doc-type t)(eq doc-type 'slot-definition))
     (slot-definition-documentation slot)))

(defmethod (setf documentation) ((new t)
				 (f function)
				 (doc-type (eql 'function)))
  (setf (documentation f t) new))

(defmethod documentation ((l cons) (doc-type (eql 'function)))
  (let* ((name (setf-function-spec-name l)))
    (if name
      (documentation name doc-type)
      (%get-documentation l doc-type))))

(defmethod (setf documentation) ((new t) (l cons) (doc-type (eql 'function)))
  (let* ((name  (setf-function-spec-name l)))
    (if name
      (setf (documentation name doc-type) new)
      (%put-documentation l doc-type new))))


(defmethod documentation ((l cons) (doc-type (eql 'compiler-macro)))
  (let* ((name (setf-function-spec-name l)))
    (if name
      (documentation name doc-type)
      (%get-documentation l doc-type))))

(defmethod (setf documentation) ((new t) (l cons) (doc-type (eql 'compiler-macr0)))
  (let* ((name (setf-function-spec-name l)))
    (if name
      (setf (documentation name doc-type) new)
      (%put-documentation l doc-type new))))


(defmethod documentation ((m method-combination)
			  (doc-type (eql 'method-combination)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (m method-combination)
				 (doc-type (eql 'method-combination)))
  (call-next-method))

(defmethod documentation ((m method-combination)
			  (doc-type (eql t)))
  (documentation m 'method-combination))

(defmethod (setf documentation) ((new t)
				 (m method-combination)
				 (doc-type (eql t)))
  (setf (documentation m 'method-combination) new))

(defmethod documentation ((m standard-method)
			  (doc-type (eql t)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (m standard-method)
				 (doc-type (eql t)))
  (call-next-method))

(defmethod documentation ((c standard-class) (doc-type (eql 'type)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (c standard-class)
				 (doc-type (eql 'type)))
  (call-next-method))

(defmethod documentation ((c standard-class) (doc-type (eql 't)))
  (documentation c 'type))

(defmethod (setf documentation) ((new t)
				 (c standard-class)
				 (doc-type (eql 't)))
  (setf (documentation c 'type) new))

(defmethod documentation ((c structure-class) (doc-type (eql 'type)))
  (call-next-method))

(defmethod (setf documentation) ((new t)
				 (c structure-class)
				 (doc-type (eql 'type)))
  (call-next-method))

(defmethod documentation ((c structure-class) (doc-type (eql 't)))
  (documentation c 'type))

(defmethod (setf documentation) ((new t)
				 (c structure-class)
				 (doc-type (eql 't)))
  (setf (documentation c 'type) new))

;;; This is now deprecated; things which call it should stop doing so.
(defun set-documentation (symbol doc-type string)
  (setf (documentation symbol doc-type) string))

(defun set-function-info (symbol info)
  (let* ((doc-string (if (consp info) (car info) info)))
    (if (and *save-doc-strings* (stringp doc-string))
      (set-documentation  symbol 'function doc-string)))
  (let* ((cons (assq symbol *nx-globally-inline*))
         (lambda-expression (if (consp info) (cdr info))))
    (if (and (proclaimed-inline-p symbol)
             (not (compiler-special-form-p symbol))
             (lambda-expression-p lambda-expression)
             (let* ((lambda-list (cadr lambda-expression)))
               (and (not (memq '&lap lambda-list))
                    (not (memq '&method lambda-list))
                    (not (memq '&lexpr lambda-list)))))
      (if cons 
        (%rplacd cons lambda-expression)
        (push (cons symbol lambda-expression) *nx-globally-inline*))
      (if cons (setq *nx-globally-inline* (delete cons *nx-globally-inline*)))))
  symbol)


(setf (documentation 'if 'function)
      "If Predicate Then [Else]
  If Predicate evaluates to non-null, evaluate Then and returns its values,
  otherwise evaluate Else and return its values. Else defaults to NIL.")

(setf (documentation 'progn 'function)
      "progn form*
  Evaluates each FORM and returns the value(s) of the last FORM.")

(defmethod documentation ((thing character-encoding) (doc-type (eql t)))
  (character-encoding-documentation thing))

(defmethod (setf documentation) (new (thing character-encoding) (doc-type (eql t)))
  (check-type new (or null string))
  (setf (character-encoding-documentation thing) new))

(defmethod documentation ((thing symbol) (doc-type (eql 'character-encoding)))
  (let* ((encoding (lookup-character-encoding (intern (string thing) :keyword))))
    (when encoding
      (documentation encoding t))))

                                 


#|
(setf (documentation 'car 'variable) "Preferred brand of automobile")
(documentation 'car 'variable)
(setf (documentation 'foo 'structure) "the structure is grand.")
(documentation 'foo 'structure)
(setf (documentation 'foo 'variable) "the metasyntactic remarker")
(documentation 'foo 'variable)
(setf (documentation 'foo 'obscure) "no one really knows what it means")
(documentation 'foo 'obscure)
(setf (documentation 'foo 'structure) "the structure is solid")
(documentation 'foo 'function)
||#

;;


(defun %page-fault-info ()
  #-windows-target
  (rlet ((usage :rusage))
    (%%rusage usage)
    (values (pref usage :rusage.ru_minflt)
            (pref usage :rusage.ru_majflt)
            (pref usage :rusage.ru_nswap)))
  #+windows-target
  ;; Um, don't know how to determine this, or anything like it.
  (values 0 0 0))


          
(defparameter *report-time-function* nil
  "If non-NULL, should be a function which accepts the following
   keyword arguments:
   :FORM              the form that was executed
   :RESULTS           a list of all values returned by the execution of FORM
   :ELAPSED-TIME      total elapsed (real) time, in internal-time-units-per-second
   :USER-TIME         elapsed user time, in internal-time-units-per-second
   :SYSTEM-TIME       elapsed system time, in internal-time-units-per-second
   :GC-TIME           total real time spent in the GC, in internal-time-units-per-second
   :BYTES-ALLOCATED   total bytes allocated
   :MINOR-PAGE-FAULTS minor page faults
   :MAJOR-PAGE-FAULTS major page faults
   :SWAPS             swaps")


(defun standard-report-time (&key form results elapsed-time user-time
                                  system-time gc-time bytes-allocated
                                  minor-page-faults major-page-faults
                                  swaps)
  (let* ((s *trace-output*)
         (units
          (ecase internal-time-units-per-second
            (1000000 "microseconds")
            (1000  "milliseconds")))
         (iwidth (max (length (format nil "~:D" elapsed-time))
                          (length (format nil "~:D" user-time))
                          (length (format nil "~:D" system-time))
                          (length (format nil "~:D" gc-time))))
                      
         (fwidth
          (ecase internal-time-units-per-second
            (1000000 6)
            (1000  3)))
         (elapsed-seconds (/ elapsed-time internal-time-units-per-second))
         (user-seconds (/ user-time internal-time-units-per-second))
         (system-seconds (/ system-time internal-time-units-per-second))
         (gc-seconds  (/ gc-time internal-time-units-per-second))
         (ffield-width (max (length (format nil "~,vF" fwidth elapsed-seconds))
                                (length (format nil "~,vF" fwidth user-seconds))
                                (length (format nil "~,vF" fwidth system-seconds))
                                (length (format nil "~,vF" fwidth gc-seconds))))
         (cpu-count (cpu-count)))
    (format s "~&~S" form)
    (format s "~&took ~v:D ~a (~v,vF seconds) to run." iwidth elapsed-time units ffield-width fwidth elapsed-seconds )
    (unless (eql gc-time 0)
      (format s
              "~%~5t~v:D ~a (~v,vF seconds, ~,2f%) of which was spent in GC." iwidth
              gc-time units ffield-width fwidth gc-seconds (* 100.0 (/ gc-seconds elapsed-seconds))))
    (format s "~&During that period, and with ~D available CPU core~P," cpu-count cpu-count)
    (format s "~&~5t~v:D ~a (~v,vF seconds) were spent in user mode" iwidth user-time units ffield-width fwidth user-seconds)
    (format s "~&~5t~v:D ~a (~v,vF seconds) were spent in system mode" iwidth system-time units ffield-width fwidth system-seconds)
    (unless (eql 0 bytes-allocated)
      (format s "~% ~:D bytes of memory allocated." bytes-allocated))
    (when (or (> minor-page-faults 0)
              (> major-page-faults 0)
              (> swaps 0))
      (format s
              "~% ~:D minor page faults, ~:D major page faults, ~:D swaps."
              minor-page-faults major-page-faults swaps))
    (format s "~&")
    (values-list results)))

(defun report-time (form thunk)
  (flet ((integer-size-in-bytes (i)
           (if (typep i 'fixnum)
             0
             (* (logand (+ 2 (uvsize i)) (lognot 1)) 4))))
    (multiple-value-bind (user-start system-start)
        (%internal-run-time)
      (multiple-value-bind (minor-start major-start swaps-start)
          (%page-fault-info)
        (let* ((initial-real-time (get-internal-real-time))
               (initial-gc-time (gctime))
               (initial-consed (total-bytes-allocated))           
               (initial-overhead (integer-size-in-bytes initial-consed)))
          (let* ((results (multiple-value-list (funcall thunk))))
            (declare (dynamic-extent results))
            (multiple-value-bind (user-end system-end)
                (%internal-run-time)
              (multiple-value-bind (minor-end major-end swaps-end)
                  (%page-fault-info)
                (let* ((new-consed (total-bytes-allocated))		     
                       (bytes-consed
                        (- new-consed (+ initial-overhead initial-consed)))
                       (elapsed-real-time
                        (- (get-internal-real-time) initial-real-time))
                       (elapsed-gc-time (- (gctime) initial-gc-time))
                       (elapsed-user-time
                        (- user-end user-start))
                       (elapsed-system-time
                        (- system-end system-start))
                       (elapsed-minor (- minor-end minor-start))
                       (elapsed-major (- major-end major-start))
                       (elapsed-swaps (- swaps-end swaps-start)))
                  (funcall (or *report-time-function*
                               #'standard-report-time)
                           :form form
                           :results results
                           :elapsed-time elapsed-real-time
                           :user-time elapsed-user-time
                           :system-time elapsed-system-time
                           :gc-time elapsed-gc-time
                           :bytes-allocated bytes-consed
                           :minor-page-faults elapsed-minor
                           :major-page-faults elapsed-major
                           :swaps elapsed-swaps))))))))))





(defun add-feature (thing)
  (when (typep thing 'symbol)
    (let* ((gvector-or-fixnum (%symptr-binding-address '*features*)))
      (if (typep gvector-or-fixnum 'fixnum)
        ;; Thread-local binding of *FEATURES*.
        (if (not (member thing *features* :test #'eq))
          (setq *features* (cons thing *features*)))
        (loop
          (let* ((old (%svref gvector-or-fixnum target::symbol.vcell-cell)))
            (when (member thing old :test #'eq)
              (return))
            (let* ((new (cons thing old)))
              (when (store-gvector-conditional target::symbol.vcell-cell
                                               gvector-or-fixnum
                                               old
                                               new)
                (return)))))))
    thing))

(defun remove-feature (thing)
  (let* ((gvector-or-fixnum (%symptr-binding-address '*features*)))
    (if (typep gvector-or-fixnum 'fixnum)
      ;; Thread-local binding of *FEATURES*.
      (setq *features* (delete thing *features*))
      (loop
        (let* ((old (%svref gvector-or-fixnum target::symbol.vcell-cell)))
          (unless (member thing old :test #'eq)
            (return))
          (let* ((new (remove thing old)))
            (when (store-gvector-conditional target::symbol.vcell-cell
                                           gvector-or-fixnum
                                           old
                                           new)
              (return))))))
    thing))
  





;;; Misc string functions


(defun string-left-trim (char-bag string &aux end)
  "Given a set of characters (a list or string) and a string, returns
  a copy of the string with the characters in the set removed from the
  left end."
  (setq string (string string))
  (setq end (length string))
  (do ((index 0 (%i+ index 1)))
      ((or (eq index end) (not (find (aref string index) char-bag)))
       (subseq string index end))))

(defun string-right-trim (char-bag string &aux end)
  "Given a set of characters (a list or string) and a string, returns
  a copy of the string with the characters in the set removed from the
  right end."
  (setq string (string string))
  (setq end (length string))
  (do ((index (%i- end 1) (%i- index 1)))
      ((or (%i< index 0) (not (find (aref string index) char-bag)))
       (subseq string 0 (%i+ index 1)))))

(defun string-trim (char-bag string &aux end)
  "Given a set of characters (a list or string) and a string, returns a
  copy of the string with the characters in the set removed from both
  ends."
  (setq string (string string))
  (setq end (length string))
  (let ((left-end) (right-end))
     (do ((index 0 (%i+ index 1)))
	 ((or (eq index end) (not (find (aref string index) char-bag)))
	  (setq left-end index)))
     (do ((index (%i- end 1) (%i- index 1)))
	 ((or (%i< index left-end) (not (find (aref string index) char-bag)))
	  (setq right-end index)))
      (subseq string left-end (%i+ right-end 1))))



(defun copy-symbol (symbol &optional (copy-props nil) &aux new-symbol def)
  "Make and return a new uninterned symbol with the same print name
  as SYMBOL. If COPY-PROPS is false, the new symbol is neither bound
  nor fbound and has no properties, else it has a copy of SYMBOL's
  function, value and property list."
  (setq new-symbol (make-symbol (symbol-name symbol)))
  (when copy-props
      (when (boundp symbol)
            (set new-symbol (symbol-value symbol)))
      (when (setq def (fboundp symbol))
            ;;;Shouldn't err out on macros/special forms.
            (%fhave new-symbol def))
      (set-symbol-plist new-symbol (copy-list (symbol-plist symbol))))
  new-symbol)


(defvar %gentemp-counter 0
  "Counter for generating unique GENTEMP symbols.")

(defun gentemp (&optional (prefix "T") (package *package*))
  "Creates a new symbol interned in package PACKAGE with the given PREFIX."
  (loop
    (let* ((new-pname (%str-cat (ensure-simple-string prefix) 
                                (%integer-to-string %gentemp-counter)))
           (sym (find-symbol new-pname package)))
      (if sym
        (setq %gentemp-counter (%i+ %gentemp-counter 1))
        (return (values (intern new-pname package))))))) ; 1 value.




(defun add-gc-hook (hook-function &optional (which-hook :pre-gc))
  (ecase which-hook
    (:pre-gc
     (pushnew hook-function *pre-gc-hook-list*)
     (setq *pre-gc-hook* #'(lambda ()
                             (dolist (hook *pre-gc-hook-list*)
                               (funcall hook)))))
    (:post-gc
     (pushnew hook-function *post-gc-hook-list*)
     (setq *post-gc-hook* #'(lambda ()
                             (dolist (hook *post-gc-hook-list*)
                               (funcall hook))))))
  hook-function)

(defun remove-gc-hook (hook-function &optional (which-hook :pre-gc))
  (ecase which-hook
    (:pre-gc
     (unless (setq *pre-gc-hook-list* (delq hook-function *pre-gc-hook-list*))
       (setq *pre-gc-hook* nil)))
    (:post-gc
     (unless (setq *post-gc-hook-list* (delq hook-function *post-gc-hook-list*))
       (setq *post-gc-hook* nil)))))






(defun find-method-by-names (name qualifiers specializers)
  (let ((gf (fboundp name)))
    (when gf
      (if (not (standard-generic-function-p gf))
        (error "~S is not a generic-function." gf)
        (let ((methods (%gf-methods gf)))
          (when methods
            (let* ((spec-len (length (%method-specializers (car methods))))
                   (new-specs (make-list spec-len :initial-element (find-class t))))
              (declare (dynamic-extent new-specs))
              (do ((specs specializers (cdr specs))
                   (nspecs new-specs (cdr nspecs)))
                  ((or (null specs) (null nspecs)))
                (let ((s (car specs)))
                  (rplaca nspecs (if (consp s) s (find-class s nil)))))
              (find-method gf qualifiers new-specs nil))))))))




(defun make-population (&key (type :list) initial-contents)
  (let* ((ntype (ecase type
                  (:list $population_weak-list)
                  (:alist $population_weak-alist)))
         (list (if (eq type :alist)
                 (map 'list (lambda (c) (cons (car c) (%cdr c))) initial-contents)
                 (if (listp initial-contents)
                   (copy-list initial-contents)
                   (coerce initial-contents 'list)))))
    (%cons-population list ntype)))

(defun population-type (population)
  (let ((ntype (population.type (require-type population 'population))))
    (cond ((eq ntype $population_weak-alist) :alist)
          ((eq ntype $population_weak-list) :list)
          (t nil))))

(declaim (inline population-contents (setf population-contents)))

(defun population-contents (population)
  (population.data (require-type population 'population)))

(defun (setf population-contents) (list population)
  (setf (population.data (require-type population 'population)) (require-type list 'list)))




(defun get-string-from-user (prompt)
  (with-terminal-input
      (format *query-io* "~&~a " prompt)
    (force-output *query-io*)
    (clear-input *query-io*)
    (values (read-line *query-io*))))


(defun select-item-from-list (list &key (window-title "Select one of the following")
				   (table-print-function #'prin1)
				   &allow-other-keys)
  (block get-answer
    (with-terminal-input
      (format *query-io* "~a:~%" window-title)
      (loop
	 (catch :redisplay
	   (do* ((l list (cdr l))
		 (i 0 (1+ i))
		 (item (car l) (car l)))
		((null l))
	     (declare (fixnum i))
	     (format *query-io* "~&  ~d: " i)
	     (funcall table-print-function item *query-io*))
	   (loop
	      (fresh-line *query-io*)
	      (let* ((string (get-string-from-user "Selection [number,q,r,?]:"))
		     (value (ignore-errors
			      (let* ((*package* *keyword-package*))
				(read-from-string string nil)))))
		(cond ((eq value :q) (throw :cancel t))
		      ((eq value :r) (throw :redisplay t))
		      ((eq value :?) 
		       (format *query-io* "~%Enter the number of the selection, ~%  r to redisplay, ~%  q to cancel or ~%  ? to show this message again."))
		      ((and (typep value 'unsigned-byte)
			    (< value (length list)))
		       (return-from get-answer (list (nth value list))))))))))))

(defvar *choose-file-dialog-hook* nil "for GUIs")
(defvar *choose-directory-dialog-hook* nil "for GUIs")

;;; There should ideally be some way to override the UI (such as
;;; it is ...) here.
;;; More generally, this either
;;;   a) shouldn't exist, or
;;;   b) should do more sanity-checking
(defun choose-file-dialog (&key file-types (prompt "File name:"))
  (let* ((hook *choose-file-dialog-hook*))
    (if hook
      (funcall hook t prompt file-types)
      (%choose-file-dialog t prompt file-types))))

(defun choose-new-file-dialog (&key prompt)
  (let* ((hook *choose-file-dialog-hook*))
    (if hook
      (funcall hook nil prompt nil)
      (%choose-file-dialog nil prompt nil))))

(defun %choose-file-dialog (must-exist prompt file-types)
  (loop
      (let* ((namestring (get-string-from-user prompt))
	     (pathname (ignore-errors (pathname namestring)))
	     (exists (and pathname (probe-file pathname))))
	(when (and (if must-exist exists)
		   (or (null file-types)
		       (member (pathname-type pathname)
			       file-types :test #'equal)))
	  (return pathname))
	(if (not exists)
	  (format *query-io* "~&~s does not exist." namestring)
	  (format *query-io* "~&Type of ~s is not one of ~{~a~}"
		  namestring file-types)))))

(defun choose-directory-dialog (&key directory)
  (let* ((hook *choose-directory-dialog-hook*))
    (when hook
      (funcall hook :directory directory))))

(defparameter *overwrite-dialog-hook* nil)
(defun overwrite-dialog (filename prompt)
  (if *overwrite-dialog-hook*
    (funcall *overwrite-dialog-hook* filename prompt)
    t))

(defparameter *disassemble-verbose* nil)

;;; Might want to have some other entry for, e.g., the inspector
;;; and to let it get its hands on the list header returned by 
;;; disassemble-ppc-function.  Maybe disassemble-ppc-function
;;; should take care of "normalizing" the code-vector ?
(defun disassemble (thing)
  "Disassemble the compiled code associated with OBJECT, which can be a
  function, a lambda expression, or a symbol with a function definition. If
  it is not already compiled, the compiler is called to produce something to
  disassemble."
  (#+ppc-target ppc-xdisassemble
   #+x86-target x86-xdisassemble
   #+arm-target arm-xdisassemble
   (require-type (function-for-disassembly thing) 'compiled-function)))

(defun function-for-disassembly (thing)
  (let* ((fun thing))
    ;; CLHS says that DISASSEMBLE should signal a type error if its
    ;; argument isn't a function designator.  Hard to imagine any
    ;; code depending on that ...
    ;;(when (typep fun 'standard-method) (setq fun (%method-function fun)))
    (when (or (symbolp fun)
              (and (consp fun) (neq (%car fun) 'lambda)))
      (setq fun (fboundp thing))
      (when (and (symbolp thing) (not (functionp fun)))
        (setq fun (macro-function thing))))
    (if (typep fun 'compiled-lexical-closure)
        (setq fun (closure-function fun)))
    (when (lambda-expression-p fun)
      (setq fun (compile-named-function fun)))
    fun))

(%fhave 'df #'disassemble)

(defun string-sans-most-whitespace (string &optional (max-length (length string)))
  (with-output-to-string (sans-whitespace)
    (loop
      for count below max-length
      for char across string
      with just-saw-space = nil
      if (member char '(#\Space #\Tab #\Newline #\Return #\Formfeed))
        do (if just-saw-space
               (decf count)
               (write-char #\Space sans-whitespace))
        and do (setf just-saw-space t)
      else
        do (setf just-saw-space nil)
        and do (write-char char sans-whitespace))))


(defparameter *svn-program* "svn")

(defloadvar *use-cygwin-svn*
    #+windows-target (not (null (getenv "CYGWIN")))
    #-windows-target nil)

(defun run-svn (args &key (output :string) (error :output) (if-fail :error ifp))
  (if (eq output :stream)
    (external-process-output-stream (run-program *svn-program* args :output :stream :error error :wait nil))
    (flet ((check-status (proc)
             (multiple-value-bind (status exit-code) (external-process-status proc)
               (unless (and (eq status :exited) (or (not ifp) (zerop exit-code)))
                 (if (eq if-fail :error)
                   (error "Running \"svn ~a\" produced exit status ~s, code ~s" (car args) status exit-code)
                   (return-from run-svn if-fail))))
             proc))
      (if (eq output :string)
        (with-output-to-string (stream)
          (check-status (run-program *svn-program* args :output stream :error error)))
        (check-status (run-program *svn-program* args :output output :error error))))))

(defun svn-info-component (component)
  (let ((component-length (length component))
        (string (run-svn (list "info" (native-translated-namestring "ccl:")) :if-fail nil)))
    (when string
      (with-input-from-string (output string)
        (do* ((line (read-line output nil nil) (read-line output nil nil)))
             ((null line))
          (when (and (>= (length line) component-length)
                     (string= component line :end2 component-length))
            (return-from svn-info-component
              (string-trim " " (subseq line component-length))))))
      nil)))

(defun svn-url () (svn-info-component "URL:"))
(defun svn-repository () (svn-info-component "Repository Root:"))

;;; Try to say something about what tree (trunk, a branch, a release)
;;; we were built from. If the URL (relative to the repository)
;;; starts with "branches", return the second component of the
;;; relative URL, otherwise return the first component.
(defun svn-tree ()
  (let* ((repo (svn-repository))
         (url (svn-url)))
    (or 
     (if (and repo url)
       (let* ((repo-len (length repo)))
         (when (and (> (length url) repo-len)
                    (string= repo url :end2 repo-len))
           ;; Cheat: do pathname parsing here.
           (let* ((path (pathname (ensure-directory-namestring (subseq url repo-len))))
                  (dir (cdr (pathname-directory path))))
             (when (string= "ccl" (car (last dir)))
               (let* ((base (car dir)))
                 (unless (or (string= base "release")
                             (string= base "releases"))
                   (if (string= base "branches")
                     (cadr dir)
                     (car dir))))))))))))


(defun svnversion-program ()
  (or (ignore-errors
        (native-translated-namestring
         (merge-pathnames "svnversion" *svn-program*)))
      "svnversion"))

(defun local-git-revision ()
  (let ((s (make-string-output-stream))
	(git-dir (native-translated-namestring
		  (merge-pathnames (ccl-directory) ".git"))))
    (multiple-value-bind (status exit-code)
	(external-process-status
	 (run-program "git" (list "--git-dir" git-dir "describe" "HEAD")
		      :output s :error :output))
      (when (and (eq status :exited)
		 (= exit-code 0))
	(string-right-trim (list #\space #\newline)
			   (get-output-stream-string s))))))

(defun local-svn-revision ()
  (let* ((s (make-string-output-stream))
         (root (native-translated-namestring "ccl:")))
    (when *use-cygwin-svn*
      (setq root (cygpath root)))
    (multiple-value-bind (status exit-code)
        (external-process-status
         (run-program (svnversion-program)  (list (if *use-cygwin-svn*
                                                    (cygpath (native-translated-namestring "ccl:"))
                                                    (native-translated-namestring "ccl:"))
                                                    (or (svn-url) "")) :output s :error :output))
      (when (and (eq :exited status) (zerop exit-code))
        (with-input-from-string (output (get-output-stream-string s))
          (let* ((line (read-line output nil nil)))
            (when (and line (parse-integer line :junk-allowed t) )
              (return-from local-svn-revision line))))))
    nil))

(defun local-vc-revision ()
  (or (local-git-revision)
      (local-svn-revision)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; svn diffs

(defun get-svn-changes (&key (directory (current-directory)) (revision :base) (reverse nil))
  "Run svn diff to compare REVISION and working copy of DIRECTORY, and return a list of
  the changed regions (in the form of source notes) in the working copy.  If REVERSE is true,
  returns regions in the REVISION version rather than the working copy."
  (let* ((svn-revision (format nil "-r~a" revision))
         (diff (run-svn `("diff" ,svn-revision ,(native-translated-namestring directory)))))
    (unless (equal diff "")
      (unless (string-equal "Index: " diff :end2 7)
        (error "Cannot understand svn output: ~s" diff))
      (parse-svn-changes diff directory (if reverse svn-revision)))))

(defun parse-svn-changes (string directory svn-revision)
  ;; Parse svn diff output string into source-note's
  (unless (equal string "")
    (assert (string-equal "Index: " string :end2 7))
    (loop
      for pos = 7 then (+ end 8)
      as file = (subseq string pos (setq pos (position #\newline string :start pos)))
      as pathname = (merge-pathnames file directory)
      as end = (search #.(%str-cat (string #\newline) "Index: ") string :start2 pos)
      nconc (parse-svn-changes-in-file string pos end pathname svn-revision)
      while end)))

(defun parse-svn-changes-in-file (string pos end pathname svn-revision)
  (let* ((line-ranges (parse-svn-changed-lines-in-file string (1+ pos) (or end (length string)) svn-revision))
         (lines (loop for (start-line . line-count) in line-ranges
                  collect start-line
                  collect (+ start-line line-count)))
         ;; Convert line ranges to character ranges.
         (line-posns (flet ((posns (stream)
                              (flet ((skip-lines (stream count)
                                       (let ((chars 0))
                                         (loop while (> count 0)
                                           do (let ((ch (read-char stream)))
                                                (loop until (or (eql ch #\newline) (null ch))
                                                  do (incf chars)
                                                  do (setq ch (read-char stream nil)))
                                                (when ch (incf chars))
                                                (decf count)))
                                         chars)))
                                (loop
                                  for last-line = 1 then line-no
                                  for last-pos = 0 then pos
                                  for line-no in (remove-duplicates (sort lines #'<))
                                  for pos = (+ last-pos (skip-lines stream (- line-no last-line)))
                                  collect (cons line-no pos)))))
                       (if svn-revision
                         (let ((stream (run-svn `("cat"
                                                  ,svn-revision
                                                  ,(native-translated-namestring pathname))
                                                :output :stream)))
                           (posns stream))
                         (with-open-file (stream pathname) (posns stream))))))
    (loop for (start-line . line-count) in line-ranges
      collect (make-source-note :filename pathname
                                :start-pos (cdr (assq start-line line-posns))
                                :end-pos (cdr (assq (+ start-line line-count) line-posns))))))


(defun parse-svn-changed-lines-in-file (string start end svn-revision)
  (flet ((next-line (str start end)
           (let ((pos (position #\Newline str :start start :end end)))
             (if pos (1+ pos) end))))
    (unless (eql start end)
      (assert 
       (let ((pos start))
         (and (loop repeat 67 always (eql (char string pos) #\=) do (incf pos))
              (eql (char string pos) #\Newline)
              (string-equal "--- " string :start2 (incf pos) :end2 (+ pos 4))
              (setq pos (position #\newline string :start pos))
              (string-equal "+++ " string :start2 (incf pos) :end2 (+ pos 4))
              (< pos end)
              (or (null (setq pos (position #\newline string :start pos :end end)))
                  (string-equal "@@ -" string :start2 (1+ pos) :end2 (+ pos 5))))))
      (when (setq start (search #.(%str-cat (string #\newline) "@@ -") string :start2 start :end2 end))
        (incf start)
        (loop
          do (incf start 4)
          collect (multiple-value-bind (start-line npos)
                                       (parse-integer string
                                                      :start (if svn-revision
                                                               start
                                                               (1+ (position #\+ string :start start :end end)))
                                                      :end end
                                                      :junk-allowed t)
                    (assert (eql (char string npos) #\,))
                    (multiple-value-bind (num-lines npos) (parse-integer string :start (1+ npos) :end end
                                                                         :junk-allowed t)
                      (assert (eql (char string npos) #\space))
                      ;; adjust for context lines
                      (loop with first = t
                        as ch = (and (< (setq npos (next-line string npos end)) end)
                                     (char string npos))
                        while (memq ch '(#\space #\+ #\-))
                        do (cond ((eq ch #\space)
                                  (decf num-lines)
                                  (when first (incf start-line)))
                                 (t (setq first nil)))
                        finally (setq start npos))
                      (cons start-line num-lines)))
          while (and (< (+ start 4) end) (string-equal "@@ -" string :start2 start :end2 (+ start 4)))
          finally (assert (eql start end)))))))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Scan the heap, collecting infomation on the primitive object types
;;; found.  Report that information.

(defun heap-utilization (&key (stream *debug-io*)
                              (gc-first t)
                              (area nil)
                              (unit nil)
                              (sort :size)
                              (classes nil)
                              (start nil)
                              (threshold (and classes 0.00005)))
  "Show statistics about types of objects in the heap.
   If :GC-FIRST is true (the default), do a full gc before scanning the heap.
   If :START is non-nil, it should be an object returned by GET-ALLOCATION-SENTINEL, only
     objects at higher address are scanned (i.e. roughly, only objects allocated after it).
   :SORT can be one of :COUNT, :LOGICAL-SIZE, or :PHYSICAL-SIZE to sort by count or size.
   :UNIT can be one of :KB :MB or :GB to show sizes in units other than bytes.
   :AREA can be used to restrict the walk to one area or a list of areas.  Some possible
   values are :DYNAMIC, :STATIC, :MANAGED-STATIC, :READONLY.  By default, all areas
   (including stacks) are examined.
   If :CLASSES is true, classifies by class rather than just typecode"
  (let ((data (collect-heap-utilization :gc-first gc-first :start start :area area :classes classes)))
    (report-heap-utilization data :stream stream :unit unit :sort sort :threshold threshold)))

(defun collect-heap-utilization (&key (gc-first t) start area classes)
  ;; returns list of (type-name count logical-sizes-total physical-sizes-total)
  (when start
    (unless (or (null area)
                (eq (heap-area-code area) area-dynamic)
                (and (consp area) (every (lambda (a) (eq (heap-area-code a) area-dynamic)) area)))
      (error "~s ~s and ~s ~s are incompatible" :start start :area area))
    (setq area area-dynamic))
  (if classes
    (collect-heap-utilization-by-class gc-first area start)
    (collect-heap-utilization-by-typecode gc-first area start)))

(defun collect-heap-utilization-by-typecode (gc-first area start)
  (let* ((nconses 0)
         (counts (make-array 257))
         (sizes (make-array 257))
         (physical-sizes (make-array 257))
         (array-size-function (arch::target-array-data-size-function
                               (backend-target-arch *host-backend*))))
    (declare (type (simple-vector 257) counts sizes physical-sizes)
             (fixnum nconses)
             (dynamic-extent counts sizes physical-sizes))
    (flet ((collect (thing)
             (when (or (null start)
                       (locally (declare (optimize (speed 3) (safety 0))) ;; lie
                         (%i< start thing)))
               (if (listp thing)
                 (incf nconses)
                 (let* ((typecode (typecode thing))
                        (logsize (funcall array-size-function typecode (uvsize thing)))
                        (physize (logandc2 (+ logsize
                                              #+64-bit-target (+ 8 15)
                                              #+32-bit-target (+ 4 7))
                                           #+64-bit-target 15
                                           #+32-bit-target 7)))
                   (incf (aref counts typecode))
                   (incf (aref sizes typecode) logsize)
                   (incf (aref physical-sizes typecode) physize))))))
      (declare (dynamic-extent #'collect))
      (when gc-first (gc))
      (%map-areas #'collect area))
    (setf (aref counts 256) nconses)
    (setf (aref sizes 256) (* nconses target::cons.size))
    (setf (aref physical-sizes 256) (aref sizes 256))
    (loop for i from 0 upto 256
      when (plusp (aref counts i))
      collect (list (if (eql i 256) 'cons (aref *heap-utilization-vector-type-names* i))
                    (aref counts i)
                    (aref sizes i)
                    (aref physical-sizes i)))))

(defun collect-heap-utilization-by-class (gc-first area start)
  (let* ((nconses 0)
         (max-classes (+ 100 (hash-table-count %find-classes%)))
         (map (make-hash-table :shared nil
                               :test 'eq
                               :size max-classes))
         (inst-counts (make-array max-classes :initial-element 0))
         (slotv-counts (make-array max-classes :initial-element 0))
         (inst-sizes (make-array max-classes :initial-element 0))
         (slotv-sizes (make-array max-classes :initial-element 0))
         (inst-psizes (make-array max-classes :initial-element 0))
         (slotv-psizes (make-array max-classes :initial-element 0))
         (overflow nil)
         (array-size-function (arch::target-array-data-size-function
                               (backend-target-arch *host-backend*))))
    (declare (type simple-vector inst-counts slotv-counts inst-sizes slotv-sizes inst-psizes slotv-psizes))
    (flet ((collect (thing)
             (when (or (null start)
                       (locally (declare (optimize (speed 3) (safety 0))) ;; lie
                         (%i< start thing)))
               (if (listp thing)
                 (incf nconses)
                 (unless (or (eq thing map)
                             (eq thing (nhash.vector map))
                             (eq thing inst-counts)
                             (eq thing slotv-counts)
                             (eq thing inst-sizes)
                             (eq thing slotv-sizes)
                             (eq thing inst-psizes)
                             (eq thing slotv-psizes))
                   (let* ((typecode (typecode thing))
                          (logsize (funcall array-size-function typecode (uvsize thing)))
                          (physize (logandc2 (+ logsize
                                                #+64-bit-target (+ 8 15)
                                                #+32-bit-target (+ 4 7))
                                             #+64-bit-target 15
                                             #+32-bit-target 7))
                          (class (class-of (if (eql typecode target::subtag-slot-vector)
                                             (uvref thing slot-vector.instance)
                                             (if (eql typecode target::subtag-function)
                                               (function-vector-to-function thing)
                                               thing))))
                          (index (or (gethash class map)
                                     (let ((count (hash-table-count map)))
                                       (if (eql count max-classes)
                                         (setq overflow t count (1- max-classes))
                                         (setf (gethash class map) count))))))
                   
                     (if (eql typecode target::subtag-slot-vector)
                       (progn
                         (incf (aref slotv-counts index))
                         (incf (aref slotv-sizes index) logsize)
                         (incf (aref slotv-psizes index) physize))
                       (progn
                         (incf (aref inst-counts index))
                         (incf (aref inst-sizes index) logsize)
                         (incf (aref inst-psizes index) physize)))))))))
      (declare (dynamic-extent #'collect))
      (when gc-first (gc))
      (%map-areas #'collect area))
    (let ((data ()))
      (when (plusp nconses)
        (push (list 'cons nconses (* nconses target::cons.size) (* nconses target::cons.size)) data))
      (maphash (lambda (class index)
                 (let* ((icount (aref inst-counts index))
                        (scount (aref slotv-counts index))
                        (name (if (and overflow (eql index (1- max-classes)))
                                "All others"
                                (or (%class-proper-name class) class))))
                   (declare (fixnum icount) (fixnum scount))
                   ;; When printing class names, the package matters.  report-heap-utilization
                   ;; uses ~a, so print here.
                   (when (plusp icount)
                     (push (list (prin1-to-string name)
                                 icount (aref inst-sizes index) (aref inst-psizes index)) data))
                   (when (plusp scount)
                     (push (list (format nil "~s slot vector" name)
                                 scount (aref slotv-sizes index) (aref slotv-psizes index)) data))))
               map)
      data)))

(defun collect-heap-ivector-utilization-by-typecode ()
  (let* ((counts (make-array 256 :initial-element 0))
	 (sizes (make-array 256 :initial-element 0))
	 (physical-sizes (make-array 256 :initial-element 0))
	 (array-size-function (arch::target-array-data-size-function
                               (backend-target-arch *host-backend*)))
	 (result ()))
    (declare (dynamic-extent counts sizes))
    (with-lock-grabbed (*heap-ivector-lock*)
      (dolist (vector *heap-ivectors*)
	(let* ((typecode (typecode vector))
	       (logsize (funcall array-size-function typecode (uvsize vector)))
	       (physsize (+ logsize
			    ;; header, delta, round up
			    #+32-bit-target (+ 4 2 7)
			    #+64-bit-target (+ 8 2 15))))
	  (incf (aref counts typecode))
	  (incf (aref sizes typecode) logsize)
	  (incf (aref physical-sizes typecode) physsize))))
    (dotimes (i 256 result)
      (when (plusp (aref counts i))
	(push (list (aref *heap-utilization-vector-type-names* i)
		    (aref counts i)
		    (aref sizes i)
		    (aref physical-sizes i))
	      result)))))

(defun heap-ivector-utilization (&key (stream *debug-io*)
				      (unit nil)
				      (sort :size))
  (let* ((data (collect-heap-ivector-utilization-by-typecode)))
    (report-heap-utilization data :stream stream :unit unit :sort sort)))
  
(defvar *heap-utilization-vector-type-names*
  (let* ((a (make-array 256)))
    #+x8664-target
    (dotimes (i 256)
      (let* ((fulltag (logand i x8664::fulltagmask))
             (names-vector
              (cond ((= fulltag x8664::fulltag-nodeheader-0)
                     *nodeheader-0-types*)
                    ((= fulltag x8664::fulltag-nodeheader-1)
                     *nodeheader-1-types*)
                    ((= fulltag x8664::fulltag-immheader-0)
                     *immheader-0-types*)
                    ((= fulltag x8664::fulltag-immheader-1)
                     *immheader-1-types*)
                    ((= fulltag x8664::fulltag-immheader-2)
                     *immheader-2-types*)))
             (name (if names-vector
                     (aref names-vector (ash i -4)))))
        ;; Special-case a few things ...
        (if (eq name 'symbol-vector)
          (setq name 'symbol)
          (if (eq name 'function-vector)
            (setq name 'function)))
        (setf (aref a i) name)))
    #+ppc64-target
    (dotimes (i 256)
      (let* ((lowtag (logand i ppc64::lowtagmask)))
        (setf (%svref a i)
              (cond ((= lowtag ppc64::lowtag-immheader)
                     (%svref *immheader-types* (ash i -2)))
                    ((= lowtag ppc64::lowtag-nodeheader)
                     (%svref *nodeheader-types* (ash i -2)))))))
    #+(or ppc32-target x8632-target arm-target)
    (dotimes (i 256)
      (let* ((fulltag (logand i target::fulltagmask)))
        (setf (%svref a i)
              (cond ((= fulltag target::fulltag-immheader)
                     (%svref *immheader-types* (ash i -3)))
                    ((= fulltag target::fulltag-nodeheader)
                     (%svref *nodeheader-types* (ash i -3)))))))
    a))

  
(defun report-heap-utilization (data &key stream unit sort threshold)
  (check-type threshold (or null (real 0 1)))
  (let* ((div (ecase unit
                ((nil) 1)
                (:kb 1024.0d0)
                (:mb (* 1024.0d0 1024.0d0))
                (:gb (* 1024.0d0 1024.0d0 1024.0d0))))
         (sort-key (ecase sort
                     (:count #'cadr)
                     (:logical-size #'caddr)
                     ((:physical-size :size) #'cadddr)
                     ((:name nil) nil)))
         (total-count 0)
         (total-lsize 0)
         (total-psize 0)
         (max-name 0)
         (others (list "All others" 0 0 0)))

    (when (hash-table-p data)
      (setq data
            (let ((alist nil))
              (maphash (lambda (type measures) (push (cons type measures) alist)) data)
              alist)))

    (flet ((type-string (name)
             (if (stringp name)
               name
               (if (symbolp name)
                 (symbol-name name)
                 (princ-to-string name)))))
      (loop for (nil count lsize psize) in data
            do (incf total-count count)
            do (incf total-lsize lsize)
            do (incf total-psize psize))

      (when (and data threshold)
        (setq data (sort data #'< :key #'cadddr))
        (loop while (< (/ (cadddr (car data)) total-psize) threshold)
              do (destructuring-bind (type count lsize psize) (pop data)
                   (declare (ignore type))
                   (incf (cadr others) count)
                   (incf (caddr others) lsize)
                   (incf (cadddr others) psize))))

      (setq data
            (if sort-key
              (sort data #'> :key sort-key)
              (sort data #'string-lessp :key #'(lambda (s) (type-string (car s))))))

      (when (> (cadr others) 0)
        (setq data (nconc data (list others))))

      (setq max-name (loop for (name) in data maximize (length (type-string name))))

      (format stream "~&Object type~vtCount     Logical size   Physical size   % of Heap~%~vt ~a~vt ~2:*~a"
              (+ max-name 7)
              (+ max-name 15)
              (ecase unit
                ((nil) "  (in bytes)")
                (:kb   "(in kilobytes)")
                (:mb   "(in megabytes)")
                (:gb   "(in gigabytes)"))
              (+ max-name 31))
      (loop for (type count logsize physsize) in data
            do (if unit
                 (format stream "~&~a~vt~11d~16,2f~16,2f~11,2f%"
                         (type-string type)
                         (1+ max-name)
                         count
                         (/ logsize div)
                         (/ physsize div)
                         (* 100.0 (/ physsize total-psize)))
                 (format stream "~&~a~vt~11d~16d~16d~11,2f%"
                         (type-string type)
                         (1+ max-name)
                         count
                         logsize
                         physsize
                         (* 100.0 (/ physsize total-psize)))))
      (if unit
        (format stream "~&~a~vt~11d~16,2f~16,2f~11,2f%~%"
                "Total"
                (1+ max-name)
                total-count
                (/ total-lsize div)
                (/ total-psize div)
                100.0d0)
        (format stream "~&~a~vt~11d~16d~16d~11,2f%~%"
                "Total"
                (1+ max-name)
                total-count
                total-lsize
                total-psize
                100.0d0))))
  (values))

(defun object-direct-size (thing)
  "Returns the size of THING (in bytes), including any headers and
   alignment overhead.  Does not descend an object's components."
  (cond ((consp thing) #+64-bit-target 16 #+32-bit-target 8)
        #+x8664-target ((symbolp thing)
                        (object-direct-size (%symptr->symvector thing)))
        #+x8664-target ((functionp thing)
                        (object-direct-size (function-to-function-vector thing)))
        ((uvectorp thing)
         (let* ((typecode (ccl::typecode thing))
                (element-count (ccl::uvsize thing))
                (sizeof-content-in-octets
                 ;; Call the architecture-specific backend function.
                 (funcall (arch::target-array-data-size-function
                           (backend-target-arch *host-backend*))
                          typecode element-count)))
           (logandc2 (+ sizeof-content-in-octets
                           #+64-bit-target (+ 8 15)
                           #+32-bit-target (+ 4 7))
                     #+64-bit-target 15
                     #+32-bit-target 7)))
        (t 0)))

(defun kernel-global-address (global)
  (check-type global symbol)
  (+ (target-nil-value) (target::%kernel-global global)))

(defloadvar *static-cons-address* (%int-to-ptr (kernel-global-address 'static-conses)))

(defloadvar *free-static-cons-address* (%int-to-ptr (kernel-global-address 'free-static-conses)))

(defun static-cons (car-value cdr-value)
  "Allocates a cons cell that doesn't move on garbage collection,
   and thus doesn't trigger re-hashing when used as a key in a hash
   table.  Usage is equivalent to regular CONS."
  (let* ((addr *static-cons-address*)
         (freeaddr  *free-static-cons-address*))
    (loop
      (with-exception-lock
          (without-interrupts      
           (let ((cell (%get-object addr 0)))
             (if cell
               (progn
                 (%set-object addr 0 (cdr cell))
                 (%set-object freeaddr 0 (1- (%get-object freeaddr 0)))
                 (setf (car cell) car-value)
                 (setf (cdr cell) cdr-value)
                 (return cell))
               (progn
                 (%ensure-static-conses)))))))))

(defun free-static-conses ()
  (%get-kernel-global free-static-conses))

(defun reserved-static-conses ()
  (%fixnum-ref-natural (%get-kernel-global static-cons-area) target::area.ndnodes))
	

(defparameter *weak-gc-method-names*
  '((:traditional . 0)
    (:non-circular . 1)))


(defun weak-gc-method ()
  (or (car (rassoc (%get-kernel-global 'weak-gc-method)
                   *weak-gc-method-names*))
      :traditional))


(defun (setf weak-gc-method) (name)
  (setf (%get-kernel-global 'weak-gc-method)
        (or (cdr (assoc name *weak-gc-method-names*))
            0))
  name)

(defun %lock-whostate-string (string lock)
  (with-standard-io-syntax
      (format nil "~a for ~a ~@[~a ~]@ #x~x"
              string
              (%svref lock target::lock.kind-cell)
              (lock-name lock)
              (%ptr-to-int (%svref lock target::lock._value-cell)))))

(defun all-watched-objects ()
  (let (result)
    (with-other-threads-suspended
      (%map-areas #'(lambda (x) (push x result)) area-watched))
    result))

(defun primitive-watch (thing)
  (require-type thing '(or cons (satisfies uvectorp)))
  (%watch thing))

(defun watch (&optional thing)
  (cond ((null thing)
	 (all-watched-objects))
	((arrayp thing)
	 (primitive-watch (array-data-and-offset thing)))
	((hash-table-p thing)
	 (primitive-watch (nhash.vector thing)))
	((standard-instance-p thing)
	 (primitive-watch (instance-slots thing)))
	(t
	 (primitive-watch thing))))

(defun unwatch (thing)
  (with-other-threads-suspended
    (%map-areas #'(lambda (x)
		    (when (eq x thing)
		      (let ((new (if (uvectorp thing)
				   (%alloc-misc (uvsize thing)
						(typecode thing))
				   (cons nil nil))))
			(return-from unwatch (%unwatch thing new)))))
                area-watched)))

(defun %parse-unsigned-integer (vector start end)
  (declare ((simple-array (unsigned-byte 8) (*)) vector)
           (fixnum start end)
           (optimize (speed 3) (safety 0)))
  (let* ((count (- end start))
         (msb 0))
    (declare (fixnum count) ((unsigned-byte 8) msb))
    (or
     (do* ((i start (1+ i)))
          ((>= i end) 0)
       (declare (fixnum i))
       (let* ((b (aref vector i)))
         (declare ((unsigned-byte 8) b))
         (cond ((zerop b) (incf start) (decf count))
               (t (setq msb b) (return)))))
     (cond
       ((or (< count #+64-bit-target 8 #+32-bit-target 4)
            (and (= count #+64-bit-target 8 #+32-bit-target 4)
                 (< msb #+64-bit-target 16 #+32-bit-target 32)))
        ;; Result will be a fixnum.
        (do* ((result 0)
              (shift 0 (+ shift 8))
              (i (1- end) (1- i)))
             ((< i start) result)
          (declare (fixnum result shift i))
          (setq result (logior result (the fixnum (%ilsl shift (aref vector i)))))))
       (t
        ;; Result will be a bignum.  If COUNT is a multiple of 4
        ;; and the most significant bit is set, need to add an
        ;; extra word of zero-extension.
        (let* ((result (allocate-typed-vector :bignum
                                              (if (and (logbitp 7 msb)
                                                       (zerop (the fixnum (logand count 3))))
                                                (the fixnum (1+ (the fixnum (ash count -2))))
                                                (the fixnum (ash (the fixnum (+ count 3)) -2))))))
          (declare ((simple-array (unsigned-byte 8) (*)) result)) ; lie
          (dotimes (i count result)
            (decf end)
            (setf (aref result
                        #+little-endian-target i
                        #+big-endian-target (the fixnum (logxor i 3)))
                  (aref vector end)))))))))

  
;;; Octets between START and END encode an unsigned integer in big-endian
;;; byte order.
(defun parse-unsigned-integer (vector &optional (start 0) end)
  (setq end (check-sequence-bounds vector start end))
  (locally (declare (fixnum start end))
      (unless (typep vector '(simple-array (unsigned-byte 8) (*)))
        (multiple-value-bind (data offset) (array-data-and-offset vector)
          (declare (fixnum offset))
          (unless (typep data '(simple-array (unsigned-byte 8) (*)))
            (report-bad-arg vector '(vector (unsigned-byte 8))))
          (incf start offset)
          (incf end offset)
          (setq vector data)))
      (%parse-unsigned-integer vector start end)))

(defun %parse-signed-integer (vector start end)
  (declare ((simple-array (unsigned-byte 8) (*)) vector)
           (fixnum start end)
           (optimize (speed 3) (safety 0)))
  (let* ((count (- end start)))
    (declare (fixnum count))
    (if (zerop count)
      0
      (let* ((sign-byte (aref vector start)))
        (declare (fixnum sign-byte))
        (if (< sign-byte 128)
          (%parse-unsigned-integer vector start end)
          (progn
            (decf sign-byte 256)
            (or
             (do* ()
                  ((= count 1) sign-byte)
               (unless (= sign-byte -1)
                 (return))
               (let* ((next (1+ start))
                      (nextb (aref vector next)))
                 (declare (fixnum next nextb))
                 (if (not (logbitp 7 nextb))
                   (return))
                 (setq sign-byte (- nextb 256)
                       start next
                       count (1- count))))
             (cond ((or (< count #+64-bit-target 8 #+32-bit-target 4)
                        (and (= count #+64-bit-target 8 #+32-bit-target 4)
                             (>= sign-byte
                                 #+64-bit-target -16
                                 #+32-bit-target -32)))
                    ;; Result will be a fixnum
                    (do* ((result 0)
                          (shift 0 (+ shift 8))
                          (i (1- end) (1- i)))
                         ((= i start) (logior result (the fixnum (%ilsl shift sign-byte))))
                      (declare (fixnum result shift i))
                      (setq result (logior result (the fixnum (%ilsl shift (aref vector i)))))))
                   (t
                    (let* ((result (allocate-typed-vector :bignum (the fixnum (ash (the fixnum (+ count 3)) -2)))))
          (declare ((simple-array (unsigned-byte 8) (*)) result)) ; lie
          (dotimes (i count (do* ((i count (1+ i)))
                                 ((= 0 (the fixnum (logand i 3)))
                                  result)
                              (declare (fixnum i))
                              (setf (aref result
                                          #+little-endian-target i
                                          #+big-endian-target (the fixnum (logxor i 3))) #xff)))
            (decf end)
            (setf (aref result
                        #+little-endian-target i
                        #+big-endian-target (the fixnum (logxor i 3)))
                  (aref vector end)))))))))))))

(defun parse-signed-integer (vector &optional (start 0) end)
  (setq end (check-sequence-bounds vector start end))
  (locally (declare (fixnum start end))
    (unless (typep vector '(simple-array (unsigned-byte 8) (*)))
      (multiple-value-bind (data offset) (array-data-and-offset vector)
        (declare (fixnum offset))
        (unless (typep data '(simple-array (unsigned-byte 8) (*)))
          (report-bad-arg vector '(vector (unsigned-byte 8))))
        (incf start offset)
        (incf end offset)
        (setq vector data)))
    (%parse-signed-integer vector start end)))

#+windows-target
(defun open-null-device ()
  (rlet ((sa #>SECURITY_ATTRIBUTES
           #>nLength (record-length #>SECURITY_ATTRIBUTES)
           #>lpSecurityDescriptor +null-ptr+
           #>bInheritHandle #$TRUE))
    (with-filename-cstrs ((name "\\Device\\Null"))
      (let* ((handle (#_CreateFileW name
                                    (logior #$GENERIC_READ #$GENERIC_WRITE)
                                    (logior #$FILE_SHARE_READ #$FILE_SHARE_WRITE)
                                    sa
                                    #$OPEN_EXISTING
                                    #$FILE_ATTRIBUTE_NORMAL
                                    +null-ptr+)))
        (unless (eql handle #$INVALID_HANDLE_VALUE)
          handle)))))
;;; call into the CCL kernel to execute a CPUID instruction,  Yes it's
;;; a PITA to need to do this
#+x86-target
(defun x86-cpuid (selector)
  (rletz ((bx :unsigned-long)
          (cx :unsigned-long )
          (dx :unsigned-long))
    (values
     (external-call "cpuid"
                    :unsigned-long selector
                    :address bx
                    :address cx
                    :address dx
                    :unsigned-long)
     (pref bx :unsigned-long)
     (pref cx :unsigned-long)
     (pref dx :unsigned-long))))

(defun winning-function-p (f)
  (let* ((bits (lfun-bits f)))
    (unless (logbitp $lfbits-noname-bit bits)
      (logbitp 32 bits))))

#+x86-target
(defun rdtscp-p ()
  (logbitp 27 (nth-value 3 (x86-cpuid #x80000001))))

#+x86-target
(defun invariant-tsc-p ()
  (logbitp 8  (nth-value 3 (x86-cpuid #x80000007))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/misc.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/number-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
  (require "LISPEQU")
  )

(declare-arch-specific-macro %make-sfloat)

(declare-arch-specific-macro %make-dfloat)

(defmacro require-null-or-double-float-sym (sym)
  (setq sym (require-type sym 'symbol))
  `(when (and ,sym (not (double-float-p ,sym)))
     (setq ,sym (require-type ,sym 'double-float))))


(declare-arch-specific-macro %numerator)

(declare-arch-specific-macro %denominator)


(defmacro %realpart (x)
  (let* ((thing (gensym))
         (complex-single-float-tag (nx-lookup-target-uvector-subtag :complex-single-float))
         (complex-double-float-tag (nx-lookup-target-uvector-subtag :complex-double-float)))
    `(let* ((,thing ,x))
      (case (ccl::typecode ,thing)
        (,complex-single-float-tag (ccl::%complex-single-float-realpart ,thing))
        (,complex-double-float-tag (ccl::%complex-double-float-realpart ,thing))
        (t (ccl::%svref ,thing 0))))))


(defmacro %imagpart (x)
  (let* ((thing (gensym))
         (complex-single-float-tag (nx-lookup-target-uvector-subtag :complex-single-float))
         (complex-double-float-tag (nx-lookup-target-uvector-subtag :complex-double-float)))
    `(let* ((,thing ,x))
      (case (ccl::typecode ,thing)
        (,complex-single-float-tag (ccl::%complex-single-float-imagpart ,thing))
        (,complex-double-float-tag (ccl::%complex-double-float-imagpart ,thing))
        (t (ccl::%svref ,thing 1))))))

(defmacro with-stack-double-floats (specs &body body)
  (collect ((binds)
            (inits)
            (names))
    (dolist (spec specs)
      (let ((name (first spec)))
        (binds `(,name (%make-dfloat)))
        (names name)
        (let ((init (second spec)))
          (when init
            (inits `(%double-float ,init ,name))))))
    `(let* ,(binds)
      (declare (dynamic-extent ,@(names))
               (double-float ,@(names)))
      ,@(inits)
      ,@body)))






 ;;; WITH-BIGNUM-BUFFERS  --  Internal.
  ;;;
  ;;; Could do freelisting someday. NAH
  ;;;
(defmacro with-bignum-buffers (specs &body body)  ; <<
  "WITH-BIGNUM-BUFFERS ({(var size [init])}*) Form*"
  (collect ((binds)
	    (inits)
	    (names))
    (dolist (spec specs)
      (let ((name (first spec))
            (size (second spec)))
        (binds `(,name (allocate-typed-vector :bignum ,size)))
        (names name)          
        (let ((init (third spec)))
          (when init
            (inits `(bignum-replace ,name ,init))))))
    `(let* ,(binds)
       (declare (dynamic-extent ,@(names)))
       ,@(inits)
       ,@body)))

;;; call fn on possibly stack allocated negative of a and/or b
;;; args better be vars - we dont bother with once-only
(defmacro with-negated-bignum-buffers (a b fn)
  `(let* ((len-a (%bignum-length ,a))
          (len-b (%bignum-length ,b))
          (a-plusp (bignum-plusp ,a))
          (b-plusp (bignum-plusp ,b)))
     (declare (type bignum-index len-a len-b))
     (if (and a-plusp b-plusp)
       (,fn ,a ,b )
       (if (not a-plusp)
         (with-bignum-buffers ((a1 (1+ len-a)))
           (negate-bignum ,a nil a1)
           (if b-plusp
             (,fn a1 ,b)
             (with-bignum-buffers ((b1 (1+ len-b)))
               (negate-bignum ,b nil b1)
               (,fn a1 b1))))
         (with-bignum-buffers ((b1 (1+ len-b)))
           (negate-bignum ,b nil b1)
           (,fn ,a b1))))))

(defmacro with-one-negated-bignum-buffer (a fn)
  `(if (bignum-plusp ,a)
    (,fn ,a)
    (with-bignum-buffers ((a1 (1+ (%bignum-length ,a))))
      (negate-bignum ,a nil a1)
      (,fn a1))))


(defmacro fixnum-to-bignum-set (big fix)
  `(%fixnum-to-bignum-set ,big ,fix))

(defmacro with-small-bignum-buffers (specs &body body)
  (collect ((binds)
	    (inits)
	    (names))
    (dolist (spec specs)
      (let ((name (first spec)))
	(binds `(,name (allocate-typed-vector :bignum
                        ,(target-word-size-case (32 1)
                                                (64 2)))))
                        
	(names name)
	(let ((init (second spec)))
	  (when init
	    (inits `(fixnum-to-bignum-set ,name ,init))))))
    `(let* ,(binds)
      (declare (dynamic-extent ,@(names)))
      ,@(inits)
      ,@body)))

(provide "NUMBER-MACROS")

;;; end of number-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/number-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/apropos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; Apropos.lisp

(in-package "CCL")

(eval-when (:execute :compile-toplevel)
   (require :level-2)
   )

(defun apropos-list (string &optional package &aux list)
  "Like APROPOS, except that it returns a list of the symbols found instead
  of describing them."
  (setq string (string-arg string))
  (if package
    (do-symbols (sym package)
      (when (%apropos-substring-p string (symbol-name sym))
        (push sym list)))
    (do-all-symbols (sym)
      (when (%apropos-substring-p string (symbol-name sym))
        (push sym list))))
  (let* ((last 0)                      ; not a symbol
         (junk #'(lambda (item)
                   (declare (debugging-function-name nil))
                   (or (eq item last) (progn (setq last item) nil)))))
    (declare (dynamic-extent junk))
    (setq list (delete-if junk (sort list #'string-lessp))))
  list)

(defvar *apropos-indent-to-search-string* nil)
(defun apropos-list-aux (theString package indent-to-search-string &aux theList)
    (setq theString (string-arg theString))
    (if package
      (do-symbols (sym package)
        (when (%apropos-substring-p theString (symbol-name sym))
          (pushnew sym theList)))
      (do-all-symbols (sym)
        (when (%apropos-substring-p theString (symbol-name sym))
          (pushnew sym theList))))
    (let* ((last 0)                      ; not a symbol
           (junk #'(lambda (item)
                     (declare (debugging-function-name nil))
                     (or (eq item last) (progn (setq last item) nil)))))
      (declare (dynamic-extent junk))
      (sort-symbol-list (delete-if junk theList) (if indent-to-search-string
                                                   theString
                                                   nil))))
  
(defun apropos-string-indented (symTuple indent)
    (let ((pr-string     (prin1-to-string (aref symTuple 0)))
          (displayOffset (aref symTuple 3)))
      (format nil "~v@a~a"
              indent
              (subseq pr-string 0 displayOffset)
              (subseq pr-string displayOffset))))
  

(defun apropos-aux (theString symtuple indent)
  (declare (ignore theString))
  (let ((sym (aref symtuple 0))
        val)
    (format t "~a" (apropos-string-indented symtuple indent))
    (when (setq val (fboundp sym))
      (cond ((functionp val)
             (princ ", Def: ")
             (prin1 (type-of val)))
            ((setq val (macro-function sym))
             (princ ", Def: MACRO ")
             (prin1 (type-of val)))
            (t (princ ", Special form"))))
    (when (boundp sym)
      (princ ",  Value: ")
      (prin1 (symbol-value sym)))
    (when (find-class sym nil)
      (princ ", Class: ")
      (prin1 (find-class sym)))
    (terpri)))

  
(defun apropos (theString &optional package)
    (multiple-value-bind (symVector indent) (apropos-list-aux theString package *apropos-indent-to-search-string*)
      (loop for symtuple across symVector
        do (apropos-aux theString symtuple indent))
      (values)))
  
#|
(defun apropos (string &optional package)
  "Briefly describe all symbols which contain the specified STRING.
  If PACKAGE is supplied then only describe symbols present in
  that package. If EXTERNAL-ONLY then only describe
  external symbols in the specified package."
  (setq string (string-arg string))
  (if package
    (do-symbols (sym package) (apropos-aux string sym))
    (do-all-symbols (sym) (apropos-aux string sym)))
  (values))

(defun apropos-aux (string sym &aux val)
  (when (%apropos-substring-p string (symbol-name sym))
    (prin1 sym)
    (when (setq val (fboundp sym))
      (cond ((functionp val)
             (princ ", Def: ")
             (prin1 (type-of val)))
            ((setq val (macro-function sym))
             (princ ", Def: MACRO ")
             (prin1 (type-of val)))
            (t (princ ", Special form"))))
    (when (boundp sym)
       (princ ",  Value: ")
       (prin1 (symbol-value sym)))
    (terpri)))
|#

; (%apropos-substring-p a b)
; Returns true iff a is a substring (case-sensitive) of b.
; Internal subroutine of apropos, does no type-checking.  Assumes strings no
; longer than 64K...




(defun %apropos-substring-p (a b)
  (let ((charA0 (%schar a 0))
        (alen (length a))
        (blen (length b)))
    (declare (fixnum alen blen) (optimize (speed 3)(safety 0)))
    (if (= alen 0)  ; "" is substring of every string
        t
        (if *apropos-case-sensitive-p*
            (dotimes (i (the fixnum (%imin blen (%i+ 1 (%i- blen alen)))))
              (declare (fixnum i))
              (when (eq (%schar b i) chara0)
                (when
                    (do ((j 1 (1+ j)))
                        ((>= j alen) t)
                      (declare (fixnum j))
                      (when (neq (%schar a j)(%schar b (%i+ j i)))
                        (return nil)))
                  (return  (%i- blen i alen)))))
            (dotimes (i (the fixnum (%imin blen (%i+ 1 (%i- blen alen)))))
              (declare (fixnum i))
              (when (eq (char-upcase (%schar b i)) (char-upcase chara0))
                (when
                    (do ((j 1 (1+ j)))
                        ((>= j alen) t)
                      (declare (fixnum j))
                      (unless (eq (char-upcase (%schar a j)) (char-upcase (%schar b (%i+ j i))))
                        (return nil)))
                  (return  (%i- blen i alen)))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; from Dave Yost
(defun find-sym-alpha-part (sym)
  (let* ((str (prin1-to-string sym))
         (sortOffset (let ((sym-start (if (find #\: str)
                                      (loop for ind from (1- (length str)) downto 0
                                            when (eql #\: (char str ind))
                                            return (1+ ind))
                                      0)))
                     (+ sym-start (find-alpha-char (subseq str sym-start))))))
    (values str sortOffset sortOffset)))

(defun find-str-in-sym (str sym)
  (let* ((symStr (string-arg (prin1-to-string sym)))
         (sortOffset (let ((sym-start (if (find #\: str)
                                      (loop for ind from (1- (length str)) downto 0
                                            when (eql #\: (char str ind))
                                            return (1+ ind))
                                      0)))
                     (+ sym-start (find-alpha-char (subseq str sym-start)))))
         (displayOffset (let ((sym-start (if (find #\: symStr)
                                       (or (loop for ind from (1- (length symStr)) downto 0
                                             when (eql #\| (schar symStr ind))
                                             do (setf ind (loop for ind2 from (1- ind) downto 0
                                                                when (eql #\| (schar symStr ind2))
                                                                return ind2))
                                             when (eql #\: (char symStr ind))
                                             return (1+ ind))
                                           0)
                                       0)))
                      (+ sym-start (search (string-upcase str) (string-upcase (subseq symStr sym-start)))))))
    (values symStr sortOffset displayOffset)))

(defun find-alpha-char (str)
  "returns the character position of the first
alphabetic character in str, or the length of str
if it contains no alphabetic characters."
  (setq str (string-arg str))
  (dotimes (ind (length str)  ind)
    (when (alpha-char-p (schar str ind))
       (return ind))))

(defun sort-symbol-list (theList search-string)
  ;;; First precompute the stylized string form of the symbols as they will be compared
  ;;; and calculate the maximum indent
  (multiple-value-bind (tmpVector indentation)
      (let (sortOffset
            displayOffset
            str)
        (loop for x in thelist do
              (multiple-value-setq (str sortOffset displayOffset)
                (if search-string
                  (find-str-in-sym search-string x)
                  (find-sym-alpha-part           x)))
                           
                           
              maximize displayOffset into indentation1
              collect `#(,x ,(string-arg (subseq str sortOffset)) ,sortOffset ,displayOffset) into tmpList1
              finally  (return (values `#(,@tmpList1) indentation1))))
    (setq TMPVECTor (sort tmpVector #'(lambda (symPair1 symPair2)
                                         (string-lessp (aref symPair1 1) (aref symPair2 1)))))
    (values tmpVector ; each element is a vector of `#(,sym sortable-string-for-sym)
            indentation)))


#|
(defun %apropos-substring-p (a b &aux (alen (length a))
                                     (xlen (%i- (length b) alen)))
  (if (%iminusp xlen) nil
    (if (eq alen 0) alen
      (let ((a0 (schar a 0)) (i 0) j)
        (tagbody loop
          (when (eq (schar b i) a0)
            (setq j 1)
            (tagbody subloop
              (when (eq j alen) (return-from %apropos-substring-p i))
              (when (eq (schar b (%i+ i j)) (schar a j))
                 (setq j (%i+ j 1))
                 (go subloop))))
          (unless (eq i xlen)
            (setq i (%i+ i 1))
            (go loop)))
        nil))))
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/apropos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/defstruct-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; This file is needed to compile DEFSTRUCT and anything accessing defstruct
; data structures.

(in-package "CCL")

(eval-when (:execute :compile-toplevel)
  (require "LISPEQU"))

(defconstant $struct-r/o 24)             ; Read-only bit in refinfo fixnum
(defconstant $struct-inherited 25)		; Struct slot is  inherited.


(defconstant $defstruct-nth 0)   ; Anything that won't conflict with array types...
(defconstant $defstruct-struct 8)
(defconstant $defstruct-simple-vector 16)


(defmacro ssd-name (ssd) `(car ,ssd))
;(defmacro ssd-type (ssd) (declare (ignore ssd)) t)
(defmacro ssd-initform (ssd) `(cadr ,ssd))
;(defmacro ssd-refinfo (ssd) `(cddr ,ssd))

(defmacro ssd-update-refinfo ((ssd refinfo-var) new-refinfo-form)
  (check-type refinfo-var symbol)
  (let ((refinfo-cons (gensym)))
    `(let* ((,refinfo-cons (cdr ,ssd))
            (,refinfo-var (cdr ,refinfo-cons)))
       (when (consp ,refinfo-var)
         (setq ,refinfo-cons ,refinfo-var)
         (setq ,refinfo-var (%cdr ,refinfo-cons)))
       (%rplacd ,refinfo-cons ,new-refinfo-form))))

(defmacro refinfo-offset (refinfo) `(%ilogand2 #xFFFF ,refinfo))
(defmacro refinfo-r/o (refinfo) `(%ilogbitp $struct-r/o ,refinfo))
(defmacro refinfo-reftype (refinfo) `(%ilogand2 #xFF (%ilsr 16 ,refinfo)))
(defmacro refinfo-inherited (refinfo) `(%ilogbitp $struct-inherited ,refinfo))

(defmacro ssd-offset (ssd) `(refinfo-offset (ssd-refinfo ,ssd)))
(defmacro ssd-r/o (ssd) `(refinfo-r/o (ssd-refinfo ,ssd)))
(defmacro ssd-reftype (ssd) `(refinfo-reftype (ssd-refinfo ,ssd)))
(defmacro ssd-inherited (ssd) `(refinfo-inherited (ssd-refinfo ,ssd)))

(defmacro ssd-set-initform (ssd value) `(rplaca (cdr ,ssd) ,value))

#| these are fns now
(defmacro ssd-set-reftype (ssd reftype)      ;-> ssd multiply evaluated
  `(rplacd (cdr ,ssd) (%ilogior2 (%ilogand2 #x100FFFF (cdr (%cdr ,ssd)))
                                 (%ilsl 16 ,reftype))))

(defmacro ssd-set-r/o (ssd)                  ;-> ssd multiply evaluated
  `(rplacd (cdr ,ssd) (%ilogior2 #x1000000 (cdr (%cdr ,ssd)))))

(defmacro copy-ssd (ssd)                     ;-> ssd multiply evaluated
  `(list* (car ,ssd) (car (%cdr ,ssd)) (%cddr ,ssd)))
|#

(defmacro named-ssd (name slot-list) `(assq ,name ,slot-list))

(defmacro sd-name (sd) `(car (svref ,sd 2)))
(defmacro sd-type (sd) `(svref ,sd 0))
(defmacro sd-slots (sd) `(svref ,sd 1))
(defmacro sd-superclasses (sd) `(svref ,sd 2))
(defmacro sd-size (sd) `(svref ,sd 3))
(defmacro sd-constructor (sd) `(svref ,sd 4))
(defmacro sd-print-function (sd) `(svref ,sd 5))
(defmacro sd-set-print-function (sd value) `(svset ,sd 5 ,value))
(defmacro sd-refnames (sd) `(svref ,sd 6))

(defmacro struct-name (struct) `(class-cell-name (car (uvref ,struct 0))))
(defmacro struct-def (struct) `(gethash (struct-name ,struct) %defstructs%))

;Can use this to let the printer print with print-function, reader read with
;constructor and slot-names, inspector inspect with slot-names.
;Everything else you have to arrange yourself.
#+ignore
(defmacro pretend-i-am-a-structure (name constructor print-function &rest slot-names)
  (let ((slots slot-names) (offset 1) (supers (list name)))
    (while slots
      (%rplaca slots (make-ssd (%car slots) () offset t))
      (ssd-set-reftype (%car slots) $v_struct)
      (setq slots (%cdr slots) offset (1+ offset)))
    (push (make-ssd 0 `',supers 0 t) slot-names)
    (ssd-set-reftype (%car slot-names) $v_struct)
    `(puthash ',name %defstructs%
          '#(internal-structure  ;Make structure-class-p false.
             ,slot-names
             ,supers
             ,offset
             ,constructor
             ,print-function
             nil))))

(provide 'defstruct-macros)

; End of defstruct-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/defstruct-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/method-combination.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1990-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.


;;;;;;;;;;;;;;;
;;
;; define-method-combination.lisp
;; Copyright 1990-1994, Apple Computer, Inc.
;; Copyright 1995-1996 Digitool, Inc.

;;

;;;;;;;;;;;;;;;
;
; Change History
;
; 05/31/96 bill list method combination is not :identity-with-one-argument
; ------------- MCL-PPC 3.9
; 12/01/93 bill specifier-match-p uses EQUAL instead of EQ
; ------------- 3.0d13
; 04/30/93 bill no-applicable-primary-method -> make-no-applicable-method-function
; ------------  2.0
; 11/05/91 gb   experiment with INLINE.
; 09/26/91 bill %badarg had the wrong number of args in with-call-method-context.
;               Mix in Flavors Technology's optimization.
; 07/21/91 gb   Use DYNAMIC-EXTENT vice DOWNWARD-FUNCTION.
; 06/26/91 bill method-combination's direct-superclass is metaobject
;-------------- 2.0b2
; 02/13/91 bill New File.
;------------ 2.0b1
;

; MOP functions pertaining to method-combination:
;
; COMPUTE-DISCRIMINATING-FUNCTION generic-function (not implemented)
; COMPUTE-EFFECTIVE-METHOD generic-function method-combination methods
; FIND-METHOD-COMBINATION generic-function method-combination-type method-combination-options
; Readers for method-combination objects
; METHOD-COMBINATION-NAME
; METHOD-COMBINATION-OPTIONS
; METHOD-COMBINATION-ORDER
; METHOD-COMBINATION-OPERATOR
; METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT

(in-package "CCL")

(defclass method-combination (metaobject)
  ((name :reader method-combination-name :initarg :name)
   (options :reader method-combination-options :initarg :options :initform nil)))

(defclass short-method-combination (method-combination) 
  ((operator :reader method-combination-operator :initarg :operator :initform nil)
   (identity-with-one-argument :reader method-combination-identity-with-one-argument
                               :initarg :identity-with-one-argument
                               :initform nil))
  (:documentation "Generated by the simple form of define-method-combination"))

(defclass long-method-combination (method-combination)
  ((expander :reader method-combination-expander :initarg :expander
             :documentation "The expander is called by compute-effective-method with args: gf mc options methods args")
   )
  (:documentation "Generated by the long form of define-method-combination"))

(defmethod print-object ((object method-combination) stream)
  (print-unreadable-object (object stream :type t)
    (let* ((name (method-combination-name object))
           (options (method-combination-options object)))
      (declare (dynamic-extent options))
      (prin1 name stream)
      (dolist (option options)
        (pp-space stream)
        (prin1 option stream)))))

; Hash a method-combination name to a method-combination-info vector
(defvar *method-combination-info* (make-hash-table :test 'eq))

(defmacro method-combination-info (method-combination-type)
  `(gethash ,method-combination-type *method-combination-info*))

;;; Need to special case (find-method-combination #'find-method-combination ...)
(without-duplicate-definition-warnings ;; override version in l1-clos-boot.lisp
 (defmethod find-method-combination ((generic-function standard-generic-function)
                                     method-combination-type
                                     method-combination-options)
   (%find-method-combination
    generic-function method-combination-type method-combination-options)))

(defun %find-method-combination (gf type options)
  (declare (ignore gf))
  (if (eq type 'standard)
    (progn
      (unless (null options)
        (error "STANDARD method-combination accepts no options."))
      *standard-method-combination*)
    (let ((mci (method-combination-info type)))
      (unless mci
        (error "~s is not a method-combination type" type))
      (labels ((same-options-p (o1 o2)
                 (cond ((null o1) (null o2))
                       ((null o2) nil)
                       ((or (atom o1) (atom o2)) nil)
                       ((eq (car o1) (car o2)) 
                        (same-options-p (cdr o1) (cdr o2)))
                       (t nil))))
        (dolist (mc (population-data (mci.instances mci)))
          (when (same-options-p options (method-combination-options mc))
            (return-from %find-method-combination mc))))
      (let ((new-mc 
             (case (mci.class mci)
               (short-method-combination
                (unless (or (null options)
                            (and (listp options)
                                 (null (cdr options))
                                 (memq (car options)
                                       '(:most-specific-first :most-specific-last))))
                  (error "Illegal method-combination options: ~s" options))
                (destructuring-bind (&key identity-with-one-argument
                                          (operator type)
                                          &allow-other-keys)
                                    (mci.options mci)
                  (make-instance 'short-method-combination
                                 :name type
                                 :identity-with-one-argument identity-with-one-argument
                                 :operator operator
                                 :options options)))
               (long-method-combination
                (make-instance 'long-method-combination
                               :name type
                               :options options
                               :expander (mci.options mci)))
               (t (error "Don't understand ~s method-combination" type)))))
        (push new-mc (population-data (mci.instances mci)))
        new-mc))))
    
; Push GF on the MCI.GFS population of its method-combination type.
(defun register-gf-method-combination (gf &optional (mc (%gf-method-combination gf)))
  (unless (eq mc *standard-method-combination*)
    (let* ((name (method-combination-name mc))
           (mci (or (method-combination-info name)
                    (error "~s not a known method-combination type" name)))
           (gfs (mci.gfs mci)))
      (pushnew gf (population-data gfs)))
    mc))

(defun unregister-gf-method-combination (gf &optional (mc (%gf-method-combination gf)))
  (unless (eq mc *standard-method-combination*)
    (let* ((name (method-combination-name mc))
           (mci (or (method-combination-info name)
                    (error "~s not a known method-combination type" name)))
           (gfs (mci.gfs mci)))
      (setf (population-data gfs) (delq gf (population-data gfs))))
    mc))


;;; Need to special case (compute-effective-method #'compute-effective-method ...)
(defmethod compute-effective-method ((generic-function standard-generic-function)
                                     (method-combination standard-method-combination)
                                     methods)
  (%compute-standard-effective-method generic-function method-combination methods))

(defun %compute-standard-effective-method (generic-function method-combination methods)
  (declare (ignore method-combination))
  (make-standard-combined-method methods nil generic-function t))

(defvar *method-combination-evaluators* (make-hash-table :test 'eq))

(defmacro get-method-combination-evaluator (key)
  `(gethash ,key *method-combination-evaluators*))

(defmacro define-method-combination-evaluator (name arglist &body body)
  (setq name (require-type name 'symbol))
  (unless (and arglist (listp arglist) (eq (length arglist) 2))
    (error "A method-combination-evaluator must take two args."))
  `(%define-method-combination-evaluator ',name #'(lambda ,arglist ,@body)))

(defun %define-method-combination-evaluator (operator function)
  (setq operator (require-type operator 'symbol))
  (setq function (require-type function 'function))
  (record-source-file operator 'method-combination-evaluator)
  (setf (get-method-combination-evaluator operator) function)
  (maphash #'(lambda (name mci)
               (when (eq operator (or (and (eq (mci.class mci) 'short-method-combination) (getf (mci.options mci) :operator)) name)))
                 (clear-method-combination-caches name mci))
           *method-combination-info*)
  function)

(defmethod compute-effective-method ((generic-function standard-generic-function)
                                     (method-combination short-method-combination)
                                     methods)
  (or (get-combined-method methods generic-function)
      (put-combined-method
       methods
       (let* ((arounds nil)
              (primaries nil)
              (iwoa (method-combination-identity-with-one-argument method-combination))
              (reverse-p (eq (car (method-combination-options method-combination))
                             :most-specific-last))
              (operator (method-combination-operator method-combination))
              (name (method-combination-name method-combination))
              qualifiers
              q)
         (dolist (m methods)
           (setq qualifiers (method-qualifiers m))
           (unless (and qualifiers (null (cdr qualifiers))
                        (cond ((eq (setq q (car qualifiers)) name)
                               (push m primaries))
                              ((eq q :around)
                               (push m arounds))
                              (t nil)))
             (%invalid-method-error m "invalid method qualifiers: ~s" qualifiers)))
         (when (null primaries)
           (return-from compute-effective-method
             (make-no-applicable-method-function generic-function)))
         (setq arounds (nreverse arounds))
         (unless reverse-p (setq primaries (nreverse primaries)))
         (or (optimized-short-effective-method generic-function operator iwoa arounds primaries)
             (let ((code (if (and iwoa (null (cdr primaries)))
                           `(call-method ,(car primaries) nil)
                           `(,operator ,@(mapcar #'(lambda (m) `(call-method ,m nil)) primaries)))))
               (make-effective-method
                generic-function
                (if arounds
                  `(call-method ,(car arounds)
                                (,@(cdr arounds) (make-method ,code)))
                  code)))))
       generic-function)))

(defun optimized-short-effective-method (gf operator iwoa arounds primaries)
  (let* ((functionp (functionp (fboundp operator)))
         (evaluator (unless functionp (get-method-combination-evaluator operator))))
    (when (or functionp evaluator)
      (let ((code (if (and iwoa (null (cdr primaries)))
                    (let ((method (car primaries)))
                      (if (call-next-method-p method)
                        #'(lambda (&rest args)
                            (declare (dynamic-extent args))
                            (%%call-method* method nil args))
                        (method-function method)))
                    (if functionp
                      (let ((length (length primaries))
                            (primaries primaries))
                        #'(lambda (&rest args)
                            (declare (dynamic-extent args))
                            (let* ((results (make-list length))
                                   (results-tail results))
                              (declare (cons results-tail))
                              (declare (dynamic-extent results))
                              (dolist (method primaries)
                                (setf (car results-tail)
                                      (%%call-method* method nil args))
                                (pop results-tail))
                              (apply operator results))))
                      (let ((primaries primaries))
                        #'(lambda (&rest args)
                            (declare (dynamic-extent args))
                            (funcall evaluator primaries args)))))))
        (if arounds
          (let* ((code-method (make-instance 'standard-method
                                             :function code
                                             :generic-function gf
                                             :name (function-name gf)))
                 (first-around (car arounds))
                 (rest-arounds (nconc (cdr arounds) (list code-method))))
            #'(lambda (&rest args)
                (declare (dynamic-extent args))
                (%%call-method* first-around rest-arounds args)))
          code)))))

(defmethod compute-effective-method ((generic-function standard-generic-function)
                                     (method-combination long-method-combination)
                                     methods)
  (or (get-combined-method methods generic-function)
      (destructuring-bind ((args-var . gf-name) . expander) 
                          (method-combination-expander method-combination)
        (let* ((user-form (funcall expander
                                   generic-function
                                   methods
                                   (method-combination-options method-combination)))
               (effective-method
                (if (functionp user-form)
                  user-form 
                  (make-effective-method generic-function user-form args-var gf-name))))
          (put-combined-method methods effective-method generic-function)))))

(defmacro with-call-method-context (args-var &body body)
  (labels ((bad-call-method-method (method)
             (error "~s is neither a method nor a ~s form." method 'make-method))
           (call-method-aux (method next-methods args-var)
             (unless (typep method 'standard-method)
               (if (and (listp method) (eq (car method) 'make-method))
                 (setq method (%make-method method))
                 (bad-call-method-method method)))
             (let ((real-next-methods nil))
               (dolist (m next-methods)
                 (cond ((typep m 'standard-method)
                        (push m real-next-methods))
                       ((and (listp m) (eq (car m) 'make-method))
                        (push (%make-method m) real-next-methods))
                       (t (bad-call-method-method m))))
               `(%%call-method* ,method
                                ',(nreverse real-next-methods)
                                ,args-var))))
    `(macrolet ((call-method (method &optional next-methods)
                  (funcall ',#'call-method-aux method next-methods ',args-var)))
       ,@body)))

(defun %make-method (make-method-form &optional
                                      args-var
                                      generic-function
                                      (method-class 'standard-method))
  (setq args-var (require-type args-var 'symbol))
  (unless (and (cdr make-method-form) (null (cddr make-method-form)))
    (%method-combination-error "MAKE-METHOD requires exactly one argument."))
  (let ((form (cadr make-method-form)))
    (make-instance 
     method-class
     :generic-function generic-function
     :name (and (functionp generic-function) (function-name generic-function))
     :function (%make-function
                nil
                `(lambda (&rest ,(setq args-var (or args-var (make-symbol "ARGS"))))
                   (declare (ignore-if-unused ,args-var)
                            (dynamic-extent ,args-var))
                   (with-call-method-context ,args-var
                     ,form))
                nil))))

(defmethod call-next-method-p ((method standard-method))
  (call-next-method-p (%method-function method)))

(defmethod call-next-method-p ((function function))
  (let (lfbits)
    (and (logbitp $lfbits-method-bit
                  (setq lfbits (lfun-bits function)))
         (logbitp $lfbits-nextmeth-bit lfbits))))

(defun make-effective-method (gf form  &optional (args-sym (make-symbol "ARGS")) (gf-name (make-symbol "GF")))
  (setq args-sym (require-type args-sym 'symbol))
  (let (m mf)
    (if (and (listp form)
             (eq (car form) 'call-method)
             (listp (cdr form))
             (typep (setq m (cadr form)) 'standard-method)
             (listp (cddr form))
             (null (cdddr form))
             (not (call-next-method-p (setq mf (%method-function m)))))
      mf
      (%make-function
       nil
       `(lambda (&rest ,args-sym)
         (declare (dynamic-extent ,args-sym))
         (let* ((,gf-name ,gf))
           (declare (ignorable ,gf-name))
           (with-call-method-context ,args-sym
             ,form)))
       nil))))

;;;;;;;
;;
;; Expansions of the DEFINE-METHOD-COMBINATION macro
;;

;;
;; Short form
;;
(defun short-form-define-method-combination (name options)
  (destructuring-bind (&key documentation identity-with-one-argument
                            (operator name)) options
    (setq name (require-type name 'symbol)
          operator (require-type operator 'symbol)
          documentation (unless (null documentation)
                          (require-type documentation 'string)))
    (let* ((mci (method-combination-info name))
           (was-short? (and mci (eq (mci.class mci) 'short-method-combination))))
      (when (and mci (not was-short?))
        (check-long-to-short-method-combination name mci))
      (if mci
        (let ((old-options (mci.options mci)))
          (setf (mci.class mci) 'short-method-combination
                (mci.options mci) options)
          (unless (and was-short?
                       (destructuring-bind (&key ((:identity-with-one-argument id))
                                                 ((:operator op) name)
                                                 &allow-other-keys)
                                           old-options
                         (and (eq id identity-with-one-argument)
                              (eq op operator))))
            (update-redefined-short-method-combinations name mci)))
        (setf (method-combination-info name)
              (setq mci (%cons-mci 'short-method-combination options)))))
    (set-documentation name 'method-combination documentation))
  (record-source-file name 'method-combination)
  name)

(defun check-long-to-short-method-combination (name mci)
  (dolist (gf (population-data (mci.gfs mci)))
    (let ((options (method-combination-options (%gf-method-combination gf))))
      (unless (or (null options)
                  (and (listp options)
                       (null (cdr options))
                       (memq (car options) '(:most-specific-first :most-specific-last))))
        (error "Redefining ~s method-combination disagrees with the~
                method-combination arguments to ~s" name gf)))))

(defun update-redefined-short-method-combinations (name mci)
  (destructuring-bind (&key identity-with-one-argument (operator name)  documentation)
                      (mci.options mci)
    (declare (ignore documentation))
    (dolist (mc (population-data (mci.instances mci)))
      (when (typep mc 'long-method-combination)
        (change-class mc 'short-method-combination))
      (if (typep mc 'short-method-combination)
         (setf (slot-value mc 'identity-with-one-argument) identity-with-one-argument
               (slot-value mc 'operator) operator)
         (error "Bad method-combination-type: ~s" mc))))
  (clear-method-combination-caches name mci))

(defun clear-method-combination-caches (name mci)
  (dolist (gf (population-data (mci.gfs mci)))
    (clear-gf-cache gf))
  (when *effective-method-gfs*          ; startup glitch
    (let ((temp #'(lambda (mc gf)
                    (when (eq name (method-combination-name (%gf-method-combination gf)))
                      (remhash mc *effective-method-gfs*)
                      (remhash mc *combined-methods*)))))
      (declare (dynamic-extent temp))
      (maphash temp *effective-method-gfs*))))

;;; Support el-bizarro arglist partitioning for the long form of
;;; DEFINE-METHOD-COMBINATION.
(defun nth-required-gf-arg (gf argvals i)
  (declare (fixnum i))
  (let* ((bits (lfun-bits gf))
         (numreq (ldb $lfbits-numreq bits)))
    (declare (fixnum bits numreq))
    (if (< i numreq)
      (nth i argvals))))

(defun nth-opt-gf-arg-present-p (gf argvals i)
  (declare (fixnum i))
  (let* ((bits (lfun-bits gf))
         (numreq (ldb $lfbits-numreq bits))
         (numopt (ldb $lfbits-numopt bits)))
    (declare (fixnum bits numreq numopt))
    (and (< i numopt)
         (< (the fixnum (+ i numreq)) (length argvals)))))

;;; This assumes that we've checked for argument presence.
(defun nth-opt-gf-arg (gf argvals i)
  (declare (fixnum i))
  (let* ((bits (lfun-bits gf))
         (numreq (ldb $lfbits-numreq bits)))
    (declare (fixnum bits numreq ))
    (nth (the fixnum (+ i numreq)) argvals)))

(defun gf-arguments-tail (gf argvals)
  (let* ((bits (lfun-bits gf))
         (numreq (ldb $lfbits-numreq bits))
         (numopt (ldb $lfbits-numopt bits)))
    (declare (fixnum bits numreq numopt))
    (nthcdr (the fixnum (+ numreq numopt)) argvals)))

(defun gf-key-present-p (gf argvals key)
  (let* ((tail (gf-arguments-tail gf argvals))
         (missing (cons nil nil)))
    (declare (dynamic-extent missing))
    (not (eq missing (getf tail key missing)))))

;; Again, this should only be called if GF-KEY-PRESENT-P returns true.
(defun gf-key-value (gf argvals key)
  (let* ((tail (gf-arguments-tail gf argvals)))
    (getf tail key)))  
  

(defun lfmc-bindings (gf-form args-form lambda-list)
  (let* ((req-idx 0)
         (opt-idx 0)
         (state :required))
    (collect ((names)
              (vals))
      (dolist (arg lambda-list)
        (case arg
          ((&whole &optional &rest &key &allow-other-keys &aux)
           (setq state arg))
          (t
           (case state
             (:required
              (names arg)
              (vals (list 'quote `(nth-required-gf-arg ,gf-form ,args-form ,req-idx)))
              (incf req-idx))
             (&whole
              (names arg)
              (vals (list 'quote `,args-form))
              (setq state :required))
             (&optional
              (let* ((var arg)
                     (val nil)
                     (spvar nil))
                (when (listp arg)
                  (setq var (pop arg)
                        val (pop arg)
                        spvar (car arg)))
                (names var)
                (vals (list 'quote
                            `(if (nth-opt-gf-arg-present-p ,gf-form ,args-form ,opt-idx)
                              (nth-opt-gf-arg ,gf-form ,args-form ,opt-idx)
                              ,val)))
                (when spvar
                  (names spvar)
                  (vals (list 'quote 
                              `(nth-opt-gf-arg-present-p ,gf-form ,args-form ,opt-idx))))
                (incf opt-idx)))
             (&rest
              (names arg)
              (vals (list 'quote
                          `(gf-arguments-tail ,gf-form ,args-form))))
             (&key
              (let* ((var arg)
                     (keyword nil)
                     (val nil)
                     (spvar nil))
                (if (atom arg)
                  (setq keyword (make-symbol (symbol-name arg)))
                  (progn
                    (setq var (car arg))
                    (if (atom var)
                      (setq keyword (make-symbol (symbol-name var)))
                      (setq keyword (car var) var (cadr var)))
                    (setq val (cadr arg) spvar (caddr arg))))
                (names var)
                (vals (list 'quote `(if (gf-key-present-p ,gf-form ,args-form ',keyword)
                                     (gf-key-value ,gf-form ,args-form ',keyword)
                                     ,val)))
                (when spvar
                  (names spvar)
                  (vals (list 'quote `(gf-key-present-p ,gf-form ,args-form ',keyword))))))
             (&allow-other-keys)
             (&aux
              (cond ((atom arg)
                     (names arg)
                     (vals nil))
                    (t
                     (names (car arg))
                     (vals (list 'quote (cadr arg))))))))))
      (values (names) (vals)))))
;;
;; Long form
;;
(defun long-form-define-method-combination (name lambda-list method-group-specifiers
                                                 forms env)
  (let (arguments args-specified? generic-fn-symbol gf-symbol-specified?)
    (unless (verify-lambda-list lambda-list)
      (error "~s is not a proper lambda-list" lambda-list))
    (loop
      (unless (and forms (consp (car forms))) (return))
      (case (caar forms)
        (:arguments
         (when args-specified? (error ":ARGUMENTS specified twice"))
         (setq arguments (cdr (pop forms))
               args-specified? t)
         (do ((args arguments (cdr args)))
             ((null args))
           (setf (car args) (require-type (car args) 'symbol))))
        (:generic-function
         (when gf-symbol-specified? (error ":GENERIC-FUNCTION specified twice"))
         (setq generic-fn-symbol
               (require-type (cadr (pop forms)) '(and symbol (not null)))
               gf-symbol-specified? t))
        (t (return))))
    (multiple-value-bind (body decls doc) (parse-body forms env)
      (unless generic-fn-symbol (setq generic-fn-symbol (make-symbol "GF")))
      (multiple-value-bind (specs order-forms required-flags descriptions)
                           (parse-method-group-specifiers method-group-specifiers)
        (let* ((methods-sym (make-symbol "METHODS"))
               (args-sym (make-symbol "ARGS"))
               (options-sym (make-symbol "OPTIONS"))
               (arg-vars ())
               (arg-vals ())
               (code `(lambda (,generic-fn-symbol ,methods-sym ,options-sym)
                        ,@(unless gf-symbol-specified?
                            `((declare (ignore-if-unused ,generic-fn-symbol))))
                        (let* (,@(progn
                                  (multiple-value-setq (arg-vars arg-vals)
                                    (lfmc-bindings generic-fn-symbol
                                                   args-sym
                                                   arguments))
                                  (mapcar #'list arg-vars arg-vals)))
                          (declare (ignorable ,@arg-vars))
                          ,@decls
                          (destructuring-bind ,lambda-list ,options-sym
                            (destructuring-bind
                              ,(mapcar #'car method-group-specifiers)
                              (seperate-method-groups
                               ,methods-sym ',specs
                               (list ,@order-forms)
                               ',required-flags
                               ',descriptions)
                              ,@body))))))
          `(%long-form-define-method-combination
            ',name (cons (cons ',args-sym ',generic-fn-symbol) #',code) ',doc))))))

(defun %long-form-define-method-combination (name args-var.expander documentation)
  (setq name (require-type name 'symbol))
  (let* ((mci (method-combination-info name)))
    (if mci
      (progn
        (setf (mci.class mci) 'long-method-combination
              (mci.options mci) args-var.expander)
        (update-redefined-long-method-combinations name mci))
      (setf (method-combination-info name)
            (setq mci (%cons-mci 'long-method-combination args-var.expander)))))
  (set-documentation name 'method-combination documentation)
  (record-source-file name 'method-combination)
  name)

(defun update-redefined-long-method-combinations (name mci)
  (let ((args-var.expander (mci.options mci)))
    (dolist (mc (population-data (mci.instances mci)))
      (when (typep mc 'short-method-combination)
        (change-class mc 'long-method-combination))
      (if (typep mc 'long-method-combination)
        (setf (slot-value mc 'expander) args-var.expander)
        (error "Bad method-combination-type: ~s" mc))))
  (clear-method-combination-caches name mci))

; Returns four values:
; method-group specifiers with :order, :required, & :description parsed out
; Values for the :order args
; Values for the :required args
; values for the :description args
(defun parse-method-group-specifiers (mgs)
  (let (specs orders requireds descriptions)
    (dolist (mg mgs)
      (push nil specs)
      (push :most-specific-first orders)
      (push nil requireds)
      (push nil descriptions)
      (push (pop mg) (car specs))       ; name
      (loop
        (when (null mg) (return))
        (when (memq (car mg) '(:order :required :description))
          (destructuring-bind (&key (order :most-specific-first) required description)
                              mg
            (setf (car orders) order)
            (setf (car requireds) required)
            (setf (car descriptions) description))
          (return))
        (push (pop mg) (car specs)))
      (setf (car specs) (nreverse (car specs))))
    (values (nreverse specs)
            (nreverse orders)
            (nreverse requireds)
            (nreverse descriptions))))

(defun seperate-method-groups (methods specs orders requireds descriptions)
  (declare (ignore descriptions))
  (let ((res (make-list (length specs))))
    (dolist (m methods)
      (let ((res-tail res))
        (dolist (s specs (%invalid-method-error
                          m "Does not match any of the method group specifiers"))
          (when (specifier-match-p (method-qualifiers m) s)
            (push m (car res-tail))
            (return))
          (pop res-tail))))
    (do ((res-tail res (cdr res-tail))
         (o-tail orders (cdr o-tail))
         (r-tail requireds (cdr r-tail)))
        ((null res-tail))
      (case (car o-tail)
        (:most-specific-last)
        (:most-specific-first (setf (car res-tail) (nreverse (car res-tail))))
        (t (error "~s is neither ~s nor ~s" (car o-tail) :most-specific-first :most-specific-last)))
      (when (car r-tail)
        (unless (car res-tail)
          ; should use DESCRIPTIONS here
          (error "A required method-group matched no method group specifiers"))))
    res))

(defun specifier-match-p (qualifiers spec)
  (flet ((match (qs s)
           (cond ((or (listp s) (eq s '*))
                  (do ((qs-tail qs (cdr qs-tail))
                       (s-tail s (cdr s-tail)))
                      ((or (null qs-tail) (atom s-tail))
                       (or (eq s-tail '*)
                           (and (null qs-tail) (null s-tail))))
                    (unless (or (eq (car s-tail) '*)
                                (equal (car qs-tail) (car s-tail)))
                      (return nil))))
                 ((atom s) (funcall s qs))
                 (t (error "Malformed method group specifier: ~s" spec)))))
    (declare (inline match))
    (dolist (s (cdr spec))
      (when (match qualifiers s)
        (return t)))))

;;;;;;;
;
; The user visible error functions
; We don't add any contextual information yet.
; Maybe we never will.
(setf (fdefinition 'method-combination-error) #'%method-combination-error)
(setf (fdefinition 'invalid-method-error) #'%invalid-method-error)

;;;;;;;
;
; The predefined method-combination types
;
(define-method-combination + :identity-with-one-argument t)
(define-method-combination and :identity-with-one-argument t)
(define-method-combination append :identity-with-one-argument t)
(define-method-combination list :identity-with-one-argument nil)
(define-method-combination max :identity-with-one-argument t)
(define-method-combination min :identity-with-one-argument t)
(define-method-combination nconc :identity-with-one-argument t)
(define-method-combination or :identity-with-one-argument t)
(define-method-combination progn :identity-with-one-argument t)

; And evaluators for the non-functions
(define-method-combination-evaluator and (methods args)
  (when methods
    (loop
      (if (null (cdr methods))
        (return (%%call-method* (car methods) nil args)))
      (unless (%%call-method* (pop methods) nil args)
        (return nil)))))

(define-method-combination-evaluator or (methods args)
  (when methods
    (loop
      (if (null (cdr methods))
        (return (%%call-method* (car methods) nil args)))
      (let ((res (%%call-method* (pop methods) nil args)))
        (when res (return res))))))

(define-method-combination-evaluator progn (methods args)
  (when methods
    (loop
      (if (null (cdr methods))
        (return (%%call-method* (car methods) nil args)))
      (%%call-method* (pop methods) nil args))))

#|

;(define-method-combination and :identity-with-one-argument t)
(defgeneric func (x) (:method-combination and))
(defmethod func and ((x window)) (print 3))
(defmethod func and ((x fred-window)) (print 2))
(func (front-window))

(define-method-combination example ()((methods positive-integer-qualifier-p))
  `(progn ,@(mapcar #'(lambda (method)
                        `(call-method ,method ()))
                    (sort methods #'< :key #'(lambda (method)
                                               (first (method-qualifiers method)))))))

(defun positive-integer-qualifier-p (method-qualifiers)
  (and (= (length method-qualifiers) 1)
       (typep (first method-qualifiers)'(integer 0 *))))

(defgeneric zork  (x)(:method-combination example))

(defmethod zork 1 ((x window)) (print 1))
(defmethod zork 2 ((x fred-window)) (print 2))
(zork (front-window))


|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/method-combination.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/defstruct.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;; Defstruct.lisp

(eval-when (eval compile)
  (require 'defstruct-macros)

)

(defvar %structure-refs% (make-hash-table :test #'eq))
(defvar %defstructs% (make-hash-table :test #'eq))

(defun make-ssd (name initform offset r/o &optional (type t))
  (let ((refinfo (%ilogior2 offset (if r/o #x1000000 0))))
    (list* name initform
           (if (eq type 't)
             refinfo
             (cons type refinfo)))))

(declaim (inline accessor-structref-info-p))
(defun accessor-structref-info-p (object) ;; as opposed to predicate structref-info.
  (consp object))

(declaim (inline structref-info-type))
(defun structref-info-type (info)
  (when (consp info)
    (if (consp (%car info)) (%caar info) 't)))

(declaim (inline structref-info-refinfo))
(defun structref-info-refinfo (info)
  (when (consp info)
    (if (consp (%car info)) (%cdar info) (%car info))))

(defun structref-set-r/o (sym &optional env)
  (let ((info (structref-info sym env)))
    (when (accessor-structref-info-p info)
      (if (consp (%car info))
        (setf (%cdar info) (%ilogior2 (%ilsl $struct-r/o 1) (%cdar info)))
        (setf (%car info) (%ilogior2 (%ilsl $struct-r/o 1) (%car info)))))))

(declaim (inline structref-info-struct))
(defun structref-info-struct (info)
  (when (consp info)
    (%cdr info)))

(defun ssd-set-reftype (ssd reftype)
  (ssd-update-refinfo (ssd refinfo)
                      (%ilogior2 (%ilogand2 #x300FFFF refinfo)
                                 (%ilsl 16 reftype))))

(defun ssd-set-r/o (ssd) 
  (ssd-update-refinfo (ssd refinfo)
                      (%ilogior2 (%ilsl $struct-r/o 1) refinfo)))

(defun ssd-set-inherited (ssd)
  (ssd-update-refinfo (ssd refinfo)
		       (bitset $struct-inherited refinfo)))

(defun copy-ssd (ssd)
  (let* ((cdr (cdr ssd))
         (cddr (cdr cdr)))
    (list* (%car ssd) (%car cdr)
           (if (consp cddr)
             (list* (%car cddr) (%cdr cddr))
             cddr))))

(declaim (inline ssd-type-and-refinfo))
(defun ssd-type-and-refinfo (ssd)
  (cddr ssd))

(defun ssd-type (ssd)
  (let ((type-and-refinfo (ssd-type-and-refinfo ssd)))
    (if (consp type-and-refinfo)
      (%car type-and-refinfo)
      't)))

(defun ssd-refinfo (ssd)
  (let ((type-and-refinfo (ssd-type-and-refinfo ssd)))
    (if (consp type-and-refinfo) (%cdr type-and-refinfo) type-and-refinfo)))

(defun %structure-class-of (thing)
  (let* ((cell (car (uvref thing 0))))
    (or (class-cell-class cell)
        (setf (class-cell-class cell)
              (find-class (class-cell-name cell))))))

;These might want to compiler-transform into non-typechecking versions...
(defun struct-ref (struct offset)
  (if (structurep struct) (uvref struct offset)
      (report-bad-arg struct 'structure-object)))

(defun struct-set (struct offset value)
  (if (structurep struct) (uvset struct offset value)
      (report-bad-arg struct 'structure-object)))

(defsetf struct-ref struct-set)


; things for defstruct to do - at load time
(defun %defstruct-do-load-time (sd predicate &optional doc &aux (name (sd-name sd)))
  ;(declare (ignore refnames))
  (when (null (sd-type sd))
    (%define-structure-class sd))
  (when (and doc *save-doc-strings*)
    (set-documentation name 'type doc))  
  (puthash name %defstructs% sd)
  (record-source-file name 'structure)
  (when (and predicate (null (sd-type sd)))
    (puthash predicate %structure-refs% name))  
  (when *fasload-print* (format t "~&~S~%" name))
  name)

(defun %defstruct-set-print-function (sd print-function print-object-p)
  (sd-set-print-function sd (if print-object-p
			      (list print-function)
			      print-function)))

(defun sd-refname-in-included-struct-p (sd name &optional env)
  (dolist (included-type (cdr (sd-superclasses sd)))
    (let ((sub-sd (or (let ((defenv (definition-environment env)))
			(when defenv (%cdr (assq included-type
						 (defenv.structures
						     defenv)))))
		      (gethash included-type %defstructs%))))
      (when sub-sd
	(if (member name (sd-refnames sub-sd) :test 'eq)
	  (return t))))))

(defun sd-refname-pos-in-included-struct (sd name)
  (dolist (included-type (cdr (sd-superclasses sd)))
    (let ((sub-sd (gethash included-type %defstructs%)))
      (when sub-sd
        (let ((refnames (sd-refnames sub-sd)))
          (if refnames
            (let ((pos (position name refnames :test 'eq)))
              (and pos (1+ pos)))
            (dolist (slot (sd-slots sub-sd))
              (let ((ssd-name (ssd-name slot)))
                (unless (fixnump ssd-name)
                  (when (eq name ssd-name)
                    (return-from sd-refname-pos-in-included-struct
                      (ssd-offset slot))))))))))))

;;; return stuff for defstruct to compile
(defun %defstruct-compile (sd refnames env)
  (let ((stuff)
        (struct (and (not (sd-type sd)) (sd-name sd))))
    (dolist (slot (sd-slots sd))
      (unless (fixnump (ssd-name slot))
        (let* ((accessor (if refnames (pop refnames) (ssd-name slot)))
               (pos (sd-refname-pos-in-included-struct sd accessor)))
          (if pos
            (let ((offset (ssd-offset slot)))
              (unless (eql pos offset)
                ;; This should be a style-warning
                (warn "Accessor ~s at different position than in included structure"
                      accessor)))
            (unless (sd-refname-in-included-struct-p sd accessor env)
              (let ((fn (slot-accessor-fn sd slot accessor env))
                    (info (cons (ssd-type-and-refinfo slot) struct)))
                (push
                 `(progn
                    ,.fn
                    (puthash ',accessor %structure-refs% ',info)
                    (record-source-file ',accessor 'structure-accessor))
                 stuff)))))))
    (nreverse stuff)))

(defun defstruct-var (name env)
  (declare (ignore env))
  (if (symbolp name)
    (if (or (constant-symbol-p name) (proclaimed-special-p name))
      (make-symbol (symbol-name name))
      name)
    'object))

(defun slot-accessor-fn (sd slot name env)
  (let* ((ref (ssd-reftype slot))
         (offset (ssd-offset slot))
         (arg (defstruct-var (sd-name sd) env))
         (value (gensym "VALUE"))
         (type (defstruct-type-for-typecheck (ssd-type slot) env))
         (form (cond ((eq ref $defstruct-nth)
                      `(nth ,offset ,arg))
                     ((eq ref $defstruct-struct)
                      `(struct-ref (typecheck ,arg ,(sd-name sd)) ,offset))
                     ((or (eq ref target::subtag-simple-vector)
                          (eq ref $defstruct-simple-vector))
                      `(svref ,arg ,offset))
                     (t `(uvref ,arg ,offset)))))
    `((defun ,name (,arg)
        ,(cond ((eq type t) form)
	       ((nx-declarations-typecheck env)
		;; TYPE may be unknown.  For example, it may be
		;; forward-referenced.  Insert a run-time check in
		;; this case.
		`(require-type ,form ',type))
	       (t `(the ,type ,form))))
      ,@(unless (ssd-r/o slot)
          `((defun (setf ,name) (,value ,arg)
              ,(cond
		((eq type t) `(setf ,form ,value))
		((nx-declarations-typecheck env)
		 ;; Checking the type of SETF's return value seems
		 ;; kind of pointless here.
		 `(require-type (setf ,form (typecheck ,value ,type)) ',type))
		(t
		 `(the ,type (setf ,form (typecheck ,value ,type)))))))))))

(defun defstruct-reftype (type)
  (cond ((null type) $defstruct-struct)
        ((eq type 'list) $defstruct-nth)
        (t (element-type-subtype (cadr type)))))

(defun defstruct-slot-defs (sd refnames env)
  (declare (ignore env))
  (let ((ref (defstruct-reftype (sd-type sd))) name defs)
    (dolist (slot (sd-slots sd))
      (ssd-set-reftype slot ref)
      (unless (fixnump (setq name (ssd-name slot))) ;Ignore fake 'name' slots
        (when refnames (setq name (pop refnames)))
        (unless (sd-refname-pos-in-included-struct sd name)
          (push name defs))))
    (setq defs (nreverse defs))
    `((declaim (inline ,@defs)))))

(defun structref-info (sym &optional env)
  (let ((info (or (and env (environment-structref-info sym env))
                  (gethash sym %structure-refs%))))
    ;; This can be removed once $fasl-min-vers is greater than #x5e
    #-BOOTSTRAPPED
    (when (or (fixnump info)
              (and (consp info) (fixnump (%cdr info))))
      ;; Old style, without struct type info.
      (setq info (cons info 'structure-object)))
    info))

(defun defstruct-type-for-typecheck (type env)
  (if (or (eq type 't)
          (specifier-type-if-known type env)
          (nx-declarations-typecheck env))
    type
    ;; Else have an unknown type used only for an implicit declaration.
    ;; Just ignore it, it's most likely a forward reference, and while it
    ;; means we might be missing out on a possible optimization, most of
    ;; the time it's not worth warning about.
    't))

;;;Used by nx-transform, setf, and whatever...
(defun defstruct-ref-transform (structref-info args env &optional no-type-p)
  (if (accessor-structref-info-p structref-info)
    (let* ((type (if no-type-p
                   't
                   (defstruct-type-for-typecheck (structref-info-type structref-info) env)))
           (refinfo (structref-info-refinfo structref-info))
           (offset (refinfo-offset refinfo))
           (ref (refinfo-reftype refinfo))
           (accessor
            (cond ((eq ref $defstruct-nth)
                   `(nth ,offset ,@args))
                  ((eq ref $defstruct-struct)
                   `(struct-ref (structure-typecheck ,@args ,(structref-info-struct structref-info)) ,offset))
                  ((eq ref target::subtag-simple-vector)
                   `(svref ,@args ,offset))
                  (ref
                   `(aref (the (simple-array ,(element-subtype-type ref) (*))
                               ,@args) ,offset))
                  (t `(uvref ,@args ,offset)))))
      (if (eq type 't)
        accessor
	(if (nx-declarations-typecheck env)
	  `(typecheck ,accessor ,type)
	  `(the ,type ,accessor))))
    `(structure-typep ,@args ',structref-info)))

;;; Should probably remove the constructor, copier, and predicate as
;;; well. Can't remove the inline proclamations for the refnames,
;;; as the user may have explicitly said this. Questionable - but surely
;;; must delete the inline definitions.
;;; Doesn't remove the copier because we don't know for sure what it's name is
(defmethod change-class ((from structure-class)
			 (to class)
			  &rest initargs &key &allow-other-keys)
  (declare (dynamic-extent initargs))
  (let ((class-name (class-name from)))
    (unless (eq from to)                  ; shouldn't be
      (remove-structure-defs class-name)
      (remhash class-name %defstructs%)))
  (%change-class from to initargs))

;;; if redefining a structure as another structure or redefining a
;;; structure as a class
(defun remove-structure-defs (class-name)
  (let ((sd (gethash class-name %defstructs%)))
    (when sd
      (dolist (refname (sd-refnames sd))
	(unless (sd-refname-in-included-struct-p sd refname)
	  (let ((def (assq refname *nx-globally-inline*)))
	    (when def (set-function-info refname nil)))
	  (let ((info (structref-info refname)))
	    (when (accessor-structref-info-p info)
	      (unless (refinfo-r/o (structref-info-refinfo info))
		(fmakunbound (setf-function-name refname)))
	      (fmakunbound refname)))))
      #|
      ;; The print-function may indeed have become obsolete,
      ;; but we can't generally remove user-defined code
      (let ((print-fn (sd-print-function sd)))
        (when (symbolp print-fn) (fmakunbound print-fn)))
      |#
      (let ((constructor (sd-constructor sd)))
        (when (symbolp constructor) (fmakunbound constructor)))
      (let ((delete-match #'(lambda (pred struct-name)
                              (when (eq struct-name class-name)
                                (remhash pred %structure-refs%)
                                (fmakunbound pred)))))
        (declare (dynamic-extent delete-match))
        ; get rid of the predicate
        (maphash delete-match %structure-refs%)))))

(defun copy-structure (source)
  "Return a copy of STRUCTURE with the same (EQL) slot values."
  (copy-uvector (require-type source 'structure-object)))

(provide 'defstruct)

; End of defstruct.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/defstruct.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/chars.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.
;; chars.lisp

(in-package "CCL")

(defun character-designator-p (thing)
  (or (typep thing 'character)
      (typep thing '(string 1))
      (and (typep thing 'symbol) (typep (symbol-name thing) '(string 1)))))

;;; If object is a character, it is returned.  If it is a string of
;;; length 1, then the sole element of the string is returned.  If it
;;; is a symbol whose pname is of length 1, then the sole element of
;;; the pname is returned. Else error.

(defun character (arg)
  "Coerce OBJECT into a CHARACTER if possible. Legal inputs are 
  characters, strings and symbols of length 1."
  (if (typep arg 'character)
    arg
    (if (and (typep arg 'string)
             (= (the fixnum (length arg)) 1))
      (char arg 0)
      (let* ((pname (if (typep arg 'symbol) (symbol-name arg))))
        (if (and pname (= (the fixnum (length pname)) 1))
          (char pname 0)
          (report-bad-arg arg '(satisfies character-designator-p)))))))



(defun digit-char (weight &optional radix)
  "All arguments must be integers. Returns a character object that
  represents a digit of the given weight in the specified radix. Returns
  NIL if no such character exists."
  (let* ((r (if radix (require-type radix 'integer) 10)))
    (if (and (typep (require-type weight 'integer) 'fixnum)
             (>= r 2)
             (<= r 36)
             (>= weight 0)
             (< weight r))
      (locally (declare (fixnum weight))
        (if (< weight 10)
          (code-char (the fixnum (+ weight (char-code #\0))))
          (code-char (the fixnum (+ weight (- (char-code #\A) 10)))))))))


(declaim (inline %control-char-p))

(defun %control-char-p (char)
  (let* ((code (char-code char)))
    (declare (type (mod #x110000) code))
    ;; If we believe that "most" characters will have relatively
    ;; small codes, then doing a linear search on this short
    ;; list is probably faster than binary search on a vector
    ;; or other approaches.
    (dolist (pair '((0 . #x1f)                          ;c0
                    (#x7f . #x9f)                       ;#\rubout, c1
                    (#x34f . #x34f)                     ;combining grapheme joiner.
                    (#x200c . #x200f)
                    (#x202a . #x202e)
                    (#x2060 . #x2063)
                    (#x206a . #x206f)
                    #+darwin-target
                    (#xf700 . #xf7ff)
                    (#xfe00 . #xfe0f)
                    (#xfeff . #xfeff)                   ;byte-order mark (0-width space).
                    (#xfff0 . #xfffd)
                    
                    (#xe0000 . #xefffd)))
      (let* ((low (car pair))
             (high (cdr pair)))
        (declare (type (mod #x110000) low high))
        (if (> low code)
          (return nil)
          (if (<= code high)
            (return t)))))))



;;; Characters that aren't control/formatting characters are graphic.
(defun graphic-char-p (c)
  "The argument must be a character object. GRAPHIC-CHAR-P returns NIL if the
  argument is a Unicode control character, otherwise returns T."
  (not (%control-char-p c)))


;True for ascii codes 10 and 32-126 inclusive.
(defun standard-char-p (c)
  "The argument must be a character object. STANDARD-CHAR-P returns T if the
   argument is a standard character -- one of the 95 ASCII printing characters
   or <return>."
  (let* ((code (char-code c)))
    (or (eq c #\newline)
        (and 
         (>= code (char-code #\space))
         (< code (char-code #\rubout))))))







(defun upper-case-p (c)
  "The argument must be a character object; UPPER-CASE-P returns T if the
   argument is an upper-case character, NIL otherwise."
  (let* ((code (char-code c))
         (to-lower *upper-to-lower*))
    (declare (type (mod #x110000) code)
             (type (simple-array (signed-byte 16) (*)) to-lower))
    (and (< code (length to-lower))
         (not (zerop (aref to-lower code))))))




(defun both-case-p (c)
  "The argument must be a character object. BOTH-CASE-P returns T if the
  argument is an alphabetic character and if the character exists in
  both upper and lower case. For ASCII, this is the same as ALPHA-CHAR-P."
  (let* ((code (char-code c))
         (to-upper *lower-to-upper*)
         (to-lower *upper-to-lower*))
    (declare (type (mod #x110000) code)
             (type (simple-array (signed-byte 16) (*)) to-lower to-upper))
    (or (and (< code (length to-upper))
             (not (zerop (aref to-upper code))))
        (and (< code (length to-lower))
             (not (zerop (aref to-lower code)))))))
  
(defun alphanumericp (c)
  "Given a character-object argument, ALPHANUMERICP returns T if the
   argument is either numeric or alphabetic."
  (let ((code (char-code c)))
    (declare (type (mod #x110000) code))
    (or
     (and (>= code (char-code #\0))
          (<= code (char-code #\9)))
     (let* ((bits *alpha-char-bits*))
       (declare (simple-bit-vector bits))
       (and (< code (length bits))
            (not (eql 0 (sbit bits code))))))))

(defun char= (ch &rest others)
  "Return T if all of the arguments are the same character."
  (declare (dynamic-extent others))
  (unless (typep ch 'character)
    (setq ch (require-type ch 'character)))
  (dolist (other others t)
    (unless (eq other ch)
      (unless (typep other 'character)
        (setq other (require-type other 'character)))
      (return))))

(defun char/= (ch &rest others)
  "Return T if no two of the arguments are the same character."
  (declare (dynamic-extent others))
  (unless (typep ch 'character)
    (setq ch (require-type ch 'character)))
  (do* ((rest others (cdr rest)))
       ((null rest) t)
    (let ((other (car rest)))
      (if (eq other ch) (return))
      (unless (typep other 'character)
        (setq other (require-type other 'character)))
      (dolist (o2 (cdr rest))
        (if (eq o2 other)(return-from char/= nil))))))


(defun char-equal (char &rest others)
  "Return T if all of the arguments are the same character.
  Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (dolist (c others t)
      (when (not (eq c char))
        (unless (eq (char-upcase char) (char-upcase c))
          (return))))))

;;; Compares each char against all following chars, not just next one. Tries
;;; to be fast for one or two args.
(defun char-not-equal (char &rest others)
  "Return T if no two of the arguments are the same character.
   Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3) (safety 0)))
    (let* ((rest (cdr others)))
      (cond 
       (rest                   
        (setq char (char-code (char-upcase char)))
        (do ((list others (cdr list)))
            ((null list))
          (rplaca list (char-code (char-upcase (car list)))))
        (while others
          (when (memq char others)
            (return-from char-not-equal nil))
	  (setq char (car others)
		others rest
		rest (cdr others)))
        t)
       (others                     ;  2 args, no table
        (not (eq (char-upcase char) (char-upcase (car others)))))
       (t t)))))


(defun char-lessp (char &rest others)
  "Return T if the arguments are in strictly increasing alphabetic order.
   Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ((code (char-code (char-upcase char))))
      (dolist (c others t)
        (unless (< code (setq code (char-code (char-upcase c))))
          (return))))))

(defun char-not-lessp (char &rest others)
  "Return T if the arguments are in strictly non-increasing alphabetic order.
   Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ((code (char-code (char-upcase char))))
      (dolist (c others t)
        (when (< code (setq code (char-code (char-upcase c))))
          (return))))))

(defun char-greaterp (char &rest others)
  "Return T if the arguments are in strictly decreasing alphabetic order.
   Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ((code (char-code (char-upcase char))))
      (dolist (c others t)
        (unless (> code (setq code (char-code (char-upcase c))))
          (return))))))

(defun char-not-greaterp (char &rest others)
  "Return T if the arguments are in strictly non-decreasing alphabetic order.
   Font, bits, and case are ignored."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ((code (char-code (char-upcase char))))
      (dolist (c others t)
        (when (> code (setq code (char-code (char-upcase c))))
          (return))))))


(defun char> (char &rest others)
  "Return T if the arguments are in strictly decreasing alphabetic order."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ()      
      (setq char (char-code char))
      (dolist (c others t)
        (let ((code (char-code c)))
          (when (not (%i> char (setq char code)))
            (return)))))))

(defun char>= (char &rest others)
  "Return T if the arguments are in strictly non-increasing alphabetic order."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ()      
      (setq char (char-code char))
      (dolist (c others t)
        (let ((code (char-code c)))
          (when (not (%i>= char (setq char code)))
            (return)))))))


(defun char< (char &rest others)
  "Return T if the arguments are in strictly increasing alphabetic order."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ()      
      (setq char (char-code char))
      (dolist (c others t)
        (let ((code (char-code c)))
          (when (not (%i< char (setq char code)))
            (return)))))))

(defun char<= (char &rest others)
  "Return T if the arguments are in strictly non-decreasing alphabetic order."
  (declare (dynamic-extent others))
  (locally (declare (optimize (speed 3)(safety 0)))
    (let* ()      
      (setq char (char-code char))
      (dolist (c others t)
        (let ((code (char-code c)))
          (when (not (%i<= char (setq char code)))
            (return)))))))

; This is Common Lisp
(defun char-int (c)
  "Return the integer code of CHAR."
  (char-code c))


;If char has an entry in the *NAME-CHAR-ALIST*, return first such entry.
;Otherwise, if char is a graphics character, return NIL
;Otherwise, if char code is < 128, return "^C", otherwise "1nn"

(defun char-name (c)
  "Return the name (a STRING) for a CHARACTER object."
  (let* ((code (char-code c)))
    (declare (type (mod #x110000) code))
    (or (gethash c *char->name*)
        (cond ((< code #x7f)
               (when (< code (char-code #\space))
                 (let ((str (make-string 2 :element-type 'base-char)))
                   (declare (simple-base-string str))
                   (setf (schar str 0) #\^)
                   (setf (schar str 1)(code-char (logxor code #x40)))
                   str)))
              ((and (< code #x100)(graphic-char-p c)) nil)
              (t (format nil "U+~4,'0x" code))))))


(defun string-downcase (string &key (start 0) end)
  (setq string (copy-string-arg string))
  (setq end (check-sequence-bounds string start end))
  (%strdown string start end))


(defun %strdown (string start end)
  (declare (fixnum start end)
           (optimize (speed 3) (safety 0)))
  (unless (typep string 'simple-string)
    (check-type string simple-string))
  (do* ((i start (1+ i))
        (to-lower *upper-to-lower*)
        (n (length to-lower)))
       ((>= i end) string)
    (declare (fixnum i n) (type (simple-array (signed-byte 16) (*)) to-lower))
    (let* ((ch (schar string i))
           (code (char-code ch))
           (delta (if (< code n) (aref to-lower code) 0)))
      (declare (character ch)
               (type (mod #x110000) code)
               (type (signed-byte 16) delta))
      (unless (zerop delta)
        (setf (schar string i)
              (code-char (the valid-char-code (+ code delta))))))))




(defun copy-string-arg (string &aux (org 0) len)
  (etypecase string
    (string
     (setq len (length string))
     (multiple-value-setq (string org)(array-data-and-offset string)))
    (symbol
     (setq string (symbol-name string))
     (setq len (length string)))
    (character
     (return-from copy-string-arg
                    (make-string 1 :initial-element string ))))
  (%substr string org (+ len org)))     

(defun string-upcase (string &key (start 0) end)
  (setq string (copy-string-arg string))
  (setq end (check-sequence-bounds string start end))
  (%strup string start end))

(defun %strup (string start end)
  (declare (fixnum start end)
           (optimize (speed 3) (safety 0)))
  (unless (typep string 'simple-string)
    (check-type string simple-string))
  (do* ((i start (1+ i))
        (to-upper *lower-to-upper*)
        (n (length to-upper)))
       ((>= i end) string)
    (declare (fixnum i n) (type (simple-array (signed-byte 16) (*)) to-upper))
    (let* ((ch (schar string i))
           (code (char-code ch))
           (delta (if (< code n) (aref to-upper code) 0)))
      (declare (character ch)
               (type (mod #x110000) code)
               (type (signed-byte 16) delta))
      (unless (zerop delta)
        (setf (schar string i) (code-char (the valid-char-code (+ code delta))))))))



(defun string-capitalize (string &key (start 0) end)
  (setq string (copy-string-arg string))
  (setq end (check-sequence-bounds string start end))
  (%strcap string start end))

(defun %strcap (string start end)
  (declare (fixnum start end))
  (let ((state :up)
        (i start))
    (declare (fixnum i))
    (while (< i end)
      (let* ((c (%schar string i))
             (alphap (alphanumericp c))) ; makes no sense
        (if alphap
          (progn
            (setf (%schar string i)
                  (case state
                    (:up (char-upcase c))
                    (t (char-downcase c))))
            (setq state :down))
          (setq state :up)))
      (setq i (1+ i)))
    string))




(defun nstring-downcase (string &key (start 0) end)
  (etypecase string
    (string
     (setq end (check-sequence-bounds string start end))
     (if (typep string 'simple-string)
       (%strdown string start end)
       (multiple-value-bind (data offset) (array-data-and-offset string)
         (%strdown data (+ start offset) (+ end offset))))
     string)))

(defun nstring-upcase (string &key (start 0) end)
  (etypecase string
    (string
     (setq end (check-sequence-bounds string start end))
     (if (typep string 'simple-string)
       (%strup string start end)
       (multiple-value-bind (data offset) (array-data-and-offset string)
         (%strup data (+ start offset) (+ end offset))))
     string)))


(defun nstring-capitalize (string &key (start 0) end)
  (etypecase string
    (string
     (setq end (check-sequence-bounds string start end))
     (if (typep string 'simple-string)
       (%strcap string start end)
       (multiple-value-bind (data offset) (array-data-and-offset string)
         (%strcap data (+ start offset) (+ end offset))))
     string)))



(defun nstring-studlify (string &key start end)
  (declare (ignore start end))
  string)

  
(defun string-compare (string1 start1 end1 string2 start2 end2)
  (let ((istart1 (or start1 0)))
    (if (and (typep string1 'simple-string)(null start1)(null end1))
      (setq start1 0 end1 (length string1))
      (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))
    (if (and (typep string2 'simple-string)(null start2)(null end2))
      (setq start2 0 end2 (length string2))
      (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))
    (setq istart1 (%i- start1 istart1))
    (let* ((val t)
           (to-upper *lower-to-upper*)
           (n (length to-upper)))
      (declare (optimize (speed 3)(safety 0))
               (type (simple-array (signed-byte 16) (*)) to-upper)
               (fixnum n))
      (do* ((i start1 (+ 1 i))
            (j start2 (+ 1 j)))
           ()
        (declare (fixnum i j))
        (when (eq i end1)
          (when (neq j end2)
            (setq val -1))
          (return))
        (when (eq j end2)
          (setq end1 i)
          (setq val 1)
          (return))
        (let* ((code1 (%scharcode string1 i))
               (code2 (%scharcode string2 j)))
          (declare (type (mod #x11000) code1 code2))
          (if (< code1 n)
            (setq code1 (+ (aref to-upper code1) code1)))
          (if (< code2 n)
            (setq code2 (+ (aref to-upper code2) code2)))
          (unless (= code1 code2)            
            (setq val (if (< code1 code2) -1 1))
            (setq end1 i)
            (return))))
      (values val (%i- end1 istart1)))))


(defun string-greaterp (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)
    (if (eq result 1) pos nil)))

(defun string-not-greaterp (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)
    (if (eq result 1) nil pos)))

(defun string-not-equal (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)
    (if (eq result t) nil pos)))

(defun string-not-lessp (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char-equal) of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-compare string1 start1 end1 string2 start2 end2)
    (if (eq result -1) nil pos)))

(declaim (inline %string-start-end))
(defun %string-start-end (string)
  (etypecase string
    (string (multiple-value-bind (data offset)
                (array-data-and-offset string)
              (declare (fixnum offset))
              (values data offset (+ offset (length string)))))
    (symbol (let* ((pname (symbol-name string)))
              (values pname 0 (length pname))))
    (character (let* ((data (make-string 1)))
                 (setf (schar data 0) string)
                 (values data 0 1)))))
                       
;;; This is generally a bit faster then the version that deals with
;;; user-supplied bounds, both because the caller avoids passing
;;; some extra arguments and because those bounds don't need to be
;;; validated.
(defun %fixed-string-equal (string1 string2)
  (let* ((start1 0)
         (end1 0)
         (start2 0)
         (end2 0))
    (declare (fixnum start1 end1 start2 end2))
    (if (typep string1 'simple-string)
      (setq end1 (uvsize string1))
      (multiple-value-setq (string1 start1 end1)
        (%string-start-end string1)))
    (if (typep string2 'simple-string)
      (setq end2 (uvsize string2))
      (multiple-value-setq (string2 start2 end2)
        (%string-start-end string2)))
    (locally
        (declare (optimize (speed 3)(safety 0))
                 (simple-string string1 string2))
      (when (= (the fixnum (- end1 start1))
               (the fixnum (- end2 start2)))
        (do* ((i start1 (1+ i))
              (j start2 (1+ j))
              (map *lower-to-upper*))
             ((= i end1) t)
          (declare (fixnum i j))
          (let ((code1 (%scharcode string1 i))
                (code2 (%scharcode string2 j)))
            (declare (type (mod #x110000) code1 code2))
            (unless (= code1 code2)
              (unless (= (the (mod #x110000) (%char-code-case-fold code1 map))
                         (the (mod #x110000) (%char-code-case-fold code2 map)))
                (return)))))))))

;;; Some of the start1/end1/start2/end2 args may be bogus.
(defun %bounded-string-equal (string1 string2 start1 end1 start2 end2)
  (let* ((disp1 nil)
         (len1 0)
         (disp2 nil)
         (len2 0))
    (declare (fixnum len1 len2))
    (if (typep string1 'simple-string)
      (setq len1 (length (the simple-string string1)))
      (etypecase string1
        (string (setq len1 (length string1))
                (multiple-value-setq (string1 disp1)
                  (array-data-and-offset string1)))
        (symbol (setq string1 (symbol-name string1)
                      len1 (length (the simple-string string1))))
        (character (setq string1 (make-string 1 :initial-element string1)
                         len1 1))))
    (if (typep string2 'simple-string)
      (setq len2 (length (the simple-string string2)))
      (etypecase string2
        (string (setq len2 (length string2))
                (multiple-value-setq (string2 disp2)
                  (array-data-and-offset string2)))
        (symbol (setq string2 (symbol-name string2)
                      len2 (length (the simple-string string2))))
        (character (setq string2 (make-string 1 :initial-element string2)
                         len2 1))))
    (flet ((bad-index (index vector) (error "Index ~s is invalid for ~s" index vector)))
      (if (null start1)
        (setq start1 0)
        (when (or (not (typep start1 'fixnum))
                  (< (the fixnum start1) 0))
          (bad-index start1 string1)))
      (if (null end1)
        (setq end1 len1)
        (when (or (not (typep end1 'fixnum))
                  (< (the fixnum end1) 0)
                  (> (the fixnum end1) len1))
          (bad-index end1 string1)))
      (locally (declare (fixnum start1 end1))
        (if (> start1 end1)
          (error ":start1 argument ~s exceeds :end1 argument ~s" start1 end1))
        (when disp1
          (locally (declare (fixnum disp1))
            (incf start1 disp1)
            (incf end1 disp1)))
        (if (null start2)
          (setq start2 0)
          (when (or (not (typep start2 'fixnum))
                    (< (the fixnum start2) 0))
            (bad-index start2 string2)))
        (if (null end2)
          (setq end2 len2)
          (when (or (not (typep end2 'fixnum))
                    (< (the fixnum end2) 0)
                    (> (the fixnum end2) len2))
            (bad-index end2 string2)))
        (locally (declare (fixnum start2 end2))
          (if (> start2 end2)
            (error ":start2 argument ~s exceeds :end2 argument ~s" start2 end2))
          (when disp2
            (locally (declare (fixnum disp2))
              (incf start2 disp2)
              (incf end2 disp2)))
          (locally
              (declare (optimize (speed 3)(safety 0))
                       (simple-string string1 string2))
            (when (= (the fixnum (- end1 start1))
                     (the fixnum (- end2 start2)))
              (do* ((i start1 (1+ i))
                    (j start2 (1+ j))
                    (map *lower-to-upper*))
                   ((= i end1) t)
                (declare (fixnum i j))
                (let ((code1 (%scharcode string1 i))
                      (code2 (%scharcode string2 j)))
                  (declare (type (mod #x110000) code1 code2))
                  (unless (= code1 code2)
                    (unless (= (the (mod #x110000) (%char-code-case-fold code1 map))
                               (the (mod #x110000) (%char-code-case-fold code2 map)))
                      (return))))))))))))

(defun string-equal (string1 string2 &key start1 end1 start2 end2)
  "Given two strings (string1 and string2), and optional integers start1,
  start2, end1 and end2, compares characters in string1 to characters in
  string2 (using char-equal)."
  (if (or start1 end1 start2 end2)
    (%bounded-string-equal string1 string2 start1 end1 start2 end2)
    (%fixed-string-equal string1 string2)))



(defun string-lessp (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char-equal)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos)(string-compare string1 start1 end1 string2 start2 end2)
    (if (eq result -1) pos nil)))

;;; forget script-manager - just do codes
(defun string-cmp (string1 start1 end1 string2 start2 end2)
  (let ((istart1 (or start1 0)))
    (if (and (typep string1 'simple-string)(null start1)(null end1))
      (setq start1 0 end1 (length string1))
      (multiple-value-setq (string1 start1 end1)(string-start-end string1 start1 end1)))
    (if (and (typep string2 'simple-string)(null start2)(null end2))
      (setq start2 0 end2 (length string2))
      (multiple-value-setq (string2 start2 end2)(string-start-end string2 start2 end2)))
    (setq istart1 (%i- start1 istart1))        
    (let* ((val t))
      (declare (optimize (speed 3)(safety 0)))
      (do* ((i start1 (%i+ 1 i))
            (j start2 (%i+ 1 j)))
           ()
        (when (eq i end1)
          (when (neq j end2)(setq val -1))
          (return))
        (when (eq j end2)
          (setq end1 i)
          (setq val 1)(return))
        (let ((code1 (%scharcode string1 i))
              (code2 (%scharcode string2 j)))
          (declare (fixnum code1 code2))
          (unless (= code1 code2)            
            (setq val (if (%i< code1 code2) -1 1))
            (setq end1 i)
            (return))))
      (values val (%i- end1 istart1)))))

(defun string> (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically greater than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)
    (if (eq result 1) pos nil)))

(defun string>= (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically greater
  than or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)
    (if (eq result -1) nil pos)))

(defun string< (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically less than
  the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)
    (if (eq result -1) pos nil)))

(defun string<= (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is lexicographically less than
  or equal to the second string, returns the longest common prefix
  (using char=) of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)
    (if (eq result 1) nil pos)))

; this need not be so fancy?
(defun string/= (string1 string2 &key start1 end1 start2 end2)
  "Given two strings, if the first string is not lexicographically equal
  to the second string, returns the longest common prefix (using char=)
  of the two strings. Otherwise, returns ()."
  (multiple-value-bind (result pos) (string-cmp string1 start1 end1 string2 start2 end2)
    (if (eq result t) nil pos)))



(provide 'chars)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/chars.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/pprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;-*-syntax:COMMON-LISP;Package:"CCL"-*-
;;;
;;; Copyright 1989-1990 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.
;-*-syntax:COMMON-LISP;Package:"CCL"-*-

;;	Change History (most recent first):
;;  2 4/8/97   akh  pretty-loop dont loop
;;  3 12/13/95 Alice Hartley no call compiler at load time
;;  3 3/2/95   akh  will promote strings to fat strings if needed
;;  (do not edit before this line!!)


;------------------------------------------------------------------------

;Copyright 1989,1990 by the Massachusetts Institute of Technology, Cambridge, 
;Massachusetts.

;Permission to use, copy, modify, and distribute this software and its
;documentation for any purpose and without fee is hereby granted,
;provided that this copyright and permission notice appear in all
;copies and supporting documentation, and that the name of M.I.T. not
;be used in advertising or publicity pertaining to distribution of the
;software without specific, written prior permission. M.I.T. makes no
;representations about the suitability of this software for any
;purpose.  It is provided "as is" without express or implied warranty.

;    M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
;    ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
;    M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
;    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
;    WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
;    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
;    SOFTWARE.

;------------------------------------------------------------------------

;This file "XP.LISP" implements an efficient pretty printer for Common
;Lisp.  The functions in this file are documented fully in MIT/AIM-1102a, July
;1989.  This report can be obtained by sending $3.25 to

;              Publications
;	       MIT AI Laboratory
;	       545 Tech. Sq.
;	       Cambridge MA 02139

;This file attempts to be as compatible with pure Common Lisp as possible.
;It has been tested on the following Common Lisps to date (7/31/89).
;  Symbolics CL version 7 (does not work in version 6),
;  LUCID CL version 3.0.2 on a sun.
;  Allegro CL version 1.2.1 on a Macintosh.
;  CMU CL.

;The companion file "XPTEST.LISP" contains a set of 600+ tests.  You should
;run these tests after the first time you compile this file on a new system.

;The companion file "XPDOC.TXT" contains brief documentation
; 04/05/97 akh  pretty-loop fix for *print-level* exceeded
; 10/26/95 slh   %gvector -> %istruct
; 08/26/93 bill  indentation
; -------- 3.0d12
; 06/26/93 alice stream-fresh-line (xp-stream) was producing premature newlines
; 05/24/93 alice *free-xps* and *free-circularity-hash-tables* are global
; 03/04/93 alice set *error-print-circle* to T
; 02/23/93 alice get-printer - look in others table before def.., with.. hack
; 02/15/93 alice don't unwind-protect in pprint-logical-block+
; 12/21/92 alice lets not print loop as #'
; 06/23/92 alice change set-pprint-dispatch+ and priority-> so '(0) is less than 0
;--------------- 2.0
; 02/22/92 (alice from "post 2.0f2c5:pprint-defmethod-patch") fix DEFMETHOD-LIKE.
; -------- 2.0f2c5
; 01/29/92 gb    pretty-structure calls structure-print-function.
; -------- 2.0f2
; 10/11/91 alice dont print generic-function as #'
; 10/09/91 alice write+ don't deal with structures and arrays - prior fix was brain dead
;    p.s. technically we shouldn't special case strings, fixnums and symbols either
; 10/03/91 alice write+ - if print-object method for structure use it.
; 09/25/91 alice fix circularity-process so we can rebind *print-circle* in mid stream 
; 09/25/91 alice pretty-structure - no dangling space if no slots
; 09/24/91 alice fix pretty-structure bogus keyword printing
; 09/11/91 alice keep first pass output until first circularity in case no circularities
; 09/09/91 alice fix print circle in case circularity detected after first line (geez)
; 		dont die if *print-pprint-dispatch* is nil
;--------------- 2.0b3
; 08/21/91 gb xp-stream-stream
; 07/21/91 gb def-accessors vice defstruct.
; 07/09/91 alice allow write+ to tail call 
; 07/01/91 bind level and length as (f *print-readably*)
; 07/01/91 generic-function & reinstate some MLY hacks for "def.." "with-.." etc.
; 06/24/91 added pretty-structure
; 05/22/91 Modified for MCL 2.0b
;;;;;;;;;;;;;;
;;; lisp: => cl:
;;; string-char => character (or base-character?)
;;; #-ccl-2 compiled format and format and much else
;;;  put the xp-stream in the xp-structure
;;; write-char => write-char+ in pretty-loop
;;; nuke *last-abbreviated-printing*
;;; Teach it about fred-special-indent-alist
;;; in fred-alist 2 means defun-like, 0 is progn-like
;;;   3 is defsetf-print , 1 is block-like
;;; Put circularity table & number in the structure? - didn't do it
;;; Nuke the xp package
;;; Added progn-print
;;; MAYBELAB take xp-stream or xp-structure
;;; Gave up on #+/#-ccl-2
;;; Could save a few hundred bytes by (funcall (formatter ...)) to (format ... )) - maybe not
;;; The dispatch table could use some compacting: done!
;;;  an entry contains test: 0 - must be some predicate if not of the other form
;;;			fn: ok
;;;                     full-spec: '((0)(cons (member defvar)))
;;; Nuke *print-shared* and *parents*
;;; This version has a new special *xp-current-object* but doesnt gratuitously cons.
;;; Fixed circle doing it twice when it needn't (what does this break?)
;;; member => memq
;;; Apply optimizations as Mly did in prior conversion, i.e. liberal doses
;;; of %i+, (declare (fixnum ...)), dont fetch a stucture field 15 times
;;; when once will suffice, no char=, fewer position & find
;;; Now about same speed as old one. (actually 10% slower) & it conses less
;;; In pprint-dispatch just store the function if (cons (member blah)) & (0) or 0.
;;; nuke some entries in pprint-dispatch where same info is in fred-special-indent-alist
;;; Size is down from 23K larger to 18K larger.
;;; maybe-print-fast iff readtable-case is :upcase
;;; add defmethod-like for guess what
;;;  nuke *abbreviation-happened*


(in-package "CCL")

(defvar *ipd* nil ;see initialization at end of file.
  "initial print dispatch table.")

(eval-when (:compile-toplevel :execute)
  (declaim (inline xp-structure-p)))

(defun xp-structure-p (x)
  (istruct-typep x 'xp-structure))


(defun entry-p (x)
  (istruct-typep x 'entry))

  

;default (bad) definitions for the non-portable functions

(eval-when (:execute :load-toplevel :compile-toplevel)
(defun structure-type-p (x) (structurep x))
(defun output-width     (&optional (s *standard-output*))
  (when (streamp s)(line-length s)))
(defun output-position  (&optional (s *standard-output*))
  (when (streamp s)(column s)))
)

(defvar *logical-block-p* nil
  "True if currently inside a logical block.")

(defvar *locating-circularities* nil
  "Integer if making a first pass over things to identify circularities.
   Integer used as counter for #n= syntax.")

(def-standard-initial-binding *free-circularity-hash-tables* nil)

(defun get-circularity-hash-table ()
  (let ((table (pop *free-circularity-hash-tables*)))
    (if table table (make-hash-table :test 'eq))))

;If you call this, then the table gets efficiently recycled.
(defun free-circularity-hash-table (table)
  (clrhash table)
  (pushnew table *free-circularity-hash-tables*))


;                       ---- DISPATCHING ----

(cl:defstruct (pprint-dispatch-table (:conc-name nil) (:copier nil))
  (conses-with-cars (make-hash-table :test #'eq) :type (or null hash-table))
  (parent-table nil)
  (others nil :type list)
  (commit-hook nil))

;;; We'd of course get finer-grained locking if each dispatch-table had
;;; its own lock, but we want to make creation of a pprint-dispatch-table
;;; as cheap as we can make it
(defstatic *pprint-dispatch-table-lock* (make-lock))


(defmethod print-object ((dispatch pprint-dispatch-table) stream)
  (print-unreadable-object (dispatch stream :type t :identity t)))

(defstatic *standard-pprint-dispatch-table* nil) ;set below

;;;The list and the hash-tables contain entries of the
;;;following form.  When stored in the hash tables, the test entry is 
;;;the number of entries in the OTHERS list that have a higher priority.

(defun make-entry (&key test fn full-spec)
  (%istruct 'entry test fn full-spec))


(defun copy-pprint-dispatch-table-conses-with-cars (table)
  (let* ((old (conses-with-cars table)))
    (when old
      (let* ((new (make-hash-table :test #'eq :size (max (hash-table-count old) 32))))
        (maphash (lambda (key value)
                   (setf (gethash key new)
                         (if (istruct-typep value 'entry)(copy-uvector value) value)))
                 old)
        new))))

(defun copy-pprint-dispatch (&optional (table *print-pprint-dispatch*))
  (if (null table)
    (make-pprint-dispatch-table
     :conses-with-cars nil
     :others (copy-list (others *ipd*))
     :parent-table *ipd*
     :commit-hook (commit-hook *ipd*))
    (let* ((table (require-type table 'pprint-dispatch-table)))
      (with-lock-grabbed (*pprint-dispatch-table-lock*)
        (make-pprint-dispatch-table
         :others (copy-list (others table))
         :conses-with-cars (copy-pprint-dispatch-table-conses-with-cars table)
         :commit-hook (commit-hook table)
         :parent-table (parent-table table)
         :commit-hook (commit-hook table))))))


(defun set-pprint-dispatch (type-specifier function
			    &optional (priority 0) (table *print-pprint-dispatch*))
  (when (or (not (numberp priority)) (complexp priority))
    (error "invalid PRIORITY argument ~A to SET-PPRINT-DISPATCH" priority))
  (when (eq table *standard-pprint-dispatch-table*)
    (error "The standard pprint dispatch table must never be modified."))
  (with-lock-grabbed (*pprint-dispatch-table-lock*)
    (let* ((parent (parent-table table)))
      (when parent
        (setf (conses-with-cars table)
              (copy-pprint-dispatch-table-conses-with-cars parent)
              (others table) (copy-list (others parent))
              (parent-table table) nil))
      (set-pprint-dispatch+ type-specifier function priority table))))


(defun set-pprint-dispatch+ (type-specifier function priority table)
  (let* ((category (specifier-category type-specifier))
	 (pred
	   (if (not (eq category 'other)) nil
	       (let ((pred (specifier-fn type-specifier)))
		 (if (symbolp pred)
                  (symbol-function pred)
                  ; checking for (lambda (x) (foo x)) => #'foo 
		  (if (and (consp (caddr pred))
			   (symbolp (caaddr pred)) 
			   (equal (cdaddr pred) '(x)))
                    (symbol-function (caaddr pred))
                    ; calling the compiler at load time is an indictable offense
                    (compile nil pred))))))
	 (entry (if function (make-entry :test pred
					 :fn function
					 :full-spec (list priority type-specifier)))))
    (case category
      (cons-with-car
       (let ((key (cadadr type-specifier)) ;(cons (member FOO))
             (cons-tbl (or (conses-with-cars table)
                           (setf (conses-with-cars table)
                                 (make-hash-table :test #'eq)))))
	(cond ((null function) (remhash key cons-tbl))
	      (T (let ((num 
		       (count-if #'(lambda (e)
				     (priority-> e priority))
				 (others table))))
                   (cond ((and (or ;(eq priority 0)
                                   (and (consp priority)(eq (%car priority) 0)))
                               (eq num 0))
                          (setq entry function))
                         (t (setf (entry-test entry) num)))
		   (setf (gethash key cons-tbl) entry))))))
      (T ;other
	 (let ((old (car (member type-specifier (others table) :test #'equal
				 :key #'(lambda (e) (cadr (entry-full-spec e)))))))
	   (when old
	     (setf (others table) (delete old (others table)))
	     (adjust-counts table (car (entry-full-spec old)) -1)))
	 (when entry
	   (let ((others (cons nil (others table))))
	      (do ((l others (cdr l)))
		  ((null (cdr l)) (rplacd l (list entry)))
		(when (priority-> priority (car (entry-full-spec (cadr l))))
		  (rplacd l (cons entry (cdr l)))
		  (return nil)))
	      (setf (others table) (cdr others)))
	   (adjust-counts table priority 1)))))
  nil)

(defun priority-> (entry-x entry-y)
  (flet ((foo (e)
              (cond ((istruct-typep e 'entry)(car (entry-full-spec e)))
                    ((or (numberp e)(consp  e)) e)
                    (t '(0)))))
    (let ((x (foo entry-x))
          (y (foo entry-y)))      
      (if (consp x)
        (if (consp y) (> (car x) (car y)) nil)
        (if (consp y) T (> x y))))))


(defun adjust-counts (table priority delta)
  (maphash #'(lambda (key value)
	       (when (priority-> priority value)
                 (when (not (istruct-typep value 'entry))
                   (setf (gethash key (conses-with-cars table))
                         (setq value (make-entry :fn value :test 0 :full-spec '(0)))))
                 (incf (entry-test value) delta)))
	   (conses-with-cars table)))

(defun pprint-dispatch (object &optional (table *print-pprint-dispatch*))
  (flet ((non-pretty-print (s object)
           (write-not-pretty s object
                             (if (get-*print-frob* '*print-level*)
                               (- *print-level* *current-level*))
                             nil nil)))
    (let ((fn (get-printer object table)))
      (values (or fn #'non-pretty-print) (not (null fn))))))

(defun get-printer-internal (object hash others)
  (let* (entry)
      (cond ((consp object)
             (setq entry (gethash (%car object) hash))
             (when (not entry)
               (setq entry (find object others :test #'fits))
               (if entry
                 (setq entry (entry-fn entry))))))
      (if (not entry)
        (setq entry (find object others :test #'fits))
        (if (istruct-typep entry 'entry)
          (let ((test (entry-test entry)))
            (when (numberp test)
              (do ((i test (1- i))
                   (l others (cdr l)))
                  ((zerop i))
                (when (fits object (car l)) (setq entry (car l)) (return nil)))))))
      (when entry
        (if (istruct-typep entry 'entry)(entry-fn entry) entry))))

(defun get-printer (object table)
  (let* ((parent (parent-table table)))
    (if parent
      (get-printer-internal object (conses-with-cars parent) (others parent))
      (with-lock-grabbed (*pprint-dispatch-table-lock*)
        (get-printer-internal object (conses-with-cars table) (others table))))))

(defun fits (obj entry) 
  (funcall (entry-test entry) obj))

(defun specifier-category (spec)
  (cond ((and (consp spec)
	      (eq (car spec) 'cons)
	      (consp (cdr spec))
	      (null (cddr spec))
	      (consp (cadr spec))
	      (eq (caadr spec) 'member)
	      (consp (cdadr spec))
	      (null (cddadr spec)))
	 'cons-with-car)
	(T 'other)))

; lets make fewer things fns that compile at load time, esp anything
; we do - really none should
(defun specifier-fn (spec) 
  (if (and (consp spec)(eq (car spec) 'satisfies)(symbolp (cadr spec)))
    (cadr spec)
    (if (and (symbolp spec)(type-predicate spec))  ; ccl specific
      (type-predicate spec)
      `(lambda (x) ,(convert-body spec)))))

(defun convert-body (spec)
  (cond ((atom spec) `(typep x ',spec))
	((member (car spec) '(and or not))
	 (cons (car spec) (mapcar #'convert-body (cdr spec))))
	((eq (car spec) 'member)
	 `(member x ',(copy-list (cdr spec))))
	((eq (car spec) 'cons)
	 `(and (consp x)
	       ,@(if (cdr spec) `((let ((x (car x)))
				    ,(convert-body (cadr spec)))))
	       ,@(if (cddr spec) `((let ((x (cdr x)))
				     ,(convert-body (caddr spec)))))))
	((eq (car spec) 'satisfies)
	 `(funcall (function ,(cadr spec)) x))
	(T `(typep x ',spec))))

;               ---- XP STRUCTURES, AND THE INTERNAL ALGORITHM ----

(eval-when (:execute :compile-toplevel) ;not used at run time.
  (defvar block-stack-entry-size 1)
  (defvar prefix-stack-entry-size 5)
  (defvar queue-entry-size 7)
  (defvar buffer-entry-size 1)
  (defvar prefix-entry-size 1)
  (defvar suffix-entry-size 1))

(eval-when (:execute :load-toplevel :compile-toplevel) ;used at run time
  (defvar block-stack-min-size #.(* 35. block-stack-entry-size))
  (defvar prefix-stack-min-size #.(* 30. prefix-stack-entry-size))
  (defvar queue-min-size #.(* 75. queue-entry-size))
  (defvar buffer-min-size 256.)
  (defvar prefix-min-size 256.)
  (defvar suffix-min-size 256.)) 

(progn
  (setf (fdefinition 'xp-stream-stream) #'(lambda (s) (xp-stream s)))

  (defmethod streamp ((x xp-structure)) t)
  (defmethod streamp ((x xp-stream)) t)

  (defmethod output-stream-p ((x xp-structure)) t)
  (defmethod output-stream-p ((x xp-stream)) t)
  
  (defun make-xp-structure ()
    (%istruct
     'xp-structure
     nil                                ; xp-base-stream
     nil                                ; xp-linel
     nil                                ; xp-line-limit
     nil                                ; xp-line-no
     nil                                ; xp-char-mode
     nil                                ; xp-char-mode-counter
     nil                                ; xp-depth-in-blocks
     (make-array #.block-stack-min-size) ; xp-block-stack
     nil                                ; xp-block-stack-ptr
     (make-array #.buffer-min-size :element-type 'base-char)
                                        ; use make-string and let it default?
                                        ; xp-buffer
     nil                                ; xp-charpos
     nil                                ; xp-buffer-ptr
     nil                                ; xp-buffer-offset
     (make-array #.queue-min-size)      ; xp-queue
     0                                  ; xp-qleft
     0                                  ; xp-qright
     (make-array #.buffer-min-size :element-type 'base-char)
                                        ; xp-prefix
     (make-array #.prefix-stack-min-size) ; xp-prefix-stack
     nil                                ; xp-prefix-stack-ptr
     (make-array #.buffer-min-size :element-type 'base-char)
                                        ; xp-suffix
     nil                                ; xp-stream
     nil                                ; xp-string-stream
     ))                            ; XP-STRUCTURE is a built-in class.

  (defmethod write-internal-1 ((xp-struc xp-structure) object level list-kludge)
    (write-internal-1 (xp-stream xp-struc) object level list-kludge))



  (defun get-xp-stream (pp)
    (xp-stream pp))
  )

 
(eval-when (:compile-toplevel :execute)
(defmacro LP<-BP (xp &optional (ptr nil))
  (if (null ptr) (setq ptr `(xp-buffer-ptr ,xp)))
  `(the fixnum (%i+ ,ptr (xp-charpos ,xp))))
(defmacro TP<-BP (xp)
  `(the fixnum (%i+ (xp-buffer-ptr ,xp) (xp-buffer-offset ,xp))))
(defmacro BP<-LP (xp ptr)
  `(the fixnum (%i- ,ptr (xp-charpos ,xp))))
(defmacro BP<-TP (xp ptr)
  `(the fixnum (%i- ,ptr (xp-buffer-offset ,xp))))
;This does not tell you the line position you were at when the TP
;was set, unless there have been no newlines or indentation output 
;between ptr and the current output point.
(defmacro LP<-TP (xp ptr)
  `(LP<-BP ,xp (BP<-TP ,xp ,ptr)))

;We don't use adjustable vectors or any of that, because we seldom have
;to actually extend and non-adjustable vectors are a lot faster in
;many Common Lisps.

(defmacro xp-check-size (FORM ptr min-size entry-size
                           &optional (type '(simple-array * (*))))
  `(let ((.old. ,form)
         (.ptr. ,ptr))
     (declare (type ,type .old.) (type fixnum .ptr.))
     (if (and (ccl::%i> .ptr. ,(- min-size entry-size)) ;seldom haxpens
              (ccl::%i> .ptr. (- (length (the ,type .old.)) ,entry-size)))
         (let ((.new. ,(let ((l `(ccl::%i+ .ptr. ,(if (= entry-size 1)
                                                    50
                                                    (* 10 entry-size)))))
                         `(make-array ,l :element-type (array-element-type .old.)))))
           ;;>>
           (replace .new. .old.)
           (setf ,form .new.))
         .old.)))

(defmacro section-start (xp) `(svref (xp-block-stack ,xp) (xp-block-stack-ptr ,xp)))
) ; eval-when

;		---- CCL specific METHODS --------
(progn
(defmethod stream-write-char ((stream xp-stream) char)
  (write-char+ char (slot-value stream 'xp-structure))
  char)

(defmethod stream-write-char ((stream xp-structure) char)
  (write-char+ char stream)
  char)

(defmethod stream-write-string ((stream xp-stream) string &optional (start 0) end)
  (setq end (check-sequence-bounds string start end))
  (write-string+ string (slot-value stream 'xp-structure) start end)
  string)

(defmethod stream-write-string ((stream xp-structure) string &optional (start 0) end)
  (setq end (check-sequence-bounds string start end))
  (write-string+ string stream start end)
  string)

; If we really don't care about the value returned then just
; plain (pprint-newline+ :fresh xp) is fine.
(defmethod stream-fresh-line ((stream xp-stream))
  (let ((xp (slot-value stream 'xp-structure)))
    (attempt-to-output xp nil nil)  ; was (attempt-to-output xp T T)
    (prog1 (not (zerop (LP<-BP xp)))      
      (pprint-newline+ :fresh xp))))


(defmethod stream-finish-output ((stream xp-stream))
  (attempt-to-output (slot-value stream 'xp-structure) t t))

(defmethod stream-force-output ((stream xp-stream))
  (attempt-to-output (slot-value stream 'xp-structure) t t)
  nil)

(defmethod stream-clear-output ((stream xp-stream))
  (let ((*locating-circularities* 1)) ;hack to prevent visible output
    (attempt-to-output (slot-value stream 'xp-structure) T T))
  nil)

(defmethod stream-line-column ((stream xp-stream))
  (LP<-BP (slot-value stream 'xp-structure)))

(defmethod stream-line-length ((stream xp-stream))
  (xp-linel (slot-value stream 'xp-structure)))

)


(defun push-block-stack (xp)
  (let ((ptr (%i+ (xp-block-stack-ptr xp) #.block-stack-entry-size)))
    (setf (xp-block-stack-ptr xp) ptr)
    (xp-check-size (xp-block-stack xp) ptr
                   #.block-stack-min-size #.block-stack-entry-size)))

(eval-when (:compile-toplevel :execute)
(defmacro prefix-ptr (xp)
  `(svref (xp-prefix-stack ,xp) (xp-prefix-stack-ptr ,xp)))
(defmacro suffix-ptr (xp)
  `(svref (xp-prefix-stack ,xp) (%i+ (xp-prefix-stack-ptr ,xp) 1)))
(defmacro non-blank-prefix-ptr (xp)
  `(svref (xp-prefix-stack ,xp) (%i+ (xp-prefix-stack-ptr ,xp) 2)))
(defmacro initial-prefix-ptr (xp)
  `(svref (xp-prefix-stack ,xp) (%i+ (xp-prefix-stack-ptr ,xp) 3)))
(defmacro section-start-line (xp)
  `(svref (xp-prefix-stack ,xp) (%i+ (xp-prefix-stack-ptr ,xp) 4)))

(defmacro stk-prefix-ptr (stk ptr)
  `(svref ,stk ,ptr))
(defmacro stk-suffix-ptr (stk ptr)
  `(svref ,stk (%i+ ,ptr 1)))
(defmacro stk-non-blank-prefix-ptr (stk ptr)
  `(svref ,stk (%i+ ,ptr 2)))
) ; EVAL-when


; saves 100 bytes and a microsecond or 2
(defun push-prefix-stack (xp)
  (let ((old-prefix 0)
        (old-suffix 0) 
        (old-non-blank 0)
        (stack (xp-prefix-stack xp))
        (ptr (xp-prefix-stack-ptr xp)))
    (declare (fixnum ptr))
    (when (>= ptr 0)
      (setq old-prefix (stk-prefix-ptr stack ptr)
	    old-suffix (stk-suffix-ptr stack ptr)
	    old-non-blank (stk-non-blank-prefix-ptr stack ptr)))
    (setq ptr (%i+ ptr #.prefix-stack-entry-size))
    (setf (xp-prefix-stack-ptr xp) ptr)
    (setq stack
          (xp-check-size (xp-prefix-stack xp) ptr
                   #.prefix-stack-min-size #.prefix-stack-entry-size))
    (setf (stk-prefix-ptr stack ptr) old-prefix)
    (setf (stk-suffix-ptr stack ptr) old-suffix)
    (setf (stk-non-blank-prefix-ptr stack ptr) old-non-blank)))



(eval-when (:compile-toplevel :execute)
(defmacro Qtype   (xp index) `(svref (xp-queue ,xp) ,index))
(defmacro Qkind   (xp index) `(svref (xp-queue ,xp) (1+ ,index)))
(defmacro Qpos    (xp index) `(svref (xp-queue ,xp) (+ ,index 2)))
(defmacro Qdepth  (xp index) `(svref (xp-queue ,xp) (+ ,index 3)))
(defmacro Qend    (xp index) `(svref (xp-queue ,xp) (+ ,index 4)))
(defmacro Qoffset (xp index) `(svref (xp-queue ,xp) (+ ,index 5)))
(defmacro Qarg    (xp index) `(svref (xp-queue ,xp) (+ ,index 6)))
(defmacro xpq-type (queue index)
  `(svref ,queue ,index))
(defmacro xpq-kind (queue index)
  `(svref ,queue (ccl::%i+ ,index 1)))
(defmacro xpq-pos (queue index)
  `(svref ,queue (ccl::%i+ ,index 2)))
(defmacro xpq-depth (queue index)
  `(svref ,queue (ccl::%i+ ,index 3)))
(defmacro xpq-end (queue index)
  `(svref ,queue (ccl::%i+ ,index 4)))
(defmacro xpq-offset (queue index)
  `(svref ,queue (ccl::%i+ ,index 5)))
(defmacro xpq-arg (queue index)
  `(svref ,queue (ccl::%i+ ,index 6)))
) ; eval-when

;we shift the queue over rather than using a circular queue because
;that works out to be a lot faster in practice.  Note, short printout
;does not ever cause a shift, and even in long printout, the queue is
;shifted left for free every time it happens to empty out.

(defun enqueue (xp type kind &optional arg)  
  (let ((queue (xp-queue xp))
        (qright (ccl::%i+ (xp-qright xp) #.queue-entry-size))
        (qleft (xp-qleft xp)))
    (declare (type fixnum qright qleft) (type simple-vector queue))
    (when (ccl::%i> qright #.(- queue-min-size queue-entry-size))
      ;;>> generic
      (replace queue queue :start2 qleft :end2 qright)
      (setf (xp-qleft xp) 0
            qright (ccl::%i- qright qleft)))
    (setq queue (xp-check-size (xp-queue  xp) qright
                               #.queue-min-size #.queue-entry-size))
    (setf (xp-qright xp) qright
          (xpq-type queue qright) type
          (xpq-kind queue qright) kind
          (xpq-pos queue qright) (TP<-BP xp)
          (xpq-depth queue qright) (xp-depth-in-blocks xp)
          (xpq-end queue qright) nil
          (xpq-offset queue qright) nil
          (xpq-arg queue qright) arg)))

(defmacro Qnext (index) `(%i+ ,index #.queue-entry-size))


;This maintains a list of XP structures.  We save them
;so that we don't have to create new ones all of the time.
;We have separate objects so that many can be in use at once.

;(Note should really be doing some locking here, but CL does not have the
;primitives for it.  There is a tiny probability here that two different
;processes could end up trying to use the same xp-stream)

(def-standard-initial-binding *free-xps* nil) ;free list of XP stream objects

(defun get-pretty-print-stream (stream)
  (let ((xp (without-interrupts (pop *free-xps*))))
    (when (not xp)(setq xp (make-xp-structure)))
    (initialize-xp xp stream)
    (let ((the-xp-stream (make-instance  'xp-stream)))
      (setf (slot-value the-xp-stream 'xp-structure) xp)
      (setf (xp-stream xp) the-xp-stream) ; lets be circular
      the-xp-stream)))

;If you call this, the xp-stream gets efficiently recycled.

(defun free-pretty-print-stream (xp)
  (setf (xp-base-stream xp) nil)
  (pushnew xp *free-xps*))

;This is called to initialize things when you start pretty printing.

(defun initialize-xp (xp stream)
  (setf (xp-base-stream xp) stream)
  (setf (xp-linel xp) (max 0 (cond (*print-right-margin*)
				           ((output-width stream))
				           (T *default-right-margin*))))
  (setf (xp-line-limit xp) *print-lines*)
  (setf (xp-line-no xp) 1)
  (setf (xp-char-mode xp) nil)
  (setf (xp-char-mode-counter xp) 0)
  (setf (xp-depth-in-blocks xp) 0)
  (setf (xp-block-stack-ptr xp) 0)
  (setf (xp-charpos xp) (cond ((output-position stream)) (T 0)))
  (setf (section-start xp) 0)
  (setf (xp-buffer-ptr xp) 0)
  (setf (xp-buffer-offset xp) (xp-charpos xp))
  (setf (xp-qleft xp) 0)
  (setf (xp-qright xp) #.(- queue-entry-size))
  (setf (xp-prefix-stack-ptr xp) #.(- prefix-stack-entry-size))
  (let ((s (xp-string-stream xp)))
    (when s (stream-position s 0)))
  xp)

;The char-mode stuff is a bit tricky.
;one can be in one of the following modes:
;NIL no changes to characters output.
;:UP CHAR-UPCASE used.
;:DOWN CHAR-DOWNCASE used.
;:CAP0 capitalize next alphanumeric letter then switch to :DOWN.
;:CAP1 capitalize next alphanumeric letter then switch to :CAPW
;:CAPW downcase letters.  When a word break letter found, switch to :CAP1.
;It is possible for ~(~) to be nested in a format string, but note that
;each mode specifies what should happen to every letter.  Therefore, inner
;nested modes never have any effect.  You can just ignore them.

(defun push-char-mode (xp new-mode)
  (if (zerop (xp-char-mode-counter xp))
      (setf (xp-char-mode xp) new-mode))
  (incf (xp-char-mode-counter xp)))

(defun pop-char-mode (xp)
  (decf (xp-char-mode-counter xp))
  (if (zerop (xp-char-mode-counter xp))
      (setf (xp-char-mode xp) nil)))

;Assumes is only called when char-mode is non-nil
(defun handle-char-mode (xp char)
  (case (xp-char-mode xp)
    (:CAP0 (cond ((not (alphanumericp char)) char)
		 (T (setf (xp-char-mode xp) :DOWN) (char-upcase char))))
    (:CAP1 (cond ((not (alphanumericp char)) char)
		 (T (setf (xp-char-mode xp) :CAPW) (char-upcase char))))
    (:CAPW (cond ((alphanumericp char) (char-downcase char))
		 (T (setf (xp-char-mode xp) :CAP1) char)))
    (:UP (char-upcase char))
    (T (char-downcase char)))) ;:DOWN

;All characters output are passed through the handler above.  However, it must
;be noted that on-each-line prefixes are only processed in the context of the
;first place they appear.  They stay the same later no matter what.  Also
;non-literal newlines do not count as word breaks.


;This handles the basic outputting of characters.  note + suffix means that
;the stream is known to be an XP stream, all inputs are mandatory, and no
;error checking has to be done.  Suffix ++ additionally means that the
;output is guaranteed not to contain a newline char.

(defun write-char+ (char xp)
  (if (eql char #\newline) (pprint-newline+ :unconditional xp)
      (write-char++ char xp)))

(defun write-string+ (string xp start end)
  (let ((sub-end nil) next-newline)
    (loop (setq next-newline
		(if (typep string 'simple-string)
                  (%str-member #\newline string start end)
                  (position #\newline string :start start :end end :test #'eq )))
	  (setq sub-end (if next-newline next-newline end))
	  (write-string++ string xp start sub-end)
	  (when (null next-newline) (return nil))
	  (pprint-newline+ :unconditional xp)
	  (setq start (%i+ 1 sub-end)))))



;note this checks (> BUFFER-PTR LINEL) instead of (> (LP<-BP) LINEL)
;this is important so that when things are longer than a line they
;end up getting printed in chunks of size LINEL.

(defun write-char++ (char xp)
  (when (> (xp-buffer-ptr xp) (xp-linel xp))
    (force-some-output xp))
  (let ((new-buffer-end (%i+ 1 (xp-buffer-ptr xp))))
    (xp-check-size (xp-buffer xp) new-buffer-end #.buffer-min-size #.buffer-entry-size)
    (if (xp-char-mode xp) (setq char (handle-char-mode xp char)))
    (setf (schar (xp-buffer xp) (xp-buffer-ptr xp)) char)    
    (setf (xp-buffer-ptr xp) new-buffer-end)))


(defun force-some-output (xp)
  (attempt-to-output xp nil nil)
  (when (> (xp-buffer-ptr xp) (xp-linel xp)) ;only if printing off end of line
    (attempt-to-output xp T T)))

(defun write-string++ (string xp start end)
  (when (> (xp-buffer-ptr xp) (xp-linel xp))
    (force-some-output xp))
  (write-string+++ string xp start end))

;never forces output; therefore safe to call from within output-line.

(defun write-string+++ (string xp start end)
  (declare (fixnum start end))
  (let ((new-buffer-end (%i+ (xp-buffer-ptr xp) (- end start))))
    (xp-check-size (xp-buffer xp) new-buffer-end #.buffer-min-size #.buffer-entry-size)
    (do ((buffer (xp-buffer xp))
	 (i (xp-buffer-ptr xp) (1+ i))
	 (j start (1+ j)))
	((= j end))
      (declare (fixnum i j))
      (let ((char (char string j)))
	(if (xp-char-mode xp) (setq char (handle-char-mode xp char)))      
	(setf (schar buffer i) char)))
    (setf (xp-buffer-ptr xp) new-buffer-end)))

(defun pprint-tab+ (kind colnum colinc xp)
  (let ((indented? nil) (relative? nil))
    (declare (fixnum colnum colinc))
    (case kind
      (:section (setq indented? T))
      (:line-relative (setq relative? T))
      (:section-relative (setq indented? T relative? T)))
    (when (or (not indented?)
              (and *print-pretty* *logical-block-p*))
      (let* ((current
              (if (not indented?) (LP<-BP xp)
                  (%i- (TP<-BP xp) (section-start xp))))
             (new
              (if (zerop colinc)
                  (if relative? (+ current colnum) (max colnum current))
                  (cond (relative?
                         (* colinc (floor (+ current colnum colinc -1) colinc)))
                        ((> colnum current) colnum)
                        (T (+ colnum
                              (* colinc
                                 (floor (+ current (- colnum) colinc) colinc)))))))
             (length (- new current)))
        (declare (fixnum current new length))
        (when (plusp length)
          (if (xp-char-mode xp) (handle-char-mode xp #\space))
          (let ((end (%i+ (xp-buffer-ptr xp) length)))
            (xp-check-size (xp-buffer xp) end #.buffer-min-size #.buffer-entry-size)
            (fill (xp-buffer xp) #\space :start (xp-buffer-ptr xp) :end end)
            (setf (xp-buffer-ptr xp) end)))))))

;note following is smallest number >= x that is a multiple of colinc
;  (* colinc (floor (+ x (1- colinc)) colinc))

(defun pprint-newline+ (kind xp)
  (enqueue xp :newline kind)
  (let ((queue (xp-queue xp))
        (qright (xp-qright xp)))
    (declare (fixnum qright))
    (do ((ptr (xp-qleft xp) (Qnext ptr))) ;find sections we are ending
        ((not (< ptr qright)))            ;all but last
      (declare (fixnum ptr))
      (when (and (null (xpq-end queue ptr))
                 (not (%i> (xp-depth-in-blocks xp) (xpq-depth queue ptr)))
                 (memq (xpq-type queue ptr) '(:newline :start-block)))
        (setf (xpq-end queue ptr) (- qright ptr))))
    (setf (section-start xp) (TP<-BP xp))
    (when (and (memq kind '(:fresh :unconditional)) (xp-char-mode xp))
      (handle-char-mode xp #\newline))
    (when (memq kind '(:fresh :unconditional :mandatory))
      (attempt-to-output xp T nil))))

(defun start-block (xp prefix-string on-each-line? suffix-string)
  (macrolet ((push-block-stack (xp)
               `(let ((ptr (%i+ (xp-block-stack-ptr ,xp) #.block-stack-entry-size)))
                  (setf (xp-block-stack-ptr ,xp) ptr)
                  (xp-check-size (xp-block-stack ,xp) ptr
                                 #.block-stack-min-size #.block-stack-entry-size))))
    (let ((length (if prefix-string (length (the string prefix-string)) 0)))        
      (declare (fixnum length))
      (when prefix-string (write-string++ prefix-string xp 0 length))    
      (if (and (xp-char-mode xp) on-each-line?)
        (let ((ptr (xp-buffer-ptr xp)))
          (declare (fixnum ptr))
          (setq prefix-string
	        (%substr (xp-buffer xp) (- ptr length) ptr))))
      (push-block-stack xp)
      (enqueue xp :start-block nil
	       (if on-each-line? (cons suffix-string prefix-string) suffix-string))
      (setf (xp-depth-in-blocks xp)(%i+ 1 (xp-depth-in-blocks xp)))      ;must be after enqueue
      (setf (section-start xp) (TP<-BP xp)))))

(defun end-block (xp suffix)
  (macrolet ((pop-block-stack (xp)
               `(decf (the fixnum (xp-block-stack-ptr ,xp)) #.block-stack-entry-size)))
    ;(unless (eq *abbreviation-happened* '*print-lines*)
      (when suffix (write-string+ suffix xp 0 (length suffix)))
      (decf (xp-depth-in-blocks xp))
      (enqueue xp :end-block nil suffix)
      (let ((queue (xp-queue xp))
            (qright (xp-qright xp)))
        (declare (fixnum qright))
        (do ((ptr (xp-qleft xp) (Qnext ptr))) ;looking for start of block we are ending
	    ((not (< ptr qright)))    ;all but last
          (declare (fixnum ptr))
          (when (and (= (the fixnum (xp-depth-in-blocks xp)) (the fixnum (xpq-depth queue ptr)))
		     (eq (xpq-type queue ptr) :start-block)
		     (null (xpq-offset queue ptr)))
	    (setf (xpq-offset queue ptr) (- qright ptr))
	    (return nil)))	;can only be 1
        (pop-block-stack xp)))) ;)

(defun pprint-indent+ (kind n xp)
  (when (and *print-pretty* *logical-block-p*)
    (enqueue xp :ind kind n)))

; The next function scans the queue looking for things it can do.
;it keeps outputting things until the queue is empty, or it finds
;a place where it cannot make a decision yet.

(eval-when (:compile-toplevel :execute)
(defmacro maybe-too-large (xp Qentry queue linel)
  `(let ((.limit. ,linel)
         (.qend. (xpq-end ,queue ,qentry)))
     (declare (fixnum .limit.))
     (when (eql (xp-line-limit ,xp) (xp-line-no ,xp)) ;prevents suffix overflow
       (decf .limit. 2) ;3 for " .." minus 1 for space (heuristic)
       (when (not (minusp (xp-prefix-stack-ptr ,xp)))
	 (decf .limit. (suffix-ptr ,xp))))
     (cond (.qend.
	    (%i> (LP<-TP ,xp (xpq-pos ,queue (%i+ ,Qentry .qend.))) .limit.))
	   ((or force-newlines? (%i> (LP<-BP ,xp) .limit.)) T)
	   (T (return nil)))))	;wait until later to decide.

(defmacro misering? (xp left)
  `(<= ,left
       (the fixnum (initial-prefix-ptr ,xp))))
) ; eval-when

;If flush-out? is T and force-newlines? is NIL then the buffer,
;prefix-stack, and queue will be in an inconsistent state after the call.
;You better not call it this way except as the last act of outputting.


(defun attempt-to-output (xp force-newlines? flush-out?)
  (macrolet ((pop-prefix-stack (xp)             
             `(decf (the fixnum (xp-prefix-stack-ptr ,xp))
                #.prefix-stack-entry-size)))
  (let* ((width  *print-miser-width*)
         (linel (xp-linel xp))
         (left  (if width (- linel width) most-positive-fixnum)))
    (declare (fixnum linel left))
  (do ((qleft (xp-qleft xp))
       (queue (xp-queue xp)(xp-queue xp)))
      ((%i> qleft (xp-qright xp))
	  (setf (xp-qleft xp) 0)
	  (setf (xp-qright xp) #.(- queue-entry-size))) ;saves shifting
    ; initial-prefix-ptr cant be referenced initially - prefix-stack-ptr is negative
    (case (xpq-type queue qleft)
      (:ind
       (unless (misering? xp left)
	 (set-indentation-prefix xp
	   (case (xpq-kind queue qleft)
	     (:block (%i+ (initial-prefix-ptr xp) (xpq-arg queue qleft)))
	     (T ; :current
	       (%i+ (LP<-TP xp (xpq-pos queue qleft))
		  (xpq-arg queue qleft)))))) )
      (:start-block
       (cond ((maybe-too-large xp qleft queue linel)
	      (push-prefix-stack xp)
	      (setf (initial-prefix-ptr xp) (prefix-ptr xp))
	      (set-indentation-prefix xp (LP<-TP xp (xpq-pos queue qleft)))
	      (let ((arg (xpq-arg queue qleft)))
		(when (consp arg) (set-prefix xp (cdr arg)))
		(setf (initial-prefix-ptr xp) (prefix-ptr xp))
		(cond ((not (listp arg)) (set-suffix xp arg))
		      ((car arg) (set-suffix xp (car arg)))))
	      (setf (section-start-line xp) (xp-line-no xp)))
	     (T (setq qleft (%i+ qleft (xpq-offset queue qleft))))) )
      (:end-block (pop-prefix-stack xp))
      (T ; :newline
       (when (case (xpq-kind queue qleft)
	       (:fresh (not (%izerop (LP<-BP xp))))
	       (:miser (misering? xp left))
	       (:fill (or (misering? xp left)
			  (%i> (xp-line-no xp) (section-start-line xp))
			  (maybe-too-large xp qleft queue linel)))
	       (T T)) ;(:linear :unconditional :mandatory) 
	 (output-line-and-setup-for-next xp qleft))))
    (setf (xp-qleft xp) (setq qleft (qnext qleft))))
  (when flush-out? (flush xp)))))


(defun flush (xp)
  (let ((ostream (xp-out-stream xp))
        (len (xp-buffer-ptr xp)))
    (when (and *print-pprint-dispatch* (commit-hook *print-pprint-dispatch*))
      (funcall (commit-hook *print-pprint-dispatch*) xp len 0))
    (when ostream      
      (write-string (xp-buffer xp) ostream :start 0 :end len))
    (incf (xp-buffer-offset xp) len)
    (incf (xp-charpos xp) len)
    (setf (xp-buffer-ptr xp) 0)))


(defun xp-out-stream (xp)
  (let ((lc *locating-circularities*))
    (cond 
     ((null lc)
      (xp-base-stream xp))
     ((= lc 0)
      (if  (null (xp-string-stream xp))
        (setf (xp-string-stream xp) (make-string-output-stream))
        (xp-string-stream xp))))))
  

;This prints out a line of stuff.

(defun output-line-and-setup-for-next (xp Qentry)
  (let* ((queue (xp-queue xp))
         (out-point (BP<-TP xp (xpq-pos queue Qentry)))
         (unconditional-p (memq (xpq-kind queue Qentry) '(:fresh :unconditional)))
         (end (if unconditional-p
                out-point
                (let ((buffer (xp-buffer xp)))
                  (declare (type simple-base-string buffer))
                  (do ((i (%i- out-point 1) (%i- i 1)))
                      ((%i< i 0) 0)
                    (when (or (neq (schar buffer i) #\Space)
                              ;; Don't match possibly-quoted space ("possibly" because the #\\ itself might be 
                              ;; quoted; don't bother checking for that, no big harm leaving the space even if
                              ;; not totally necessary).
                              (and (%i< 0 i) (eq (schar buffer (%i- i 1)) #\\)))
                      (return (%i+ i 1)))))))
         (prefix-end
          (if unconditional-p (non-blank-prefix-ptr xp) (prefix-ptr xp)))
         (old-ptr (xp-buffer-ptr xp))
         (new-ptr (%i+ old-ptr (%i- prefix-end out-point)))
         (line-limit-exit (and (xp-line-limit xp) (not (%i> (xp-line-limit xp) (xp-line-no xp))))))
    (when line-limit-exit
      (setf (xp-buffer-ptr xp) end)          ;truncate pending output.
      (write-string+++ " .." xp 0 3)
      (reverse-string-in-place (xp-suffix xp) 0 (suffix-ptr xp))
      (write-string+++ (xp-suffix xp) xp 0 (suffix-ptr xp))
      (setf (xp-qleft xp) (qnext (xp-qright xp)))
      ;(setq *abbreviation-happened* '*print-lines*)
      (throw 'line-limit-abbreviation-exit T))
    (setf (xp-line-no xp)(%i+ 1 (xp-line-no xp)))
    (when (and *print-pprint-dispatch* (commit-hook *print-pprint-dispatch*))
      (funcall (commit-hook *print-pprint-dispatch*) xp out-point prefix-end))
    (let ((bstream (xp-out-stream xp)))
      (when bstream
        (write-string (xp-buffer xp) bstream :start 0 :end end)
        (stream-write-char bstream #\newline)))
    (setf (xp-charpos xp) 0)
    (when (%i> new-ptr old-ptr)                  ;almost never happens
      (xp-check-size (xp-buffer xp) new-ptr #.buffer-min-size #.buffer-entry-size))
    (setf (xp-buffer-ptr xp) new-ptr)
    (decf (xp-buffer-offset xp) (- prefix-end out-point))
    (let ((buffer (xp-buffer xp)))
      (replace buffer buffer :start1 prefix-end :start2 out-point :end2 old-ptr)
      (replace buffer (xp-prefix xp) :end2 prefix-end)
      (unless unconditional-p
        (setf (section-start-line xp) (xp-line-no xp))))))



(defun set-indentation-prefix (xp new-position)
  (let ((new-ind (max (non-blank-prefix-ptr xp) new-position)))
    (declare (fixnum new-ind))
    (setf (prefix-ptr xp) (initial-prefix-ptr xp))
    (xp-check-size (xp-prefix xp) new-ind #.prefix-min-size #.prefix-entry-size)
    (when (%i> new-ind (prefix-ptr xp))
      (fill (xp-prefix xp) #\space :start (prefix-ptr xp) :end new-ind))
    (setf (prefix-ptr xp) new-ind)))

(defun set-prefix (xp prefix-string)
  (declare (string prefix-string))
  (replace (xp-prefix xp) prefix-string
	   :start1 (%i- (prefix-ptr xp) (length prefix-string)))
  (setf (non-blank-prefix-ptr xp) (prefix-ptr xp)))

(defun set-suffix (xp suffix-string)
  (declare (string suffix-string))
  (let* ((end (length suffix-string))
	 (new-end (%i+ (suffix-ptr xp) end)))
    (declare (fixnum end new-end))
    (xp-check-size (xp-suffix xp) new-end #.suffix-min-size #.suffix-entry-size)
    (do ((i (1- new-end) (1- i)) (j 0 (1+ j))) ((= j end))
      (declare (fixnum i j))
      (setf (char (xp-suffix xp) i) (char suffix-string j)))
    (setf (suffix-ptr xp) new-end)))

(defun reverse-string-in-place (string start end)
  (declare (fixnum start end))
  (do ((i start (1+ i)) (j (1- end) (1- j))) ((not (< i j)) string)
    (declare (fixnum i j))
    (let ((c (schar string i)))
      (setf (schar string i) (schar string j))
      (setf (schar string j) c))))

;		   ---- BASIC INTERFACE FUNCTIONS ----

;The internal functions in this file, and the (formatter "...") expansions
;use the '+' forms of these functions directly (which is faster) because,
;they do not need error checking of fancy stream coercion.  The '++' forms
;additionally assume the thing being output does not contain a newline.

(defun maybe-initiate-xp-printing (fn stream &rest args)
  (if (xp-structure-p stream) (apply fn stream args)
    (if (typep stream 'xp-stream)
      (apply fn (slot-value stream 'xp-structure) args)
      (let ((*locating-circularities* (if *print-circle* 0 nil))
            (*circularity-hash-table*
             (if *print-circle* (get-circularity-hash-table) nil)))
        (prog1 (xp-print fn (decode-stream-arg stream) args)
          (if *circularity-hash-table*
            (free-circularity-hash-table *circularity-hash-table*)))))))

(defun xp-print (fn stream args)
  (flet ((do-it (fn stream args)
           (prog1 (do-xp-printing fn stream args)
             (when *locating-circularities*
               (setq *locating-circularities* nil)
               (do-xp-printing fn stream args)))))
    (cond (*print-readably*
           (let* ((*print-level* nil)
                  (*print-length* nil)
                  (*print-lines* nil)
                  (*print-escape* t)
                  (*print-gensym* t)
                  (*print-array* nil))
             (do-it fn stream args)))
          (t (do-it fn stream args)))))

(defun decode-stream-arg (stream)
  (cond ((eq stream T) *terminal-io*)
	((null stream) *standard-output*)
	(T stream)))

(defun do-xp-printing (fn stream args)
  (let ((xp (slot-value (get-pretty-print-stream stream) 'xp-structure))
	(*current-level* 0)
        (*xp-current-object* nil)
	(result nil))
    (declare (special *foo-string*))
    (catch 'line-limit-abbreviation-exit
      (start-block xp nil nil nil)
      (setq result (apply fn xp args))
      (end-block xp nil))
    (when (and *locating-circularities*
	       (zerop *locating-circularities*)	;No circularities.
               ;(= (xp-line-no xp) 1)	     	;Didn't suppress line.
	       ;(zerop (xp-buffer-offset xp))
               )	;Didn't suppress partial line.
      (setq *locating-circularities* nil)
      (let ((s (xp-string-stream xp)))
        (when s
          (stream-write-entire-string (xp-base-stream xp)
                                      (get-output-stream-string s)))))
    (when (catch 'line-limit-abbreviation-exit
	    (attempt-to-output xp nil T)
            nil)
      (attempt-to-output xp T T))
    (free-pretty-print-stream xp)
    result))



(defun write+ (object xp &optional interior-cdr circle)
  (let ((pretty *print-pretty*)) ;((*parents* *parents*))
    (when (or circle
              (not (and *circularity-hash-table*
		        (eq (setq circle (circularity-process xp object interior-cdr)) :subsequent))))
      (when *circularity-hash-table*
        (setq *xp-current-object* object))	
      (let ((printer (if pretty (get-printer object *print-pprint-dispatch*) nil))
	    #|type|#)
	(cond (printer
	       (funcall printer xp object))
	      ((and pretty (maybe-print-fast xp object)))
              (t (write-not-pretty xp object
                                   (if *print-level*
                                     (- *print-level* *current-level*)
                                     most-positive-fixnum)
                                   interior-cdr circle)))))))

;It is vital that this function be called EXACTLY once for each occurrence of 
;  each thing in something being printed.
;Returns nil if printing should just continue on.
;  Either it is not a duplicate, or we are in the first pass and do not know.
;returns :FIRST if object is first occurrence of a DUPLICATE.
;  (This can only be returned on a second pass.)
;  After an initial code (printed by this routine on the second pass)
;  printing should continue on for the object.
;returns :SUBSEQUENT if second or later occurrence.
;  Printing is all taken care of by this routine.

;Note many (maybe most) lisp implementations have characters and small numbers
;represented in a single word so that the are always eq when they are equal and the
;reader takes care of properly sharing them (just as it does with symbols).
;Therefore, we do not want circularity processing applied to them.  However,
;some kinds of numbers (e.g., bignums) undoubtedly are complex structures that
;the reader does not share.  However, they cannot have circular pointers in them
;and it is therefore probably a waste to do circularity checking on them.  In
;any case, it is not clear that it easy to tell exactly what kinds of numbers a
;given implementation of CL is going to have the reader automatically share.

; if not pretty print a space before dot

(defun circularity-process (xp object interior-cdr? &aux (not-pretty (not *print-pretty*)))
  (declare (ftype function invalid-hash-key-p))
  (unless (or (numberp object)
	      (characterp object)
              (invalid-hash-key-p object)
	      (and (symbolp object)	;Reader takes care of sharing.
		   (or (null *print-gensym*) (symbol-package object))))
    (let ((id (gethash object *circularity-hash-table*)))
      (if (and *locating-circularities* *print-circle*) ; << was *locating-circularities*
        (progn ;(push (list object id info-p) barf)
          (cond ((null id)	;never seen before
                 ;(when *parents* (push object *parents*))
                 (setf (gethash object *circularity-hash-table*) 0)
                 nil)
                ((zerop id) ;possible second occurrence
                 (setf (gethash object *circularity-hash-table*)
                       (incf *locating-circularities*))
                 :subsequent)
                (T :subsequent)));third or later occurrence
        (progn ;(push (list object id info-p interior-cdr?) barf2)          
          (cond 
           ((or (null id)	;never seen before (note ~@* etc. conses)
                (zerop id));no duplicates
            nil)
           (t (when interior-cdr?
                (write-string++ (if not-pretty " . #" ". #")
                                            xp 0
                                            (if not-pretty 4 3)))
              (cond ((plusp id)
                     (cond (interior-cdr?
                            (decf *current-level*))
                           (T (write-char++ #\# xp)))
                     (print-fixnum xp id)
                     (write-char++ #\= xp)
                     (setf (gethash object *circularity-hash-table*) (- id))
                     :first)
                    (T (when (not interior-cdr?) (write-char++ #\# xp))
                       (print-fixnum xp (- id))
                       (write-char++ #\# xp)
                       :subsequent)))))))))

;This prints a few very common, simple atoms very fast.
;Pragmatically, this turns out to be an enormous savings over going to the
;standard printer all the time.  There would be diminishing returns from making
;this work with more things, but might be worth it.
; does this really win?

(defun maybe-print-fast (xp object)
  (cond ((stringp object)
	 (cond ((null *print-escape*) (write-string+ object xp 0 (length object)) T)
	       ((every #'(lambda (c) (not (or (eq c #\") (eq c #\\))))
		       object)
		(write-char++ #\" xp)
		(write-string+ object xp 0 (length object))
		(write-char++ #\" xp) T)))
	((typep object 'fixnum)
	 (when (and (null *print-radix*) (= *print-base* 10.))
	   (when (minusp object)
	     (write-char++ #\- xp)
	     (setq object (- object)))
	   (print-fixnum xp object) T))
	((symbolp object)
         (if (> *print-base* 10) ; may need to escape potential numbers
           (write-a-symbol object (xp-stream xp))
           (let ((s (symbol-name object))
                 (p (symbol-package object))
                 (is-key (keywordp object))
                 (mode (case *print-case*
                         (:downcase :down)
                         (:capitalize :cap1)
                         (T nil)))) ; note no-escapes-needed requires all caps
             (declare (string s))
             (cond ((and (or is-key (eq p *package*)
                             (and  ;*package* ;can be NIL on symbolics
                              (multiple-value-bind (symbol type) (find-symbol s)
                                (and type (eq object symbol)))))
                         (eq (readtable-case *readtable*) :upcase)
                         (neq *print-case* :studly)
                         (no-escapes-needed s))
                    (when (and is-key *print-escape*)
                      (write-char++ #\: xp))
                    (if mode (push-char-mode xp mode))
                    (write-string++ s xp 0 (length s))
                    (if mode (pop-char-mode xp)) T)))))))
         
(defun print-fixnum (xp fixnum)
  (multiple-value-bind (digits d)
      (truncate fixnum 10)
    (unless (zerop digits)
      (print-fixnum xp digits))
    (write-char++ (code-char (+ #.(char-code #\0) d)) xp)))

;just wants to succeed fast in a lot of common cases.
;assumes no funny readtable junk for the characters shown.

(defun no-escapes-needed (s)
  (declare (string s))
  (let ((n (length s)))
    (declare (fixnum n))
    (and (not (zerop n))
	 (let ((c (schar s 0)))
	   (or (and (alpha-char-p c) (upper-case-p c)) (%str-member c "*<>")))
	 (do ((i 1 (1+ i))) ((= i n) T)
           (declare (fixnum i))
	   (let ((c (schar s i)))
	     (if (not (or (digit-char-p c)
                          (and (alpha-char-p c) (upper-case-p c))
			  (%str-member c "*+<>-")))
		 (return nil)))))))


(without-duplicate-definition-warnings  ;; override l1-io version.
 (defun pprint (object &optional (stream *standard-output*))
   "Prettily output OBJECT preceded by a newline."
   (setq stream (decode-stream-arg stream))
   (terpri stream)
   (let ((*print-escape* T) (*print-pretty* T))
     (write-1 object stream))
   (values)))


;Any format string that is converted to a function is always printed
;via an XP stream (See formatter).

(defvar *format-string-cache* nil)

(defun process-format-string (string-or-fn force-fn?)
  (declare (ignore force-fn?))
  string-or-fn)


;Each of these causes the stream to be pessimistic and insert
;newlines wherever it might have to, when forcing the partial output
;out.  This is so that things will be in a consistent state if
;output continues to the stream later.

(defmethod stream-force-output ((xp xp-structure))
  (attempt-to-output xp t t))

(defmethod stream-finish-output ((xp xp-structure))
  (attempt-to-output xp t t))

(defun pprint-recording-positions (form stream recorder)
  ;; The hair here comes from the fact that the pretty printer backtracks to insert newlines.
  (let* ((old-table *print-pprint-dispatch*)
         (rec-pending nil)
         (record (require-type recorder 'function)))
    (flet ((rec-pprint (xp object)
             #+gz (assert (or (null rec-pending)
                              (<= (caar rec-pending) (xp-buffer-ptr xp))))
             (let ((real-printer (get-printer object old-table)))
               (when real-printer
                 (push (list* (xp-buffer-ptr xp) t object) rec-pending)
                 (funcall real-printer xp object)
                 (push (list* (xp-buffer-ptr xp) nil object) rec-pending))))
           (rec-commit (xp commited inserted)
             (loop with change = (- inserted commited)
               as last = nil then pending
               as pending = rec-pending then (cdr pending) while pending
               do (when (<= (caar pending) commited) ;; commit the rest.
                    (if last
                      (setf (cdr last) nil)
                      (setf rec-pending nil))
                    (loop with start = (stream-position (xp-out-stream xp))
                      for (offset open-p . object) in (nreverse pending)
                      do (funcall record object open-p (+ start offset)))
                    (return nil))
               do (incf (caar pending) change))))
      (let* ((*print-pretty* t)
             (*print-circle* nil)
             (*print-length* nil)
             (*print-level* nil)
             (*print-lines* nil)
             (*print-miser-width* nil)
             (*read-suppress* nil)
             (*print-pprint-dispatch* (make-pprint-dispatch-table :commit-hook #'rec-commit)))
        (set-pprint-dispatch 'cons #'rec-pprint)
        (write-1 form stream)
        #+gz (assert (null rec-pending))))
    form))



;           ---- FUNCTIONAL INTERFACE TO DYNAMIC FORMATTING ----

;The internal functions in this file, and the (formatter "...") expansions
;use the '+' forms of these functions directly (which is faster) because,
;they do not need error checking or fancy stream coercion.  The '++' forms
;additionally assume the thing being output does not contain a newline.


(defun pprint-newline (kind &optional (stream *standard-output*))
    "Output a conditional newline to STREAM (which defaults to
   *STANDARD-OUTPUT*) if it is a pretty-printing stream, and do
   nothing if not. KIND can be one of:
     :LINEAR - A line break is inserted if and only if the immediatly
        containing section cannot be printed on one line.
     :MISER - Same as LINEAR, but only if ``miser-style'' is in effect.
        (See *PRINT-MISER-WIDTH*.)
     :FILL - A line break is inserted if and only if either:
       (a) the following section cannot be printed on the end of the
           current line,
       (b) the preceding section was not printed on a single line, or
       (c) the immediately containing section cannot be printed on one
           line and miser-style is in effect.
     :MANDATORY - A line break is always inserted.
   When a line break is inserted by any type of conditional newline, any
   blanks that immediately precede the conditional newline are ommitted
   from the output and indentation is introduced at the beginning of the
   next line. (See PPRINT-INDENT.)"
    (when (not (memq kind '(:linear :miser :fill :mandatory)))
      (signal-type-error kind '(member :linear :miser :fill :mandatory) 
                         "Invalid KIND argument ~A to PPRINT-NEWLINE"))
    (when (and *print-pretty* *logical-block-p*)    
      (setq stream (decode-stream-arg stream))
      (cond ((xp-structure-p stream)
             (pprint-newline+ kind stream))
            ((typep stream 'xp-stream)
             (pprint-newline+ kind (slot-value stream 'xp-structure)))
            (t (pp-newline stream kind))))
    nil)

(defun pprint-indent (relative-to n &optional (stream *standard-output*))
  "Specify the indentation to use in the current logical block if STREAM
   (which defaults to *STANDARD-OUTPUT*) is it is a pretty-printing stream
   and do nothing if not. (See PPRINT-LOGICAL-BLOCK.)  N is the indentation
   to use (in ems, the width of an ``m'') and RELATIVE-TO can be either:
     :BLOCK - Indent relative to the column the current logical block
        started on.
     :CURRENT - Indent relative to the current column.
   The new indentation value does not take effect until the following line
   break."
  (setq stream (decode-stream-arg stream))
  (when (not (memq relative-to '(:block :current)))
    (error "Invalid KIND argument ~A to PPRINT-INDENT" relative-to))
  (cond ((xp-structure-p stream)
         (pprint-indent+ relative-to (truncate n) stream))
        ((typep stream 'xp-stream)
         (pprint-indent+ relative-to (truncate n) (slot-value stream 'xp-structure)))
        (t nil)) ; ???(break)))
  nil)

(defun pprint-tab (kind colnum colinc &optional (stream *standard-output*))
  "If STREAM (which defaults to *STANDARD-OUTPUT*) is a pretty-printing
   stream, perform tabbing based on KIND, otherwise do nothing. KIND can
   be one of:
     :LINE - Tab to column COLNUM. If already past COLNUM tab to the next
       multiple of COLINC.
     :SECTION - Same as :LINE, but count from the start of the current
       section, not the start of the line.
     :LINE-RELATIVE - Output COLNUM spaces, then tab to the next multiple of
       COLINC.
     :SECTION-RELATIVE - Same as :LINE-RELATIVE, but count from the start
       of the current section, not the start of the line."
  (setq stream (decode-stream-arg stream))
  (when (not (memq kind '(:line :section :line-relative :section-relative)))
    (error "Invalid KIND argument ~A to PPRINT-TAB" kind))

  (when (and *print-pretty* *logical-block-p*)
    (cond ((xp-structure-p stream)
           (pprint-tab+ kind colnum colinc stream))
          ((typep stream 'xp-stream)
           (pprint-tab+ kind colnum colinc (slot-value stream 'xp-structure)))))
  nil)

;                        ---- COMPILED FORMAT ----

;Note that compiled format strings always print through xp streams even if
;they don't have any xp directives in them.  As a result, the compiled code
;can depend on the fact that the stream being operated on is an xp
;stream not an ordinary one.


(eval-when (:compile-toplevel :load-toplevel :execute)
; called by formatter frobs
(defun do-sub-format-0 (s control-string args)
    (setq s (if (xp-structure-p s)(xp-stream s)
              (if (output-stream-p s)
                s
                (require-type s '(satisfies output-stream-p)))))
                
    (let ((*format-control-string* control-string)
          (*format-top-level* t))      
      (cond ((and (or *print-pretty* *print-circle*)
                  (not (typep s 'xp-stream)))
             (maybe-initiate-xp-printing
              #'do-sub-format-1 s args))
            (t (do-sub-format-1 s args)))))

; called from above, format, and logical-block-sub
(defun do-sub-format-1 (stream args)
  (let ((*format-original-arguments* args)
        (*format-arguments* args)
        (*format-colon-rest* 'error))
    (declare (special *format-colon-rest*))
    (if (xp-structure-p stream)(setq stream (xp-stream stream)))
    (do-sub-format stream)
    ; copylist cause args is dynamic extent in format & formatter
    ; n.b. when printing lisp code its nearly always nil
    (setq args *format-arguments*)
    (if (and (consp args) *format-top-level*)(copy-list args) args)))

(defmacro formatter (control-string) ; maybe-initiate-xp-printing?
  (setq control-string (require-type control-string 'string))
  `(function 
    (lambda (s &rest args)
      ; IFFY because things can end up in the same place on the stack
      ; appearing EQ giving bogus circularity detection
      ; But now we have fixed things so we don't circle check rest args (ha!)
      (do-sub-format-0 s ,control-string args))))

(defmacro pprint-pop+ (args xp)
  `(if (pprint-pop-check+ ,args ,xp)
       (return-from logical-block nil)
       (pop ,args)))

(defun pprint-pop-check+ (args xp)
  (let ((current-length *current-length*))
    (declare (fixnum current-length))
    (setq current-length (setq *current-length* (1+ *current-length*)))
    (cond ((not (listp args))  ;must be first so supersedes length abbrev
	   (write-string++ ". " xp 0 2)
	   (write+ args xp)
	   T)
	  ((and *print-length* ;must supersede circle check
	        (not (< current-length *print-length*)))
	   (write-string++ "..." xp 0 3)
	   ;(setq *abbreviation-happened* T)
	   T)
	  ((and *circularity-hash-table* (not *format-top-level*)
                (not (zerop current-length)))
           (let ((circle (circularity-process xp args T)))
	     (case circle
	       (:first ;; note must inhibit rechecking of circularity for args.
                (write+ args xp T circle)
                T)
	       (:subsequent T)
	       (T nil)))))))

(defun check-block-abbreviation (xp args circle-check?)
  (cond ((not (listp args)) (write+ args xp) T)
	((and *print-level* (> *current-level* *print-level*))
	 (write-char++ #\# XP) 
         ;(setq *abbreviation-happened* T)
         T)
	((and *circularity-hash-table* circle-check? (neq args *xp-current-object*)
	      (eq (circularity-process xp args nil) :subsequent))
         T)
	(T nil)))


)


;                ---- PRETTY PRINTING FORMATS ----

(defun pretty-array (xp array)
  (when (typep xp 'xp-stream)(setq xp (slot-value xp 'xp-structure)))
  (cond ((vectorp array) (pretty-vector xp array))
	((zerop (array-rank array))
	 (write-string++ "#0A" xp 0 3)
	 (write+ (aref array) xp))
	(T (pretty-non-vector xp array))))

(defun pretty-vector (xp v)
  (pprint-logical-block (xp nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (declare (fixnum end i))
      (when (plusp end)
	(loop (pprint-pop)   ;HUH
	      (write+ (aref v i) xp)
	      (if (= (incf i) end) (return nil))
	      (write-char++ #\space xp)
	      (pprint-newline+ :fill xp))))))

(defun pretty-non-vector (xp array)
  (let* ((bottom (1- (array-rank array)))
	 (indices (make-list (1+ bottom) :initial-element 0))
	 (dims (array-dimensions array)))
    (funcall (formatter "#~DA") xp (1+ bottom))
    (labels ((pretty-slice (slice)
	       (pprint-logical-block (xp nil :prefix "(" :suffix ")")
		 (let ((end (nth slice dims))
		       (spot (nthcdr slice indices))
		       (i 0))
		   (when (plusp end)
		     (loop (pprint-pop)
			   (setf (car spot) i)
			   (if (= slice bottom)
			       (write+ (apply #'aref array indices) xp)
			       (pretty-slice (1+ slice)))
			   (if (= (incf i) end) (return nil))
			   (write-char++ #\space xp)
			   (pprint-newline+ (if (= slice bottom) :fill :linear) xp)))))))
      (pretty-slice 0))))

(defun pretty-structure (xp struc &aux (class (struct-def struc)) (slots (sd-slots class)))
  (when (typep xp 'xp-stream)(setq xp (slot-value xp 'xp-structure)))
  (let* ((class (ccl::struct-def struc)) ;;guaranteed non-NIL if this function is called
         (pf (structure-print-function class)))
    (cond 
     (pf
      (if (consp pf)
        (funcall (car pf) struc (xp-stream xp))
	(funcall pf struc (xp-stream xp) *current-level*)))
     (t 
      (pprint-logical-block (xp nil :prefix "#S(" :suffix ")")
        (pprint-pop)
        (write+ (sd-name class) xp)
        (start-block xp (if (cdr slots) " " "") nil "")
        (when slots
          (let ((pcase *print-case*))
            (loop 
              (let* ((slot (pop slots))(name (ssd-name slot)))
                (cond
                 ((symbolp name)
                  (pprint-pop)
                  (write-char++ #\: xp)
                  (write-pname (symbol-name name) pcase xp)
                  (write-char++ #\space xp)
                  (pprint-pop)
                  (write+ (uvref struc (ssd-offset slot)) xp)              
                  (when (null slots)(return nil))
                  (write-char++ #\space xp)
                  (pprint-newline+ :fill xp))
                 ((null slots)(return nil)))))))
        (end-block xp ""))))))



;Must use pprint-logical-block (no +) in the following three, because they are
;exported functions.

(defun pprint-linear (s list &optional (colon? T) atsign?)
  "Output LIST to STREAM putting :LINEAR conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-LINEAR
   can be used with the ~/.../ format directive."
  (declare (ignore atsign?))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (write-char++ #\space s)
	  (pprint-newline+ :linear s))))

(defun pprint-fill (s list &optional (colon? T) atsign?)
  "Output LIST to STREAM putting :FILL conditional newlines between each
   element. If COLON? is NIL (defaults to T), then no parens are printed
   around the output. ATSIGN? is ignored (but allowed so that PPRINT-FILL
   can be used with the ~/.../ format directive."
  (declare (ignore atsign?))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (write-char++ #\space s)
	  (pprint-newline+ :fill s))))

(defun pprint-tabular (s list &optional (colon? T) atsign? (tabsize nil))
  "Output LIST to STREAM tabbing to the next column that is an even multiple
   of TABSIZE (which defaults to 16) between each element. :FILL style
   conditional newlines are also output between each element. If COLON? is
   NIL (defaults to T), then no parens are printed around the output.
   ATSIGN? is ignored (but allowed so that PPRINT-TABULAR can be used with
   the ~/.../ format directive."
  (declare (ignore atsign?))
  (when (null tabsize) (setq tabsize 16))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))    
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (write-char++ #\space s)
	  (pprint-tab+ :section-relative 0 tabsize s)
	  (pprint-newline+ :fill s))))

; perhaps should use alternate-fn-call instead
(defun fn-call (xp list)
  (funcall (formatter "~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>") xp list))

;Although idiosyncratic, I have found this very useful to avoid large
;indentations when printing out code.

(defun alternative-fn-call (xp list)
  (if (> (length (symbol-name (car list))) 12)
      (funcall (formatter "~:<~1I~@{~W~^ ~_~}~:>") xp list)
      (funcall (formatter "~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>") xp list)))

(defun bind-list (xp list &rest args)
  (declare (ignore args))
  (if (do ((i 50 (1- i))
	   (ls list (cdr ls))) ((null ls) t)
	(when (or (not (consp ls)) (not (symbolp (car ls))) (minusp i))
	  (return nil)))
      (pprint-fill xp list)
      (funcall (formatter "~:<~@{~:/pprint-fill/~^ ~_~}~:>") xp list)))

(defun block-like (xp list &rest args)
    (declare (ignore args))
  (funcall (formatter "~:<~1I~^~W~^ ~@_~W~^~@{ ~_~W~^~}~:>") xp list))

(defun defun-like (xp list &rest args)
    (declare (ignore args))
  (funcall (formatter "~:<~1I~W~^ ~@_~W~^ ~@_~:/pprint-fill/~^~@{ ~_~W~^~}~:>")
	    xp list))

(defun defvar-like (xp list &rest args)
    (declare (ignore args))
  (funcall (formatter "~:<~1I~W~^ ~@_~W~^ ~@_~W~^~@{ ~_~W~^~}~:>")
	    xp list))

(defun print-fancy-fn-call (xp list template)
  (let ((i 0) (in-first-section T))
    (declare (fixnum i))
    (pprint-logical-block+ (xp list "(" ")" nil T nil)
      (write+ (pprint-pop) xp)
      (pprint-indent+ :current 1 xp)
      (loop
	(pprint-exit-if-list-exhausted)
	(write-char++ #\space xp)
	(when (eq i (car template))
	  (pprint-indent+ :block (cadr template) xp)
	  (setq template (cddr template))
	  (setq in-first-section nil))
	(pprint-newline (cond ((and (zerop i) in-first-section) :miser)
			      (in-first-section :fill)
			      (T :linear))
			xp)
	(write+ (pprint-pop) xp)
	(incf i)))))

(defun defmethod-like (xp list &rest args)
  (declare (ignore args))
  (cond ((and (consp (cdr list))(consp (cddr list))(listp (caddr list)))
         (defun-like xp list))
        (t (defsetf-print xp list))))


(defun maybelab (xp item &rest args)
    (declare (ignore args) (special need-newline indentation))
  (when (typep xp 'xp-stream)(setq xp (slot-value xp 'xp-structure)))
  (when need-newline (pprint-newline+ :mandatory xp))
  (cond ((and item (symbolp item))
	 (write+ item xp)
	 (setq need-newline nil))
	(T (pprint-tab+ :section indentation 0 xp)
	   (write+ item xp)
	   (setq need-newline T))))

(defun function-call-p (x)
  (and (consp x) (symbolp (car x)) (fboundp (car x))))



;THE FOLLOWING STUFF SETS UP THE DEFAULT *PRINT-PPRINT-DISPATCH*
 
;This is an attempt to specify a correct format for every form in the CL book
;that does not just get printed out like an ordinary function call 
;(i.e., most special forms and many macros).  This of course does not 
;cover anything new you define.

(defun let-print (xp obj)
  (funcall (formatter "~:<~1I~W~^ ~@_~/ccl::bind-list/~^~@{ ~_~W~^~}~:>") xp obj))

(defun cond-print (xp obj)
  (funcall (formatter "~:<~W~^ ~:I~@_~@{~:/pprint-linear/~^ ~_~}~:>") xp obj))

(defun dmm-print (xp list)
  (print-fancy-fn-call xp list '(3 1)))

(defun defsetf-print (xp list)
  (print-fancy-fn-call xp list '(3 1)))

(defun do-print (xp obj)
  (funcall 
 (formatter "~:<~W~^ ~:I~@_~/ccl::bind-list/~^ ~_~:/pprint-linear/ ~1I~^~@{ ~_~W~^~}~:>")
           xp obj))


(defun flet-print (xp obj)
  (funcall (formatter "~:<~1I~W~^ ~@_~:<~@{~/ccl::block-like/~^ ~_~}~:>~^~@{ ~_~W~^~}~:>")
	   xp obj))

(defun function-print (xp list)
  (if (and *print-abbreviate-quote* (consp (cdr list)) (null (cddr list)))
      (format (xp-stream xp) "#'~W" (cadr list))
      (fn-call xp list)))

(defun mvb-print (xp list)
  (print-fancy-fn-call xp list '(1 3 2 1)))

(defun prog-print (xp list)
  (let ((need-newline T) (indentation (1+ (length (symbol-name (car list)))))) ; less?
    (declare (special need-newline indentation))
    (funcall (formatter "~:<~W~^ ~:/pprint-fill/~^ ~@{~/ccl::maybelab/~^ ~}~:>")
	     xp list)))


(defun progn-print (xp list)
  (funcall (formatter "~:<~1I~@{~W~^ ~_~}~:>") xp list))

(defun setq-print (xp obj)
  (funcall (formatter "~:<~W~^ ~:I~@_~@{~W~^ ~:_~W~^ ~_~}~:>") xp obj))

(defun quote-print (xp list)
  (if (and (consp (cdr list)) (null (cddr list)))
      (format (xp-stream xp) "'~W" (cadr list))
      (pprint-fill xp list)))

(defun tagbody-print (xp list)
  (let ((need-newline (and (consp (cdr list))
			   (symbolp (cadr list)) (cadr list)))
	(indentation (1+ (length (symbol-name (car list))))))
    (declare (special need-newline indentation))
    (funcall (formatter "~:<~W~^ ~@{~/ccl::maybelab/~^ ~}~:>") xp list)))

(defun up-print (xp list)
  (print-fancy-fn-call xp list '(0 3 1 1)))

;here is some simple stuff for printing LOOP

;The challange here is that we have to effectively parse the clauses of the
;loop in order to know how to print things.  Also you want to do this in a 
;purely incremental way so that all of the abbreviation things work, and
;you wont blow up on circular lists or the like.  (More aesthic output could
;be produced by really parsing the clauses into nested lists before printing them.)

;The following program assumes the following simplified grammar of the loop
;clauses that explains how to print them.  Note that it does not bare much
;resemblence to the right parsing grammar, however, it produces half decent
;output.  The way to make the output better is to make the grammar more
;detailed.  
;
;loop == (LOOP {clause}*)      ;one clause on each line.
;clause == block | linear | cond | finally
;block == block-head {expr}*   ;as many exprs as possible on each line.
;linear == linear-head {expr}* ;one expr on each line.
;finally == FINALLY [DO | DOING | RETURN] {expr}* ;one expr on each line.
;cond == cond-head [expr]
;          clause
;	   {AND clause}*       ;one AND on each line.
;        [ELSE
;          clause
;	   {AND clause}*]      ;one AND on each line.
;        [END]
;block-head == FOR | AS | WITH | AND
;              | REPEAT | NAMED | WHILE | UNTIL | ALWAYS | NEVER | THEREIS | RETURN
;              | COLLECT | COLLECTING | APPEND | APPENDING | NCONC | NCONCING | COUNT
;              | COUNTING | SUM | SUMMING | MAXIMIZE | MAXIMIZING | MINIMIZE | MINIMIZING 
;linear-head == DO | DOING | INITIALLY
;var-head == FOR | AS | WITH
;cond-head == IF | WHEN | UNLESS
;expr == <anything that is not a head symbol>

;Note all the string comparisons below are required to support some
;existing implementations of LOOP.
(defun token-type (token &aux string)
  (cond ((not (symbolp token)) :expr)
	((string= (setq string (string token)) "FINALLY") :finally)
	((member string '("IF" "WHEN" "UNLESS") :test #'string=) :cond-head)
	((member string '("DO" "DOING" "INITIALLY") :test #'string=) :linear-head)
	((member string '("FOR" "AS" "WITH" "AND" "END" "ELSE"
			  "REPEAT" "NAMED" "WHILE" "UNTIL" "ALWAYS" "NEVER"
			  "THEREIS" "RETURN" "COLLECT" "COLLECTING" "APPEND"
			  "APPENDING" "NCONC" "NCONCING" "COUNT" "COUNTING"
			  "SUM" "SUMMING" "MAXIMIZE" "MAXIMIZING"
			  "MINIMIZE" "MINIMIZING")
		 :test #'string=)
	 :block-head)
	(T :expr)))

; maybe put in a separate file (replace write-char by write-char+)
(defun pretty-loop (xp loop)
  (if (not (and (consp (cdr loop)) (symbolp (cadr loop)))) ; old-style loop
      (tagbody-print xp loop)
      (pprint-logical-block (xp loop :prefix "(" :suffix ")")
	(let (token type)
	  (labels ((next-token ()
		     (pprint-exit-if-list-exhausted)
		     (setq token (pprint-pop))
		     (setq type (token-type token)))
		   (print-clause (xp)
		     (case type
		       (:linear-head (print-exprs xp nil :mandatory))
		       (:cond-head (print-cond xp))
		       (:finally (print-exprs xp T :mandatory))
		       (otherwise (print-exprs xp nil :fill))))
		   (print-exprs (xp skip-first-non-expr newline-type)
		     (pprint-logical-block (xp nil)
		       (write+ token xp)
		       (next-token)
		       (when (and skip-first-non-expr (not (eq type :expr)))
			 (write-char+ #\space xp)
			 (write+ token xp)
			 (next-token))
		       (when (eq type :expr)
			 (write-char+ #\space xp)
			 (pprint-indent :current 0 xp)
			 (loop (write+ token xp)
			       (next-token)
			       (when (not (eq type :expr)) (return nil))
			       (write-char+ #\space xp)
			       (pprint-newline newline-type xp)))))
		   (print-cond (xp)
		     (pprint-logical-block (xp nil)
		       (write+ token xp)
		       (next-token)
		       (when (eq type :expr)
			 (write-char+ #\space xp)
			 (write+ token xp)
			 (next-token))
		       (write-char+ #\space xp)
		       (pprint-indent :block 2 xp)
		       (pprint-newline :linear xp)
		       (print-clause xp)
		       (print-and-list xp)
		       (when (string= (string token) "ELSE")
			 (print-else-or-end xp)
			 (write-char+ #\space xp)
			 (pprint-newline :linear xp)
			 (print-clause xp)
			 (print-and-list xp))
		       (when (string= (string token) "END")
			 (print-else-or-end xp))))
		   (print-and-list (xp)
		     (loop (when (not (string= (string token) "AND")) (return nil))
			   (write-char+ #\space xp)
			   (pprint-newline :mandatory xp)
			   (write+ token xp)
			   (next-token)
			   (write-char+ #\space xp)
			   (print-clause xp)))
		   (print-else-or-end (xp)
		     (write-char+ #\space xp)
		     (pprint-indent :block 0 xp)
		     (pprint-newline :linear xp)
		     (write+ token xp)
		     (next-token)
		     (pprint-indent :block 2 xp)))
	    (pprint-exit-if-list-exhausted)
	    (write+ (pprint-pop) xp)
	    (next-token)
	    (write-char+ #\space xp)
	    (pprint-indent :current 0 xp)
	    (loop (print-clause xp)
		  (write-char+ #\space xp)
		  (pprint-newline :linear xp)
                  ; without this we can loop forever
                  (if (and *print-level*
			   (>= *current-level* *print-level*))
		    (return))))))))

;Backquote is a big problem we MUST do all this reconsing of structure in
;order to get a list that will trigger the right formatting functions to
;operate on it.  On the other side of the coin, we must use a non-list structure 
;for the little backquote printing markers to ensure that they will always
;print out the way we want no matter what the code printers say.
;  Note that since it is sometimes possible to write the same
;backquote form in several ways, this might not necessarily print out a
;form in exactly the way you wrote it.  For example '`(a .,b) and '`(a ,@b)
;both print out as `'(a .,b), because the backquote reader produces the
;same code in both cases.


(setq *IPD* (make-pprint-dispatch-table))

(set-pprint-dispatch+ '(satisfies function-call-p) #'alternative-fn-call '(-5) *IPD*)
(set-pprint-dispatch+ 'cons #'pprint-fill '(-10) *IPD*)

(set-pprint-dispatch+ '(cons (member defstruct)) #'block-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member block)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member case)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member catch)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member ccase)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member compiler-let)) #'let-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member cond)) #'cond-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member ctypecase)) #'block-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member defclass)) #'defun-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member ctypecase)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defconstant)) #'defvar-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member define-setf-expander)) #'defun-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defmacro)) #'defun-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member define-modify-macro)) #'dmm-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member defparameter)) #'defvar-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defsetf)) #'defsetf-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member define-setf-expander)) #'defun-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member cl:defstruct)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member deftype)) #'defun-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defun)) #'defun-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defmethod)) #'defmethod-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member defvar)) #'defvar-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member do)) #'do-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member do*)) #'do-print '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member do-all-symbols)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member do-external-symbols)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member do-symbols)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member dolist)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member dotimes)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member ecase)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member etypecase)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member eval-when)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member flet)) #'flet-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member function)) #'function-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member generic-function)) #'fn-call '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member labels)) #'flet-print '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member lambda)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member let)) #'let-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member let*)) #'let-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member locally)) #'block-like '(0) *IPD*)

(set-pprint-dispatch+ '(cons (member loop)) #'pretty-loop '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member macrolet)) #'flet-print '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member multiple-value-bind)) #'mvb-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member multiple-value-setq)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member prog)) #'prog-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member prog*)) #'prog-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member progv)) #'defvar-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member psetf)) #'setq-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member psetq)) #'setq-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member quote)) #'quote-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member return-from)) #'block-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member setf)) #'setq-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member setq)) #'setq-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member tagbody)) #'tagbody-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member throw)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member typecase)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member unless)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member unwind-protect)) #'up-print '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member when)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member with-input-from-string)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member with-open-file)) #'block-like '(0) *IPD*)
(set-pprint-dispatch+ '(cons (member with-open-stream)) #'block-like '(0) *IPD*) 
(set-pprint-dispatch+ '(cons (member with-output-to-string)) #'block-like '(0) *IPD*) 


;so only happens first time is loaded. - why doesn't this work right?
; cause we have *print-pprin... bound to NIL
(when  t ;(eq *print-pprint-dispatch* T)
  (setq *print-pprint-dispatch* (copy-pprint-dispatch nil)))

(setq *error-print-circle* t)  ; now we can circle-print

; 82 bytes shorter but uglier
(defun write-not-pretty (stream object level list-kludge circle)
  (declare (type fixnum level) (type (or null fixnum) list-kludge))
  (when (xp-structure-p stream)(setq stream (xp-stream stream)))  
  (cond ((eq circle :subsequent)
         (if  list-kludge (stream-write-char stream #\)))
         (return-from write-not-pretty nil))
        ((not list-kludge))
        ((null object)(return-from write-not-pretty nil))
        ((and (not (consp object)) (not circle))
         (stream-write-entire-string stream " . "))
        ((eq circle :first)
         (when (consp object) (stream-write-char stream #\())
         (write-a-frob object stream level list-kludge)
         (when (consp object) (stream-write-char stream #\)))
         (return-from write-not-pretty nil))                     
        (t (stream-write-char stream #\space)))
  (write-a-frob object stream level list-kludge))

(def-standard-initial-binding *PRINT-PPRINT-DISPATCH* (copy-pprint-dispatch nil)) ; We have to support this.

(setq *standard-pprint-dispatch-table* (copy-pprint-dispatch nil))

(eval-when (:load-toplevel :execute) 
  (setq *error-print-circle* t))

;changes since last documentation.
;~/fn/ only refers to global function values, not lexical.

;------------------------------------------------------------------------

;Copyright 1989,1990 by the Massachusetts Institute of Technology, Cambridge, 
;Massachusetts.

;Permission to use, copy, modify, and distribute this software and its
;documentation for any purpose and without fee is hereby granted,
;provided that this copyright and permission notice appear in all
;copies and supporting documentation, and that the name of M.I.T. not
;be used in advertising or publicity pertaining to distribution of the
;software without specific, written prior permission. M.I.T. makes no
;representations about the suitability of this software for any
;purpose.  It is provided "as is" without express or implied warranty.

;    M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
;    ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
;    M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
;    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
;    WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
;    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
;    SOFTWARE.

;------------------------------------------------------------------------

#|
	Change History (most recent last):
	2	12/29/94	akh	merge with d13
|# ;(do not edit past this line!!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/pprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/prepare-mcl-environment.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; prepare-mcl-environment.lisp
;; Load this into a PPCCL to make it into an MCL-PPC for shipping
;; Sort of.

(in-package "CCL")

(defun %reset-outermost-binding (symbol value)
  (let* ((symvector (symptr->symvector symbol))
         (idx (%svref symvector target::symbol.binding-index-cell))
         (marker (%no-thread-local-binding-marker)))
    (if (> idx 0)
      (do-db-links (db var)
        (when (eq var idx)
          (let* ((oldval (%fixnum-ref db (* 2 target::node-size))))
            (unless (eq oldval marker)
              (setf (%fixnum-ref db (* 2 target::node-size)) value))))))
    (setf (uvref symvector target::symbol.vcell-cell) value)))

(defun freeze-current-definitions ()
  ;; Set the frozen bits so that redefine-kernel-function
  ;; will error if a builtin function is redefined.
  (do-all-symbols (s)
    (when (fboundp s)
      (%symbol-bits s (bitset $sym_fbit_frozen (%symbol-bits s)))))
  ;; Force an error if a kernel method is redefined.
  (make-all-methods-kernel))

(defun thaw-current-definitions ()
  ;; Clear the frozen bits on all fboundp symbols
  (do-all-symbols (s)
    (when (fboundp s)
      (%symbol-bits s (bitclr $sym_fbit_frozen (%symbol-bits s)))))
  ;; Allow redefinition of kernel methods.
  (make-all-methods-non-kernel))

(defun set-user-environment (&optional (freeze-definitions nil))
  "Arrange that the outermost special bindings of *PACKAGE* and
*WARN-IF-REDEFINE-KERNEL* restore values of the CL-USER package and T
respectively, and set *CCL-SAVE-SOURCE-LOCATIONS* to :NO-TEXT.
If the optional argument is true, marks all globally defined
functions and methods as being predefined (this is a fairly
expensive operation.)"
  (when freeze-definitions
    (freeze-current-definitions))
  ;; enable redefine-kernel-function's error checking
  (%reset-outermost-binding '*warn-if-redefine-kernel* t)
  ;; Set the top-level *package* to the CL-USER package
  (%reset-outermost-binding '*package* (find-package "CL-USER"))
  (setq *ccl-save-source-locations* :NO-TEXT))

(defun set-development-environment (&optional (thaw-definitions nil))
  "Arrange that the outermost special bindings of *PACKAGE* and
*WARN-IF-REDEFINE-KERNEL* restore values of the CCL package and NIL
respectively, and set *ccl-save-source-locations* to T. If the
optional argument is true, mark all globally defined functions and
methods as being not predefined (this is a fairly expensive operation.)"
  (when thaw-definitions
    (thaw-current-definitions))
  ;; enable redefine-kernel-function's error checking
  (%reset-outermost-binding '*warn-if-redefine-kernel* nil)
  ;; Set the top-level *package* to the CCL package
  (%reset-outermost-binding '*package* (find-package "CCL"))
  (setq *ccl-save-source-locations* T))
  


(defmacro in-development-mode (&body body)
  `(let* ((*package* (find-package "CCL"))
	  (*warn-if-redefine-kernel* nil))
    ,@body))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/prepare-mcl-environment.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/level-2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; Level-2.lisp

(in-package "CCL")

(eval-when (eval compile)
  (require "LEVEL-2")
  (require "BACKQUOTE")
  (require "DEFSTRUCT-MACROS"))



(eval-when (eval compile)
  (require "LISPEQU"))








; This incredibly essential thing is part of ANSI CL; put it in the
; right package someday.
; Like maybe when it says something about doc strings, or otherwise
; becomes useful.

(defun parse-macro (name arglist body &optional env)
  (values (parse-macro-1 name arglist body env)))

; Return a list containing a special declaration for SYM
; if SYM is declared special in decls.
; This is so we can be pedantic about binding &WHOLE/&ENVIRONMENT args
; that have been scarfed out of a macro-like lambda list.
; The returned value is supposed to be suitable for splicing ...
(defun hoist-special-decls (sym decls)
  (when sym
    (dolist (decl decls)
      (dolist (spec (cdr decl))
        (when (eq (car spec) 'special)
          (dolist (s (%cdr spec))
            (when (eq s sym)
              (return-from hoist-special-decls `((declare (special ,sym)))))))))))

(defun parse-macro-1 (name arglist body &optional env)
  (parse-macro-internal name arglist body env nil))

(defun parse-macro-internal (name arglist body env default-initial-value)
  (unless (verify-lambda-list arglist t t t)
    (error "Invalid lambda list ~s" arglist))
  (multiple-value-bind (lambda-list whole environment)
      (normalize-lambda-list arglist t t)
    (multiple-value-bind (body local-decs doc)
        (parse-body body env t)
      (let ((whole-var (gensym "WHOLE"))
            (env-var (gensym "ENVIRONMENT")))
        (multiple-value-bind (bindings binding-decls)
            (%destructure-lambda-list lambda-list whole-var nil nil
                                      :cdr-p t
                                      :whole-p nil
                                      :use-whole-var t
                                      :default-initial-value default-initial-value)
          (when environment
            (setq bindings (nconc bindings (list `(,environment ,env-var)))))
          (when whole
            (setq bindings (nconc bindings (list `(,whole ,whole-var)))))
          (values
            `(lambda (,whole-var ,env-var)
               (declare (ignorable ,whole-var ,env-var))
               (block ,name
                 (let* ,(nreverse bindings)
                   ,@(when binding-decls `((declare ,@binding-decls)))
                   ,@local-decs
                   ,@body)))
            doc))))))

(defun lambda-list-bounds (lambda-list)
  (let* ((state :required)
         (min 0)
         (max 0))
    (do* ((lambda-list lambda-list (cdr lambda-list)))
         ((null lambda-list) (values min max))
      (case (car lambda-list)
        ((&rest &key &body) (return (values min nil)))
        (&aux (return (values min max)))
        (&optional (setq state :optional))
        (t (ecase state
             (:required (incf min) (incf max))
             (:optional (incf max))))))))
  
(defun prepare-to-destructure (list lambda-list min max)
  (if (if max
        (and (proper-list-p list)
             (let* ((len (length list)))
               (<= min len max)))
             (do* ((tail list (cdr tail))
                   (n min (1- n)))
                  ((zerop n) t)
               (when (atom tail)
                 (return))))
    list
    (let* ((reason
            (if max
              (if (not (proper-list-p list))
                "it is not a proper list"
                (let* ((len (length list)))
                  (if (eql min max)
                    (format nil "it contains ~d elements, and exactly ~d are expected" len min)
                    (if (< len min)
                      (format nil "it contains ~d elements, and at least ~d are expected" len min)
                      (format nil "it contains ~d elements, and at most ~d are expected" len max)))))
              (format nil "it does not contain at least ~d elements" min))))
      (signal-program-error "~s can't be destructured against the lambda list ~s, because ~a."
                          list lambda-list reason))))
    

(defun %destructure-lambda-list (lambda-list wholeform  lets decls
                                              &key cdr-p (whole-p t) use-whole-var default-initial-value)
  (unless (and (listp lambda-list)
               (verify-lambda-list lambda-list t whole-p))
    (signal-simple-program-error "Invalid lambda list: ~s" lambda-list))
  (multiple-value-bind (normalized whole) (normalize-lambda-list
					   lambda-list whole-p)
    (let* ((argstate :required)
	   (allow-other-keys nil)
	   (rest-arg-name nil)
	   (w (if use-whole-var wholeform (or whole (gensym "WHOLE"))))
	   (argptr (gensym "ARGS"))
	   (has-&key nil)
	   (keywords ())
	   (first-keyword-init ())
	   (restp nil))
      (labels ((simple-var (var &optional (initform `,default-initial-value))
		 (let* ((binding `(,var ,initform)))
		   (push  binding lets)
		   binding))
	       (structured-var (context sub-lambda-list initform)
		 (let* ((v (gensym (string context))))
		   (simple-var v initform)
		   (multiple-value-setq (lets decls)
		     (%destructure-lambda-list
		      sub-lambda-list
		      v
		      lets
		      decls
		      :default-initial-value default-initial-value
                      ))
		   v)))
	(unless use-whole-var
	  (if (atom w)
	    (simple-var w wholeform)
	    (progn
	      (setq w (structured-var "WHOLE" w (if cdr-p `(cdr ,wholeform) wholeform))
		    cdr-p nil))))
        (multiple-value-bind (min max) (lambda-list-bounds normalized)
          (simple-var argptr `(prepare-to-destructure ,@(if cdr-p `((cdr ,w)) `(,w)) ',lambda-list ,min ,max))
          (push `(ignorable ,argptr) decls)
          (when max
            (push `(list ,argptr) decls))
          (do* ((tail normalized (cdr tail)))
               ((null tail)
                (if has-&key
                  (let* ((key-check-form `(check-keywords
                                           ',(nreverse keywords)
                                           ,rest-arg-name ,allow-other-keys)))
                    (if first-keyword-init
                      (rplaca (cdr first-keyword-init)
                              `(progn
                                ,key-check-form
                                ,(cadr first-keyword-init)))
                      (let* ((check-var (gensym "CHECK")))
                        (push `(ignorable ,check-var) decls)
                        (simple-var check-var key-check-form)))))
                (values lets decls))
            (let* ((var (car tail)))
              (cond ((or (eq var '&rest) (eq var '&body))
                     (let* ((r (cadr tail))
                            (init argptr))
                            (if (listp r)
                              (setq rest-arg-name
                                    (structured-var "REST" r init))
                              (progn
                                (setq rest-arg-name (gensym "REST"))
                                (simple-var rest-arg-name init)
                                (simple-var r rest-arg-name ))))
                       (setq restp t)
                       (setq tail (cdr tail)))
                     ((eq var '&optional) (setq argstate :optional))
                     ((eq var '&key)
                      (setq argstate :key)
                      (setq has-&key t)
                      (unless restp
                        (setq restp t
                              rest-arg-name (gensym "KEYS"))
                        (push `(ignorable ,rest-arg-name) decls)
                        (simple-var rest-arg-name
                                    argptr)))
                     ((eq var '&allow-other-keys)
                      (setq allow-other-keys t))
                     ((eq var '&aux)
                      (setq argstate :aux))
                     ((listp var)
                      (case argstate
                        (:required
                         (structured-var "REQ" var `(pop ,argptr)))
                        (:optional
                         (let* ((variable (car var))
                                (initform (if (cdr var)
                                            (cadr var)
                                            `,default-initial-value))
                                (anon-spvar (gensym "OPT-SUPPLIED-P"))
                                (spvar (if (cddr var)
                                         (caddr var)))
                                (varinit `(if ,anon-spvar
                                           (pop ,argptr)
                                           ,initform)))
                           (simple-var anon-spvar
                                       `(not (null  ,argptr)))
                           (if (listp variable)
                             (structured-var "OPT" variable varinit)
                             (simple-var variable varinit))
                           (if spvar
                             (simple-var spvar anon-spvar))))
                        (:key
                         (let* ((explicit-key (consp (car var)))
                                (variable (if explicit-key
                                            (cadar var)
                                            (car var)))
                                (keyword (if explicit-key
                                           (caar var)
                                           (make-keyword variable)))
                                (initform (if (cdr var)
                                            (cadr var)
                                            `,default-initial-value))
                                (anon-spvar (gensym "KEY-SUPPLIED-P"))
                                (spvar (if (cddr var)
                                         (caddr var))))
                           (push keyword keywords)
                           (let* ((sp-init (simple-var anon-spvar
                                                       `(%keyword-present-p
                                                         ,rest-arg-name
                                                         ',keyword)))
                                  (var-init `(if ,anon-spvar
                                              (getf ,rest-arg-name ',keyword)
                                              ,initform)))
                             (unless first-keyword-init
                               (setq first-keyword-init sp-init))
                             (if (listp variable)
                               (structured-var "KEY" variable var-init)
                               (simple-var variable var-init))
                             (if spvar
                               (simple-var spvar anon-spvar)))))
                        (:aux
                         (simple-var (car var) (cadr var)))
                        (t (error "NYI: ~s" argstate))))
                     ((symbolp var)
                      (case argstate
                        (:required
                         (simple-var var `(pop ,argptr)))
                        (:optional
                         (simple-var var `(if ,argptr
                                           (pop ,argptr)
                                           ',default-initial-value)))
                        (:key
                         (let* ((keyword (make-keyword var)))
                           (push keyword keywords)
                           (let* ((init (simple-var
                                         var
                                         `(getf ,rest-arg-name
                                           ',keyword
                                           ,@(if default-initial-value
                                                 `(',default-initial-value))))))
                             (unless first-keyword-init
                               (setq first-keyword-init init)))))
                        (:aux
                         (simple-var var))))))))))))






(defun apply-to-htab-syms (function pkg-vector)
  (let* ((sym nil)
         (foundp nil))
    (dotimes (i (uvsize pkg-vector))
      (declare (fixnum i))
      (multiple-value-setq (sym foundp) (%htab-symbol pkg-vector i))
      (when foundp (funcall function sym)))))

(defun iterate-over-external-symbols (pkg-spec function)
  (apply-to-htab-syms function (car (pkg.etab (pkg-arg (or pkg-spec *package*))))))

(defun iterate-over-present-symbols (pkg-spec function)
  (let ((pkg (pkg-arg (or pkg-spec *package*))))
    (apply-to-htab-syms function (car (pkg.etab pkg)))
    (apply-to-htab-syms function (car (pkg.itab pkg)))))

(defun iterate-over-accessable-symbols (pkg-spec function)
  (let* ((pkg (pkg-arg (or pkg-spec *package*)))
         (used (pkg.used pkg))
         (shadowed (pkg.shadowed pkg)))
    (iterate-over-present-symbols pkg function)
    (when used
      (if shadowed
        (flet ((ignore-shadowed-conflicts (var)
                 (unless (%name-present-in-package-p (symbol-name var) pkg)
                   (funcall function var))))
          (declare (dynamic-extent #'ignore-shadowed-conflicts))
          (dolist (u used) (iterate-over-external-symbols u #'ignore-shadowed-conflicts)))
        (dolist (u used) (iterate-over-external-symbols u function))))))

(defun iterate-over-all-symbols (function)
  (dolist (pkg %all-packages%)
    (iterate-over-present-symbols pkg function)))          



;;;Eval definitions for things open-coded by the compiler.
;;;Don't use DEFUN since it should be illegal to DEFUN compiler special forms...
;;;Of course, these aren't special forms.
(macrolet ((%eval-redef (name vars &rest body)
             (when (null body) (setq body `((,name ,@vars))))
             `(setf (symbol-function ',name)
                    (qlfun ,name ,vars ,@body))))
  (declare (optimize (speed 1) (safety 1)))
  (%eval-redef %ilsl (n x))
  (%eval-redef %ilsr (n x))
  (%eval-redef neq (x y))
  (%eval-redef not (x))
  (%eval-redef null (x))
  (%eval-redef rplaca (x y))
  (%eval-redef rplacd (x y))
  (%eval-redef set-car (x y))
  (%eval-redef set-cdr (x y))
  (%eval-redef int>0-p (x))
  (%eval-redef %get-byte (ptr &optional (offset 0)) (%get-byte ptr offset))
  (%eval-redef %get-word (ptr &optional (offset 0)) (%get-word ptr offset))
  (%eval-redef %get-signed-byte (ptr &optional (offset 0)) (%get-signed-byte ptr offset))
  (%eval-redef %get-signed-word (ptr &optional (offset 0)) (%get-signed-word ptr offset))
  (%eval-redef %get-long (ptr &optional (offset 0)) (%get-long ptr offset))
  (%eval-redef %get-fixnum (ptr &optional (offset 0)) (%get-fixnum ptr offset))
  (%eval-redef %get-signed-long (ptr &optional (offset 0)) (%get-signed-long ptr offset))
  (%eval-redef %get-unsigned-long (ptr &optional (offset 0)) (%get-unsigned-long ptr offset))
  (%eval-redef %get-ptr (ptr &optional (offset 0)) (%get-ptr ptr offset))
  (%eval-redef %get-full-long (ptr &optional (offset 0)) (%get-full-long ptr offset))
  (%eval-redef %int-to-ptr (int))
  (%eval-redef %ptr-to-int (ptr))
  (%eval-redef %ptr-eql (ptr1 ptr2))
  (%eval-redef %setf-macptr (ptr1 ptr2))
  (%eval-redef %null-ptr-p (ptr))
 


  (%eval-redef %iasr (x y))

  
  (%eval-redef %set-byte (p o &optional (new (prog1 o (setq o 0))))
               (%set-byte p o new))
  (%eval-redef %set-unsigned-byte (p o &optional (new (prog1 o (setq o 0))))
               (%set-unsigned-byte p o new))
  (%eval-redef %set-word (p o &optional (new (prog1 o (setq o 0))))
               (%set-word p o new))
  (%eval-redef %set-unsigned-word (p o &optional (new (prog1 o (setq o 0))))
               (%set-unsigned-word p o new))
  (%eval-redef %set-long (p o &optional (new (prog1 o (setq o 0))))
               (%set-long p o new))
  (%eval-redef %set-unsigned-long (p o &optional (new (prog1 o (setq o 0))))
               (%set-unsigned-long p o new))
  (%eval-redef %set-ptr (p o &optional (new (prog1 o (setq o 0))))
               (%set-ptr p o new))

  
  (%eval-redef %word-to-int (word))
  (%eval-redef %inc-ptr (ptr &optional (by 1)) (%inc-ptr ptr by))
  
  (%eval-redef char-code (x))
  (%eval-redef code-char (x))
  (%eval-redef 1- (n))
  (%eval-redef 1+ (n))

  (%eval-redef uvref (x y))
  (%eval-redef uvset (x y z))
  (%eval-redef uvsize (x))

  (%eval-redef svref (x y))
  (%eval-redef svset (x y z))
  
 
  

  (%eval-redef cons (x y))
  (%eval-redef endp (x))

  (progn
    (%eval-redef typecode (x))
    (%eval-redef lisptag (x))
    (%eval-redef fulltag (x))
    (%eval-redef %unbound-marker ())
    (%eval-redef %slot-unbound-marker ())
    (%eval-redef %slot-ref (v i))
    (%eval-redef %alloc-misc (count subtag &optional (initial nil initial-p))
                 (if initial-p
                   (%alloc-misc count subtag initial)
                   (%alloc-misc count subtag)))
    (%eval-redef %setf-double-float (x y))
    (%eval-redef %lisp-word-ref (x y))
    (%eval-redef %temp-cons (x y))
    (%eval-redef require-fixnum (x))
    (%eval-redef require-symbol (x))
    (%eval-redef require-list (x))
    (%eval-redef require-real (x))
    (%eval-redef require-simple-string (x))
    (%eval-redef require-simple-vector (x))
    (%eval-redef require-character (x))
    (%eval-redef require-number (x))
    (%eval-redef require-integer (x))
    (%eval-redef require-s8 (x))
    (%eval-redef require-u8 (x))
    (%eval-redef require-s16 (x))
    (%eval-redef require-u16 (x))
    (%eval-redef require-s32 (x))
    (%eval-redef require-u32 (x))
    (%eval-redef require-s64 (x))
    (%eval-redef require-u64 (x))
    (%eval-redef %reference-external-entry-point (x))    
    )
  
  (%eval-redef %get-bit (ptr offset))
  (%eval-redef %set-bit (ptr offset val))
  (%eval-redef %get-double-float (ptr &optional (offset 0))
	       (%get-double-float ptr offset))
  (%eval-redef %get-single-float (ptr &optional (offset 0))
	       (%get-single-float ptr offset))
  (%eval-redef %set-double-float (p o &optional (new (prog1 o (setq o 0))))
	       (%set-double-float p o new))
  (%eval-redef %set-single-float (p o &optional (new (prog1 o (setq o 0))))
	       (%set-single-float p o new))
  (%eval-redef assq (item list))
  (%eval-redef %fixnum-ref-double-float (base &optional (index 0))
               (%fixnum-ref-double-float base index))
  (%eval-redef %fixnum-set-double-float (base index &optional (new (prog1 index (setq index 0))))
               (%fixnum-set-double-float base index new))
  (%eval-redef ivector-typecode-p (arg))
  (%eval-redef gvector-typecode-p (arg))
)

; In the spirit of eval-redef ...


;; pointer hacking stuff 
;
;



;;; I'd guess that the majority of bitfields in the world whose width is
;;; greater than 1 have a width of two.  If that's true, this is probably
;;; faster than trying to be more clever about it would be.
(defun %get-bitfield (ptr start-bit width)
  (declare (fixnum start-bit width))
  (do* ((bit #+big-endian-target start-bit
             #+little-endian-target (the fixnum (1- (the fixnum (+ start-bit width))))
             #+big-endian-target (1+ bit)
             #+little-endian-target (1- bit))
	(i 0 (1+ i))
	(val 0))
       ((= i width) val)
    (declare (fixnum val i bit))
    (setq val (logior (ash val 1) (%get-bit ptr bit)))))

(defun %set-bitfield (ptr start width val)
  (declare (fixnum val start width))
  (do* ((v val (ash v -1))
	(bit #+big-endian-target (1- (+ start width))
             #+little-endian-target start
             #+big-endian-target (1- bit)
             #+little-endian-target (1+ bit))
	(i 0 (1+ i)))
       ((= i width) val)
    (declare (fixnum v bit i))
    (setf (%get-bit ptr bit) (logand v 1))))

; expands into compiler stuff

(setf (symbol-function '%get-unsigned-byte) (symbol-function '%get-byte))
(setf (symbol-function '%get-unsigned-word) (symbol-function '%get-word))
(setf (symbol-function '%get-signed-long) (symbol-function '%get-long))

(defun decompose-record-accessor (accessor &aux ret)
  (do* ((str (symbol-name accessor) (%substr str (+ i 1) len))
        (len (length str) (length str))
        (i (%str-member #\. str) (%str-member #\. str))
        (field (%substr str 0 (or i len)) (%substr str 0 (or i len))))
       ((not i) (nreverse (cons (make-keyword field) ret)))
    (push (make-keyword field) ret)))




(provide 'level-2)

	


;; end of level-2.lisp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/level-2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/numbers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; Lib;numbers.lisp - Lisp arithmetic code.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
 (require :number-macros)
 (require :number-case-macro)
 #+(and cross-compiling 64-bit-target)
 (declaim (ftype function %single-float-atanh %single-float-acosh
                 %single-float-asinh %single-float-tanh
                 %single-float-cosh %single-float-sinh)))



(defconstant double-float-positive-infinity
  #.(let* ((division-by-zero (get-fpu-mode  :division-by-zero)))
      (declare (notinline /))
      (unwind-protect
           (progn
             (ccl:set-fpu-mode :division-by-zero nil)
             (/ 0d0))
	(ccl:set-fpu-mode :division-by-zero division-by-zero))))

(defconstant double-float-negative-infinity
  #.(let* ((division-by-zero (get-fpu-mode  :division-by-zero)))
      (declare (notinline /))
      (unwind-protect
           (progn
             (ccl:set-fpu-mode :division-by-zero nil)
             (/ -0d0))
	(ccl:set-fpu-mode :division-by-zero division-by-zero))))

(defconstant double-float-nan
  #.(let ((invalid (get-fpu-mode :invalid)))
      (declare (notinline +))
      (unwind-protect
	   (progn
	     (set-fpu-mode :invalid nil)
	     (+ double-float-positive-infinity double-float-negative-infinity))
	(set-fpu-mode :invalid invalid))))

(defun parse-float (str len off)  
  ; we cant assume this really is a float but dont call with eg s1 or e1
  (let ((integer 0)(expt 0)(sign 0)(done 0)(digits 0) point-pos type) 
    (setq integer
          (do ((n off (1+ n))
               (first t nil)
               (maxn  (+ off len)))
              ((>= n maxn) integer)
            (declare (fixnum n maxn))
            (let ((c (%schar str n)))
              (cond ((eq c #\.)
                     (setq point-pos digits))
                    ((and first (eq c #\+)))
                    ((and first (eq c #\-))
                     (setq sign -1))
                    ((memq c '(#\s #\f #\S #\F))
                     (setq type 'short-float)
                     (return integer))
                    ((memq c '(#\d #\l  #\D  #\L))
                     (setq type 'double-float)
                     (return integer))
                    ((memq c '(#\e #\E))
                     (return integer))
                    ((setq c (digit-char-p c))
                     (setq digits (1+ digits))
                     (setq integer (+ c (* 10 integer))))                  
                    (t (return-from parse-float nil)))
              (setq done (1+ done)))))
    (when point-pos
      (setq expt  (%i- point-pos digits)))
    (when (null type)
      (setq type *read-default-float-format*))
    (when (> len done)
      (let ((eexp nil) (inf nil) (nan nil) (esign 1) c (xsign-n -1))
        (do ((n (%i+ off done 1) (1+ n))
             (first t nil))
            ((>= n (+ off len)))
          (declare (fixnum n))
          (setq c (%schar str n))
          (cond ((and first (or (eq c #\+)(eq c #\-)))
                 (when (eq c #\-)(setq esign -1))
		 (setq xsign-n (1+ n)))
		((and (= n xsign-n)
		      (or (eq c #\+)(eq c #\-)))
                 (if (eq c #\-)
		     (setq nan t)
		     (setq inf t)))
                ((setq c (digit-char-p c))
                 (setq eexp (+ c (* (or eexp 0) 10))))
                (t (return-from parse-float nil))))
        (when (not eexp)(return-from parse-float nil))
        (cond 
	 (inf 
	  (return-from parse-float
	    (coerce (if (minusp sign)
			double-float-negative-infinity
			double-float-positive-infinity)
		    type)))
	 (nan 
	  (return-from parse-float
	    (coerce double-float-nan type)))
	 (expt (setq expt (%i+ expt (* esign eexp))))
	 (t (return-from parse-float nil)))))
    (fide sign integer expt (subtypep type 'short-float))))


;; an interesting test case: 1.448997445238699
;; The correct result is 6525704354437805 x 2^-52
;; Incorrect is          6525704354437806 x 2^-52
;; (from Will Clinger, "How to Read Floating Point Numbers Accurately",
;;  ACM SIGPLAN'90 Conference on Programming Language Design and Implementation")
;; Doug Curries numbers 214748.3646, 1073741823/5000


;; Sane read losers
;; 15871904747836473438871.0e-8
;; 3123927307537977993905.0-13
;; 17209940865514936528.0e-6
;; "13.60447536e132" => adds some gratuitous drech
;; "94824331561426550.889e182"
;; "1166694.64175277e-150" => 1.1666946417527701E-144
;; "3109973217844.55680988601e-173"
;; "817332.e-184" => 8.173320000000001E-179
;; "2695.13e-180" => 2.6951300000000002E-177
;; "89.85345789e-183" => 8.985345789000001E-182
;; "0864813880.29e140" => 8.648138802899999E+148
;; "5221.e-193" => 5.2209999999999995E-190
;; "7.15628e-175" => 7.156280000000001E-175

(defparameter float-powers-of-5  nil)
(defparameter integer-powers-of-5 nil)

(defun 5-to-e (e)
  (declare (fixnum e)(optimize (speed 3)(safety 0)))
  (if (> e 335)
    (* (5-to-e 335)(5-to-e (- e 335))) ; for the dude who types 200 digits and e-500
    (if (< e 12)
      (svref integer-powers-of-5 e)
      (multiple-value-bind (q r) (truncate e 12) ; was floor
        (declare (fixnum q r))        
        (if (eql r 0)
          (svref integer-powers-of-5 (%i+ q 11))
          (* (svref integer-powers-of-5 r)
             (svref integer-powers-of-5 (%i+ q 11))))))))

(defun float-5-to-e (e)
  (if (> e 22)  ; shouldnt happen
    (expt 5.0d0 e)
    (svref float-powers-of-5 e)))

(defparameter a-short-float nil)

(eval-when (:compile-toplevel :execute)
  ; number of bits for mantissa before rounding
  (defconstant *short-float-extended-precision* 28)
  (defconstant *double-float-extended-precision* 60)
  ; number of mantissa bits including hidden bit
  (defconstant *double-float-precision* (1+ IEEE-double-float-mantissa-width))
  (defconstant *short-float-precision* (1+ IEEE-single-float-mantissa-width))
  (defconstant *double-float-bias* IEEE-double-float-bias)
  (defconstant *double-float-max-exponent* (1+ IEEE-double-float-normal-exponent-max))
  (defconstant *double-float-max-exact-power-of-5* 23)
  ;(defconstant *short-float-max-exact-integer-length* 24)
  (defconstant *double-float-max-exact-integer-length* 53)
)




(eval-when (:compile-toplevel :execute)
  (defconstant *short-float-max-exact-power-of-5* 10)
  (defconstant *short-float-bias* IEEE-single-float-bias)
  (defconstant *short-float-max-exact-integer-length* 24)
  (defconstant *short-float-max-exponent* (1+ IEEE-single-float-normal-exponent-max))
)

  
;; this stuff  could be in a shared file

(defun fide #|float-integer-with-decimal-exponent|# (sign integer power-of-10 &optional short)
  ;; take care of the zero case
  (when (zerop integer)
    (return-from fide ;float-integer-with-decimal-exponent
       (if short
         (if (minusp sign) -0.0s0 0.0s0)
         (if (minusp sign) -0.0d0 0.0d0))))
  (let ((abs-power (abs power-of-10))
        (integer-length (integer-length integer)))
    ;; this doesn't work for the above example, so arithmetic must be done wrong
    ;; This does work if set FPCR precision to double
    ;; now see if the conversion can be done simply:
    ;; if both the integer and the power of 10 can be floated exactly, then
    ;; correct rounding can be done by the multiply or divide
    (when (or;short
           (and (<= integer-length  
                    ;; was (if short 17 53) why 17? see above
                    (if short *short-float-max-exact-integer-length* *double-float-max-exact-integer-length*)) 
                ;; (integer-length (expt 5 23)) => 54
                ;; was (if short 5 23)
                (< abs-power  (if short 
                                *short-float-max-exact-power-of-5*
                                *double-float-max-exact-power-of-5*)))) ; we mean < 23 not <=
      ;; if you care about consing, this could be done in assembly language or whatever,
      ;; since all integers fit in 53 bits
      (return-from fide ;float-integer-with-decimal-exponent
        (let* ((signed-integer (prog1 (if (minusp sign) (- integer) integer)))
               (float (float signed-integer (if short 0.0s0 0.0d0)))
               (10-to-power (scale-float (float-5-to-e abs-power) abs-power)))
          ;; coerce to short-float does not whine about undeflow, but does re overflow
          (when short (setq 10-to-power (coerce 10-to-power 'short-float)))
          (if (zerop abs-power)
            float
            (if (minusp power-of-10)
              (/ float  10-to-power)
              (* float  10-to-power))))))
    (try-harder sign integer power-of-10 short)))


(defun try-harder (sign integer power-of-10 short)
  (flet ((ovf (&optional under)
           (if under
             (if (get-fpu-mode :underflow)
               (error 'floating-point-underflow
                      :operation 'scale
                      :operands (list sign integer power-of-10)))
             (if (get-fpu-mode :overflow)
               (error 'floating-point-overflow
                      :operation 'scale
                      :operands (list sign integer power-of-10))))
           (return-from try-harder
             (if under
               (if short
                 (if (minusp sign) -0.0s0 0.0s0)                 
                 (if (minusp sign) 0.0d0 0.0d0))
               (if short
                 (if (minusp sign) most-negative-short-float most-positive-short-float)              
                 (if (minusp sign) most-negative-double-float most-positive-double-float))))))
  (let* ((integer-length (integer-length integer)) new-int power-of-2)
    (if (minusp power-of-10)
      (progn 
        ;; avoid creating enormous integers with 5-to-e only to error later
        (when (< power-of-10 -335)
          (let ((poo (+ (round integer-length 3.2) power-of-10)))
            ;; overestimate digits in integer
            (when (< poo -335) (ovf t))
            ;; this case occurs if 600+ digits 
            (when (> poo 335) (ovf))))
        (let* ((divisor (5-to-e (- power-of-10)))
               ;; make sure we will have enough bits in the quotient
               ;; (and a couple extra for rounding)
               (shift-factor (+ (- (integer-length divisor) integer-length)
                                (if short *short-float-extended-precision* *double-float-extended-precision*)))
               (scaled-integer integer))
          (if (plusp shift-factor)
            (setq scaled-integer (ash integer shift-factor))
            (setq divisor (ash divisor (- shift-factor))))
          (multiple-value-bind (quotient remainder)(floor scaled-integer divisor)
            (unless (zerop remainder) ; whats this - tells us there's junk below
              (setq quotient (logior quotient 1)))
            (setq new-int quotient)
            (setq power-of-2  (- power-of-10 shift-factor)))))
      (progn
        (when (> power-of-10 335)(ovf))
        (setq new-int (* integer (5-to-e power-of-10)))
        (setq power-of-2 power-of-10)))
    (float-and-scale-and-round sign new-int power-of-2 short))))


(defun float-and-scale-and-round (sign integer power-of-2 short &optional result)
  (let* ((length (integer-length integer))
         (lowbits 0)
         (prec (if short *short-float-precision* *double-float-precision*))
         (ep (if short *short-float-extended-precision* *double-float-extended-precision*)))
    (when (<= length prec)
      ;; float can be done exactly, so do it the easy way
      (return-from float-and-scale-and-round
        (scale-float (float (if (minusp sign) (- integer) integer) (if short a-short-float))
                     power-of-2)))    
    (let* ((exponent (+ length power-of-2))
           (biased-exponent (+ exponent (if short *short-float-bias* *double-float-bias*)))
           (sticky-residue nil))
      (cond
       ((<= biased-exponent 0)
        ;; denormalize the number
        (setf sticky-residue (not (zerop (ldb integer (byte (- 1 biased-exponent) 0)))))
        (setf integer (ash integer (- biased-exponent 1)))
        (setf biased-exponent 0)))
      (let ((lowest (min ep length)))
        (when (and (> length ep)(not (zerop (ldb (byte (- length ep) 0) integer))))
          (setq integer (logior integer (ash 1 (- length ep)))))
        ; somewhere between 1 and (- ep prec) bits
        (setq lowbits (ash (ldb (byte (- lowest prec) (- length lowest)) integer) (- ep lowest))))
      (let* ((significand (ldb (byte (1- prec) (- length prec)) integer)))
        (when (and (not (zerop (ldb (byte 1 (- length (1+ prec))) integer)))   ; round bit
                   (or sticky-residue (oddp significand)
                       (not (zerop (ldb (byte (- ep prec 1) 0) lowbits)))))
          ;; round up
          (setf significand (ldb (byte (1- prec) 0) (+ significand 1)))
          (when (zerop significand)
            (incf biased-exponent)))
        (cond ((and (zerop biased-exponent)
                    (zerop significand)
                    (get-fpu-mode :underflow))
               (error 'floating-point-underflow
                      :operation 'scale
                      :operands (list sign integer power-of-2)))
              ((>= biased-exponent (if short *short-float-max-exponent* *double-float-max-exponent*))
               (cond 
                     (t
                      (if (get-fpu-mode :overflow)
                        (error 'floating-point-overflow
                               :operation 'scale
                               :operands (list sign integer power-of-2)))
                      (setf significand 0)                      
                      (setq biased-exponent (if short *short-float-max-exponent* *double-float-max-exponent*))))))
        (values
         (if short 
           (make-short-float-from-fixnums (ldb (byte 23 0) significand)
                                          biased-exponent
                                          sign #-64-bit-target result)
           (make-float-from-fixnums (ldb (byte 24 28) significand)
                                    (ldb (byte 28 0) significand)
                                    biased-exponent
                                    sign result))
         lowbits)))))




(defparameter a-short-float 1.0s0)

(defmethod print-object ((rs random-state) stream)
  (let* ((s1 (random.mrg31k3p-state rs)))
    (format stream "#.(~s~{ ~s~})"       ;>> #.GAG!!!
            'ccl::initialize-mrg31k3p-state
	    (coerce s1 'list))))

(defun float-radix (float)
  "Return (as an integer) the radix b of its floating-point argument."
  (require-type float 'float)
  2)

(defun float-digits (float)
  (if (typep (require-type float 'float) 'short-float)
    IEEE-single-float-digits
    IEEE-double-float-digits))

(defun number-arg (arg)
  (if (numberp arg) arg (%badarg arg 'number)))





;==> Needs a transform...
(defun logandc2 (integer1 integer2)
  "Bitwise AND INTEGER1 with (LOGNOT INTEGER2)."
  (logandc1 integer2 integer1))

(defun logorc2 (integer1 integer2)
  "Bitwise OR INTEGER1 with (LOGNOT INTEGER2)."
  (logorc1 integer2 integer1))



; Figure that the common (2-arg) case is caught by a compiler transform anyway.
(defun gcd (&lexpr numbers)
  "Return the greatest common divisor of the arguments, which must be
  integers. Gcd with no arguments is defined to be 0."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))   
    (if (zerop count)
      0
      (let* ((n0 (%lexpr-ref numbers count 0)))
        (if (= count 1)
          (%integer-abs n0)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (setq n0 (gcd-2 n0 (%lexpr-ref numbers count i)))))))))

(defun lcm-2 (n0 n1)
  (or (typep n0 'integer) (report-bad-arg n0 'integer))
  (or (typep n1 'integer) (report-bad-arg n1 'integer))
  (locally (declare (integer n0 n1))
    (if (zerop n0)
      0
      (if (zerop n1)
	0
	(let* ((small (if (< n0 n1) n0 n1))
	       (large (if (eq small n0) n1 n0)))
	  (values (truncate (abs (* n0 n1)) (gcd large small))))))))

(defun lcm (&lexpr numbers)
  "Return the least common multiple of one or more integers. LCM of no
  arguments is defined to be 1."
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))    
    (if (zerop count)
      1
      (let* ((n0 (%lexpr-ref numbers count 0)))
        (if (= count 1)
          (%integer-abs n0)
	  (if (= count 2)
	    (lcm-2 n0 (%lexpr-ref numbers count 1))
	    (do* ((i 1 (1+ i)))
		 ((= i count) n0)
	      (declare (fixnum i))
	      (setq n0 (lcm-2 n0 (%lexpr-ref numbers count i))))))))))


	   
(defun rationalize (number)
  "Converts any REAL to a RATIONAL.  Floats are converted to a simple rational
  representation exploiting the assumption that floats are only accurate to
  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:
      (= x (float (rationalize x) x))"
  (if (floatp number)
    (labels ((simpler-rational (less-predicate lonum loden hinum hiden
                                               &aux (trunc (if (eql less-predicate #'<=)
                                                             #'ceiling
                                                             #'(lambda (n d) (1+ (floor n d)))))
                                               (term (funcall trunc lonum loden)))
               ;(pprint (list lonum loden hinum hiden))
               (if (funcall less-predicate (* term hiden) hinum)
                 (values term 1)
                 (multiple-value-bind 
                   (num den)
                   (simpler-rational less-predicate hiden (- hinum (* (1- term) hiden))
                                     loden (- lonum (* (1- term) loden)))
                   (values (+ den (* (1- term) num)) num)))))                           
      (multiple-value-bind (fraction exponent sign) (integer-decode-float number)
        ;; the first 2 tests may be unnecessary - I think the check
        ;; for denormalized is compensating for a bug in 3.0 re
        ;; floating a rational (in order to pass tests in
        ;; ppc-test-arith).
        (if (or (and (typep number 'double-float)  ; is it denormalized
                     (eq exponent #.(nth-value 1 (integer-decode-float least-positive-double-float)))) ; aka -1074))
                (eq exponent #.(nth-value 1 (integer-decode-float least-positive-short-float))) ; aka -149))
                (zerop (logand fraction (1- fraction)))) ; or a power of two
          (rational number)
          (if (minusp exponent)
	    ;;less than 1
            (let ((num (ash fraction 2))
	          (den (ash 1 (- 2 exponent))))
	      (multiple-value-bind 
                (n d)
                (simpler-rational (if (evenp fraction) #'<= #'<)
                                  (- num 2) ;(if (zerop (logand fraction (1- fraction))) 1 2))
                                  den  (+ num 2) den)
	        (when (minusp sign)
	          (setq n (- n)))
	        (/ n d)))
            ;;greater than 1
            (ash (if (minusp number) (- fraction) fraction) exponent)))))
    (rational number)))
#|
(defun testrat (&optional (n 1000))
  (dotimes (i n)
    (let* (( numerator (random (ash 1 63)))
          (denominator (random (ash 1 63)))
          (sign  (if (zerop (random 2)) 1 -1))
          (trial (float (/ (* sign numerator) denominator)))
          (rat (rationalize trial)))
      (when (not (= (float rat) trial))
        (error "Rationalize failed. Input ~s Rational ~s Float ~s" trial rat (float rat))))))

; smallest fails in 3.0 - powers of 2 - works here but we cheat a bit
(defun testrat2 ()
  (let ((f least-positive-double-float))
    (dotimes (i 100)
      (when (not (= (float (rationalize f)) f))
        (cerror "a" "rat failed ~s ~s" f i))
      (setq f (* f 2)))))

; fails a lot in 3.0 - not powers of 2 - works here
(defun testrat3 ()
  (let ((f least-positive-double-float))
    (dotimes (i 1000)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i)))))
  (let ((f least-negative-double-float))
    (dotimes (i 1000)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i))))))

(defun testrat31 ()
  (let ((f least-positive-short-float))
    (dotimes (i 1000)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i)))))
  (let ((f least-negative-short-float))
    (dotimes (i 1000)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i))))))

; works in 3.0 - and here
(defun testrat4 ()
  (let ((f least-positive-normalized-double-float))
    (dotimes (i 1000)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i)))))
  (let ((f least-negative-normalized-double-float))
    (dotimes (i 100)
      (let ((f2 (* (+ i i 1) f)))
        (when (not (= (float (rationalize f2)) f2))
          (cerror "a" "rat failed ~s ~s" f2 i))))))
        
    
|#

#| now in l1-numbers.lisp
(defun logeqv (&lexpr numbers)
  (let* ((count (%lexpr-count numbers)))
    (declare (fixnum count))
    (if (zerop count)
      -1
      (let* ((n0 (%lisp-word-ref numbers count)))
        (if (= count 1)
          (require-type n0 'integer)
          (do* ((i 1 (1+ i)))
               ((= i count) n0)
            (declare (fixnum i))
            (declare (optimize (speed 3) (safety 0)))
            (setq n0 (logeqv-2 (%lexpr-ref numbers count i) n0))))))))
|#


(defparameter *boole-ops* 
  (vector
   #'(lambda (i1 i2) (declare (ignore i1 i2)) 0)
   #'(lambda (i1 i2) (declare (ignore i1 i2)) -1)
   #'(lambda (i1 i2) (declare (ignore i2)) i1)
   #'(lambda (i1 i2) (declare (ignore i1)) i2)
   #'(lambda (i1 i2) (declare (ignore i2)) (lognot i1))
   #'(lambda (i1 i2) (declare (ignore i1)) (lognot i2))
   #'(lambda (i1 i2) (logand i1 i2))
   #'(lambda (i1 i2) (logior i1 i2))
   #'(lambda (i1 i2) (logxor i1 i2))
   #'(lambda (i1 i2) (logeqv i1 i2))
   #'(lambda (i1 i2) (lognand i1 i2))
   #'(lambda (i1 i2) (lognor i1 i2))
   #'(lambda (i1 i2) (logandc1 i1 i2))
   #'(lambda (i1 i2) (logandc2 i1 i2))
   #'(lambda (i1 i2) (logorc1 i1 i2))
   #'(lambda (i1 i2) (logorc2 i1 i2))))
 


;===> Change these constants to match maclisp!!
(defun boole (op integer1 integer2)
  "Bit-wise boolean function on two integers. Function chosen by OP:
        0       BOOLE-CLR
        1       BOOLE-SET
        2       BOOLE-1
        3       BOOLE-2
        4       BOOLE-C1
        5       BOOLE-C2
        6       BOOLE-AND
        7       BOOLE-IOR
        8       BOOLE-XOR
        9       BOOLE-EQV
        10      BOOLE-NAND
        11      BOOLE-NOR
        12      BOOLE-ANDC1
        13      BOOLE-ANDC2
        14      BOOLE-ORC1
        15      BOOLE-ORC2"
  (unless (and (typep op 'fixnum)
               (locally (declare (fixnum op))
                 (and (>= op 0)
                      (<= op 15))))
    (report-bad-arg op '(integer 0 15)))
  (funcall (%svref *boole-ops* op)
	   (require-type integer1 'integer)
	   (require-type integer2 'integer)))


(defun %integer-power (b e)
  (declare (type unsigned-byte e))
  (if (zerop e)
    (+ 1 (* b 0))
    (if (eql b 2)
      (ash 1 e)
      (do* ((next (ash e -1) (ash e -1))
            (oddexp (oddp e) (oddp e))
            (total (if oddexp b 1) (if oddexp (* b total) total)))
           ((zerop next) total)
        (declare (type unsigned-byte next))
        (setq b (* b b) e next)))))

(defun signum (x)
  "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER))."
  (cond ((complexp x) (if (zerop x)
                        x
                        (let ((m (max (abs (realpart x))
                                      (abs (imagpart x)))))
                          (cond ((rationalp m)
                                 ;; rescale to avoid intermediate under/overflow
                                 (setq x (/ x m)))
                                ((> m #.(ash 1 23))
                                 ;; ensure no overflow for abs
                                 (setq x (/ x 2))))
                          (/ x (abs x)))))
        ((rationalp x) (if (plusp x) 1 (if (zerop x) 0 -1)))
        ((zerop x) (float 0.0 x))
        (t (float-sign x))))



; Thanks to d34676@tansei.cc.u-tokyo.ac.jp (Akira KURIHARA)
(defun isqrt (n &aux n-len-quarter n-half n-half-isqrt
                init-value iterated-value)
  "Return the root of the nearest integer less than n which is a perfect
   square.  Argument n must be a non-negative integer"
  (cond
   ((eql n 0) 0)
   ; this fails sometimes - do we care? 70851992595801818865024053174 or #x80000000
   ; maybe we do - its used by dotimes
   ;((not (int>0-p n)) (report-bad-arg n '(integer 0))) ;'unsigned-byte)) ; Huh?
   ((or (not (integerp n))(minusp n))(report-bad-arg n '(integer 0)))
   ((> n 24)		; theoretically (> n 7) ,i.e., n-len-quarter > 0
    (setq n-len-quarter (ash (integer-length n) -2))
    (setq n-half (ash n (- (ash n-len-quarter 1))))
    (setq n-half-isqrt (isqrt n-half))
    (setq init-value (ash (1+ n-half-isqrt) n-len-quarter))
    (loop
      (setq iterated-value (ash (+ init-value (floor n init-value)) -1))
      (if (not (< iterated-value init-value))
        (return init-value)
        (setq init-value iterated-value))))
   ((> n 15) 4)
   ((> n  8) 3)
   ((> n  3) 2)
   (t 1)))


(defun sinh (x)
  "Return the hyperbolic sine of NUMBER."
  (if (complexp x) 
    (let ((r (realpart x))
          (i (imagpart x)))
      (complex (* (sinh r) (cos i))
               (* (cosh r) (sin i))))
    (if (typep x 'double-float)
      (%double-float-sinh! x (%make-dfloat))
      #+32-bit-target
      (target::with-stack-short-floats ((sx x))
	(%single-float-sinh! sx (%make-sfloat)))
      #+64-bit-target
        (%single-float-sinh (%short-float x)))))


(defun cosh (x)
  "Return the hyperbolic cosine of NUMBER."
  (if (complexp x) 
    (let ((r (realpart x))
          (i (imagpart x)))
      (complex (* (cosh r) (cos i))
               (* (sinh r) (sin i))))
    (if (typep x 'double-float)
      (%double-float-cosh! x (%make-dfloat))
      #+32-bit-target
      (target::with-stack-short-floats ((sx x))
	(%single-float-cosh! sx (%make-sfloat)))
      #+64-bit-target
      (%single-float-cosh (%short-float x)))))

(defun tanh (x)
  "Return the hyperbolic tangent of NUMBER."
  (cond ((complexp x)
         (let ((r (realpart x))
               (i (imagpart x)))
           (if (zerop r)
             (complex r (tan i))
             (let* ((tx (tanh r))
                    (ty (tan i))
                    (ty2 (* ty ty))
                    (d (1+ (* (* tx tx) ty2)))
                    (c (if (> (abs r) 20)
                         (* 2 (exp (- (abs r))))
                         (/ (cosh r)))))
               (complex (/ (* tx (1+ ty2)) d)
                        (/ (* (* c c) ty) d))))))
        ((typep x 'double-float)
         (%double-float-tanh! x (%make-dfloat)))
        ((and (typep x 'rational)
              (> (abs x) 12))
         (if (plusp x) 1.0s0 -1.0s0))
        (t
         #+32-bit-target
         (target::with-stack-short-floats ((sx x))
           (%single-float-tanh! sx (%make-sfloat)))
         #+64-bit-target
         (%single-float-tanh (%short-float x)))))

(defun asinh (x)
  "Return the hyperbolic arc sine of NUMBER."
  (cond ((typep x 'double-float)
         (%double-float-asinh! x (%make-dfloat)))
        ((typep x 'short-float)
         #+32-bit-target
         (%single-float-asinh! x (%make-sfloat))
         #+64-bit-target
         (%single-float-asinh (%short-float x)))
        ((typep x 'rational)
         (if (< (abs x) most-positive-short-float)
           #+32-bit-target
           (target::with-stack-short-floats ((sx x))
             (%single-float-asinh! sx (%make-sfloat)))
           #+64-bit-target
           (%single-float-asinh (%short-float x))
           (* (signum x) (log-e (* 2 (abs x))))))
        (t
         (i* (%complex-asin/acos (i* x) nil) -1))))

;;; for complex case, use acos and post-fix the branch cut
(defun acosh (x)
  "Return the hyperbolic arc cosine of NUMBER."
  (cond ((and (typep x 'double-float)
              (locally (declare (type double-float x))
                (<= 1.0d0 x)))
         (%double-float-acosh! x (%make-dfloat)))
        ((and (typep x 'short-float)
              (locally (declare (type short-float x))
                (<= 1.0s0 x)))
         #+32-bit-target
         (%single-float-acosh! x (%make-sfloat))
         #+64-bit-target
         (%single-float-acosh (%short-float x)))
        ((and (typep x 'rational)
              (<= 1 x))
         (cond ((< x 2)
                (log1+ (+ (- x 1) (sqrt (- (* x x) 1)))))
               ((<= x most-positive-short-float)
                #+32-bit-target
                (target::with-stack-short-floats ((x1 x))
                  (%single-float-acosh! x1 (%make-sfloat)))
                #+64-bit-target
                (%single-float-acosh (%short-float x)))
               (t
                (log-e (* 2 x)))))
        (t
         (let ((sign (and (typep x 'complex)
                          (let ((ix (imagpart x)))
                            (typecase ix
                              (double-float (%double-float-sign ix))
                              (single-float (%short-float-sign ix))
                              (t (minusp ix)))))))
           (i* (%complex-asin/acos x t) (if sign -1 1))))))

(defun atanh (x)
  "Return the hyperbolic arc tangent of NUMBER."
  (cond ((and (typep x 'double-float)
              (locally (declare (type double-float x))
                (and (<= -1.0d0 x)
                     (<= x 1.0d0))))
         (%double-float-atanh! x (%make-dfloat)))
        ((and (typep x 'short-float)
              (locally (declare (type short-float x))
                (and (<= -1.0s0 x)
                     (<= x 1.0s0))))
         #+32-bit-target
         (%single-float-atanh! x (%make-sfloat))
         #+64-bit-target
         (%single-float-atanh x))
        ((and (typep x 'rational)
              (<= (abs x) 1))
         (let ((n (numerator x))
               (d (denominator x)))
           (/ (log-e (/ (+ d n) (- d n))) 2)))
        (t
         (let ((r (realpart x)))
           (if (zerop r)
             (complex r (atan (imagpart x)))
             (%complex-atanh x))))))

(defun ffloor (number &optional divisor)
  "Same as FLOOR, but returns first value as a float."
  (multiple-value-bind (q r) (floor number divisor)
    (values (float q (if (floatp r) r 0.0)) r)))

(defun fceiling (number &optional divisor)
  "Same as CEILING, but returns first value as a float."
  (multiple-value-bind (q r) (ceiling number divisor)
    (values (float q (if (floatp r) r 0.0)) r)))

(defun ftruncate (number &optional divisor)
  "Same as TRUNCATE, but returns first value as a float."
  (multiple-value-bind (q r) (truncate number divisor)
    (values (float q (if (floatp r) r 0.0)) r)))

(defun fround (number &optional divisor)
  "Same as ROUND, but returns first value as a float."
  (multiple-value-bind (q r) (round number divisor)
    (values (float q (if (floatp r) r 0.0)) r)))

(defun rational (number)
  "RATIONAL produces a rational number for any real numeric argument. This is
  more efficient than RATIONALIZE, but it assumes that floating-point is
  completely accurate, giving a result that isn't as pretty."
  (if (floatp number)
    (multiple-value-bind (s e sign)
        (number-case number
          (short-float
           (integer-decode-short-float number))
          (double-float
           (integer-decode-double-float number)))
      (if (eq sign -1) (setq s (- s)))
      (if (%iminusp e)
        (/ s (ash 1 (%i- 0 e)))
        (ash s e)))
    (if (rationalp number)
      number
      (report-bad-arg number 'real))))

; make power tables for floating point reader
(progn
  (setq float-powers-of-5 (make-array 23))
  (let ((array float-powers-of-5))
    (dotimes (i 23)
      (setf (svref array i)  (float (expt 5 i) 0.0d0))))
  (setq integer-powers-of-5 (make-array (+ 12 (floor 324 12))))
  (let ((array integer-powers-of-5))
    (dotimes (i 12)
      (setf (svref array i)  (expt 5 i)))
    (dotimes (i (floor 324 12))
      (setf (svref array (+ i 12)) (expt 5 (* 12 (1+ i)))))))


(provide 'numbers)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/numbers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/pathnames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2001 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;pathnames.lisp Pathnames for Coral Common LISP
(in-package "CCL")

(eval-when (eval compile)
  (require 'level-2)
  (require 'backquote)
)
;(defconstant $accessDenied -5000) ; put this with other errnos
(defconstant $afpAccessDenied -5000) ; which name to use?


#-BOOTSTRAPPED ;; get rid of this once bootstrapped
(progn
(unless (fboundp 'native-to-filename) (fset 'native-to-filename #'identity))
(unless (fboundp 'native-to-namestring) (fset 'native-to-namestring #'identity)))

;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
;ANSI CL logical pathnames


(defvar *pathname-translations-pathname*
  (make-pathname :host "ccl" :type "pathname-translations"))

(defun load-logical-pathname-translations (host)
  ;(setq host (verify-logical-host-name host))
  (when (not (%str-assoc host %logical-host-translations%))
    (setf (logical-pathname-translations host)
          (with-open-file (file (merge-pathnames (make-pathname :name host :defaults nil)
                                                 *pathname-translations-pathname*)
                                :element-type 'base-char)
            (read file)))
    T))

(defun back-translate-pathname (path &optional hosts)
  (let ((newpath (back-translate-pathname-1 path hosts)))
    (cond ((equalp path newpath)
	   ;; (fcomp-standard-source path)
	   (namestring (pathname path)))
          (t newpath))))


(defun back-translate-pathname-1 (path &optional hosts)
  (dolist (host %logical-host-translations%)
    (when (or (null hosts) (member (car host) hosts :test 'string-equal))
      (dolist (trans (cdr host))
        (when (pathname-match-p path (cadr trans))
          (let* ((src (car trans)) newpath)
            ;; Force host in backtranslated path
            (when (null (pathname-host src))
              (setq src (make-pathname :host (car host) :defaults src)))
            (setq newpath (translate-pathname path (cadr trans) src :reversible t))
            (return-from back-translate-pathname-1 
              (if  (equalp path newpath) path (back-translate-pathname-1 newpath hosts))))))))
  path)



; must be after back-translate-pathname
(defun physical-pathname-p (path)
  (let* ((path (pathname path))
         (dir (pathname-directory path)))
    (and dir
         (or (not (logical-pathname-p path))
             (not (null (memq (pathname-host path) '(nil :unspecific))))))))



;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
;File or directory Manipulations

(defun unix-rename (old-name new-name)
  (with-filename-cstrs ((old old-name)
			(new new-name))
    #+windows-target
    (#__wunlink new)
    (let* ((res #-windows-target (#_rename old new)
		#+windows-target (#__wrename old new)))
      (declare (fixnum res))
      (if (zerop res)
        (values t nil)
        (values nil (%get-errno))))))

(defun rename-file (file new-name &key (if-exists :error))
  "Rename FILE to have the specified NEW-NAME. If FILE is a stream open to a
  file, then the associated file is renamed."
  (let* ((original (truename file))
	 (original-namestring (defaulted-native-namestring original))
	 (new-name (merge-pathnames new-name (merge-pathnames file)))
	 (new-namestring (defaulted-native-namestring new-name)))
    (unless new-namestring
      (error "~S can't be created." new-name))
    (unless (and (probe-file new-name)
		 (not (if-exists if-exists new-name)))
      (multiple-value-bind (res error)
	                   (unix-rename original-namestring
					new-namestring)
	(unless res
	  (error "Failed to rename ~A to ~A: ~A"
		 original new-name error))
	(when (streamp file)
	  (setf (stream-filename file)
		(namestring (native-to-pathname new-namestring))))
	(values new-name original (truename new-name))))))

(defun copy-file (source-path dest-path &key (if-exists :error) (if-does-not-exist :create)
			      (preserve-attributes nil))
  (let* ((original (truename source-path))
	 (new-name (merge-pathnames dest-path original))
         (buffer (make-array 4096 :element-type '(unsigned-byte 8))))
    (with-open-file (in original :direction :input
                        :element-type '(unsigned-byte 8))
      (with-open-file (out new-name :direction :output
                           :if-exists if-exists
                           :if-does-not-exist if-does-not-exist
                           :element-type '(unsigned-byte 8))
        (when (null out) (return-from copy-file nil)) ;; :if-exists nil
        (loop
          as n = (stream-read-vector in buffer 0 4096) until (eql n 0)
          do (stream-write-vector out buffer 0 n))))
    (when preserve-attributes
      (copy-file-attributes original new-name))
    (values new-name original (truename new-name))))

(defun recursive-copy-directory (source-path dest-path &key test (if-exists :error))
  ;; TODO: Support :if-exists :supersede to blow away any files not in source dir
  (assert (directoryp source-path)(source-path)
          "source-path is not a directory in RECURSIVE-COPY-DIRECTORY")
  (setq if-exists (require-type if-exists '(member :overwrite :error)))
  (setq dest-path (ensure-directory-pathname dest-path))
  (when (eq if-exists :error)
    (when (probe-file dest-path)
      (if-exists if-exists dest-path))
    ;; Skip the probe-file in recursive calls, we already know it's ok.
    (setq if-exists :overwrite))
  (let* ((source-dir (ensure-directory-pathname source-path))
         (pattern (make-pathname :name :wild :type :wild :defaults source-dir))
         (source-files (directory pattern :test test :directories t :files t)))
    (ensure-directories-exist dest-path)
    (dolist (f source-files)
      (when (or (null test) (funcall test f))
        (if (directory-pathname-p f)
            (let ((dest-file (make-pathname :name (first (last (pathname-directory f)))
                                            :defaults dest-path)))
              (recursive-copy-directory f dest-file :test test :if-exists if-exists))
            (let* ((dest-file (make-pathname :name (pathname-name f)
                                             :type (pathname-type f)
                                             :defaults dest-path)))
              (copy-file f dest-file :if-exists :supersede :preserve-attributes t)))))))

(defun delete-empty-directory (path)
  (let* ((namestring (defaulted-native-namestring path))
	 (err (%rmdir namestring)))
    (or (eql 0 err) (signal-file-error err path))))

(defun delete-directory (path)
  "Delete specified directory and all its contents."
  (let ((namestring (defaulted-native-namestring path)))
    (if (eq :directory (%unix-file-kind namestring t))
      (let* ((dir (ensure-directory-pathname path))
	     (wild (make-pathname :name :wild :type :wild :defaults dir))
	     (files (directory wild :directories nil :files t
			       :follow-links nil :include-emacs-lockfiles t))
	     (subdirs (directory wild :directories t :files nil
				 :follow-links nil
				 :include-emacs-lockfiles t)))
	(dolist (f files)
	  (delete-file f))
	(dolist (d subdirs)
	  (delete-directory d))
	(delete-empty-directory path))
      (error "~s is not a directory" path))))

;;; use with caution!
;;; blows away a directory and all its contents
(defun recursive-delete-directory (path &key (if-does-not-exist :error))
  (setq path (make-pathname :name nil :type nil
                            :defaults (merge-pathnames (ensure-directory-pathname path))))
  (setq if-does-not-exist (require-type if-does-not-exist '(member :error nil)))
  (when (eq if-does-not-exist :error)
    (unless (probe-file path)
      (if-does-not-exist if-does-not-exist path)))
  (when (probe-file path)
      (if (directoryp path)
	  ;; it's a directory: blow it away
	  (let* ((pattern (make-pathname :name :wild :type :wild :defaults path))
		 (files (directory pattern :directories nil :files t))
		 (subdirs (directory pattern :directories t :files nil))
		 (target-pathname (defaulted-native-namestring path)))
	    (dolist (f files)
	      (delete-file f))
	    (dolist (d subdirs)
	      (recursive-delete-directory d :if-does-not-exist if-does-not-exist))
	    (%rmdir target-pathname))
	  ;; it's not a directory: for safety's sake, signal an error
	  (error "Pathname '~A' is not a directory" path))))

;;; It's not clear that we can support anything stronger than
;;; "advisory" ("you pretend the file's locked & I will too") file
;;; locking under Darwin.




(defun create-directory (path &key (mode #o777))
  (let* ((pathname (translate-logical-pathname (merge-pathnames path)))
	 (created-p nil)
	 (parent-dirs (let* ((pd (pathname-directory pathname)))
			(if (eq (car pd) :relative)
			  (pathname-directory (merge-pathnames
					       pathname
					       (mac-default-directory)))
			  pd)))
	 (nparents (length parent-dirs)))
    (when (wild-pathname-p pathname)
      (error 'file-error :error-type "Inappropriate use of wild pathname ~s"
	     :pathname pathname))
    (do* ((i 1 (1+ i)))
	 ((> i nparents) (values pathname created-p))
      (declare (fixnum i))
      (let* ((parent (make-pathname
		      :name :unspecific
		      :type :unspecific
		      :host (pathname-host pathname)
		      :device (pathname-device pathname)
		      :directory (subseq parent-dirs 0 i)))
	     (parent-name (defaulted-native-namestring parent))
	     (parent-kind (%unix-file-kind parent-name)))

	(if parent-kind
	  (unless (eq parent-kind :directory)
	    (error 'simple-file-error
		   :error-type "Can't create directory ~s, since file ~a exists and is not a directory"
		   :pathname pathname
		   :format-arguments (list parent-name)))
	  (let* ((result (%mkdir parent-name mode)))
	    (declare (fixnum result))
	    (if (< result 0)
	      (signal-file-error result parent-name)
	      (setq created-p t))))))))


(defun ensure-directories-exist (pathspec &key verbose (mode #o777))
  "Test whether the directories containing the specified file
  actually exist, and attempt to create them if they do not.
  The MODE argument is an extension to control the Unix permission
  bits.  Portable programs should avoid using the :MODE keyword
  argument."
  (let ((pathname (let ((pathspec (translate-logical-pathname (merge-pathnames pathspec))))
		    (make-directory-pathname :device (pathname-device pathspec)
					     :directory (pathname-directory pathspec))))
	(created-p nil))
    (when (wild-pathname-p pathname)
      (error 'file-error
	     :error-type "Inappropriate use of wild pathname ~s"
	     :pathname pathname))
    (let ((dir (pathname-directory pathname)))
      (if (eq (car dir) :relative)
	(setq dir (pathname-directory (merge-pathnames
				       pathname
				       (mac-default-directory)))))
      (loop for i from 1 upto (length dir)
	    do (let ((newpath (make-pathname
			       :name :unspecific
			       :type :unspecific
			       :host (pathname-host pathname)
			       :device (pathname-device pathname)
			       :directory (subseq dir 0 i))))
		 (unless (probe-file newpath)
		   (let ((namestring (native-translated-namestring newpath)))
		     (when verbose
		       (format *standard-output* "~&Creating directory: ~A~%"
			       namestring))
		     (%mkdir namestring mode)
		     (unless (probe-file newpath)
		       (error 'file-error
			      :pathname namestring
			      :error-type "Can't create directory ~S."))
		     (setf created-p t)))))
      (values pathspec created-p))))

(defun dirpath-to-filepath (path)
  (setq path (translate-logical-pathname (merge-pathnames path)))
  (let* ((dir (pathname-directory path))
         (super (butlast dir))
         (name (car (last dir))))
    (when (eq name :up)
      (setq dir (remove-up (copy-list dir)))
      (setq super (butlast dir))
      (setq name (car (last dir))))
    (when (null super)
      (signal-file-error $xnocreate path))
    (setq path (make-pathname :directory super :name name :defaults nil))))

(defun filepath-to-dirpath (path)
  (let* ((dir (pathname-directory path))
         (rest (file-namestring path)))
    (make-pathname :directory (append dir (list rest)) :defaults nil)))
  


;Takes a pathname, returns the truename of the directory if the pathname
;names a directory, NIL if it names an ordinary file, error otherwise.
;E.g. (directoryp "ccl;:foo:baz") might return #P"hd:mumble:foo:baz:" if baz
;is a dir. - should we doc this - its exported?
(defun directoryp (path)
  (let* ((native (defaulted-native-namestring path))
	 (realpath (%realpath native)))
    (if realpath (eq (%unix-file-kind realpath) :directory))))
	 

;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
;Wildcards



 
;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
;Directory Traversing

(defun %path-cat (device dir subdir)
  (if device
      (%str-cat device ":" dir subdir)
    (%str-cat dir subdir)))

(defmacro with-open-dir ((dirent device dir state follow-links) &body body)
  (let* ((namestring (gensym)))
    `(let* ((,namestring (native-translated-namestring (make-pathname :device ,device :directory ,dir :defaults nil))))
      (when (%new-directory-p ,namestring ,follow-links ,state)
        (let* ((,dirent (%open-dir ,namestring)))
          (when ,dirent
            (unwind-protect
                 (progn ,@body)
              (close-dir ,dirent))))))))

(defun path-is-link (path)
  "Returns T if PATH is a (hard or symbolic) link, NIL otherwise."
  ;; Actually, it's a bit more subtle than that; it basically
  ;; returns information about the last component of PATH.  If
  ;; some enclosing directory name is a link but the last component
  ;; isn't, this'll return false.
  (eq (%unix-file-kind (native-translated-namestring path) t) :link))

(defstruct (directory-result (:constructor %make-directory-result))
  (truenames (make-hash-table :shared nil :test 'string= :hash-function 'sxhash))
  (directories-seen ()))


;;; If no component of the pathname involves a link we could avoid the call to
;;; TRUENAME here.  Later ...
(defun %add-directory-result (path result follow-links &optional followed-some-links)
  (declare (ignore followed-some-links))
  (let* ((truename (if follow-links (truename path) path))
         (namestring (namestring truename))
         (truenames (directory-result-truenames result)))
    (or (gethash namestring truenames)
        (setf (gethash namestring truenames) truename))))
    

(defun %process-directory-result (result)
  (collect ((pairs))
    (maphash (lambda (namestring truename) (pairs (cons namestring truename))) (directory-result-truenames result))
    (mapcar #'cdr (sort (pairs) #'string< :key #'car))))

(defun %new-directory-p (native-namestring follow-links result)
  (multiple-value-bind (win mode size mtime inode uid blocksize rmtime  gid dev)
      (%stat native-namestring (not follow-links))
    (declare (ignore size mtime uid blocksize rmtime gid #+windows-target inode #+windows-target dev))
    (when (and win (= (logand mode #$S_IFMT) #$S_IFDIR))
      #+windows-target
      (let* ((dirname (namestring (truename (native-to-pathname native-namestring)))))
        (unless (member dirname (directory-result-directories-seen result) :test #'string=)
          (push dirname (directory-result-directories-seen result))
          t))
      #-windows-target
      (when (dolist (pair (directory-result-directories-seen result) t)
              (when (and (eql inode (car pair))
                         (eql dev (cdr pair)))
                (return)))
        (push (cons inode dev) (directory-result-directories-seen result))
        t))))

  
(defun directory (path &key (directories t) ;; include subdirectories
                            (files t)         ;; include files
			    (all t)           ;; include Unix dot files (other than dot and dot dot)
			    (directory-pathnames t) ;; return directories as directory-pathname-p's.
                            (include-emacs-lockfiles nil) ;; inculde .#foo
			    test              ;; Only return pathnames matching test
			    (follow-links t)) ;; return truename's of matching files.
  "Return a list of PATHNAMEs, each the TRUENAME of a file that matched the
   given pathname. Note that the interaction between this ANSI-specified
   TRUENAMEing and the semantics of the Unix filesystem (symbolic links..)
   means this function can sometimes return files which don't have the same
   directory as PATHNAME."
  (let* ((keys (list :directories directories ;list defaulted key values
		     :files files
		     :all all
		     :directory-pathnames directory-pathnames
		     :test test
                     :include-emacs-lockfiles include-emacs-lockfiles
		     :follow-links follow-links))
	 (path (full-pathname (merge-pathnames path) :no-error nil))
	 (dir (directory-namestring path)))
    (declare (dynamic-extent keys))
    (if (null (pathname-directory path))
      (setq dir (directory-namestring (setq path
					    (merge-pathnames path
							     (mac-default-directory))))))
    (assert (eq (car (pathname-directory path)) :absolute) ()
	    "full-pathname returned relative path ~s??" path)
    (%process-directory-result (%directory "/" dir path '(:absolute) keys (%make-directory-result)))))

(defun %directory (native-dir rest path so-far keys result)
  (multiple-value-bind (native-sub-dir wild rest) (%split-dir rest)
    (%some-specific native-dir native-sub-dir wild rest path so-far keys result)))

(defun %some-specific (native-dir native-sub-dir wild rest path so-far keys result)
  (let* ((start 1)
	 (end (length native-sub-dir))
	 (native-full-dir (if (eq start end) native-dir (%str-cat native-dir (%substr native-sub-dir start end)))))
    (while (neq start end)
      (let ((pos (position #\/ native-sub-dir :start start :end end)))
	(push (native-to-filename (%substr native-sub-dir start pos)) so-far)
	(setq start (%i+ 1 pos))))
    (cond ((null wild)
	   (%files-in-directory native-full-dir path so-far keys result))
	  ((string= wild "**")
	   (%all-directories native-full-dir rest path so-far keys result))
	  (t (%one-wild native-full-dir wild rest path so-far keys result)))))

; for a * or *x*y
(defun %one-wild (native-dir wild rest path so-far keys result)
  (let ((device (pathname-device path))
	(all (getf keys :all))
        (follow-links (getf keys :follow-links))
        (dir (native-to-namestring native-dir))
	name)
    (with-open-dir (dirent device dir result follow-links)
      (while (setq name (%read-dir dirent))
	(when (and (or all (neq (%schar name 0) #\.))
		   (not (string= name "."))
		   (not (string= name ".."))
		   (%path-str*= name wild)
		   (eq (%unix-file-kind (%path-cat device native-dir name) (not follow-links)) :directory))
	  (let ((native-subdir (%path-cat nil native-dir name))
                (so-far (cons (native-to-filename name) so-far)))
	    (declare (dynamic-extent so-far))
            (%directory (%str-cat native-subdir "/") rest path so-far keys result)))))
    result))

(defun %files-in-directory (native-dir path so-far keys result)
  (let ((device (pathname-device path))
        (name (pathname-name path))
        (type (pathname-type path))
	(directories (getf keys :directories))
	(files (getf keys :files))
	(directory-pathnames (getf keys :directory-pathnames))
	(test (getf keys :test))
	(follow-links (getf keys :follow-links))
	(all (getf keys :all))
        (include-emacs-lockfiles (getf keys :include-emacs-lockfiles))
        (dir (native-to-namestring native-dir))
        native-sub dir-list ans)
    (if (not (or name type))
      (let (full-path)
	(when (and directories
		   (eq (%unix-file-kind (native-translated-namestring (setq full-path (%cons-pathname (reverse so-far) nil nil nil device)))
					(not follow-links))
		       :directory))
	  (setq ans (if directory-pathnames full-path
		      (%cons-pathname (reverse (cdr so-far)) (car so-far) nil nil device)))
	  (when (and ans (or (null test) (funcall test ans)))
            (%add-directory-result ans result follow-links))))
      (with-open-dir (dirent (pathname-device path) dir result follow-links)
	(while (setq native-sub (%read-dir dirent))
	  (when (and (or all (neq (%schar native-sub 0) #\.))
                     (or include-emacs-lockfiles
                         (< (length native-sub) 2)
                         (not (string= native-sub ".#" :end1 2)))
		     (not (string= native-sub "."))
		     (not (string= native-sub ".."))
		     (%file*= name type native-sub))
	    (setq ans
		  (if (eq (%unix-file-kind (%path-cat device native-dir native-sub) (not follow-links)) :directory)
		    (when directories
		      (let* ((std-sub (native-to-filename native-sub)))
			(if directory-pathnames
			  (%cons-pathname (reverse (cons std-sub so-far)) nil nil nil device)
			  (%cons-pathname (or dir-list (setq dir-list (reverse so-far))) std-sub nil nil device))))
		    (when files
		      (multiple-value-bind (name type) (%std-name-and-type native-sub)
			(%cons-pathname (or dir-list (setq dir-list (reverse so-far))) name type nil device)))))
	    (when (and ans (or (null test) (funcall test ans)))
	      (%add-directory-result ans result follow-links))))))
    result))

(defun %all-directories (native-dir rest path so-far keys result)
  (let ((do-files nil)
        (do-dirs nil)
        (device (pathname-device path))
        (name (pathname-name path))
        (type (pathname-type path))
	(all (getf keys :all))
	(test (getf keys :test))
	(directory-pathnames (getf keys :directory-pathnames))
	(follow-links (getf keys :follow-links))
	sub native-sub dir-list ans)
    ;; First process the case that the ** stands for 0 components
    (multiple-value-bind (native-next-dir next-wild next-rest) (%split-dir rest)
      (while (and next-wild ; Check for **/**/ which is the same as **/
		  (string= native-next-dir "/")
		  (string= next-wild "**"))
        (setq rest next-rest)
        (multiple-value-setq (native-next-dir next-wild next-rest) (%split-dir rest)))
      (cond ((not (string= native-next-dir "/"))
	     (%some-specific native-dir native-next-dir next-wild next-rest path so-far keys result))
	    (next-wild
             (%one-wild native-dir next-wild next-rest path so-far keys result))
	    ((or name type)
	     (when (getf keys :files) (setq do-files t))
	     (when (getf keys :directories) (setq do-dirs t)))
	    (t (when (getf keys :directories)
		 (setq sub (if directory-pathnames
			     (%cons-pathname (setq dir-list (reverse so-far)) nil nil nil device)
			     (%cons-pathname (reverse (cdr so-far)) (car so-far) nil nil device)))
		 (when (or (null test) (funcall test sub))
                   (%add-directory-result sub result follow-links))))))
    ;; now descend doing %all-dirs on dirs and collecting files & dirs
    ;; if do-x is t
    (with-open-dir (dirent device (native-to-namestring native-dir) result follow-links)
      (while (setq native-sub (%read-dir dirent))
        (when (and (or all (neq (%schar native-sub 0) #\.))
                   (not (string= native-sub "."))
		   (not (string= native-sub "..")))
	  (if (eq (%unix-file-kind (%path-cat device native-dir native-sub) (not follow-links)) :directory)
	    (let* ((native-subfile (%path-cat nil native-dir native-sub))
		   (std-sub (native-to-filename native-sub))
		   (so-far (cons std-sub so-far))
		   (native-subdir (%str-cat native-subfile  "/")))
	      (declare (dynamic-extent so-far))
	      (when (and do-dirs (%file*= name type native-sub))
		(setq ans (if directory-pathnames
			    (%cons-pathname (reverse so-far) nil nil nil device)
			    (%cons-pathname (or dir-list (setq dir-list (reverse (cdr so-far))))
					    std-sub nil nil device)))
		(when (or (null test) (funcall test ans))
		  (%add-directory-result ans result follow-links)))
              (%all-directories native-subdir rest path so-far keys result))
	    (when (and do-files (%file*= name type native-sub))
	      (multiple-value-bind (name type) (%std-name-and-type native-sub)
		(setq ans (%cons-pathname (or dir-list (setq dir-list (reverse so-far))) name type nil device))
		(when (or (null test) (funcall test ans))
		  (%add-directory-result ans result follow-links))))))))
    result))

(defun %split-dir (dir &aux pos)                 ; dir ends in a "/".
  ;"/foo/bar/../x*y/baz/../z*t/"  ->  "/foo/bar/../" "x*y" "/baz/../z*t/",
  ;  where the first value is native, second and third are escaped.
  (if (null (setq pos (%path-mem "*" dir)))
    (if (%path-mem-last-quoted "/" dir)
      (signal-file-error $xbadfilenamechar dir #\/)
      (values (namestring-unquote dir) nil nil))
    (let (epos (len (length dir)))
      (setq pos (if (setq pos (%path-mem-last "/" dir 0 pos)) (%i+ pos 1) 0)
            epos (%path-mem "/" dir pos len))
      (when (%path-mem-last-quoted "/" dir 0 pos)
	(signal-file-error $xbadfilenamechar dir #\/))
      (values (unless (%izerop pos) (namestring-unquote (%substr dir 0 pos)))
              (%substr dir pos epos)
              (%substr dir epos len)))))

(defun %file*= (name-pat type-pat pstr)
  (when (and (eq name-pat :wild)
             (or (null type-pat)
                 (eq type-pat :unspecific)))
    (setq type-pat :wild))
  (if (eq name-pat :wild) (setq name-pat "*"))
  (if (eq type-pat :wild) (setq type-pat "*"))
  (when (and (null name-pat) (null type-pat))
    (return-from %file*= T))
  (let* ((end (length pstr))
	 (pos (position #\. pstr :from-end t))
	 (type (and pos (%substr pstr (%i+ pos 1) end)))
	 (name (unless (eq (or pos end) 0) (if pos (%substr pstr 0 pos) pstr))))
    (and (cond ((or (eq name-pat :unspecific) (null name-pat)) (null name))
	       (t (%path-str*= (or name "") name-pat)))
	 (cond ((or (null type-pat) (eq type-pat :unspecific)) (null type))
	       (t (%path-str*= (or type "") type-pat))))))

(provide "PATHNAMES")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/pathnames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/print-db.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defmacro print-db (&rest forms &aux)
  `(multiple-value-prog1
     (progn ,@(print-db-aux forms))
     (terpri *trace-output*)))

(defun print-db-aux (forms)
   (when forms
     (cond ((stringp (car forms))
            `((print ',(car forms) *trace-output*)
              ,@(print-db-aux (cdr forms))))
           ((null (cdr forms))
            `((print ',(car forms) *trace-output*)
              (let ((values (multiple-value-list ,(car forms))))
                (prin1 (car values) *trace-output*)
                (apply #'values values))))
           (t `((print ',(car forms) *trace-output*)
                (prin1 ,(car forms) *trace-output*)
                ,@(print-db-aux (cdr forms)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/print-db.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/read.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")


                         


(defun signal-reader-error (input-stream format-string &rest format-args)
  (error 'simple-reader-error :stream input-stream
         :format-control format-string :format-arguments format-args))

#| ; Can't see any reason to leave this in
(defun read-file-to-list (file &aux result)
   ;(print-db (setq file (prepend-default-dir file)))   
   (with-open-file (stream file :direction :input)
       (setq result (read-file-to-list-aux stream)))
   result)

(defun read-file-to-list-aux (stream)
   (if (eofp stream)
        nil
       (let ((form (read stream nil *eof-value* nil)))
            ;(%print "just read " form)
           (if (eq form *eof-value*)
                nil
               (cons form (read-file-to-list-aux stream))))))
|#

(set-dispatch-macro-character #\# #\*
 (qlfun |#*-reader| (input-stream sub-char int 
   &aux list list-length array array-length last-bit)
  (declare (ignore sub-char))
  (do* ((char (read-char input-stream nil nil t)
              (read-char input-stream nil nil t))
        (attr 0))
       ((or (null char)
            (= $cht_tmac (setq attr (%character-attribute char (rdtab.ttab *readtable*))))
            (= $cht_wsp attr))
        (if char (unread-char char input-stream)))
    (declare (type (unsigned-byte 8) attr))
    (let ((number (- (char-code char) 48)))
      (if (or (<= 0 number 1) *read-suppress*)
          (setq list (cons number list))
          (signal-reader-error input-stream "reader macro #* got illegal character ~S" char))))
  (setq last-bit (car list))
  (setq list (nreverse list))
  (setq list-length (list-length list))
  (if (not (integerp int))
      (setq int list-length))
  (cond (*read-suppress* nil)
        ((and (= 0 list-length) (> int 0))
         (signal-reader-error input-stream "reader macro #~S* needs something" int))
        ((> list-length int)
         (signal-reader-error input-stream "reader macro #~S* can't fit ~S" int list))
        (t (setq array-length (if int int list-length))
           (setq array (make-array array-length :element-type 'bit))
           (do ((i 0 (1+ i))
                (bit-list list (cdr bit-list)))
               ((>= i array-length))
             (aset array i (if bit-list
                               (car bit-list)
                               last-bit)))
           array))))

(set-dispatch-macro-character #\# #\A
 (qlfun |#A-reader| (stream ignore dimensions)
   (declare (ignore ignore))
   (cond (*read-suppress*
          (read stream () () t)
          nil)
         ((not dimensions)
          (signal-reader-error stream "reader macro #A used without a rank integer"))
         ((eql dimensions 0) ;0 dimensional array
          (make-array nil :initial-contents (read-internal stream t nil t)))
         ((and (integerp dimensions) (> dimensions 0)) 
          (let ((initial-contents (read-internal stream t nil t)))
            (cond ((not (typep initial-contents 'sequence))
                   (signal-reader-error stream "The form following a #~SA reader macro should have been a sequence, but it was: ~S" dimensions initial-contents))
                  ((= (length initial-contents) 0)
                   (make-array (make-list dimensions :initial-element 0)))
                  ((= dimensions 1)
                   (make-array (length initial-contents) :initial-contents initial-contents))
                  (t
                   (let ((dlist (make-list dimensions)))
                     (do ((dl dlist (cdr dl))
                          (il initial-contents (if (> (length il) 0)
                                                 (etypecase il
                                                   (list (car il))
                                                   (vector (aref il 0))))))
                         ((null dl))
                       (rplaca dl (length il)))
                     (make-array dlist :initial-contents initial-contents))))))
         (t (signal-reader-error stream "Dimensions argument to #A not a non-negative integer: ~S" dimensions)))))

(set-dispatch-macro-character #\# #\S
  (qlfun |#S-reader| (input-stream sub-char int &aux list sd)
     (declare (ignore sub-char int))
     (setq list (read-internal input-stream t nil t))
     (unless *read-suppress*
       (unless (and (consp list)
                    (symbolp (%car list))
                    (setq sd (gethash (%car list) %defstructs%))
		    (setq sd (sd-constructor sd)))
         (error "Can't initialize structure from ~S." list))
       (let ((args ()) (plist (cdr list)))
         (unless (plistp plist) (report-bad-arg plist '(satisfies plistp)))
         (while plist
           (push (make-keyword (pop plist)) args)
           (push (pop plist) args))
         (apply sd (nreverse args))))))

;;;from slisp reader2.lisp, and apparently not touched in 20 years.
(defun parse-integer (string &key (start 0) end (radix 10) junk-allowed)
  "Examine the substring of string delimited by start and end
  (default to the beginning and end of the string)  It skips over
  whitespace characters and then tries to parse an integer. The
  radix parameter must be between 2 and 36."
  (flet ((parse-integer-not-integer-string (s)
	   (error 'parse-integer-not-integer-string :string s)))
    (declare (inline parse-integer-not-integer-string))
    (unless (typep string 'string)
      (setq string (require-type string 'string)))
    (setq end (check-sequence-bounds string start end))
    (setq radix (%validate-radix radix))
    (let ((index (do ((i start (1+ i)))
		     ((= i end)
		      (if junk-allowed
                        (return-from parse-integer (values nil end))
                        (parse-integer-not-integer-string string)))
                   (unless (whitespacep (char string i)) (return i))))
          (minusp nil)
          (found-digit nil)
          (result 0))
      (declare (fixnum start end radix))
      (let ((char (char string index)))
        (cond ((char= char #\-)
               (setq minusp t)
               (setq index (1+ index)))
              ((char= char #\+)
               (setq index (1+ index)))))
      (loop
        (when (= index end) (return nil))
        (let* ((char (char string index))
               (weight (digit-char-p char radix)))
	  (cond (weight
		 (setq result (+ weight (* result radix))
		       found-digit t))
		(junk-allowed (return nil))
		((whitespacep char)
		 (until (eq (setq index (1+ index)) end)
		   (unless (whitespacep (char string index))
		     (parse-integer-not-integer-string string)))
		 (return nil))
		(t
		 (parse-integer-not-integer-string string))))
	(setq index (1+ index)))
      (values
       (if found-digit
	 (if minusp (- result) result)
	 (if junk-allowed
	   nil
	   (parse-integer-not-integer-string string)))
       index))))

(defun get-read-object (arg)
  (if (listp %read-objects%)
    (assoc arg %read-objects%)
    (gethash arg %read-objects%)))

(defparameter *read-objects-hash-threshold* 30)

(defun note-read-object (data)
  (let* ((lab (car data)))
    (if (get-read-object lab)
      (%err-disp $xduprdlbl lab)
      (if (listp %read-objects%)
        (if (< (length %read-objects%) *read-objects-hash-threshold*)
          (push data %read-objects%)
          (let* ((hash (make-hash-table :test #'eql :shared nil :rehash-size 2.0)))
            (dolist (info %read-objects%)
              (let* ((lab (car info)))
                (setf (gethash lab hash) info)))
            (setf (gethash lab hash) data)
            (setq %read-objects% hash)))
        (setf (gethash lab %read-objects%) data)))))


    

(set-dispatch-macro-character #\# #\#
  #'(lambda (stream char arg)
      (declare (ignore stream))
      (if *read-suppress* 
        nil
        (if arg
          (let ((pair (get-read-object arg)))
            (if pair
              (let* ((cell (cdr pair)))
                (setf (car cell) t)
                (cdr cell))
              (%err-disp $xnordlbl arg)))
          (%err-disp $xrdndarg char)))))

(set-dispatch-macro-character 
 #\# 
 #\=
 #'(lambda (stream char arg &aux lab form)
     (cond (*read-suppress* (values))
           ((null arg) (%err-disp $xrdndarg char))
           (t (setq lab (cons arg nil))
              (%rplacd lab (cons nil lab))
              (note-read-object lab)
              (setq form (read stream t nil t))
              (when (eq form lab)       ;#n= #n#.  No can do.
                (%err-disp $xnordlbl (%car lab)))
              (%rplacd (cdr lab) form)
              (let* ((reffed (cadr lab)))
                (if (not reffed)
                  form
                  (let ((scanned nil))
                    (labels ((circle-subst (tree)
                               (if (eq tree lab)
                                 (progn
                                   (unless (memq tree scanned)
                                     (setq scanned (%temp-cons tree scanned))
                                     (circle-subst (cddr tree)))
                                   (cddr tree))
                                 (progn
                                   (cond ((consp tree)
                                          (unless (memq tree scanned)
                                            (push tree scanned)
                                            (locally 
                                                (declare (type cons tree))
                                              (let* ((orig (car tree))
                                                     (new (circle-subst orig)))
                                                (unless (eq orig new)
                                                  (rplaca tree new))
                                                (setq orig (cdr tree)
                                                      new (circle-subst orig))
                                                (unless (eq orig new)
                                                  (rplacd tree new))))))
                                         ((let* ((typecode (typecode tree)))
                                            (declare (type (unsigned-byte 8) typecode))
                                            (or (= typecode target::subtag-simple-vector)
                                                (= typecode target::subtag-struct)
                                                (= typecode target::subtag-arrayH)))
                                          (unless (memq tree scanned)
                                            (push tree scanned)
                                            (let* ((n (uvsize tree)))
                                              (declare (fixnum n))
                                              (do* ((i (if (eql (typecode tree) target::subtag-struct) 1 0) (1+ i)))
                                                   ((= i n))
                                                (declare (fixnum i))
                                                (let* ((old (%svref tree i))
                                                       (new (circle-subst old)))
                                               (unless (eq old new)
                                                 (setf (%svref tree i) new))))))))
                                   tree))))
                      (declare (dynamic-extent #'circle-subst))
                      (circle-subst form)))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/read.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/sort.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Sort

;;; sorts a sequence destructively using a predicate which must be a
;;;  of two arguments which returns non-() only if the first argument is
;;;  strictly less than the second.  The keyfun (if present) must be a
;;;  function of one argument.  The predicate is applied to keyfun of the
;;;  sequence elements, or directly to the elements if the keyfun is not
;;;  given.

;;; Sort dispatches to type specific sorting routines.

(in-package "CCL")

(defun sort (sequence predicate &key key)
  "Returns SEQUENCE, which has been modified to be in order.
   If sequence is a displaced array, sorts just that portion of the
   data-array which is part of SEQUENCE."
  (if (< (length sequence) 2)
    sequence
    (if (listp sequence)
      (sort-list sequence predicate key)
      (quick-sort-vector sequence predicate key))))

(defun stable-sort (sequence predicate &key key)
  "Returns SEQUENCE, which has been modified to be in order.
   If sequence is a displaced array, sorts just that portion of the
   data-array which is part of SEQUENCE."
  (if (< (length sequence) 2)
    sequence
    (if (listp sequence)
      (sort-list sequence predicate key)
      (merge-sort-vector sequence predicate key))))


;;; Vector sorting.
;;; The quick-sort is a little slower than the merge-sort, but it doesn't cons.
;;; The merge-sort is stable.
;;; Note that there are three version of each:
;;;   AREF for non-simple (eventually) vectors.
;;;   %SVREF with a key.
;;;   %SVREF without a key.
;;; Other than that, the three versions are duplicates.
(defun merge-sort-vector (vector pred key)
  (canonicalize-pred-and-key)
  (let* ((end (length vector)))
    (when (> end 1)
      (multiple-value-bind (real-vector start) 
                           (array-data-and-offset vector)
        (incf end start)
        (unless (fixnump end)
          (error "Sorry, can't sort vectors larger than ~d." most-positive-fixnum))
        (let* ((temp-array (make-array (the fixnum end))))
          (declare (dynamic-extent temp-array))
          (if (simple-vector-p real-vector)
            (if key
              (%merge-sort-simple-vector
               real-vector start end pred key temp-array nil)
              (%merge-sort-simple-vector-no-key
               real-vector start end pred temp-array nil))
            (%merge-sort-vector real-vector start end pred key temp-array nil))))))
  vector)

(defun quick-sort-vector (vector pred key)
  (canonicalize-pred-and-key)
  (let ((end (length vector)))
    (when (> end 1)
      (multiple-value-bind (real-vector start) 
                           (array-data-and-offset vector)
        (incf end (%i- start 1))
; No vector should have a length that's not  a fixnum.
        '(unless (fixnump end)
          (error "Sorry, can't sort vectors larger than ~d." most-positive-fixnum))
        (if (simple-vector-p real-vector)
          (if key
            (%quick-sort-simple-vector real-vector start end pred key)
            (%quick-sort-simple-vector-no-key real-vector start end pred))
          (%quick-sort-vector
           real-vector start end pred (or key #'identity))))))
  vector)

;;; merge-sort internals

(defun %merge-sort-vector (vector start end pred key
                                  temp-vec res-temp?)
  ;; If somebody wanted to do it, half of these arefs can be %svrefs,
  ;; but you'd need two loops in the merge code
  ;; (temp-vec is simple if res-temp? is false).
  ;; But who sorts non-svref'able vectors anyway?
  (let* ((mid (%ilsr 1 (%i+ start end))))
    (if (%i<= (%i- mid 1) start)
      (unless res-temp?
        (setf (aref temp-vec start) (aref vector start)))
      (%merge-sort-vector
       vector start mid pred key temp-vec (not res-temp?)))
    (if (%i>= (%i+ mid 1) end)
      (unless res-temp?
        (setf (aref temp-vec mid) (aref vector mid)))
      (%merge-sort-vector 
       vector mid end pred key temp-vec (not res-temp?)))
    
    (unless res-temp?
      (psetq vector temp-vec temp-vec vector))
    
    (%merge-vectors vector start mid vector mid end temp-vec start pred key)))
    
(defun %merge-sort-simple-vector (vector start end pred key
                                         temp-vec res-temp?)
  (let* ((mid (%ilsr 1 (%i+ start end))))
    (if (%i<= (%i- mid 1) start)
      (unless res-temp?
        (setf (%svref temp-vec start) (%svref vector start)))
      (%merge-sort-simple-vector
       vector start mid pred key temp-vec (not res-temp?)))
    (if (%i>= (%i+ mid 1) end)
      (unless res-temp?
        (setf (%svref temp-vec mid) (%svref vector mid)))
      (%merge-sort-simple-vector 
       vector mid end pred key temp-vec (not res-temp?)))
    
    (unless res-temp?
      (psetq vector temp-vec temp-vec vector))
    
    (%merge-simple-vectors
     vector start mid vector mid end temp-vec start pred key)))

(defun %merge-sort-simple-vector-no-key (vector start end pred
                                                temp-vec res-temp?)
  (let* ((mid (%ilsr 1 (%i+ start end))))
    (if (%i<= (%i- mid 1) start)
      (unless res-temp?
        (setf (%svref temp-vec start) (%svref vector start)))
      (%merge-sort-simple-vector-no-key
       vector start mid pred temp-vec (not res-temp?)))
    (if (%i>= (%i+ mid 1) end)
      (unless res-temp?
        (setf (%svref temp-vec mid) (%svref vector mid)))
      (%merge-sort-simple-vector-no-key
       vector mid end pred temp-vec (not res-temp?)))
    
    (unless res-temp?
      (psetq vector temp-vec temp-vec vector))
    
    (%merge-simple-vectors-no-key
     vector start mid vector mid end temp-vec start pred)))

(defun %merge-vectors (a1 start1 end1 a2 start2 end2
                          out start-out pred key)
  (let* ((i1 start1)
         (i2 start2)
         (i-out start-out)
         v1 v2 k1 k2)
    (cond ((eq start1 end1)
           (when (eq start2 end2)
             (return-from %merge-vectors out))
           (setq i1 start2
                 end1 end2
                 a1 a2
                 v1 (aref a1 i1)))
          ((eq start2 end2)
           (setq i1 start1
                 v1 (aref a1 i1)))
          (t
           (setq v1 (aref a1 i1)
                 v2 (aref a2 i2)
                 k1 (if key (funcall key v1) v1)
                 k2 (if key (funcall key v2) v2))
           (loop (if (funcall pred k2 k1)
                   (progn (setf (aref out i-out) v2
                                i-out (%i+ i-out 1)
                                i2 (%i+ i2 1))
                          (when (eq i2 end2)
                            (return))
                          (setq v2 (aref a2 i2)
                                k2 (if key (funcall key v2) v2)))
                   (progn (setf (aref out i-out) v1
                                i-out (%i+ i-out 1)
                                i1 (%i+ i1 1))
                          (when (eq i1 end1)
                            (setq a1 a2 i1 i2 end1 end2 v1 v2)
                            (return))
                          (setq v1 (aref a1 i1)
                                k1 (if key (funcall key v1) v1)))))))
    (loop
      (setf (aref out i-out) v1
            i1 (%i+ i1 1))
      (if (eq i1 end1) 
        (return out))
      (setq v1 (aref a1 i1)
            i-out (%i+ i-out 1)))))

(defun %merge-simple-vectors (a1 start1 end1 a2 start2 end2
                                 out start-out pred key)
  (let* ((i1 start1)
         (i2 start2)
         (i-out start-out)
         v1 v2 k1 k2)
    (cond ((eq start1 end1)
           (when (eq start2 end2)
             (return-from %merge-simple-vectors out))
           (setq i1 start2
                 end1 end2
                 a1 a2
                 v1 (%svref a1 i1)))
          ((eq start2 end2)
           (setq i1 start1
                 v1 (%svref a1 i1)))
          (t
           (setq v1 (%svref a1 i1)
                 v2 (%svref a2 i2)
                 k1 (if key (funcall key v1) v1)
                 k2 (if key (funcall key v2) v2))
           (loop (if (funcall pred k2 k1)
                   (progn (setf (%svref out i-out) v2
                                i-out (%i+ i-out 1)
                                i2 (%i+ i2 1))
                          (when (eq i2 end2)
                            (return))
                          (setq v2 (%svref a2 i2)
                                k2 (funcall key v2)))
                   (progn (setf (%svref out i-out) v1
                                i-out (%i+ i-out 1)
                                i1 (%i+ i1 1))
                          (when (eq i1 end1)
                            (setq a1 a2 i1 i2 end1 end2 v1 v2)
                            (return))
                          (setq v1 (%svref a1 i1)
                                k1 (funcall key v1)))))))
    (loop
      (setf (%svref out i-out) v1
            i1 (%i+ i1 1))
      (if (eq i1 end1) 
        (return out))
      (setq v1 (%svref a1 i1)
            i-out (%i+ i-out 1)))))

(defun %merge-simple-vectors-no-key (a1 start1 end1 a2 start2 end2
                                        out start-out pred)
  (let* ((i1 start1)
         (i2 start2)
         (i-out start-out)
         v1 v2)
    (cond ((eq start1 end1)
           (when (eq start2 end2)
             (return-from %merge-simple-vectors-no-key out))
           (setq i1 start2
                 end1 end2
                 a1 a2
                 v1 (%svref a1 i1)))
          ((eq start2 end2)
           (setq i1 start1
                 v1 (%svref a1 i1)))
          (t
           (setq v1 (%svref a1 i1)
                 v2 (%svref a2 i2))
           (loop (if (funcall pred v2 v1)
                   (progn (setf (%svref out i-out) v2
                                i-out (%i+ i-out 1)
                                i2 (%i+ i2 1))
                          (when (eq i2 end2)
                            (return))
                          (setq v2 (%svref a2 i2)))
                   (progn (setf (%svref out i-out) v1
                                i-out (%i+ i-out 1)
                                i1 (%i+ i1 1))
                          (when (eq i1 end1)
                            (setq a1 a2 i1 i2 end1 end2 v1 v2)
                            (return))
                          (setq v1 (%svref a1 i1)))))))
    (loop
      (setf (%svref out i-out) v1
            i1 (%i+ i1 1))
      (if (eq i1 end1) 
        (return out))
      (setq v1 (%svref a1 i1)
            i-out (%i+ i-out 1)))))


;;; Quick sort internals
(defun %quick-sort-vector (vector start end pred key)
  (declare (optimize (speed 3) (safety 0)))
  (declare (fixnum start end))
  (if (< start end)
    (let* ((p (the fixnum (+ start (the fixnum (ash (the fixnum (- end start)) -1)))))
           (Ai (aref vector p))
           (x (funcall key Ai))
           (pivot Ai)
           (i start)
           (j (the fixnum (1+ end)))
           Aj)
      (declare (fixnum p i j))
      (setf (aref vector p) (aref vector start)
            (aref vector start) Ai)
      (block partition
        (loop
          (loop (unless (> (decf j) i) (return-from partition))
                (unless (funcall pred
                                 x
                                 (funcall key (setq Aj (aref vector j))))
                  (return)))
          (loop (unless (< (incf i) j) (return-from partition))
                (unless (funcall pred
                                 (funcall key (setq Ai (aref vector i)))
                                 x)
                  (return)))
          (setf (aref vector i) Aj
                (aref vector j) Ai)))
      (setf (aref vector start) (aref vector j)
            (aref vector j) pivot)
      ; This compare is important.  It limits stack depth to log(end-start)
      (if (< (the fixnum (- j start)) (the fixnum (- end j)))
        (progn
          (%quick-sort-vector vector start (the fixnum (1- j)) pred key)
          (%quick-sort-vector vector (the fixnum (1+ j)) end pred key))
        (progn
          (%quick-sort-vector vector (the fixnum (1+ j)) end pred key)
          (%quick-sort-vector vector start (the fixnum (1- j)) pred key))))
    vector))

(defun %quick-sort-simple-vector (vector start end pred key)
  (declare (optimize (speed 3) (safety 0)))
  (declare (type simple-vector vector)
           (fixnum start end))
  (if (< start end)
    (let* ((p (the fixnum (+ start (the fixnum (ash (the fixnum (- end start)) -1)))))
           (Ai (svref vector p))
           (pivot Ai)
           (x (funcall key Ai))
           (i start)
           (j (the fixnum (1+ end)))
           Aj)
      (declare (fixnum p i j))
      (setf (svref vector p) (svref vector start)
            (svref vector start) Ai)
      (block partition
        (loop
          (loop (unless (> (decf j) i) (return-from partition))
                (unless (funcall pred
                                 x
                                 (funcall key (setq Aj (svref vector j))))
                  (return)))
          (loop (unless (< (incf i) j) (return-from partition))
                (unless (funcall pred
                                 (funcall key (setq Ai (svref vector i)))
                                 x)
                  (return)))
          (setf (aref vector i) Aj
                (aref vector j) Ai)))
      (setf (svref vector start) (svref vector j)
            (svref vector j) pivot)
      (if (< (the fixnum (- j start)) (the fixnum (- end j)))
        (progn
          (%quick-sort-simple-vector vector start (the fixnum (1- j)) pred key)
          (%quick-sort-simple-vector vector (the fixnum (1+ j)) end pred key))
        (progn
          (%quick-sort-simple-vector vector (the fixnum (1+ j)) end pred key)
          (%quick-sort-simple-vector vector start (the fixnum (1- j)) pred key))))
    vector))

(defun %quick-sort-simple-vector-no-key (vector start end pred)
  (declare (optimize (speed 3) (safety 0)))
  (declare (type simple-vector vector)
           (fixnum start end))
  (if (< start end)
    (let* ((p (the fixnum (+ start (the fixnum (ash (the fixnum (- end start)) -1)))))
           (x (svref vector p))
           (i start)
           (j (the fixnum (1+ end)))
           Ai Aj)
      (declare (fixnum p i j))
      (setf (svref vector p) (svref vector start)
            (svref vector start) x)
      (block partition
        (loop
          (loop (unless (> (decf j) i) (return-from partition))
                (unless (funcall pred
                                 x
                                 (setq Aj (svref vector j)))
                  (return)))
          (loop (unless (< (incf i) j) (return-from partition))
                (unless (funcall pred
                                 (setq Ai (svref vector i))
                                 x)
                  (return)))
          (setf (aref vector i) Aj
                (aref vector j) Ai)))
      (setf (svref vector start) (svref vector j)
            (svref vector j) x)
      (if (< (the fixnum (- j start)) (the fixnum (- end j)))
        (progn
          (%quick-sort-simple-vector-no-key vector start (the fixnum (1- j)) pred)
          (%quick-sort-simple-vector-no-key vector (the fixnum (1+ j)) end pred))
        (progn
          (%quick-sort-simple-vector-no-key vector (the fixnum (1+ j)) end pred)
          (%quick-sort-simple-vector-no-key vector start (the fixnum (1- j)) pred))))
    vector))



;; This conses like crazy if you merge lists into vectors or vice-versa, but
;; I don't want to write 6 more merging routines.  Fry's coerce's
;; will have to stand for now.
;; Only difficulty here is parsing the result-type for vectors.
(defun merge (result-type sequence1 sequence2 predicate &key key)
  "Merge the sequences SEQUENCE1 and SEQUENCE2 destructively into a
   sequence of type RESULT-TYPE using PREDICATE to order the elements.
   If result-type specifies an array, the returned array will not be
   a complex array. Usually, result-type is either LIST, ARRAY or STRING."
  (let* ((result-len (+ (length sequence1) (length sequence2)))
         (result-ctype (specifier-type result-type)))
    (cond ((csubtypep result-ctype (specifier-type 'null))
           (unless (zerop result-len)
             (error 'invalid-subtype-error :datum result-type
                    :expected-type 'cons)))
          ((csubtypep result-ctype (specifier-type 'list))
           (canonicalize-pred-and-key predicate key)
           (values                      ; For the terminally pedantic.
            (merge-lists* (if (listp sequence1)
                            sequence1
                            (coerce sequence1 'list))
                          (if (listp sequence2)
                            sequence2
                            (coerce sequence2 'list))
                          predicate key)))
          ((csubtypep result-ctype (specifier-type 'vector))
           (merge-vectors (if (listp sequence1)
                            (coerce sequence1 'vector)
                            sequence1)
                          (if (listp sequence2)
                            (coerce sequence2 'vector)
                            sequence2)
                          predicate key
                          result-type))
          (t (error 'invalid-subtype-error
                    :datum result-type
                    :expected-type 'sequence)))))

(defun merge-vectors (vector-1 vector-2 pred key 
                               &optional (result-type 'vector))
  "Internal function.  Use MERGE instead."
  (canonicalize-pred-and-key)
  (let* ((length-1 (length vector-1))
         (length-2 (length vector-2))
         (result-length (+ length-1 length-2))
         (result (make-merge-vectors-result
                  result-type result-length vector-1 vector-2))
         real-vector-1 start-1 real-vector-2 start-2)
    (multiple-value-setq (real-vector-1 start-1)
                         (array-data-and-offset vector-1))
    (multiple-value-setq (real-vector-2 start-2)
                         (array-data-and-offset vector-2))
    (incf length-1 start-1)
    (incf length-2 start-2)
    (if (and (simple-vector-p real-vector-1) (simple-vector-p real-vector-2)
             (simple-vector-p result))
      (if key
        (%merge-simple-vectors real-vector-1 start-1 length-1
                               real-vector-2 start-2 length-2
                               result 0 pred key)
        (%merge-simple-vectors-no-key real-vector-1 start-1 length-1
                                      real-vector-2 start-2 length-2
                                      result 0 pred))
      (%merge-vectors real-vector-1 start-1 length-1
                      real-vector-2 start-2 length-2
                      result 0 pred key))))

;; OK, here goes the type parsing...
(defun make-merge-vectors-result (result-type result-length vector-1 vector-2)
  (let* ((ctype (specifier-type result-type)))
    (let* ((size (array-ctype-length ctype))
           (elt-type (array-or-union-ctype-element-type ctype)))
      (if (eq elt-type '*)
        (let ((et1 (array-element-type vector-1))
              (et2 (array-element-type vector-2)))
          (setq elt-type (if (eq et1 et2) et1 `(or ,et1 ,et2)))))
      (if (and size (not (eq size result-length)))
        (error 'invalid-subtype-error
               :datum result-type
               :expected-type `(vector ,elt-type ,result-length))
        (make-array (the fixnum (or size result-length))
                    :element-type elt-type)))))
        

;; Gee, that wasn't so bad after all.
;; Well, when you're building on the shoulders of giants,
;; your little effort can seem great.


;; "If I haven't seen as far as others, it's because giants were standing on my shoulders."
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/sort.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/source-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;; If we're reloading this file, don't want to be calling functions from here with
;; only some of them redefined.  So revert to the bootstrapping version until the end.
(fset 'record-source-file #'level-1-record-source-file)

(defvar *source-files-lock* (make-lock "Source Files Lock"))

(defvar *unique-setf-names* (make-hash-table :test #'eq))

(defun canonical-maybe-setf-name (name)
  (if (setf-function-name-p name)
    (let ((tem (%setf-method (%cadr name))))
      (if (non-nil-symbol-p tem) ;; e.g. (setf car) => set-car
        tem
        (or (gethash (%cadr name) *unique-setf-names*)
            (setf (gethash (%cadr name) *unique-setf-names*) (list 'setf (%cadr name))))))
    name))

(defgeneric name-of (thing)
  (:method ((thing t)) thing)
  (:method ((thing method-function)) (name-of (%method-function-method thing)))
  (:method ((thing function)) (name-of (function-name thing)))
  (:method ((thing method)) `(:method ,(method-name thing) ,@(method-qualifiers thing) ,(method-specializers thing)))
  (:method ((thing class)) (class-name thing))
  (:method ((thing method-combination)) (method-combination-name thing))
  (:method ((thing package)) (package-name thing))
  (:method ((thing eql-specializer)) `(eql ,(eql-specializer-object thing))))

;; This used to be weak, but the keys are symbols-with-definitions, so why bother.
;; Set a high rehash threshold because space matters more than speed here.
;; Do not use lock-free hash tables, because they optimize reads at the expense of
;; writes/rehashes.  Writes/rehashes affect file-compilation speed, which matters.
(defvar %source-files% (make-hash-table :test #'eq
                                        :size 14000
                                        :rehash-size 1.8 ;; compensate for high threshold
                                        :rehash-threshold .95
                                        :lock-free nil))



(defvar *direct-methods-only* t
  "If true, method name source location lookup will find direct methods only.  If false,
   include all applicable methods")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Definition types
;;
;; Definition types are uniquely identified by a symbol, but are implemented as
;; classes so they can inherit/customize behavior.  They have no instances other
;; than the class prototype, which is used to invoke methods.
;;

(defgeneric definition-type-name (def-type)
  (:documentation "The preferred user-visible name of the def-type.  Used for
error messages etc.  The default method returns the name specified in
define-definition-type."))

(defclass definition-type ()
  ((name :allocation :class :reader definition-type-name :initform t))
  (:documentation "Superclass of all definition types"))

(defgeneric definition-base-name (def-type def)
  ;; Note that a def can have multiple base names, but each one needs a different def-type
  (:documentation "Return the name that, when the user asks for all definitions of that
name, this def should be included.  Typically this is a symbol.  It's used as a key in
an EQ hash table, so must return EQ values for equivalent definitions.
The default method returns the rightmost atom in name")
  (:method ((dt definition-type) name)
    (while (consp name)
      (let ((x (last name)))
        (setq name (or (cdr x) (car x)))))
    name))

(defgeneric definition-same-p (def-type def1 def2)
  (:documentation "Returns true if the two definitions are equivalent, i.e. one should
replace the other.  The default method calls EQUAL.")
  (:method ((dt definition-type) name1 name2)
    (equal name1 name2)))

(defgeneric definition-bound-p (def-type def)
  (:documentation "Returns true if def is currently defined.  Used to decide whether to issue
redefinition warnings.  The default method returns T.")
  (:method ((dt definition-type) name)
    (declare (ignore name))
    t))

;;;;;;;;;;

(defvar *definition-types* ()
  "alist of all known definition type names and their class prototypes")

(defmethod print-object ((dt definition-type) stream)
  (if *print-escape*
    (let ((definedp (class-name (class-of dt))))
      (print-unreadable-object (dt stream :type definedp :identity t)
        (unless definedp
          (format stream "#:~s " 'definition-type)) ;; subtly indicate it's a subclass...
        (format stream "~s" (definition-type-name dt))))
    (format stream "~s" (definition-type-name dt))))

(defmethod name-of ((thing definition-type))
  (definition-type-name thing))

(defmacro define-definition-type (name supers)
  "Defines a class named name-DEFINITION-TYPE and registers it as the class of
definition type NAME"
  (let ((class-name (intern (%str-cat (symbol-name name) "-DEFINITION-TYPE"))))
    `(progn
       (defclass ,class-name ,(or supers '(definition-type))
         ((name :allocation :class :initform ',name)))
       (record-source-file ',name 'definition-type)
       (register-definition-type (find-class ',class-name) '(,name)))))

(defun register-definition-type (class names)
  (let ((instance (class-prototype class)))
    (with-lock-grabbed (*source-files-lock*)
      ;; If had a previous definition, the defclass will signal any duplicate
      ;; definition warnings, so here just silently replace previous one.
      (without-interrupts
        (setq *definition-types*
              (remove instance *definition-types* :key #'cdr)))
      (loop for name in names
            unless (without-interrupts
                     (unless (assq name *definition-types*)
                       (push (cons name instance) *definition-types*)))
              do (error "There is already a different definition type ~s named ~s"
                        (cdr (assq name *definition-types*))
                        name)))
    ;; Return instance for use in make-load-form
    instance))

(defun auto-create-definition-type (name)
  ;; Use an anonymous class, so this means can't write methods on it.
  ;; If you want to write methods on it, use define-definition-type first.
  (let* ((super (find-class 'definition-type))
         (new-class (make-instance (class-of super)
                      :direct-superclasses (list super)
                      :direct-slots `((:name name
                                       :allocation :class
                                       :initform ',name
                                       :initfunction ,(constantly name))))))
    (register-definition-type new-class (list name))
    (class-prototype new-class)))

(defmethod definition-type-instance ((dt definition-type) &key (if-does-not-exist :error))
  (if (rassoc dt *definition-types* :test #'eq)
    dt
    (ecase if-does-not-exist
      ((nil) nil)
      ((:error) (error "~s is not a known definition-type" dt)))))

(defmethod definition-type-instance ((name symbol) &key (if-does-not-exist :error))
  (or (cdr (assq name *definition-types*))
      (ecase if-does-not-exist
        ((nil) nil)
        ((:error) (error "~s is not a known definition-type" name))
        ((:create) (auto-create-definition-type name)))))

(defmethod definition-type-instance ((class class) &key (if-does-not-exist :error))
  (definition-type-instance (class-prototype class) :if-does-not-exist if-does-not-exist))

(defmethod make-load-form ((dt definition-type) &optional env)
  (declare (ignore env))
  (let ((names (loop for (name . instance) in *definition-types*
                     when (eq dt instance) collect name)))
    `(register-definition-type ',(class-of dt) ',names)))


(register-definition-type (find-class 'definition-type) '(t))

(defparameter *t-definition-type* (definition-type-instance 't))

(define-definition-type function ())

(defparameter *function-definition-type* (definition-type-instance 'function))

(defmethod definition-base-name ((dt function-definition-type) name)
  (while (and (consp name) (not (setf-function-name-p name)))
    (let ((x (last name)))
      (or (setq name (cdr x))
          ;; Try to detect the (:internal .... <hairy-method-name>) case
          (when (and (setq name (car x))
                     ;;check for plausible method name
                     (setq x (method-def-parameters name))
                     (neq x 'setf)
                     (not (keywordp x)))
            (setq name x)))))
  (if (setf-function-name-p name)
    (canonical-maybe-setf-name name)
    (and (symbolp name) name)))

(defmethod definition-bound-p ((dt function-definition-type) name)
  (and (or (symbolp name) (setf-function-name-p name))
       (or (fboundp name)
           ;; treat long-form setf expanders like macros.
           (and (consp name) (functionp (%setf-method (cadr name)))))))

(define-definition-type macro (function-definition-type))

(define-definition-type compiler-macro (macro-definition-type))

(define-definition-type symbol-macro (macro-definition-type))

(define-definition-type setf-expander (macro-definition-type))

(define-definition-type generic-function (function-definition-type))

(define-definition-type method ())

(defparameter *method-definition-type* (definition-type-instance 'method))

(defmethod definition-base-name ((dt method-definition-type) (name cons))
  (if (setf-function-name-p name)
    (canonical-maybe-setf-name name)
    (definition-base-name *function-definition-type* (if (eq (car name) :method) (cadr name) (car name)))))

;; defmethod passes the actual method into record-source-file
(defmethod definition-base-name ((dt method-definition-type) (method method))
  (definition-base-name dt (method-name method)))

(defmethod definition-base-name ((dt method-definition-type) (fn method-function))
  (definition-base-name dt (function-name fn)))

(defmethod definition-same-p ((dt method-definition-type) m1 m2)
  (multiple-value-bind (n1 q1 s1) (method-def-parameters m1)
    (multiple-value-bind (n2 q2 s2) (method-def-parameters m2)
      (and (definition-same-p *function-definition-type* n1 n2)
           (equal q1 q2)
           (eql (length s1) (length s2))
           (every #'(lambda (s1 s2)
                      (or (equal s1 s2)
                          (progn
                            (when (symbolp s2) (rotatef s1 s2))
                            (and (symbolp s1)
                                 (classp s2)
                                 (or (eq (find-class s1 nil) s2)
                                     (eq s1 (class-name s2)))))))
                  s1 s2)))))

(defmethod definition-bound-p ((dt method-definition-type) meth &aux fn)
  (when (setq fn (method-def-parameters meth))
    (loop for m in (and (setq fn (fboundp fn))
                        (typep fn 'generic-function)
                        (generic-function-methods fn))
          thereis (definition-same-p dt meth m))))

(define-definition-type reader-method (method-definition-type))

(define-definition-type writer-method (method-definition-type))

(define-definition-type callback (function-definition-type))

(define-definition-type structure-accessor (function-definition-type))

(define-definition-type type ())

(define-definition-type class ())

(defmethod definition-bound-p ((dt class-definition-type) name)
  (and (non-nil-symbol-p name) (find-class name nil)))

(define-definition-type condition (class-definition-type))

(define-definition-type structure ())

(define-definition-type definition-type ())

(defmethod definition-bound-p ((dt definition-type-definition-type) name)
  (definition-type-instance name :if-does-not-exist nil))

(define-definition-type method-combination ())

(define-definition-type variable ())

(defmethod definition-bound-p ((dt variable-definition-type) name)
  (and (non-nil-symbol-p name) (boundp name)))

(define-definition-type constant (variable-definition-type))

(define-definition-type package ())

(defmethod definition-base-name ((dt package-definition-type) name)
  (if (or (stringp name) (non-nil-symbol-p name))
    (intern (string name) :keyword)
    name))

(defmethod definition-bound-p ((dt package-definition-type) name)
  (and (or (stringp name) (symbolp name))
       (find-package (string name))))

(defmethod definition-same-p ((dt package-definition-type) d1 d2)
  (and (or (stringp d1) (symbolp d1))
       (or (stringp d2) (symbolp d2))
       (equal (string d1) (string d2))))


;;;;;;;;;;;

(declaim (inline default-definition-type))

(defun default-definition-type (name)
  (if (typep name 'method)
    *method-definition-type*
    *function-definition-type*))

;; remember & reuse last few (TYPE . file) entries
(let ((cache (make-list 10 :initial-element nil)))
  (defun type-file-cons (type files)
    (loop for prev = nil then p for p = cache then (cdr p)
          do (when (or (and (eq type (caar p)) (equal files (cdar p)))
                       (and (null (cdr p))
                            (setf (car p) (cons type files))))
               (when prev ;; move to front unless already there
                 (setf (cdr prev) (cdr p))
                 (setf (cdr p) cache)
                 (setq cache p))
               (return (car p))))))

(defun %source-file-entries (key)
  (let ((data (gethash key %source-files%)))
    (if (and (listp data)
             (listp (%cdr data)))
      data
      (list data))))

(defun %set-source-file-entries (key list &aux data)
  (setf (gethash key %source-files%)
        (if (and list
                 (null (cdr list))
                 ;; One element, but make sure can recognize it.
                 (not (and (listp (%car list))
                           (listp (%cdar data)))))
          (car list)
          list)))

(defun make-def-source-entry (key type name files)
  (setq files (if (or (%cdr files) (listp (%car files))) files (%car files)))
  (cond ((eq type (default-definition-type name))
         (if (and (eq name key) (atom files))
           files
           (cons name files)))
        ((eq name key)
         (type-file-cons type files))
        (t
         (cons (cons type name) files))))

(defun decode-def-source-entry (key entry)
  (if (atom entry)
    (and entry (values (default-definition-type key) key (list entry)))
    (let* ((file-or-files (%cdr entry))
           (files (if (consp file-or-files) file-or-files (list file-or-files))))
      (cond ((typep (%car entry) 'definition-type)
             (values (%car entry) key files))
            ((and (consp (%car entry)) (typep (%caar entry) 'definition-type))
             (values (%caar entry) (%cdar entry) files))
            (t
             (values (default-definition-type (%car entry)) (%car entry) files))))))

(defun def-source-entry.name (key entry)
  (assert (not (null entry)))
  (cond ((atom entry) key)
        ((typep (%car entry) 'definition-type) key)
        ((and (consp (%car entry)) (typep (%caar entry) 'definition-type))
         (%cdar entry))
        (t
         (%car entry))))

(defun def-source-entry.type (key entry)
  (cond ((atom entry) (default-definition-type key))
        ((typep (%car entry) 'definition-type) (%car entry))
        ((and (consp (%car entry)) (typep (%caar entry) 'definition-type))
         (%caar entry))
        (t
         (default-definition-type (%car entry)))))

(defun def-source-entry.sources (key entry)
  (declare (ignore key))
  (cond ((consp entry)
         (if (consp (%cdr entry)) (%cdr entry) (list (%cdr entry))))
        (entry (list entry))
        (t nil)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 


;; Some objects (specifically functions) have source location information associated with the
;; object itself, in addition to any source locations associated with its definition.  This
;; allows us to find source for, e.g., anonymous functions.
(defgeneric get-object-sources (thing)
  ;; returns a list of entries ((a-type . a-name) source . previous-sources)
  (:method ((thing t)) nil)
  (:method ((fn function))
    (let ((source (function-source-note fn)))
      (when source
        (list (list* (cons *function-definition-type* (or (name-of fn) fn)) source nil)))))
  (:method ((fn method-function))
    (let ((source (function-source-note fn)))
      (when source
        (list (list* (cons *method-definition-type* (%method-function-method fn)) source nil)))))
  (:method ((m method))
    (get-object-sources (method-function m)))
  (:method ((fn compiled-lexical-closure))
    (get-object-sources (closure-function fn))))

(defun find-definition-sources (name &optional (type t))
  "Returns a list of entries ((a-type . a-name) source . previous-sources), where
a-type is a subtype of TYPE, and a-name is either NAME or it's a special case of
NAME (e.g. if NAME is the name of generic function, a-name could be a method of NAME).

If NAME is not a cons or symbol, it's assumed to be an object (e.g. class or
function) whose source location we try to heuristically locate, usually by looking up
the sources of its name.

If NAME is a method name and *DIRECT-METHODS-ONLY* is false, will also locate all
applicable methods.

The returned list is guaranteed freshly consed (ie suitable for nconc'ing)."

  (let* ((dt-class (class-of (definition-type-instance type)))
         (matches (get-object-sources name)))
    (if matches
      (setq matches (delete-if-not (lambda (info) (typep (caar info) dt-class)) matches))
      ;; No intrinsic source info for the thing itself, look it up by name.
      (let (seen-dts implicit-type implicit-dt-class implicit-name)
        (typecase name
          (method
             (setq implicit-type 'method implicit-name name))
          (method-function
             (setq implicit-type 'method implicit-name (%method-function-method name)))
          (function
             (setq implicit-type 'function implicit-name (name-of name)))
          (method-combination
             (setq implicit-type 'method-combination implicit-name (name-of name)))
          (package
             (setq implicit-type 'package implicit-name (name-of name)))
          (class
             (setq implicit-type 'class implicit-name (name-of name)))
          (t
           (locally
               (declare (ftype function xref-entry-p xref-entry-full-name xref-entry-type))
             (if (and (find-class 'xref-entry nil)
                      (xref-entry-p name))
               (setq implicit-type (xref-entry-type name) implicit-name (xref-entry-full-name name))
               (setq implicit-type t implicit-name name)))))
        (setq implicit-dt-class (class-of (definition-type-instance implicit-type)))
        (with-lock-grabbed (*source-files-lock*)
          (loop for (nil . dt) in *definition-types*
                when (and (typep dt dt-class) (typep dt implicit-dt-class) (not (memq dt seen-dts)))
                  do (let* ((key (definition-base-name dt implicit-name))
                            (all (%source-file-entries key)))
                       (push dt seen-dts)
                       (loop for entry in all
                             when (and (eq dt (def-source-entry.type key entry))
                                       (or (eq implicit-name key) ;; e.g. all methods on a gf
                                           (definition-same-p dt implicit-name (def-source-entry.name key entry))))
                               do (multiple-value-bind (type name files)
                                      (decode-def-source-entry key entry)
                                    (push (cons (cons type name) files) matches))))))))

    ;; include indirect applicable methods.  Who uses this case?
    (when (and (eq type 'method)
               (not (typep name 'method))
               (not *direct-methods-only*))
      (multiple-value-bind (sym qualifiers specializers) (method-def-parameters name)
        (when sym
          (loop for m in (find-applicable-methods sym specializers qualifiers)
                unless (definition-same-p *method-definition-type* m name)
                  do (setq matches (nconc (find-definition-sources m 'method) matches))))))
    matches))

;;; backward compatibility

;;; modified version of %method-applicable-p - args are class names
;;; not instances
(defun %my-method-applicable-p (method args cpls)
  (do* ((specs (%method-specializers method) (%cdr specs))
        (args args (%cdr args))
        (cpls cpls (%cdr cpls)))
      ((null args) t)
    (let ((spec (%car specs))
          (arg (%car args)))
      (if (typep spec 'eql-specializer)
        (if (consp arg)
          (unless (eql (cadr arg) (eql-specializer-object spec))
            (return nil))
          (if (typep (eql-specializer-object spec) arg)
            ;(unless (eq arg *null-class*) (return :undecidable))
            t  ;; include if it's at all possible it might be applicable.
            (return nil)))
        (unless (memq spec (%car cpls))
          (return nil))))))

;;; modified version of %compute-applicable-methods*
;;; omit errors and args are class names not instances
;;; returns a new list.
(defun find-applicable-methods (name args qualifiers)
  (let ((gf (fboundp name)))
    (when (and gf (typep gf 'standard-generic-function))
      (let* ((methods (or (%gf-methods gf)
                          (return-from find-applicable-methods nil)))
             (arg-count (length (%method-specializers (car methods))))
             (args-length (length args))
             (bits (inner-lfun-bits gf))
             res)
        (unless (or (logbitp $lfbits-rest-bit bits)
                    (logbitp $lfbits-restv-bit bits)
                    (logbitp $lfbits-keys-bit bits)
                    (<= args-length 
                        (+ (ldb $lfbits-numreq bits) (ldb $lfbits-numopt bits))))
                                        ;(error "Too many args for ~s" gf)
          (return-from find-applicable-methods))
        (when (< arg-count args-length)
          (setq args (subseq args 0 (setq args-length arg-count))))
        (setq args (mapcar (lambda (arg)
                             (typecase arg
                               (eql-specializer `(eql ,(eql-specializer-object arg)))
                               (class arg)
                               (symbol (or (find-class (or arg t) nil)
                                           ;;(error "Invalid class name ~s" arg)
                                           (return-from find-applicable-methods)))
                               (t
                                  (unless (and (consp arg) (eql (car arg) 'eql) (null (cddr arg)))
                                    ;;(error "Invalid specializer ~s" arg)
                                    (return-from find-applicable-methods))
                                  arg)))
                           args))
        (let ((cpls (make-list args-length)))
          (declare (dynamic-extent cpls))
          (do ((args-tail args (cdr args-tail))
               (cpls-tail cpls (cdr cpls-tail)))
              ((null cpls-tail))
            (declare (type list args-tail cpls-tail))
            (let ((arg (car args-tail)))
              (setf (car cpls-tail)
                    (%class-precedence-list (if (consp arg)
                                              (class-of (cadr arg))
                                              arg)))))
          (dolist (m methods)
            (when (%my-method-applicable-p m args cpls)
              (push m res)))
          (let ((methods (sort-methods res cpls (%gf-precedence-list gf))))
            (when (eq (generic-function-method-combination gf)
                      *standard-method-combination*)
                                        ; around* (befores) (afters) primaries*
              (setq methods (compute-method-list methods))
              (when methods
                (setq methods
                      (if (not (consp methods))
                        (list methods)
                        (let ((afters (cadr (member-if #'listp methods))))
                          (when afters (nremove afters methods))
                          (nconc
                           (mapcan #'(lambda (x)(if (listp x) x (cons x nil)))
                                   methods)
                           afters))))))
            (if (and qualifiers (neq qualifiers t))
              (delete-if #'(lambda (m)(not (equal qualifiers (%method-qualifiers m))))
                         methods)
              methods)))))))

;;; Do this just in case record source file doesn't remember the right
;;; definition
(defun methods-match-p (x y)  
  (or (eq x y)
      (and (typep x 'method)
           (typep y 'method)
           (equal (method-name x)
                  (method-name y))
           (equal (method-specializers x)
                  (method-specializers y))
           (equal (method-qualifiers x)
                  (method-qualifiers y)))))

(defun edit-definition-p (name &optional (type t)) ;exported
  (let ((specs (get-source-files-with-types name type)))
    (when (and (null specs)
               (symbolp name))
      (let* ((str (symbol-name name))
             (len (length str)))
        (when (and (> len 0) (memq (char str (1- len)) '(#\. #\, #\:)))
          (let ((newsym (find-symbol (%substr str 0 (1- len)) (symbol-package name))))
            (when newsym
              (setq specs (get-source-files-with-types newsym type)))))))
    specs))

(defun get-source-files-with-types (name &optional (type t))
  (let ((list (find-definition-sources name type)))
    ;; Convert to old format, (type-or-name . file)
    (loop for ((dt . full-name) . sources) in list
          as spec = (if (eq full-name name) (definition-type-name dt) full-name)
          nconc (mapcan (lambda (s)
                          (when s (list (cons spec (source-note-filename s)))))
                        sources))))


;; For ilisp.
(defun %source-files (name)
  (let ((type-list ())
        (meth-list ()))
    (loop for ((dt . full-name) . sources) in (find-definition-sources name t)
          as files = (mapcan #'(lambda (s)
                                 (and s (setq s (source-note-filename s)) (list s)))
                             sources)
          when files
            do (if (typep dt 'method-definition-type)
                 (dolist (file files)
                   (push (cons full-name file) meth-list))
                 (push (cons (definition-type-name dt) files) type-list)))
    (when meth-list
      (push (cons 'method meth-list) type-list))
    type-list))

;; For CVS slime as of 11/15/2008.
(defun get-source-files-with-types&classes (sym &optional (type t) classes qualifiers the-method)
  (let* ((name (or the-method
                   (and (or (eq type 'method) classes qualifiers)
                        `(sym ,@qualifiers ,classes))
                   sym)))
    (get-source-files-with-types name type)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; record-source-file

;; Returns nil if not a method/method name
(defun method-def-parameters (m)
  (when (typep m 'method-function)
    (setq m (%method-function-method m)))
  (if (typep m 'method)
    (values (method-name m)
            (method-qualifiers m)
            (method-specializers m))
    (let (name quals specs data last)
      (when (consp m)
        (when (eq (car m) :method) (setq m (cdr m)))
        ;; (name spec1 .. specn) or (name qual1 .. qualn (spec1 ... specn))
        (setq data (cdr m) last (last data))
        (when (null (cdr last))
          (setq last (car last))
          (if (and (listp last) (neq (car last) 'eql))
            (setq quals (butlast data) specs last)
            (setq specs data))
          (setq name (car m))
          (when (and (or (non-nil-symbol-p name) (setf-function-name-p name))
                     (every #'(lambda (q) (not (listp q))) quals)
                     (every #'(lambda (s)
                                (or (non-nil-symbol-p s)
                                    (classp s)
                                    (and (consp s)
                                         (consp (cdr s))
                                        (null (cddr s))
                                         (eq (car s) 'eql))))
                            specs))
            (values name quals specs)))))))

(defmethod record-definition-source ((dt definition-type) name source)
  (let* ((key (definition-base-name dt name))
         (all (%source-file-entries key))
         (e-loc nil)
         (e-files nil))
    (loop for ptr on all as entry = (car ptr)
          do (when (and (eq dt (def-source-entry.type key entry))
                        (definition-same-p dt name (def-source-entry.name key entry)))
               (setq e-files (def-source-entry.sources key entry))
               (let ((old (flet ((same-file (x y)
                                   (setq x (source-note-filename x))
                                   (setq y (source-note-filename y))
                                   (or (equal x y)
                                       (and x
                                            y
                                            (or (stringp x) (pathnamep x))
                                            (or (stringp y) (pathnamep y))
                                            (equal
                                             (or (probe-file x) (full-pathname x))
                                             (or (probe-file y) (full-pathname y)))))))
                            (member source e-files :test #'same-file))))
                 (when (and old (neq source (car e-files))) ;; move to front
                   (setq e-files (cons source (remove (car old) e-files :test #'eq)))))
               (return (setq e-loc ptr))))
    (unless (and e-files (eq source (car e-files)))
      ;; Never previously defined in this file
      (when (and (car e-files)            ; don't warn if last defined interactively
                 *warn-if-redefine*
                 (definition-bound-p dt name))
        (warn "~A ~S previously defined in: ~A is now being redefined in: ~A~%"
              (definition-type-name dt)
              name
              (source-note-filename (car e-files))
              (or (source-note-filename source) "{No file}")))
      (setq e-files (cons source e-files)))
    (let ((entry (make-def-source-entry key dt name e-files)))
      (if e-loc
        (setf (car e-loc) entry)
        (push entry all))
      (%set-source-file-entries key all))
    name))

(defmethod record-definition-source ((dt method-definition-type) (m method) source)
  ;; In cases of non-toplevel method definitions, as in the expansion of defgeneric,
  ;; the method function note has more specific info than *loading-toplevel-location*.
  (call-next-method dt m (or (function-source-note (method-function m)) source)))

;;; avoid hanging onto beezillions of pathnames
(defparameter *last-back-translated-name* (cons nil nil))

;; Define the real record-source-file, which will be the last defn handled by the
;; bootstrapping record-source-file, so convert all queued up data right afterwards.
(progn

(defun record-source-file (name def-type &optional (source (or *loading-toplevel-location*
                                                               *loading-file-source-file*)))
  (when (and source *record-source-file*)
    (with-lock-grabbed (*source-files-lock*)
      (let ((file-name (source-note-filename source)))
        (when file-name
          (unless (equalp file-name (car *last-back-translated-name*))
            (setf (car *last-back-translated-name*) file-name)
            (setf (cdr *last-back-translated-name*)
                  (if (physical-pathname-p file-name)
                    (namestring (back-translate-pathname file-name))
                    file-name)))
          (setq file-name (cdr *last-back-translated-name*))
          (if (source-note-p source)
            (setf (source-note-filename source) file-name)
            (setq source file-name))))
      (when (eq def-type 't) (report-bad-arg def-type '(not (eql t))))
      (record-definition-source (definition-type-instance def-type
                                    :if-does-not-exist :create)
                                name
                                source))))

;; Collect level-0 source file info
(do-all-symbols (s)
  (let ((f (get s 'bootstrapping-source-files)))
    (when f
      (if (consp f)
        (destructuring-bind ((type . source)) f
          (when source (record-source-file s type source)))
        (record-source-file s 'function f))
      (remprop s 'bootstrapping-source-files))))

;; Collect level-1 source file info
(when (consp *record-source-file*)
  (let ((list (nreverse (shiftf *record-source-file* t))))
    (while list
      (apply #'record-source-file (pop list)))))
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/source-files.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/streams.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; streams.lisp
;;;General io-functions

(in-package "CCL")

(eval-when (:execute :compile-toplevel)
  (require :level-2)
  (require :streams)
  (require :backquote)

  )






(defun read-line (&optional input-stream (eof-error-p t) eof-value recursive-p)
  
  (declare (ignore recursive-p)
           (optimize (speed 3)))
  (let* ((input-stream (designated-input-stream input-stream)))
    (multiple-value-bind (string eof)
        (if (typep input-stream 'basic-stream)
          (let* ((ioblock (basic-stream-ioblock input-stream)))
            (with-ioblock-input-locked (ioblock)
               (funcall (ioblock-read-line-function ioblock) ioblock)))
          (stream-read-line input-stream))
      (if eof
	(if (= (length string) 0)
	  (if eof-error-p
	    (signal-eof-error input-stream)
	    (values eof-value t))
	  (values string t))
	(values string nil)))))

(eval-when (:compile-toplevel)
  (declaim (inline read-char-internal)))

(defun read-char-internal (input-stream eof-error-p eof-value)
  (declare (optimize (speed 3) (space 0)))
  (check-eof
   (if (or (typep input-stream 'basic-stream)
           (typep (setq input-stream (designated-input-stream input-stream))
                  'basic-stream))
     (let* ((ioblock (basic-stream-ioblock input-stream)))
       (funcall (ioblock-read-char-function ioblock) ioblock))
     (stream-read-char input-stream))
   input-stream eof-error-p eof-value))

(defun read-char (&optional input-stream (eof-error-p t) eof-value recursive-p)
  (declare (ignore recursive-p))
  (read-char-internal input-stream eof-error-p eof-value))

(defun unread-char (char &optional input-stream)
  (let* ((input-stream (designated-input-stream input-stream)))
    (if (typep input-stream 'basic-stream)
      (let* ((ioblock (basic-stream-ioblock input-stream)))
        (funcall (ioblock-unread-char-function ioblock) ioblock char))
      (stream-unread-char input-stream char))
    nil))

(defun peek-char (&optional peek-type input-stream
                            (eof-error-p t) eof-value recursive-p)
  (declare (ignore recursive-p))
  (let* ((input-stream (designated-input-stream input-stream)))
    (cond ((null peek-type)
           (check-eof (stream-peek-char input-stream) input-stream eof-error-p eof-value))
          (t
           (do* ((value (stream-peek-char input-stream) (stream-peek-char input-stream)))
                ((eq value :eof)
                 (return (check-eof value input-stream eof-error-p eof-value)))
             (if (eq peek-type t)
               (unless (whitespacep value)
                 (return value))
               (if (characterp peek-type)
                 (if (eql peek-type value)
                   (return value))
                 (report-bad-arg peek-type '(or character (member nil t)))))
             (stream-read-char input-stream))))))

(defun read-char-no-hang (&optional input-stream (eof-error-p t) eof-value recursive-p)
  (declare (ignore recursive-p))
  (setq input-stream (designated-input-stream input-stream))
  (check-eof (stream-read-char-no-hang input-stream) input-stream eof-error-p eof-value))

(defun read-byte (stream &optional (eof-error-p t) eof-value)
  (declare (optimize (speed 3) (space 0)))
  (if (typep stream 'basic-stream)
    (let* ((ioblock (basic-stream-ioblock stream)))
      (check-eof (funcall (ioblock-read-byte-function ioblock) ioblock)
                 stream
                 eof-error-p
                 eof-value))
    (check-eof
     (stream-read-byte stream)
     stream
     eof-error-p
     eof-value)))

;;;;;;;;;;;; OUTPUT STREAMS

(defun clear-output (&optional stream)
  (let* ((stream (real-print-stream stream)))
    (stream-clear-output stream)
    nil))

(defun finish-output (&optional stream)
  (let* ((stream (real-print-stream stream)))
    (stream-finish-output stream)
    nil))



(defun line-length (stream)
  (or (stream-line-length stream) *default-right-margin*))

(defun write-byte (byte stream)
  (declare (optimize (speed 3) (space 0)))
  "Write one byte, BYTE, to STREAM."
  (if (typep stream 'basic-stream)
    (let* ((ioblock (basic-stream-ioblock stream)))
      (funcall (ioblock-write-byte-function ioblock) ioblock byte))
    (stream-write-byte stream byte))
  byte)


;;;General stream functions



(defmacro with-open-stream ((var stream) &body body &aux (svar (gensym)))
  "Perform a series of operations on stream, return a value, and then
close the stream.  VAR is bound to the value of STREAM, and then BODY is
executed as an implicit progn. STREAM is automatically closed on exit
from with-open-stream, no matter whether the exit is normal or abnormal.
The stream has dynamic extent; its extent ends when the form is exited."
  `(let (,svar)
     (unwind-protect
       (let ((,var (setq ,svar ,stream)))
         ,@body)
       (when ,svar (close ,svar)))))




;;

;;; from i/o chapter of steele
;;; Ever notice that -much- of this code is from the i/o chapter
;;; of steele ?  Strange but true ...

(defun read-from-string (string &optional (eof-error-p t) eof-value
                                &key (start 0) end preserve-whitespace
                                &aux idx)
  "The characters of string are successively given to the lisp reader
   and the lisp object built by the reader is returned. Macro chars
   will take effect."
  (values
   (with-input-from-string (stream string :index idx :start start :end end)
     (if preserve-whitespace
       (read-preserving-whitespace stream eof-error-p eof-value)
       (read stream eof-error-p eof-value)))
   idx))


;;;File Stuff here

(defun dribble (&optional filename)
  "With a file name as an argument, dribble opens the file and sends a
     record of further I/O to that file. Without an argument, it closes
     the dribble file, and quits logging."
  (process-dribble *current-process* filename))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/streams.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/arglist.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;; Record pseudo-arglist info for special operators.
(record-arglist 'catch "tag &body body")
(record-arglist 'progn "&BODY BODY")
(record-arglist 'function "NAME-OR-LAMBDA-EXPRESSION")
(record-arglist 'go "TAG")
(record-arglist 'symbol-macrolet "(&REST BINDINGS) &BODY BODY")
(record-arglist 'locally "DECLARATION* &BODY BODY")
(record-arglist 'setq "[SYMBOL VALUE]*")
(record-arglist 'tagbody "&REST TAGS-OR-FORMS")
(record-arglist 'return-from "BLOCK VALUES")
(record-arglist 'quote '(form))
(record-arglist 'macrolet "(&REST BINDINGS) &BODY BODY")
(record-arglist 'the '(type-specifier form))
(record-arglist 'eval-when "(&REST SITUATIONS) &BODY BODY")
(record-arglist 'let* "(&REST BINDINGS) &BODY BODY")
(record-arglist 'let "(&REST BINDINGS) &BODY BODY")
(record-arglist 'load-time-value '(form))
(record-arglist 'throw '(tag value))
(record-arglist 'unwind-protect "PROTECTED-FORM &BODY CLEANUP-FORMS")
(record-arglist 'flet "(&REST BINDINGS) &BODY BODY")
(record-arglist 'multiple-value-call '(function &rest values-producing-forms))
(record-arglist 'block "NAME &BODY BODY")
(record-arglist 'labels "(&REST BINDINGS) &BODY BODY")
(record-arglist 'multiple-value-prog1 "VALUES-PRODUCING-FORM &BODY FORMS-FOR-EFFECT")
(record-arglist 'if '(test true &optional false))
(record-arglist 'progv "(&REST VARS) (&REST VALUES) &BODY BODY")
(record-arglist 'nfunction '(function-name lambda-expression))


; Returns two values: the arglist & it's functions binding.
; If the second arg is NIL, there was no function binding.
(defun arglist (sym &optional include-bindings)
  (%arglist sym include-bindings))

(defun arglist-string (sym &optional include-bindings)
  (multiple-value-bind (res type)
                       (%arglist-internal sym include-bindings)
    (values
     (if (stringp res)
       res
       (and res (with-standard-io-syntax (princ-to-string res))))
     type)))

(defun set-arglist (sym arglist)
  (let ((real-sym (arglist-sym-and-def sym)))
    (when (or real-sym (null sym))
      (if (eq arglist t)
        (remhash real-sym %lambda-lists%)
        (setf (gethash real-sym %lambda-lists%) arglist)))))

(defsetf arglist set-arglist)

; Same as ARGLIST, but has the option of using TEMP-CONS instead of CONS
; to cons up the list.
(defun %arglist (sym &optional include-bindings)
  (multiple-value-bind (res type)
                       (%arglist-internal
                        sym include-bindings)
    (when (stringp res)
      (with-input-from-string (stream res)
        (setq res nil)
        (let ((eof (list nil))
              val errorp)
          (declare (dynamic-extent eof))
          (loop
            (multiple-value-setq (val errorp)
              (ignore-errors (values (read stream nil eof))))
            (when errorp
              (push '&rest res)
              (push ':unparseable res)
              (return))
            (when (eq val eof)
              (return))
            (push val res))
          (setq res
                (if (and (null (cdr res)) (listp (car res)))
                  (car res)
                  (nreverse res))))))
    (values res type)))

(defun %arglist-internal (sym include-bindings 
                              &aux def type)
  (multiple-value-setq (sym def) (arglist-sym-and-def sym))
  (if (generic-function-p def)
    (values (generic-function-lambda-list def) :declaration)
    (let ((ll (gethash sym %lambda-lists% *eof-value*))
        (macrop (and (symbolp sym) (eq (macro-function sym) def))))
    (flet ((strip (f) (if (stringp f) f (strip-bindings f include-bindings))))
      (declare (dynamic-extent #'strip))
      (cond ((neq ll *eof-value*) (values (strip ll) :declaration))
            ((consp def)
             ;; Presumably (lambda (... arglist) ...)
             (values (strip (cadr def)) :definition))
            ((neq (setq ll (getf (%lfun-info def) 'arglist *eof-value*)) *eof-value*)
             (values ll :definition))
            ((and (not macrop) (setq ll (uncompile-function def)))
             (values (strip (cadr ll)) (or type :definition)))
            ((lfunp def)
             (multiple-value-bind (arglist gotit) 
                                  (unless macrop (arglist-from-map def))
               (if gotit
                 (values arglist :analysis)
                 (cond  (macrop (values nil :unknown))
                       (t (values (arglist-from-compiled-def def) :analysis))))))
            (t (values nil nil)))))))

            

(defun strip-bindings (arglist include-bindings)
  (if include-bindings
    arglist
    (let ((res nil))
      (do ((args arglist (%cdr args)))
          ((not (consp args)) (nreconc res args))
        (let ((arg (car args)))
          (cond ((atom arg)
                 (push arg res))
                ((atom (car arg))
                 (push (car arg) res))
                (t (push (caar arg) res))))))))

(defun arglist-sym-and-def (sym &aux def)
  (cond ((functionp sym)
         (setq def sym
               sym (function-name def))
         (unless (and (symbolp sym) (eq def (fboundp sym)))
           (setq sym nil)))
        ((listp sym)
         (if (eq (car sym) 'setf)
           (setq sym (setf-function-name (cadr sym))
                 def (find-unencapsulated-definition (fboundp sym)))
           (setq sym nil def nil)))
        ((standard-method-p sym)
         (setq def (closure-function 
                    (find-unencapsulated-definition (%method-function sym)))))
        ((and (macro-function sym))
         (setq def (macro-function sym)))
        ((special-operator-p sym)
         nil)
        (t (setq def (find-unencapsulated-definition (fboundp sym)))))
  (values sym (if (standard-generic-function-p def) def (closure-function def))))

(defun arglist-from-map (lfun)
  (multiple-value-bind (nreq nopt restp nkeys allow-other-keys
                        optinit lexprp
                        ncells nclosed)
      (function-args lfun)
    (declare (ignore optinit))
    (if lexprp
      (setq restp t))
    (let ((map (car (function-symbol-map lfun))))
      (if map
        (let ((total (+ nreq nopt (if restp 1 0) (or nkeys 0)))
              (idx (- (length map) nclosed))
              (res nil))
          (if (%izerop total)
            (values nil t)
            (progn
              (dotimes (x nreq)
                (declare (fixnum x))
                (push (if (> idx 0) (elt map (decf idx)) (make-arg "ARG" x)) res))
              (when (neq nopt 0)
                (push '&optional res)
                (dotimes (x (the fixnum nopt))
                  (push (if (> idx 0) (elt map (decf idx)) (make-arg "OPT" x)) res)))

              (when restp
                (push (if lexprp '&lexpr '&rest) res)
                (push (if (> idx 0) (elt map (decf idx)) 'the-rest) res))
              (when nkeys
                (push '&key res)
                (let ((keyvect (lfun-keyvect lfun)))
                  (dotimes (i (length keyvect))
                    (push (elt keyvect i) res))))
              (when allow-other-keys
                (push '&allow-other-keys res))))
          (values (nreverse res) t))
        (values nil (zerop ncells))))))

(defun arg-names-from-map (lfun pc)
  (when lfun
    (multiple-value-bind (nreq nopt restp nkeys allow-other-keys
			       optinit lexprp
			       ncells nclosed)
	(function-args lfun)
      (declare (ignore optinit ncells allow-other-keys))
      (collect ((req)
		(opt)
		(keys))
	(let* ((rest nil)
	       (map (if (and pc (> pc target::arg-check-trap-pc-limit))
			(car (function-symbol-map lfun)))))
	  (if (and map pc)
	      (let ((total (+ nreq nopt (if (or restp lexprp) 1 0) (or nkeys 0)))
		    (idx (- (length map) nclosed)))
		(unless (zerop total)
		  (progn
		    (dotimes (x (the fixnum nreq))
		      (declare (fixnum x))
		      (req (if (> idx 0) (elt map (decf idx)) (make-arg "ARG" x))))
		    (when (neq nopt 0)
		      (dotimes (x (the fixnum nopt))
			(opt (if (> idx 0) (elt map (decf idx)) (make-arg "OPT" x)))))
		    (when (or restp lexprp)
		      (setq rest (if (> idx 0) (elt map (decf idx)) 'the-rest)))
		    (when nkeys
		      (dotimes (i (the fixnum nkeys))
			(keys (if (> idx 0) (elt map (decf idx)) (make-arg "KEY" i)))))))))
	  (values (or (not (null map))
		      (and (eql 0 nreq) (eql 0 nopt) (not restp) (null nkeys)))
		  (req) (opt) rest (keys)))))))
              
              


(defvar *req-arg-names*
  #(arg-0 arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9))

(defvar *opt-arg-names*
  #(opt-0 opt-1 opt-2 opt-3 opt-4 opt-5 opt-6 opt-7 opt-8 opt-9))


(defun make-arg (prefix count)
  (cond ((and (string= prefix "ARG") (< count (length *req-arg-names*)))
         (svref *req-arg-names* count))
        ((and (string= prefix "OPT") (< count (length *opt-arg-names*)))
         (svref *opt-arg-names* count))
        (t (intern (format nil "~a-~d" prefix count) :CCL))))

(defun arglist-from-compiled-def (lfun &aux (res nil) argnames)
  (multiple-value-bind (nreq nopt restp nkeys allow-other-keys
                             optinit lexprp
                             ncells nclosed)
      (function-args lfun)
    (declare (ignore optinit ncells nclosed))
    (flet ((push-various-args (prefix count)
             (dotimes (i (the fixnum count))
               (push (make-arg prefix i) res))))
      (declare (dynamic-extent #'push-various-args))
      ;; Treat &LEXPR like &REST.
      (if lexprp (setq restp t lexprp nil))
      (cond ((and (eq 0 (+ nreq nopt (or nkeys 0))) (not restp))
             nil)
            (t 
             (if argnames
               (setq res (reverse (butlast argnames (- (length argnames) nreq))))
               (push-various-args "ARG" nreq))
             (when (> nopt 0)
               (push '&optional res)
               (if argnames
                 (setq res (append (reverse (subseq argnames nreq (+ nreq nopt))) res))
                 (push-various-args "OPT" nopt)))
             (when restp
               (push '&rest res)
               (if argnames
                 (push (nth (+ nreq nopt) argnames) res)
                 (push 'the-rest res)))
             (when nkeys
               (push '&key res)
               (let ((keyvect (lfun-keyvect lfun)))
                 (dotimes (i (length keyvect))
                   (push (elt keyvect i) res))))
             (when allow-other-keys
               (push '&allow-other-keys res))
             (nreverse res))))))

; End of arglist.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/arglist.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/backquote.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;;   Copyright (C) 2009 Clozure Associates
;;;   Copyright (C) 1994-2001 Digitool, Inc
;;;   This file is part of Clozure CL.  
;;;
;;;   Clozure CL is licensed under the terms of the Lisp Lesser GNU Public
;;;   License , known as the LLGPL and distributed with Clozure CL as the
;;;   file "LICENSE".  The LLGPL consists of a preamble and the LGPL,
;;;   which is distributed with Clozure CL as the file "LGPL".  Where these
;;;   conflict, the preamble takes precedence.  
;;;
;;;   Clozure CL is referenced in the preamble as the "LIBRARY."
;;;

; Backquote.lisp

(in-package "CCL")

#+nil
(progn
;;; Common Lisp backquote implementation, written in Common Lisp.
;;; Author: Guy L. Steele Jr.     Date: 27 December 1985
;;; Texted under Symbolics Common Lisp and Lucid Common Lisp.
;;; This software is in the public domain.

;;; The following are unique tokens used during processing
;;; They need not be symbols; they need not even be atoms.

(defvar *comma* (make-symbol "`,"))
(defvar *comma-atsign* (make-symbol "`,@"))
(defvar *comma-dot* (make-symbol "`,."))
(defvar *bq-list* (make-symbol "BQ-LIST"))
(defvar *bq-append* (make-symbol "BQ-APPEND"))
(defvar *bq-list** (make-symbol "BQ-LIST*"))
(defvar *bq-nconc* (make-symbol "BQ-NCONC"))
(defvar *bq-clobberable* (make-symbol "BQ-CLOBBERABLE"))
(defvar *bq-quote* (make-symbol "BQ-QUOTE"))
(defvar *bq-quote-nil* (list *bq-quote* nil))

;;; Reader macro characters:
;;;    `foo is read in as (BACKQUOTE foo)
;;;    ,foo is read in as (#:COMMA foo)
;;;    ,@foo is read in as (#:COMMA-ATSIGN foo)
;;;    ,.foo is read in as (#:COMMA-DOT foo)
;;; where #:COMMA is the value of the variable *COMMA* etc.

;;; BACKQUOTE is an ordinary macro (not a read-macro) that
;;; processes the expression foo, looking for occurrences of
;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT.  It constructs code
;;; in strict accordance with the rules on pages 349-350 of
;;; of the first edition (pages 528-529 of this second edition).
;;; It then optionally applies a code simplifier.

(set-macro-character #\`
                     #'(lambda (stream char)
                         (declare (ignore char))
                         (list 'backquote (read stream t nil t))))

(set-macro-character #\,
                     #'(lambda (stream char)
                         (declare (ignore char))
                         (case (peek-char nil stream t nil t)
                           (#\@ (read-char stream t nil t)
                            (list *comma-atsign* (read stream t nil t)))
                           (#\. (read-char stream t nil t)
                            (list *comma-dot* (read stream t nil t)))
                           (otherwise (list *comma* (read stream t nil t))))))

;;; if the value of *BQ-SIMPLIFY* is non-nil, then BACKQUOTE
;;; processing applies the code simplifier.  If the value is NIL,
;;; then the code resulting from BACKQUOTE is exactly that
;;; specified by the official rules.

(defvar *bq-simplify* t)

(defmacro backquote (x)
  (bq-completely-process x))

;;; Backquote processing proceeds in three stages:
;;;
;;; (1) BQ-PROCESS applies the rules to remove occurrences of
;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT corresponding to
;;; this level of BACKQUOTE.  (It also causes embedded calls to
;;; BACKQUOTE to be expanded so that nesting is properly handled.)
;;; Code is produced that is expressed in terms of functions
;;; #:BQ-LIST, #:BQ-APPEND, and #:BQ-CLOBBERABLE.  This is done
;;; so that the simplifier will simplify only list construction
;;; functions actually generated by backquote and will not involve
;;; any user code in the simplification.   #:BQ-LIST means LIST,
;;; #:BQ-APPEND means APPEND, and #:BQ-CLOBBERABLE means IDENTITY
;;; but indicates places where ",." was used and where NCONC may
;;; therefore be introduced by the simplifier for efficiency.
;;;
;;; (2) BQ-SIMPLIFY, if used, rewrites the code produced by
;;; BQ-PROCESS to produce equivalent but faster code.  The
;;; additional functions #:BQ-LIST* and #:BQ-NCONC may be
;;; introduced into the code.
;;;
;;; (3) BQ-REMOVE-TOKENS goes through the code and replaces
;;; #:BQ-LIST with LIST, #:BQ-APPEND with APPEND, and so on.
;;; #:BQ-CLOBBERABLE is simply eliminated (a call to it being
;;; replaced by its argument).  #:BQ-LIST* is replaced by either
;;; LIST* or CONS (the latter is used in the two-argument case,
;;; purely to make the resulting code a tad more readable).

(defun bq-completely-process (x)
  (let ((raw-result (bq-process x)))
    (bq-remove-tokens (if *bq-simplify*
                        (bq-simplify raw-result)
                        raw-result))))

; Portable code could just say (coerce list 'vector)
(defun list-to-vector (list)
  (unless (listp list)
    (setq list (require-type list 'list)))
  (%list-to-uvector nil list))

(define-compiler-macro list-to-vector (&whole whole form)
  (if (quoted-form-p form)
    (list-to-vector (cadr form))
    whole))

(defun bq-process (x)
  (cond ((atom x)
         (if (simple-vector-p x)
           (list 'list-to-vector (bq-process (coerce x 'list)))
           (list *bq-quote* x)))
        ((eq (car x) 'backquote)
         (bq-process (bq-completely-process (cadr x))))
        ((eq (car x) *comma*) (cadr x))
        ((eq (car x) *comma-atsign*)
         (error ",@~S after `" (cadr x)))
        ((eq (car x) *comma-dot*)
         (error ",.~S after `" (cadr x)))
        (t (do ((p x (cdr p))
                (q '() (cons (bracket (car p)) q)))
               ((atom p)
                (cons *bq-append*
                      (nreconc q (list (list *bq-quote* p)))))
             (when (eq (car p) *comma*)
               (unless (null (cddr p)) (error "Malformed ,~S" p))
               (return (cons *bq-append*
                             (nreconc q (list (cadr p))))))
             (when (eq (car p) *comma-atsign*)
               (error "Dotted ,@~S" p))
             (when (eq (car p) *comma-dot*)
               (error "Dotted ,.~S" p))))))

;;; This implements the bracket operator of the formal rules

(defun bracket (x)
  (cond ((atom x)
         (list *bq-list* (bq-process x)))
        ((eq (car x) *comma*)
         (list *bq-list* (cadr x)))
        ((eq (car x) *comma-atsign*)
         (cadr x))
        ((eq (car x) *comma-dot*)
         (list *bq-clobberable* (cadr x)))
        (t (list *bq-list* (bq-process x)))))

;;; This auxiliary function is like MAPCAR but has two extra
;;; purpoess: (1) it handles dotted lists; (2) it tries to make
;;; the result share with the argument x as much as possible.

(defun maptree (fn x)
  (if (atom x)
    (funcall fn x)
    (let ((a (funcall fn (car x)))
          (d (maptree fn (cdr x))))
      (if (and (eql a (car x)) (eql d (cdr x)))
        x
        (cons a d)))))

;;; This predicate is true of a form that when read looked
;;; like ,@foo or ,.foo

(defun bq-splicing-frob (x)
  (and (consp x)
       (or (eq (car x) *comma-atsign*)
           (eq (car x) *comma-dot*))))

;;; This predicate is true of a form that when read
;;; looked like ,@foo or just plain ,foo.

(defun bq-frob (x)
  (and (consp x)
       (or (eq (car x) *comma*)
           (eq (car x) *comma-atsign*)
           (eq (car x) *comma-dot*))))

;;; The simplifier essentially looks for calls to #:BQ-APPEND and
;;; tries to simplify them.  The arguments to #:BQ-APPEND are
;;; processed from right to left, building up a replacement for.
;;; At each step a number of special cases are handled that,
;;; loosely speaking, look like this:
;;;
;;; (APPEND (LIST a b c) foo) => (LIST* a b c foo)
;;;   provided a, b, c are not splicing frobs
;;; (APPEND (LIST* a b c) foo) => (LIST* a b (APPEND c foo))
;;;   provided a, b, c are not splicing frobs
;;; (APPEND (QUOTE (x)) foo) => (LIST* (QUOTE x) foo)
;;; (APPEND (CLOBBERABLE x) foo) => (NCONC x foo)

(defun bq-simplify (x)
  (if (atom x)
    x
    (let ((x (if (eq (car x) *bq-quote*)
               x
               (maptree #'bq-simplify x))))
      (if (not (eq (car x) *bq-append*))
        x
        (bq-simplify-args x)))))

(defun bq-simplify-args (x)
  (do ((args (reverse (cdr x)) (cdr args))
       (result
        nil
        (cond ((atom (car args))
               (bq-attach-append *bq-append* (car args) result))
              ((and (eq (caar args) *bq-list*)
                    (notany #'bq-splicing-frob (cdar args)))
               (bq-attach-conses (cdar args) result))
              ((and (eq (caar args) *bq-list**)
                    (notany #'bq-splicing-frob (cdar args)))
               (bq-attach-conses
                (reverse (cdr (reverse (cdar args))))
                (bq-attach-append *bq-append*
                                  (car (last (car args)))
                                  result)))
              ((and (eq (caar args) *bq-quote*)
                    (consp (cadar args))
                    (not (bq-frob (cadar args)))
                    (null (cddar args)))
               (bq-attach-conses (list (list *bq-quote*
                                             (caadar args)))
                                 result))
              ((eq (caar args) *bq-clobberable*)
               (bq-attach-append *bq-nconc* (cadar args) result))
              (t (bq-attach-append *bq-append*
                                   (car args)
                                   result)))))
      ((null args) result)))

(defun null-or-quoted (x)
  (or (null x) (and (consp x) (eq (car x) *bq-quote*))))

;;; When BQ-ATTACH-APPEND is called, the OP should be #:BQ-APPEND
;;; or #:BQ-NCONC.  This produces a form (op item result) but
;;; some simplifications are done on the fly:
;;;
;;;  (op '(a b c) '(d e f g)) => '(a b c d e f g)
;;;  (op item 'nil) => item, provided item is not a splicable frob
;;;  (op item 'nil) => (op item), if item is a splicable frob
;;;  (op item (op a b c)) => (op item a b c)

(defun bq-attach-append (op item result)
  (cond ((and (null-or-quoted item) (null-or-quoted result))
         (list *bq-quote* (append (cadr item) (cadr result))))
        ((or (null result) (equal result *bq-quote-nil*))
         (if (bq-splicing-frob item) (list op item) item))
        ((and (consp result) (eq (car result) op))
         (list* (car result) item (cdr result)))
        (t (list op item result))))

;;; The effec tof BQ-ATTACH-CONSES is to produce a form as if by
;;; `(LIST* ,@items ,result) but some simplifications are done
;;; on the fly.
;;;
;;;  (LIST* 'a 'b 'c 'd) => '(a b c . d)
;;;  (LIST* a b c 'nil) => (LIST a b c)
;;;  (LIST* a b c (LIST* d e f g)) => (LIST* a b c d e f g)
;;;  (LIST* a b c (LIST d e f g)) => (LIST a b c d e f g)

(defun bq-attach-conses (items result)
  (cond ((and (every #'null-or-quoted items)
              (null-or-quoted result))
         (list *bq-quote*
               (append (mapcar #'cadr items) (cadr result))))
        ((or (null result) (equal result *bq-quote-nil*))
         (cons *bq-list* items))
        ((and (consp result)
              (or (eq (car result) *Bq-list*)
                  (eq (car result) *bq-list**)))
         (cons (car result) (append items (cdr result))))
        (t (cons *bq-list** (append items (list result))))))

;;; Removes funny toeksn and changes (#:BQ-LIST* a b) into
;;; (CONS a b) instead of (LIST* a b), purely for readability.

(defun bq-remove-tokens (x)
  (cond ((eq x *bq-list*) 'list)
        ((eq x *bq-append*) 'append)
        ((eq x *bq-nconc*) 'nconc)
        ((eq x *bq-list**) 'list*)
        ((eq x *bq-quote*) 'quote)
        ((atom x) x)
        ((eq (car x) *bq-clobberable*)
         (bq-remove-tokens (cadr x)))
        ((and (eq (car x) *bq-list**)
              (consp (cddr x))
              (null (cdddr x)))
         (cons 'cons (maptree #'bq-remove-tokens (cdr x))))
        (t (maptree #'bq-remove-tokens x))))

)

#-nil
(progn
(declaim (special *|`,|* *|`,.|* *|`,@|*))

;;;Backquote reads in as a call to the BACKQUOTE-EXPANDER macro.
;;;This makes it a little obscure to look at raw, but makes it possible for
;;;the pretty-printer to print things read in with backquote.

(defvar *backquote-expand* t "If non-NIL, expand at read-time")

(defmacro backquote-expander (*|`,|* *|`,.|* *|`,@|* form)
   (declare (special *|`,|* *|`,.|* *|`,@|*))
   (multiple-value-bind (form constantp) (backquote-aux form)
     (backq-form form constantp)))

(defun backquote-aux (form)
  ;;Doesn't try to optimize multiple CONS's into LIST/LIST*'s, leaving it up
  ;;to the compiler.  The code here is mainly concerned with folding
  ;;constants, since the compiler is not allowed to do that in general.
  (cond
   ((simple-vector-p form)
    (let ((elts ()) (i (length form)))
      (until (%izerop i) (push (svref form (setq i (%i- i 1))) elts))
      (multiple-value-bind (elts quotedp) (backquote-aux elts)
        (if quotedp
          (values (list-to-vector elts) t)
          (list 'list-to-vector elts)))))
   ((self-evaluating-p form) (values form t))
   ((atom form) (values form t))
   ((eq (%car form) 'backquote-expander) (backquote-aux (macroexpand-1 form)))
   ((eq (%car form) *|`,|*) (%cdr form))
   ((eq (%car form) *|`,@|*) (error "Misplaced ,@~S after backquote" (%cdr form)))
   ((eq (%car form) *|`,.|*) (error "Misplaced ,.~S after backquote" (%cdr form)))
   (t (let* ((car (%car form))
             (splice (and (consp car) (if (eq (%car car) *|`,@|*) 'append
                                        (if (eq (%car car) *|`,.|*) 'nconc)))))
        (multiple-value-bind (cdr qd) (backquote-aux (%cdr form))
          (if splice
            (cond ((null (%cdr car)) (values cdr qd))
                  ((null cdr) (values (%cdr car) (self-evaluating-p (%cdr car))))
                  (t (list splice (%cdr car) (backq-form cdr qd))))
            (multiple-value-bind (car qa) (backquote-aux car)
              (cond ((and qa qd) (values (cons car cdr) t))
                    ((null cdr) (list 'list car))
                    (t (list 'list*     ; was CONS
                             (backq-form car qa) (backq-form cdr qd)))))))))))

(defun backq-form (form constantp)
  (if (and constantp (not (self-evaluating-p form))) (list 'quote form) form))

(defparameter *backquote-stack* ())

(set-macro-character 
 #\`
 (nfunction 
  |` reader|
  (lambda (stream char &aux form)
    (declare (ignore char))
    (setq form
          (let* ((|`,| (make-symbol "`,"))
                 (|`,.| (make-symbol "`,."))
                 (|`,@| (make-symbol "`,@")))
            (list 'backquote-expander |`,| |`,.| |`,@|
                  (let ((*backquote-stack* (list* |`,| |`,.| |`,@| *backquote-stack*)))
                    (read stream t nil t)))))
    (if *backquote-expand* (values (macroexpand-1 form)) form))))

(set-macro-character 
 #\, 
 (nfunction
  |, reader| 
  (lambda (stream char &aux (stack *backquote-stack*))
    (when (null stack)
      (signal-reader-error stream "Comma not inside backquote"))
    (let ((*backquote-stack* (cdddr stack)))
      (setq char (tyi stream))
      (cond ((eq char #\@)
             (cons (%caddr stack) (read stream t nil t)))
            ((eq char #\.)
             (cons (%cadr stack) (read stream t nil t)))
            (t
             (untyi char stream)
             (cons (%car stack) (read stream t nil t))))))))
)

(provide 'backquote)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/backquote.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/backtrace-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; backtrace-lds.lisp
;;; low-level support for stack-backtrace dialog (Lisp Development System)

(in-package "CCL")


(defparameter *saved-register-count*
  #+(or x8632-target arm-target) 0
  #+x8664-target 4
  #+ppc-target 8)

(defparameter *saved-register-names*
  #+(or x8632-target arm-target) nil
  #+x8664-target #(save3 save2 save1 save0)
  #+ppc-target #(save7 save6 save5 save4 save3 save2 save1 save0))

(defun frame-function (frame context)
  "Returns the function using the frame, and pc offset within the function, if known"
  (declare (ignore context))
  (cfp-lfun frame))

(defun frame-supplied-arguments (frame context &key (unknown-marker (%unbound-marker)))
  "Return a list of supplied arguments to the call which opened this frame, as best we can reconstruct it"
  (multiple-value-bind (lfun pc) (cfp-lfun frame)
    (multiple-value-bind (args valid) (supplied-argument-list context frame lfun pc)
      (if (not valid)
        unknown-marker
        (if (eq unknown-marker (%unbound-marker))
          args
          (substitute unknown-marker (%unbound-marker) args))))))

(defun frame-named-variables (frame context &key (unknown-marker (%unbound-marker)))
  "Returns an alist of (NAME . VALUE) of all named variables in this frame."
  (multiple-value-bind (lfun pc) (cfp-lfun frame)
    (multiple-value-bind (args locals) (arguments-and-locals context frame lfun pc unknown-marker)
      (if (eq unknown-marker (%unbound-marker))
        (append args locals)
        (substitute unknown-marker (%unbound-marker) (append args locals))))))


(defun frame-arguments-and-locals (frame context &key unknown-marker)
  "Return two values, the arguments and the locals, known for this frame, as alists of (name . value)"
  (multiple-value-bind (lfun pc) (cfp-lfun frame)
    (arguments-and-locals context frame lfun pc unknown-marker)))

;;; Returns three values: (ARG-VALUES TYPES NAMES), solely for the benefit
;;; of the FRAME-ARGUMENTS function in SLIME's swank-openmcl.lisp.
;;; ARG-VALUES is a list of the values of the args supplied to the function
;;; TYPES is a list of (for bad historical reasons) strings .describing
;;;   whether they're "required", "optional", etc.  SLIME only really
;;;   cares about whether this is equal to "keyword" or not.
;;; NAMES is a list of symbols which name the args.
;; 7/13/2009: This is now deprecated.  Use frame-supplied-arguments.
(defun frame-supplied-args (frame lfun pc child context)
  (declare (ignore child))
  (if (null pc)
    (values nil nil nil)
    (if (<= pc target::arg-check-trap-pc-limit)
      (values (arg-check-call-arguments frame lfun) nil nil)
      (multiple-value-bind (arglist valid) (arglist-from-map lfun)
        (if (not valid)
          (values nil nil nil)
          (let* ((args (arguments-and-locals context frame lfun pc))
                 (state :required))
            (collect ((arg-values)
                      (types)
                      (names))
              (dolist (arg arglist)
                (if (or (member arg lambda-list-keywords)
                        (eq arg '&lexpr))
                  (setq state arg)
                  (let* ((pair (pop args)))
                    (case state
                      (&lexpr
                         (with-list-from-lexpr (rest (cdr pair))
                           (dolist (r rest) (arg-values r) (names nil) (types nil)))
                         (return))
                      (&rest
                         (dolist (r (cdr pair)) (arg-values r) (names nil) (types nil))
                         (return))
                      (&key
                         (arg-values arg)
                         (names nil)
                         (types nil)))
                    (let* ((value (cdr pair)))
                      (if (eq value (%unbound-marker))
                        (return))
                      (names (car pair))
                      (arg-values value)
                      (types nil)))))
              (values (arg-values) (types) (names)))))))))


#|
(setq *save-local-symbols* t)

(defun test (flip flop &optional bar)
  (let ((another-one t)
        (bar 'quux))
    (break)))

(test '(a b c d) #\a)

(defun closure-test (flim flam)
  (labels ((inner (x)
              (let ((ret (list x flam)))
                (break))))
    (inner flim)
    (break)))

(closure-test '(a b c) 'quux)

(defun set-test (a b)
  (break)
  (+ a b))

(set-test 1 'a)

||#


(provide 'backtrace-lds)

; End of backtrace-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/backtrace-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/backtrace.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; backtrace.lisp
;;; low-level support for stack-backtrace printing

(in-package "CCL")

#+ppc-target (require "PPC-BACKTRACE")
#+x86-target (require "X86-BACKTRACE")
#+arm-target (require "ARM-BACKTRACE")


(defparameter *backtrace-show-internal-frames* nil)
(defparameter *backtrace-print-level* 2)
(defparameter *backtrace-print-length* 5)
(defparameter *backtrace-print-string-length* :default)

(defparameter *backtrace-format* :traditional
  "If :TRADITIONAL, shows calls to non-toplevel functions using FUNCALL, and shows frame address values.
   If :DIRECT, uses a more streamlined format.")

(defun context-for-suspended-tcr (tcr)
  (let ((frame-ptr (%tcr-frame-ptr tcr)))
    (new-backtrace-info nil
                        frame-ptr ;; youngest - not used
                        frame-ptr ;; oldest - not used
                        tcr
                        nil       ;; condition - not used
                        frame-ptr ;; current
                        #+ppc-target *fake-stack-frames*
                        #+(or x86-target arm-target) frame-ptr
                        (%fixnum-ref tcr (- target::tcr.db-link
					    target::tcr-bias))
                        0         ;; break level - not used
                        )))
  

(defun backtrace-as-list (&key
                          context
                          process
                          origin
                          (count target::target-most-positive-fixnum)
                          (start-frame-number 0)
                          (print-level *backtrace-print-level*)
                          (print-length *backtrace-print-length*)
                          (print-string-length *backtrace-print-string-length*)
                          (show-internal-frames *backtrace-show-internal-frames*))
  "Returns a list representing the backtrace.
Each element in the list is a list that describes the call in one stack frame:
   (function arg1 arg2 ...)
The arguments are represented by strings, the function is a symbol or a function
object."
  (let* ((*backtrace-print-level* print-level)
         (*backtrace-print-length* print-length)
         (*backtrace-print-string-length* print-string-length)
         (*backtrace-format* :list)
         (result nil))
    (map-call-frames (lambda (p context)
                       (multiple-value-bind (lfun pc) (cfp-lfun p)
                         (push (if lfun
                                 (backtrace-call-arguments context p lfun pc)
                                 "?????")
                               result)))
                     :context context
                     :process process
                     :origin origin
                     :count count
                     :start-frame-number start-frame-number
                     :test (and (not show-internal-frames) 'function-frame-p))
    (nreverse result)))

(defun print-call-history (&key context
                                process
                                origin
                                (detailed-p t)
                                (count target::target-most-positive-fixnum)
                                (start-frame-number 0)
                                (stream *debug-io*)
                                (print-level *backtrace-print-level*)
                                (print-length *backtrace-print-length*)
                                (print-string-length *backtrace-print-string-length*)
                                (show-internal-frames *backtrace-show-internal-frames*)
                                (format *backtrace-format*))
  (let ((*backtrace-print-level* print-level)
        (*backtrace-print-length* print-length)
        (*backtrace-print-string-length* print-string-length)
        (*backtrace-format* format)
        (*standard-output* stream)
        (*print-circle* nil)
        (frame-number (or start-frame-number 0)))
    (map-call-frames (lambda (p context)
                       (multiple-value-bind (lfun pc) (cfp-lfun p)
                         (unless (and (typep detailed-p 'fixnum)
                                      (not (= (the fixnum detailed-p) frame-number)))
                           (%show-stack-frame-label frame-number p context lfun pc detailed-p)
                           (when detailed-p
                             (if (or (eq detailed-p :raw) (null lfun))
                               (%show-stack-frame p context lfun pc)
                               (%show-args-and-locals p context lfun pc)))
                           (incf frame-number))))
                     :context context
                     :process process
                     :origin origin
                     :count count
                     :start-frame-number start-frame-number
                     :test (and (not show-internal-frames) 'function-frame-p))
    (values)))

(defun function-frame-p (p context)
  (and (not (catch-csp-p p context)) (cfp-lfun p)))

(defun map-call-frames (fn &key context
                           process
			   origin
                           (count target::target-most-positive-fixnum)
			   (start-frame-number 0)
                           test)
  (when (and context process (neq (bt.tcr context) (process-tcr process)))
    (error "Context ~s doesn't correspond to the process ~s" context process))
  (let ((tcr (cond (context (bt.tcr context))
                   (process (process-tcr process))
                   (t (%current-tcr))))
        (*print-catch-errors* t)
        (*signal-printing-errors* nil))
    (if (eq tcr (%current-tcr))
      (%map-call-frames-internal fn context (or origin (%get-frame-ptr)) count start-frame-number test)
      (unwind-protect
	   (progn
	     (%suspend-tcr tcr)
             (when (null context)
               (setq context (context-for-suspended-tcr tcr)))
             (%map-call-frames-internal fn context (or origin (bt.current context))  count start-frame-number test))
	(%resume-tcr tcr))))
  nil)

; RAW case
(defun %show-stack-frame (p context lfun pc)
  (handler-case
      (multiple-value-bind (count vsp parent-vsp) (count-values-in-frame p context)
	(declare (fixnum count))
	(dotimes (i count)
	  (multiple-value-bind (var type name) 
			       (nth-value-in-frame p i context lfun pc vsp parent-vsp)
	    (format t "~&  ~D " i)
	    (when name (format t "~s" name))
	    (let* ((*print-length* (default-print-length *backtrace-print-length*))
		   (*print-level* (default-print-level *backtrace-print-level*))
                   (*print-string-length* (default-print-string-length *backtrace-print-string-length*)))
	      (format t ": ~s" var))
	    (when type (format t " (~S)" type)))))
    (error () (format t "#<error printing frame>")))
  (terpri)
  (terpri))

(defun %show-args-and-locals (p context lfun pc)
  (handler-case
      (let* ((unavailable (cons nil nil)))
	(multiple-value-bind (args locals) (arguments-and-locals context p lfun pc unavailable)
          (case *backtrace-format*
            (:direct
               (format t "~&     Arguments: ~:s" (arglist-from-map lfun)))
            (t (format t "~&  ~s" (arglist-from-map lfun))))
	  (let* ((*print-length* (default-print-length *backtrace-print-length*))
		 (*print-level* (default-print-level *backtrace-print-level*))
                 (*print-string-length* (default-print-string-length *backtrace-print-string-length*)))
	    (flet ((show-pair (pair prefix)
		     (destructuring-bind (name . val) pair
		       (format t "~&~a~s: " prefix name)
		       (if (eq val unavailable)
			 (format t "#<Unavailable>")
			 (format t "~s" val)))))
              (case *backtrace-format*
                (:direct
                   (when args
                     (dolist (arg args)
                       (show-pair arg "       ")))
                   (when locals
                     ;; This shows all bindings (including specials), but help on debugger
                     ;; commands refers to "locals", so say both words...
                     (format t "~&     Local bindings:")
                     (dolist (loc locals)
                       (show-pair loc "       "))))
                (t
                   (dolist (arg args)
                     (show-pair arg "   "))
                   (terpri)
                   (terpri)
                   (dolist (loc locals)
                     (show-pair loc "  "))))))))
    (error () (format t "#<error printing args and locals>")))
  (terpri)
  (terpri))


(defun backtrace-call-arguments (context cfp lfun pc)
  (nconc (let* ((name (function-name lfun)))
           (if (function-is-current-definition? lfun)
             (list name)
             (case *backtrace-format*
               (:direct
                  (list (format nil "~s" (or name lfun))))
               (:list
                  (list 'funcall (format nil "~s" (or name lfun))))
               (t (list 'funcall `(function ,(concatenate 'string "#<" (%lfun-name-string lfun) ">")))))))
         (backtrace-supplied-args context cfp lfun pc)))

(defun backtrace-supplied-args (context frame lfun pc)
  (multiple-value-bind (args valid) (supplied-argument-list context frame lfun pc)
    (if (not valid)
      '("???")    
      (loop for arg in args
            collect (if (eq arg (%unbound-marker))
                      "?"
                      (let* ((*print-length* (default-print-length *backtrace-print-length*))
                             (*print-level* (default-print-level *backtrace-print-level*))
                             (*print-string-length* (default-print-string-length *backtrace-print-string-length*)))
                        (format nil "~s" arg)))))))

;;; Return a list of "interesting" frame addresses in context, most
;;; recent first.
(defun %stack-frames-in-context (context &optional (include-internal *backtrace-show-internal-frames*))
  (collect ((frames))
    (do* ((p (bt.youngest context) (parent-frame p context))
          (q (bt.oldest context)))
         ((eql p q) (frames))
      (when (or (not (catch-csp-p p context)) include-internal)
        (when (or (cfp-lfun p) include-internal)
          (frames p))))))

(defun %map-call-frames-internal (fn context origin count skip-initial test)
  (when (null skip-initial) (setq skip-initial 0))
  (when (null count) (setq count target::target-most-positive-fixnum))
  (unless (eq (last-frame-ptr context origin) (last-frame-ptr context))
    (error "Origin ~s is not in the stack of ~s" origin context))
  (let ((q (last-frame-ptr context))
        (frame-number 0))
    (do ((p origin (parent-frame p context)))
        ((or (null p) (eq p q) (%stack< q p context) (<= count 0)) nil)
      (when (or (null test) (funcall test p context))
        (when (<= skip-initial frame-number)
          (funcall fn p context)
          (decf count))
        (incf frame-number)))))

(defun %show-stack-frame-label (frame-number p context lfun pc detailed-p)
  (case *backtrace-format*
    (:direct
       (let ((call (backtrace-call-arguments context p lfun pc)))
         (format t "~&~3D: ~a ~a~@d~:[~; [Exception]~]"
                 frame-number
                 (if lfun
                   (if detailed-p (car call) call)
                   "<non-function frame>")
                 "at pc "
                 pc
                 (exception-frame-p p))))
    (t (format t "~&~c(~x) : ~D ~a ~d"
                      (if (exception-frame-p p)  #\* #\space)
                      (index->address p) frame-number
                      (if lfun (backtrace-call-arguments context p lfun pc))
                      pc))))


(defun %access-lisp-data (vstack-index)
  (%fixnum-ref vstack-index))

(defun %store-lisp-data (vstack-index value)
  (setf (%fixnum-ref vstack-index) value))

(defun closed-over-value (data)
  (if (closed-over-value-p data)
    (uvref data 0)
    data))

(defun set-closed-over-value (value-cell value)
  (setf (uvref value-cell 0) value))



;;; Act as if VSTACK-INDEX points at some lisp data & return that data.
(defun access-lisp-data (vstack-index)
  (closed-over-value (%access-lisp-data vstack-index)))

(defun find-local-name (cellno lfun pc)
  (let* ((n cellno))
    (when lfun
      (multiple-value-bind (mask where) (registers-used-by lfun pc)
        (if (and where (< (1- where) n (+ where (logcount mask))))
          (let ((j *saved-register-count*))
            (decf n where)
            (loop (loop (if (logbitp (decf j) mask) (return)))
                  (if (< (decf n) 0) (return)))
            (values (format nil "saved ~a" (aref *saved-register-names* j))
                    nil))
          (multiple-value-bind (nreq nopt restp nkeys junk optinitp junk ncells nclosed)
                               (if lfun (function-args lfun))
            (declare (ignore junk optinitp))
            (if nkeys (setq nkeys (+ nkeys nkeys)))
            (values
             (if (and ncells (< n ncells))
               (if (< n nclosed)
                 :inherited
                 (if (< (setq n (- n nclosed)) nreq)
                   "required"
                   (if (< (setq n (- n nreq)) nopt)
                     "optional"
                     (progn
                       (setq n (- n nopt))
                       (progn
                         (if (and nkeys (< n nkeys))
                           (if (not (logbitp 0 n)) ; a keyword
                             "keyword"
                             "key-supplied-p")
                           (progn
                             (if nkeys (setq n (- n nkeys)))
                             (if (and restp (zerop n))
                               "rest"
                               "opt-supplied-p")))))))))
             (match-local-name cellno (function-symbol-map lfun) pc))))))))

(defun map-entry-value (context cfp lfun pc idx unavailable)
  (declare (fixnum pc idx))
  (let* ((info (function-symbol-map lfun)))
    (if (null info)
      unavailable
      (let* ((addrs (cdr info))
             (i (* 3 idx))
             (addr (uvref addrs i))
             (startpc (uvref addrs (the fixnum (+ i 1))))
             (endpc (uvref addrs (the fixnum (+ i 2)))))
        (declare (fixnum i addr startpc endpc))
        (if (or (< pc startpc)
                (>= pc endpc))
          unavailable
          (let* ((value (if (= #o77 (ldb (byte 6 0) addr))
                          (raw-frame-ref cfp context (ash addr (- (+ target::word-shift 6)))
                                         unavailable)
                          (find-register-argument-value context cfp addr unavailable))))
            (if (typep value 'value-cell)
              (uvref value 0)
              value)))))))

;;; Returns non-nil on success (not newval)
(defun set-map-entry-value (context cfp lfun pc idx newval)
  (declare (fixnum pc idx))
  (let* ((unavailable (cons nil nil))
         (value (map-entry-value context cfp lfun pc idx unavailable)))
    (if (eq value unavailable)
      nil
      (if (typep value 'value-cell)
        (progn (setf (uvref value 0) newval) t)

        (let* ((addrs (cdr (function-symbol-map lfun)))
               (addr (uvref addrs (the fixnum (* 3 idx)))))
          (declare (fixnum  addr))
          (if (= #o77 (ldb (byte 6 0) addr))
            (raw-frame-set cfp context (ash addr (- (+ target::word-shift 6))) newval)
            (set-register-argument-value context cfp addr newval))
          t)))))

          
(defun argument-value (context cfp lfun pc name &optional (quote t))
  (declare (fixnum pc))
  (let* ((info (function-symbol-map lfun))
         (unavailable (%unbound-marker)))
    (if (null info)
      unavailable
      (let* ((names (car info))
             (addrs (cdr info)))
        (do* ((nname (1- (length names)) (1- nname))
              (naddr (- (length addrs) 3) (- naddr 3)))
             ((or (< nname 0) (< naddr 0)) unavailable)
          (declare (fixnum nname naddr))
          (when (eq (svref names nname) name)
            (let* ((value
                    (let* ((addr (uvref addrs naddr))
                           (startpc (uvref addrs (the fixnum (1+ naddr))))
                           (endpc (uvref addrs (the fixnum (+ naddr 2)))))
                      (declare (fixnum addr startpc endpc))
                      (if (or (< pc startpc)
                              (>= pc endpc))
                        unavailable
                        (if (= #o77 (ldb (byte 6 0) addr))
                          (raw-frame-ref cfp context (ash addr (- (+ target::word-shift 6)))
                                         unavailable)
                          (find-register-argument-value context cfp addr unavailable))))))
              (if (typep value 'value-cell)
                (setq value (uvref value 0)))
              (if (or (not quote) (self-evaluating-p value))
                (return value)
                (return (list 'quote value))))))))))



(defun raw-frame-ref (cfp context index bad)
  (%raw-frame-ref cfp context index bad))

(defun raw-frame-set (cfp context index new)
  (%raw-frame-set cfp context index new))
  
(defun find-register-argument-value (context cfp regval bad)
  (%find-register-argument-value context cfp regval bad))

(defun set-register-argument-value (context cfp regval newval)
  (%set-register-argument-value context cfp regval newval))

    

(defun dbg-form (frame-number)
  (when *break-frame*
    (let* ((cfp (nth-raw-frame frame-number *break-frame* nil)))
      (if (and cfp (not (catch-csp-p cfp nil)))
        (multiple-value-bind (function pc)
            (cfp-lfun cfp)
          (if (and function
                   (function-is-current-definition? function))
            (block %cfp-form
              (collect ((form))
                (multiple-value-bind (nreq nopt restp keys allow-other-keys
                                           optinit lexprp ncells nclosed)
                    (function-args function)
                  (declare (ignore ncells))
                  (unless (or lexprp restp (> 0 nclosed) (> 0 nopt) keys allow-other-keys
                              optinit)
                    (let* ((name (function-name function)))
                      (multiple-value-bind (arglist win)
                          (arglist-from-map function)
                      (when (and win name (symbolp name))
                        (form name)
                        (dotimes (i nreq)
                          (let* ((val (argument-value nil cfp function pc (pop arglist))))
                            (if (closed-over-value-p val)
                              (setq val (%svref val target::value-cell.value-cell)))
                            (if (eq val (%unbound-marker))
                              (return-from %cfp-form nil))
                            (form val))))))))
                (form)))))))))

(defun function-args (lfun)
  "Returns 9 values, as follows:
     req = number of required arguments
     opt = number of optional arguments
     restp = t if rest arg
     keys = number of keyword arguments or NIL if &key not mentioned
     allow-other-keys = t if &allow-other-keys present
     optinit = t if any optional arg has non-nil default value or supplied-p
               variable
     lexprp = t if function is a lexpr, in which case all other values are
              undefined.
     ncells = number of stack frame cells used by all arguments.
     nclosed = number of inherited values (now counted distinctly from required)
     All numeric values (but ncells) are mod 64."
  (let* ((bits (lfun-bits lfun))
         (req (ldb $lfbits-numreq bits))
         (opt (ldb $lfbits-numopt bits))
         (restp (logbitp $lfbits-rest-bit bits))
         (keyvect (lfun-keyvect lfun))
         (keys (and keyvect (length keyvect)))
         (allow-other-keys (logbitp $lfbits-aok-bit bits))
         (optinit (logbitp $lfbits-optinit-bit bits))
         (lexprp (logbitp $lfbits-restv-bit bits))
         (nclosed (ldb $lfbits-numinh bits)))
    (values req opt restp keys allow-other-keys optinit lexprp
            (unless (or lexprp)
              (+ req opt (if restp 1 0) (if keys (+ keys keys) 0)
                 (if optinit opt 0) nclosed))
            nclosed)))

;;; If we can tell reliably, return the function's minimum number of
;;; non-inherited arguments, the maximum number of such arguments (or NIL),
;;; and the actual number of such arguments.  We "can't tell" if either
;;; of the arguments to this function are null, and we can't tell reliably
;;; if any of the lfbits fields are full.
(defun min-max-actual-args (fn nargs)
  (let* ((lfbits (if (and fn nargs)
		   (lfun-bits fn)
		   -1))
	 (raw-req (ldb $lfbits-numreq lfbits))
	 (raw-opt (ldb $lfbits-numopt lfbits))
	 (raw-inh (ldb $lfbits-numinh lfbits)))
    (declare (fixnum raw-req raw-opt raw-inh))
    (if (or (eql raw-req (1- (ash 1 (byte-size $lfbits-numreq))))
	    (eql raw-opt (1- (ash 1 (byte-size $lfbits-numopt))))
	    (eql raw-inh (1- (ash 1 (byte-size $lfbits-numinh)))))
      (values nil nil nil)
      (values raw-req
	      (unless (or (lfun-keyvect fn)
			  (logbitp $lfbits-rest-bit lfbits)
			  (logbitp $lfbits-restv-bit lfbits))
		(+ raw-req raw-opt))
	      (- nargs raw-inh)))))



(defun closed-over-value-p (value)
  (eql target::subtag-value-cell (typecode value)))


(defun variables-in-scope (lfun pc)
  ;; Return a list of all symbol names "in scope" in the function lfun
  ;; at relative program counter PC, using the function's symbol map.
  ;; The list will be ordered so that least-recent bindings appear first.
  ;; Return a list of the matching symbol map entries as a second value
  (when pc
    (locally (declare (fixnum pc))
      (let* ((map (function-symbol-map lfun))
             (names (car map))
             (info (cdr map)))
        (when map
          (let* ((vars ())
                 (indices ()))
            (dotimes (i (length names) (values vars indices))
              (let* ((start-pc (aref info (1+ (* 3 i))))
                     (end-pc (aref info (+ 2 (* 3 i)))))
                (declare (fixnum start-pc end-pc))
                (when (and (>= pc start-pc)
                           (< pc end-pc))
                  (push i indices)
                  (push (svref names i) vars))))))))))


(defun arg-value (context cfp lfun pc unavailable name)
  (multiple-value-bind (vars map-indices) (variables-in-scope lfun pc)
    (multiple-value-bind (valid req opt rest keys)
        (arg-names-from-map lfun pc)
      (if valid
        (let* ((nargs (+ (length req) (length opt) (if rest 1 0) (length keys)))
               (pos (position name vars)))
          (if (and pos (< pos nargs))
            (map-entry-value context cfp lfun pc (nth pos map-indices) unavailable)
            unavailable))
        unavailable))))

(defun local-value (context cfp lfun pc unavailable name)
  (multiple-value-bind (vars map-indices) (variables-in-scope lfun pc)
    (multiple-value-bind (valid req opt rest keys)
        (arg-names-from-map lfun pc)
      (if valid
        (let* ((nargs (+ (length req) (length opt) (if rest 1 0) (length keys)))
               (names (nthcdr nargs vars))
               (indices (nthcdr nargs map-indices))
               (pos (if (typep name 'unsigned-byte)
                      name
                      (position name names :from-end t))))
          (if pos
            (map-entry-value context cfp lfun pc (nth pos indices) unavailable)
            unavailable))
        unavailable))))

(defun set-arg-value (context cfp lfun pc name new)
  (multiple-value-bind (vars map-indices) (variables-in-scope lfun pc)
    (multiple-value-bind (valid req opt rest keys)
        (arg-names-from-map lfun pc)
      (if valid
        (let* ((nargs (+ (length req) (length opt) (if rest 1 0) (length keys)))
               (pos (position name vars)))
          (when (and pos (< pos nargs))
            (set-map-entry-value context cfp lfun pc (nth pos map-indices) new)))))))

(defun set-local-value (context cfp lfun pc name new)
  (multiple-value-bind (vars map-indices) (variables-in-scope lfun pc)
    (multiple-value-bind (valid req opt rest keys)
        (arg-names-from-map lfun pc)
      (if valid
        (let* ((nargs (+ (length req) (length opt) (if rest 1 0) (length keys)))
               (names (nthcdr nargs vars))
               (indices (nthcdr nargs map-indices))
               (pos (if (typep name 'unsigned-byte)
                      name
                      (position name names :from-end t))))
          (if (and pos (< pos nargs))
            (set-map-entry-value context cfp lfun pc (nth pos indices) new)))))))


(defun arguments-and-locals (context cfp lfun pc &optional unavailable)
  (multiple-value-bind (vars map-indices) (variables-in-scope lfun pc)
    (collect ((args)
              (inherited-indices)
              (inherited-vars)
              (locals))
      (multiple-value-bind (valid req opt rest keys)
          (arg-names-from-map lfun pc)
        (when valid
          (let* ((numinh (ldb $lfbits-numinh (lfun-bits lfun))))
            (dotimes (i numinh)
              (inherited-indices (pop map-indices))
              (inherited-vars (pop vars))))
          (let* ((nargs (+ (length req) (length opt) (if rest 1 0) (length keys)))
                 (nlocals (- (length vars) nargs))
                 (local-vars (append (nthcdr nargs vars) (inherited-vars)))
                 (local-indices (append (nthcdr nargs map-indices) (inherited-indices)))
                 (arg-vars (if (<= nlocals 0) vars (nbutlast vars nlocals)))
                 (arg-indices (if (<= nlocals 0) map-indices (nbutlast map-indices nlocals))))
            (flet ((get-arg-value (name)
                     (let* ((pos (position name arg-vars :test #'eq)))
                       (when pos
                         (args (cons name (map-entry-value context cfp lfun pc (nth pos arg-indices) unavailable))))))
                   (get-local-value (name)
                     (when name
                       (locals (cons name (map-entry-value context cfp lfun pc (pop local-indices) unavailable))))))
              (dolist (name req)
                (get-arg-value name))
              (dolist (name opt)
                (get-arg-value name))
              (when rest
                (get-arg-value rest))
              (dolist (name keys)
                (get-arg-value name))
              (dolist (name local-vars)
                (get-local-value name)))))
           (values (args) (locals))))))

;; Return list of supplied arguments, as best we can reconstruct it.
(defun supplied-argument-list (context frame lfun pc)
  (if (null pc)
    (values nil nil)
    (if (<= pc target::arg-check-trap-pc-limit)
      (values (arg-check-call-arguments frame lfun) t)
      (multiple-value-bind (params valid) (arglist-from-map lfun)
        (if (not valid)
          (values nil nil)
          (let* ((args (arguments-and-locals context frame lfun pc)) ;overkill, but will do.
                 (state :required)
                 (result ()))
            (dolist (param params)
              (if (or (member param lambda-list-keywords) (eq param '&lexpr))
                (setq state param)
                (let* ((pair (pop args))
                       (value (cdr pair)))
                  (case state
                    (&lexpr
                     (with-list-from-lexpr (rest value)
                       (dolist (r rest) (push r result)))
                     (return))
                    (&rest
                     (unless (listp value) (setf value (list value)))
                     (dolist (r value) (push r result))
                     (return))
                    (&key (push param result)))
                  (push value result))))
            (values (nreverse result) t)))))))


(defun safe-cell-value (val)
  val)

(defun closure-closed-over-values (closure)
  (when (typep closure 'compiled-lexical-closure)
    (let* ((inner (closure-function closure))
           (nclosed (nth-value 8 (function-args inner)))
           (names (car (function-symbol-map inner))))
      (when nclosed
        (collect ((cells))
          (do* ((i (1- (length names)) (1- i))
                (k 0 (1+ k))
                (idx 2 (1+ idx)))
               ((= k nclosed) (reverse (cells)))
            (let* ((name (svref names i))
                   (imm (nth-immediate closure idx)))
              (cells (list name (if (closed-over-value-p imm)
                                  (closed-over-value imm)
                                  imm))))))))))

      
;;; Find the oldest binding frame that binds the same symbol as
;;; FRAME in context.  If found, return the saved value of that
;;; binding, else the value of the symbol in the context's thread.
(defun oldest-binding-frame-value (context frame)
  (let* ((oldest nil)
         (binding-index (%fixnum-ref frame (ash 1 target::fixnum-shift))))
    (do* ((db (db-link context) (%fixnum-ref db 0)))
         ((eq frame db)
          (if oldest
            (%fixnum-ref oldest (ash 2 target::fixnum-shift))
            (let* ((symbol (binding-index-symbol binding-index)))
              (if context
                (symbol-value-in-tcr symbol (bt.tcr context))
                (%sym-value symbol)))))
      (if (eq (%fixnum-ref db (ash 1 target::fixnum-shift)) binding-index)
        (setq oldest db)))))

(defun (setf oldest-binding-frame-value) (new context frame)
  (let* ((oldest nil)
         (binding-index (%fixnum-ref frame (ash 1 target::fixnum-shift))))
    (do* ((db (db-link context) (%fixnum-ref db 0)))
         ((eq frame db)
          (if oldest
            (setf (%fixnum-ref oldest (ash 2 target::fixnum-shift)) new)
            (let* ((symbol (binding-index-symbol binding-index)))
              (if context
                (setf (symbol-value-in-tcr symbol (bt.tcr context)) new)
                (%set-sym-value symbol new)))))
      (if (eq (%fixnum-ref db (ash 1 target::fixnum-shift)) binding-index)
        (setq oldest db)))))
    


;;; End of backtrace.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/backtrace.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/case-error.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;I wanted a read that would not error even when given a #<
; and also allow backspace and such.
(defun read-line-no-error (&optional (stream *standard-output*) &aux result)
  (ignore-errors
     (setq result (read-from-string (read-line stream) nil))
     (return-from read-line-no-error (values result t)))
  (values nil nil))



;;;; Assert & Check-Type

;;; Assert-Value-Prompt  --  Internal
;;;
;;;    Prompt for a new value to set a place to.   We do a read-line,
;;; and if there is anything there, we eval it and return the second
;;; value true, otherwise it is false.
;;;
(defun assertion-value-prompt (place)
  (let* ((nvals (length (nth-value 2 (get-setf-method-multiple-value place))))
         (vals nil))
    (dotimes (i nvals)
      (if (eq nvals 1)
        (format *query-io* "Value for ~S: " place)
        (format *query-io* "Value ~D for ~S: " i place))
      (let* ((line (read-line *query-io*))
             (object  (read-from-string line nil *eof-value*)))
        (if (eq object *eof-value*)
            (return)
            (push (eval object) vals))))
    (values (nreverse vals) (not (null vals)))))

(defun %assertion-failure (setf-places-p test-form string &rest condition-args)
  (cerror 
   (if setf-places-p 
     "allow some places to be set and test the assertion again."
     "test the assertion again.")
   (cond
    ((stringp string)
     (make-condition 'simple-error
                     :format-control string
                     :format-arguments  condition-args))
    ((null string)
     (make-condition 'simple-error
                     :format-control "Failed assertion: ~S"
                     :format-arguments (list test-form)))
    ((typep string 'condition)
     (when  condition-args (error "No args ~S allowed with a condition ~S"  condition-args string))
     string)
    (t (apply #'make-condition string  condition-args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/case-error.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/ccl-export-syms.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (export				;remember "CCL" at end of list
					;setq %ccl-package-export-syms
   '(
     local
     set-local
     @
     *elements-per-buffer*
     save-application
     def-load-pointers
     *save-exit-functions*
     *restore-lisp-functions*
     *lisp-cleanup-functions*
     *lisp-startup-functions*
     defloadvar
     defstatic
     defstaticvar
     *break-on-warnings*
					; misc
     record-source-file
     get-source-files
     edit-definition
     edit-definition-p
     *loading-file-source-file*
     *load-preserves-optimization-settings*
     find-definition-sources
     define-definition-type
     definition-type
     definition-type-name
     *save-source-locations*
     function-source-note
     source-note
     source-note-p
     source-note-filename
     source-note-start-pos
     source-note-end-pos
     source-note-text
     ensure-source-note-text
     *record-pc-mapping*
     find-source-note-at-pc
     caller-functions
     *svn-program*
     watch
     unwatch
     stack-access
     *stack-access-defeat-hook*
     using-linear-scan

     show-documentation
     %set-toplevel
     toplevel-loop
     toplevel-function
     repl-function-name
     toplevel
     *listener-prompt-format*
     cancel
     catch-cancel
     throw-cancel
     *backtrace-on-break*
     *show-restarts-on-break*
     print-call-history
     backtrace-as-list
     dbg-form
     *backtrace-print-level*
     *backtrace-print-length*
     *backtrace-print-string-length*
     *backtrace-show-internal-frames*
     *backtrace-format*
     map-call-frames
     frame-function
     frame-supplied-arguments
     frame-named-variables
     apply-in-frame
     *error-print-level*
     *error-print-length*
     *error-print-string-length*
     *quit-on-eof*
     *quit-interrupt-hook*
     *break-hook*
     *top-error-frame*
     *select-interactive-process-hook*
     interrupt-signal-condition
     macroexpand-all
     compiler-macroexpand
     compiler-macroexpand-1
     compile-user-function
     uncompile-function
     report-compiler-warning
     compiler-warning
     style-warning
     compiler-warning-source-note
     compiler-warning-function-name
     *merge-compiler-warnings*
     abort-break
     *trace-print-level*
     *trace-print-length*
     *trace-print-string-length*
     *trace-bar-frequency*
     trace-function
     *ignore-extra-close-parenthesis*
     advise
     unadvise
     advisedp
     nfunction
     function-name
     setf-function-p
     setf-function-spec-name
     name-of

     assq
     bignump
     bitp
     constant-symbol-p
     proclaimed-special-p
     delq
     fixnump
     quit
     include
     memq
     nremove
					;put
     ratiop
     structure-typep
     structurep
     type-specifier-p
     displaced-array-p
     without-interrupts
     with-interrupts-enabled
     true
     false
     neq
     whitespacep
     *print-structure*
     *print-simple-vector*
     *print-simple-bit-vector*
     *print-string-length*
     *print-abbreviate-quote*
     *signal-printing-errors*
     unignore
     *warn-if-redefine-kernel*
     without-duplicate-definition-warnings
     require-type
     dovector
     debugging-function-name
     *make-package-use-defaults*
     *autoload-lisp-package*
     tyo
     tyi
     untyi
     compiled-lexical-closure		; the type name
     lsh

     ;; Arguments, image name, etc.
     *command-line-argument-list*
     *unprocessed-command-line-arguments*
     *heap-image-name*

					; The MOP
     accessor-method-slot-definition
     add-dependent
     add-direct-method
     add-direct-subclass
     add-method
     class-default-initargs
     class-direct-default-initargs
     class-direct-slots
     class-direct-subclasses
     class-direct-superclasses
     class-finalized-p
     class-precedence-list
     class-prototype
     class-slots
     compute-applicable-methods
     compute-applicable-methods-using-classes
     compute-class-precedence-list
     compute-default-initargs
     compute-discriminating-function
     compute-effective-method
     compute-effective-slot-definition
     compute-slots
     direct-slot-definition-class
     effective-slot-definition-class
     ensure-class
     ensure-class-using-class
     ensure-generic-function-using-class
     eql-specializer
     eql-specializer-object
     extract-lambda-list
     extract-specializer-names
     finalize-inheritance
     find-method-combination
     funcallable-standard-instance-access
     generic-function-argument-precedence-order
     generic-function-declarations
     generic-function-lambda-list
     generic-function-method-class
     generic-function-method-combination
     generic-function-methods
     generic-function-name
     intern-eql-specializer
     make-method-lambda
     map-dependents
     method-function
     method-generic-function
     method-lambda-list
     method-name
     method-specializers
     method-qualifiers
     slot-definition-documentation
     slot-definition-allocation
     slot-definition-initargs
     slot-definition-initform
     slot-definition-initfunction
     slot-definition-name
     slot-definition-type
     slot-definition-readers
     slot-definition-writers
     slot-definition-location
     reader-method-class
     remove-dependent
     remove-direct-method
     remove-direct-subclass
     remove-method
     set-funcallable-instance-function
     slot-boundp-using-class
     slot-makunbound-using-class
     slot-value-using-class
     specializer-direct-generic-functions
     specializer-direct-methods
     standard-instance-access
     update-dependent
     validate-superclass
     writer-method-class
     
     metaobject
     long-method-combination
     short-method-combination
     standard-accessor-method
     standard-reader-method
     standard-writer-method
     specializer

     funcallable-standard-class
     funcallable-standard-object
     forward-referenced-class
     standard-direct-slot-definition
     standard-effective-slot-definition

     standard-slot-definition
     slot-definition
     effective-slot-definition
     direct-slot-definition
     
     clear-specializer-direct-methods-caches
     *check-call-next-method-with-args*
     clear-gf-cache
     clear-all-gf-caches
     clear-clos-caches

     method-exists-p
     method-specializers
     class-own-wrapper
     specializer-direct-methods
     specializer-direct-generic-functions
     copy-instance

     override-one-method-one-arg-dcode
     optimize-generic-function-dispatching

     ;; Not MOP
     no-applicable-method-exists
     string-studlify			;** DO NOT REMOVE, DO NOT DOCUMENT
     nstring-studlify			;** DO NOT REMOVE, DO NOT DOCUMENT

					; User Options
     *compile-definitions*
     *record-source-file*
     *save-doc-strings*
     *fasl-save-doc-strings* 
     *warn-if-redefine*
     *break-on-errors* 
     *save-definitions*
     *fasl-save-definitions* 
     *save-local-symbols*
     *fasl-save-local-symbols*
     *save-arglist-info*
     *always-eval-user-defvars*
     *disassemble-verbose*
     target-fasl-version

					;These 3 need to be set by the user in order for the correspondingly named
					;functions to return something other than "unspecified".
     *short-site-name*
     *long-site-name*
     machine-owner

     init-list-default
     fset

					; Files.
     mac-default-directory
     current-directory
     directory-pathname-p
     full-pathname
     temp-pathname
     create-file
     create-directory
     file-create-date
     set-file-write-date
     set-file-create-date
     copy-file
     lock-file
     unlock-file
     file-locked-p
     file-data-size
     directoryp
     delete-directory
     *trust-paths-from-environment*


     *module-search-path*
     *module-provider-functions*
     *.lisp-pathname*
     *.fasl-pathname*
     *pathname-translations-pathname*
     *default-external-format*
     *default-line-termination*
     pathname-encoding-name
     with-filename-cstrs
     get-foreign-namestring
     native-translated-namestring
     native-to-pathname
     fasl-concatenate
     event-ticks
     set-event-ticks
     event-dispatch
     *ticks-per-second*
     encoding-problem
     decoding-problem
     with-encoding-problems-as-errors
     with-decoding-problems-as-errors

     *application*
     arglist
     arglist-string
     arglist-to-stream
     function-args


     get-string-from-user
     with-terminal-input
     *request-terminal-input-via-break*
     add-auto-flush-stream
     remove-auto-flush-stream
     select-item-from-list


					; Low-level
     %stack-block
     %vstack-block
     %get-byte
     %get-signed-byte
     %get-unsigned-byte
     %get-word
     %get-signed-word
     %get-unsigned-word
     %get-long
     %get-unsigned-long
     %get-signed-long
     %%get-signed-longlong
     %%get-unsigned-longlong
     %get-fixnum
     %get-point
     %get-ptr
     %get-string
     %get-cstring
     %str-from-ptr
     %get-double-float
     %get-single-float
     %inc-ptr
     %incf-ptr
     %setf-macptr
     %null-ptr
     %null-ptr-p
     %ptr-eql
     %ptr-to-int
     %int-to-ptr
     %word-to-int
     %address-of
     ensure-simple-string
     %copy-float
     with-macptrs
     pointerp
     macptrp
     macptr
     rlet
     rletz
     make-record
     pref
     rref
     paref
     dparef
     sparef
     with-cstrs
     with-encoded-cstrs
     with-string-vector
     with-pointer-to-ivector
     get-encoded-string
     +null-ptr+
     free
     define-entry-point
     define-callback
     defcallback
     ff-call
     %ff-call
     %reference-external-entry-point
     foreign-symbol-entry
     foreign-symbol-address
     def-foreign-type

     uvref
     uvectorp
     uvsize

     ;;Streams (should be made more complete sometime)
     input-stream
     output-stream
     stream-eofp

     open-file-streams
     note-open-file-stream
     remove-open-file-stream
     clear-open-file-streams
     stream-line-length
     string-output-stream
     truncating-string-stream
     make-truncating-string-stream
     stream-rubout-handler


					; Tools
     gc
     egc
     egc-enabled-p
     egc-active-p
     configure-egc
     egc-configuration
     gccounts
     gctime
     lisp-heap-gc-threshold
     use-lisp-heap-gc-threshold
     set-lisp-heap-gc-threshold
     gc-retain-pages
     gc-retaining-pages
     gc-verbose
     gc-verbose-p
     weak-gc-method
     *trace-max-indent* 
     *trace-level* 
     static-cons
     free-static-conses
     reserved-static-conses
     get-gc-notification-threshold
     set-gc-notification-threshold
     *pending-gc-notification-hook*
     current-time-in-nanoseconds
     
     population
     make-population
     population-type
     population-contents

     hash-table-weak-p

     compiler-let


     COMPILER-POLICY
     CURRENT-COMPILER-POLICY
     CURRENT-FILE-COMPILER-POLICY
     FIND-MACTYPE
     NEW-COMPILER-POLICY
     SET-CURRENT-COMPILER-POLICY
     SET-CURRENT-FILE-COMPILER-POLICY
     STANDARD-METHOD-COMBINATION
     STREAM-DEVICE
     STREAM-DIRECTION
     *current-process*
     PROCESS
     all-processes
     process-preset
     process-reset
     process-reset-and-enable
     process-enable
     process-abort
     process-kill
     process-interrupt
     process-name
     process-plist
     process-run-function
     make-process
     process-suspend-count
     process-serial-number
     process-initial-form
     process-whostate
     process-priority
     process-total-run-time
     process-creation-time
     clear-process-run-time
     process-resume
     process-suspend
     process-exhausted-p
     let-globally
     process-wait
     process-wait-with-timeout
     process-allow-schedule
     process-kill-issued
     process-termination-semaphore
     process-allocation-quantum
     default-allocation-quantum
     current-process-allocation-quantum
     join-process

     *HOST-PAGE-SIZE*
     
     make-lock
     lock-name
     with-lock-grabbed
     grab-lock
     release-lock
     try-lock
     lock
     read-write-lock
     lock-not-owner

     lock-acquisition-status
     clear-lock-acquisition-status
     lock-acquisition
     make-lock-acquisition

     semaphore-notification-status
     clear-semaphore-notification-status
     semaphore-notification
     make-semaphore-notification
     
     make-read-write-lock
     with-read-lock
     with-write-lock
     symbol-value-in-process

     make-semaphore
     wait-on-semaphore
     timed-wait-on-semaphore
     signal-semaphore
     semaphore

     process-input-wait
     process-output-wait
     wait-for-signal
                                        ; termination
     terminate-when-unreachable
     terminate
     drain-termination-queue
     cancel-terminate-when-unreachable
     termination-function
     *enable-automatic-termination*

     get-fpu-mode
     set-fpu-mode

					; There's more. Like...

     *listener-indent*
     *error-print-circle*
     *break-loop-when-uninterruptable*

     application-error
     application-name
     application-init-file

     cwd

     ;; Old CLtL2 stuff:

     *applyhook*
     *evalhook*
     applyhook
     augment-environment
     declaration-information
     define-declaration
     define-setf-method
     evalhook
     enclose
     function-information
     generic-flet
     generic-labels
     get-setf-method
     get-setf-method-multiple-value
     parse-macro
     variable-information
     with-added-methods

     ;; Gray Streams
     fundamental-stream
     fundamental-input-stream
     fundamental-output-stream
     fundamental-character-stream
     fundamental-character-input-stream
     fundamental-character-output-stream
     fundamental-binary-stream
     fundamental-binary-input-stream
     fundamental-binary-output-stream

     stream-read-char
     stream-unread-char
     stream-read-char-no-hang
     stream-peek-char
     stream-listen
     stream-read-line
     stream-clear-input

     stream-write-char
     stream-line-column
     stream-start-line-p
     stream-write-string
     stream-terpri
     stream-fresh-line
     stream-force-output
     stream-clear-output
     stream-advance-to-column

     stream-read-byte
     stream-write-byte

     stream-read-ivector
     stream-write-ivector

     stream-read-list
     stream-write-list
     stream-read-vector
     stream-write-vector

     stream-input-timeout
     stream-output-timeout
     with-input-timeout
     with-output-timeout
     stream-deadline

     input-timeout
     output-timeout
     communication-deadline-expired

     make-heap-ivector
     dispose-heap-ivector
     ;;
     external
     external-call
     open-shared-library
     close-shared-library
     shlib
     external-entry-point
     use-interface-dir
     unuse-interface-dir
     create-interfaces
     ;;
     run-program
     external-process
     signal-external-process
     external-process-id
     external-process-input-stream
     external-process-output-stream
     external-process-error-stream
     external-process-status
     ;;
     *altivec-available*
     altivec-available-p
     *altivec-lapmacros-maintain-vrsave-p*
     ;;
     *alternate-line-terminator*
     ;;
     set-user-environment
     set-development-environment
     *resident-editor-hook*
     cpu-count
     *report-time-function*
     ;;
     compile-ccl
     xcompile-ccl
     xload-level-0
     rebuild-ccl
     update-ccl
     test-ccl
     defglobal

     getenv
     setenv
     unsetenv

     external-format
     make-external-format
     external-format-character-encoding
     external-format-line-termination
     character-encoding
     define-character-encoding
     list-character-encodings
     describe-character-encoding
     describe-character-encodings
     get-character-encoding
     lookup-character-encoding
     string-size-in-octets
     encode-string-to-octets
     count-characters-in-octet-vector
     decode-string-from-octets
     *terminal-character-encoding-name*
     *default-file-character-encoding*
     *default-socket-character-encoding*
     define-character-encoding-alias
     remove-character-encoding-alias
     ;; Mapped files.
     map-file-to-ivector
     map-file-to-octet-vector
     unmap-ivector
     unmap-octet-vector
     ;; Miscellany
     heap-utilization
     collect-heap-utilization
     parse-unsigned-integer
     parse-signed-integer
     pui-stream
     psi-stream
     with-output-to-vector
     with-input-from-vector
     make-vector-output-stream
     make-vector-input-stream
     unsigned-integer-to-binary
     signed-integer-to-binary
     vector-input-stream
     vector-output-stream
     get-output-stream-vector  
     *vector-output-stream-default-initial-allocation*   
     external-process-creation-failure
     object-direct-size
     add-feature
     remove-feature
     choose-file-dialog
     choose-new-file-dialog
     choose-directory-dialog
     ;; Disabling heap allocation (to detect unexpected consing.)
     allow-heap-allocaton
     heap-allocation-allowed-p
     allocation-disabled

     ) "CCL"
   )
  )

;;; Define a package for MOP extensions.
(defpackage "OPENMCL-MOP"
  (:use)
  (:import-from
   "CCL"
   "ACCESSOR-METHOD-SLOT-DEFINITION"
   "ADD-DEPENDENT"
   "ADD-DIRECT-METHOD"
   "ADD-DIRECT-SUBCLASS"
   "ADD-METHOD"
   "CLASS-DEFAULT-INITARGS"
   "CLASS-DIRECT-DEFAULT-INITARGS"
   "CLASS-DIRECT-SLOTS"
   "CLASS-DIRECT-SUBCLASSES"
   "CLASS-DIRECT-SUPERCLASSES"
   "CLASS-FINALIZED-P"
   "CLASS-PRECEDENCE-LIST"
   "CLASS-PROTOTYPE"
   "CLASS-SLOTS"
   "COMPUTE-APPLICABLE-METHODS"
   "COMPUTE-APPLICABLE-METHODS-USING-CLASSES"
   "COMPUTE-CLASS-PRECEDENCE-LIST"
   "COMPUTE-DEFAULT-INITARGS"
   "COMPUTE-DISCRIMINATING-FUNCTION"
   "COMPUTE-EFFECTIVE-METHOD"
   "COMPUTE-EFFECTIVE-SLOT-DEFINITION"
   "COMPUTE-SLOTS"
   "DIRECT-SLOT-DEFINITION-CLASS"
   "EFFECTIVE-SLOT-DEFINITION-CLASS"
   "ENSURE-CLASS"
   "ENSURE-CLASS-USING-CLASS"
   "ENSURE-GENERIC-FUNCTION-USING-CLASS"
   "EQL-SPECIALIZER"
   "EQL-SPECIALIZER-OBJECT"
   "EXTRACT-LAMBDA-LIST"
   "EXTRACT-SPECIALIZER-NAMES"
   "FINALIZE-INHERITANCE"
   "FIND-METHOD-COMBINATION"
   "FUNCALLABLE-STANDARD-INSTANCE-ACCESS"
   "GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER"
   "GENERIC-FUNCTION-DECLARATIONS"
   "GENERIC-FUNCTION-LAMBDA-LIST"
   "GENERIC-FUNCTION-METHOD-CLASS"
   "GENERIC-FUNCTION-METHOD-COMBINATION"
   "GENERIC-FUNCTION-METHODS"
   "GENERIC-FUNCTION-NAME"
   "INTERN-EQL-SPECIALIZER"
   "MAKE-METHOD-LAMBDA"
   "MAP-DEPENDENTS"
   "METHOD-FUNCTION"
   "METHOD-GENERIC-FUNCTION"
   "METHOD-LAMBDA-LIST"
   "METHOD-NAME"
   "METHOD-SPECIALIZERS"
   "METHOD-QUALIFIERS"
   "SLOT-DEFINITION-DOCUMENTATION"
   "SLOT-DEFINITION-ALLOCATION"
   "SLOT-DEFINITION-INITARGS"
   "SLOT-DEFINITION-INITFORM"
   "SLOT-DEFINITION-INITFUNCTION"
   "SLOT-DEFINITION-NAME"
   "SLOT-DEFINITION-TYPE"
   "SLOT-DEFINITION-READERS"
   "SLOT-DEFINITION-WRITERS"
   "SLOT-DEFINITION-LOCATION"
   "READER-METHOD-CLASS"
   "REMOVE-DEPENDENT"
   "REMOVE-DIRECT-METHOD"
   "REMOVE-DIRECT-SUBCLASS"
   "REMOVE-METHOD"
   "SET-FUNCALLABLE-INSTANCE-FUNCTION"
   "SLOT-BOUNDP-USING-CLASS"
   "SLOT-MAKUNBOUND-USING-CLASS"
   "SLOT-VALUE-USING-CLASS"
   "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS"
   "SPECIALIZER-DIRECT-METHODS"
   "STANDARD-DIRECT-SLOT-DEFINITION"
   "STANDARD-EFFECTIVE-SLOT-DEFINITION"
   "STANDARD-INSTANCE-ACCESS"
   "UPDATE-DEPENDENT"
   "VALIDATE-SUPERCLASS"
   "WRITER-METHOD-CLASS"
     
   "METAOBJECT"
   "LONG-METHOD-COMBINATION"
   "SHORT-METHOD-COMBINATION"
   "STANDARD-ACCESSOR-METHOD"
   "STANDARD-READER-METHOD"
   "STANDARD-WRITER-METHOD"
   "SPECIALIZER"

   "FUNCALLABLE-STANDARD-CLASS"
   "FUNCALLABLE-STANDARD-OBJECT"
   "FORWARD-REFERENCED-CLASS"

   "CLEAR-SPECIALIZER-DIRECT-METHODS-CACHES"
   "*CHECK-CALL-NEXT-METHOD-WITH-ARGS*"
   "CLEAR-GF-CACHE"
   "CLEAR-ALL-GF-CACHES"
   "CLEAR-CLOS-CACHES"

   "METHOD-EXISTS-P"
   "METHOD-SPECIALIZERS"
   "CLASS-OWN-WRAPPER"
   "SPECIALIZER-DIRECT-METHODS"
   "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS"
   "COPY-INSTANCE"
   "STANDARD-SLOT-DEFINITION"
   "SLOT-DEFINITION"
   "EFFECTIVE-SLOT-DEFINITION"
   "DIRECT-SLOT-DEFINITION"
   )
  (:export
   "ACCESSOR-METHOD-SLOT-DEFINITION"
   "ADD-DEPENDENT"
   "ADD-DIRECT-METHOD"
   "ADD-DIRECT-SUBCLASS"
   "ADD-METHOD"
   "CLASS-DEFAULT-INITARGS"
   "CLASS-DIRECT-DEFAULT-INITARGS"
   "CLASS-DIRECT-SLOTS"
   "CLASS-DIRECT-SUBCLASSES"
   "CLASS-DIRECT-SUPERCLASSES"
   "CLASS-FINALIZED-P"
   "CLASS-PRECEDENCE-LIST"
   "CLASS-PROTOTYPE"
   "CLASS-SLOTS"
   "COMPUTE-APPLICABLE-METHODS"
   "COMPUTE-APPLICABLE-METHODS-USING-CLASSES"
   "COMPUTE-CLASS-PRECEDENCE-LIST"
   "COMPUTE-DEFAULT-INITARGS"
   "COMPUTE-DISCRIMINATING-FUNCTION"
   "COMPUTE-EFFECTIVE-METHOD"
   "COMPUTE-EFFECTIVE-SLOT-DEFINITION"
   "COMPUTE-SLOTS"
   "DIRECT-SLOT-DEFINITION-CLASS"
   "EFFECTIVE-SLOT-DEFINITION-CLASS"
   "ENSURE-CLASS"
   "ENSURE-CLASS-USING-CLASS"
   "ENSURE-GENERIC-FUNCTION-USING-CLASS"
   "EQL-SPECIALIZER"
   "EQL-SPECIALIZER-OBJECT"
   "EXTRACT-LAMBDA-LIST"
   "EXTRACT-SPECIALIZER-NAMES"
   "FINALIZE-INHERITANCE"
   "FIND-METHOD-COMBINATION"
   "FUNCALLABLE-STANDARD-INSTANCE-ACCESS"
   "GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER"
   "GENERIC-FUNCTION-DECLARATIONS"
   "GENERIC-FUNCTION-LAMBDA-LIST"
   "GENERIC-FUNCTION-METHOD-CLASS"
   "GENERIC-FUNCTION-METHOD-COMBINATION"
   "GENERIC-FUNCTION-METHODS"
   "GENERIC-FUNCTION-NAME"
   "INTERN-EQL-SPECIALIZER"
   "MAKE-METHOD-LAMBDA"
   "MAP-DEPENDENTS"
   "METHOD-FUNCTION"
   "METHOD-GENERIC-FUNCTION"
   "METHOD-LAMBDA-LIST"
   "METHOD-NAME"
   "METHOD-SPECIALIZERS"
   "METHOD-QUALIFIERS"
   "SLOT-DEFINITION-DOCUMENTATION"
   "SLOT-DEFINITION-ALLOCATION"
   "SLOT-DEFINITION-INITARGS"
   "SLOT-DEFINITION-INITFORM"
   "SLOT-DEFINITION-INITFUNCTION"
   "SLOT-DEFINITION-NAME"
   "SLOT-DEFINITION-TYPE"
   "SLOT-DEFINITION-READERS"
   "SLOT-DEFINITION-WRITERS"
   "SLOT-DEFINITION-LOCATION"
   "READER-METHOD-CLASS"
   "REMOVE-DEPENDENT"
   "REMOVE-DIRECT-METHOD"
   "REMOVE-DIRECT-SUBCLASS"
   "REMOVE-METHOD"
   "SET-FUNCALLABLE-INSTANCE-FUNCTION"
   "SLOT-BOUNDP-USING-CLASS"
   "SLOT-MAKUNBOUND-USING-CLASS"
   "SLOT-VALUE-USING-CLASS"
   "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS"
   "SPECIALIZER-DIRECT-METHODS"
   "STANDARD-DIRECT-SLOT-DEFINITION"
   "STANDARD-EFFECTIVE-SLOT-DEFINITION"
   "STANDARD-INSTANCE-ACCESS"
   "UPDATE-DEPENDENT"
   "VALIDATE-SUPERCLASS"
   "WRITER-METHOD-CLASS"
     
   "METAOBJECT"
   "LONG-METHOD-COMBINATION"
   "SHORT-METHOD-COMBINATION"
   "STANDARD-ACCESSOR-METHOD"
   "STANDARD-READER-METHOD"
   "STANDARD-WRITER-METHOD"
   "SPECIALIZER"

   "FUNCALLABLE-STANDARD-CLASS"
   "FORWARD-REFERENCED-CLASS"


   "CLEAR-SPECIALIZER-DIRECT-METHODS-CACHES"
   "*CHECK-CALL-NEXT-METHOD-WITH-ARGS*"
   "CLEAR-GF-CACHE"
   "CLEAR-ALL-GF-CACHES"
   "CLEAR-CLOS-CACHES"

   "METHOD-EXISTS-P"
   "METHOD-SPECIALIZERS"
   "CLASS-OWN-WRAPPER"
   "SPECIALIZER-DIRECT-METHODS"
   "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS"
   "COPY-INSTANCE"
   "STANDARD-SLOT-DEFINITION"
   "SLOT-DEFINITION"
   "EFFECTIVE-SLOT-DEFINITION"
   "DIRECT-SLOT-DEFINITION"
   ))

(unless (eq %lisp-system-fixups% T)
  (while %lisp-system-fixups%
    (let* ((fn.source (car %lisp-system-fixups%))
           (*loading-toplevel-location* (and (source-note-p (cdr fn.source)) (cdr fn.source)))
           (*loading-file-source-file* (source-note-filename (cdr fn.source)))
           )
      (funcall (car fn.source)))
    (setq %lisp-system-fixups% (cdr %lisp-system-fixups%)))
  (setq %lisp-system-fixups% T))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/ccl-export-syms.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/compile-ccl.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(require 'systems)

(defparameter *sysdef-modules*
  '(systems compile-ccl))

(defparameter *level-1-modules*
  '(level-1
    l1-cl-package
    l1-boot-1 l1-boot-2 l1-boot-3
    l1-utils l1-init l1-symhash l1-numbers l1-aprims 
    l1-sort l1-dcode l1-clos-boot l1-clos
    l1-unicode l1-streams l1-files l1-io 
    l1-format l1-readloop l1-reader
    l1-sysio l1-pathnames l1-events
    l1-boot-lds  l1-readloop-lds 
    l1-lisp-threads  l1-application l1-processes
    l1-typesys sysutils l1-error-system
    l1-error-signal version l1-callbacks
    l1-sockets linux-files
    ))

(defparameter *compiler-modules*
  '(nx optimizers dll-node arch vreg vinsn 
    reg subprims  backend nx2 acode-rewrite))


(defparameter *ppc-compiler-modules*
  '(ppc32-arch
    ppc64-arch
    ppc-arch
    ppcenv
    ppc-asm
    risc-lap
    ppc-lap
    ppc-backend
))

(defparameter *x86-compiler-modules*
  '(x8632-arch
    x8664-arch
    x86-arch
    x8632env
    x8664env
    x86-asm
    x86-lap
    x86-backend
))

(defparameter *arm-compiler-modules*
  '(arm-arch
    armenv
    arm-asm
    arm-lap
))

(defparameter *ppc32-compiler-backend-modules*
  '(ppc32-backend ppc32-vinsns))

(defparameter *ppc64-compiler-backend-modules*
  '(ppc64-backend ppc64-vinsns))


(defparameter *ppc-compiler-backend-modules*
  '(ppc2))


(defparameter *x8632-compiler-backend-modules*
  '(x8632-backend x8632-vinsns))

(defparameter *x8664-compiler-backend-modules*
  '(x8664-backend x8664-vinsns))

(defparameter *x86-compiler-backend-modules*
  '(x862))

(defparameter *arm-compiler-backend-modules*
  '(arm-backend arm-vinsns arm2))




(defparameter *ppc-xload-modules* '(xppcfasload xfasload heap-image ))
(defparameter *x8632-xload-modules* '(xx8632fasload xfasload heap-image ))
(defparameter *x8664-xload-modules* '(xx8664fasload xfasload heap-image ))
(defparameter *arm-xload-modules* '(xarmfasload xfasload heap-image ))


;;; Not too OS-specific.
(defparameter *ppc-xdev-modules* '(ppc-lapmacros ))
(defparameter *x86-xdev-modules* '(x86-lapmacros ))
(defparameter *arm-xdev-modules* '(arm-lapmacros ))

(defmacro with-global-optimization-settings ((&key speed
                                                   space
                                                   safety
                                                   debug
                                                   compilation-speed)
                                             &body body
                                             &environment env)
  (flet ((check-quantity (val default)
           (if val
             (require-type val '(mod 4))
             default)))
    (multiple-value-bind (body decls) (parse-body body env)
      `(let* ((*nx-speed* ,(check-quantity speed '*nx-speed*))
              (*nx-space* ,(check-quantity space '*nx-space*))
              (*nx-safety* ,(check-quantity safety '*nx-safety*))
              (*nx-debug* ,(check-quantity debug '*nx-debug*))
              (*nx-cspeed* ,(check-quantity compilation-speed '*nx-cspeed*)))
        ,@decls
        ,@body))))
  
(defun target-xdev-modules (&optional (target
				       (backend-target-arch-name
					*host-backend*)))
  (case target
    ((:ppc32 :ppc64) *ppc-xdev-modules*)
    ((:x8632 :x8664) *x86-xdev-modules*)
    (:arm *arm-xdev-modules*)))

(defun target-xload-modules (&optional (target
					(backend-target-arch-name *host-backend*)))
  (case target
    ((:ppc32 :ppc64) *ppc-xload-modules*)
    (:x8632 *x8632-xload-modules*)
    (:x8664 *x8664-xload-modules*)
    (:arm *arm-xload-modules*)))






(defparameter *env-modules*
  '(lispequ hash backquote   level-2 macros
    defstruct-macros lists chars setf setf-runtime
    defstruct defstruct-lds 
    foreign-types
    db-io
    nfcomp
    hashenv))

(defun target-env-modules (&optional (target
				      (backend-name *host-backend*)))
  (append *env-modules*
          (list
           (ecase target
             (:linuxppc32 'ffi-linuxppc32)
             (:darwinppc32 'ffi-darwinppc32)
             (:darwinppc64 'ffi-darwinppc64)
             (:linuxppc64 'ffi-linuxppc64)
	     (:darwinx8632 'ffi-darwinx8632)
             (:linuxx8664 'ffi-linuxx8664)
             (:darwinx8664 'ffi-darwinx8664)
             (:freebsdx8664 'ffi-freebsdx8664)
             (:solarisx8664 'ffi-solarisx8664)
             (:win64 'ffi-win64)
             (:linuxx8632 'ffi-linuxx8632)
             (:win32 'ffi-win32)
             (:solarisx8632 'ffi-solarisx8632)
             (:freebsdx8632 'ffi-freebsdx8632)
             (:linuxarm 'ffi-linuxarm)
             (:androidarm 'ffi-androidarm)
             (:darwinarm 'ffi-darwinarm)))))


(defun target-compiler-modules (&optional (target
					   (backend-target-arch-name
					    *host-backend*)))
  (case target
    (:ppc32 (append *ppc-compiler-modules*
                    *ppc32-compiler-backend-modules*
                    *ppc-compiler-backend-modules*))
    (:ppc64 (append *ppc-compiler-modules*
                    *ppc64-compiler-backend-modules*
                    *ppc-compiler-backend-modules*))
    (:x8632 (append *x86-compiler-modules*
                    *x8632-compiler-backend-modules*
                    *x86-compiler-backend-modules*))
    (:x8664 (append *x86-compiler-modules*
                    *x8664-compiler-backend-modules*
                    *x86-compiler-backend-modules*))
    (:arm (append *arm-compiler-modules*
                  *arm-compiler-backend-modules*))))

(defparameter *other-lib-modules*
  '(streams pathnames backtrace
    apropos
    numbers 
    dumplisp
    source-files
    swink))

(defun target-other-lib-modules (&optional (target
					    (backend-target-arch-name
					     *host-backend*)))
  (append *other-lib-modules*
	  (case target
	    ((:ppc32 :ppc64) '(ppc-backtrace ppc-disassemble))
            ((:x8632 :x8664) '(x86-backtrace x86-disassemble x86-watch))
            (:arm '(arm-backtrace arm-disassemble)))))
	  

(defun target-lib-modules (&optional (backend-name
                                      (backend-name *host-backend*)))
  (let* ((backend (or (find-backend backend-name) *host-backend*))
         (arch-name (backend-target-arch-name backend)))
    (append (target-env-modules backend-name) (target-other-lib-modules arch-name))))


(defparameter *code-modules*
  '(encapsulate
    read misc  arrays-fry
    sequences sort 
    method-combination
    case-error pprint 
    format time 
;        eval step
    backtrace-lds  ccl-export-syms prepare-mcl-environment))



(defparameter *aux-modules*
  '(number-macros number-case-macro
    loop
    runtime
    mcl-compat
    arglist
    edit-callers
    describe
    cover
    leaks
    core-files
    dominance
    swank-loader
    remote-lisp
    asdf
    sockets
    defsystem
    jp-encode
    cn-encode
    ))







(defun target-level-1-modules (&optional (target (backend-name *host-backend*)))
  (append *level-1-modules*
	  (case target
	    ((:linuxppc32 :darwinppc32 :linuxppc64 :darwinppc64)
	     '(ppc-error-signal ppc-trap-support
	       ppc-threads-utils ppc-callback-support))            
            ((:linuxx8664 :freebsdx8664 :darwinx8664 :solarisx8664
                          :darwinx8632 :win64  :linuxx8632 :win32 :solarisx8632
                          :freebsdx8632)
             '(x86-error-signal x86-trap-support
               x86-threads-utils x86-callback-support))
            ((:linuxarm :darwinarm :androidarm)
             '(arm-error-signal arm-trap-support
               arm-threads-utils arm-callback-support)))))


;;; Needed to cross-dump an image


(unless (fboundp 'xload-level-0)
  (%fhave 'xload-level-0
          #'(lambda (&rest rest)
	      (in-development-mode
	       (require-modules (target-xload-modules)))
              (apply 'xload-level-0 rest))))

(defun find-module (module &optional (target (backend-name *host-backend*))  &aux data fasl sources)
  (if (setq data (assoc module *ccl-system*))
    (let* ((backend (or (find-backend target) *host-backend*)))
      (setq fasl (cadr data) sources (caddr data))      
      (setq fasl (merge-pathnames (backend-target-fasl-pathname
				   backend) fasl))
      (values fasl (if (listp sources) sources (list sources))))
    (error "Module ~S not defined" module)))

;compile if needed.
(defun target-compile-modules (modules target force-compile)
  (if (not (listp modules)) (setq modules (list modules)))
  (in-development-mode
   (dolist (module modules t)
     (multiple-value-bind (fasl sources) (find-module module target)
      (if (needs-compile-p fasl sources force-compile)
        (progn
          (require'nfcomp)
          (compile-file (car sources)
			:output-file fasl
			:verbose t
			:target target)))))))


(defun needs-compile-p (fasl sources force-compile)
  (if fasl
    (if (eq force-compile t)
      t
      (if (not (probe-file fasl))
        t
        (let ((fasldate (file-write-date fasl)))
          (if (if (integerp force-compile) (> force-compile fasldate))
            t
            (dolist (source sources nil)
              (if (> (file-write-date source) fasldate)
                (return t)))))))))



;;;compile if needed, load if recompiled.

(defun update-modules (modules &optional force-compile)
  (if (not (listp modules)) (setq modules (list modules)))
  (in-development-mode
   (dolist (module modules t)
     (multiple-value-bind (fasl sources) (find-module module)
       (if (needs-compile-p fasl sources force-compile)
	 (progn
	   (require'nfcomp)
	   (let* ((*warn-if-redefine* nil))
	     (compile-file (car sources) :output-file fasl :verbose t :load t))
	   (provide module)))))))

(defun compile-modules (modules &optional force-compile)
  (target-compile-modules modules (backend-name *host-backend*) force-compile)
)



(defun compile-ccl (&optional force-compile)
  (with-compilation-unit ()
    (update-modules *sysdef-modules* force-compile)
    (update-modules 'nxenv force-compile)
    (update-modules *compiler-modules* force-compile)
    (update-modules (target-compiler-modules) force-compile)
    (update-modules (target-xdev-modules) force-compile)
    (update-modules (target-xload-modules)  force-compile)
    (let* ((env-modules (target-env-modules))
           (other-lib (target-other-lib-modules)))
      (require-modules env-modules)
      (update-modules env-modules force-compile)
      (compile-modules (target-level-1-modules)  force-compile)
      (update-modules other-lib force-compile)
      (require-modules other-lib)
      (require-update-modules *code-modules* force-compile))
    (compile-modules *aux-modules* force-compile)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun require-env (&optional force-load)
  (require-modules  (target-env-modules)
                   force-load))

(defun compile-level-1 (&optional force-compile)
  (require-env)
  (compile-modules (target-level-1-modules (backend-name *host-backend*))
                   force-compile))





(defun compile-lib (&optional force-compile)
  (compile-modules (target-lib-modules)
                   force-compile))

(defun compile-code (&optional force-compile)
  (compile-modules *code-modules* force-compile))


;Compile but don't load

(defun xcompile-ccl (&optional force)
  (with-compilation-unit ()
    (compile-modules *sysdef-modules* force)
    (compile-modules 'nxenv force)
    (compile-modules *compiler-modules* force)
    (compile-modules (target-compiler-modules) force)
    (compile-modules (target-xdev-modules) force)
    (compile-modules (target-xload-modules)  force)
    (compile-modules (target-env-modules) force)
    (compile-modules (target-level-1-modules) force)
    (compile-modules (target-other-lib-modules) force)
    (compile-modules *code-modules* force)
    (compile-modules *aux-modules* force)))

(defun require-update-modules (modules &optional force-compile)
  (if (not (listp modules)) (setq modules (list modules)))
  (in-development-mode
    (dolist (module modules)
    (require-modules module)
    (update-modules module force-compile))))


(defun target-xcompile-ccl (target &optional force)
  (let* ((*target-backend* *host-backend*))
    (require-update-modules *sysdef-modules* force)) ;in the host
  (let* ((backend (or (find-backend target) *target-backend*))
	 (arch (backend-target-arch-name backend)))
    (target-compile-modules 'nxenv target force)
    (target-compile-modules *compiler-modules* target force)
    (target-compile-modules (target-compiler-modules arch) target force)
    (target-compile-modules (target-level-1-modules target) target force)
    (target-compile-modules (target-lib-modules target) target force)
    (target-compile-modules *sysdef-modules* target force)
    (target-compile-modules *aux-modules* target force)
    (target-compile-modules *code-modules* target force)
    (target-compile-modules (target-xdev-modules arch) target force)))

(defun cross-compile-ccl (target &optional force)
  (with-cross-compilation-target (target)
    (let* ((*target-backend* (find-backend target)))
      (target-xcompile-ccl target force))))


(defun require-module (module force-load)
  (multiple-value-bind (fasl source) (find-module module)
      (setq source (car source))
      (if (if fasl (probe-file fasl))
        (if force-load
          (progn
            (load fasl)
            (provide module))
          (require module fasl))
        (if (probe-file source)
          (progn
            (if fasl (format t "~&Can't find ~S so requiring ~S instead"
                             fasl source))
            (if force-load
              (progn
                (load source)
                (provide module))
              (require module source)))
          (error "Can't find ~S or ~S" fasl source)))))

(defun require-modules (modules &optional force-load)
  (if (not (listp modules)) (setq modules (list modules)))
  (let ((*package* (find-package :ccl)))
    (dolist (m modules t)
      (require-module m force-load))))


(defun target-xcompile-level-1 (target &optional force)
  (target-compile-modules (target-level-1-modules target) target force))

(defun standard-boot-image-name (&optional (target (backend-name *host-backend*)))
  (ecase target
    (:darwinppc32 "ppc-boot.image")
    (:linuxppc32 "ppc-boot")
    (:darwinppc64 "ppc-boot64.image")
    (:linuxppc64 "ppc-boot64")
    (:darwinx8632 "x86-boot32.image")
    (:linuxx8664 "x86-boot64")
    (:freebsdx8664 "fx86-boot64")
    (:darwinx8664 "x86-boot64.image")
    (:solarisx8664 "sx86-boot64")
    (:win64 "wx86-boot64.image")
    (:linuxx8632 "x86-boot32")
    (:win32 "wx86-boot32.image")
    (:solarisx8632 "sx86-boot32")
    (:freebsdx8632 "fx86-boot32")
    (:linuxarm "arm-boot")
    (:androidarm "aarm-boot")))

(defun standard-kernel-name (&optional (target (backend-name *host-backend*)))
  (ecase target
    (:darwinppc32 "dppccl")
    (:linuxppc32 "ppccl")
    (:darwinppc64 "dppccl64")
    (:darwinx8632 "dx86cl")
    (:linuxppc64 "ppccl64")
    (:linuxx8664 "lx86cl64")
    (:freebsdx8664 "fx86cl64")
    (:darwinx8664 "dx86cl64")
    (:solarisx8664 "sx86cl64")
    (:win64 "wx86cl64.exe")
    (:linuxx8632 "lx86cl")
    (:win32 "wx86cl.exe")
    (:solarisx8632 "sx86cl")
    (:freebsdx8632 "fx86cl")
    (:linuxarm "armcl")
    (:darwinarm "darmcl")
    (:androidarm "aarmcl")))

(defun standard-image-name (&optional (target (backend-name *host-backend*)))
  (concatenate 'string (pathname-name (standard-kernel-name target)) ".image"))

(defun kernel-build-directory (&optional (target (backend-name *host-backend*)))
  (ecase target
    (:darwinppc32 "darwinppc")
    (:linuxppc32 "linuxppc")
    (:darwinppc64 "darwinppc64")
    (:linuxppc64 "linuxppc64")
    (:darwinx8632 "darwinx8632")
    (:linuxx8664 "linuxx8664")
    (:freebsdx8664 "freebsdx8664")
    (:darwinx8664 "darwinx8664")
    (:solarisx8664 "solarisx64")
    (:win64 "win64")
    (:linuxx8632 "linuxx8632")
    (:win32 "win32")
    (:solarisx8632 "solarisx86")
    (:freebsdx8632 "freebsdx8632")
    (:linuxarm "linuxarm")
    (:darwinarm "darwinarm")
    (:androidarm "androidarm")))

;;; If we distribute (e.g.) 32- and 64-bit versions for the same
;;; machine and OS in the same svn directory, return the name of the
;;; peer backend, or NIL. For example., the peer of :linuxppc64 is
;;; :linuxppc32.  Note that this may change over time.
;;; Return NIL if the concept doesn't apply.
(defun peer-platform (&optional (target (backend-name *host-backend*)))
  (let* ((pairs '((:darwinppc32 . :darwinppc64)
                  (:linuxppc32 . :linuxppc64)
                  (:darwinx8632 . :darwinx8664)
                  (:linuxx8632 . :linuxx8664)
                  (:win32 . :win64)
                  (:solarisx8632 . :solarisx8664)
                  (:freebsdx8632 . :freebsdx8664))))
    (or (cdr (assoc target pairs))
        (car (rassoc target pairs)))))

(defun make-program (&optional (target (backend-name *host-backend*)))
  ;; The Solaris "make" program is too clever to understand -C, so
  ;; use GNU make (installed as "gmake").
  (case target
    ((:solarisx8664 :solarisx8632) "gmake")
    (t "make")))


(defun describe-external-process-failure (proc reminder)
  "If it appears that the external-process PROC failed in some way,
try to return a string that describes that failure.  If it seems
to have succeeded or if we can't tell why it failed, return NIL.
This is mostly intended to describe process-creation/fork/exec failures,
not runtime errors reported by a successfully created process."
  (multiple-value-bind (status exit-code)
      (external-process-status proc)
    (let* ((procname (car (external-process-args proc)))
           (string
            (case status
              (:error
               (%strerror exit-code))
              #-windows-target
              (:exited
               (when(= exit-code #-android-target #$EX_OSERR #+android-target 71)
                 "generic OS error in fork/exec")))))
      (when string
        (format nil "Error executing ~a: ~a~&~a" procname string reminder)))))

(defparameter *known-optional-features* '(:count-gf-calls :monitor-futex-wait :unique-dcode :qres-ccl :eq-hash-monitor))
(defvar *build-time-optional-features* nil)
(defvar *ccl-save-source-locations* :no-text)

(defun rebuild-ccl (&key update full clean kernel force (reload t) exit
                         reload-arguments verbose optional-features
                         (save-source-locations *ccl-save-source-locations*)
                         (allow-constant-redefinition nil allow-constant-redefinition-p))
  (let* ((*build-time-optional-features* (intersection *known-optional-features* optional-features))
         (*features* (append *build-time-optional-features* *features*))
	 (*save-source-locations* save-source-locations))
    (when *build-time-optional-features*
      (setq full t))
    (when full
      (setq clean t kernel t reload t))
    (when update
      (multiple-value-bind (changed conflicts new-binaries)
	  (update-ccl :verbose (not (eq update :quiet)))
	(declare (ignore changed conflicts))
	(when new-binaries
	  (format t "~&There are new bootstrapping binaries.  Please restart
the lisp and run REBUILD-CCL again.")
	  (return-from rebuild-ccl nil))))
    (when (or clean force)
      ;; for better bug reports...
      (format t "~&Rebuilding ~a using ~a"
              (lisp-implementation-type)
              (lisp-implementation-version))
      (unless allow-constant-redefinition-p
        (when (or force clean update)
          (setq allow-constant-redefinition t))))
    (let* ((cd (current-directory))
           (*cerror-on-constant-redefinition* (not allow-constant-redefinition ))
	   (*warn-if-redefine-kernel* nil))
      (unwind-protect
           (progn
             (setf (current-directory) "ccl:")
             (when clean
               (dolist (f (directory
                           (merge-pathnames
                            (make-pathname :name :wild
                                           :type (pathname-type *.fasl-pathname*))
                            "ccl:**;")))
                 (delete-file f)))
             (with-global-optimization-settings ()
               (compile-ccl (not (null force)))
               (if force (xload-level-0 :force) (xload-level-0)))
             (when kernel
               (when (or clean force)
                 ;; Do a "make clean".
                 (run-program "make"
                              (list "-C"
                                    (format nil "lisp-kernel/~a"
                                            (kernel-build-directory))
                                    "clean")))
               (format t "~&;Building lisp-kernel ...")
               (with-output-to-string (s)
                 (let* ((proc (run-program (make-program)
                                           (list "-C" 
                                                 (format nil "lisp-kernel/~a"
                                                         (kernel-build-directory))
                                                 "-j"
                                                            
                                                 (format nil "~d" (1+ (cpu-count))))
                                           :output s
                                           :error :output)))
                   (multiple-value-bind (status exit-code)
                       (external-process-status proc)
                     (if (and (eq :exited status) (zerop exit-code))
                       (progn
                         (format t "~&;Kernel built successfully.")
                         (when verbose
                           (format t "~&;kernel build output:~%~a"
                                   (get-output-stream-string s)))
                         (sleep 1))
                       (error "Error(s) during kernel compilation.~%~a"
                              (or
                               (describe-external-process-failure
                                proc
                                "Developer tools may not be installed correctly.")
                               (get-output-stream-string s))))))))
             (when reload
               (let* ((old-write-date
                       (or (ignore-errors (file-write-date (standard-image-name)))
                           0)))
                 (with-input-from-string (cmd (format nil
                                                "(save-application ~s)"
                                                (standard-image-name)))
                   (with-output-to-string (output)
                     (multiple-value-bind (status exit-code)
                         (external-process-status
                          (run-program
                           (format nil "./~a" (standard-kernel-name))
                           (list* "--image-name" (standard-boot-image-name)
                                  "--no-init"
                                  "--batch"
                                  reload-arguments)
                           :input cmd
                           :output output
                           :error output))
                       (if (and (eq status :exited)
                                (eql exit-code 0))
                         (let* ((write-date (or (ignore-errors (file-write-date (standard-image-name))) 0)))
                           (unless (and write-date (> write-date old-write-date))
                             (error "The heap image ~a does not appear to have been written correctly.  This may indicate a problem with the bootstapping image." (standard-image-name)))
                           (format t "~&;Wrote heap image: ~s"
                                   (truename (format nil "ccl:~a"
                                                     (standard-image-name))))
                           (when verbose
                             (format t "~&;Reload heap image output:~%~a"
                                     (get-output-stream-string output))))
                         (error "Errors (~s ~s) reloading boot image:~&~a"
                                status exit-code
                                (get-output-stream-string output))))))))
             (when exit
               (quit)))
        (setf (current-directory) cd)))))
                                                  
               
(defun create-interfaces (dirname &key target populate-arg)
  (let* ((backend (if target (find-backend target) *target-backend*))
         (*default-pathname-defaults* nil)
         (ftd (backend-target-foreign-type-data backend))
         (d (use-interface-dir dirname ftd))
         (populate (merge-pathnames "C/populate.sh"
                                    (merge-pathnames
                                     (interface-dir-subdir d)
                                     (ftd-interface-db-directory ftd))))
         (cdir (make-pathname :directory (pathname-directory (translate-logical-pathname populate))))
         (args (list "-c"
                     (format nil "cd ~a && /bin/sh ~a ~@[~a~]"
                             (native-translated-namestring cdir)
                             (native-translated-namestring populate)
                             populate-arg))))
    (format t "~&;[Running interface translator via ~s to produce .ffi file(s) from headers]~&" populate)
    (force-output t)
    (multiple-value-bind (status exit-code)
        (external-process-status
         (run-program "/bin/sh" args :output t))
      (if (and (eq status :exited)
               (eql exit-code 0))
        (let* ((f 'parse-standard-ffi-files))
          (require "PARSE-FFI")
          (format t "~%~%;[Parsing .ffi files; may create new .cdb files for ~s]" dirname)
          (funcall f dirname target)
          (format t "~%~%;[Parsing .ffi files again to resolve forward-referenced constants]")
          (funcall f dirname target))))))

(defun update-ccl (&key (verbose t))
  (let* ((changed ())
	 (new-binaries ())
         (conflicts ()))
    (with-output-to-string (out)
      (with-preserved-working-directory ("ccl:")                     
        (when verbose (format t "~&;Running 'svn update'."))
        (multiple-value-bind (status exit-code)
            (external-process-status
             (run-program *svn-program* '("update" "--non-interactive") :output out :error t))
          (when verbose (format t "~&;'svn update' complete."))
          (if (not (and (eq status :exited)
                        (eql exit-code 0)))
            (error "Running \"svn update\" produced exit status ~s, code ~s." status exit-code)
            (let* ((sout (get-output-stream-string out))
                   (added ())
                   (deleted ())
                   (updated ())
                   (merged ())
                   (binaries (list (standard-kernel-name) (standard-image-name )))
                   (peer (peer-platform)))
              (when peer
                (push (standard-kernel-name peer) binaries)
                (push (standard-image-name peer) binaries))
              (flet ((svn-revert (string)
                       (multiple-value-bind (status exit-code)
                           (external-process-status (run-program *svn-program* `("revert" ,string)))
                         (when (and (eq status :exited) (eql exit-code 0))
                           (setq conflicts (delete string conflicts :test #'string=))
                           (push string updated)))))
                (with-input-from-string (in sout)
                  (do* ((line (read-line in nil nil) (read-line in nil nil)))
                       ((null line))
                    (when (and (> (length line) 2)
                               (eql #\space (schar line 1)))
                      (let* ((path (string-trim " " (subseq line 2))))
                        (case (schar line 0)
                          (#\A (push path added))
                          (#\D (push path deleted))
                          (#\U (push path updated))
                          (#\G (push path merged))
                          (#\C (push path conflicts)))))))
                ;; If the kernel and/or image conflict, use "svn revert"
                ;; to replace the working copies with the (just updated)
                ;; repository versions.
                (setq changed (if (or added deleted updated merged conflicts) t))
                (dolist (f binaries)
		  (cond ((member f conflicts :test #'string=)
			 (svn-revert f)
			 (setq new-binaries t))
			((or (member f updated :test #'string=)
			     (member f merged :test #'string=))
			 (setq new-binaries t))))

                ;; If there are any remaining conflicts, offer
                ;; to revert them.
                (when conflicts
                  (with-preserved-working-directory ()
                    (cerror "Discard local changes to these files (using 'svn revert')."
                            "'svn update' was unable to merge local changes to the following file~p with the updated versions:~{~&~s~}" (length conflicts) conflicts)
                    (dolist (c (copy-list conflicts))
                      (svn-revert c))))
                ;; Report other changes, if verbose.
                (when (and verbose
                           (or added deleted updated merged conflicts))
                  (format t "~&;Changes from svn update:")
                  (flet ((show-changes (herald files)
                           (when files
                             (format t "~&; ~a:~{~&;  ~a~}"
                                     herald files))))
                    (show-changes "Conflicting files" conflicts)
                    (show-changes "New files/directories" added)
                    (show-changes "Deleted files/directories" deleted)
                    (show-changes "Updated files" updated)
                    (show-changes "Files with local changes, successfully merged" merged)))))))))
    (values changed conflicts new-binaries)))

(defmacro with-preserved-working-directory ((&optional dir) &body body)
  (let ((wd (gensym)))
    `(let ((,wd (mac-default-directory)))
       (unwind-protect
	    (progn 
	      ,@(when dir `((cwd ,dir)))
	      ,@body)
	 (cwd ,wd)))))

(defun ensure-tests-loaded (&key force update ansi ccl (load t))
  (unless (and (find-package "REGRESSION-TEST") (not force))
    (if (probe-file "ccl:tests;ansi-tests;")
      (when update
	(cwd "ccl:tests;")
	(run-program *svn-program* '("update") :output t))
      (let* ((repo (svn-repository))
	     (url (format nil "~a/trunk/tests" repo))
	     (s (make-string-output-stream)))
	(if (null repo)
	  (error "Can't determine svn repository.  ccl directory is ~s"
		 (ccl-directory))
	  (progn
	    (format t "~&Using ~a to check out test suite from ~a ~
                       into ccl:tests;~%" *svn-program* url)
	    (cwd "ccl:")
	    (multiple-value-bind (status exit-code)
                (external-process-status
                 (run-program *svn-program* (list "checkout" url "tests")
                              :output s :error s))
	      (unless (and (eq status :exited)
			   (eql exit-code 0))
		(error "Failed to check out test suite: ~%~a"
		       (get-output-stream-string s))))))))
    (cwd "ccl:tests;ansi-tests;")
    (run-program "make" '("-k" "clean") :output t)
    (map nil 'delete-file (directory "*.*fsl"))
    (when load
      ;; Muffle the typecase "clause ignored" warnings, since there is really nothing we can do about
      ;; it without making the test suite non-portable across platforms...
      (handler-bind ((warning (lambda (c)
                                (if (typep c 'shadowed-typecase-clause)
                                  (muffle-warning c)
                                  (when (let ((w (or (and (typep c 'compiler-warning)
                                                          (eq (compiler-warning-warning-type c) :program-error)
                                                          (car (compiler-warning-args c)))
                                                     c)))
                                          (or (typep (car (compiler-warning-args c))
                                                     'shadowed-typecase-clause)
                                              (and (typep w 'simple-warning)
                                                   (or 
                                                    (string-equal
                                                     (simple-condition-format-control w)
                                                     "Clause ~S ignored in ~S form - shadowed by ~S .")
                                                    ;; Might as well ignore these as well, they're intentional.
                                                    (string-equal
                                                     (simple-condition-format-control w)
                                                     "Duplicate keyform ~s in ~s statement.")))))
                                    (muffle-warning c))))))
        ;; This loads the infrastructure
        (load "ccl:tests;ansi-tests;gclload1.lsp")
        ;; This loads the actual tests
        (let ((redef-var (find-symbol "*WARN-IF-REDEFINE-TEST*" :REGRESSION-TEST)))
          (progv (list redef-var) (list (if force nil (symbol-value redef-var)))
            (when ansi
              (load "ccl:tests;ansi-tests;gclload2.lsp"))
            ;; And our own tests
            (when ccl
              (load "ccl:tests;ansi-tests;ccl.lsp"))))))))


(defun test-ccl (&key force (update t) verbose (catch-errors t) (ansi t) (ccl t)
                      optimization-settings exit exhaustive)
  (if exhaustive
    (let* ((total-failures ()))
      (ensure-tests-loaded :update update :force nil :load nil)
      (dotimes (speed 4)
        (dotimes (space 4)
          (dotimes (safety 4)
            (dotimes (debug 4)
              (dotimes (compilation-speed 4)
                (let* ((optimization-settings `((speed ,speed)
                                                (space ,space)
                                                (safety ,safety)
                                                (debug ,debug)
                                                (compilation-speed ,compilation-speed))))
                  (format t "~&;Testing ~a at optimization settings~&;~s~&"
                          (lisp-implementation-version) optimization-settings)
                  (let* ((failures (test-ccl :force t
                                             :update nil
                                             :verbose verbose
                                             :catch-errors catch-errors
                                             :ansi ansi
                                             :ccl ccl
                                             :optimization-settings optimization-settings
                                             :exit nil)))
                    (when failures
                      (push (cons optimization-settings failures) total-failures)))))))))
      (if exit
        (quit (if total-failures 1 0))
        total-failures))
    (with-preserved-working-directory ()
      (let* ((*package* (find-package "CL-USER"))
             (*load-preserves-optimization-settings* t))
        (with-global-optimization-settings ()
          (proclaim `(optimize ,@optimization-settings))
          (ensure-tests-loaded :force force :update update :ansi ansi :ccl ccl)
          (cwd "ccl:tests;ansi-tests;")
          (let ((do-tests (find-symbol "DO-TESTS" "REGRESSION-TEST"))
                (failed (find-symbol "*FAILED-TESTS*" "REGRESSION-TEST"))
                (*print-catch-errors* nil))
            (prog1
                (time (funcall do-tests :verbose verbose :compile t
                               :catch-errors catch-errors
                               :optimization-settings (or optimization-settings '((speed 1) (space 1) (safety 1) (debug 1) (compilation-speed 1)))))
              ;; Clean up a little
              (map nil #'delete-file
                   (directory (merge-pathnames *.fasl-pathname* "ccl:tests;ansi-tests;temp*"))))
            (let ((failed-tests (symbol-value failed)))
              (when exit
                (quit (if failed-tests 1 0)))
              failed-tests)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/compile-ccl.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/db-io.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2001-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; The "CDB" files used here are similar (but not identical) to those
;;; used in the Unix CDB package <http://cr.yp.to/cdb.html>.  The primary
;;; known & intentional differences are:
;;;
;;; a) key values, record positions, and other 32-bit metadata in the
;;;    files are stored in native (vice little-endian) order.
;;; b) hash values are always non-negative fixnums.
;;;
;;; I haven't thought of a compelling reason to attempt full compatibility.
;;;
;;; The basic idea is that the database files are created in a batch
;;; process and are henceforth read-only (e.g., lookup is optimized by
;;; making insertion & deletion impractical or impossible.)  That's
;;; just about exactly what we want here.
;;;
;;; Those of you keeping score may notice that this is the third or forth
;;; database format that Clozure CL has used for its interface database.
;;; As always, this will hopefully be the last format change; the fact
;;; that this code is self-contained (doesn't depend on any Unix database
;;; library) should make it easier to port to other platforms.

(in-package "CCL")

(defparameter *interface-abi-version* 2)
(defparameter *min-interface-abi-version* 1)

(defconstant cdb-hash-mask (1- (ash 1 29)))

(defun cdb-hash (buf len)
  (declare (type (unsigned-byte 29) len))
  (let* ((h 5381))
    (declare (type (unsigned-byte 29) h))
    (dotimes (i len (logand h cdb-hash-mask))
      (declare (type (unsigned-byte 29) i))
      (setq h (+ h (the (unsigned-byte 29) (logand cdb-hash-mask (the (signed-byte 30) (ash h 5))))))

      (setq h (logxor (the (unsigned-byte 8) (%get-unsigned-byte buf i)) h)))))

(defconstant cdbm-hplist 1000)

(defmacro hp-h (v n)
  `(aref ,v (* ,n 2)))

(defmacro hp-p (v n)
  `(aref ,v (1+ (* ,n 2))))

(defstruct cdbm-hplist
  (hp (make-array (* 2 cdbm-hplist)
		  :element-type '(unsigned-byte 32)
		  :initial-element 0))
  (next nil)
  (num 0))





#+openmcl
(progn

  #-BOOTSTRAPPED ;; remove once bootstrapped.
  (unless (fboundp 'defaulted-native-namestring) (fset 'defaulted-native-namestring #'native-translated-namestring))

  ;;; Given a (possibly logical) PATHNAME, return a corresponding namestring
  ;;; suitable for passing to an OS file-open call.
  (defun cdb-native-namestring (pathname)
    (defaulted-native-namestring pathname))
  
  ;;; Open the file specified by PATHNAME for output and return a
  ;;; small integer "file id" (fid).
  (defun fid-open-output (pathname)
    (let ((dir (make-pathname :type nil :name nil :defaults pathname)))
      (unless (probe-file dir)
	(error "The directory ~S does not exist, cannot open/create ~S"
	       dir pathname)))
    (let* ((id (fd-open (cdb-native-namestring pathname)
			(logior #$O_WRONLY #$O_CREAT #$O_TRUNC))))
      (if (< id 0)
	(%errno-disp id pathname)
	id)))

  ;;; Open the file specified by PATHNAME for input and return a
  ;;; file id.
  #-windows-target
  (defun fid-open-input (pathname)
    (let* ((id (fd-open (cdb-native-namestring pathname) #$O_RDONLY)))
      (if (< id 0)
	(%errno-disp id pathname)
	id)))
  ;; On Windows, open() can't open the same file twice, which breaks
  ;; bootstrapping.  Use CreateFile instead, and tell it to share.
  #+windows-target
  (defun fid-open-input (pathname)
    (with-filename-cstrs ((name (cdb-native-namestring pathname)))
      (let* ((handle (#_CreateFileW
				   name
				   #$GENERIC_READ
				   #$FILE_SHARE_READ
				   (%null-ptr)
				   #$OPEN_EXISTING
				   #$FILE_ATTRIBUTE_NORMAL
				   (%null-ptr))))
	(if (eql handle *windows-invalid-handle*)
	  (error "Error opening CDB database ~S" pathname)
	  (%ptr-to-int handle)))))

  ;;; Read N octets from FID into BUF.  Return #of octets read or error.
  (defun fid-read (fid buf n)
    (let* ((count (fd-read fid buf n)))
      (if (< count 0)
	(%errno-disp count "reading from file")
	count)))

  ;;; Write N octets to FID from BUF.  Return #of octets written or error.
  (defun fid-write (fid buf n)
    (let* ((count (fd-write fid buf n)))
      (if (< count 0)
	(%errno-disp count "writing to file")
	count)))

  ;;; Return the absolute (octet) position of FID.
  (defun fid-pos (fid)
    (fd-tell fid))

  ;;; Return the current size of the file referenced by FID, in
  ;;; octets.
  (defun fid-size (fid)
    (fd-size fid))
  
  ;;; Seek to specified position (relative to file start.)
  (defun fid-seek (fid pos)
    (fd-lseek fid pos #$SEEK_SET))

  ;;; Guess what this does ?
  (defun fid-close (fid)
    (fd-close fid))

  ;;; Allocate a block of size N bytes (via malloc, #_NewPtr, etc.)
  (defun cdb-alloc (n)
    (malloc n))

  ;;; Free a block allocated by cdb-alloc.
  (defun cdb-free (block)
    (free block))
  )

;;; I suppose that if we wanted to store these things in little-endian
;;; order this'd be the place to swap bytes ...
(defun fid-write-u32 (fid val)
  (%stack-block ((valptr 4))
    (setf (%get-unsigned-long valptr) val)
    (fid-write fid valptr 4)
    val))

(defun fid-read-u32 (fid)
  (%stack-block ((valptr 4))
    (fid-read fid valptr 4)
    (%get-unsigned-long valptr)))



;;; Write N elements of a vector of type (UNSIGNED-BYTE 32) to file-id
;;; FID, starting at element START.  The vector should be a simple
;;; (non-displaced) array.
(defun fid-write-u32-vector (fid v n start)
  (let* ((remaining-octets (* n 4))
	 (start-octet (* start 4))
	 (bufsize 2048))
    (%stack-block ((buf bufsize))
      (do* ()
	   ((zerop remaining-octets))
	(let* ((chunksize (min remaining-octets bufsize)))
	  (%copy-ivector-to-ptr v start-octet buf 0 chunksize)
	  (fid-write fid buf chunksize)
	  (incf start-octet chunksize)
	  (decf remaining-octets chunksize))))))

(defstruct cdbx
  fid					;a small integer denoting a file
  pathname)				;that file's pathname

;;; A CDBM is used to create a database.
(defstruct (cdbm (:include cdbx))
  (final (make-array (* 256 2)
		     :element-type '(unsigned-byte 32)
		     :initial-element 0))
  (count (make-array 256 :element-type '(unsigned-byte 32) :initial-element 0))
  (start (make-array 256 :element-type '(unsigned-byte 32) :initial-element 0))
  (head nil)
  (split nil)
  (hash nil)
  (numentries 0)
  )

(defun cdbm-open (pathname)
  (let* ((fid (fid-open-output pathname))
	 (cdbm (make-cdbm :fid fid :pathname pathname))
	 (final (cdbm-final cdbm)))
    ;;; Write the (empty) final table to the start of the file.  Twice.
    (fid-write-u32-vector fid final (length final) 0)
    (fid-write-u32-vector fid final (length final) 0)
    cdbm))

;;; Note a newly-added <key,value> pair's file position and hash code.
(defun %cdbm-add-hash-pos (cdbm hash pos)
  (let* ((head (cdbm-head cdbm)))
    (when (or (null head)
	      (>= (cdbm-hplist-num head) cdbm-hplist))
      (setq head (make-cdbm-hplist))
      (setf (cdbm-hplist-next head) (cdbm-head cdbm)
	    (cdbm-head cdbm) head))
    (let* ((num (cdbm-hplist-num head))
	   (hp (cdbm-hplist-hp head)))
      (setf (hp-h hp num) hash
	    (hp-p hp num) pos))
    (incf (cdbm-hplist-num head))
    (incf (cdbm-numentries cdbm))))

(defun cdbm-put (cdbm key data)
  (let* ((fid (cdbm-fid cdbm))
	 (pos (fid-pos fid))
	 (keylen (pref key :cdb-datum.size))
	 (keyptr (pref key :cdb-datum.data))
	 (datalen (pref data :cdb-datum.size))
	 (hash (cdb-hash keyptr keylen)))
    (fid-write-u32 fid keylen)
    (fid-write-u32 fid datalen)
    (fid-write fid keyptr keylen)
    (fid-write fid (pref data :cdb-datum.data) datalen)
    (%cdbm-add-hash-pos cdbm hash pos)))

(defun %cdbm-split (cdbm)
  (let* ((count (cdbm-count cdbm))
	 (start (cdbm-start cdbm))
	 (numentries (cdbm-numentries cdbm)))
    (dotimes (i 256) (setf (aref count i) 0))
    (do* ((x (cdbm-head cdbm) (cdbm-hplist-next x)))
	 ((null x))
      (do* ((i (cdbm-hplist-num x))
	    (hp (cdbm-hplist-hp x)))
	   ((zerop i))
	(decf i)
	(incf (aref count (logand 255 (hp-h hp i))))))
    (let* ((memsize 1))
      (dotimes (i 256)
	(let* ((u (* 2 (aref count i))))
	  (if (> u memsize)
	    (setq memsize u))))
      (incf memsize numentries)
      (let* ((split (make-array (the fixnum (* 2 memsize))
				:element-type '(unsigned-byte 32))))
	(setf (cdbm-split cdbm) split)
	(setf (cdbm-hash cdbm)
	      (make-array (- (* 2 memsize)
			     (* 2 numentries))
			  :element-type '(unsigned-byte 32)
			  :displaced-to split
			  :displaced-index-offset (* 2 numentries)))
	(let* ((u 0))
	  (dotimes (i 256)
	    (incf u (aref count i))
	    (setf (aref start i) u)))

	(do* ((x (cdbm-head cdbm) (cdbm-hplist-next x)))
	     ((null x))
	  (do* ((i (cdbm-hplist-num x))
		(hp (cdbm-hplist-hp x)))
	       ((zerop i))
	    (decf i)
	    (let* ((idx (decf (aref start (logand 255 (hp-h hp i))))))
	      (setf (hp-h split idx) (hp-h hp i)
		    (hp-p split idx) (hp-p hp i)))))))))

(defun %cdbm-throw (cdbm pos b)
  (let* ((count (aref (cdbm-count cdbm) b))
	 (len (* 2 count))
	 (hash (cdbm-hash cdbm))
	 (split (cdbm-split cdbm)))
    (let* ((final (cdbm-final cdbm)))
      (setf (aref final (* 2 b)) pos
	    (aref final (1+ (* 2 b))) len))
    (unless (zerop len)
      (dotimes (j len)
	(setf (hp-h hash j) 0
	      (hp-p hash j) 0))
      (let* ((hpi (aref (cdbm-start cdbm) b)))
	(dotimes (j count)
	  (let* ((where (mod (ash (hp-h split hpi) -8) len)))
	    (do* ()
		 ((zerop (hp-p hash where)))
	      (incf where)
	      (if (= where len)
		(setq where 0)))
	    (setf (hp-p hash where) (hp-p split hpi)
		  (hp-h hash where) (hp-h split hpi)
		  hpi (1+ hpi))))))
    len))

;;; Write data structures to the file, then close the file.
(defun cdbm-close (cdbm)
  (when (cdbm-fid cdbm)
    (%cdbm-split cdbm)
    (let* ((hash (cdbm-hash cdbm))
	   (fid (cdbm-fid cdbm))
	   (pos (fid-pos fid)))
      (dotimes (i 256)
	(let* ((len (%cdbm-throw cdbm pos i)))
	  (dotimes (u len)
	    (fid-write-u32 fid (hp-h hash u))
	    (fid-write-u32 fid (hp-p hash u))
	    (incf pos 8))))
      (write-cdbm-trailer cdbm)
      (fid-seek fid (* 256 2 4)) ; skip the empty "final" table, write the new one
      (let* ((final (cdbm-final cdbm)))
	(fid-write-u32-vector fid final (length final) 0))
      (fid-close fid)
      (setf (cdbm-fid cdbm) nil))))

(defun write-cdbm-trailer (cdbm)
  (let* ((string (format nil "~s ~s ~d " "OpenMCL Interface File" (backend-name *target-backend*) *interface-abi-version*)))
    (%stack-block ((buf 512))
      (%cstr-pointer string buf)
      (fid-write (cdbm-fid cdbm) buf 512))))

      
;;; A CDB is used to access a database.
(defstruct (cdb (:include cdbx))
  (lock (make-lock)))

      
;;; Do the bytes on disk match KEY ?
(defun %cdb-match (fid key keylen)
  (%stack-block ((buf keylen))
    (fid-read fid buf keylen)
    (dotimes (i keylen t)
      (unless (= (the fixnum (%get-unsigned-byte key i))
		 (the fixnum (%get-unsigned-byte buf i)))
	(return)))))

;;; Seek to file position of data associated with key.  Return length
;;; of data (or NIL if no matching key.)
(defun %cdb-seek (fid key keylen)
  (let* ((hash (cdb-hash key keylen)))
    (fid-seek fid (+ (* 256 2 4) (* 8 (logand hash 255))))
    (let* ((pos (fid-read-u32 fid))
           (lenhash (fid-read-u32 fid)))
      (unless (zerop lenhash)
        (let* ((h2 (mod (ash hash -8) lenhash)))
          (dotimes (i lenhash)
            (fid-seek fid (+ pos (* 8 h2)))
            (let* ((hashed-key (fid-read-u32 fid))
                   (poskd (fid-read-u32 fid)))
              (when (zerop poskd)
                (return-from %cdb-seek nil))
              (when (= hashed-key hash)
                (fid-seek fid poskd)
                (let* ((hashed-key-len (fid-read-u32 fid))
                       (data-len (fid-read-u32 fid)))
                  (when (= hashed-key-len keylen)
                    (if (%cdb-match fid key keylen)
                      (return-from %cdb-seek data-len)))))
              (if (= (incf h2) lenhash)
                (setq h2 0)))))))))

;;; This should only be called with the cdb-lock of the containing cdb
;;; held.
(defun %cdb-get (fid key value)
  (setf (pref value :cdb-datum.size) 0
	(pref value :cdb-datum.data) (%null-ptr))
  (when fid
    (let* ((datalen (%cdb-seek fid
                               (pref key :cdb-datum.data)
                               (pref key :cdb-datum.size))))
      (when datalen
        (let* ((buf (cdb-alloc datalen)))
          (fid-read fid buf datalen)
          (setf (pref value :cdb-datum.size) datalen
                (pref value :cdb-datum.data) buf)))
      value)))

(defun cdb-get (cdb key value)
  (with-lock-grabbed ((cdb-lock cdb))
    (%cdb-get (cdb-fid cdb) key value)))

(defun cdb-subdirectory-path (&optional (ftd *target-ftd*))
  (let* ((ftd-name (ftd-interface-db-directory ftd))
	 (ftd-dir (pathname-directory ftd-name)))
    (assert (equalp (pathname-host ftd-name) "ccl"))
    (assert (eq (car ftd-dir) :absolute))
    (cdr ftd-dir)))

(defvar *interfaces-root* "ccl:")

(defun open-interface-db-pathname (name d)
  (let* ((db-path (make-pathname :host (pathname-host *interfaces-root*)
				 :directory (append
					     (or (pathname-directory *interfaces-root*)
						 '(:absolute))
					     (cdb-subdirectory-path *target-ftd*))))
	 (path (merge-pathnames name
				(merge-pathnames (interface-dir-subdir d) db-path))))
    (cdb-open path)))

(defun cdb-open (pathname)
  (if (probe-file pathname)
    (let* ((cdb (make-cdb :fid (fid-open-input (cdb-native-namestring pathname))
                          :pathname (namestring pathname))))
      (cdb-check-trailer cdb))
    (progn
      (if (probe-file (make-pathname :name nil :type nil :defaults pathname))
        (warn "Interface file ~s does not exist." pathname)
        (warn "Interface file ~s does not exist, and the containing directory does not exist.~%This may mean that that the \"ccl:\" logical-pathname host has not been properly initialized. " (translate-logical-pathname pathname)))
      (make-cdb :fid nil :pathname (namestring pathname)))))

(defun cdb-check-trailer (cdb)
  (flet ((error-with-cdb (string &rest args)
           (error "Error in interface file at ~s: ~a"
                  (cdb-pathname cdb) (apply #'format nil string args))))
    (let* ((fid (cdb-fid cdb)))
      (fid-seek fid (- (fid-size fid) 512))
      (%stack-block ((buf 512))
        (fid-read fid buf 512)
        (let* ((string (make-string 512)))
          (dotimes (i 512)
            (setf (%scharcode string i) (%get-unsigned-byte buf i)))
          (with-input-from-string (s string)
            (let* ((sig (ignore-errors (read s)))
                   (target (ignore-errors (read s)))
                   (version (ignore-errors (read s))))
              (if (equal sig "OpenMCL Interface File")
                (if (eq target (backend-name *target-backend*))
                  (if (and version
                           (>= version *min-interface-abi-version*)
                           (<=  version *interface-abi-version*))
                    cdb
                    (error-with-cdb "Wrong interface ABI version. Expected ~d, got ~d" *interface-abi-version* version))
                  cdb #+nil(error-with-cdb "Wrong target."))
                (error-with-cdb "Missing interface file signature.  Obsolete version?")))))))))

                  
    
(defun cdb-close (cdb)
  (let* ((fid (cdb-fid cdb)))
    (setf (cdb-fid cdb) nil)
    (when fid
      (fid-close fid))
    t))

(defmethod print-object ((cdb cdbx) stream)
  (print-unreadable-object (cdb stream :type t :identity t)
    (let* ((fid (cdb-fid cdb)))
      (format stream "~s [~a]" (cdb-pathname cdb) (or fid "closed")))))


(defun cdb-enumerate-keys (cdb &optional (predicate #'true))
  "Returns a list of all keys (strings) in the open .cdb file CDB which
satisfy the optional predicate PREDICATE."
  (with-lock-grabbed ((cdb-lock cdb))
    (let* ((keys ())
           (fid (cdb-fid cdb)))
      (dotimes (i 256 keys)
        (fid-seek fid (+ (* 256 2 4) (* 8 i)))
        (let* ((pos (fid-read-u32 fid))
               (n (fid-read-u32 fid)))
          (dotimes (j n)
            (fid-seek fid (+ pos (* 8 j) 4))
            (let* ((posk (fid-read-u32 fid)))
              (unless (zerop posk)
                (fid-seek fid posk)
                (let* ((hashed-key-len (fid-read-u32 fid)))
                  ;; Skip hashed data length
                  (fid-read-u32 fid)
                  (let* ((string (make-string hashed-key-len)))
                    (%stack-block ((buf hashed-key-len))
                      (fid-read fid buf hashed-key-len)
                      (dotimes (k hashed-key-len)
                        (setf (schar string k)
                              (code-char (%get-unsigned-byte buf k)))))
                    (when (funcall predicate string)
                      (push (copy-seq string) keys))))))))))))
                                        ;
                  


(defstruct ffi-type
  (ordinal nil)
  (defined nil)
  (string)
  (name)                                ; a keyword, uppercased or NIL
)

(defmethod print-object ((x ffi-type) out)
  (print-unreadable-object (x out :type t :identity t)
    (format out "~a" (ffi-type-string x))))

(defvar *ffi-prefix* "")

(defstruct (ffi-mem-block (:include ffi-type))
  fields
  (anon-global-id )
  (alt-alignment-bits nil))

(defstruct (ffi-union (:include ffi-mem-block)
                      (:constructor
                       make-ffi-union (&key
                                       string name
                                       &aux
                                       (anon-global-id
                                        (unless name
                                          (concatenate 'string
                                                       *ffi-prefix*
                                                       "-" string)))))))


(defstruct (ffi-transparent-union (:include ffi-mem-block)
                                  (:constructor
                                   make-ffi-transparent-union (&key
                                                               string name
                                                               &aux
                                                               (anon-global-id
                                                                (unless name
                                                                  (concatenate 'string
                                                                               *ffi-prefix*
                                                                               "-" string)))))))
(defstruct (ffi-struct (:include ffi-mem-block)
                       (:constructor
                       make-ffi-struct (&key
                                       string name
                                       &aux
                                       (anon-global-id
                                        (unless name
                                          (concatenate 'string
                                                       *ffi-prefix*
                                                       "-" string)))))))

(defstruct (ffi-typedef (:include ffi-type))
  (type))

(defstruct (ffi-objc-class (:include ffi-type))
  super-foreign-name
  protocol-names
  own-ivars
  )

(defstruct (ffi-objc-method)
  class-name
  arglist
  result-type
  flags)

(defstruct (ffi-objc-message (:include ffi-type))
  methods)
                            

(defun ffi-struct-reference (s)
  (or (ffi-struct-name s) (ffi-struct-anon-global-id s)))

(defun ffi-union-reference (u)
  (or (ffi-union-name u) (ffi-union-anon-global-id u)))

(defun ffi-transparent-union-reference (u)
  (or (ffi-transparent-union-name u) (ffi-transparent-union-anon-global-id u)))

(defstruct (ffi-function (:include ffi-type))
  arglist
  return-value)
    

(eval-when (:compile-toplevel :load-toplevel :execute)
(defconstant db-string-constant 0)
(defconstant db-read-string-constant 1)
(defconstant db-s32-constant 2)
(defconstant db-u32-constant 3)
(defconstant db-float-constant 4)
(defconstant db-double-constant 5)
(defconstant db-char-constant 6)
(defconstant db-pointer-constant 7)
)

(defparameter *arg-spec-encoding*
  '((#\Space . :void)
    (#\a . :address)
    (#\F . :signed-fullword)
    (#\f . :unsigned-fullword)
    (#\H . :signed-halfword)
    (#\h . :unsigned-halfword)
    (#\B . :signed-byte)
    (#\b . :unsigned-byte)
    (#\s . :single-float)
    (#\d . :double-float)
    (#\L . :signed-doubleword)
    (#\l . :unsigned-doubleword)
    (#\r . :record)))



(defun decode-arguments (string)
  (let* ((result nil))
    (collect ((args))
      (do* ((i 0 (1+ i)))
           ((= i (length string)) (values (args) result))
        (declare (fixnum i))
        (let* ((ch (schar string i))
               (val (if (or (eql ch #\r) (eql ch #\u) (eql ch #\t))
                      (let* ((namelen (char-code (schar string (incf i))))
                             (name (make-string namelen)))
                        (dotimes (k namelen)
                          (setf (schar name k)
                                (schar string (incf i))))
                        (setq name (escape-foreign-name name))
                        (if (eql ch #\r)
                          `(:struct ,name)
                          (if (eql ch #\u)
                            `(:union ,name)
                            (if (eql ch #\U)
                              `(:transparent-union ,name)
                              name))))
                      (cdr (assoc ch *arg-spec-encoding*)))))
          (if result
            (args val)
            (setq result val)))))))


;;; encoded external function looks like:
;;; byte min-args
;;; byte name-length
;;; name-length bytes of name
;;; result+arg specs

(defun extract-db-function (datum)
  (let* ((val nil)
         (dsize (pref datum :cdb-datum.size)))
    (with-macptrs ((dptr))
      (%setf-macptr dptr (pref datum :cdb-datum.data))
      (unless (%null-ptr-p dptr)
	(let* ((min-args (%get-byte dptr))
	       (name-len (%get-byte dptr 1))
	       (external-name (%str-from-ptr (%inc-ptr dptr 2) name-len))
	       (encoding-len (- dsize (+ 2 name-len)))
	       (encoding (make-string encoding-len)))
	  (declare (dynamic-extent encoding))
          (%str-from-ptr (%inc-ptr dptr (+ 2 name-len)) encoding-len encoding)
	  (cdb-free (pref datum :cdb-datum.data))
	  (multiple-value-bind (args result)
	      (decode-arguments encoding)
	    (setq val (make-external-function-definition
		       :entry-name external-name
		       :arg-specs args
		       :result-spec result
		       :min-args min-args))))))
    val))

(defun db-lookup-function (cdb name)
  (when cdb
    (rletZ ((value :cdb-datum)
            (key :cdb-datum))
      (with-cstrs ((keyname (string name)))
        (setf (pref key :cdb-datum.data) keyname
              (pref key :cdb-datum.size) (length (string name))
              (pref value :cdb-datum.data) (%null-ptr)
              (pref value :cdb-datum.size) 0)
        (cdb-get cdb key value)
        (extract-db-function value)))))




        
(defun extract-db-constant-value (datum)
  (let* ((val nil)
         (dsize (pref datum :cdb-datum.size)))
    (with-macptrs ((dptr))
      (%setf-macptr dptr (pref datum :cdb-datum.data))
      (unless (%null-ptr-p dptr)
	(let* ((class (pref dptr :dbm-constant.class)))
	  (setq val
		(ecase class
                  ((#.db-string-constant #.db-read-string-constant)
                   (let* ((str (%str-from-ptr (%inc-ptr dptr 4) (- dsize 4))))
                     (if (eql class db-read-string-constant)
                       (read-from-string str)
                       str)))
                  (#.db-s32-constant (pref dptr :dbm-constant.value.s32))
                  (#.db-u32-constant (pref dptr :dbm-constant.value.u32))
                  (#.db-float-constant (pref dptr :dbm-constant.value.single-float))
                  (#.db-double-constant (pref dptr :dbm-constant.value.double-float))
                  (#.db-char-constant (code-char (pref dptr :dbm-constant.value.u32)))
                  (#.db-pointer-constant
                   (let* ((val (pref dptr :dbm-constant.value.u32)))
                     #+64-bit-target
                     (if (logbitp 31 val)
                       (setq val (logior val (ash #xffffffff 32))))
                     (%int-to-ptr val )))))
	  (cdb-free (pref datum :cdb-datum.data)))))
    val))



(defun db-lookup-constant (cdb name)
  (when cdb
    (rletZ ((value :cdb-datum)
            (key :cdb-datum))
      (with-cstrs ((keyname (string name)))
        (setf (pref key :cdb-datum.data) keyname
              (pref key :cdb-datum.size) (length (string name))
              (pref value :cdb-datum.data) (%null-ptr)
              (pref value :cdb-datum.size) 0)
        (cdb-get cdb key value)
        (extract-db-constant-value value)))))
    


(defun db-define-string-constant (cdbm name val &optional (class db-string-constant))
  (let* ((dsize (+ 4 (length val))))
    (%stack-block ((valbuf dsize))
      (dotimes (i (length val))
        (setf (%get-unsigned-byte valbuf (the fixnum (+ 4 i)))
              (%scharcode val i)))
      (setf (%get-long valbuf) class)
      (rletZ ((content :cdb-datum)
	      (key :cdb-datum))
        (setf (pref content :cdb-datum.size) dsize
              (pref content :cdb-datum.data) valbuf)
        (with-cstrs ((keyname (string name)))
          (setf (pref key :cdb-datum.size) (length (string name))
                (pref key :cdb-datum.data) keyname)
	  (cdbm-put cdbm key content))))))
      
(defun db-define-constant (cdbm name val)
  (typecase val
    (string (db-define-string-constant cdbm name val))
    ((or (unsigned-byte 32)
         (signed-byte 32)
         short-float
         double-float
         character
         macptr)
     (rletZ ((constant :dbm-constant)
	     (content :cdb-datum)
	     (key :cdb-datum))
       (etypecase val
         ((signed-byte 32)
          (setf (pref constant :dbm-constant.value.s32) val)
          (setf (pref constant :dbm-constant.class) db-s32-constant))
         ((unsigned-byte 32)
          (setf (pref constant :dbm-constant.value.u32) val)
          (setf (pref constant :dbm-constant.class) db-u32-constant))
         (short-float
          (setf (pref constant :dbm-constant.value.single-float) val)
          (setf (pref constant :dbm-constant.class) db-float-constant))
         (double-float
          (setf (pref constant :dbm-constant.value.double-float) val)
          (setf (pref constant :dbm-constant.class) db-double-constant))
         (character
          (setf (pref constant :dbm-constant.value.u32) (char-code val))
          (setf (pref constant :dbm-constant.class) db-char-constant))
         (macptr
          (setf (pref constant :dbm-constant.value.u32) (logand #xffffffff (%ptr-to-int val)))
          (setf (pref constant :dbm-constant.class) db-pointer-constant))
         )
       (setf (pref content :cdb-datum.data) constant
             (pref content :cdb-datum.size) (record-length :dbm-constant))
       (with-cstrs ((keyname (string name)))
         (setf (pref key :cdb-datum.data) keyname
               (pref key :cdb-datum.size) (length (string name)))
	 (cdbm-put cdbm key content))))
    (t (db-define-string-constant cdbm name (format nil "~a" val) db-read-string-constant))))


  

(defmacro with-new-db-file ((var pathname) &body body)
  (let* ((db (gensym)))
    `(let* (,db)
      (unwind-protect
           (let* ((,var (setq ,db (cdbm-open ,pathname))))
             ,@body)
        (when ,db (cdbm-close ,db))))))



(defun interface-db-pathname (name d &optional (ftd *target-ftd*))
  (merge-pathnames name
		   (merge-pathnames (interface-dir-subdir d)
				    (ftd-interface-db-directory ftd))))

(def-ccl-pointers reset-db-files ()
  (do-interface-dirs (d)
    (setf (interface-dir-constants-interface-db-file d) nil
	  (interface-dir-functions-interface-db-file d) nil
	  (interface-dir-records-interface-db-file d) nil
	  (interface-dir-types-interface-db-file d) nil
          (interface-dir-vars-interface-db-file d) nil
          (interface-dir-objc-classes-interface-db-file d) nil
          (interface-dir-objc-methods-interface-db-file d) nil)))

(defun db-constants (dir)
  (or (interface-dir-constants-interface-db-file dir)
      (setf (interface-dir-constants-interface-db-file dir)
	    (open-interface-db-pathname "constants.cdb" dir))))

(defun db-objc-classes (dir)
  (or (interface-dir-objc-classes-interface-db-file dir)
      (setf (interface-dir-objc-classes-interface-db-file dir)
            (open-interface-db-pathname "objc-classes.cdb" dir))))

(defun db-objc-methods (dir)
  (or (interface-dir-objc-methods-interface-db-file dir)
      (setf (interface-dir-objc-methods-interface-db-file dir)
            (open-interface-db-pathname "objc-methods.cdb" dir))))

(defun db-vars (dir)
  (or (interface-dir-vars-interface-db-file dir)
      (setf (interface-dir-vars-interface-db-file dir)
	    (open-interface-db-pathname "vars.cdb" dir))))

(defun db-types (dir)
  (or (interface-dir-types-interface-db-file dir)
      (setf (interface-dir-types-interface-db-file dir)
	    (open-interface-db-pathname "types.cdb" dir))))

(defun db-records (dir)
  (or (interface-dir-records-interface-db-file dir)
      (setf (interface-dir-records-interface-db-file dir)
	    (open-interface-db-pathname "records.cdb" dir))))

(defun db-functions (dir)
  (or (interface-dir-functions-interface-db-file dir)
      (setf (interface-dir-functions-interface-db-file dir)
	    (open-interface-db-pathname "functions.cdb" dir))))

(defun load-os-constant (sym &optional query)
  (let* ((val (do-interface-dirs (d)
		    (let* ((v (db-lookup-constant (db-constants d) sym)))
		      (when v (return v))))))
    (if query
      (not (null val))
      (if val
        (let* ((*record-source-file* nil))
          (%defconstant sym val)
          val)
        (error "Constant not found: ~s" sym)))))

(defun %load-var (name &optional query-only)
  (let* ((ftd *target-ftd*)
         (string (if (getf (ftd-attributes ftd)
                           :prepend-underscores)
                   (concatenate 'string "_" (string name))
                   (string name)))
         (fv (gethash string (fvs))))
    (unless fv
      (with-cstrs ((cstring string))
        (let* ((type
                (do-interface-dirs (d)
                  (let* ((vars (db-vars d)))
                    (when vars
                      (rletZ ((value :cdb-datum)
                              (key :cdb-datum))
                        (setf (pref key :cdb-datum.data) cstring
                              (pref key :cdb-datum.size) (length string)
                              (pref value :cdb-datum.data) (%null-ptr)
                              (pref value :cdb-datum.size) 0)
                        (cdb-get vars key value)
                        (let* ((vartype (extract-db-type value ftd)))
                          (when vartype (return vartype)))))))))
          (when type
            (setq fv (%cons-foreign-variable string type))
            (resolve-foreign-variable fv nil)
            (setf (gethash string (fvs)) fv)))))
    (if query-only
      (not (null fv))
      (or fv (error "Foreign variable ~s not found" string)))))


(set-dispatch-macro-character 
 #\# #\&
 (qlfun |#&-reader| (stream char arg)
   (declare (ignore char arg))
   (let* ((package (find-package (ftd-interface-package-name *target-ftd*))))
     (multiple-value-bind (sym query source)
         (%read-symbol-preserving-case
          stream
          package)
       (unless *read-suppress*
         (let* ((fv (%load-var sym query)))
           (values (if query
                     fv
                     (%foreign-access-form `(%reference-external-entry-point (load-time-value ,fv))
                                           (fv.type fv)
                                           0
                                           nil))
                   source)))))))


              

(defstruct objc-message-info
  message-name
  methods                               ; all methods
  ambiguous-methods                     ; partitioned by signature
  req-args
  flags
  protocol-methods
  lisp-name
  selector)



   
(defstruct objc-method-info
  message-info
  class-name
  class-pointer                         ;canonical, in some sense
  arglist
  result-type
  flags
  signature
  signature-info
  )



(defmethod print-object ((m objc-method-info) stream)
  (print-unreadable-object (m stream :type t :identity t)
    (format stream "~c[~a ~a]"
            (if (getf (objc-method-info-flags m) :class)
              #\+
              #\-)
            (let* ((name (objc-method-info-class-name m)))
              (if (getf (objc-method-info-flags m) :protocol)
                (format nil "<~a>" name)
                name))
            (objc-message-info-message-name
                          (objc-method-info-message-info m)))))

(defun extract-db-objc-message-info (datum message-name info &optional
                                           (ftd *target-ftd*))
  (with-macptrs ((buf))
    (%setf-macptr buf (pref datum :cdb-datum.data))
    (unless (%null-ptr-p buf)
      (unless info
        (setq info
              (make-objc-message-info
               :message-name (string message-name))))
      (let* ((p 0)
             (nmethods 0)
             (nargs 0))
        (multiple-value-setq (nmethods p) (%decode-uint buf p))
        (multiple-value-setq (nargs p) (%decode-uint buf p))
        (dotimes (i nmethods)
          (let* ((flag-byte (prog1 (%get-unsigned-byte buf p)
                              (incf p)))
                 (is-class-method (logbitp 0 flag-byte))
                 (is-protocol-method (logbitp 1 flag-byte))
                 (class-name ())
                 (result-type ())
                 (arg-types ())
                 (arg-type ()))
            (multiple-value-setq (class-name p) (%decode-name buf p t))
            (multiple-value-setq (result-type p) (%decode-type buf p ftd t))
            (dotimes (i nargs)
              (multiple-value-setq (arg-type p) (%decode-type buf p ftd t))
              (push arg-type arg-types))
            (unless (dolist (m (objc-message-info-methods info))
                      (when (and (eq (getf (objc-method-info-flags m) :class)  is-class-method)
                                 (string= (objc-method-info-class-name m)
                                          class-name))
                        (return t)))
              (let* ((flags ()))
                (if is-class-method
                  (setf (getf flags :class) t))
                (if is-protocol-method
                  (setf (getf flags :protocol) t))
                (push (make-objc-method-info
                                     :message-info info
                                     :class-name class-name
                                     :arglist (nreverse arg-types)
                                     :result-type result-type
                                     :flags flags)
                 (objc-message-info-methods info))))))
        (cdb-free (pref datum :cdb-datum.data))))
    info))

(defun db-note-objc-method-info (cdb message-name message-info)
  (when cdb
    (rletZ ((value :cdb-datum)
            (key :cdb-datum))
      (with-cstrs ((keyname (string message-name)))
        (setf (pref key :cdb-datum.data) keyname
              (pref key :cdb-datum.size) (length (string message-name))
              (pref value :cdb-datum.data) (%null-ptr)
              (pref value :cdb-datum.size) 0)
        (cdb-get cdb key value)
        (extract-db-objc-message-info value message-name message-info)))))

(defun lookup-objc-message-info (message-name &optional message-info)
  (do-interface-dirs (d)
    (setq message-info
          (db-note-objc-method-info (db-objc-methods d) message-name message-info)))
  message-info)

(defun %find-objc-class-info (name)
  (do-interface-dirs (d)
    (let* ((info (db-lookup-objc-class (db-objc-classes d) name)))
      (when info (return info)))))

(defun load-external-function (sym query)
  (let* ((def (or (do-interface-dirs (d)
		    (let* ((f (db-lookup-function (db-functions d) sym)))
		      (when f (return f))))
                  (unless query
                    (error "Foreign function not found: ~s" sym)))))
    (if query
      (not (null def))
      (progn
        (setf (gethash sym (ftd-external-function-definitions
                            *target-ftd*)) def)
        (setf (macro-function sym) #'%external-call-expander)
        sym))))

(defun %read-symbol-preserving-case (stream package)
  (let* ((case (readtable-case *readtable*))
         (query nil)
	 (error nil)
	 (sym nil)
         (source nil))
    (let* ((*package* package))
      (unwind-protect
	   (progn
	     (setf (readtable-case *readtable*) :preserve)
             (when (eq #\? (peek-char t stream nil nil))
               (setq query t)
               (read-char stream))
	     (multiple-value-setq (sym source error)
	       (handler-case (read-internal stream nil nil nil)
		 (error (condition) (values nil nil condition)))))
	(setf (readtable-case *readtable*) case)))
    (when error
      (error error))
    (values sym query source)))

(set-dispatch-macro-character 
 #\# #\$
 (qlfun |#$-reader| (stream char arg)
        (declare (ignore char))
        (let* ((package (find-package (ftd-interface-package-name *target-ftd*))))
          (multiple-value-bind (sym query source)
              (%read-symbol-preserving-case
               stream
               package)
            (unless *read-suppress*
              (etypecase sym
                (symbol
                 (let* ((const (load-os-constant sym t)))
                   (if query
                     (values const source)
                     (progn
                       (if const
                         (progn
                           (when (eq (symbol-package sym) package)
                             (unless arg (setq arg 0))
                             (ecase arg
                               (0
                                (unless (and (constant-symbol-p sym)
                                             (not (eq (%sym-global-value sym)
                                                      (%unbound-marker-8))))
                                  (load-os-constant sym)))
                               (1 (makunbound sym) (load-os-constant sym))))
                           (values sym source))
                         (let* ((fv (%load-var sym nil)))
                           (values
                            (%foreign-access-form `(%reference-external-entry-point (load-time-value ,fv))
                                                  (fv.type fv)
                                                  0
                                                  nil)
                            source)))))))
                (string
                 (let* ((val 0)
                        (len (length sym)))
                   (dotimes (i 4 (values val source))
                     (let* ((ch (if (< i len) (char sym i) #\space)))
                       (setq val (logior (ash val 8) (char-code ch)))))))))))))

(set-dispatch-macro-character #\# #\_
  (qlfun |#_-reader| (stream char arg)
    (declare (ignore char))
    (unless arg (setq arg 0))
    (multiple-value-bind (sym query source)
        (%read-symbol-preserving-case
		 stream
		 (find-package (ftd-interface-package-name *target-ftd*)))
      (unless *read-suppress*
        (unless (and sym (symbolp sym)) (report-bad-arg sym 'symbol))
        (if query
          (values (load-external-function sym t) source)
          (let* ((def (if (eql arg 0)
                        (gethash sym (ftd-external-function-definitions
                                      *target-ftd*)))))
            (values (if (and def (eq (macro-function sym) #'%external-call-expander))
                      sym
                      (load-external-function sym nil))
                    source)))))))

(set-dispatch-macro-character
 #\# #\>
 (qlfun |#>-reader| (stream char arg)
    (declare (ignore char arg))
    (if *read-suppress*
      (progn
        (%read-list-expression stream nil)
        nil)
      (let* ((readtable *readtable*)
             (case (readtable-case readtable))
             (string nil)
             (error nil))
        (unwind-protect
             (progn
               (setf (readtable-case readtable) :preserve)
               (multiple-value-setq (string error)
                 (handler-case (read-symbol-token stream)
                   (error (condition) (values nil condition)))))
          (setf (readtable-case *readtable*) case))
        (when error
          (error error))
        (escape-foreign-name string)))))
             



(eval-when (:compile-toplevel :execute)
  (defconstant encoded-type-void 0)
  (defconstant encoded-type-signed-32 1)
  (defconstant encoded-type-unsigned-32 2)
  (defconstant encoded-type-signed-8 3)
  (defconstant encoded-type-unsigned-8 4)
  (defconstant encoded-type-signed-16 5)
  (defconstant encoded-type-unsigned-16 6)
  (defconstant encoded-type-signed-n 7) ;N
  (defconstant encoded-type-unsigned-n 8) ;N
  (defconstant encoded-type-single-float 9)
  (defconstant encoded-type-double-float 10)
  (defconstant encoded-type-pointer 11) ; <type>
  (defconstant encoded-type-array 12) ; <size> <type>
  (defconstant encoded-type-named-struct-ref 13); <tag>
  (defconstant encoded-type-named-union-ref 14) ;<tag>
  (defconstant encoded-type-named-type-ref 15) ; <name>
  (defconstant encoded-type-anon-struct-ref 16) ; <tag>
  (defconstant encoded-type-anon-union-ref 17) ; <tag>
  (defconstant encoded-type-bitfield-marker 18) ; <nbits>
  (defconstant encoded-type-named-transparent-union-ref 19) ; <name>
  (defconstant encoded-type-anon-transparent-union-ref 20)  ;<tag>
  )


(defconstant encoded-type-type-byte (byte 5 0))
(defconstant encoded-type-align-byte (byte 3 5)
  "alignment in octets, if other than \"natural\" alignment,")

;;; Constants & function names get saved verbatim.
;;; Record, type, and field names get escaped.

(defun encode-name (name &optional verbatim)
  (if (null name)
    (list 0)
    (let* ((string
	    (if (and (typep name 'keyword)
		     (not verbatim))
	      (unescape-foreign-name name)
	      (string name)))
           (length (length string)))
      (cons length (map 'list #'char-code string)))))

(defun encode-ffi-field (field)
  (destructuring-bind (name type offset width) field
  `(,@(encode-name name)
    ,@(encode-ffi-type type)
    ,@(encode-uint offset)
    ,@(encode-uint width))))

(defun encode-ffi-field-list (fields)
  (let* ((len (length fields)))
    (labels ((encode-fields (fields)
               (if fields
                 `(,@(encode-ffi-field (car fields)) ,@(encode-fields (cdr fields))))))
      `(,@(encode-uint len) ,@(encode-fields fields)))))

(defun encode-ffi-union (u)
  (let* ((name (ffi-union-name u))
	 (alt-align-in-bytes-mask (ash (or (ffi-union-alt-alignment-bits u)
				      0)
				  (- 5 3))))
    (if name
      `(,(logior encoded-type-named-union-ref alt-align-in-bytes-mask)
        ,@(encode-name name)
        ,@(encode-ffi-field-list (ffi-union-fields u)))
      `(,(logior encoded-type-anon-union-ref alt-align-in-bytes-mask)
        ,@(encode-ffi-field-list (ffi-union-fields u))))))

(defun encode-ffi-transparent-union (u)
  (let* ((name (ffi-transparent-union-name u))
	 (alt-align-in-bytes-mask (ash (or (ffi-transparent-union-alt-alignment-bits u)
                                           0)
                                       (- 5 3))))
    (if name
      `(,(logior encoded-type-named-transparent-union-ref alt-align-in-bytes-mask)
        ,@(encode-name name)
        ,@(encode-ffi-field-list (ffi-transparent-union-fields u)))
      `(,(logior encoded-type-anon-transparent-union-ref alt-align-in-bytes-mask)
        ,@(encode-ffi-field-list (ffi-transparent-union-fields u))))))

(defun encode-ffi-struct (s)
  (let* ((name (ffi-struct-name s))
	 (alt-align-in-bytes-mask (ash (or (ffi-struct-alt-alignment-bits s)
					   0)
				       (- 5 3))))
    (if name
      `(,(logior encoded-type-named-struct-ref alt-align-in-bytes-mask)
        ,@(encode-name (ffi-struct-name s))
        ,@(encode-ffi-field-list (ffi-struct-fields s)))
      `(,(logior encoded-type-anon-struct-ref alt-align-in-bytes-mask)
        ,@(encode-ffi-field-list (ffi-struct-fields s))))))

(defun encode-ffi-objc-class (c)
  (let* ((protocols (ffi-objc-class-protocol-names c)))
    (labels ((encode-name-list (names)
               (if names
                 `(,@(encode-name (car names) t)
                   ,@(encode-name-list (cdr names))))))
      `(,@(encode-name (ffi-objc-class-string c))
        ,@(encode-name (ffi-objc-class-super-foreign-name c))
        ,@(encode-uint (length protocols))
        ,@(encode-name-list protocols)
        ,@(encode-ffi-field-list (ffi-objc-class-own-ivars c))))))


(defstruct db-objc-class-info
  class-name
  superclass-name
  protocols
  ivars
  instance-methods
  class-methods
  )

(defun extract-db-objc-class (datum &optional (ftd *target-ftd*))
  (let* ((val nil))
    (with-macptrs ((buf))
      (%setf-macptr buf (pref datum :cdb-datum.data))
      (unless (%null-ptr-p buf)
	(let* ((p 0)
               (protocol-count 0)
               (class-name ())
               (superclass-name ())
               (protocol-name ())
               (ivars ()))
          (collect ((protocols))
            (multiple-value-setq (class-name p) (%decode-name buf p t))
            (multiple-value-setq (superclass-name p) (%decode-name buf p t))
            (multiple-value-setq (protocol-count p) (%decode-uint buf p))
            (dotimes (i protocol-count)
              (multiple-value-setq (protocol-name p) (%decode-name buf p t))
              (protocols protocol-name))
            (setq ivars (%decode-field-list buf p ftd))
            (cdb-free (pref datum :cdb-datum.data))
            (setq val (make-db-objc-class-info
                       :class-name class-name
                       :superclass-name superclass-name
                       :ivars ivars
                       :protocols (protocols)
                     ))))))
    val))

(defun db-lookup-objc-class (cdb name)
  (when cdb
    (rletZ ((value :cdb-datum)
            (key :cdb-datum))
      (with-cstrs ((keyname (string name)))
        (setf (pref key :cdb-datum.data) keyname
              (pref key :cdb-datum.size) (length (string name))
              (pref value :cdb-datum.data) (%null-ptr)
              (pref value :cdb-datum.size) 0)
        (cdb-get cdb key value)
        (extract-db-objc-class value)))))

(defun encode-u32 (val)
  `(,(ldb (byte 8 24) val)
    ,(ldb (byte 8 16) val)
    ,(ldb (byte 8 8) val)
    ,(ldb (byte 8 0) val)))

(defun encode-uint (val)
  (collect ((bytes))
    (do* ((b (ldb (byte 7 0) val) (ldb (byte 7 0) val))
          (done nil))
         (done (bytes))
      (when (zerop (setq val (ash val -7)))
        (setq b (logior #x80 b) done t))
      (bytes b))))

    

(defun encode-ffi-type (spec)
  (case (car spec)
    (:primitive
     (let ((primtype (cadr spec)))
       (if (atom primtype)
         (case primtype
           (:float `(,encoded-type-single-float))
           (:double `(,encoded-type-double-float))
           (:void `(,encoded-type-void))
           (:signed `(,encoded-type-signed-32))
           (:unsigned `(,encoded-type-unsigned-32))
           ((:long-float :long-double) (encode-ffi-type '(:array 2 (:primitive :double))))
           (:complex-int (encode-ffi-type '(:array 2 (:primitive :signed))))
           (:complex-float (encode-ffi-type '(:array 2 (:primitive :float))))
           (:complex-double (encode-ffi-type '(:array 2 (:primitive :double))))
           (:complex-long-double (encode-ffi-type '(:array 4 (:primitive :double)))))
         (ecase (car primtype)
           (* `(,encoded-type-pointer ,@(encode-ffi-type
                                           (if (eq (cadr primtype) t)
                                             `(:primitive :void)
                                             (cadr primtype)))))
           (:signed
            (case (cadr primtype)
              (32 `(,encoded-type-signed-32))
              (16 `(,encoded-type-signed-16))
              (8 `(,encoded-type-signed-8))
              (t `(,encoded-type-signed-n ,(cadr primtype)))))
           (:unsigned
            (case (cadr primtype)
              (32 `(,encoded-type-unsigned-32))
              (16 `(,encoded-type-unsigned-16))
              (8 `(,encoded-type-unsigned-8))
              (t `(,encoded-type-unsigned-n ,(cadr primtype)))))))))
     (:struct
      (let* ((s (cadr spec))
             (name (ffi-struct-name s))
	     (alt-align-bytes-mask (ash (or (ffi-struct-alt-alignment-bits s)
					    0)
					(- 5 3))))
      `(,(if name
             (logior encoded-type-named-struct-ref alt-align-bytes-mask)
             (logior encoded-type-anon-struct-ref alt-align-bytes-mask))
        ,@(encode-name (ffi-struct-reference s)))))
     (:union
      (let* ((u (cadr spec))
             (name (ffi-union-name u))
	     (alt-align-bytes-mask (ash (or (ffi-union-alt-alignment-bits u)
					    0)
					(- 5 3)))	     )
      `(,(if name
             (logior encoded-type-named-union-ref alt-align-bytes-mask)
             (logior encoded-type-anon-union-ref alt-align-bytes-mask))
        ,@(encode-name (ffi-union-reference u)))))
     (:transparent-union
      (let* ((u (cadr spec))
             (name (ffi-transparent-union-name u))
	     (alt-align-bytes-mask (ash (or (ffi-transparent-union-alt-alignment-bits u)
					    0)
					(- 5 3)))	     )
      `(,(if name
             (logior encoded-type-named-transparent-union-ref alt-align-bytes-mask)
             (logior encoded-type-anon-transparent-union-ref alt-align-bytes-mask))
        ,@(encode-name (ffi-transparent-union-reference u)))))
     (:typedef
      `(,encoded-type-named-type-ref ,@(encode-name (ffi-typedef-name (cadr spec)))))
     (:pointer
      `(,encoded-type-pointer ,@(encode-ffi-type
                                   (if (eq (cadr spec) t)
                                     '(:primitive :void)
                                     (cadr spec)))))
     (:array
      `(,encoded-type-array ,@(encode-uint (cadr spec)) ,@(encode-ffi-type (caddr spec))))
     (t
      (break "Type spec = ~s" spec))))

(defun encode-ffi-arg-type (spec)
  (case (car spec)
    (:primitive
     (let ((primtype (cadr spec)))
       (if (atom primtype)
         (case primtype
           (:float `(#\s))
           (:double `(#\d))
           (:void `(#\Space))
           (:signed `(#\F))
           (:unsigned `(f))
           ((:long-double :complex-int
			  :complex-float :complex-double :complex-long-double)
            #|(encode-ffi-arg-type `(:struct ,primtype))|#
            `(#\?)))
         (ecase (car primtype)
           (* `(#\a))
           (:signed
            (let* ((nbits (cadr primtype)))
              (if (<= nbits 8)
                '(#\B)
                (if (<= nbits 16)
                  '(#\H)
                  (if (<= nbits 32)
                    '(#\F)
		    (if (<= nbits 64)
		      `(#\L)
		      '(#\?)))))))
           (:unsigned
            (let* ((nbits (cadr primtype)))
              (if (<= nbits 8)
                '(#\b)
                (if (<= nbits 16)
                  '(#\h)
                  (if (<= nbits 32)
                    '(#\f)
		    (if (<= nbits 64)
		      `(#\l)
		      '(#\?)))))))))))
    ((:struct :union :transparent-union)
     `(,(ecase (car spec)
          (:struct #\r)
          (:union #\u)
          (:transparent-union #\U))
           ,@(encode-name
              (if (eq (car spec) :struct)
                (ffi-struct-reference (cadr spec))
                (ffi-union-reference (cadr spec))))))
    (:typedef
     `(#\t ,@(encode-name (ffi-typedef-name (cadr spec)))))
    (:pointer
      `(#\a))
    (:array
      `(#\?))))

(defun encode-ffi-arg-list (args)
  (if args
    `(,@(encode-ffi-arg-type (car args)) ,@(encode-ffi-arg-list (cdr args)))))

(defvar *prepend-underscores-to-ffi-function-names* nil)

(defun encode-ffi-function (f)
  (let* ((args (ffi-function-arglist f))
	 (string (ffi-function-string f))
	 (name (if *prepend-underscores-to-ffi-function-names*
		 (concatenate 'string "_" string)
		 string))
         (min-args (length args))
         (result (ffi-function-return-value f)))
    `(,min-args
      ,@(encode-name name t)		; verbatim
      ,@(encode-ffi-arg-type result)
      ,@(encode-ffi-arg-list args))))

(defun encode-ffi-objc-method (m)
  (let* ((flag-byte (logior (if (getf (ffi-objc-method-flags m) :class) 1 0)
                            (if (getf (ffi-objc-method-flags m) :protocol) 2 0))))
  `(,flag-byte
    ,@(encode-name (ffi-objc-method-class-name m) t)
    ,@(encode-ffi-type (ffi-objc-method-result-type m))
    ,@(apply #'append (mapcar #'encode-ffi-type (ffi-objc-method-arglist m))))))

(defun save-ffi-objc-message (cdbm message)
  (let* ((methods (ffi-objc-message-methods message))
         (nmethods (length methods))
         (nargs (length (ffi-objc-method-arglist (car methods)))))
    (labels ((encode-objc-method-list (ml)
               (when ml
                 `(,@(encode-ffi-objc-method (car ml))
                   ,@(encode-objc-method-list (cdr ml))))))
      (db-write-byte-list cdbm
                          (ffi-objc-message-string message)
                          `(,@(encode-uint nmethods)
                            ,@(encode-uint nargs)
                            ,@(encode-objc-method-list methods))
                          t))))
  
    
(defun save-byte-list (ptr l)
  (do* ((l l (cdr l))
        (i 0 (1+ i)))
       ((null l))
    (let* ((b (car l)))
      (if (typep b 'character)
        (setq b (char-code b)))
      (setf (%get-unsigned-byte ptr i) b))))

(defun db-write-byte-list (cdbm keyname bytes &optional verbatim)
  (let* ((len (length bytes)))
    (%stack-block ((p len))
      (save-byte-list p bytes)
      (rletZ ((contents :cdb-datum)
	      (key :cdb-datum))
        (let* ((foreign-name
		(if verbatim
		  keyname
		  (unescape-foreign-name keyname))))
	  (with-cstrs ((keystring foreign-name))
	    (setf (pref contents :cdb-datum.data) p
		  (pref contents :cdb-datum.size) len
		  (pref key :cdb-datum.data) keystring
		  (pref key :cdb-datum.size) (length foreign-name))
	    (cdbm-put cdbm key contents)))))))

(defun save-ffi-function (cdbm fun)
  (let* ((encoding (encode-ffi-function fun)))
    (db-write-byte-list cdbm
			(ffi-function-string fun)
			encoding
			t)))

(defun save-ffi-typedef (cdbm def)
  (db-write-byte-list cdbm
                       (ffi-typedef-string def)
                       (encode-ffi-type (ffi-typedef-type def))
		       t))

(defun save-ffi-struct (cdbm s)
  (db-write-byte-list cdbm (ffi-struct-reference s) (encode-ffi-struct s)))

(defun save-ffi-union (cdbm u)
  (db-write-byte-list cdbm (ffi-union-reference u) (encode-ffi-union u)))

(defun save-ffi-transparent-union (cdbm u)
  (db-write-byte-list cdbm (ffi-transparent-union-reference u) (encode-ffi-transparent-union u)))


(defun db-define-var (cdbm name type)
  (db-write-byte-list cdbm
                      (if *prepend-underscores-to-ffi-function-names*
                        (concatenate 'string "_" name)
                        name)
  (encode-ffi-type type) t))

(defun save-ffi-objc-class (cdbm c)
  (db-write-byte-list cdbm (ffi-objc-class-name c) (encode-ffi-objc-class c)))


;;; An "uppercase-sequence" is a maximal substring of a string that
;;; starts with an uppercase character and doesn't contain any
;;; lowercase characters.
(defun count-uppercase-sequences (string)
  (let* ((state :lower)
	 (nupper 0))
    (declare (fixnum nupper))
    (dotimes (i (length string) nupper)
      (let* ((ch (char string i)))
	(case state
	  (:lower 
	   (when (upper-case-p ch)
	     (incf nupper)
	     (setq state :upper)))
	  (:upper
	   (unless (upper-case-p ch)
	     (setq state :lower))))))))

(defun escape-foreign-name (in &optional
			       (count (count-uppercase-sequences in)))
  (intern
   (if (zerop count)
     (string-upcase in)
     (let* ((len (length in))
	    (j 0)
	    (out (make-string (+ len (* 2 count))))
	    (state :lower))
       (flet ((outch (ch)
		(setf (schar out j) ch)
		(incf j)
		ch))
	 (dotimes (i len (progn (if (eq state :upper) (outch #\>)) out))
	   (let* ((ch (char in i)))
	     (cond ((and (upper-case-p ch) (eq state :lower))
		    (outch #\<)
		    (setq state :upper))
		   ((and (not (upper-case-p ch)) (eq state :upper))
		    (outch #\>)
		    (setq state :lower)))
	     (outch (char-upcase ch)))))))
   *keyword-package*))

(defun unescape-foreign-name (key)
  (let* ((string (if (typep key 'symbol)
                   (string-downcase key)
                   (string key)))
	 (nleftbrackets (count #\< string))
         (nrightbrackets (count #\> string))
         (nbrackets (+ nleftbrackets nrightbrackets)))
    (declare (fixnum nleftbrackets nrightbrackets nbrackets))
    (if (zerop nbrackets)
      string
      (if (/= nleftbrackets nrightbrackets)
        (error "Mismatched brackets in ~s." key)
        (let* ((len (length string))
               (out (make-string (- len nbrackets)))
               (j 0)
               (state :lower))
          (dotimes (i len out)
            (let* ((ch (schar string i)))
              (if (or (and (eq ch #\<)
                           (eq state :upper))
                      (and (eq ch #\>)
                           (eq state :lower)))
                (error "Mismatched brackets in ~s." key))
              (case ch
                (#\< (setq state :upper))
                (#\> (setq state :lower))
                (t (setf (schar out j) (if (eq state :upper)
                                         (char-upcase ch)
                                         (char-downcase ch))
                         j (1+ j)))))))))))

	
	
(defun %decode-name (buf p &optional verbatim)
  (declare (type macptr buf) (fixnum p))
  (let* ((n (%get-unsigned-byte buf p)))
    (declare (fixnum n))
    (if (zerop n)
      (values nil (1+ p))
      (let* ((pname (%str-from-ptr (%inc-ptr buf (1+ p)) n)))
        (values (if verbatim pname (escape-foreign-name pname))
                (+ p (1+ n)))))))

(defun %decode-u32 (buf p)
  (declare (fixnum p) (type macptr buf))
  (values (dpb
           (%get-unsigned-byte buf p)
           (byte 8 24)
           (dpb
            (%get-unsigned-byte buf (+ p 1))
            (byte 8 16)
            (dpb
             (%get-unsigned-byte buf (+ p 2))
             (byte 8 8)
             (%get-unsigned-byte buf (+ p 3)))))
          (+ p 4)))

(defun %decode-uint (buf p)
  (do* ((val 0)
        (p p (1+ p))
        (shift 0 (+ shift 7))
        (done nil))
       (done (values val p))
    (let* ((b (%get-unsigned-byte buf p)))
      (setq done (logbitp 7 b) val (logior val (ash (logand b #x7f) shift))))))
       
  
;; Should return a FOREIGN-TYPE structure (except if suppress-typedef-expansion is true, may
;; return a symbol for encoded-type-named-type-ref)
(defun %decode-type (buf p ftd &optional suppress-typedef-expansion)
  (declare (type macptr buf) (fixnum p))
  (let* ((q (1+ p)))
    (ecase (ldb encoded-type-type-byte (%get-unsigned-byte buf p))
      (#.encoded-type-void (values (parse-foreign-type :void) q))
      (#.encoded-type-signed-32 (values (svref *signed-integer-types* 32) q))
      (#.encoded-type-unsigned-32 (values (svref *unsigned-integer-types* 32) q))
      (#.encoded-type-signed-8 (values (svref *signed-integer-types* 8) q))
      (#.encoded-type-unsigned-8 (values (svref *unsigned-integer-types* 8) q))
      (#.encoded-type-signed-16 (values (svref *signed-integer-types* 16) q))
      (#.encoded-type-unsigned-16 (values (svref *unsigned-integer-types* 16) q))
      (#.encoded-type-signed-n (values (let* ((bits (%get-unsigned-byte buf q)))
                                         (if (<= bits 32)
                                           (svref *signed-integer-types* bits)
                                           (make-foreign-integer-type
                                            :signed t
                                            :bits bits)))
                                         (1+ q)))
      (#.encoded-type-unsigned-n (values (let* ((bits (%get-unsigned-byte buf q)))
                                         (if (<= bits 32)
                                           (svref *unsigned-integer-types* bits)
                                           (make-foreign-integer-type
                                            :signed nil
                                            :bits bits)))
                                           (1+ q)))
      (#.encoded-type-single-float (values (parse-foreign-type :float) q))
      (#.encoded-type-double-float (values (parse-foreign-type :double) q))
      (#.encoded-type-pointer (multiple-value-bind (target qq)
                                  (%decode-type buf q ftd suppress-typedef-expansion)
                                (values (make-foreign-pointer-type
                                         :to target
                                         :bits (getf (ftd-attributes ftd)
                                                     :bits-per-word)
                                         )
                                          qq)))
      (#.encoded-type-array
       (multiple-value-bind (size qq) (%decode-uint buf q)
         (multiple-value-bind (target qqq) (%decode-type buf qq ftd)
           (let* ((type-alignment (foreign-type-alignment target))
                  (type-bits (foreign-type-bits target)))
             (values (make-foreign-array-type
                      :element-type target
                      :dimensions (list size)
                      :alignment type-alignment
                      :bits (if type-bits
                              (* (align-offset type-bits type-alignment) size)))
                     qqq)))))
      (#.encoded-type-named-type-ref
       (multiple-value-bind (name qq) (%decode-name buf q)         
         (values (if suppress-typedef-expansion
                   name
                   (%parse-foreign-type name))
                 qq)))
      (#.encoded-type-named-struct-ref
       (multiple-value-bind (name qq) (%decode-name buf q)
         (values (or (info-foreign-type-struct name)
                     (setf (info-foreign-type-struct name)
                           (make-foreign-record-type :kind :struct
                                                     :name name)))
                 qq)))
      (#.encoded-type-named-union-ref
       (multiple-value-bind (name qq) (%decode-name buf q)
         (values (or (info-foreign-type-union name)
                     (setf (info-foreign-type-union name)
                           (make-foreign-record-type :kind :union
                                                     :name name)))
                 qq)))
      (#.encoded-type-named-transparent-union-ref
       (multiple-value-bind (name qq) (%decode-name buf q)
         (let* ((already (info-foreign-type-union name)))
           (when already
             (setf (foreign-record-type-kind already) :transparent-union))
           (values (or already
                     (setf (info-foreign-type-union name)
                           (make-foreign-record-type :kind :transparent-union
                                                     :name name)))
                 qq))))
      ((#.encoded-type-anon-struct-ref
        #.encoded-type-anon-union-ref
        #.encoded-type-anon-transparent-union-ref)
       (multiple-value-bind (tag qq) (%decode-name buf q t)
         (values (load-record tag) qq))))))

(defun extract-db-type (datum ftd)
  (let* ((data (pref datum :cdb-datum.data)))
    (unless (%null-ptr-p data)
      (prog1
	  (%decode-type data 0 ftd)
	(cdb-free data)))))

(defun %load-foreign-type (cdb name ftd)
  (when cdb
    (with-cstrs ((string (string name)))
      (rletZ ((contents :cdb-datum)
              (key :cdb-datum))
        (setf (pref key :cdb-datum.size) (length (string name))
            (pref key :cdb-datum.data) string
            (pref contents :cdb-datum.data) (%null-ptr)
            (pref contents :cdb-datum.size) 0)
      (cdb-get cdb key contents)
      (let* ((type (extract-db-type contents ftd)))
	(if type
	  (%def-foreign-type (escape-foreign-name name) type ftd)))))))

(defun load-foreign-type (name &optional (ftd *target-ftd*))
  (let* ((name (unescape-foreign-name name)))
    (do-interface-dirs (d ftd)
      (let* ((type (%load-foreign-type (db-types d) name ftd)))
	(when type (return type))))))

(defun %decode-field (buf p ftd)
  (declare (type macptr buf) (fixnum p))
  (multiple-value-bind (name p) (%decode-name buf p)
    (multiple-value-bind (type p) (%decode-type buf p ftd)
      (multiple-value-bind (offset p) (%decode-uint buf p)
        (multiple-value-bind (width p) (%decode-uint buf p)
          (values (make-foreign-record-field :type type
                                             :name name
                                             :bits width
                                             :offset offset)
                  p))))))

(defun %decode-field-list (buf p ftd)
  (declare (type macptr buf) (fixnum p))
  (let* ((n nil)
         (fields nil))
    (multiple-value-setq (n p) (%decode-uint buf p))
    (dotimes (i n (values (nreverse fields) p))
      (multiple-value-bind (field q) (%decode-field buf p ftd)
        (push field fields)
        (setq p q)))))

(defun %determine-record-attributes (rtype parsed-fields &optional alt-align)
  (let* ((total-bits 0)
         (overall-alignment 1)
	 #+(and darwinppc-target ppc32-target)
	 (first-field-p t)
         (kind (foreign-record-type-kind rtype)))
    (dolist (field parsed-fields)
      (let* ((field-type (foreign-record-field-type field))
             (bits (ensure-foreign-type-bits field-type))
             (natural-alignment (foreign-type-alignment field-type))
	     (alignment (if alt-align
			  (min natural-alignment alt-align)
			  #+(and darwinppc-target ppc32-target)
			  (if first-field-p
			    (progn
			      (setq first-field-p nil)
			      natural-alignment)
			    (min 32 natural-alignment))
			  #-(and darwinppc-target ppc32-target)
			  natural-alignment)))
        (unless bits
          (error "Unknown size: ~S"
                 (unparse-foreign-type field-type)))
        (unless alignment
          (error "Unknown alignment: ~S"
                 (unparse-foreign-type field-type)))
        (setq overall-alignment (max overall-alignment (if (= alignment 1) 32 alignment)))
        (ecase kind
          (:struct (let* ((imported-offset (foreign-record-field-offset field))
                          (offset (or imported-offset (align-offset total-bits alignment))))
                     (unless imported-offset
                       (setf (foreign-record-field-offset field) offset))
                     (setq total-bits (+ offset bits))))
          ((:union :transparent-union) (setq total-bits (max total-bits bits))))))
    (setf (foreign-record-type-fields rtype) parsed-fields
          (foreign-record-type-alignment rtype) (or
						 alt-align
						 overall-alignment)
          (foreign-record-type-bits rtype) (align-offset
					    total-bits
					    (or alt-align overall-alignment))
	  (foreign-record-type-alt-align rtype) alt-align)
    rtype))

(defun %decode-record-type (buf p ftd already)
  (declare (type macptr buf) (fixnum p))
  (let* ((rbyte (%get-unsigned-byte buf p))
	 (rcode (ldb encoded-type-type-byte rbyte))
	 (ralign-in-bytes (ldb encoded-type-align-byte rbyte))
	 (alt-align (unless (zerop ralign-in-bytes)
		      (the fixnum (ash ralign-in-bytes 3)))))
    (declare (fixnum rbyte rcode ralign-in-bytes))
    (multiple-value-bind (name q)
        (case rcode
          ((#.encoded-type-anon-struct-ref
            #.encoded-type-anon-union-ref
            #.encoded-type-anon-transparent-union-ref)
           (values nil (1+ p)))
          (t
           (%decode-name buf (1+ p))))
      (%determine-record-attributes
       (or already
           (if name
             (if (eql rcode encoded-type-named-struct-ref)
               (or (info-foreign-type-struct name)
                   (setf (info-foreign-type-struct name)
                         (make-foreign-record-type :kind :struct :name name)))
               (or (info-foreign-type-union name)
                   (setf (info-foreign-type-union name)
                         (make-foreign-record-type :kind
                                                   (if (eql rcode encoded-type-named-union-ref)
                                                     :union
                                                     :transparent-union)
                                                   :name name))))
             (make-foreign-record-type
              :kind (if (eql rcode encoded-type-anon-struct-ref)
                      :struct
                      (if (eql rcode encoded-type-anon-union-ref)
                        :union
                        :transparent-union))
              :name name)))
       (%decode-field-list buf q ftd)
       alt-align))))

(defun extract-db-record (datum ftd already)
  (let* ((data (pref datum :cdb-datum.data)))
    (unless (%null-ptr-p data)
      (prog1
	  (%decode-record-type data 0 ftd already)
	(cdb-free data)))))


(defun %load-foreign-record (cdb name ftd already)
  (when cdb
    (with-cstrs ((string (string name)))
      (rlet ((contents :cdb-datum)
             (key :cdb-datum))
        (setf (pref key :cdb-datum.size) (length (string name))
              (pref key :cdb-datum.data) string
              (pref contents :cdb-datum.data) (%null-ptr)
              (pref contents :cdb-datum.size) 0)
        (cdb-get cdb key contents)
        (extract-db-record contents ftd already)))))

(defun load-record (name &optional (ftd *target-ftd*))
  ;; Try to destructively modify any info we already have.  Use the
  ;; "escaped" name (keyword) for the lookup here.
  (let* ((already (or (info-foreign-type-struct name ftd)
                      (info-foreign-type-union name ftd)))
         (name (unescape-foreign-name name)))
    (do-interface-dirs (d ftd)
      (let* ((r (%load-foreign-record (db-records d) name ftd already)))
	(when r (return r))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/db-io.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/defstruct-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; defstruct-lds.lisp

(in-package "CCL")

(eval-when (eval compile)
  (require 'defstruct-macros)
)




(defun uvector-subtype-p (thing subtype-number)
  (= (the fixnum (typecode thing)) subtype-number))

(defun uvector (subtype &rest p)
  (declare (dynamic-extent p))
  (let ((n (length p)) (uv))
    (setq uv  (%alloc-misc n subtype))
    (dotimes (i (the fixnum n)) (declare (fixnum i)) (uvset uv i (pop p)))
    uv))

;(defmacro test (&rest args) `(macroexpand-1 (defstruct ,@args)))

;--> To do: compiler transform for copier, possibly constructor.
(defmacro defstruct (options &rest slots &environment env)
  "DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}
   Define the structure type Name. Instances are created by MAKE-<name>, 
   which takes &KEY arguments allowing initial slot values to the specified.
   A SETF'able function <name>-<slot> is defined for each slot to read and
   write slot values. <name>-p is a type predicate.

   Popular DEFSTRUCT options (see manual for others):

   (:CONSTRUCTOR Name)
   (:PREDICATE Name)
       Specify the name for the constructor or predicate.

   (:CONSTRUCTOR Name Lambda-List)
       Specify the name and arguments for a BOA constructor
       (which is more efficient when keyword syntax isn't necessary.)

   (:INCLUDE Supertype Slot-Spec*)
       Make this type a subtype of the structure type Supertype. The optional
       Slot-Specs override inherited slot options.

   Slot options:

   :TYPE Type-Spec
       Asserts that the value of this slot is always of the specified type.

   :READ-ONLY {T | NIL}
       If true, no setter function is defined for this slot."
  ;There's too much state to keep around here to break it up into little
  ;functions, so what the hell, let's do it all inline...
  (prog (struct-name type conc-name constructors copier predicate include
         print-function print-object  named initial-offset boa-constructors print-p
         documentation (slot-list ()) (offset 0) superclasses sd
         refnames)
    ;Parse options
    (if (atom options)
      (setq struct-name options options ())
      (setq struct-name (pop options)))
    (unless (symbolp struct-name) (signal-program-error $XNotSym struct-name))
    (let (name args no-constructors-p predicate-p)
      (while options
        (if (atom (car options))
          (setq name (%car options) args ())
          (setq name (%caar options) args (%cdar options)))
        (case name
          (:conc-name
           (when conc-name (go dup-options))
           (when (cdr args) (go bad-options))
           (setq conc-name (or args (list nil))))
          (:constructor
           (when (cddr args) (go bad-options))
           (cond ((cdr args) (push args boa-constructors))
		 ((null args)
		  (push (concat-pnames "MAKE-" struct-name) constructors))
		 ((eq (%car args) nil)
		  (setq no-constructors-p t))
                 (t (unless (symbolp (%car args)) (go bad-options))
		    (push (%car args) constructors))))
          (:copier
           (when copier (go dup-options))
           (when (or (cdr args) (not (symbolp (%car args)))) (go bad-options))
           (setq copier args))
          (:predicate
           (when predicate (go dup-options))
           (when (or (cdr args) (not (symbolp (%car args)))) (go bad-options))
           (setq predicate-p t predicate args))
          (:include
           (when include (go dup-options))
           (when (or (null args) (not (symbolp (car args)))) (go bad-options))
           (setq include args))
          ((:print-function :print-object)
           (when print-function (go dup-options))
           (when (or (cdr args)
                     (not (or (symbolp (%car args))
                              (and (consp (%car args)) (eq (%caar args) 'lambda)))))
             (go bad-options))
           (setq print-p t
		 print-function (%car args)
		 print-object (eq name :print-object)))
          (:type
           (when type (go dup-options))
           (when (cdr args) (go bad-options))
           (unless (eq (setq type (%car args)) 'list)
             (when (eq type 'vector) (setq type '(vector t)))
             (when (or (atom type) (neq (%car type) 'vector) (cdr (%cdr type)))
               (go bad-options))))
          (:named
           (when args (go bad-options))
           (setq named t))
          (:initial-offset
           (when initial-offset (go dup-options))
           (when (or (cdr args) (not (fixnump (%car args))) (%i< (%car args) 0))
             (go bad-options))
           (setq initial-offset (%car args)))
          (t (go bad-options)))
        (setq options (%cdr options)))
      ;Options parsed!  Do defaulting and some consistency checking.
      (cond (type
             (when (null (defstruct-reftype type)) ;e.g. (vector NIL)
               (bad-named-arg :type type))
             (when print-p
               (error "Cannot specify ~S with ~S" :print-function :type))
             (if (and named (consp type) (eq (car type) 'vector)
                      (cadr type) (not (subtypep 'symbol (cadr type))))
               (error "Cannot specify ~S with type: ~S" :named type))
             )
            ((built-in-type-p struct-name)
             (error "Cannot redefine built-in type ~S" struct-name))
            (initial-offset
             (error "Cannot use ~S without ~S" :initial-offset :type))
            (t (setq named t)))
      (if (not named)
        (when predicate-p
          (unless (null (setq predicate (%car predicate)))
            (error "Cannot specify :PREDICATE for an unnamed structure")))
        (setq predicate (if (null predicate)
                          (concat-pnames struct-name "-P")
                          (%car predicate))))
      (setq conc-name
            (if (null conc-name) (%str-cat (symbol-name struct-name) "-")
                (if (%car conc-name) (string (%car conc-name)))))
      (when (and no-constructors-p
		 (or constructors boa-constructors))
	(error "~s combined with other ~s options"
	       '(:constructor nil) :constructor))
      (unless no-constructors-p
	(unless (or boa-constructors constructors)
	  (push (concat-pnames "MAKE-" struct-name) constructors)))
      (setq copier
            (if (null copier) (concat-pnames "COPY-" struct-name) (%car copier))))
    ;Process included slots
    (when include
      (let* ((included-name (%car include))
             (sub-sd (or (let* ((defenv (definition-environment env)))
                          (when defenv (%cdr (assq included-name (defenv.structures defenv)))))
                         (gethash included-name %defstructs%)))
            (slots (%cdr include))
            name args ssd)
        (unless sub-sd (error "No such structure: ~S" (cons :include include)))
        (unless (eq (defstruct-reftype type)
                    (defstruct-reftype (sd-type sub-sd)))
          (error "Incompatible structure type ~S for ~S"
                 (sd-type sub-sd) (cons :include include)))
        (dolist (ssd (sd-slots sub-sd)) (push
					 (let* ((new-ssd (copy-ssd ssd)))
					   (ssd-set-inherited new-ssd)
					   new-ssd)
					   slot-list))
        (while slots
          (if (atom (car slots))
            (setq name (%car slots) args ())
            (setq name (%caar slots) args (%cdar slots)))
          (unless (symbolp name) (signal-program-error $XNotSym name))
          (unless (setq ssd (named-ssd name slot-list))
            (error "~S has no ~S slot, in ~S"
                   (sd-name sub-sd) name (cons :include include)))
          (ssd-set-initform ssd (pop args))
          (while args
            (when (atom (cdr args)) (signal-program-error "~S is not a proper list" (cdr args)))
            (cond ((eq (%car args) :type) )
                  ((eq (%car args) :read-only)
                   (when (and (not (%cadr args)) (ssd-r/o ssd))
                     (signal-program-error "Slot ~S in ~S must be read-only" name (sd-name sub-sd)))
                   (when (%cadr args) (ssd-set-r/o ssd)))
                  (t (signal-program-error "~S must be  (member :type :read-only)." (%car args))))
            (setq args (%cddr args)))
          (setq slots (%cdr slots)))
        (setq offset (sd-size sub-sd))
        (setq superclasses (sd-superclasses sub-sd))))
    (push struct-name superclasses)
    ;Now add own slots
    (setq offset (%i+ offset (or initial-offset 0)))
    (when (and named (or type (not include)))
      (push (make-ssd 0 (if type `',struct-name `',superclasses) offset t) slot-list)
      (setq named offset offset (%i+ offset 1)))
    (when (stringp (%car slots))
      (setq documentation (%car slots) slots (%cdr slots)))
    (let (name args read-only initform slot-type)
      (while slots
         (if (atom (%car slots))
           (setq name (%car slots) args ())
           (setq name (%caar slots) args (%cdar slots)))
         (unless (symbolp name) (go bad-slot))
         (setq read-only nil initform (pop args) slot-type t)
         (while args
            (when (atom (cdr args)) (go bad-slot))
            ;; To do: check for multiple/incompatible options.
            (cond ((eq (%car args) :type)
                   (setq slot-type (%cadr args)))
                  ((eq (%car args) :read-only)
                   (setq read-only (%cadr args)))
                  (t (go bad-slot)))
            (setq args (%cddr args)))
         (specifier-type slot-type env) ;; Check for validity (signals program error)
         (push (make-ssd name initform offset read-only slot-type) slot-list)
         (setq slots (%cdr slots) offset (%i+ offset 1))))
    (setq slot-list (nreverse slot-list))
    (when (and (null type) include)
      (ssd-set-initform (car slot-list) `',superclasses))
    (progn ;when conc-name
      (dolist (slot slot-list)
        (unless (fixnump (ssd-name slot))
          (push (if conc-name
                  (concat-pnames conc-name (ssd-name slot))
                  (ssd-name slot))
                refnames)))
      (setq refnames (nreverse refnames)))
    (setq sd (vector type slot-list superclasses offset (car constructors) () refnames))
    (return
     `(progn
	,@(when (null (sd-type sd))
		`((when (memq ',struct-name *nx-known-declarations*)
		    (check-declaration-redefinition ',struct-name 'defstruct))))
       (remove-structure-defs  ',struct-name) ; lose any previous defs
        ,.(defstruct-slot-defs sd refnames env)
        (eval-when (:compile-toplevel)
          (define-compile-time-structure 
            ',sd 
            ',refnames 
            ,(if (and predicate (null (sd-type sd))) `',predicate)
            ,env))        
        (%defstruct-do-load-time
         ',sd
         ,(if (and predicate (null (sd-type sd))) `',predicate)
         ,.(if documentation (list documentation)))
        ,.(if copier (defstruct-copier sd copier env))
        ,.(if predicate (defstruct-predicate sd named predicate env))
        ,.(%defstruct-compile sd refnames env)
        ,.(defstruct-boa-constructors sd boa-constructors env)
	,.(defstruct-constructors sd constructors env)
       ;; Wait until slot accessors are defined, to avoid
       ;; undefined function warnings in the print function/method.
       (%defstruct-set-print-function
	',sd
	,(if print-function
	  (if (symbolp print-function)
	    `',print-function
	    `#',print-function)
	  (unless print-p (if include 0)))
	,print-object)
        ',struct-name))

    dup-options
     (error "Duplicate ~S options not allowed" (%car options))
    bad-options
     (signal-program-error "Bad defstruct option ~S." (%car options))
    bad-slot
    (signal-program-error "Bad defstruct slot spec ~S." (%car slots))))

(defun concat-pnames (name1 name2)
  (intern (%str-cat (string name1) (string name2))))

(defun wrap-with-typecheck (value slot env)
  (let ((slot-type (defstruct-type-for-typecheck (ssd-type slot) env)))
    (if (eq t slot-type)
      value
      `(typecheck ,value ,slot-type))))

(defun make-class-cells-list (class-names)
  (if (and (consp class-names)
           (eq (car class-names) 'quote)
           (consp (cdr class-names))
           (null (cddr class-names))
           (listp (cadr class-names))
           (every #'symbolp (cadr class-names)))
    `',(mapcar (lambda (name) (find-class-cell name t)) (cadr class-names))
    class-names))

(defun defstruct-constructors (sd constructors env &aux (list ()))
  (dolist (c constructors list)
    (push (defstruct-constructor sd c env) list)))

(defun defstruct-constructor (sd constructor env &aux (offset 0)
                                                      (args ())
                                                      (values ())
                                                      slot-offset
                                                      name)
  (dolist (slot (sd-slots sd))
    (setq slot-offset (ssd-offset slot))
    #-bccl (when (%i< slot-offset offset)
             (error "slots out of order! ~S" (sd-slots sd)))
    (while (%i< offset slot-offset)
      (push nil values)
      (setq offset (%i+ offset 1)))
    (if (fixnump (setq name (ssd-name slot)))
      (if (eql 0 name)
        (push (make-class-cells-list (ssd-initform slot)) values) 
        (push (wrap-with-typecheck (ssd-initform slot) slot env) values))
      (let* ((temp (make-symbol (symbol-name name))))
        (push (list (list (make-keyword name) temp) (ssd-initform slot)) args)
        (push (wrap-with-typecheck temp slot env) values)))
    (setq offset (%i+ offset 1)))
  (setq values (nreverse values))
  `(defun ,constructor (&key ,@(nreverse args))
     ,(case (setq name (defstruct-reftype (sd-type sd)))
          (#.$defstruct-nth `(list ,@values))
          (#.target::subtag-simple-vector `(vector ,@values))
          ((#.target::subtag-struct #.$defstruct-struct)
           `(gvector :struct ,@values))
          (t `(uvector ,name ,@values)))))

(defun defstruct-boa-constructors (sd boas env &aux (list ()))
  (dolist (boa boas list)
    (push (defstruct-boa-constructor sd boa env) list)))

(defun defstruct-boa-constructor (sd boa env &aux (args ())
                                     (used-slots ())
                                     (values ())
                                     (offset 0)
				     (auxen ())
                                     arg-kind slot slot-offset)
  (unless (verify-lambda-list (cadr boa))
    (error "Invalid lambda-list in ~S ." (cons :constructor boa)))
  (dolist (arg (cadr boa))
    (cond ((memq arg lambda-list-keywords)
           (setq arg-kind arg))
          ((setq slot (named-ssd arg (sd-slots sd)))
           (when (or (eq arg-kind '&optional) (eq arg-kind '&key)
                     ;; for &aux variables, init value is
                     ;; implementation-defined, however it's not
                     ;; supposed to signal a type error until slot is
                     ;; assigned, so might as well just use the
                     ;; initform.
                     (eq arg-kind '&aux))
             (setq arg (list arg (ssd-initform slot)))
	     (when (eq arg-kind '&aux)
	       (push slot auxen)))
           (push slot used-slots))
          ((and (consp arg) (setq slot (named-ssd (if (consp (%car arg)) (%cadar arg) (%car arg)) (sd-slots sd))))
	   (when (eq arg-kind '&aux)
	     (push slot auxen))
           (push slot used-slots))
          (t nil))
    (push arg args))
  (dolist (slot (sd-slots sd))
    (setq slot-offset (ssd-offset slot))
    (when (%i< slot-offset offset) (error "slots out of order! ~S" sd))
    (while (%i< offset slot-offset)
      (push nil values)
      (setq offset (%i+ offset 1)))
    (push (if (memq slot used-slots)
	    (ssd-name slot)
	    (if (eql 0 (ssd-name slot))
              (make-class-cells-list (ssd-initform slot))
              (if (constantp (ssd-initform slot)) (ssd-initform slot)
		  (progn
		    (unless (eq arg-kind '&aux)
		      (push (setq arg-kind '&aux) args))
		    (push (list (ssd-name slot) (ssd-initform slot)) args)
		    (ssd-name slot)))))
          values)
    (setq offset (%i+ offset 1)))
  (setq values (mapcar (lambda (v s) (if (memq s auxen)
				       v
				       (wrap-with-typecheck v s env)))
		       (nreverse values) (sd-slots sd)))
  `(defun ,(car boa) ,(nreverse args)
     ,(case (setq slot (defstruct-reftype (sd-type sd)))
        (#.$defstruct-nth `(list ,@values))
        (#.target::subtag-simple-vector `(vector ,@values))
        ((#.target::subtag-struct #.$defstruct-struct)
         `(gvector :struct ,@values))
        (t `(uvector ,slot ,@values)))))

(defun defstruct-copier (sd copier env)
  (let* ((sd-name (sd-name sd))
         (sd-type (sd-type sd))
         (var (defstruct-var sd-name env))
         (arg (if sd-type var `(typecheck ,var ,sd-name)))
         (fn (if (eq sd-type 'list) 'copy-list 'copy-uvector)))
    `((defun ,copier (,var) (,fn ,arg)))))

(defun defstruct-predicate (sd named predicate env)
  (declare (ignore env))
  (let* ((arg (gensym))
         (sd-name (sd-name sd))
         (body
          (case (sd-type sd)
            ((nil) `(structure-typep ,arg ',(find-class-cell sd-name t)))
            ((list) `(and (consp ,arg) (eq (nth ,named ,arg) ',sd-name)))
            (t `(and (uvector-subtype-p ,arg ,(defstruct-reftype (sd-type sd)))
               (< ,named (uvsize ,arg))
               (eq (uvref ,arg ,named) ',sd-name))))))
    `((defun ,predicate (,arg) ,body))))

; End of defstruct-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/defstruct-lds.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/describe.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;; -*- Mode:Lisp; Package:INSPECTOR -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(defpackage "INSPECTOR"
  (:use "CL" "CCL")
  (:export "MAKE-INSPECTOR"
           "COMPUTE-LINE-COUNT"
           "LINE-N"
           "INSPECTOR-OBJECT"
           "INSPECTOR-LINE-COUNT"

           "*INSPECTOR-DISASSEMBLY*"))



(in-package "INSPECTOR")

(defvar ccl::@ nil)
(defvar ccl::@@ nil)
(defvar ccl::@@@ nil)

;;; The basic inspector object.
;;; Note that this knows nothing about windows.
;;; It merely knows how to number the constituent parts of an object,
;;; How to access a constituent, and how to print a constituent to a stream.
(defclass inspector ()
  ((object :accessor inspector-object :initarg :object)
   (line-count :accessor inspector-line-count :initarg :line-count :initform nil)
   ;; so can refresh.
   (initargs :reader inspector-initargs :initform nil)))

(defmethod initialize-instance :before ((i inspector) &rest initargs)
  (setf (slot-value i 'initargs) initargs))

;;; The usual way to cons up an inspector
(defmethod make-inspector (object)
  (multiple-value-bind (class alias) (inspector-class object)
    (make-instance class :object (or alias object))))

(defmethod initialize-instance :after ((i inspector) &key update-line-count)
  (when update-line-count
    (update-line-count i)))

(defmethod refresh-inspector ((i inspector))
  (apply #'make-instance (class-of i) (slot-value i 'initargs)))

;; New protocol, used by gui inspector instead of the line-n protocol, which isn't quite right.
;; Perhaps tty inspector should use it as well.  Returns the line inspector rather than object,
;; and returns the value string rather than having the caller print it.
(defmethod inspector-line ((i inspector) index)
  (let ((line-i (multiple-value-bind (value label type) (inspector::line-n i index)
		  (and (not (eq (parse-type i type) :comment))
		       (line-n-inspector i index value label type)))))
    (multiple-value-bind (label-string value-string) (line-n-strings i index)
      (values line-i label-string value-string))))

(defmethod inspector-object-string ((i inspector))
  (let ((ob (inspector-object i))
	(*print-readably* nil)
        (*signal-printing-errors* nil)
        (*print-circle* t)
        (*print-length* 20)
        (*print-pretty* nil))
    (prin1-to-string ob)))

;; for a comment value = nil, label = "the comment" type = :comment
;;; => line-i = nil

;;;;;;;
;;;
;;; The protocol for an inspector.
;;; Change these to defgeneric's when it exists.
;;;
;;; Usually, you need to define methods only for
;;; inspector-class, compute-line-count, line-n, and (setf line-n)

;;; Return the type of inspector for an object
(defmethod inspector-class (object)
  (cond ((or (method-exists-p #'line-n object 0)
             (method-exists-p #'inspector-line 0))
         'usual-inspector)
        ((and (uvectorp object)
              (find-class 'uvector-inspector nil))
         'uvector-inspector)
        (t 'basic-inspector)))

;;; Return three values: the value, label, and type of the nth line of the object
;;; Valid types are:
;;;  :NORMAL or NIL  - a normal constituent line: changeable
;;;  :COLON          - a normal line with ": " between the label and the value
;;;  :COMMENT        - a commentary line - Print only the label
;;;  :STATIC         - a commentary line with an inspectable value: not changeable
(defmethod line-n ((i inspector) n)
  (declare (ignore n)))

; set the value of line n of the object (the label is fixed)
(defmethod (setf line-n) (value (i inspector) n)
  (declare (ignore value n)))

; Compute the number of lines in the object
(defmethod compute-line-count ((i inspector))
  0
  )

; Compute the number of lines in the object and set the line-count slot
; If the length is greater than the limit, return (list limit)
(defun update-line-count (inspector)
  (setf (inspector-line-count inspector) (compute-line-count inspector)))

; Print the nth line to a stream
(defmethod prin1-line-n ((i inspector) stream n)
  (multiple-value-call #'prin1-line i stream (line-n i n)))

(defmethod prin1-line ((i inspector) stream value &optional label type function)
  (unless function
    (setq function (inspector-print-function i type)))
  (funcall function i stream value label type))

(defvar *collect-labels-if-list* t)

(defmethod end-of-label ((stream string-output-stream))
  (when (listp *collect-labels-if-list*)
    (push (get-output-stream-string stream) *collect-labels-if-list*)))

(defmethod line-n-strings ((i inspector) n)
  (let* ((*collect-labels-if-list* ())
	 (value-string (with-output-to-string (stream)
			 (prin1-line-n i stream n)))
	 (label-string (pop *collect-labels-if-list*))
         (end (or (position-if-not #'whitespacep label-string :from-end t) -1)))
    (assert (null *collect-labels-if-list*))
    (unless (and (>= end 0) (eql (char label-string end) #\:)) (incf end))
    (setq label-string (subseq label-string 0 end))
    (values label-string value-string)))

(defmethod inspector-print-function ((i inspector) type)
  (declare (ignore type))
  'prin1-normal-line)

; Print a value to a stream.
(defmethod prin1-normal-line ((i inspector) stream value &optional label type
                              colon-p)
  (let* ((type-sym (parse-type i type)))
    (if (eq type-sym :colon) (setq colon-p t))
    (when label
      (prin1-label i stream value label type)
      (if colon-p (princ ": " stream)))
    (end-of-label stream)              ; used by cacheing code
    (unless (eq type-sym :comment)
      (prin1-value i stream value label type))))

(defun prin1-colon-line (i stream value &optional label type)
  (prin1-normal-line i stream value label type t))

(defmethod prin1-label ((i inspector) stream value &optional label type)
  (declare (ignore value type))
  (if (stringp label)
    (write-string label stream)
    (princ label stream)))

(defmethod prin1-value ((i inspector) stream value &optional label type)
  (declare (ignore label type))
  (prin1 value stream))

;;; Call function on the inspector object and its value, label, & type, for
;;; each line in the selected range (default to the whole thing).
;;; This can avoid (e.g.) doing NTH for each element of a list.
;;; This is the generic-function which the inspector-window uses to
;;; display a screenful.
(defmethod map-lines ((i inspector) function &optional 
                      (start 0) 
                      end)
  (when (null (inspector-line-count i))
    (update-line-count i))
  (unless end
    (setq end (inspector-line-count i)))
  (when (and start end)
    (let ((index start))
      (dotimes (c (- end start))
        (multiple-value-call function i index (inspector-line i index))
        (incf index)))))

;;;;;;;
;;;
;;; Dealing with unbound slots and bogus objects
;;;
(defclass unbound-marker () ())

(defvar *unbound-marker* (make-instance 'unbound-marker))
(defvar *slot-unbound-marker* (make-instance 'unbound-marker))

(defmethod print-object ((x unbound-marker) stream)
  (print-object (ccl::%unbound-marker) stream))

(defclass bogus-object-wrapper ()
  ((address :initarg :address)))

(defmethod print-object ((x bogus-object-wrapper) stream)
  (print-unreadable-object (x stream)
    (format stream "BOGUS object @ #x~x" (slot-value x 'address))))

(defvar *bogus-object-hash*
  (make-hash-table :test 'eql :weak :value :size 0))

(defun bogus-object-wrapper (x)
  (let ((address (%address-of x)))
    (or (gethash address *bogus-object-hash*)
        (setf (gethash address *bogus-object-hash*)
              (make-instance 'bogus-object-wrapper :address address)))))

(defun eliminate-unbound (x)
  (cond ((eq x (ccl::%unbound-marker))
         *unbound-marker*)
        ((eq x (ccl::%slot-unbound-marker))
         *slot-unbound-marker*)
        ((ccl::bogus-thing-p x)
         (bogus-object-wrapper x))
        (t x)))

(defun restore-unbound (x)
  (if (eq x *unbound-marker*)
    (ccl::%unbound-marker)
    (if (eq x *slot-unbound-marker*)
      (ccl::%slot-unbound-marker)
      x)))

(defmethod line-n :around ((i inspector) n)
  (declare (ignore n))
  (let ((res (multiple-value-list (call-next-method))))
    (declare (dynamic-extent res))
    (apply #'values (eliminate-unbound (car res)) (cdr res))))

(defmethod (setf line-n) :around (new-value (i inspector) n)
  (call-next-method (restore-unbound new-value) i n))


;;;;;;;
;;;
;;; describe-object
;;; Eventually, this wants to reuse a global inspector rather than
;;; consing one.
(defparameter *describe-pretty* t)

(defmacro with-errorfree-printing (&body body)
  `(let ((*print-readably* nil)
         (*signal-printing-errors* nil))
     ,@body))

(defun format-line-for-tty (stream label-string value-string)
  (when (equal label-string "") (setq label-string nil))
  (when (equal value-string "") (setq value-string nil))
  (format stream "~@[~a~]~@[~a~]~@[~a~]"
	  label-string
	  (and label-string
	       value-string 
	       (not (eql #\space (char label-string (1- (length label-string)))))
	       ": ")
	  value-string))

(defun describe (object &optional stream)
  "Print a description of the object X."
  (cond ((null stream) (setq stream *standard-output*))
        ((eq stream t) (setq stream *terminal-io*)))
  (setq stream (require-type stream 'stream))
  (let* ((*print-circle* t)
         (*print-length* 20))
    (describe-object object stream)
    (values)))

(defmethod describe-object (object stream)
  (let ((inspector (make-inspector object)))
    (with-errorfree-printing
        (let* ((*print-pretty* (or *print-pretty* *describe-pretty*))
               (temp #'(lambda (i index child &optional label-string value-string)
			 (declare (ignore i index child))
			 (format-line-for-tty stream label-string value-string)
			 (terpri stream))))
          (declare (dynamic-extent temp))
          (map-lines inspector temp))))
  (values))

;;; usual-inspector
;;; Objects that know how to inspect themselves but don't need any
;;; special info other than the object can be a usual-inspector.
;;; This class exists mostly to save consing a class for every type
;;; of object in the world.
(defclass usual-inspector (inspector)
  ())

;;;;;;;
;;
;; formatting-inspector
;; This one prints using a format string.
;; Expects line-n to return (values value label type format-string)

(defclass formatting-inspector (inspector) ())
(defclass usual-formatting-inspector (usual-inspector formatting-inspector) ())

(defmethod prin1-line ((i formatting-inspector) stream value
                       &optional label type (format-string "~s"))
  (funcall (if (listp format-string) #'apply #'funcall)
           #'format-normal-line i stream value label type format-string))

(defmethod format-normal-line ((i inspector) stream value &optional 
                               label type (format-string "~s") colon-p)
  (let* ((type-sym (parse-type i type)))
    (if (eq type-sym :colon) (setq colon-p t))
    (when label
      (prin1-label i stream value label type)
      (if colon-p (princ ": " stream)))
    (end-of-label stream)              ; used by cacheing code
    (unless (eq type-sym :comment)
      (format stream format-string value))))

;;;;;;;
;;
;; inspectors for CCL objects
;;


(defmethod parse-type ((i inspector) type &optional default1 default2)
  (declare (ignore default1 default2))
  (values (if (consp type) (car type) type)))

;;; Used by the cache-entry-stream class to save the column where the label ends.
(defmethod end-of-label (stream)
  (declare (ignore stream)))



;;;;;
;;
;; The default inspector class
;; Used when we don't know what else to do
;;

(defclass basic-inspector (inspector) ())

(defmethod compute-line-count ((i basic-inspector))
  3)                                    ; type, class, value

(defun line-n-out-of-range (i n)
  (error "~s is not a valid index for line-n of ~s" n i))

(defun setf-line-n-out-of-range (i n)
  (error "~s is not a valid index for setf-line-n of ~s" n i))

(defmethod line-n ((i basic-inspector) n)
  (let ((object (inspector-object i)))
    (case n
      (0 (values object nil :static))
      (1 (values (type-of object) "Type: " :static))
      (2 (values (class-of object) "Class: " :static))
      (t (line-n-out-of-range i n)))))

;;;;;;;
;;
;; Automate the object being the first line
;;
(defclass object-first-mixin () ())
(defclass object-first-inspector (object-first-mixin inspector) ())

(defmethod compute-line-count :around ((i object-first-mixin))
  (1+ (call-next-method)))

(defmethod line-n :around ((i object-first-mixin) n)
  (if (eql 0 n)
    (values (inspector-object i) nil)
    (call-next-method i (1- n))))

(defmethod (setf line-n) :around (value (i object-first-mixin) n)
  (if (eql n 0)
    (replace-object i value)
    (call-next-method value i (1- n))))

(defun replace-object (inspector new-object)
  (declare (ignore inspector))
  (make-inspector new-object))


; A mixin that displays the object, its type, and its class as the first three lines.
(defclass basics-first-mixin () ())

(defmethod compute-line-count :around ((i basics-first-mixin))
  (+ 3 (call-next-method)))

(defmethod line-n :around ((i basics-first-mixin) n)
  (let ((object (inspector-object i)))
    (case n
      (0 (values object nil))
      (1 (values (type-of object) "Type: " :static))
      (2 (values (class-of object) "Class: " :static))
      (t (call-next-method i (- n 3))))))

(defmethod line-n-inspector :around ((i basics-first-mixin) n value label type)
  (if (< n 3)
    (make-inspector value)
    (call-next-method i (- n 3) value label type)))

(defmethod (setf line-n) :around (new-value (i basics-first-mixin) n)
  (case n
    (0 (replace-object i new-value))
    ((1 2) (setf-line-n-out-of-range i n))
    (t (call-next-method new-value i (- n 3)))))

;;;;;;;
;;
(defclass usual-object-first-inspector (object-first-mixin usual-inspector)
  ())
(defclass usual-basics-first-inspector (basics-first-mixin usual-inspector)
  ())

(defvar *inspector*)

(defmethod compute-line-count ((i usual-inspector))
  (let ((*inspector* i))
    (compute-line-count (inspector-object i))))

(defmethod line-n ((i usual-inspector) n)
  (let ((*inspector* i))
    (line-n (inspector-object i) n)))

(defmethod (setf line-n) (value (i usual-inspector) n)
  (let ((*inspector* i))
    (setf (line-n (inspector-object i) n) value)))

(defmethod inspector-commands ((i usual-inspector))
  (let ((*inspector* i))
    (inspector-commands (inspector-object i))))

(defmethod inspector-commands (random)
  (declare (ignore random))
  nil)

;;;;;;;
;;
;; Bogus objects
;;

(defclass bogus-object-inspector (object-first-inspector)
  ())

(defmethod compute-line-count ((i bogus-object-inspector))
  3)

(defmethod line-n ((i bogus-object-inspector) n)
  (values
   nil
   (case n
     (0 "One cause of a bogus object is when a stack consed object is stored")
     (1 "in a register and then control exits the dynamic-extent of the object.")
     (2 "The compiler doesn't bother to clear the register since it won't be used again."))
   '(:comment :plain :plain)))

(defmethod inspector-class :around (object)
  (if (ccl::bogus-thing-p object)
    'bogus-object-inspector
    (call-next-method)))

;;;;;;;
;;
;; A general sequence inspector
;;
(defclass sequence-inspector (inspector)
  ((print-function :initarg :print-function :initform #'prin1 :reader print-function)
   (commands :initarg :commands :initform nil :accessor inspector-commands)
   (line-n-inspector :initform nil :initarg :line-n-inspector
                     :accessor line-n-inspector-function)
   (replace-object-p :initform nil :initarg :replace-object-p
                     :reader replace-object-p)
   (resample-function :initform nil :initarg :resample-function
                      :reader resample-function)
   (line-n-function :initform nil :initarg :line-n-function
                    :reader line-n-function)
   (setf-line-n-p :initform t :initarg :setf-line-n-p
                  :reader setf-line-n-p))
  (:default-initargs :update-line-count t))



(defmethod compute-line-count ((i sequence-inspector))
  (let ((resample-function (resample-function i)))
    (when resample-function
      (setf (inspector-object i) (funcall resample-function i))))
  (length (inspector-object i)))

(defmethod line-n ((i sequence-inspector) n)
  (let ((f (line-n-function i)))
    (if f
      (funcall f i n)
      (values (elt (inspector-object i) n) nil (unless (setf-line-n-p i) :static)))))

(defmethod (setf line-n) (new-value (i sequence-inspector) n)
  (if (setf-line-n-p i)
    (setf (elt (inspector-object i) n) new-value)
    (setf-line-n-out-of-range i n)))

(defmethod prin1-value ((inspector sequence-inspector) stream value
                        &optional label type)
  (declare (ignore label type))
  (funcall (print-function inspector) value stream))

(defmethod line-n-inspector ((i sequence-inspector) n value label type)
  (let ((f (line-n-inspector-function i)))
    (or (and f (funcall f i n value label type)) (call-next-method))))

;;;;;;;
;;
;; standard-object
;; This should be redone to use the exported class query functions
;; (as soon as they exist)
;;
(defclass standard-object-inspector (object-first-inspector)
  ())

(defmethod inspector-class ((o standard-object))
  'standard-object-inspector)

(defmethod compute-line-count ((i standard-object-inspector))
  (standard-object-compute-line-count i))

(defun standard-object-compute-line-count (i)  
  (let* ((object (ccl::maybe-update-obsolete-instance (inspector-object i)))
         (class (class-of object))
         (all-slots (ccl::class-slots class)))
    (multiple-value-bind (instance-slots class-slots other-slots) (ccl::extract-instance-class-and-other-slotds all-slots)
      (let* ((ninstance-slots (length instance-slots))
             (nclass-slots (length class-slots))
             (nother-slots (length other-slots)))
        (+ 2                                ; class, wrapper
           (if (eql 0 ninstance-slots)
             0
             (1+ ninstance-slots))
           (if (eql 0 nclass-slots)
             0
             (1+ nclass-slots))
           (if (eql 0 nother-slots)
             0
             (1+ nother-slots))
           (if (eql 0 (+ nclass-slots ninstance-slots nother-slots))
             1
             0))))))

(defun slot-value-or-unbound (instance slot-name)
  (eliminate-unbound (ccl::slot-value-if-bound instance slot-name
					       (ccl::%slot-unbound-marker))))

(defparameter *standard-object-type* (list nil))
(defparameter *standard-object-static-type*
  (cons :static (cdr *standard-object-type*)))
(defparameter *standard-object-comment-type* 
  (list :comment))

(defmethod line-n ((i standard-object-inspector) n)
  (standard-object-line-n i n))

(defmethod prin1-label ((i standard-object-inspector) stream value &optional label type)
  (declare (ignore value type))
  (if (symbolp label)
    (prin1 label stream)
    (call-next-method)))

; Looks like
; Class:
; Wrapper:
; [Instance slots:
;  slots...]
; [Class slots:
;  slots...]
; [Other slots:
;  slots...]

(defun standard-object-line-n (i n)
  (let* ((instance (inspector-object i))
         (class (class-of instance))
         (all-slots (class-slots class))
         (wrapper (or (ccl::standard-object-p instance)
                      (if (typep instance 'ccl::funcallable-standard-object)
                        (ccl::gf.instance.class-wrapper instance))))
	 (instance-start 2))
    (if (< n instance-start)
      (if (eql n 0)
	(values class "Class: " :normal)
	(values wrapper "Wrapper: " :static))
      (multiple-value-bind (instance-slotds class-slotds other-slotds)
          (ccl::extract-instance-class-and-other-slotds all-slots)
        (let* ((instance-count (length instance-slotds))
               (shared-start (+ instance-start instance-count
                                (if (eql 0 instance-count) 0 1))))
          (if (< n shared-start)
            (if (eql n instance-start)
              (values nil "Instance slots" :comment)
              (let ((slot-name (slot-definition-name
                                (elt instance-slotds (- n instance-start 1)))))
                (values (slot-value-or-unbound instance slot-name)
                        slot-name
                        :colon)))
            (let* ((shared-count (length class-slotds))
                   (shared-end (+ shared-start shared-count
                                  (if (eql shared-count 0) 0 1))))
              (if (< n shared-end)
                (if (eql n shared-start)
                  (values nil "Class slots" :comment)
                  (let ((slot-name (slot-definition-name 
                                    (elt class-slotds (- n shared-start 1)))))
                    (values (slot-value-or-unbound instance slot-name)
                            slot-name
                            :colon)))
                (let* ((other-start shared-end)
                       (other-end (+ other-start (if other-slotds (1+ (length other-slotds)) 0))))
                  (if (< n other-end)
                    (if (eql n other-start)
                      (values nil "Other slots" :comment)
                      (let ((slot-name (slot-definition-name 
                                        (elt other-slotds (- n other-start 1)))))
                        (values (slot-value-or-unbound instance slot-name)
                                slot-name
                                :colon)))
                    (if (and (eql 0 instance-count) (eql 0 shared-count) (null other-slotds) (eql n other-end))
                      (values nil "No Slots" :comment)
                      (line-n-out-of-range i n))))))))))))

(defmethod (setf line-n) (value (i standard-object-inspector) n)
  (standard-object-setf-line-n value i n))

(defun standard-object-setf-line-n (value i n)
  (let* ((instance (inspector-object i))
         (class (class-of instance))
         (instance-start 2))
    (if (< n instance-start)
      (cond
       ((eql n 0) (change-class instance value)
         (update-line-count i))
        (t (setf-line-n-out-of-range i n)))
      (let* ((slotds (ccl::extract-instance-effective-slotds class))
             (instance-count (length slotds))
             (shared-start (+ instance-start instance-count
                              (if (eql 0 instance-count) 0 1))))
        (if (< n shared-start)
          (if (eql n instance-start)
            (setf-line-n-out-of-range i n)
            (let ((slot-name (slot-definition-name
                              (elt slotds (- n instance-start 1)))))
              (setf (slot-value instance slot-name) (restore-unbound value))))
          (let* ((slotds (ccl::extract-class-effective-slotds class))
                 (shared-count (length slotds))
                 (shared-end (+ shared-start shared-count
                                (if (eql shared-count 0) 0 1))))
            (if (< n shared-end)
              (if (eql n shared-start)
                (setf-line-n-out-of-range i n)
                (let ((slot-name (slot-definition-name 
                                  (elt slotds (- n shared-start 1)))))
                  (setf (slot-value instance slot-name)
                        (restore-unbound value))))
              (setf-line-n-out-of-range i n))))))))


;;;;;;;;;;;  Inspector objects for common classes.

(defparameter *plain-comment-type* '(:comment (:plain)))
(defparameter *bold-comment-type* '(:comment (:bold)))

(defun resample-it ()
  )

;;;;;;;
;;
;; Lists
;;
(defclass cons-inspector (basics-first-mixin inspector) ())

(defclass list-inspector (basics-first-mixin inspector)
  ((length :accessor list-inspector-length)
   (dotted-p :accessor list-inspector-dotted-p)
   (nthcdr :accessor list-inspector-nthcdr)
   (n :accessor list-inspector-n)))

(defmethod inspector-class ((o list))
  (if (listp (cdr o))
    'list-inspector
    'cons-inspector))

; Same as list-length-and-final-cdr, but computes the real length of the list
(defun real-list-length (list)
  (multiple-value-bind (len final-cdr max-circ-len)
      (ccl::list-length-and-final-cdr list)
    (if (null max-circ-len)
      (values len final-cdr nil)
      (let ((middle (nthcdr max-circ-len list))
            (n 1))
        (loop (when (eq list middle) (return))
          (pop list)
          (incf n))
        (pop list)
        (loop (when (eq list middle) (return))
          (pop list)
          (incf n))
        (values nil nil n)))))        

(defmethod compute-line-count ((i list-inspector))
  (multiple-value-bind (len final-cdr circ-len) (real-list-length (inspector-object i))
    (setf (list-inspector-dotted-p i) final-cdr)
    (setf (list-inspector-nthcdr i) (inspector-object i))
    (setf (list-inspector-n i) 0)
    (+ 1                                ; regular, dotted, or circular
       1                                ; length
       (abs (setf (list-inspector-length i)
                  (or len (- circ-len))))   ; the elements
       (if final-cdr 2 0))))            ; the final-cdr and it's label

(defmethod compute-line-count ((i cons-inspector))
  2)                                    ; car & cdr

(defmethod line-n ((i list-inspector) en &aux (n en))
  (let* ((circ? (list-inspector-length i))
         (length (abs circ?)))
    (cond ((eql 0 n)
           (values nil (cond ((list-inspector-dotted-p i) "Dotted List")
                             ((< circ? 0) "Circular List")
                             (t "Normal List"))
                   *plain-comment-type*))
          ((eql 0 (decf n)) (values length "Length: "))
          ((>= (decf n) (setq length length))   ; end of dotted list
           (let ((final-cdr (list-inspector-dotted-p i)))
             (unless final-cdr (line-n-out-of-range i en))
             (if (eql n length)
               (values nil "Non-nil final cdr" *plain-comment-type*)
               (values final-cdr (- length 0.5) :colon))))
          (t (let* ((saved-n (list-inspector-n i))
                    (nthcdr (if (>= n saved-n)
                              (nthcdr (- n saved-n) (list-inspector-nthcdr i))
                              (nthcdr n (inspector-object i)))))
               (setf (list-inspector-nthcdr i) nthcdr
                     (list-inspector-n i) n)
               (values (car nthcdr) n :colon))))))

(defmethod line-n ((i cons-inspector) n)
  (let ((object (inspector-object i)))
    (ecase n
           (0 (values (car object) "Car: "))
           (1 (values (cdr object) "Cdr: ")))))

(defmethod (setf line-n) (value (i list-inspector) n)
  (when (< n 2)
    (setf-line-n-out-of-range i n))
  (decf n 2)
  (setf (elt (inspector-object i) n) value)
  (resample-it))

(defmethod (setf line-n) (value (i cons-inspector) n)
  (let ((object (inspector-object i)))
    (ecase n
           (0 (setf (car object) value))
           (1 (setf (cdr object) value))))
  (resample-it))

;;;;;;;
;;
;; General uvector's
;;
(defclass uvector-inspector (basics-first-mixin inspector)
  ((name-list :initarg :name-list :initform nil :accessor name-list)))

(defmethod uvector-name-list (object) 
  (let* ((type (type-of object))
         (names (cdr (assq type ccl::*def-accessor-types*)))
         (names-size (length names))
         res)
    (when names
      (dotimes (i (uvsize object))
        (declare (fixnum i))
        (let ((name (and (> names-size i) (aref names i))))
          (if name
            (push (if (listp name) (car name) name) res)
            (if (and (eql i 0) (typep object 'ccl::internal-structure))
              (push 'type res)
              (push i res)))))
      (nreverse res))))

(defmethod compute-line-count ((i uvector-inspector))
  (setf (name-list i) (uvector-name-list (inspector-object i)))
  (uvsize (inspector-object i)))

(defmethod line-n ((i uvector-inspector) n)
  (values (uvref (inspector-object i) n)
          (or (let ((name-list (name-list i))) (and name-list (nth n (name-list i))))
              n)
          :colon))

(defmethod (setf line-n) (new-value (i uvector-inspector) n)
  (setf (uvref (inspector-object i) n) new-value))

(defmethod inspector-commands ((i uvector-inspector))
  (let ((object (inspector-object i)))
    (if (method-exists-p #'inspector-commands object)
      (inspector-commands object))))

;;;;;;;
;;
;; Vectors & Arrays
;;
(defmethod inspector-class ((v ccl::simple-1d-array))
  'usual-basics-first-inspector)

(defmethod compute-line-count ((v ccl::simple-1d-array))
  (+ 1 (length v)))

(defmethod line-n ((v ccl::simple-1d-array) n)
  (cond ((eql 0 n) (values (length v) "Length" :static 'prin1-colon-line))
        (t (decf n 1)
           (values (aref v n) n :colon))))

(defmethod (setf line-n) (value (v ccl::simple-1d-array) n)
  (when (<= n 0)
    (setf-line-n-out-of-range v n))
  (decf n 1)
  (prog1 (setf (aref v n) value)
    (resample-it)))

(defclass array-inspector (uvector-inspector) ())

(defmethod inspector-class ((v array))
  'array-inspector)

(defmethod uvector-name-list ((a array))
  (if (eql 1 (array-rank a))
    (if (array-has-fill-pointer-p a)
      '("Fill Pointer" "Physical size" "Data vector" "Displacement" "Flags")
      '("Logical size" "Physical size" "Data vector" "Displacement" "Flags"))
    `("Rank" "Physical size" "Data vector" "Displacement" "Flags" "Dim0" "Dim1" "Dim2" "Dim3")))

(defmethod compute-line-count ((i array-inspector))
  (let* ((a (inspector-object i))
         (rank (array-rank a)))
    (call-next-method)                  ; calculate name list
    (+ (if (eql rank 1) (1+ (uvsize a))  7)
       (apply #'* (array-dimensions a)))))

(defmethod line-n ((i array-inspector) n)
  (let* ((v (inspector-object i))
         (rank (array-rank v))
         (uvsize (if (eql rank 1)
                   (+ (uvsize v) 1)
                   7)))
    (cond ((eql 0 n) (values (array-element-type v)
                             (if (adjustable-array-p v)
                               "Adjustable, Element type"
                               "Element type")
                             :static 'prin1-colon-line))
          ((eql  5 n)
           (values  (uvref v target::vectorH.flags-cell)
                   "Flags: "
                   :static
                   #'(lambda (i s v l type)
                       (format-normal-line i s v l type "#x~x"))))
          ((and (eql  6 n) (not (eql rank 1)))
           (values (array-dimensions v) "Dimensions: " :static))
          ((< n uvsize) (call-next-method i (1- n)))
          (t (let ((index (- n uvsize)))
               (values (row-major-aref v index) (array-indices v index) :colon))))))

(defmethod (setf line-n) (new-value (i array-inspector) n)
  (let* ((v (inspector-object i))
         (rank (array-rank v))
         (uvsize (if (eql rank 1)
                   (+ (uvsize v) 1)
                   7)))
    (prog1
      (cond ((or (eql 0 n) (eql 1 n) (and (eql 4 n) (not (eql rank 1))))
             (setf-line-n-out-of-range i n))
            ((< n uvsize)
             (if (eql 3 n)
               (setq new-value (require-type new-value 'array))
               (setq new-value (require-type new-value 'fixnum)))
             (call-next-method new-value i (1- n)))
          (t (let ((index (- n uvsize)))
               (setf (row-major-aref v index) new-value))))
      (resample-it))))

(defun array-indices (a row-major-index)
  (let ((rank (array-rank a)))
    (if (eql 1 rank)
      row-major-index
      (let ((res nil)
            dim
            (dividend row-major-index)
            remainder)
        (loop
          (when (zerop rank) (return res))
          (setq dim (array-dimension a (decf rank)))
          (multiple-value-setq (dividend remainder) (floor dividend dim))
          (push remainder res))))))
  
(defmethod prin1-line ((i array-inspector) stream value &optional
                       label type function)
  (declare (ignore stream value type function))
  (if (or (numberp label) (listp label))   ; First line or contents lines
    (call-next-method)
    (let ((*print-array* nil))
      (call-next-method))))

;;;;;;;
;;
;; Numbers
;;
(defmethod inspector-class ((num number)) 'usual-formatting-inspector)

; floats
(defmethod compute-line-count ((num float)) 5)

(defmethod line-n ((num float) n)
  (let ((type :static))
    (ecase n
      (0 (values num "Float:           " type))
      (1 (values num "Scientific:      " type
                 (if (< num 0) "~8,2e" "~7,2e")))
      (2 (values (if (zerop num) "illegal" (log num 2))
                     "Log base 2:      " type "~d"))
      (3 (values (rationalize num)
                     "Ratio equiv:     " type))
      (4 (values (round num)
                     "Nearest integer: " type)))))

; complex numbers
(defmethod compute-line-count ((num complex)) 3)

(defmethod line-n ((num complex) n)
  (let ((type :static))
    (ecase n
      (0 (values num            "Complex num:    " type))
      (1 (values (realpart num) "Real part:      " type))
      (2 (values (imagpart num) "Imaginary part: " type)))))

; ratios
(defmethod compute-line-count ((num ratio)) 6)

(defmethod line-n ((num ratio) n)
  (let ((type :static))
    (ecase n
      (0 (values num               "Ratio:           " type))
      (1 (values (float num)       "Scientific:      " type 
                 (if (< num 0) "~8,2e" "~7,2E")))
      (2 (values (if (zerop num) "illegal" (log num 2))
                                   "Log base 2:      " type "~d"))
      (3 (values (round num)       "Nearest integer: " type))
      (4 (values (numerator num)   "Numerator:       " type))
      (5 (values (denominator num) "Denominator:     " type)))))

; integers
(defmethod compute-line-count ((num integer)) 
  (let ((res 12))
    (unless (< 0 num 4000) (decf res))   ; not a roman number
    (unless (<= 0 num 255) (decf res))   ; not a character
    res))

(defmethod line-n ((num integer) n)
  (if (and (>= n 7) (not (< 0 num 4000))) (incf n))   ; maybe skip roman.
  (if (and (>= n 8) (not (<= 0 num 255))) (incf n))   ; maybe skip character.
  (let* ((type :static)
         (neg? (< num 0))
         (norm (if neg? 
                 (+ num (expt 2 (max 32 (* 4 (round (+ (integer-length num) 4) 4)))))
                 num)))
    (ecase n
      (0  (values num
                (if (fixnump num)
                  "Fixnum:      "
                  "Bignum:      ")
                type "~s"))
      (1  (let ((num (ignore-errors (float num))))
            (values num "Scientific:  " type
                    (cond ((null num) "FLOATING-POINT-OVERFLOW")
                          ((< num 0) "~8,2e")
                          (t "~7,2e")))))
      (2  (values (if (zerop num) "illegal" (log num 2)) 
                  "Log base 2:  " type "~d"))
      (3  (values norm
                  "Binary:      " type
                  (if neg? "#b...~b" "#b~b")))
      (4  (values norm
                  "Octal:       " type
                  (if neg? "#o...~o" "#o~o")))
      (5  (values num
                  "Decimal:     " type "~d."))
      (6  (values norm
                  "Hex:         " type
                  (if neg? "#x...~x" "#x~x")))
      (7  (values (format nil "~@r" num)
                  "Roman:       " type "~a"))
      (8  (values (code-char num)
                  "Character:   " type "~s"))
      (9 (values (ccl::ensure-simple-string (prin1-to-string num))
                  "Abbreviated: "
                  type #'format-abbreviated-string))
      (10 (values (or (ignore-errors (universal-time-string num)) "#<error>")
                  "As time:     " type "~a"))
      (11 (if (< num 0)
            (values most-negative-fixnum 'most-negative-fixnum type '("~d." t))
            (values most-positive-fixnum 'most-positive-fixnum type '("~d." t)))))))

(defun format-abbreviated-string (stream string)
  (setq string (require-type string 'simple-string))
  (let ((length (length string)))
    (if (< length 7)
      (princ string stream)
      (format stream "~a <- ~s digits -> ~a"
              (subseq string 0 3)
              (- length 6)
              (subseq string (- length 3) length)))))

(defun universal-time-string (num)
  (multiple-value-bind (second minute hour date month year day)
                       (decode-universal-time num)
    (with-output-to-string (s)
      (format s "~d:~2,'0d:~2,'0d " hour minute second)
      (princ (nth day '("Monday" "Tuesday" "Wednesday" "Thursday" "Friday"
                        "Saturday" "Sunday"))
             s)
      (format s ", ~d " date)
      (princ (nth month '("" "January" "February" "March" "April" "May" "June" "July"
                          "August" "September" "October" "November" "December"))
             s)
      (format s ", ~d" year))))

; Characters
(defmethod compute-line-count ((ch character)) 2)

(defmethod line-n ((ch character) n)
  (let ((type :static))
    (ecase n
      (0 (values ch             "Character: " type))
      (1 (values (char-code ch) "char-code: " type)))))

;;;;;;;
;;
;; Symbols
;;
(defun symbol-has-bindings-p (sym)
  (or (constantp sym) (proclaimed-special-p sym) (boundp sym)
      (special-operator-p sym) (macro-function sym) (fboundp sym)
      (type-specifier-p sym) (record-type-p sym nil)
      (find-class sym nil)))

(defmethod inspector-class ((sym symbol)) 'usual-basics-first-inspector)

(defmethod compute-line-count ((sym symbol))
  (+ (if (symbol-has-bindings-p sym) 1 0)
     1                                  ; package
     1                                  ; symbol-name
     1                                  ; symbol-value
     1                                  ; symbol-function
     (if (fboundp sym) 1 0)             ; arglist
     1                                  ; plist
     (if (find-class sym nil) 1 0)      ; class
     ))


(defmethod normalize-line-number ((sym symbol) n)
  (if (and (>= n 0) (not (symbol-has-bindings-p sym))) (incf n))
  (if (and (>= n 5) (not (fboundp sym))) (incf n))
  n)

(defmethod line-n ((sym symbol) n)
  (setq n (normalize-line-number sym n))
  (let ((type :normal)
        (comment '(:comment (:bold)))
        (static :static))
    (ecase n
      (0 (values nil (symbol-type-line sym) comment))
      (1 (let ((p (symbol-package sym)))
           (if (null p)
             (values nil "No home package." comment)
             (multiple-value-bind (found kind) (find-symbol (symbol-name sym) p)
               (values p 
                       (if (or (null kind) (neq found sym))
                         "NOT PRESENT in home package: "
                         (format nil "~a in package: " kind))
                       static)))))
      (2 (values (symbol-name sym) "Print name: " static))
      (3 (values (if (boundp sym) (symbol-value sym) *unbound-marker*)
                 "Value: " type))
      (4 (values (if (fboundp sym)
                   (cond ((macro-function sym))
                         ((special-operator-p sym) sym)
                         (t (symbol-function sym)))
                   *unbound-marker*)
                 "Function: " type))
      (5 (values (and (fboundp sym) (arglist sym))
                 "Arglist: " static))
      (6 (values (symbol-plist sym) "Plist: " type))
      (7 (values (find-class sym) "Class: " static)))))

(defmethod (setf line-n) (value (sym symbol) n)
  (let (resample-p)
    (setq n (normalize-line-number sym n))
    (setq value (restore-unbound value))
    (ecase n
      ((0 1 2 5) (setf-line-n-out-of-range sym n))
      (3 (setf resample-p (not (boundp sym))
               (symbol-value sym) value))
      (4 (setf resample-p (not (fboundp sym))
               (symbol-function sym) value))
      (6 (setf (symbol-plist sym) value)))
    (when resample-p (resample-it))
    value))

(defun record-type-p (name &optional check-database)
  (declare (ignore check-database))
  (and (keywordp name)
       (ignore-errors (ccl::%foreign-type-or-record name))))

; Add arglist here.
(defun symbol-type-line (sym)
  (let ((types (list
                (cond ((constantp sym)
                       "Constant")
                      ((proclaimed-special-p sym)
                       "Special Variable")
                      ((boundp sym)
                       "Non-special Variable")
                      (t nil))
                (cond ((special-operator-p sym)
                       "Special Operator")
                      ((macro-function sym)
                       "Macro")
                      ((fboundp sym)
                       "Function")
                      (t nil))
                (if (type-specifier-p sym) "Type Specifier")
                (if (record-type-p sym nil) "Record Type")
                (if (find-class sym nil) "Class Name")))
        flag)
    (with-output-to-string (s)
      (dolist (type types)
        (when type
          (if flag (write-string ", " s))
          (setq flag t)
          (write-string type s))))))
    

(defmethod inspector-commands ((sym symbol))
  (let ((res nil))
    '(push (list "Documentation" #'(lambda () (show-documentation sym)))
          res)
    (let ((class (find-class sym nil)))
      (if class
        (push (list "Inspect Class" #'(lambda () (inspect class))) res)))
    (if (boundp sym)
      (push (list "MAKUNBOUND" #'(lambda () (when (y-or-n-p (format nil "~s?" `(makunbound ',sym)))
                                              (makunbound sym) (resample-it))))
            res))
    (if (fboundp sym)
      (push (list "FMAKUNBOUND" #'(lambda () (when (y-or-n-p (format nil "~s?" `(fmakunbound ',sym)))
                                               (fmakunbound sym) (resample-it))))
            res))
    '(if (record-type-p sym)
      (push (list "Inspect Record Type" #'(lambda () (inspect-record-type sym)))
            res))
    (nreverse res)))


(defmethod line-n-inspector ((sym symbol) n value label type)
  (declare (ignore label type))
  (setq n (normalize-line-number sym n))
  (if (eql n 6)
    (make-instance 'plist-inspector :symbol sym :object value)
    (call-next-method)))

(defclass plist-inspector (inspector)
  ((symbol :initarg :symbol :reader plist-symbol)))

(defmethod inspector-window-title ((i plist-inspector))
  (format nil "~a of ~s" 'plist (plist-symbol i)))

(defmethod compute-line-count ((i plist-inspector))
  (+ 3 (/ (length (inspector-object i)) 2)))

(defmethod line-n ((i plist-inspector) n)
  (let* ((plist (inspector-object i)))
    (cond ((eql 0 n) (values plist "Plist: "))
          ((eql 1 n) (values (plist-symbol i) "Symbol: " :static))
          ((eql 2 n) (values nil nil :comment))
          (t (let ((rest (nthcdr (* 2 (- n 3)) plist)))
               (values (cadr rest) (car rest) :colon))))))

(defmethod (setf line-n) (new-value (i plist-inspector) n)
  (let* ((plist (inspector-object i)))
    (if (eql n 0)
      (replace-object i new-value)
      (if (< n 3)
        (setf-line-n-out-of-range i n)
        (let ((rest (nthcdr (* 2 (- n 3)) plist)))
          (setf (cadr rest) new-value)
          (resample-it))))))

(defparameter *inspector-disassembly* nil)

;;;;;;;
;;
;; Functions
;;
(defclass function-inspector (inspector)
  ((header-lines :initform nil :reader header-lines)
   (disasm-p :accessor disasm-p :initform *inspector-disassembly*)
   (disasm-info :accessor disasm-info)
   (pc-width :accessor pc-width)
   (pc :initarg :pc :initform nil :accessor pc)))

(defmethod standard-header-count ((f function-inspector)) (length (header-lines f)))

(defmethod header-count ((f function-inspector)) (standard-header-count f))

(defclass closure-inspector (function-inspector)
  ((n-closed :accessor closure-n-closed)))

(defmethod inspector-class ((f function)) 'function-inspector)
(defmethod inspector-class ((f compiled-lexical-closure)) 'closure-inspector)

(defmethod compute-line-count :before ((f function-inspector))
  (let* ((o (inspector-object f))
         (doc (documentation o t))
         (sn (ccl::function-source-note o))
         (lines (nconc (list (list o ""))
                       (list (list (function-name o) "Name" :colon))
                       (list (multiple-value-bind (arglist type) (arglist o)
                               (let ((label (if type
                                              (format nil "Arglist (~(~a~))" type)
                                              "Arglist unknown")))
                                 (list arglist label (if type :colon '(:comment (:plain)))))))
                       (list (list (ccl::lfun-bits o) "Bits" :colon))
                       (list (list (ccl::%lfun-info o) "Plist" :colon))
                       (when doc (list (list (substitute #\space #\newline doc) "Documentation" :colon)))
                       (when sn (list (list sn "Source Location" :colon))))))
    (setf (slot-value f 'header-lines) lines)))

(defmethod compute-line-count ((f function-inspector))
  (+ (header-count f) (compute-disassembly-lines f)))

(defmethod line-n-strings ((f function-inspector) n)
  (if (< (decf n (header-count f)) 0)
    (call-next-method)
    (disassembly-line-n-strings f n)))

(defmethod line-n-inspector ((f function-inspector) n value label type)
  (declare (ignore value label type))
  (if (< (decf n (header-count f)) 0)
    (call-next-method)
    (disassembly-line-n-inspector f n)))

(defmethod line-n ((f function-inspector) n)
  (let* ((lines (header-lines f))
         (nlines (length lines)))
    (if (< n nlines)
      (apply #'values (nth n lines))
      (disassembly-line-n f (- n nlines)))))

(defmethod compute-line-count :before ((f closure-inspector))
  (let* ((o (inspector-object f))
	 (nclosed (nth-value 8 (function-args (ccl::closure-function o)))))
    (setf (closure-n-closed f) nclosed)))

(defmethod header-count ((f closure-inspector))
  (+ (standard-header-count f)
     1                              ; the function we close over
     1                              ; "Closed over values"
     (closure-n-closed f)))

(defmethod line-n ((f closure-inspector) n)
  (let ((o (inspector-object f))
        (nclosed (closure-n-closed f)))
    (if (< (decf n (standard-header-count f)) 0)
      (call-next-method)
      (cond ((< (decf n) 0)
             (values (ccl::closure-function o) "Inner lfun: " :static))
            ((< (decf n) 0)
             (values nclosed "Closed over values" :comment))
            ((< n nclosed)
             (let* ((value (ccl::nth-immediate o (1+ (- nclosed n))))
                    (map (car (ccl::function-symbol-map (ccl::closure-function o))))
                    (label (or (and map (aref map (+ n (- (length map) nclosed))))
                               n))
                    (cellp (ccl::closed-over-value-p value)))
               (when cellp
                 (setq value (ccl::closed-over-value value)
                       label (format nil "(~a)" label)))
               (values value label (if cellp :normal :static) #'prin1-colon-line)))
            (t (disassembly-line-n f (- n nclosed)))))))

(defmethod (setf line-n) (new-value (f function-inspector) n)
  (let ((o (inspector-object f))
        (standard-header-count (standard-header-count f)))
    (if (< n standard-header-count)
      (case n
        (0 (replace-object f new-value))
        (1 (ccl::lfun-name o new-value) (resample-it))
        (t (setf-line-n-out-of-range f n)))
      (set-disassembly-line-n f (- n standard-header-count) new-value)))
  new-value)

(defmethod (setf line-n) (new-value (f closure-inspector) en &aux (n en))
  (let ((o (inspector-object f))
        (nclosed (closure-n-closed f)))
    (if (< (decf n (standard-header-count f)) 0)
      (call-next-method)
      (cond ((< (decf n 2) 0)          ; inner-lfun or "Closed over values"
             (setf-line-n-out-of-range f en))
            ((< n nclosed)       ; closed-over variable
             (let* ((value (ccl::nth-immediate o (1+ (- nclosed n))))
                    (cellp (ccl::closed-over-value-p value)))
               (unless cellp (setf-line-n-out-of-range f en))
               (ccl::set-closed-over-value value new-value)))
            (t (set-disassembly-line-n f (- n nclosed) new-value))))))

(defun compute-disassembly-lines (f &optional (function (inspector-object f)))
  (if (and (functionp function) (disasm-p f))
    (let* ((lines (ccl::disassemble-lines function)) ;; list of (object label instr)
           (length (length lines))
           (last-label (loop for n from (1- length) downto 0 as line = (aref lines n)
                             thereis (and (consp line) (cadr line))))
           (max-pc (if (consp last-label) (cadr last-label) last-label)))
      (setf (pc-width f) (length (format nil "~d" max-pc)))
      (setf (disasm-info f) lines)
      (1+ length))
    0))

(defun disassembly-line-n (f n)
  (if (< (decf n) 0)
    (values nil "Disassembly:" :comment)
    (let ((line (aref (disasm-info f) n)))
      (if (consp line)
        (destructuring-bind (object label instr) line
          (values object (cons label instr) :static))
        (values nil (cons nil line) :static)))))

(defun disassembly-line-n-inspector (f n)
  (unless (< (decf n) 0)
    (let ((line (aref (disasm-info f) n)))
      (and (consp line)
	   (car line)
	   (make-inspector (car line))))))

(defun disassembly-line-n-strings (f n)
  (if (< (decf n) 0)
    (values "Disassembly:" nil)
    (let ((line (aref (disasm-info f) n)))
      (if (consp line)
        (destructuring-bind (object label instr) line
          (declare (ignore object))
          (unless (stringp label)
            (setq label (with-output-to-string (stream)
                          (prin1-disassembly-label f stream label))))
          (values label instr))
        (values nil line)))))

(defun set-disassembly-line-n (f n new-value &optional 
                                 (function (inspector-object f)))
  (declare (ignore new-value function))
  (setf-line-n-out-of-range f n))

(defmethod prin1-label ((f function-inspector) stream value &optional data type)
  (declare (ignore value type))
  (if (atom data)                      ; not a disassembly line
    (call-next-method)
    (prin1-disassembly-label f stream (car data))))

(defun prin1-disassembly-label (f stream label)
  (let* ((pc label)
         (label-p (and (consp pc) (setq pc (cadr pc))))
         (pc-mark (pc f))
         (pc-width (pc-width f)))
    (when pc
      (write-char (if (eql pc pc-mark) #\* #\Space) stream)
      (format stream "~@[L~d~]~vT~v<[~d]~> " label-p (+ pc-width 3) (+ pc-width 2) pc))))

#+x86-target
(defmethod prin1-value ((f function-inspector) stream value &optional data type)
  (declare (ignore value type))
  (if (atom data) ;; not a disassembly line
    (call-next-method)
    (princ (cdr data) stream)))


#+ppc-target
(defmethod prin1-value ((f function-inspector) stream value &optional label type)
  (if (atom label)                      ; not a disassembly line
    (unless (eq (if (consp type) (car type) type) :comment)
      (call-next-method))
    (let ((q (cdr label)))
      (write-char #\( stream)
      (loop (if (null q) (return))
        (ccl::disasm-prin1 (pop q) stream)
        (if q (write-char #\space stream)))
      (write-char #\) stream)))
  value)

;; Generic-functions
;; Display the list of methods on a line of its own to make getting at them faster
;; (They're also inside the dispatch-table which is the first immediate in the disassembly).
(defclass gf-inspector (function-inspector)
  ((method-count :accessor method-count)))

(defmethod inspector-class ((f standard-generic-function))
  (if (functionp f) 
    'gf-inspector
    'standard-object-inspector))

(defmethod compute-line-count :before ((f gf-inspector))
  (let* ((gf (inspector-object f))
         (count (length (generic-function-methods gf))))
    (setf (method-count f) count)))

(defmethod header-count ((f gf-inspector))
  (+ (standard-header-count f) 1 (method-count f)))

(defmethod line-n ((f gf-inspector) n)
  (let* ((count (method-count f))
	 (methods (generic-function-methods (inspector-object f))))
    (cond ((< (decf n  (standard-header-count f)) 0)
           (call-next-method))
          ((< (decf n) 0)
	   (values methods "Methods: " :comment))
          ((< n count)
	   (values (nth n methods) nil :static))
          (t (disassembly-line-n f (- n count))))))

(defmethod (setf line-n) (new-value (f gf-inspector) n)
  (let* ((count (method-count f))
         (en n))
    (cond ((< (decf n (standard-header-count f)) 0)
           (call-next-method))
          ((< (decf n) count)
           (setf-line-n-out-of-range f en))
          (t (set-disassembly-line-n f (- n count) new-value)))))

#|
(defmethod inspector-commands ((f gf-inspector))
  (let* ((function (inspector-object f))
         (method (selected-object (inspector-view f))))
    (if (typep method 'method)
      (nconc
       (call-next-method)
       `(("Remove method"
         ,#'(lambda ()
              (remove-method function method)
              (resample-it)))))
      (call-next-method))))
|#

;;;;;;;
;;
;; Structures
;;
(defmethod inspector-class ((s structure-object))
  'usual-basics-first-inspector)

(defun structure-slots (s)
  (let ((slots (ccl::sd-slots (ccl::struct-def s))))
    (if (symbolp (caar slots))
      slots
      (cdr slots))))

(defmethod compute-line-count ((s structure-object))
  (length (structure-slots s)))

(defmethod line-n ((s structure-object) n)
  (let ((slot (nth n (structure-slots s))))
    (if slot
      (values (uvref s (ccl::ssd-offset slot)) (ccl::ssd-name slot) :colon)
      (line-n-out-of-range s n))))

(defmethod (setf line-n) (new-value (s structure-object) n)
  (let ((slot (nth n (structure-slots s))))
    (if slot
      (setf (uvref s (ccl::ssd-offset slot)) new-value)
      (setf-line-n-out-of-range s n))))


(defclass basic-stream-inspector (uvector-inspector) ())

(defmethod inspector-class ((bs ccl::basic-stream)) 'basic-stream-inspector)
  
;;;;;;;
;;
;; packages
;;
(defclass package-inspector (uvector-inspector) ())

(defmethod inspector-class ((p package)) 'package-inspector)

(defmethod compute-line-count ((i package-inspector))
  (+ 2 (call-next-method)))

(defmethod line-n ((i package-inspector) n)
  (cond ((eql n 0) (values (ccl::%pkgtab-count (ccl::pkg.itab (inspector-object i)))
                           "Internal Symbols: " :static))
        ((eql n 1) (values (ccl::%pkgtab-count (ccl::pkg.etab (inspector-object i)))
                           "External Symbols: " :static))
        (t (call-next-method i (- n 2)))))

(defmethod (setf line-n) (new-value (i package-inspector) n)
  (if (< n 2)
    (setf-line-n-out-of-range i n)
    (call-next-method new-value i (- n 2))))

(defmethod inspector-commands ((i package-inspector))
  `(("Inspect all packages" ,#'(lambda () (inspect (list-all-packages))))
    (,(format nil "(setq *package* '~a" (inspector-object i))
     ,#'(lambda () (setq *package* (inspector-object i))))))

;;;;;;;
;;
;; Records
;;
(defclass record-inspector (object-first-inspector)
  ((record-type :accessor record-type)
   (field-names :accessor field-names)
   (unlock :initform nil :accessor unlock)))

(defmethod inspector-class ((o macptr))
  'record-inspector)


;;; Still needs work.
;;; Lots of work.
(defclass thread-inspector (uvector-inspector) ())

(defmethod inspector-class ((thread ccl::lisp-thread))
  'thread-inspector)

(defmethod compute-line-count :before ((i thread-inspector))
)

(defmethod line-n ((thread thread-inspector) n)
  (declare (ignorable n))
  (call-next-method)
)

#|
(defmethod line-n-inspector ((i thread-inspector) n value label type)
  (declare (ignore n type))
  (or (and value
           (macptrp value)
           (not (%null-ptr-p value)))
      (call-next-method)))
|#


(defmethod line-n-inspector (i n value label type)
  (declare (ignore i n label type))
  (make-inspector value))

(defmethod line-n-inspector ((i usual-inspector) n value label type)
  (let ((object (inspector-object i)))
    (if (typep object 'usual-inspector)
      (make-inspector value)
      (line-n-inspector (inspector-object i) n value label type))))




;;;;;;;
;;
;; an ERROR-FRAME stores the stack addresses that the backtrace window displays
;;

;; set to list of function you don't want to see
;; Functions can be symbols, nil for kernel, or #'functions
(defparameter *backtrace-internal-functions*  
  (list :kernel))

(defvar *backtrace-hide-internal-functions-p* t)

(defclass error-frame ()
  ((addresses :accessor addresses)
   (restart-info :accessor restart-info)
   (stack-start :initarg :stack-start  :reader stack-start)
   (stack-end :initarg :stack-end :reader stack-end)
   (tcr :initarg :tcr :initform (ccl::%current-tcr) :reader tcr)
   (context :initarg :context :reader context)
   (frame-count :accessor frame-count)
   (ignored-functions :accessor ignored-functions
                      :initform (and *backtrace-hide-internal-functions-p*
                                     *backtrace-internal-functions*))
   (break-condition :accessor break-condition
                    :initarg :break-condition)
   (unavailable-value-marker :initform (cons nil nil)
                             :accessor unavailable-value-marker)))
  


(defmethod initialize-instance ((f error-frame) &key)
  (call-next-method)
  (initialize-addresses f))

(defmethod initialize-addresses ((f error-frame))
  (let* ((addresses (coerce (ccl::%stack-frames-in-context (context f)) 'vector)))
      (setf (frame-count f) (length addresses)
            (addresses f) addresses)))

(defmethod compute-frame-info ((f error-frame) n)
  (let* ((frame (aref (addresses f) n))
         (context (context f))
         (marker (unavailable-value-marker f)))
    
    (multiple-value-bind (lfun pc) (ccl::cfp-lfun frame)
      (multiple-value-bind (args locals) (ccl::arguments-and-locals context frame lfun pc marker)
        (list (ccl::arglist-from-map lfun) args locals)))))

(defun print-error-frame-limits (f stream)
  (format stream "#x~x - #x~x" (stack-start f) (stack-end f)))

(defmethod print-object ((f error-frame) stream)
  (print-unreadable-object (f stream :type 'frame-ptr)
    (print-error-frame-limits f stream)))



;;;;;;;
;;
;; The inspector for error-frame objects
;;



;;; The "vsp-range" and "tsp-range" slots have to do with
;;; recognizing/validating stack-allocated objects
(defclass stack-inspector (inspector)
  ((vsp-range :accessor vsp-range :initarg :vsp-range)
   (tsp-range :accessor tsp-range :initarg :tsp-range)
   (csp-range :accessor csp-range :initarg :csp-range)))



                           
(defmethod initialize-instance ((i stack-inspector) &rest initargs &key context)
  (declare (dynamic-extent initargs))
  (let* ((start (ccl::child-frame (ccl::parent-frame (ccl::bt.youngest context) context) context))
         (end (ccl::child-frame (ccl::parent-frame (ccl::bt.oldest context) context) context))
         (tcr (ccl::bt.tcr context)))
    (apply #'call-next-method
           i
           :object 
           (make-instance 'error-frame
             :stack-start start
             :stack-end end
             :tcr tcr
             :context context
             :break-condition (ccl::bt.break-condition context))
           #-arm-target
           :tsp-range #-arm-target (ccl::make-tsp-stack-range tcr context)
           :vsp-range (ccl::make-vsp-stack-range tcr context)
           :csp-range (ccl::make-csp-stack-range tcr context)
           initargs)))

(defmethod print-object ((i stack-inspector) stream)
  (print-unreadable-object (i stream :type 'stack-inspector)
    (print-error-frame-limits (inspector-object i) stream)))

(defmethod addresses ((f stack-inspector))
  (addresses (inspector-object f)))

(defmethod compute-line-count ((f stack-inspector))
  (frame-count (inspector-object f)))

(defmethod line-n ((f stack-inspector) n)
  (let* ((frame (aref (addresses (inspector-object f)) n)))
    (ccl::cfp-lfun frame)))



 


;;; inspecting a single stack frame
;;; The inspector-object is expected to be an error-frame
(defclass stack-frame-inspector (inspector)
  ((frame-number :initarg :frame-number :initform nil :reader frame-number)
   (frame-info :initform nil :accessor frame-info)))


(defmethod initialize-instance ((i stack-frame-inspector) &rest initargs &key
                                object frame-number)
  (declare (dynamic-extent initargs))
  (setq object (require-type object 'error-frame))
  (apply #'call-next-method i 
         :object object
         initargs)
  (setf (frame-number i) frame-number))

    

(defmethod compute-line-count ((i stack-frame-inspector))
  (let ((frame-number (frame-number i)))
    (if (null frame-number)
      0
      (let* ((error-frame (inspector-object i))
             (frame-info (or (frame-info i)
                             (setf (frame-info i) (compute-frame-info error-frame frame-number)))))
        (destructuring-bind (args locals) (cdr frame-info)
          (+ 1 (length args) 1 (length locals)))))))

(defmethod line-n ((i stack-frame-inspector) n)
  (unless (< -1 n (inspector-line-count i))
    (line-n-out-of-range i n))
  (destructuring-bind (arglist args locals) (frame-info i)
    (if (zerop n)
      (values arglist nil :static)
      (let* ((nargs (length args)))
        (decf n)
        (if (< n nargs)
          (cons :arg (nth n args))
          (progn
            (decf n nargs)
            (if (zerop n)
              nil
              (cons :local (nth (1- n) locals)))))))))

(defmethod (setf line-n) (value (i stack-frame-inspector) n)
  (declare (ignorable value n))
  (error "not yet!"))

        



(defmethod prin1-value ((i stack-frame-inspector) stream value &optional label type)
  (declare (ignore label type))
  (when value
    (if (or (atom value) (not (typep (car value) 'keyword)))
      (prin1 value stream)
      (progn
        (if (eq (car value) :arg)
          (format stream "   ")
          (format stream "  "))
        (when (cdr value)
          (destructuring-bind (label . val) (cdr value)
            (format stream "~a: " label)
            (if (eq val *unbound-marker*)
              (format stream "??")
              (prin1 val stream))))))))

(defmethod (setf frame-number) (frame-number (i stack-frame-inspector))
  (let ((max (1- (frame-count (inspector-object i)))))
    (unless (or (null frame-number)
                (and (<= 0 frame-number max)))
      (setq frame-number (require-type frame-number `(or null (integer 0 ,max))))))
  (unless (eql frame-number (frame-number i))
    (setf (slot-value i 'frame-number) frame-number)
    (setf (inspector-line-count i) nil)
    frame-number))

;;; Inspector


(defvar *inspector-ui* ())
(defvar *previous-inspector-ui* nil)

(defclass inspector-ui ()
    ((inspector :initarg :inspector :accessor inspector-ui-inspector)
     (level :initarg :level :accessor inspector-ui-level)))

(defclass inspector-tty-ui (inspector-ui)
    ((origin :initarg :origin :initform 0 :accessor inspector-tty-ui-origin)
     (pagesize :initarg :pagesize :initform 20 :accessor
	       inspector-tty-ui-pagesize)))

(defmethod ui-initialize ((ui inspector-tty-ui)))

(defmethod ui-present ((ui inspector-tty-ui))
  (let* ((inspector (inspector-ui-inspector ui)))
    (with-errorfree-printing
	(let* ((stream *debug-io*)
	       (origin (inspector-tty-ui-origin ui))
	       (pagesize (inspector-tty-ui-pagesize ui))
	       (page-end (+ origin pagesize))
	       (n (compute-line-count inspector))
	       (end (min page-end n))
	       (tag -1)
	       (*print-pretty* (or *print-pretty* *describe-pretty*))
	       (*print-length* 5)
	       (*print-level* 5)
	       (func #'(lambda (i index child &optional label-string value-string)
			 (declare (ignore i))
			 (when child (incf tag))
			 (unless (< index origin)
			   (format stream "~@[[~d]~]~8t" (and child tag))
			   (format-line-for-tty stream label-string value-string)
			   (terpri stream)))))
	  (declare (dynamic-extent func))
	  (map-lines inspector func 0 end)))
    (values)))

(ccl::define-toplevel-command
    :tty-inspect i (n)
    "inspect <n>th item"
    (inspector-ui-inspect-nth *inspector-ui* n))

(ccl::define-toplevel-command
    :tty-inspect pop ()
    "exit current inspector level"
    (invoke-restart 'exit-inspector))

(ccl::define-toplevel-command
    :tty-inspect q ()
    "exit inspector"
  (invoke-restart 'end-inspect))

(ccl::define-toplevel-command
    :tty-inspect show ()
    "re-show currently inspected object (the value of CCL:@)"
    (ui-present *inspector-ui*))

(defmethod inspector-ui-next-page ((ui inspector-tty-ui))
  (let* ((nlines (compute-line-count (inspector-ui-inspector ui)))
	 (origin (inspector-tty-ui-origin ui))
	 (page-size (inspector-tty-ui-pagesize ui))
	 (new-origin (+ origin page-size)))
    (if (< new-origin nlines)
      (setf (inspector-tty-ui-origin ui) new-origin))
    (ui-present ui)))
    
(ccl::define-toplevel-command
    :tty-inspect next ()
    "show next page of object data"
    (inspector-ui-next-page *inspector-ui*))

(defmethod inspector-ui-prev-page ((ui inspector-tty-ui))
  (let* ((origin (inspector-tty-ui-origin ui))
	 (page-size (inspector-tty-ui-pagesize ui))
	 (new-origin (max 0 (- origin page-size))))
    (setf (inspector-tty-ui-origin ui) new-origin)
    (ui-present ui)))

(ccl::define-toplevel-command
    :tty-inspect prev ()
    "show previous page of object data"
    (inspector-ui-prev-page *inspector-ui*))

(ccl::define-toplevel-command
    :tty-inspect home ()
    "show first page of object data"
    (progn
      (setf (inspector-tty-ui-origin *inspector-ui*) 0)
      (ui-present *inspector-ui*)))

(ccl::define-toplevel-command
    :tty-inspect s (n v)
    "set the <n>th line of object data to value <v>"
    (let* ((ui *inspector-ui*))
      (setf (line-n (inspector-ui-inspector ui) n) v)
      (ui-present ui)))


(defmethod ui-interact ((ui inspector-tty-ui))
  (let* ((level (inspector-ui-level ui))
         (ccl::*default-integer-command* `(:i 0 ,(1- (compute-line-count (inspector-ui-inspector ui))))))
    (declare (special ccl::*default-integer-command*))
    (restart-case
        (ccl:with-terminal-input
          (ccl::with-toplevel-commands :tty-inspect
            (ccl::read-loop
             :prompt-function #'(lambda (stream)
                                  (if (eql level 0)
                                    (format stream "~&Inspect> ")
                                    (format stream "~&Inspect ~d> " level))))))
      (exit-inspector ()
        (if *previous-inspector-ui*
          (ui-present *previous-inspector-ui*)
          (terpri *debug-io*))))))

(defmethod inspector-ui-inspect-nth ((ui inspector-tty-ui) n)
  (let* ((inspector (inspector-ui-inspector ui))
	 (new-inspector (block nil
			  (let* ((tag -1)
				 (func #'(lambda (i index child &rest strings)
					   (declare (ignore i index strings))
					   (when (and child (eql (incf tag) n)) (return child)))))
			    (declare (dynamic-extent func))
			    (map-lines inspector func))))
	 (ccl::@ (inspector-object new-inspector)))
    (inspector-ui-inspect
     (make-instance 'inspector-tty-ui
       :level (1+ (inspector-ui-level ui))
       :inspector new-inspector))))

(defparameter *default-inspector-ui-class-name* 'inspector-tty-ui)

(defmethod inspector-ui-inspect ((ui inspector-ui))
  (let* ((*previous-inspector-ui* *inspector-ui*)
         (*inspector-ui* ui))
    (ui-initialize ui)
    (ui-present ui)
    (ui-interact ui)
    (values)))

(defun tty-inspect (thing)
  (inspector-ui-inspect (make-instance *default-inspector-ui-class-name*
                                       :inspector (make-inspector thing)
					 :level 0)))

(defparameter *default-inspector-ui-creation-function* (lambda (thing)
                                                         (ccl::application-ui-operation *application* :inspect thing)))

(defmethod ccl::ui-object-do-operation ((o ccl::ui-object) (operation (eql :inspect)) &rest args)
  (apply #'tty-inspect args))

(defun inspect (thing)
  (let* ((ccl::@@@ nil)
         (ccl::@@ nil)
         (ccl::@ thing))
    (restart-case (funcall *default-inspector-ui-creation-function* thing)
      (end-inspect () thing))))

(defmethod note-inspecting-item ((i inspector))
  (setq ccl::@@@ ccl::@@
        ccl::@@ ccl::@
        ccl::@ (inspector-object i)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/describe.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/encapsulate.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defvar *loading-removes-encapsulation* nil
  "If true, loading a new method definition from a file will remove any tracing and advice on the method")

(defvar *trace-pfun-list* nil)
(defvar *trace-enable* t)
(defvar *trace-level* 0)
(defparameter *trace-max-indent* 40)
(defvar *trace-print-level* :default)
(defvar *trace-print-length* :default)
(defvar *trace-print-string-length* :default)
;(defparameter *trace-define-if-undefined* nil)
(defparameter *trace-bar-frequency* nil)
(defvar *trace-hook* nil)
(defvar *untrace-hook* nil)
(defvar *trace-print-hook* nil)

;;;
;;;  We support encapsulating three types of objects, i.e. modifying their definition
;;;  without changing their identity:
;;;    1. symbol - via the symbol-function slot
;;;    2. method - via the %method-function slot
;;;    3. standard-generic-function - via the %gf-dcode slot
;;;
;;; Encapsulation is effected by creating a new compiled function and storing it in the
;;; slot above. The new function references a gensym fbound to the original definition
;;; (except in the case of a gf, the gensym is fbound to a copy of the gf which in
;;; turn contains the original dcode, since we can't invoke the dcode directly).
;;; In addition, an ENCAPSULATION struct describing the encapsulation is created and
;;; stored in the *encapsulation-table* with the new compiled function as the key.
;;;
;;; 

(defparameter *encapsulation-table*
  (make-hash-table :test #'eq :rehash-size 2 :size 2 :weak t))

(defstruct (encapsulation)
  symbol         ; the uninterned name containing original def
  type           ; trace or advise
  spec           ; the original function spec
  advice-name    ; optional
  advice-when    ; :before, :after, :around 
  owner          ; where encapsulation is installed (can change)
)

(defun encapsulation-old-def (cap)
  (fboundp (encapsulation-symbol cap)))

(defun setf-function-spec-name (spec)
  (if (setf-function-name-p spec)
    (let ((name (%setf-method (cadr spec))))
      (if (non-nil-symbol-p name)  ; this can be an anonymous function
        name
        (setf-function-name (cadr spec))))
    spec))

(defun trace-tab (direction &aux (n (min *trace-level* *trace-max-indent*)))
  (fresh-line *trace-output*)
  (dotimes (i (1- n))
    (declare (fixnum i))
    (write-char (if (and *trace-bar-frequency* 
                         (eq 0 (mod i *trace-bar-frequency*)))
                  #\| #\Space) *trace-output*))
  (if (eq direction :in)
    (format *trace-output* "~d> " (1- *trace-level*))
    (format *trace-output* "<~d " (1- *trace-level*))))

(defun trace-before  (&rest args)
  (declare (dynamic-extent args))
  (trace-tab :in)
  (let* ((*print-level* (default-print-level *trace-print-level*))
         (*print-length* (default-print-length *trace-print-length*))
         (*print-string-length* (default-print-string-length *trace-print-string-length*))
         (*print-readably* nil))
    (format *trace-output* "Calling ~S ~%" args)
    (force-output *trace-output*)))

(defun trace-after (sym &rest args &aux (n (length args)))
  (declare (dynamic-extent args))
  (let* ((*print-level* (default-print-level *trace-print-level*))
         (*print-length* (default-print-length *trace-print-length*))
         (*print-string-length* (default-print-string-length *trace-print-string-length*))
         (*print-readably* nil))
    (if (eq n 1)
      (progn
        (trace-tab :out)
        (format *trace-output* "~S returned ~S~%" sym (%car args)))
      (progn
        (trace-tab :out)
        (format *trace-output* "~S returned ~S values :" sym n)
        (dolist (val args)
          (trace-tab :out)
          (format *trace-output* "     ~S" val))))
    (force-output *trace-output*)))

(defun forget-encapsulations (name)
  (when (%traced-p name)
    (format t "~%... Untracing ~a" name) 
    (%untrace-1 name))
  (when (%advised-p name)
    (format t "~%... Unadvising ~a" name) 
    (%unadvise-1 name))
  nil)

(defun function-encapsulated-p (fn-or-method)
  (get-encapsulation fn-or-method))

(defun %encap-fboundp (thing)
  (etypecase thing
    (symbol (fboundp thing))
    (method (%method-function thing))))
  
(defun %encap-binding (thing)
  (require-type (etypecase thing
                  (symbol (fboundp thing))
                  (method (%method-function thing)))
                'function))

(defun get-encapsulation (spec)
  (let* ((key (typecase spec
                (symbol (let* ((def (fboundp spec)))
                          (if (generic-function-p def)
                            (%gf-dcode def)
                            def)))
                (method (%method-function spec))
                (standard-generic-function (%gf-dcode spec))
                (function spec)))
         (cap (gethash key *encapsulation-table*)))
    #+gz (assert (or (null cap)
                     (let ((fn (%encap-binding (encapsulation-owner cap))))
                       (eq (if (standard-generic-function-p fn) (%gf-dcode fn) fn) key))))
    cap))

(defun set-encapsulation-owner (fn owner)
  (let ((cap (get-encapsulation fn)))
    (when cap
      (setf (encapsulation-owner cap) owner))))

(defun put-encapsulation (fn cap)
  (let* ((owner (encapsulation-owner cap))
         (old-def (%encap-binding owner))
         (newsym (encapsulation-symbol cap)))
    (setf (gethash fn *encapsulation-table*) cap)
    (set-encapsulation-owner old-def newsym)
    (etypecase owner
      (symbol
       (cond ((standard-generic-function-p old-def)
              (%fhave newsym (%copy-function old-def))
              (setf (%gf-dcode old-def) fn))
             (t
              (%fhave newsym old-def)
              (%fhave owner fn))))
      (method
       (%fhave newsym old-def)
       (setf (%method-function owner) fn)
       (remove-obsoleted-combined-methods owner)))))

(defun remove-encapsulation (cap)
  (let* ((owner (encapsulation-owner cap))
         (cur-def (%encap-fboundp owner))
         (old-def (encapsulation-old-def cap)))
    (typecase owner
      (symbol
       (cond ((or (null cur-def)
                  (not (eq cap (get-encapsulation cur-def))))
              ;; rebound behind our back, oh well.
              nil)
             ((standard-generic-function-p cur-def)
              (remhash (%gf-dcode cur-def) *encapsulation-table*)
              (set-encapsulation-owner old-def owner)
              (setf (%gf-dcode cur-def) (%gf-dcode old-def)))
             (t
              (remhash cur-def *encapsulation-table*)
              (set-encapsulation-owner old-def owner)
              (%fhave owner old-def))))
      (method
       (remhash cur-def *encapsulation-table*)
       (set-encapsulation-owner old-def owner)
       (setf (%method-function owner) old-def)
       (remove-obsoleted-combined-methods owner)))))


(defun encapsulate (owner newdef type spec newsym &optional advice-name advice-when)
  (let ((cap (make-encapsulation
	      :owner owner
	      :symbol newsym
	      :type type
	      :spec spec
	      :advice-name advice-name
	      :advice-when advice-when)))
    (put-encapsulation newdef cap)
    cap))

(defun find-unencapsulated-definition (fn)
  (when fn
    (loop for cap = (get-encapsulation fn) while cap
      do (setq fn (encapsulation-old-def cap)))
    fn))

(defun set-unencapsulated-definition (cap newdef)
  (loop for owner = (encapsulation-symbol cap)
    do (setq cap (get-encapsulation owner)) while cap
    finally (%fhave owner newdef)))

(defun %encapsulation-thing (spec &optional define-if-not (error-p t))
  ;; Returns either an fboundp symbol or a method, or nil.
  (typecase spec
    (symbol
     ;; weed out macros and special-forms
     (if (or (null spec) (special-operator-p spec) (macro-function spec))
       (if error-p
         (error "Cannot trace or advise ~a~S"
                (cond ((null spec) "")
                      ((special-operator-p spec) "special operator ")
                      (t "macro "))
                spec)
         nil)
       (if (or (fboundp spec)
               (and define-if-not
                    (progn
                      (warn "~S was undefined" spec)
                      (%fhave spec (%function 'trace-null-def))
                      t)))
         spec
         (if error-p
           (error "~S is undefined." spec)
           nil))))
    (method spec)
    (cons
     (case (car spec)
       (:method 
        (let ((gf (cadr spec))
              (qualifiers (butlast (cddr spec)))
              (specializers (car (last (cddr spec))))
              method)
          (setq specializers (require-type specializers 'list))
          (prog ()
            AGN
            (cond ((setq method
                         (find-method-by-names gf qualifiers specializers))
                   (return method))
                  (define-if-not
                    (when (define-undefined-method spec gf qualifiers specializers)
                      (go AGN)))
                  (t (if error-p
                       (error "Method ~s qualifiers ~s specializers ~s not found."
                              gf qualifiers specializers)
                       (return nil)))))))
       (setf
        (let ((name-or-fn (setf-function-spec-name spec)))
          (cond ((symbolp name-or-fn) (%encapsulation-thing name-or-fn))
                ((functionp name-or-fn) ; it's anonymous - give it a name
                 (let ((newname (gensym)))
                   (%fhave newname name-or-fn)
                   (store-setf-method (cadr spec) newname)
                   newname)))))))
    (t (if error-p
         (error "Invalid trace spec ~s" spec)
         nil))))

(defun trace-null-def (&rest ignore)
  (declare (ignore ignore)))

(defun define-undefined-method (spec gf qualifiers specializers)
  (let (vars def)    
    (flet ((blob (e)
                 (let ((v (gensym)))
                   (push v vars)
                   (list v e))))
      (declare (dynamic-extent #'blob))
      (setq def
            (let ((lambda-list (mapcar #' blob specializers)))
              (eval
               `(defmethod ,gf ,@qualifiers (,@lambda-list &rest ignore)
                  (declare (ignore ignore ,@vars))))))
      (when def (warn "~S was undefined" spec))
      def)))

(defun traceable-symbol-p (sym)
  (and sym
       (not (special-operator-p sym))
       (not (macro-function sym))
       (fboundp sym)))

(defun %trace-package (pkg &rest args)
  (declare (dynamic-extent args))
  (do-present-symbols (sym pkg)
    ;; Don't auto-trace imported symbols, because too often these are imported
    ;; system functions...
    (when (eq (symbol-package sym) pkg)
      (when (traceable-symbol-p sym)
        (apply #'trace-function sym args))
      (when (or (%setf-method sym)
                ;; Not really right.  Should construct the name if doesn't exist.
                ;; But that would create a lot of garbage for little gain...
                (let ((name (existing-setf-function-name sym)))
                  (traceable-symbol-p name)))
        (apply #'trace-function `(setf ,sym) args)))))

(defun trace-print-body (print-form)
  (when print-form
    (if (and (consp print-form) (eq (car print-form) 'values))
      `((mapcar #'(lambda (name object)
                    (trace-tab :in)
                    (format *trace-output* "~s = ~s" name object))
         ',(cdr print-form)
         (list ,@(cdr print-form))))
      `((let ((objects (multiple-value-list ,print-form))
              (i -1))
          (if (and objects (not (cdr objects)))
            (progn
              (trace-tab :in)
              (format *trace-output* "~s = ~s" ',print-form (car objects)))
            (dolist (object objects)
              (trace-tab :in)
              (format *trace-output* "~s [~d] = ~s" ',print-form (incf i) object))))))))

(defun trace-backtrace-body (test-form)
  (when test-form
    `((let ((test ,test-form))
        (when test
          (multiple-value-bind (detailed-p count)
              (cond ((memq test '(:detailed :verbose :full))
                     (values t nil))
                    ((integerp test)
                     (values nil test))
                    ((and (consp test)
                          (keywordp (car test))
                          (consp (cdr test))
                          (null (cddr test)))
                     (values (memq (car test) '(:detailed :verbose :full))
                             (and (integerp (cadr test)) (cadr test))))
                    (t (values nil nil)))
            (let ((*debug-io* *trace-output*))
              (print-call-history :detailed-p detailed-p
                                  :count (or count most-positive-fixnum))
              (terpri *trace-output*))))))))

(defun trace-inside-frame-p (name)
  (if (packagep name)
    (map-call-frames #'(lambda (p context)
                         (declare (ignore context))
                         (let* ((fn (cfp-lfun p))
                                (fname (and fn (function-name fn)))
                                (sym (typecase fname
                                       (method (method-name fname))
                                       (cons (and (setf-function-name-p fname) (cadr fname)))
                                       (symbol fname)
                                       (t nil))))
                           (when (and sym (eq (symbol-package sym) name))
                             (return-from trace-inside-frame-p t)))))
    (let ((fn (%encap-binding name)))
      (when fn
        (map-call-frames #'(lambda (p context)
                             (declare (ignore context))
                             (when (eq (cfp-lfun p) fn)
                               (return-from trace-inside-frame-p t))))))))

(defun trace-package-spec (spec)
  (when (or (stringp spec)
            (packagep spec)
            (and (consp spec) (eq (car spec) :package)))
    (let ((pkg (if (consp spec)
                 (destructuring-bind (pkg) (cdr spec) pkg)
                 spec)))
      (pkg-arg pkg))))

(defun trace-function (spec &rest args &key before after methods
                            (if t) (before-if t) (after-if t)
                            print print-before print-after
                            eval eval-before eval-after
                            break break-before break-after
                            backtrace backtrace-before backtrace-after
                            inside
                            define-if-not
                            ;; Some synonyms, just to be nice
                            (condition t) (if-before t) (if-after t) (wherein nil))

  (declare (dynamic-extent args))
  (let ((pkg (trace-package-spec spec)))
    (when pkg
      (return-from trace-function (apply #'%trace-package pkg args))))

  ;; A little bit of dwim, after all this _is_ an interactive tool...
  (unless (eq condition t)
    (setq if (if (eq if t) condition `(and ,if ,condition))))
  (unless (eq if-before t)
    (setq before-if (if (eq before-if t) if-before `(and ,before-if ,if-before))))
  (unless (eq if-after t)
    (setq after-if (if (eq after-if t) if-after `(and ,after-if ,if-after))))
  (when (and inside (trace-spec-p inside))
    (setq inside (list inside)))
  (when wherein
    (setq inside (append inside (if (trace-spec-p wherein) (list wherein) wherein))))
  (case break
    (:before (setq break-before (or break-before t) break nil))
    (:after (setq break-after (or break-after t) break nil)))
  (case backtrace
    (:before (setq backtrace-before (or backtrace-before t) backtrace nil))
    (:after (setq backtrace-after (or backtrace-after t) backtrace nil)))
  (case before
    (:break (setq before :print break-before t))
    (:backtrace (setq before :print backtrace-before t)))
  (case after
    (:break (setq after :print break-after t))
    (:backtrace (setq after :print backtrace-after t)))

  (when break
    (setq break-before (if break-before
                         `(and ,break ,break-before)
                         break))
    (setq break-after (if break-after
                        `(and ,break ,break-after)
                        break)))
  (unless backtrace-before
    (setq backtrace-before backtrace))
  (when (and (consp backtrace-before) (keywordp (car backtrace-before)))
    (setq backtrace-before `',backtrace-before))
  (when (and (consp backtrace-after) (keywordp (car backtrace-after)))
    (setq backtrace-after `',backtrace-after))

  (when (and (null before) (null after))
    (setq before :print)
    (setq after :print))
  (when (and (null before) backtrace-before)
    (setq before :print))

  (case before
    ((:print :default) (setq before #'trace-before)))
  (case after
    ((:print :default) (setq after #'trace-after)))

  (when (or (non-nil-symbol-p before) (functionp before))
    (setq before `',before))
  (when (or (non-nil-symbol-p after) (functionp after))
    (setq after `',after))

  (when inside
    (let ((tests (loop for spec in inside
                       as name = (or (trace-package-spec spec)
                                     (%encapsulation-thing spec nil nil)
                                     (error "Cannot trace inside ~s" spec))
                       collect `(trace-inside-frame-p ',name))))
      (setq if `(and ,if (or ,@tests)))))

  (setq eval-before `(,@(trace-print-body print-before)
                      ,@(trace-print-body print)
                      ,@(and eval-before `(,eval-before))
                      ,@(and eval `(,eval))
                      ,@(and before `((apply ,before ',spec args)))
                      ,@(trace-backtrace-body backtrace-before)
                      ,@(and break-before `((when ,break-before
                                              (force-output *trace-output*)
                                              (break "~s trace entry: ~s" ',spec args))))))
  (setq eval-after `(,@(trace-backtrace-body backtrace-after)
                     ,@(and after `((apply ,after ',spec vals)))
                     ,@(and eval `(,eval))
                     ,@(and eval-after `(,eval-after))
                     ,@(trace-print-body print)
                     ,@(trace-print-body print-after)
                     ,@(and break-after `((when ,break-after
                                            (force-output *trace-output*)
                                            (break "~s trace exit: ~s" ',spec vals))))))

  (prog1
      (block %trace-block
        ;;
        ;; see if we're a callback
        ;;
        (when (and (typep spec 'symbol)
                   (boundp spec)
                   (macptrp (symbol-value spec)))
          (let ((len (length %pascal-functions%))
                (sym-name (symbol-name spec)))
            (declare (fixnum len))
            (dotimes (i len)
              (let ((pfe (%svref %pascal-functions% i)))
                (when (and (vectorp pfe)
                           (string= sym-name (symbol-name (pfe.sym pfe))))
                  (when backtrace
                    (if (null before)
                      (setq before :print)))
                  (setf (pfe.trace-p pfe)
                        `(,@(if before `((:before . ,before)))
                          ,@(if after `((:after . ,after)))
                          ,@(if backtrace `((:backtrace . ,backtrace)))))
                  (push spec *trace-pfun-list*)))))
          (return-from %trace-block))
        ;;
        ;; now look for traceable methods.
        ;; It's possible, but not likely, that we will be both
        ;; a callback and a function or method, if so we trace both.
        ;; This isn't possible.
        ;; If we're neither, signal an error.
        ;;
        (let* ((trace-thing (%encapsulation-thing spec define-if-not)) def)
          (%untrace-1 trace-thing)
          (setq def (%encap-binding trace-thing))
          (when (and methods (typep def 'standard-generic-function))
            (dolist (m (%gf-methods def))
              (apply #'trace-function m args)))
          #+old
          (when step               ; just check if has interpreted def
            (if (typep def 'standard-generic-function)
              (let ((methods (%gf-methods def)))
                ; should we complain if no methods? naah
                (dolist (m methods) ; stick :step-gf in advice-when slot
                  (%trace m :step t)
                  (let ((e (function-encapsulation m)))
                    (when e (setf (encapsulation-advice-when e) :step-gf))))
                ; we choose to believe that before and after are intended for the gf
                (if  (or before after)
                  (setq step nil)                
                  (return-from %trace-block)))
              #|(uncompile-for-stepping trace-thing nil t)|#))
          (let* ((newsym (gensym "TRACE"))
                 (method-p (typep trace-thing 'method))
                 (newdef (trace-global-def 
                          spec newsym if before-if eval-before after-if eval-after method-p)))
            (when method-p
              (copy-method-function-bits def newdef))
            (encapsulate trace-thing newdef 'trace spec newsym))))
    (when *trace-hook*
      (apply *trace-hook* spec args))))


(defun %traced-p (thing)
  (let ((cap (get-encapsulation thing)))
    (and cap (eq (encapsulation-type cap) 'trace))))

(defmacro untrace (&rest syms)
  "Remove tracing from the specified functions. With no args, untrace all
   functions."
  (if syms
    `(%untrace-0 ',syms)
    `(%untrace-all)))

(defun %untrace-0 (syms)
  (let (val x)
    (dolist (symbol syms)
      (setq x (%untrace symbol))
      (when x (push x val)))
    val))

(defun %untrace-all ()
  (dolist (pfun *trace-pfun-list*)
    (%untrace pfun)
    (when *untrace-hook*
      (funcall *untrace-hook* pfun)))
  (loop for cap being the hash-value of *encapsulation-table*
    when (eq (encapsulation-type cap) 'trace)
    collect (let ((spec (encapsulation-spec cap)))
              (remove-encapsulation cap)
              (when *untrace-hook*
                (funcall *untrace-hook* spec))
              spec)))

(defun %untrace (sym &aux val)
  (when (and (consp sym)(consp (car sym)))
    (setq sym (car sym)))
  (cond
   ((and (typep sym 'symbol)
         (boundp sym)
         (macptrp (symbol-value sym)))
    (%untrace-pfun sym))
   (t 
    (let* ((trace-thing (%encapsulation-thing sym))
           (def (%encap-binding trace-thing)))
      (when (typep def 'standard-generic-function)
        (let ((methods (%gf-methods def)))
          (dolist (m methods)
            (let ((cap (get-encapsulation m)))
              (when (and cap (eq (encapsulation-advice-when cap) :step-gf))
                (remove-encapsulation cap)
                (push m val))))))
      ; gf could have first been traced :step, and then just plain traced
      ; maybe the latter trace should undo the stepping??
      (let ((spec (%untrace-1 trace-thing)))
        (when spec
          (push spec val))))))
  (when *untrace-hook*
    (funcall *untrace-hook* sym))
  (if (null (cdr val)) (car val) val))

;; thing is a symbol or method - def is current definition
;; we already know its traced
(defun %untrace-1 (thing)
  (let ((cap (get-encapsulation thing)))
    (when (and cap (eq (encapsulation-type cap) 'trace))
      (remove-encapsulation cap)
      (encapsulation-spec cap))))

(defun %untrace-pfun (sym)
  (let ((len (length %pascal-functions%))
        (sym-name (symbol-name sym)))
    (declare (fixnum len))
    (dotimes (i len)
      (let ((pfe (%svref %pascal-functions% i)))
        (when (and (vectorp pfe)
                   (string= sym-name (symbol-name (pfe.sym pfe))))
          (setf (pfe.trace-p pfe) nil
                *trace-pfun-list* (remove sym *trace-pfun-list*))
          (return-from %untrace-pfun sym))))
    nil))



(defmacro trace (&rest syms)
  "TRACE {Option Global-Value}* { Name | (Name {Option Value}*) }*

TRACE is a debugging tool that provides information when specified
functions are called."
  (if syms
    (let ((options (loop while (keywordp (car syms))
                     nconc (list (pop syms) (pop syms)))))
      `(%trace-0 ',syms ',options))
    `(%trace-list)))

(defun trace-spec-p (arg)
  (or (atom arg)
      (memq (car arg) '(:method setf :package))))


(defun %trace-0 (syms &optional global-options)
  (dolist (spec syms)
    (if (trace-spec-p spec)
      (apply #'trace-function spec global-options)
      (apply #'trace-function (append spec global-options)))))

(defun %trace-list ()
  (let (res)
    (loop for x being the hash-value of *encapsulation-table*
	 when (eq (encapsulation-type x) 'trace)
	 do (push (encapsulation-spec x) res))
    (dolist (x *trace-pfun-list*)
      (push x res))
    res))

(defmacro with-traces (syms &body body)
 `(unwind-protect
       (progn
         (let ((*trace-output* (make-broadcast-stream)))
           ;; if you're tracing ccl internals you'll get trace output as it encapsulates the
           ;; functions so hide all the trace output while eval'ing the trace form itself.
           (trace ,@syms))
         ,@body)
    (untrace ,@syms)))

;; this week def is the name of an uninterned gensym whose fn-cell is original def

(defun trace-global-def (sym def if before-if eval-before after-if eval-after &optional method-p)
  (let ((saved-method-var (gensym))
        (enable (gensym))
        do-it)
    (setq do-it
          (cond #+old (step
                       (setq step-it            
                             `(step-apply-simple ',def args))
                       (if (eq step t)
                         step-it
                         `(if (apply ',step ',sym args) ; gaak
                           ,step-it
                           ,(if (and before method-p)
                                `(apply-with-method-context ,saved-method-var (symbol-function ',def) args)
                                `(apply ',def args)))))
                (t (if (and eval-before method-p)
                     `(apply-with-method-context ,saved-method-var (symbol-function ',def) args)
                     `(apply ',def args)))))
    (compile-named-function-warn
     `(lambda (,@(and eval-before method-p `(&method ,saved-method-var))
               &rest args) ; if methodp put &method on front of args - vs get-saved-method-var?
       (declare (dynamic-extent args))
       (declare (ftype function ,def))
       (let ((*trace-level* (1+ *trace-level*))
             (,enable ,if))
         (declare (special *trace-enable* *trace-level*))
         ,(when eval-before
           `(when (and ,enable ,before-if *trace-enable*)
             (when *trace-print-hook*
               (funcall *trace-print-hook* ',sym t))
             (let* ((*trace-enable* nil))
               ,@eval-before)
             (when *trace-print-hook*
               (funcall *trace-print-hook* ',sym nil))))
         ,(if eval-after
           `(let ((vals (multiple-value-list ,do-it)))
             (when (and ,enable ,after-if *trace-enable*)
               (when *trace-print-hook* 
                 (funcall *trace-print-hook* ',sym t))
               (let* ((*trace-enable* nil))
                 ,@eval-after)
               (when *trace-print-hook* 
                 (funcall *trace-print-hook* ',sym nil)))
             (values-list vals))
           do-it)))
     `(traced ,sym)
     :keep-symbols t)))

; &method var tells compiler to bind var to contents of next-method-context
(defun advise-global-def (def when stuff &optional method-p dynamic-extent-arglist)
  (let* ((saved-method-var (gensym)))
    `(lambda (,@(if (and method-p (neq when :after))
                  `(&method ,saved-method-var))
              &rest arglist)
       ,@(and dynamic-extent-arglist '((declare (dynamic-extent arglist))))
       (declare (ftype function ,def))
       (declare (ignorable arglist))
       (let ()
         ,(ecase
            when
            (:before
             `(block nil
                ,stuff                  
                (return ,(if method-p
                           `(apply-with-method-context ,saved-method-var (symbol-function ',def) arglist)
                           `(apply ',def arglist)))))
            (:after         
             `(block nil
                (let ((values (multiple-value-list (apply (function ,def) arglist))))
                  ;(declare (dynamic-extent values))
                  ,stuff
                  (return (values-list values)))))
            (:around
             ;; stuff is e.g. (+ 5 (:do-it))
             (if method-p 
               `(macrolet ((:do-it ()
                             `(apply-with-method-context ,',saved-method-var 
                                                         (symbol-function ',',def)
                                                         arglist)))
                  (block nil
                    (return  ,stuff)))
               `(macrolet ((:do-it ()
                             `(apply (function ,',def) arglist)))
                  (block nil
                    (return  ,stuff))))))))))


(defun compile-named-function-warn (fn name &rest keys)
  (declare (dynamic-extent keys))
  (multiple-value-bind (result warnings) (apply #'compile-named-function fn :name name keys)
    (when warnings 
      (let ((first t))
        (dolist (w warnings)
          (signal-compiler-warning w first nil nil nil)
          (setq first nil))))
    result))

       
(defun %advised-p (thing)
  (loop for nx = thing then (encapsulation-symbol cap)
    as cap = (get-encapsulation nx) while cap
    thereis (eq (encapsulation-type cap) 'advice)))

(defun %advice-encapsulations (thing when advice-name)
  (loop for nx = thing then (encapsulation-symbol cap)
    as cap = (get-encapsulation nx) while cap
    when (and (eq (encapsulation-type cap) 'advice)
              (or (null when) (eq when (encapsulation-advice-when cap)))
              (or (null advice-name) (equal advice-name (encapsulation-advice-name cap))))
    collect cap))

(defun advise-2 (newdef newsym method-p function-spec when advice-name define-if-not)      
  (let* ((advise-thing (%encapsulation-thing function-spec define-if-not))
         orig-sym)
    (let ((capsules (%advice-encapsulations advise-thing when advice-name)))
      (when capsules 
        (unadvise-capsules capsules)))
    (when (%traced-p advise-thing)
      ; make traced call advised
      (setq orig-sym
            (encapsulation-symbol (get-encapsulation advise-thing))))
    (lfun-name newdef `(advised ',function-spec))
    (if method-p (copy-method-function-bits (%encap-binding advise-thing) newdef))
    (encapsulate (or orig-sym advise-thing) newdef 'advice function-spec newsym advice-name when)
    newdef))

(defmacro advise (function form &key (when :before) name define-if-not dynamic-extent-arglist)
  (let* ((newsym (gensym "ADVICE"))
         ; WAS typep advise-thing 'method
         (method-p (or (typep function 'method) ; can this happen?
                       (and (consp function)(eq (car function) :method))))
         (newdef (advise-global-def newsym when form method-p dynamic-extent-arglist)))
      `(advise-2 ,newdef ',newsym ,method-p ',function ',when ',name
                 ,define-if-not)))

(defmacro advisedp (function-spec &key when name)
  `(advisedp-1 ',function-spec ',when ',name))

(defun encapsulation-advice-spec (cap)
  (list (encapsulation-spec cap)
        (encapsulation-advice-when cap)
        (encapsulation-advice-name cap)))
  
(defun advisedp-1 (function-spec when name)
  (cond ((eq t function-spec)
         (loop for c being the hash-value of *encapsulation-table*
           when (and (eq (encapsulation-type c) 'advice)
                     (or (null when)(eq when (encapsulation-advice-when c)))
                     (or (null name)(equal name (encapsulation-advice-name c))))
           collect (encapsulation-advice-spec c)))
        (t (let* ((advise-thing (%encapsulation-thing function-spec))
                  (capsules (%advice-encapsulations advise-thing when name)))
             (mapcar #'encapsulation-advice-spec capsules)))))

(defun %unadvise-1 (function-spec &optional when advice-name ignore)
  (declare (ignore ignore))
  (let ((advise-thing (%encapsulation-thing function-spec)))
    (let ((capsules (%advice-encapsulations advise-thing when advice-name)))
      (when capsules (unadvise-capsules capsules)))))

(defun unadvise-capsules (capsules)
  (let (val)
    (dolist (capsule capsules)
        (push (encapsulation-advice-spec capsule) val)
        (remove-encapsulation capsule))
    val))

(defmacro unadvise (function &key when name)
  (cond ((neq function t)
         `(%unadvise-1 ',function ',when ',name))
        (t `(%unadvise-all ',when ',name))))

(defun %unadvise-all (&optional when name)
  (loop for cap being the hash-value of *encapsulation-table*
    when (and (eq (encapsulation-type cap) 'advice)
              (or (null when)(eq when (encapsulation-advice-when cap)))
              (or (null name)(equal name (encapsulation-advice-name cap))))
    collect (progn
              (remove-encapsulation cap)
              (encapsulation-advice-spec cap))))

;; Called from %defun. Return t if we defined it, nil otherwise
(defun %defun-encapsulated-maybe (name newdef)
  (assert (not (get-encapsulation newdef)))
  (let ((old-def (fboundp name)) cap)
    (when (and old-def (setq cap (get-encapsulation name)))
      (cond ((or (and *loading-files* *loading-removes-encapsulation*)
                 ;; redefining a gf as a fn.
                 (typep old-def 'standard-generic-function))
             (forget-encapsulations name)
             nil)
            (t (set-unencapsulated-definition cap newdef)
               T)))))

;; Called from clos when change dcode
(defun %set-encapsulated-gf-dcode (gf new-dcode)
  (loop with cap = (get-encapsulation gf)
    for gf-copy = (encapsulation-old-def cap)
    as cur-dcode = (%gf-dcode gf-copy)
    do (setq cap (get-encapsulation cur-dcode))
    ;; refresh all the gf copies, in case other info in gf changed
    do (%copy-function gf gf-copy)
    do (setf (%gf-dcode gf-copy) (if cap cur-dcode new-dcode))
    while cap))

;; Called from clos when oldmethod is being replaced by newmethod in a gf.
(defun %move-method-encapsulations-maybe (oldmethod newmethod &aux cap)
  (unless (eq oldmethod newmethod)
    (cond ((and *loading-removes-encapsulation* *loading-files*)
           (when (%traced-p oldmethod)
             (warn "~%... Untracing ~s" (%untrace-1 oldmethod)))
           (when (%advised-p oldmethod)
             (format t "~%... Unadvising ~s" (%unadvise-1 oldmethod))))
          (t (when (setq cap (get-encapsulation oldmethod))
               (let* ((old-inner-def (find-unencapsulated-definition oldmethod))
                      (newdef (%method-function newmethod))
                      (olddef (%method-function oldmethod)))
                 ;; make last encapsulation call new definition
                 (set-unencapsulated-definition cap newdef)
                 (setf (%method-function newmethod) olddef)
                 (set-encapsulation-owner olddef newmethod)
                 (setf (%method-function oldmethod) old-inner-def)
                 (loop
                   for def = olddef then (encapsulation-old-def cap)
                   for cap = (get-encapsulation def) while cap
                   do (copy-method-function-bits newdef def))))))))

#|
        Change History (most recent last):
        2       12/29/94        akh     merge with d13
|# ;(do not edit past this line!!)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/encapsulate.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/foreign-types.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2001-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; This is a slightly-watered-down version of CMUCL's ALIEN-TYPE system.

(in-package "CCL")

(defstruct (interface-dir
	     (:include dll-node)
	    )
  (name)
  (subdir)
  (constants-interface-db-file)
  (functions-interface-db-file)
  (records-interface-db-file)
  (types-interface-db-file)
  (vars-interface-db-file)
  (objc-classes-interface-db-file)
  (objc-methods-interface-db-file))

(defmethod print-object ((d interface-dir) stream)
  (print-unreadable-object (d stream :type t :identity t)
    (format stream "~s ~s"
            (interface-dir-name d)
            (interface-dir-subdir d))))

;;; We can't reference foreign types early in the cold load,
;;; but we want things like RLET to be able to set a pointer's
;;; type based on the foreign-type's "ordinal".  We therefore
;;; seem to have to arrange that certain types have fixed,
;;; "canonical" ordinals.  I doubt if we need more than a handful
;;; of these, but let's burn 100

(defconstant max-canonical-foreign-type-ordinal 100)

;;; Some foreign types are "common" (POSIXy things that're available
;;; on most platforms; some are very platform-specific.  It's getting
;;; to be a mess to keep those separate by reader conditionalization,
;;; so use the first 50 ordinals for "common" foreign types and the
;;; next 50 for platform-specific stuff.

(defconstant max-common-foreign-type-ordinal 50)

;;; This is intended to try to encapsulate foreign type stuff, to
;;; ease cross-compilation (among other things.)

(defstruct (foreign-type-data (:conc-name ftd-)
			      (:constructor make-ftd))
  (translators (make-hash-table :test #'eq))
  (kind-info (make-hash-table :test #'eq))
  (definitions (make-hash-table :test #'eq))
  (struct-definitions (make-hash-table :test #'eq))
  (union-definitions (make-hash-table :test #'eq))
  ;; Do we even use this ?
  (enum-definitions (make-hash-table :test #'eq))
  (interface-db-directory ())
  (interface-package-name ())
  (external-function-definitions (make-hash-table :test #'eq))
  (dirlist (make-dll-header))
  (attributes ())
  (ff-call-expand-function ())
  (ff-call-struct-return-by-implicit-arg-function ())
  (callback-bindings-function ())
  (callback-return-value-function ())
  (ordinal max-canonical-foreign-type-ordinal)
  (ordinal-lock (make-lock))
  (ordinal-types (make-hash-table :test #'eq :weak :value))
  (pointer-types (make-hash-table :test #'eq))
  (array-types (make-hash-table :test #'equal))
  (platform-ordinal-types ()))




(defvar *host-ftd* (make-ftd
                    :interface-db-directory
                    #.(ecase (backend-name *target-backend*)
                        (:linuxppc32 "ccl:headers;")
                        (:darwinppc32 "ccl:darwin-headers;")
                        (:darwinppc64 "ccl:darwin-headers64;")
                        (:linuxppc64 "ccl:headers64;")
			(:darwinx8632 "ccl:darwin-x86-headers;")
                        (:linuxx8664 "ccl:x86-headers64;")
                        (:darwinx8664 "ccl:darwin-x86-headers64;")
                        (:freebsdx8664 "ccl:freebsd-headers64;")
                        (:solarisx8664 "ccl:solarisx64-headers;")
                        (:win64 "ccl:win64-headers;")
                        (:linuxx8632 "ccl:x86-headers;")
                        (:win32 "ccl:win32-headers;")
                        (:solarisx8632 "ccl:solarisx86-headers;")
                        (:freebsdx8632 "ccl:freebsd-headers;")
                        (:linuxarm "ccl:arm-headers;")
                        (:darwinarm "ccl:darwin-arm-headers;")
                       (:androidarm "ccl:android-headers;"))
                    :interface-package-name
                    #.(ftd-interface-package-name *target-ftd*)
                    :attributes
                    '(:bits-per-word #+64-bit-target 64 #+32-bit-target 32
                      #+win64-target :bits-per-long #+win64-target 32
                      :signed-char #+darwinppc-target t #-darwinppc-target nil
                      :struct-by-value #+darwinppc-target t #-darwinppc-target nil
                      :struct-return-in-registers #+(or (and darwinppc-target 64-bit-target)) t #-(or (and darwinppc-target 64-bit-target)) nil
                      :struct-return-explicit  #+(or (and darwinppc-target 64-bit-target)) t #-(or (and darwinppc-target 64-bit-target)) nil
                      :struct-by-value-by-field  #+(or (and darwinppc-target 64-bit-target)) t #-(or (and darwinppc-target 64-bit-target)) nil
                    
                      :prepend-underscores #+darwinppc-target t #-darwinppc-target nil)
                    :ff-call-expand-function
                    'os::expand-ff-call
                    :ff-call-struct-return-by-implicit-arg-function
                    'os::record-type-returns-structure-as-first-arg
                    :callback-bindings-function
                    'os::generate-callback-bindings
                    :callback-return-value-function
                    'os::generate-callback-return-value
                    :platform-ordinal-types
                    (case (backend-name *target-backend*)
                        (:win64 '((:struct :_stat64)))
                        (:win32 '((:struct :__stat64)))
                        (t
                         (case (target-os-name *target-backend*)
                           (:darwin '((:struct :host_basic_info)))
                           (:solaris '((:struct :lifnum)
                                       (:struct :lifconf)))
                           (t ()))))))
                    
(defvar *target-ftd* *host-ftd*)
(setf (backend-target-foreign-type-data *host-backend*)
      *host-ftd*)

(defun next-foreign-type-ordinal (&optional (ftd *target-ftd*))
  (with-lock-grabbed ((ftd-ordinal-lock ftd))
    (incf (ftd-ordinal ftd))))


(defmacro do-interface-dirs ((dir &optional (ftd '*target-ftd*)) &body body)
  `(do-dll-nodes  (,dir (ftd-dirlist ,ftd))
    ,@body))

(defun find-interface-dir (name &optional (ftd *target-ftd*))
  (do-interface-dirs (d ftd)
    (when (eq name (interface-dir-name d))
      (return d))))

(defun require-interface-dir (name &optional (ftd *target-ftd*))
  (or (find-interface-dir name ftd)
      (error "Interface directory ~s not found" name)))

(defun ensure-interface-dir (name &optional (ftd *target-ftd*))
  (or (find-interface-dir name ftd)
      (let* ((d (make-interface-dir
		 :name name
		 :subdir (make-pathname
			  :directory
			  `(:relative ,(string-downcase name))))))
	(append-dll-node d (ftd-dirlist ftd)))))

(defun use-interface-dir (name &optional (headers-dir nil) (ftd *target-ftd*))
  "Tell Clozure CL to add the interface directory denoted by dir-id to the
list of interface directories which it consults for foreign type and
function information. Arrange that that directory is searched before any
others.

Optional headers-dir arg may be used to specify a non-standard location for
the interface directory.

Note that use-interface-dir merely adds an entry to a search list. If the
named directory doesn't exist in the file system or doesn't contain a set
of database files, a runtime error may occur when Clozure CL tries to open some
database file in that directory, and it will try to open such a database
file whenever it needs to find any foreign type or function information.
unuse-interface-dir may come in handy in that case."
  (when (foreign-type-data-p headers-dir) ;; backward compat
    (shiftf ftd headers-dir nil))
  (let* ((d (ensure-interface-dir name ftd)))
    (move-dll-nodes d (ftd-dirlist ftd))
    (when headers-dir
      (let ((target-dir (merge-pathnames (make-pathname :directory `(:relative ,@(cdb-subdirectory-path ftd))) headers-dir)))
        (setf (interface-dir-subdir d) (merge-pathnames (interface-dir-subdir d) target-dir))))
    d))

(defun unuse-interface-dir (name &optional (ftd *target-ftd*))
  "Tell Clozure CL to remove the interface directory denoted by dir-id from
the list of interface directories which are consulted for foreign type
and function information. Returns T if the directory was on the search
list, NIL otherwise."
  (let* ((d (find-interface-dir name ftd)))
    (when d
      (remove-dll-node d)
      t)))


(use-interface-dir :libc)


;;;; Utility functions.

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun align-offset (offset alignment)
    (let ((extra (rem offset alignment)))
      (if (zerop extra) offset (+ offset (- alignment extra)))))

  (defun guess-alignment (bits)
    (cond ((null bits) nil)
          ((> bits 32) 64)
          ((> bits 16) 32)
          ((> bits 8) 16)
          ((= bits 8) 8)
          (t 1)))

  (defstruct foreign-type-class
    (name nil #|:type symbol|#)
    (include nil :type (or null foreign-type-class))
    (unparse nil :type (or null function))
    (type= nil :type (or null function))
    (lisp-rep nil :type (or null function))
    (foreign-rep nil :type (or null function))
    (extract-gen nil :type (or null function))
    (deposit-gen nil :type (or null function))
    (naturalize-gen nil :type (or null function))
    (deport-gen nil :type (or null function))
    ;; Cast?
    (arg-tn nil :type (or null function))
    (result-tn nil :type (or null function))
    (subtypep nil :type (or null function)))

  (defvar *foreign-type-classes* (make-hash-table :test #'eq))

  (defun info-foreign-type-translator (x &optional (ftd *target-ftd*))
    (gethash (make-keyword x) (ftd-translators ftd)))
  (defun (setf info-foreign-type-translator) (val x &optional (ftd *target-ftd*))
    (setf (gethash (make-keyword x) (ftd-translators ftd)) val))

  (defun note-foreign-type-ordinal (type ftd)
    (let* ((ordinal (and type (foreign-type-ordinal type))))
      (when (and ordinal (not (eql 0 ordinal)))
        (with-lock-grabbed ((ftd-ordinal-lock ftd))
          (setf (gethash ordinal (ftd-ordinal-types ftd)) type)))))
  
  (defun info-foreign-type-kind (x &optional (ftd *target-ftd*))
    (if (info-foreign-type-translator x ftd)
      :primitive
      (or (gethash (make-keyword x) (ftd-kind-info ftd)) :unknown)))
  (defun (setf info-foreign-type-kind) (val x &optional (ftd *target-ftd*))
    (setf (gethash (make-keyword x) (ftd-kind-info ftd)) val))
		   
  (defun info-foreign-type-definition (x &optional (ftd *target-ftd*))
    (gethash (make-keyword x) (ftd-definitions ftd)))
  (defun (setf info-foreign-type-definition) (val x &optional (ftd *target-ftd*))
    (note-foreign-type-ordinal val ftd)
    (setf (gethash (make-keyword x) (ftd-definitions ftd)) val))
  (defun clear-info-foreign-type-definition (x &optional (ftd *target-ftd*))
    (remhash (make-keyword x) (ftd-definitions ftd)))

  (defun info-foreign-type-struct (x &optional (ftd *target-ftd*))
    (gethash (make-keyword x) (ftd-struct-definitions ftd)))
  (defun (setf info-foreign-type-struct) (val x &optional (ftd *target-ftd*))
    (let* ((name (make-keyword x)))
      (when (gethash name (ftd-union-definitions ftd))
        (cerror "Define ~s as a struct type"
                "~s is already defined as a union type"
                name)
        (remhash name (ftd-union-definitions ftd)))
      (note-foreign-type-ordinal val ftd)
      (setf (gethash name (ftd-struct-definitions ftd)) val)))

  (defun info-foreign-type-union (x &optional (ftd *target-ftd*))
    (gethash (make-keyword x) (ftd-union-definitions ftd)))
  (defun (setf info-foreign-type-union) (val x  &optional (ftd *target-ftd*))
    (let* ((name (make-keyword x)))
      (when (gethash name (ftd-struct-definitions ftd))
        (cerror "Define ~s as a union type"
                "~s is already defined as a struct type"
                name)
        (remhash name (ftd-struct-definitions ftd)))
    (note-foreign-type-ordinal val ftd)
    (setf (gethash name (ftd-union-definitions ftd)) val)))

  (defun info-foreign-type-enum (x  &optional (ftd *target-ftd*))
    (gethash (make-keyword x) (ftd-enum-definitions ftd)))
  (defun (setf info-foreign-type-enum) (val x &optional (ftd *target-ftd*))
    (note-foreign-type-ordinal val ftd)
    (setf (gethash (make-keyword x) (ftd-enum-definitions ftd)) val))

  (defun require-foreign-type-class (name)
    (or (gethash name  *foreign-type-classes*)
        (error "Unknown foreign type class ~s" name)))

  (defun find-or-create-foreign-type-class (name include)
    (let* ((old (gethash name *foreign-type-classes*))
           (include-class (if include (require-foreign-type-class include))))
      (if old
        (setf (foreign-type-class-name old) include-class)
        (setf (gethash name *foreign-type-classes*)
              (make-foreign-type-class :name name :include include-class)))))


  (defconstant method-slot-alist
    '((:unparse . foreign-type-class-unparse)
      (:type= . foreign-type-class-type=)
      (:subtypep . foreign-type-class-subtypep)
      (:lisp-rep . foreign-type-class-lisp-rep)
      (:foreign-rep . foreign-type-class-foreign-rep)
      (:extract-gen . foreign-type-class-extract-gen)
      (:deposit-gen . foreign-type-class-deposit-gen)
      (:naturalize-gen . foreign-type-class-naturalize-gen)
      (:deport-gen . foreign-type-class-deport-gen)
      ;; Cast?
      (:arg-tn . foreign-type-class-arg-tn)
      (:result-tn . foreign-type-class-result-tn)))

  (defun method-slot (method)
    (cdr (or (assoc method method-slot-alist)
             (error "No method ~S" method))))
  )

(defmethod print-object ((f foreign-type-class) out)
  (print-unreadable-object (f out :type t :identity t)
    (prin1 (foreign-type-class-name f) out)))


;;; We define a keyword "BOA" constructor so that we can reference the slots
;;; names in init forms.
;;;
(defmacro def-foreign-type-class ((name &key include include-args) &rest slots)
  (let ((defstruct-name
	 (intern (concatenate 'string "FOREIGN-" (symbol-name name) "-TYPE"))))
    (multiple-value-bind
	(include include-defstruct overrides)
	(etypecase include
	  (null
	   (values nil 'foreign-type nil))
	  (symbol
	   (values
	    include
	    (intern (concatenate 'string
				 "FOREIGN-" (symbol-name include) "-TYPE"))
	    nil))
	  (list
	   (values
	    (car include)
	    (intern (concatenate 'string
				 "FOREIGN-" (symbol-name (car include)) "-TYPE"))
	    (cdr include))))
      `(progn
	 (eval-when (:compile-toplevel :load-toplevel :execute)
	   (find-or-create-foreign-type-class ',name ',(or include 'root)))
	 (defstruct (,defstruct-name
			(:include ,include-defstruct
				  (class ',name)
				  ,@overrides)
			(:constructor
			 ,(intern (concatenate 'string "MAKE-"
					       (string defstruct-name)))
			 (&key class bits alignment
			       ,@(mapcar #'(lambda (x)
					     (if (atom x) x (car x)))
					 slots)
			       ,@include-args)))
	   ,@slots)))))

(defmacro def-foreign-type-method ((class method) lambda-list &rest body)
  (let ((defun-name (intern (concatenate 'string
					 (symbol-name class)
					 "-"
					 (symbol-name method)
					 "-METHOD"))))
    `(progn
       (defun ,defun-name ,lambda-list
	 ,@body)
       (setf (,(method-slot method) (require-foreign-type-class ',class))
	     #',defun-name))))

(defmacro invoke-foreign-type-method (method type &rest args)
  (let ((slot (method-slot method)))
    (once-only ((type type))
      `(funcall (do ((class (require-foreign-type-class (foreign-type-class ,type))
			    (foreign-type-class-include class)))
		    ((null class)
		     (error "Method ~S not defined for ~S"
			    ',method (foreign-type-class ,type)))
		  (let ((fn (,slot class)))
		    (when fn
		      (return fn))))
		,type ,@args))))


;;;; Foreign-type defstruct.

(eval-when (:compile-toplevel :load-toplevel :execute)
  (find-or-create-foreign-type-class 'root nil))

(defstruct (foreign-type
	    (:constructor make-foreign-type (&key class bits alignment ordinal))
	    (:print-object
	     (lambda (s out)
	       (print-unreadable-object (s out :type t :identity t)
		 (prin1 (unparse-foreign-type s) out)))))
  (class 'root :type symbol)
  (bits nil :type (or null unsigned-byte))
  (alignment (guess-alignment bits) :type (or null unsigned-byte))
  (ordinal (next-foreign-type-ordinal)))



(defmethod make-load-form ((s foreign-type) &optional env)
  (declare (ignore env))
  (if (eq s *void-foreign-type*)
    '*void-foreign-type*
    `(parse-foreign-type ',(unparse-foreign-type s))))




;;;; Type parsing and unparsing.

(defvar *auxiliary-type-definitions* nil)
(defvar *new-auxiliary-types*)

;;; WITH-AUXILIARY-FOREIGN-TYPES -- internal.
;;;
;;; Process stuff in a new scope.
;;;
(defmacro with-auxiliary-foreign-types (&body body)
  `(let ((*auxiliary-type-definitions*
	  (if (boundp '*new-auxiliary-types*)
	      (append *new-auxiliary-types* *auxiliary-type-definitions*)
	      *auxiliary-type-definitions*))
	 (*new-auxiliary-types* nil))
     ,@body))

;;; PARSE-FOREIGN-TYPE -- public
;;;
(defun parse-foreign-type (type &optional (ftd *target-ftd*))
  "Parse the list structure TYPE as a foreign type specifier and return
   the resultant foreign-type structure."
  (if (boundp '*new-auxiliary-types*)
    (%parse-foreign-type type ftd)
    (let ((*new-auxiliary-types* nil))
      (%parse-foreign-type type ftd))))

(defun %parse-foreign-type (type &optional (ftd *target-ftd*))
  (if (consp type)
    (let ((translator (info-foreign-type-translator (car type) ftd)))
      (unless translator
        (error "Unknown foreign type: ~S" type))
      (funcall translator type nil))
    (case (info-foreign-type-kind type)
      (:primitive
       (let ((translator (info-foreign-type-translator type ftd)))
         (unless translator
           (error "No translator for primitive foreign type ~S?" type))
      (funcall translator (list type) nil)))
      (:defined
          (or (info-foreign-type-definition type ftd)
              (error "Definition missing for foreign type ~S?" type)))
      (:unknown
       (let* ((loaded (load-foreign-type type ftd)))
	 (if loaded
	   (setq type loaded)))
       (or (info-foreign-type-definition type ftd)
           (error "Unknown foreign type: ~S" type))))))

(defun auxiliary-foreign-type (kind name &optional (ftd *target-ftd*))
  (declare (ignore ftd))
  (flet ((aux-defn-matches (x)
           (and (eq (first x) kind) (eq (second x) name))))
    (let ((in-auxiliaries
           (or (find-if #'aux-defn-matches *new-auxiliary-types*)
               (find-if #'aux-defn-matches *auxiliary-type-definitions*))))
      (if in-auxiliaries
        (values (third in-auxiliaries) t)))))

(defun %set-auxiliary-foreign-type (kind name defn &optional (ftd *target-ftd*))
  (declare (ignore ftd))
  (flet ((aux-defn-matches (x)
	   (and (eq (first x) kind) (eq (second x) name))))
    (when (find-if #'aux-defn-matches *new-auxiliary-types*)
      (error "Attempt to multiple define ~A ~S." kind name))
    (when (find-if #'aux-defn-matches *auxiliary-type-definitions*)
      (error "Attempt to shadow definition of ~A ~S." kind name)))
  (push (list kind name defn) *new-auxiliary-types*)
  defn)

(defsetf auxiliary-foreign-type %set-auxiliary-foreign-type)


(defun ensure-foreign-type (x)
  (if (typep x 'foreign-type)
    x
    (parse-foreign-type x)))

;;; *record-type-already-unparsed* -- internal
;;;
;;; Holds the list of record types that have already been unparsed.  This is
;;; used to keep from outputing the slots again if the same structure shows
;;; up twice.
;;; 
(defvar *record-types-already-unparsed*)

;;; UNPARSE-FOREIGN-TYPE -- public.
;;; 
(defun unparse-foreign-type (type)
  "Convert the foreign-type structure TYPE back into a list specification of
   the type."
  (declare (type foreign-type type))
  (let ((*record-types-already-unparsed* nil))
    (%unparse-foreign-type type)))

;;; %UNPARSE-FOREIGN-TYPE -- internal.
;;;
;;; Does all the work of UNPARSE-FOREIGN-TYPE.  It's seperate because we need
;;; to recurse inside the binding of *record-types-already-unparsed*.
;;; 
(defun %unparse-foreign-type (type)
  (invoke-foreign-type-method :unparse type))




;;;; Foreign type defining stuff.

(defmacro def-foreign-type-translator (name lambda-list &body body &environment env)
  (expand-type-macro '%def-foreign-type-translator name lambda-list body env))


(defun %def-foreign-type-translator (name translator docs)
  (declare (ignore docs))
  (setf (info-foreign-type-translator name) translator)
  (clear-info-foreign-type-definition name)
  #+nil
  (setf (documentation name 'foreign-type) docs)
  name)


(defmacro def-foreign-type (name type)
  "If name is non-NIL, define name to be an alias for the foreign type
specified by foreign-type-spec. If foreign-type-spec is a named structure
or union type, additionally defines that structure or union type.

If name is NIL, foreign-type-spec must be a named foreign struct or union
definition, in which case the foreign structure or union definition is put
in effect.

Note that there are two separate namespaces for foreign type names, one for
the names of ordinary types and one for the names of structs and unions.
Which one name refers to depends on foreign-type-spec in the obvious manner."
  (with-auxiliary-foreign-types
    (let ((foreign-type (parse-foreign-type type)))
      `(eval-when (:compile-toplevel :load-toplevel :execute)
	 ,@(when *new-auxiliary-types*
	     `((%def-auxiliary-foreign-types ',*new-auxiliary-types*)))
	 ,@(when name
	     `((%def-foreign-type ',name ',foreign-type)))))))

(defun %def-auxiliary-foreign-types (types)
  (dolist (info types)
    (destructuring-bind (kind name defn) info
      (macrolet ((frob (accessor)
		   `(let ((old (,accessor name)))
		      (unless (or (null old) (foreign-type-= old defn))
			(warn "Redefining ~A ~S to be:~%  ~S,~%was:~%  ~S"
			      kind name defn old))
		      (setf (,accessor name) defn))))
	(ecase kind
	  (:struct (frob info-foreign-type-struct))
	  (:union (frob info-foreign-type-union))
	  (:enum (frob info-foreign-type-enum)))))))

(defun %def-foreign-type (name new &optional (ftd *target-ftd*))
  (ecase (info-foreign-type-kind name ftd)
    (:primitive
     (error "~S is a built-in foreign type." name))
    (:defined
     (let ((old (info-foreign-type-definition name ftd)))
       (unless (or (null old) (foreign-type-= new old))
	 (warn "Redefining ~S to be:~%  ~S,~%was~%  ~S" name
	       (unparse-foreign-type new) (unparse-foreign-type old)))))
    (:unknown))
  (setf (info-foreign-type-definition name ftd) new)
  (setf (info-foreign-type-kind name ftd) :defined)
  name)



;;;; Interfaces to the different methods

(defun foreign-type-= (type1 type2)
  "Return T iff TYPE1 and TYPE2 describe equivalent foreign types."
  (or (eq type1 type2)
      (and (eq (foreign-type-class type1)
	       (foreign-type-class type2))
	   (invoke-foreign-type-method :type= type1 type2))))

(defun foreign-subtype-p (type1 type2)
  "Return T iff the foreign type TYPE1 is a subtype of TYPE2.  Currently, the
   only supported subtype relationships are is that any pointer type is a
   subtype of (* t), and any array type first dimension will match 
   (array <eltype> nil ...).  Otherwise, the two types have to be
   FOREIGN-TYPE-=."
  (or (eq type1 type2)
      (invoke-foreign-type-method :subtypep type1 type2)))

(defun foreign-typep (object type)
  "Return T iff OBJECT is a foreign of type TYPE."
  (let ((lisp-rep-type (compute-lisp-rep-type type)))
    (if lisp-rep-type
	(typep object lisp-rep-type))))


(defun compute-naturalize-lambda (type)
  `(lambda (foreign ignore)
     (declare (ignore ignore))
     ,(invoke-foreign-type-method :naturalize-gen type 'foreign)))

(defun compute-deport-lambda (type)
  (declare (type foreign-type type))
  (multiple-value-bind
      (form value-type)
      (invoke-foreign-type-method :deport-gen type 'value)
    `(lambda (value ignore)
       (declare (type ,(or value-type
			   (compute-lisp-rep-type type)
			   `(foreign ,type))
		      value)
		(ignore ignore))
       ,form)))

(defun compute-extract-lambda (type)
  `(lambda (sap offset ignore)
     (declare (type system-area-pointer sap)
	      (type unsigned-byte offset)
	      (ignore ignore))
     (naturalize ,(invoke-foreign-type-method :extract-gen type 'sap 'offset)
		 ',type)))

(defun compute-deposit-lambda (type)
  (declare (type foreign-type type))
  `(lambda (sap offset ignore value)
     (declare (type system-area-pointer sap)
	      (type unsigned-byte offset)
	      (ignore ignore))
     (let ((value (deport value ',type)))
       ,(invoke-foreign-type-method :deposit-gen type 'sap 'offset 'value)
       ;; Note: the reason we don't just return the pre-deported value
       ;; is because that would inhibit any (deport (naturalize ...))
       ;; optimizations that might have otherwise happen.  Re-naturalizing
       ;; the value might cause extra consing, but is flushable, so probably
       ;; results in better code.
       (naturalize value ',type))))

(defun compute-lisp-rep-type (type)
  (invoke-foreign-type-method :lisp-rep type))

(defun compute-foreign-rep-type (type)
  (invoke-foreign-type-method :foreign-rep type))





;;;; Default methods.

(defvar *void-foreign-type* (make-foreign-type :class 'root :bits 0 :alignment 0 :ordinal 0))

(def-foreign-type-method (root :unparse) (type)
  (if (eq type *void-foreign-type*)
    :void
    `(!!unknown-foreign-type!! ,(type-of type))))

(def-foreign-type-method (root :type=) (type1 type2)
  (declare (ignore type1 type2))
  t)

(def-foreign-type-method (root :subtypep) (type1 type2)
  (foreign-type-= type1 type2))

(def-foreign-type-method (root :lisp-rep) (type)
  (declare (ignore type))
  nil)

(def-foreign-type-method (root :foreign-rep) (type)
  (declare (ignore type))
  '*)

(def-foreign-type-method (root :naturalize-gen) (type foreign)
  (declare (ignore foreign))
  (error "Cannot represent ~S typed foreigns." type))

(def-foreign-type-method (root :deport-gen) (type object)
  (declare (ignore object))
  (error "Cannot represent ~S typed foreigns." type))

(def-foreign-type-method (root :extract-gen) (type sap offset)
  (declare (ignore sap offset))
  (error "Cannot represent ~S typed foreigns." type))

(def-foreign-type-method (root :deposit-gen) (type sap offset value)
  `(setf ,(invoke-foreign-type-method :extract-gen type sap offset) ,value))

(def-foreign-type-method (root :arg-tn) (type state)
  (declare (ignore state))
  (error "Cannot pass foreigns of type ~S as arguments to call-out"
	 (unparse-foreign-type type)))

(def-foreign-type-method (root :result-tn) (type state)
  (declare (ignore state))
  (error "Cannot return foreigns of type ~S from call-out"
	 (unparse-foreign-type type)))



;;;; The INTEGER type.

(def-foreign-type-class (integer)
  (signed t :type (member t nil)))

(defvar *unsigned-integer-types*
  (let* ((a (make-array 65)))
    (dotimes (i 65 a)
      (setf (svref a i) (make-foreign-integer-type :signed nil
						   :bits i
						   :alignment
						   (if (= 1 (logcount i))
                                                     i
                                                     1))))))

(defvar *signed-integer-types*
  (let* ((a (make-array 65)))
    (dotimes (i 65 a)
      (setf (svref a i) (make-foreign-integer-type :signed t
						   :bits i
						   :alignment
                                                   (if (= 1 (logcount i))
                                                     i
                                                     1))))))
         

(defvar *bool-type* (make-foreign-integer-type :bits 8 :signed #+darwin-target t #-darwin-target nil))

						  

(def-foreign-type-method (integer :unparse) (type)
  (if (eq type *bool-type*)
    :<BOOL>
    (let* ((bits (foreign-integer-type-bits type))
           (signed (foreign-integer-type-signed type))
           (alignment (foreign-integer-type-alignment type)))
      (if (eql alignment 1)
        (if (eql bits 1)
          :bit
          `(:bitfield ,bits))
        (list (if signed :signed :unsigned) bits)))))
  
(def-foreign-type-method (integer :type=) (type1 type2)
  (and (eq (foreign-integer-type-signed type1)
	   (foreign-integer-type-signed type2))
       (= (foreign-integer-type-bits type1)
	  (foreign-integer-type-bits type2))))

(def-foreign-type-method (integer :lisp-rep) (type)
  (list (if (foreign-integer-type-signed type) 'signed-byte 'unsigned-byte)
	(foreign-integer-type-bits type)))

(def-foreign-type-method (integer :foreign-rep) (type)
  (list (if (foreign-integer-type-signed type) 'signed-byte 'unsigned-byte)
	(foreign-integer-type-bits type)))

(def-foreign-type-method (integer :naturalize-gen) (type foreign)
  (declare (ignore type))
  foreign)

(def-foreign-type-method (integer :deport-gen) (type value)
  (declare (ignore type))
  value)

(def-foreign-type-method (integer :extract-gen) (type sap offset)
  (declare (type foreign-integer-type type))
  (let ((ref-form
	 (if (foreign-integer-type-signed type)
	  (case (foreign-integer-type-bits type)
	    (8 `(%get-signed-byte ,sap (/ ,offset 8)))
	    (16 `(%get-signed-word ,sap (/ ,offset 8)))
	    (32 `(%get-signed-long ,sap (/ ,offset 8)))
	    (64 `(%%get-signed-longlong ,sap (/ ,offset 8))))
	  (case (foreign-integer-type-bits type)
            (1 `(%get-bit ,sap ,offset))
	    (8 `(%get-unsigned-byte ,sap (/ ,offset 8)))
	    (16 `(%get-unsigned-word ,sap (/ ,offset 8)))
	    (32 `(%get-unsigned-long ,sap (/ ,offset 8)))
	    (64 `(%%get-unsigned-longlong ,sap (/ ,offset 8)))
	    (t  `(%get-bitfield ,sap ,offset ,(foreign-integer-type-bits type)))))))
    (or ref-form
	(error "Cannot extract ~D bit integers."
	       (foreign-integer-type-bits type)))))



;;;; The BOOLEAN type.

(def-foreign-type-class (boolean :include integer :include-args (signed)))



(def-foreign-type-method (boolean :lisp-rep) (type)
  (declare (ignore type))
  `(member t nil))

(def-foreign-type-method (boolean :naturalize-gen) (type foreign)
  (declare (ignore type))
  `(not (zerop ,foreign)))

(def-foreign-type-method (boolean :deport-gen) (type value)
  (declare (ignore type))
  `(if ,value 1 0))


(def-foreign-type-method (boolean :unparse) (type)
  `(boolean ,(foreign-boolean-type-bits type)))


;;;; the FLOAT types.

(def-foreign-type-class (float)
  (type () :type symbol))

(def-foreign-type-method (float :unparse) (type)
  (foreign-float-type-type type))

(def-foreign-type-method (float :lisp-rep) (type)
  (foreign-float-type-type type))

(def-foreign-type-method (float :foreign-rep) (type)
  (foreign-float-type-type type))

(def-foreign-type-method (float :naturalize-gen) (type foreign)
  (declare (ignore type))
  foreign)

(def-foreign-type-method (float :deport-gen) (type value)
  (declare (ignore type))
  value)


(def-foreign-type-class (single-float :include (float (bits 32))
				    :include-args (type)))


(def-foreign-type-method (single-float :extract-gen) (type sap offset)
  (declare (ignore type))
  `(%get-single-float ,sap (/ ,offset 8)))


(def-foreign-type-class (double-float :include (float (bits 64))
				    :include-args (type)))


(def-foreign-type-method (double-float :extract-gen) (type sap offset)
  (declare (ignore type))
  `(%get-double-float ,sap (/ ,offset 8)))



;;;; The MACPTR type

(def-foreign-type-class (macptr))


(def-foreign-type-method (macptr :unparse) (type)
  (declare (ignore type))
  'macptr)

(def-foreign-type-method (macptr :lisp-rep) (type)
  (declare (ignore type))
  'macptr)

(def-foreign-type-method (macptr :foreign-rep) (type)
  (declare (ignore type))
  'macptr)

(def-foreign-type-method (macptr :naturalize-gen) (type foreign)
  (declare (ignore type))
  foreign)

(def-foreign-type-method (macptr :deport-gen) (type object)
  (declare (ignore type))
  object)

(def-foreign-type-method (macptr :extract-gen) (type sap offset)
  (declare (ignore type))
  `(%get-ptr ,sap (/ ,offset 8)))


;;;; the FOREIGN-VALUE type.

(def-foreign-type-class (foreign-value :include macptr))

(def-foreign-type-method (foreign-value :lisp-rep) (type)
  (declare (ignore type))
  nil)

(def-foreign-type-method (foreign-value :naturalize-gen) (type foreign)
  `(%macptr-foreign ,foreign ',type))

(def-foreign-type-method (foreign-value :deport-gen) (type value)
  (declare (ignore type))
  `(foreign-macptr ,value))



;;;; The POINTER type.

(def-foreign-type-class (pointer :include (foreign-value))
  (to *void-foreign-type* :type (or symbol foreign-type)))



(def-foreign-type-method (pointer :unparse) (type)
  (let ((to (foreign-pointer-type-to type)))
    `(:* ,(if to
	     (%unparse-foreign-type to)
	     :void))))

(def-foreign-type-method (pointer :type=) (type1 type2)
  (let ((to1 (foreign-pointer-type-to type1))
	(to2 (foreign-pointer-type-to type2)))
    (if to1
	(if to2
	    (foreign-type-= to1 to2)
	    nil)
	(null to2))))

(def-foreign-type-method (pointer :subtypep) (type1 type2)
  (and (foreign-pointer-type-p type2)
       (let ((to1 (foreign-pointer-type-to type1))
	     (to2 (foreign-pointer-type-to type2)))
	 (if to1
	     (if to2
		 (foreign-subtype-p to1 to2)
		 t)
	     (null to2)))))

(def-foreign-type-method (pointer :deport-gen) (type value)
  (values
   `(etypecase ,value
      (null
       (%int-to-ptr 0))
      (macptr
       ,value)
      ((foreign ,type)
       (foreign-sap ,value)))
   `(or null macptr (foreign ,type))))


;;;; The MEM-BLOCK type.


(def-foreign-type-class (mem-block :include foreign-value))

(def-foreign-type-method (mem-block :extract-gen) (type sap offset)
  (let* ((nbytes (%foreign-type-or-record-size type :bytes)))
    `(%composite-pointer-ref ,nbytes ,sap (/ ,offset 8))))

(def-foreign-type-method (mem-block :deposit-gen) (type sap offset value)
  (let ((bits (foreign-mem-block-type-bits type)))
    (unless bits
      (error "Cannot deposit foreigns of type ~S (unknown size)." type))
    `(%copy-macptr-to-macptr ,value 0 ,sap ,offset ',bits)))



;;;; The ARRAY type.

(def-foreign-type-class (array :include mem-block)
  (element-type () :type foreign-type)
  (dimensions () :type list))



(def-foreign-type-method (array :unparse) (type)
  `(array ,(%unparse-foreign-type (foreign-array-type-element-type type))
	  ,@(foreign-array-type-dimensions type)))

(def-foreign-type-method (array :type=) (type1 type2)
  (and (equal (foreign-array-type-dimensions type1)
	      (foreign-array-type-dimensions type2))
       (foreign-type-= (foreign-array-type-element-type type1)
                       (foreign-array-type-element-type type2))))

(def-foreign-type-method (array :subtypep) (type1 type2)
  (and (foreign-array-type-p type2)
       (let ((dim1 (foreign-array-type-dimensions type1))
	     (dim2 (foreign-array-type-dimensions type2)))
	 (and (= (length dim1) (length dim2))
	      (or (and dim2
		       (null (car dim2))
		       (equal (cdr dim1) (cdr dim2)))
		  (equal dim1 dim2))
	      (foreign-subtype-p (foreign-array-type-element-type type1)
			       (foreign-array-type-element-type type2))))))


;;;; The RECORD type.

(defstruct (foreign-record-field
	     (:print-object
	      (lambda (field stream)
		(print-unreadable-object (field stream :type t)
		  (funcall (formatter "~S ~S~@[ ~D@~D~]")
			   stream
			   (foreign-record-field-type field)
			   (foreign-record-field-name field)
			   (foreign-record-field-bits field)
                           (foreign-record-field-offset field))))))
  (name () :type symbol)
  (type () :type foreign-type)
  (bits nil :type (or unsigned-byte null))
  (offset 0 :type unsigned-byte))



(defmethod make-load-form ((f foreign-record-field) &optional env)
  (make-load-form-saving-slots f :environment env))

(def-foreign-type-class (record :include mem-block)
  (kind :struct :type (member :struct :union :transparent-union))
  (name nil :type (or symbol null))
  (fields nil :type list)
  ;; For, e.g., records defined with #pragma options align=mac68k
  ;; in effect.  When non-nil, this specifies the maximum alignment
  ;; of record fields and the overall alignment of the record.
  (alt-align nil :type (or unsigned-byte null)))

(defmethod make-load-form ((r foreign-record-type) &optional environment)
  (declare (ignore environment))
  `(parse-foreign-type ',(unparse-foreign-type r)))


(defun parse-foreign-record-type (kind name fields &optional (ftd *target-ftd*))
  (let* ((result (if name
                   (or
                    (ecase kind
                      (:struct (info-foreign-type-struct name ftd))
                      ((:union :transparent-union) (info-foreign-type-union name ftd)))
                    (case kind
                      (:struct (setf (info-foreign-type-struct name ftd)
                                     (make-foreign-record-type :name name :kind :struct)))
                      ((:union :transparent-union)
                       (setf (info-foreign-type-union name ftd)
                                     (make-foreign-record-type :name name :kind kind)))))
                   (make-foreign-record-type :kind kind))))
    (when fields
      (multiple-value-bind (parsed-fields alignment bits)
          (parse-field-list fields kind (foreign-record-type-alt-align result))
        (let* ((old-fields (foreign-record-type-fields result)))
          (setf (foreign-record-type-fields result) parsed-fields
                (foreign-record-type-alignment result) alignment
                (foreign-record-type-bits result) bits)
          (when old-fields
            (unless (record-fields-match old-fields parsed-fields 5)
              (warn "Redefining ~a ~s fields to be:~%~s~%were~%~s"
                    kind name parsed-fields old-fields))))))
    (if name
      (unless (eq (auxiliary-foreign-type kind name) result)
        (setf (auxiliary-foreign-type kind name) result)))
    result))

;;; PARSE-FOREIGN-RECORD-FIELDS -- internal
;;;
;;; Used by parse-foreign-type to parse the fields of struct and union
;;; types.  RESULT holds the record type we are paring the fields of,
;;; and FIELDS is the list of field specifications.
;;;
(defun parse-field-list (fields kind &optional alt-alignment)
  (collect ((parsed-fields))
    (let* ((total-bits 0)
           (overall-alignment 1)
           (first-field-p t)
           (attributes (ftd-attributes *target-ftd*))
           (poweropen-alignment (getf attributes :poweropen-alignment))
           (bits-per-word (getf attributes :bits-per-word))
           (use-natural-alignment (getf attributes :natural-alignment)))
        
      (dolist (field fields)
        (destructuring-bind (var type &optional bits) field
          (declare (ignore bits))
          (let* ((field-type (parse-foreign-type type))
                 (bits (ensure-foreign-type-bits field-type))
                 (natural-alignment (foreign-type-alignment field-type))
                 (alignment (if alt-alignment
                              (min natural-alignment alt-alignment)
                              (if poweropen-alignment
                                (if first-field-p
                                  (progn
                                    (setq first-field-p nil)
                                    natural-alignment)
                                  (min 32 natural-alignment))
                                (if use-natural-alignment
                                  natural-alignment
                                  (min bits-per-word natural-alignment)))))
                 (parsed-field
                  (make-foreign-record-field :type field-type
                                             :name var)))
            (parsed-fields parsed-field)
            (when (null bits)
              (error "Unknown size: ~S"
                     (unparse-foreign-type field-type)))
            (when (null alignment)
              (error "Unknown alignment: ~S"
                     (unparse-foreign-type field-type)))
            (setf overall-alignment (max overall-alignment (if (< alignment 8) 32 alignment)))
            (ecase kind
              (:struct
               (let ((offset (align-offset total-bits alignment)))
                 (setf (foreign-record-field-offset parsed-field) offset)
                 (setf (foreign-record-field-bits parsed-field) bits)
                 (setf total-bits (+ offset bits))))
              ((:union :transparent-union)
               (setf total-bits (max total-bits bits)))))))
      (values (parsed-fields)
              (or alt-alignment overall-alignment)
              (align-offset total-bits (or alt-alignment overall-alignment))))))
            


(defun parse-foreign-record-fields (result fields)
  (declare (type foreign-record-type result)
	   (type list fields))
  (multiple-value-bind (parsed-fields alignment bits)
      (parse-field-list fields (foreign-record-type-kind result) (foreign-record-type-alt-align result))
    (setf (foreign-record-type-fields result) parsed-fields
          (foreign-record-type-alignment result) alignment
          (foreign-record-type-bits result) bits)))


(def-foreign-type-method (record :unparse) (type)
  `(,(case (foreign-record-type-kind type)
       (:struct :struct)
       (:union :union)
       (:transparent-union :transparent-union)
       (t '???))
    ,(foreign-record-type-name type)
    ,@(unless (member type *record-types-already-unparsed* :test #'eq)
	(push type *record-types-already-unparsed*)
	(mapcar #'(lambda (field)
		    `(,(foreign-record-field-name field)
		      ,(%unparse-foreign-type (foreign-record-field-type field))
		      ,@(if (foreign-record-field-bits field)
			    (list (foreign-record-field-bits field)))))
		(foreign-record-type-fields type)))))

;;; Test the record fields. The depth is limiting in case of cyclic
;;; pointers.
(defun record-fields-match (fields1 fields2 depth)
  (declare (type list fields1 fields2)
	   (type (mod 64) depth))
  (labels ((record-type-= (type1 type2 depth)
	     (and (eq (foreign-record-type-name type1)
		      (foreign-record-type-name type2))
		  (eq (foreign-record-type-kind type1)
		      (foreign-record-type-kind type2))
		  (= (length (foreign-record-type-fields type1))
		     (length (foreign-record-type-fields type2)))
		  (record-fields-match (foreign-record-type-fields type1)
				       (foreign-record-type-fields type2)
				       (1+ depth))))
	   (pointer-type-= (type1 type2 depth)
	     (let ((to1 (foreign-pointer-type-to type1))
		   (to2 (foreign-pointer-type-to type2)))
	       (if to1
		   (if to2
		    (or (> depth 10)
		       (type-= to1 to2 (1+ depth)))
		       nil)
		   (null to2))))
	   (type-= (type1 type2 depth)
	     (cond ((and (foreign-pointer-type-p type1)
			 (foreign-pointer-type-p type2))
		    (or (> depth 10)
			(pointer-type-= type1 type2 depth)))
		   ((and (foreign-record-type-p type1)
			 (foreign-record-type-p type2))
		    (record-type-= type1 type2 depth))
		   (t
		    (foreign-type-= type1 type2)))))
    (do ((fields1-rem fields1 (rest fields1-rem))
	 (fields2-rem fields2 (rest fields2-rem)))
	((or (eq fields1-rem fields2-rem)
	     (endp fields1-rem)
             (endp fields2-rem))
	 (eq fields1-rem fields2-rem))
      (let ((field1 (first fields1-rem))
	    (field2 (first fields2-rem)))
	(declare (type foreign-record-field field1 field2))
	(unless (and (eq (foreign-record-field-name field1)
			 (foreign-record-field-name field2))
		     (eql (foreign-record-field-bits field1)
			  (foreign-record-field-bits field2))
		     (eql (foreign-record-field-offset field1)
			  (foreign-record-field-offset field2))
		     (let ((field1 (foreign-record-field-type field1))
			   (field2 (foreign-record-field-type field2)))
		       (type-= field1 field2 (1+ depth))))
	  (return nil))))))

(def-foreign-type-method (record :type=) (type1 type2)
  (and (eq (foreign-record-type-name type1)
	   (foreign-record-type-name type2))
       (eq (foreign-record-type-kind type1)
	   (foreign-record-type-kind type2))
       (= (length (foreign-record-type-fields type1))
	  (length (foreign-record-type-fields type2)))
       (record-fields-match (foreign-record-type-fields type1)
			    (foreign-record-type-fields type2) 0)))


;;;; The FUNCTION and VALUES types.

(defvar *values-type-okay* nil)

(def-foreign-type-class (function :include mem-block)
  (result-type () :type foreign-type)
  (arg-types () :type list)
  (stub nil :type (or null function)))



(def-foreign-type-method (function :unparse) (type)
  `(function ,(%unparse-foreign-type (foreign-function-type-result-type type))
	     ,@(mapcar #'%unparse-foreign-type
		       (foreign-function-type-arg-types type))))

(def-foreign-type-method (function :type=) (type1 type2)
  (and (foreign-type-= (foreign-function-type-result-type type1)
		     (foreign-function-type-result-type type2))
       (= (length (foreign-function-type-arg-types type1))
	  (length (foreign-function-type-arg-types type2)))
       (every #'foreign-type-=
	      (foreign-function-type-arg-types type1)
	      (foreign-function-type-arg-types type2))))


(def-foreign-type-class (values)
  (values () :type list))



(def-foreign-type-method (values :unparse) (type)
  `(values ,@(mapcar #'%unparse-foreign-type
		     (foreign-values-type-values type))))

(def-foreign-type-method (values :type=) (type1 type2)
  (and (= (length (foreign-values-type-values type1))
	  (length (foreign-values-type-values type2)))
       (every #'foreign-type-=
	      (foreign-values-type-values type1)
	      (foreign-values-type-values type2))))




;;;; The FOREIGN-SIZE macro.

(defmacro foreign-size (type &optional (units :bits))
  "Return the size of the foreign type TYPE.  UNITS specifies the units to
   use and can be either :BITS, :BYTES, or :WORDS."
  (let* ((foreign-type (parse-foreign-type type))
         (bits (ensure-foreign-type-bits foreign-type)))
    (if bits
      (values (ceiling bits
                       (ecase units
                         (:bits 1)
                         (:bytes 8)
                         (:words 32))))
      (error "Unknown size for foreign type ~S."
             (unparse-foreign-type foreign-type)))))

(defun ensure-foreign-type-bits (type)
  (or (foreign-type-bits type)
      (and (typep type 'foreign-record-type)
           (let* ((name (foreign-record-type-name type)))
             (and name
                  (load-record name)
                  (foreign-type-bits type))))
      (and (typep type 'foreign-array-type)
	   (let* ((element-type (foreign-array-type-element-type type))
		  (dims (foreign-array-type-dimensions type)))
	     (if (and (ensure-foreign-type-bits element-type)
		      (every #'integerp dims))
	       (setf (foreign-array-type-alignment type)
		     (foreign-type-alignment element-type)
		     (foreign-array-type-bits type)
		     (* (align-offset (foreign-type-bits element-type)
				      (foreign-type-alignment element-type))
			(reduce #'* dims))))))))

(defun require-foreign-type-bits (type)
  (or (ensure-foreign-type-bits type)
      (error "Can't determine attributes of foreign type ~s" type)))

(defun %find-foreign-record (name)
  (or (info-foreign-type-struct name)
      (info-foreign-type-union name)
      (load-record name)))


(defun %foreign-type-or-record (type)
  (if (typep type 'foreign-type)
    type
    (if (consp type)
      (parse-foreign-type type)
      (or (%find-foreign-record type)
	  (parse-foreign-type type)))))

(defun %foreign-type-or-record-size (type &optional (units :bits))
  (let* ((info (%foreign-type-or-record type))
         (bits (ensure-foreign-type-bits info)))
    (if bits
      (values (ceiling bits
                       (ecase units
                         (:bits 1)
                         (:bytes 8)
                         (:words 32))))
      (error "Unknown size for foreign type ~S."
             (unparse-foreign-type info)))))

(defun %find-foreign-record-type-field (type field-name)
  (ensure-foreign-type-bits type)       ;load the record type if necessary.
  (let* ((fields (foreign-record-type-fields type)))
    (or (find field-name  fields :key #'foreign-record-field-name :test #'string-equal)
                         (error "Record type ~a has no field named ~s.~&Valid field names are: ~&~a"
                                (foreign-record-type-name type)
                                field-name
                                (mapcar #'foreign-record-field-name fields)))))

(defun %foreign-access-form (base-form type bit-offset accessors)
  (if (null accessors)
    (invoke-foreign-type-method :extract-gen type base-form bit-offset)
    (etypecase type
      (foreign-record-type
       (let* ((field (%find-foreign-record-type-field type (car accessors))))
         (%foreign-access-form base-form
                               (foreign-record-field-type field)
                               (+ bit-offset (foreign-record-field-offset field))
                               (cdr accessors))))
      (foreign-pointer-type
       (%foreign-access-form
        (invoke-foreign-type-method :extract-gen type base-form bit-offset)
        (foreign-pointer-type-to type)
        0
        accessors)))))

(defun %foreign-array-access-form (base-form type index-form)
  (etypecase type
    ((or foreign-pointer-type foreign-array-type)
     (let* ((to (if (foreign-array-type-p type)
                  (foreign-array-type-element-type type)
                  (foreign-pointer-type-to type)))
            (size (foreign-type-bits to))
            (bit-offset `(the fixnum (* ,size (the fixnum ,index-form)))))
       (invoke-foreign-type-method :extract-gen to base-form bit-offset)))
    (foreign-type
     (%foreign-array-access-form base-form (make-foreign-pointer-type :to type) index-form))))




;;;; Naturalize, deport, extract-foreign-value, deposit-foreign-value

(defun naturalize (foreign type)
  (declare (type foreign-type type))
  (funcall (coerce (compute-naturalize-lambda type) 'function)
           foreign type))

(defun deport (value type)
  (declare (type foreign-type type))
  (funcall (coerce (compute-deport-lambda type) 'function)
           value type))

(defun extract-foreign-value (sap offset type)
  (declare (type macptr sap)
           (type unsigned-byte offset)
           (type foreign-type type))
  (funcall (coerce (compute-extract-lambda type) 'function)
           sap offset type))

(defun deposit-foreign-value (sap offset type value)
  (declare (type macptr sap)
           (type unsigned-byte offset)
           (type foreign-type type))
  (funcall (coerce (compute-deposit-lambda type) 'function)
           sap offset type value))



(defmacro external (name)
  "If there is already an EXTERNAL-ENTRY-POINT for the symbol named by name,
find it and return it. If not, create one and return it.

Try to resolve the entry point to a memory address, and identify the
containing library.

Be aware that under Darwin, external functions which are callable from C
have underscores prepended to their names, as in '_fopen'."
  `(load-eep ,name))

(defmacro external-call (name &rest args)
  "Call the foreign function at the address obtained by resolving the
external-entry-point associated with name, passing the values of each arg
as a foreign argument of type indicated by the corresponding
arg-type-specifier. Returns the foreign function result (coerced to a
Lisp object of type indicated by result-type-specifier), or NIL if
result-type-specifer is :VOID or NIL"
  `(ff-call (%reference-external-entry-point
	     (load-time-value (external ,name))) ,@args))

(defmacro ff-call (entry &rest args)
  "Call the foreign function at address entrypoint passing the values of
each arg as a foreign argument of type indicated by the corresponding
arg-type-specifier. Returns the foreign function result (coerced to a
Lisp object of type indicated by result-type-specifier), or NIL if
result-type-specifer is :VOID or NIL"
  (funcall (ftd-ff-call-expand-function *target-ftd*)
           `(%ff-call ,entry) args))
	
	  

(defmethod make-load-form ((eep external-entry-point) &optional env)
  (declare (ignore env))
  `(load-eep ,(eep.name eep)))


(defmethod print-object ((eep external-entry-point) out)
  (print-unreadable-object (eep out :type t :identity t)
    (format out "~s" (eep.name eep))
    (let* ((addr (eep.address eep))
	   (container (eep.container eep)))
      (if addr
        #+ppc-target
        (progn
          #+32-bit-target
          (format out " (#x~8,'0x) " (logand #xffffffff (ash addr 2)))
          #+64-bit-target
          (format out " (#x~16,'0x) " (if (typep addr 'integer)
                                        (logand #xffffffffffffffff (ash addr 2))
                                        (%ptr-to-int addr))))
	#+(or x8632-target arm-target)
	(format out " (#x~8,'0x) " addr)
        #+x8664-target
        (format out " (#x~16,'0x) " addr)
	(format out " {unresolved} "))
      (when (and container (or (not (typep container 'macptr))
				    (not (%null-ptr-p container))))
	(format out "~a" (shlib.soname container))))))



(defun %cons-foreign-variable (name type &optional container)
  (%istruct 'foreign-variable nil name type container))

(defmethod make-load-form ((fv foreign-variable) &optional env)
  (declare (ignore env))
  `(load-fv ,(fv.name fv) ',(fv.type fv)))

(defmethod print-object ((fv foreign-variable) out)
  (print-unreadable-object (fv out :type t :identity t)
    (format out "~s" (fv.name fv))
    (let* ((addr (fv.addr fv))
	   (container (fv.container fv)))
      (if addr
        #+32-bit-target
	(format out " (#x~8,'0x) " (logand #xffffffff (%ptr-to-int addr)))
        #+64-bit-target
        	(format out " (#x~16,'0x) " (logand #xfffffffffffffffff (%ptr-to-int addr)))
	(format out " {unresolved} "))
      (when (and container (or (not (typep container 'macptr))
				    (not (%null-ptr-p container))))
	(format out "~a" (shlib.soname container))))))


(defmethod print-object ((s shlib) stream)
  (print-unreadable-object (s stream :type t :identity t)
    (format stream "~a" (or (shlib.soname s) (shlib.pathname s)))))

#-(or darwin-target windows-target)
(defun dlerror ()
  (with-macptrs ((p))
    (%setf-macptr p (#_dlerror))
    (unless (%null-ptr-p p) (%get-cstring p))))

(defstruct (external-function-definition (:conc-name "EFD-")
                                         (:constructor
                                          make-external-function-definition
                                          (&key entry-name arg-specs
                                                result-spec
                                                (min-args (length arg-specs))))
                                         )
  (entry-name "" :type string)
  (arg-specs () :type list)
  (result-spec nil :type (or symbol list))
  (min-args 0 :type fixnum))


(defun %external-call-expander (whole env)
  (declare (ignore env))
  (destructuring-bind (name &rest args) whole
    (collect ((call))
      (let* ((info (or (gethash name (ftd-external-function-definitions
                                      *target-ftd*))
                       (error "Unknown external-function: ~s" name)))
             (external-name (efd-entry-name info))
             (arg-specs (efd-arg-specs info))
             (result (efd-result-spec info))
             (monitor (eq (car args) :monitor-exception-ports)))
        (when monitor
          (setq args (cdr args))
          (call :monitor-exception-ports))
        (let* ((rtype (parse-foreign-type result)))
          (if (typep rtype 'foreign-record-type)
            (call (pop args))))
        (do* ((specs arg-specs (cdr specs))
              (args args (cdr args)))
             ((null specs)
              (call result)
              (if args
                (error "Extra arguments in ~s"  whole)
                `(external-call ,external-name ,@(call))))
          (let* ((spec (car specs)))
            (cond ((eq spec :void)
                   ;; must be last arg-spec; remaining args should be
                   ;; keyword/value pairs
                   (unless (evenp (length args))
                     (error "Remaining arguments should be keyword/value pairs: ~s"
                            args))
                   (do* ()
                        ((null args))
                     (call (pop args))
                     (call (pop args))))
                  (t
                   (call spec)
                   (if args
                     (call (car args))
                     (error "Missing arguments in ~s" whole))))))))))

(defun translate-foreign-arg-type (foreign-type-spec)
  (let* ((foreign-type (parse-foreign-type foreign-type-spec)))
    (etypecase foreign-type
      (foreign-pointer-type :address)
      (foreign-integer-type
       (let* ((bits (foreign-integer-type-bits foreign-type))
              (signed (foreign-integer-type-signed foreign-type)))
         (declare (fixnum bits))
         (cond ((<= bits 8) (if signed :signed-byte :unsigned-byte))
               ((<= bits 16) (if signed :signed-halfword :unsigned-halfword))
               ((<= bits 32) (if signed :signed-fullword :unsigned-fullword))
               ((<= bits 64) (if signed :signed-doubleword :unsigned-doubleword))
               (t `(:record ,bits)))))
      (foreign-float-type
       (ecase (foreign-float-type-bits foreign-type)
         (32 :single-float)
         (64 :double-float)))
      (foreign-record-type
       `(:record ,(foreign-record-type-bits foreign-type))))))
      

(defmacro define-external-function (name (&rest arg-specs) result-spec
					 &key (min-args (length arg-specs)))
  (let* ((entry-name nil)
         (package (find-package (ftd-interface-package-name *target-ftd*)))
         (arg-keywords (mapcar #'translate-foreign-arg-type arg-specs))
         (result-keyword (unless (and (symbolp result-spec)
                                    (eq (make-keyword result-spec) :void))
                               (translate-foreign-arg-type result-spec))))
    (when (and (consp result-keyword) (eq (car result-keyword) :record))
      (push :address arg-keywords)
      (setq result-keyword nil))
    (if (consp name)
      (setq entry-name (cadr name) name (intern (unescape-foreign-name
                                                 (car name))
                                                package))
      (progn
        (setq entry-name (unescape-foreign-name name)
              name (intern entry-name package))
        (if (getf (ftd-attributes *target-ftd*)
                  :prepend-underscore)
          (setq entry-name (concatenate 'string "_" entry-name)))))
    `(progn
      (setf (gethash ',name (ftd-external-function-definitions *target-ftd*))
       (make-external-function-definition
	:entry-name ',entry-name
	:arg-specs ',arg-keywords
	:result-spec ',result-keyword
	:min-args ,min-args))
      (setf (macro-function ',name) #'%external-call-expander)
      ',name)))


#+darwinppc-target
(defun open-dylib (name)
  (with-cstrs ((name name))
    (#_NSAddImage name (logior #$NSADDIMAGE_OPTION_RETURN_ON_ERROR 
			       #$NSADDIMAGE_OPTION_WITH_SEARCHING))))

(defparameter *foreign-representation-type-keywords*
  `(:signed-doubleword :signed-fullword :signed-halfword :signed-byte
    :unsigned-doubleword :unsigned-fullword :unsigned-halfword :unsigned-byte
    :address
    :single-float :double-float
    :void))

(defun null-coerce-foreign-arg (arg-type-keyword argform)
  (declare (ignore arg-type-keyword))
  argform)

(defun null-coerce-foreign-result (result-type-keyword resultform)
  (declare (ignore result-type-keyword))
  resultform)

(defun foreign-type-to-representation-type (f)
  (if (or (member f *foreign-representation-type-keywords*)
	  (typep f 'unsigned-byte))
    f
    (let* ((ftype (if (typep f 'foreign-type)
                    f
                    (parse-foreign-type f))))
      (or
       (and (eq (foreign-type-class ftype) 'root) :void)	 
       (typecase ftype
	 ((or foreign-pointer-type foreign-array-type) :address)
	 (foreign-double-float-type :double-float)
	 (foreign-single-float-type :single-float)
	 (foreign-integer-type
	  (let* ((signed (foreign-integer-type-signed ftype))
		 (bits (foreign-integer-type-bits ftype)))
	    (if signed
	      (if (<= bits 8)
		:signed-byte
		(if (<= bits 16)
		  :signed-halfword
		  (if (<= bits 32)
		    :signed-fullword
		    (if (<= bits 64)
		      :signed-doubleword))))
	      (if (<= bits 8)
		:unsigned-byte
		(if (<= bits 16)
		  :unsigned-halfword
		  (if (<= bits 32)
		    :unsigned-fullword
		    (if (<= bits 64)
		      :unsigned-doubleword)))))))
	 (foreign-record-type
          (if (getf (ftd-attributes *target-ftd*)
                  :struct-by-value)
            (let* ((bits (ensure-foreign-type-bits ftype)))
              (ceiling bits (target-word-size-case
                             (32 32)
                             (64 64))))
          :address)))
       (error "can't determine representation keyword for ~s" f)))))

(defun foreign-record-accessor-names (record-type &optional prefix)
  (collect ((accessors))
    (dolist (field (foreign-record-type-fields record-type) (accessors))
      (let* ((field-name (append prefix (list (foreign-record-field-name field))))
	     (field-type (foreign-record-field-type field)))
	(if (typep field-type 'foreign-record-type)
	  (dolist (s (foreign-record-accessor-names field-type field-name))
	    (accessors s))
	  (accessors field-name))))))

;;; Are all (scalar) fields in the field-list FIELDS floats ?'
(defun all-floats-in-field-list (fields)
  (dolist (field fields t)
    (let* ((field-type (foreign-record-field-type field)))
      (cond ((typep field-type 'foreign-record-type)
             (unless (all-floats-in-field-list (foreign-record-type-fields field-type))
                                     (return nil)))
            ((typep field-type 'foreign-array-type)
             (unless (typep (foreign-array-type-element-type field-type) 'foreign-float-type)
               (return nil)))
            (t (unless (typep field-type 'foreign-float-type)
                 (return nil)))))))

;;; Are any (scalar) fields in the field-list FIELDS floats ?
(defun some-floats-in-field-list (fields)
  (dolist (field fields)
    (let* ((field-type (foreign-record-field-type field)))
      (cond ((typep field-type 'foreign-float-type)
             (return t))
            ((typep field-type 'foreign-record-type)
             (if (some-floats-in-field-list (foreign-record-type-fields field-type))
               (return t)))
            ((typep field-type 'foreign-array-type)
             (if (typep (foreign-array-type-element-type field-type)
                        'foreign-float-type)
               (return t)))))))

;;; We don't use foreign type ordinals when cross-compiling,
;;; so the read-time conditionalization is OK here.

#-windows-target
(defparameter *canonical-os-foreign-types*
  '((:struct :timespec)
    (:struct :stat)
    (:struct :passwd)
    #>Dl_info
    (:array (:struct :pollfd) 1)) )

#+windows-target
(defparameter *canonical-os-foreign-types*
  `(#>FILETIME
    #>SYSTEM_INFO
    #>HANDLE
    #>PROCESS_INFORMATION
    #>STARTUPINFO
    (:array #>HANDLE 2)
    #>DWORD
    (:array #>wchar_t #.#$MAX_PATH)
    #>fd_set
    #>DWORD_PTR
    #>SYSTEMTIME))
    
    
(defun canonicalize-foreign-type-ordinals (ftd)
  (let* ((canonical-ordinal 0))          ; used for :VOID
    (flet ((canonicalize-foreign-type-ordinal (spec)
             (let* ((new-ordinal (incf canonical-ordinal)))
               (when spec
                 (let* ((type (parse-foreign-type spec))
                        (old-ordinal (foreign-type-ordinal type)))
                   (unless (eql new-ordinal old-ordinal)
                     (remhash old-ordinal (ftd-ordinal-types ftd))
                     (setf (foreign-type-ordinal type) new-ordinal)
                     (note-foreign-type-ordinal type ftd))))
               new-ordinal)))
      (canonicalize-foreign-type-ordinal :signed)
      (canonicalize-foreign-type-ordinal :unsigned)
      (canonicalize-foreign-type-ordinal #+64-bit-target :long #-64-bit-target nil)
      (canonicalize-foreign-type-ordinal :address)
      (canonicalize-foreign-type-ordinal '(:struct :sockaddr_in))
      (canonicalize-foreign-type-ordinal '(:struct :sockaddr_un))
      (canonicalize-foreign-type-ordinal '(:struct :linger))
      (canonicalize-foreign-type-ordinal '(:struct :hostent))
      (canonicalize-foreign-type-ordinal '(:array :unsigned-long 3))
      (canonicalize-foreign-type-ordinal '(:* :char))
      (canonicalize-foreign-type-ordinal '(:struct :in_addr))
      (canonicalize-foreign-type-ordinal '(:struct :cdb-datum))
      (canonicalize-foreign-type-ordinal '(:struct :dbm-constant))
      (canonicalize-foreign-type-ordinal '(:* (:struct :hostent)))
      (canonicalize-foreign-type-ordinal '(:array :int 2))
      (canonicalize-foreign-type-ordinal '(:array (:struct :pollfd) 1))
      (canonicalize-foreign-type-ordinal '(:struct :dirent))
      (canonicalize-foreign-type-ordinal '(:struct :timeval))
      (canonicalize-foreign-type-ordinal '(:struct :addrinfo))
      (canonicalize-foreign-type-ordinal :float)
      (canonicalize-foreign-type-ordinal :double)

      (setq canonical-ordinal (1- max-common-foreign-type-ordinal))

      (dolist (spec *canonical-os-foreign-types*)
        (canonicalize-foreign-type-ordinal spec))
      (dolist (spec (ftd-platform-ordinal-types ftd))
        (canonicalize-foreign-type-ordinal spec)))))

(defun install-standard-foreign-types (ftd)
  (let* ((*target-ftd* ftd)
         (natural-word-size (getf (ftd-attributes ftd) :bits-per-word))
         (long-word-size (or (getf (ftd-attributes ftd) :bits-per-long)
                             natural-word-size)))

    (def-foreign-type-translator signed (&optional (bits 32))
      (if (<= bits 64)
        (svref *signed-integer-types* bits)
        (make-foreign-integer-type :bits bits)))


    (def-foreign-type-translator integer (&optional (bits 32))
      (if (<= bits 64)
        (svref *signed-integer-types* bits)
        (make-foreign-integer-type :bits bits)))

    (def-foreign-type-translator unsigned (&optional (bits 32))
      (if (<= bits 64)
        (svref *unsigned-integer-types* bits)
        (make-foreign-integer-type :bits bits :signed nil)))

    (def-foreign-type-translator bitfield (&optional (bits 1))
      (make-foreign-integer-type :bits bits :signed nil :alignment 1))

    (def-foreign-type-translator root ()
      (make-foreign-type :class 'root :bits 0 :alignment 0))

    (def-foreign-type-translator :<BOOL> () *bool-type*)

    (def-foreign-type-translator single-float ()
      (make-foreign-single-float-type :type 'single-float))

    (def-foreign-type-translator double-float ()
      (make-foreign-double-float-type :type 'double-float))

    (def-foreign-type-translator macptr ()
      (make-foreign-macptr-type :bits natural-word-size))

    (def-foreign-type-translator values (&rest values)
      (unless *values-type-okay*
        (error "Cannot use values types here."))
      (let ((*values-type-okay* nil))
        (make-foreign-values-type
         :values (mapcar #'parse-foreign-type values))))

    (def-foreign-type-translator function (result-type &rest arg-types)
      (make-foreign-function-type
       :result-type (let ((*values-type-okay* t))
                      (parse-foreign-type result-type))
       :arg-types (mapcar #'parse-foreign-type arg-types)))

    (def-foreign-type-translator struct (name &rest fields)
      (parse-foreign-record-type :struct name fields))
    
    (def-foreign-type-translator union (name &rest fields)
      (parse-foreign-record-type :union name fields))

    (def-foreign-type-translator transparent-union (name &rest fields)
      (parse-foreign-record-type :transparent-union name fields))

    (def-foreign-type-translator array (ele-type &rest dims)
      (when dims
	;; cross-compiling kludge. replaces '(or index null)
        (unless (typep (first dims) `(or
				      ,(target-word-size-case
					(32 '(integer 0 #.(expt 2 24)))
					(64 '(integer 0 #.(expt 2 56))))
				      null))
          (error "First dimension is not a non-negative fixnum or NIL: ~S"
                 (first dims)))
        (let ((loser (find-if-not #'(lambda (x) (typep x 'index))
                                  (rest dims))))
          (when loser
            (error "Dimension is not a non-negative fixnum: ~S" loser))))
	
      (let* ((type (parse-foreign-type ele-type))
             (pair (cons type dims)))
        (declare (dynamic-extent pair))
        (ensure-foreign-type-bits type)
        (let* ((atype 
                (or (gethash pair (ftd-array-types *target-ftd*))
                    (setf (gethash (cons type dims) (ftd-array-types *target-ftd*))
                          
                          (make-foreign-array-type
                           :element-type type
                           :dimensions dims
                           :alignment (foreign-type-alignment type)
                           :bits (if (and (ensure-foreign-type-bits type)
                                          (every #'integerp dims))
                                   (* (align-offset (foreign-type-bits type)
                                                    (foreign-type-alignment type))
                                      (reduce #'* dims))))))))
          (note-foreign-type-ordinal atype *target-ftd*)
          atype)))

    (def-foreign-type-translator * (to)
      (let* ((ftd *target-ftd*)
             (to (if (eq to t) *void-foreign-type* (parse-foreign-type to ftd))))
        (or (gethash to (ftd-pointer-types ftd))
            (setf (gethash to (ftd-pointer-types *target-ftd*))
                  (make-foreign-pointer-type
                   :to to
                   :bits natural-word-size)))))
    
    (def-foreign-type-translator boolean (&optional (bits 32))
      (make-foreign-boolean-type :bits bits :signed nil))

    (%def-foreign-type :signed-char (parse-foreign-type '(:signed 8) ftd))
    (%def-foreign-type :signed-byte (parse-foreign-type '(:signed 8) ftd))
    (%def-foreign-type :short (parse-foreign-type '(:signed 16) ftd))
    (%def-foreign-type :signed-halfword (parse-foreign-type :short ftd))
    (%def-foreign-type :int (parse-foreign-type '(:signed 32) ftd))
    (%def-foreign-type :signed-fullword (parse-foreign-type :int ftd))
    (%def-foreign-type :signed-short (parse-foreign-type '(:signed 16) ftd))
    (%def-foreign-type :signed-int (parse-foreign-type '(:signed 32) ftd))
    (%def-foreign-type :signed-doubleword (parse-foreign-type '(:signed 64) ftd))
    (%def-foreign-type :char (parse-foreign-type #-darwin-target '(:unsigned 8)
                      #+darwin-target '(:signed 8) ftd))
    (%def-foreign-type :unsigned-char (parse-foreign-type '(:unsigned 8) ftd))
    (%def-foreign-type :unsigned-byte (parse-foreign-type '(:unsigned 8) ftd))
    (%def-foreign-type :unsigned-short (parse-foreign-type '(:unsigned 16) ftd))
    (%def-foreign-type :unsigned-halfword (parse-foreign-type :unsigned-short ftd))
    (%def-foreign-type :unsigned-int (parse-foreign-type '(:unsigned 32) ftd))
    (%def-foreign-type :unsigned-fullword (parse-foreign-type :unsigned-int ftd))
    (%def-foreign-type :unsigned-doubleword (parse-foreign-type '(:unsigned 64) ftd))
    (%def-foreign-type :bit (parse-foreign-type '(:bitfield 1) ftd))

    (%def-foreign-type :float (parse-foreign-type :single-float ftd))
    (%def-foreign-type :double (parse-foreign-type :double-float ftd))

    (%def-foreign-type :void *void-foreign-type*)
    (%def-foreign-type :address (parse-foreign-type '(:* :void) ftd))
    (let* ((signed-long-type (parse-foreign-type
                              `(:signed ,long-word-size)))
           (unsigned-long-type (parse-foreign-type
                                `(:unsigned ,long-word-size))))
      (%def-foreign-type :long signed-long-type ftd)
      (%def-foreign-type :signed-long signed-long-type ftd)
      (%def-foreign-type :unsigned-long unsigned-long-type ftd))
    ;;
    ;; Defining the handful of foreign structures that are used
    ;; to build Clozure CL here ensures that all backends see appropriate
    ;; definitions of them.
    ;;
    ;; Don't use DEF-FOREIGN-TYPE here; this often runs too
    ;; early in the cold load for that to work.
    ;;
    (parse-foreign-type
     '(:struct :cdb-datum
       (:data (* t))
       (:size (:unsigned 32)))
     ftd)
    (parse-foreign-type
     '(:struct :dbm-constant
       (:class (:unsigned 32))
       (:pad (:unsigned 32))
       (:value
        (:union nil
         (:s32 (:signed 32))
         (:u32 (:unsigned 32))
         (:single-float :float)
         (:double-float :double))))
     ftd)
    ;; This matches the xframe-list struct definition in
    ;; "ccl:lisp-kernel;constants.h"
    (parse-foreign-type
     '(:struct :xframe-list
       (:this (:* t #|(struct :ucontext)|#))
       (:prev (:* (:struct  :xframe-list))))
    ftd)
  ))

(defmethod make-load-form ((p macptr) &optional env)
  (declare (ignore env))
  (let* ((value (%ptr-to-int p)))
    (unless (or (< value 65536)
                (>= value (- (ash 1 target::nbits-in-word) 65536)))
      (error "~&~s can't be referenced as a constant because its address contains more than 16 significant bits." p))
    (if (zerop value)
      '+null-ptr+
      `(%int-to-ptr ,value))))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/foreign-types.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;; -*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Functions to implement FORMAT.
;;;

(in-package "CCL")

;;; Special variables local to FORMAT
;;; why do these have top-level bindings ????? - seems wrong or at least unnecessary

(defvar *format-control-string* ""
  "The current FORMAT control string")

(defvar *format-index* 0
  "The current index into *format-control-string*")

(defvar *format-length* 0
  "The length of the current FORMAT control string")

(defvar *format-arguments* ()
  "Arguments to the current call of FORMAT")

(defvar *format-original-arguments* ()
  "Saved arglist from top-level FORMAT call for ~* and ~@*")

(defvar *format-arguments-variance* nil
  "Non-NIL only during compile-time scanning of a format string, in which case it is the
number of additional elements at the front of *format-arguments* that may be already used
up at runtime.  I.e. the actual *format-arguments* may be anything between *format-arguments*
and (nthcdr *format-arguments-variance* *format-arguments*)")

(def-standard-initial-binding *format-stream-stack* nil "A stack of string streams for collecting FORMAT output")

(defvar *format-pprint* nil
  "Has a pprint format directive (~W ~I ~_ ~:T) or logical-block directive been seen?")

(defvar *format-justification-semi* nil
  "Has a ~<...~:;...~> been seen?")

(defvar *format-colon-rest* nil
  )

;;; prevent circle checking rest args. Really EVIL when dynamic-extent
(def-standard-initial-binding *format-top-level* nil)


;;; ERRORS

;;; Since errors may occur while an indirect control string is being
;;; processed, i.e. by ~? or ~{~:}, some sort of backtrace is necessary
;;; in order to indicate the location in the control string where the
;;; error was detected.  To this end, errors detected by format are
;;; signalled by throwing a list of the form ((control-string args))
;;; to the tag FORMAT-ERROR.  This throw will be caught at each level
;;; of indirection, and the list of error messages re-thrown with an
;;; additional message indicating that indirection was present CONSed
;;; onto it.  Ultimately, the last throw will be caught by the top level
;;; FORMAT function, which will then signal an error to the Slisp error
;;; system in such a way that all the errror messages will be displayed
;;; in reverse order.

(defun format-error (complaint &rest args)
  (throw 'format-error
         (list (list "~1{~:}~%~S~%~V@T^" complaint args
                    *format-control-string* (1+ *format-index*)))))


;;; MACROS

;;; This macro establishes the correct environment for processing
;;; an indirect control string.  CONTROL-STRING is the string to
;;; process, and FORMS are the forms to do the processing.  They 
;;; invariably will involve a call to SUB-FORMAT.  CONTROL-STRING
;;; is guaranteed to be evaluated exactly once.
(eval-when (compile eval #-bccl load)

; does this need to exist?????
#|| ; put it out of its misery
(defmacro format-with-control-string (control-string &rest forms)
  `(let ((string (if (simple-string-p ,control-string)
                     ,control-string
                     (coerce ,control-string 'simple-base-string))))
        (declare (simple-string string))
        (let ((error (catch 'format-error
                            (let ((*format-control-string* string)
                                  (*format-length* (length string))
                                  (*format-index* 0))
                                 ,@forms
                                 nil))))
          
             (when error
                   (throw 'format-error
                          (cons (list "While processing indirect control string~%~S~%~V@T^"
                                      *format-control-string*
                                      (1+ *format-index*))
                                error))))))
||#
(defmacro format-indirect-error (error)
  `(throw 'format-error
         (cons (list "While processing indirect control string~%~S~%~V@T^"
                     *format-control-string*
                     (1+ *format-index*))
               ,error)))


(defmacro get-a-format-string-stream ()
  '(or (pop *format-stream-stack*) (make-string-output-stream :element-type 'base-char))) ; ??

;;; This macro rebinds collects output to the standard output stream
;;; in a string.  For efficiency, we avoid consing a new stream on
;;; every call.  A stack of string streams is maintained in order to
;;; guarantee re-entrancy.

(defmacro with-format-string-output (stream-sym &rest forms)
  `(let ((,stream-sym nil))
     (unwind-protect
       (progn
         (setq ,stream-sym (get-a-format-string-stream))
         ,@forms
         (prog1
           (get-output-stream-string ,stream-sym)
           (push ,stream-sym *format-stream-stack*)))
       (when ,stream-sym (file-position ,stream-sym 0)))))

;;; This macro decomposes the argument list returned by PARSE-FORMAT-OPERATION.
;;; PARMVAR is the list of parameters.  PARMDEFS is a list of lists of the form
;;; (<var> <default>).  The FORMS are evaluated in an environment where each 
;;; <var> is bound to either the value of the parameter supplied in the 
;;; parameter list, or to its <default> value if the parameter was omitted or
;;; explicitly defaulted.

(defmacro with-format-parameters (parmvar parmdefs &body  body &environment env)
  (do ((parmdefs parmdefs (cdr parmdefs))
       (bindings () (cons `(,(caar parmdefs) (or (if ,parmvar (pop ,parmvar))
                                                 ,(cadar parmdefs)))
                          bindings)))
      ((null parmdefs)
       (multiple-value-bind (forms decls) (parse-body body env)
         `(let ,(nreverse bindings)
            ,@decls
            (when ,parmvar
              (format-error "Too many parameters"))
            ,@forms)))))



;;; Returns the index of the first occurrence of the specified character
;;; between indices START (inclusive) and END (exclusive) in the control
;;; string.


(defmacro format-find-char (char start end)
  `(%str-member  ,char *format-control-string*
                   ,start ,end))


) ;end of eval-when for macros

;;; CONTROL STRING PARSING 

;;; The current control string is kept in *format-control-string*. 
;;; The variable *format-index* is the position of the last character
;;; processed, indexing from zero.  The variable *format-length* is the
;;; length of the control string, which is one greater than the maximum
;;; value of *format-index*.  


;;; Gets the next character from the current control string.  It is an
;;; error if there is none.  Leave *format-index* pointing to the
;;; character returned.

(defun format-nextchar ()
  (let ((index (%i+ 1 *format-index*)))    
    (if (%i< (setq *format-index* index) *format-length*)
      (schar *format-control-string* index)
      (format-error "Syntax error"))))



;;; Returns the current character, i.e. the one pointed to by *format-index*.

(defmacro format-peek ()
  `(schar *format-control-string* *format-index*))




;;; Attempts to parse a parameter, starting at the current index.
;;; Returns the value of the parameter, or NIL if none is found. 
;;; On exit, *format-index* points to the first character which is
;;; not a part of the recognized parameter.

(defun format-get-parameter (ch)
  (case ch
    (#\# (format-nextchar)
     (let ((n (or *format-arguments-variance* 0))
           (len (length *format-arguments*)))
       (declare (fixnum n len))
       (if (eql n 0)
         len
         `(the (integer ,(- len n) ,len) (length *format-arguments*)))))
    ((#\V #\v)
     (prog1 (pop-format-arg) (format-nextchar)))
    (#\' (prog1 (format-nextchar) (format-nextchar)))
    (t (cond ((or (eq ch #\-) (eq ch #\+) (digit-char-p ch))
              (let ((neg-parm (eq ch #\-)))
                (unless (setq ch (digit-char-p ch))
                  (unless (setq ch (digit-char-p (format-nextchar)))
                    (format-error "Illegal parameter")))
                (do ((number ch (+ ch (* number 10))))
                    ((not (setq ch (digit-char-p (format-nextchar))))
                     (if neg-parm (- number) number)))))
             (t nil)))))

(defun format-skip-parameter (ch) ; only caller is parse-format-operation
  "Might someday want to add proper format error checking for negative 
      parameters"
  (let ()
    (case ch
      ((#\V #\v #\#)
       (format-nextchar))
      (#\' (format-nextchar) (format-nextchar))
      (#\,)
      (t (when (or (eq ch #\-) (eq ch #\+)) (format-nextchar))
         (while (digit-char-p (format-nextchar)))))))

(defun format-no-semi (char &optional colon atsign)
  (when *format-justification-semi*
    (format-error "~~~:[~;:~]~:[~;@~]~c illegal in this context" colon atsign char))
  (setq *format-pprint* t))

;;; Parses a format directive, including flags and parameters.  On entry,
;;; *format-index* should point to the "~" preceding the command.  On
;;; exit, *format-index* points to the command character itself.
;;; Returns the list of parameters, the ":" flag, the "@" flag, and the
;;; command character as multiple values.  Explicitly defaulted parameters
;;; appear in the list of parameters as NIL.  Omitted parameters are simply 
;;; not included in the list at all.

(defun parse-format-operation (&optional get-params) ; only caller is format-find-command
  (let ((ch (format-nextchar)) parms colon atsign)
    (when (or (digit-char-p ch)
              ;(%str-member ch ",#Vv'"))
              (memq ch '(#\- #\, #\# #\V #\v #\')))      
      (cond (get-params
             (setq parms (list (format-get-parameter ch)))
             (until (neq (setq ch (format-peek)) #\,)
               (setq ch (format-nextchar))
               (push (format-get-parameter ch) parms)))
            (t (setq parms t)  ; tell caller there were some so we get correct error msgs
               (format-skip-parameter ch)
               (until (neq (setq ch (format-peek)) #\,)
                 (setq ch (format-nextchar))
                 (format-skip-parameter ch)))))
    ; allow either order
    (case ch
      (#\: (setq colon t ch (format-nextchar))
           (when (eq ch #\@)
             (setq atsign t ch (format-nextchar))))
      (#\@ (setq atsign t ch (format-nextchar))
           (when (eq ch #\:)
             (setq colon t ch (format-nextchar)))))
    (values (if (consp parms) (nreverse parms) parms)
            colon
            atsign
            ch)))


;;; Starting at the current value of *format-index*, finds the first
;;; occurrence of one of the specified directives. Embedded constructs,
;;; i.e. those inside ~(~), ~[~], ~{~}, or ~<~>, are ignored.  And error is
;;; signalled if no satisfactory command is found.  Otherwise, the
;;; following are returned as multiple values:
;;;
;;;     The value of *format-index* at the start of the search
;;;     The index of the "~" character preceding the command
;;;     The parameter list of the command
;;;     The ":" flag
;;;     The "@" flag
;;;     The command character
;;;
;;; Implementation note:  The present implementation is not particulary
;;; careful with storage allocation.  It would be a good idea to have
;;; a separate function for skipping embedded constructs which did not
;;; bother to cons parameter lists and then throw them away. This issue has been addressed. (akh)
;;;
;;; We go to some trouble here to use POSITION for most of the searching.
;;; God only knows why!!!!

;; and interesting note - the only caller who wants parameters is format-get-segments for
;; ~< .... ~n:; ...~>
(defun format-find-command (command-list &optional get-params evil-commands)
  (let* ((start *format-index*)
         (length *format-length*)
         tilde)
    (loop
      (setq tilde (format-find-char #\~ *format-index* length))
      (if (not tilde) (format-error "Expecting one of ~S" command-list))
      (setq *format-index* tilde)
      (multiple-value-bind (parms colon atsign command)
                           (parse-format-operation get-params)
        (when (memq command command-list)
          (return (values start tilde parms colon atsign command)))
        (when (and evil-commands
                   (or (memq command  '(#\w #\_ #\i #\W #\I))
                       (and colon (memq command '(#\t #\T)))))
          (format-error "Illegal in this context"))
        (case command
          (#\{ (format-nextchar) (format-find-command '(#\})))
          (#\( (format-nextchar) (format-find-command '(#\))))
          (#\[ (format-nextchar) (format-find-command '(#\])))
          (#\< (format-nextchar) 
               (multiple-value-bind (prev tilde parms colon atsign cmd)
                   (format-find-command '(#\>))
                 (declare (ignore prev tilde parms atsign cmd))
                 (if (and evil-commands colon)
                     (format-error "Logical-block directive not allowed inside justification directive"))))
	  (#\~ (format-nextchar))
          ((#\} #\> #\) #\])
           (format-error "No matching bracket")))))))

(defun format-find-command-no-params (command-list &key (colon t) (atsign t))
  (multiple-value-bind (prev tilde parms colon-flag atsign-flag command)
                       (format-find-command command-list)
    (with-format-parameters parms ()
      (format-no-flags (and (not colon) colon-flag) (and (not atsign) atsign-flag)))
    (values prev tilde command colon-flag atsign-flag)))

;;; This is the FORMAT top-level function.

(defun format (stream control-string &rest format-arguments)
  (declare (dynamic-extent format-arguments))
  (if (null stream)
    (with-output-to-string (s)
			   (apply #'format s control-string format-arguments))
    (if (stringp stream)
      (with-output-to-string (s stream)
			     (apply #'format s control-string format-arguments))
      (let ((*format-top-level* t))
	(when (xp-structure-p stream)(setq stream (xp-stream-stream stream))) ; for xp tests only! They call format on a structure
	(setq stream (if (eq stream t)
		       *standard-output*
		       (require-type stream 'stream)))     
	(if (functionp control-string)
	  (apply control-string stream format-arguments)
	  (let* ((control-string (ensure-simple-string control-string))
                 (*format-control-string* control-string)
                 (*format-pprint* nil)
                 (*format-justification-semi* nil))
            (declare (type simple-string control-string))
	    (cond
	      ;; Try to avoid pprint overhead in this case.
	      ((not (position #\~ control-string))
	       (write-string control-string stream))
	      ((and (or *print-pretty* *print-circle*)
		    (not (typep stream 'xp-stream)))
	       (maybe-initiate-xp-printing
		#'(lambda (s o)
		    (do-sub-format-1 s o))
		stream format-arguments))
	      (t 
	       (let ((*format-original-arguments* format-arguments)
		     (*format-arguments* format-arguments)
		     (*format-colon-rest* 'error)) ; what should this be??
		 (do-sub-format stream))))))
	nil))))

(defun format-to-string (string control-string &rest format-arguments)
  (declare (dynamic-extent format-arguments))
  (if string
    (with-output-to-string (stream string)
      (apply #'format stream control-string format-arguments))
    (with-output-to-string (stream)
      (apply #'format stream control-string format-arguments))))

(defun do-sub-format (stream)
  (let (errorp)
    (setq errorp
          (catch 'format-error
            (catch 'format-escape 
              (sub-format stream 0 (length *format-control-string*)))
            nil))    
    (when errorp
      (error "~%~:{~@?~%~}" (nreverse errorp)))))



;;; This function does the real work of format.  The segment of the control
;;; string between indiced START (inclusive) and END (exclusive) is processed
;;; as follows: Text not part of a directive is output without further
;;; processing.  Directives are parsed along with their parameters and flags,
;;; and the appropriate handlers invoked with the arguments COLON, ATSIGN, and
;;; PARMS. 
;;;

;;; POP-FORMAT-ARG also defined in l1-format

; in l1-format
(def-standard-initial-binding *logical-block-xp* nil)

(without-duplicate-definition-warnings
 (defun pop-format-arg (&aux (args *format-arguments*) (xp *logical-block-xp*) (av *format-arguments-variance*))
   (when (and (null args) (null xp))
     (format-error "Missing argument"))
   (when xp
     (if (null av)
       (when (pprint-pop-check+ args xp)    ; gets us level and length stuff in logical block
         (throw 'logical-block nil))
       ;; Could record that might exit here, but nobody cares.
       #+no (note-format-scan-option *logical-block-options*)))
   (if (or (null av) (eql av 0))
     (progn
       (setq *format-arguments* (cdr args))
       (%car args))
     (let ((types (loop for x in args as i from 0 below av
                    collect (nx-form-type x))))
       (when (eql av (length args))
         (setq *format-arguments-variance* (1- av)))
       (setq *format-arguments* (cdr args))
       `(the (or ,@types) (car *format-arguments*))))))

; SUB-FORMAT is now defined in L1-format.lisp
; DEFFORMAT is also defined there.

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; pretty-printing stuff
;;; 

(defformat #\W format-write (stream colon atsign)
  (format-no-semi #\W)
  (let ((arg (pop-format-arg)))
    (cond (atsign
       (let ((*print-level* nil)
             (*print-length* nil))
         (if colon
           (let ((*print-pretty* t))
             (write-1 arg stream))
           (write-1 arg stream))))
      (t (if colon
           (let ((*print-pretty* t))
             (write-1 arg stream))
           (write-1 arg stream))))))

(defformat #\I format-indent (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (declare (ignore atsign))
  (format-no-semi #\I)
  (with-format-parameters parms ((n 0))
    (pprint-indent (if colon :current :block) n stream)))

(defformat #\_ format-conditional-newline (stream colon atsign)
  (format-no-semi #\_)
  (let ((option
         (cond (atsign
                (cond (colon  :mandatory)
                      (t :miser)))
               (colon :fill)
               (t :linear))))
    (pprint-newline option stream)))

;;; Tabulation  ~T 

(defformat #\T format-tab (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (when colon
    (format-no-semi #\T t))
  (with-format-parameters parms ((colnum 1) (colinc 1))
    (cond ((or (typep stream 'xp-stream) (xp-structure-p stream))
           (let ((kind (if colon
                           (if atsign :section-relative :section)
                           (if atsign :line-relative :line))))
             (cond ((xp-structure-p stream)
                    (pprint-tab+ kind colnum colinc stream))
                   ((typep stream 'xp-stream)
                    (pprint-tab+ kind colnum colinc
                                 (slot-value stream 'xp-structure))))))
          ((not colon)
           (pprint-tab-not-pretty stream colnum colinc atsign)))))

(defun pprint-tab-not-pretty (stream colnum colinc &optional atsign)
  (let* ((position (column stream))
         (count (if atsign
                  (if position
                    (if (zerop colinc)
                      colnum (+ colnum (mod (- (+ position colnum)) colinc)))
                    colnum)
                  (if position
                    (if (<= colnum position)
                      (if (zerop colinc)
                        0 (- colinc (mod (- position colnum) colinc)))
                      (- colnum position))
                    2))))
    (while (> count 0)
      (write-string "                                                                                "
                           stream :start 
                           0 :end (min count 80))
      (setq count (- count 80)))))


;;; ~/ call function
(defformat #\/ format-call-function (stream colon atsign &rest parms)
  (let* ((string *format-control-string*)
         (ipos (1+ *format-index*))
         (epos (format-find-char #\/ ipos *format-length*)))    
    ; the spec is DUMB here - it requires that : and :: be treated the same
    (when (not epos) (format-error "Unmatched ~~/"))
    (let ((cpos (format-find-char #\: ipos epos))
          package)
      (cond (cpos 
             (setq package (or (find-package (string-upcase (%substr string ipos cpos)))
                               (format-error "Unknown package")))
             (when (eql #\: (schar string (%i+ 1 cpos)))
               (setq cpos (%i+ cpos 1)))
             (setq ipos (%i+ cpos 1)))
            (t (setq package (find-package "CL-USER"))))
      (let ((thing (intern (string-upcase (%substr string ipos epos)) package)))
        (setq *format-index* epos) ; or 1+ epos?
	(apply thing stream (pop-format-arg) colon atsign parms)))))

;;; Conditional case conversion  ~( ... ~)

#| coral's old version
(defformat #\( format-capitalization (stream colon atsign)
  (format-nextchar)
  (multiple-value-bind (prev tilde) (format-find-command-no-params '(#\)))
   (let* (finished
          (string (with-format-string-output stream
                    (setq finished (catch 'format-escape (sub-format stream prev tilde) t)))))
     (write-string
         (cond ((and atsign colon)
                (nstring-upcase string))
               (colon
                (nstring-capitalize string))
               (atsign
                (let ((strlen (length string)))
                     ;; Capitalize the first word only
                     (nstring-downcase string)
                     (do ((i 0 (1+ i)))
                         ((or (<= strlen i) (alpha-char-p (char string i)))
                          (setf (char string i) (char-upcase (char string i)))
                          string))))
               (t (nstring-downcase string)))
         stream :start 
         0 :end (length string))
     (unless finished (throw 'format-escape nil)))))

|#

(defformat #\( format-capitalization (stream colon atsign)
  (format-nextchar)
  (multiple-value-bind (prev tilde) (format-find-command-no-params '(#\)))
    (let (catchp)
      (cond ((typep stream 'xp-stream)
             (let ((xp (slot-value stream 'xp-structure)))
               (push-char-mode xp (cond ((and colon atsign) :UP)
				         (colon :CAP1)
				         (atsign :CAP0)
				         (T :DOWN)))
               (setq catchp
                     (catch 'format-escape
                       (sub-format stream prev tilde)
                       nil))
	       (pop-char-mode xp)))
            (t
             (let* ((string (with-format-string-output stream                      
                              (setq catchp (catch 'format-escape
                                             (sub-format stream prev tilde)
                                             nil)))))
               (write-string
                (cond ((and atsign colon)
                       (nstring-upcase string))
                      (colon
                       (nstring-capitalize string))
                      (atsign
                       ;; Capitalize the first word only
                       (nstring-downcase string)
                       (dotimes (i (length string) string)
                         (let ((ch (char string i)))
                           (when (alpha-char-p ch)
                             (setf (char string i) (char-upcase ch))
                             (return string)))))
                      (t (nstring-downcase string)))         
                stream :start 
                0 :end (length string)))))
      (when catchp
        (throw 'format-escape catchp))
      )))

;;; Up and Out (Escape)  ~^

(defformat #\^ format-escape (stream colon atsign &optional p1 p2 p3)
  (declare (ignore stream))
  (when atsign
    (format-error "FORMAT command ~~~:[~;:~]@^ is undefined" colon))
  (when (cond (p3 (etypecase p2
                    (real
                     (<= p1 p2 p3))
                    (character
                     (char< p1 p2 p3))))
              (p2 (equal p1 p2))
              (p1 (eql p1 0))
              (t (null (if colon *format-colon-rest* *format-arguments*))))
    (throw 'format-escape (if colon 'format-colon-escape t))))

;;; Conditional expression  ~[ ... ]


;;; ~[  - Maybe these guys should deal with ~^ too - i.e. catch format-escape etc.
;;; but I cant think of a case where just throwing to the { catcher fails

(defun format-untagged-condition (stream)
  (let ((test (pop-format-arg)))
    (unless (integerp test)
      (format-error "Argument to ~~[ must be integer - ~S" test))
    (do ((count 0 (1+ count)))
        ((= count test)
         (multiple-value-bind (prev tilde cmd colon atsign)
                              (format-find-command-no-params '(#\; #\]) :atsign nil)
           (declare (ignore colon atsign))
           (sub-format stream prev tilde)
           (unless (eq cmd #\])
             (format-find-command '(#\])))))
      (multiple-value-bind (prev tilde cmd colon atsign)
                           (format-find-command-no-params '(#\; #\]) :atsign nil)
        (declare (ignore prev tilde atsign))
        (when (eq cmd #\]) (return))
        (format-nextchar)
        (when colon
          (multiple-value-bind (prev tilde cmd colon atsign)
                               (format-find-command-no-params '(#\; #\]))
            (declare (ignore colon atsign))
            (sub-format stream prev tilde)
            (unless (eq cmd #\])
              (format-find-command-no-params '(#\]))))
          (return))))))


;;; ~@[

(defun format-funny-condition (stream)
  (multiple-value-bind (prev tilde) (format-find-command-no-params '(#\]))
    (if *format-arguments*
      (if (car *format-arguments*)
        (sub-format stream prev tilde)
        (pop *format-arguments*))
      (format-error "Missing argument"))))


;;; ~:[ 

(defun format-boolean-condition (stream)
  (multiple-value-bind (prev tilde command) (format-find-command-no-params '(#\; #\]))
    (when (eq command #\])
      (format-error "Two clauses separated by ~~; are required for ~~:["))
    (format-nextchar)
    (if (pop-format-arg)
      (multiple-value-bind (prev tilde)
          (format-find-command-no-params '(#\]) :colon nil :atsign nil)
        (sub-format stream prev tilde))
      (progn
        (sub-format stream prev tilde)
        (format-find-command-no-params '(#\]))))))


(defformat #\[ format-condition (stream colon atsign &optional p)
  (when p (push p *format-arguments*))
  (format-nextchar)
  (cond (colon
         (when atsign
           (format-error  "~~:@[ undefined"))
         (format-boolean-condition stream))
        (atsign
         (format-funny-condition stream))
        (t (format-untagged-condition stream))))


;;; Iteration  ~{ ... ~}

(defformat #\{ format-iteration (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (with-format-parameters parms ((max-iter -1))
    (format-nextchar)
    (multiple-value-bind (prev tilde end-cmd end-colon end-atsign)
                         (format-find-command-no-params '(#\}) :atsign nil)
      (declare (ignore end-cmd end-atsign))
      (if (= prev tilde)
        ;; Use an argument as the control string if ~{~} is empty
        (let ((string (pop-format-arg)))
          (cond ((stringp string)
                 (when (not (simple-string-p string)) ; fix here too
                   (setq string (coerce string 'simple-string))))
                ((not (functionp string))
                 (format-error "Control string is not a string or function")))          
          (let ((error 
                 (catch 'format-error
                   (cond
                    ((stringp string)
                     (let* ((length (length (the simple-string string)))
                            (*format-control-string* string)
                            (*format-length* length)
                            (*format-index* 0))
                       (format-do-iteration stream 0 length
                                            max-iter colon atsign end-colon)))
                    (t ;(functionp string)
                     (format-do-iteration stream string nil 
                                          max-iter colon atsign end-colon)))
                   nil)))
            (when error (format-indirect-error error))))
        (format-do-iteration stream prev tilde 
                             max-iter colon atsign end-colon)))))


;;; The two catch tags FORMAT-ESCAPE and FORMAT-COLON-ESCAPE are needed here
;;; to correctly implement ~^ and ~:^.  The former aborts only the current
;;; iteration, but the latter aborts the entire iteration process.
;;; ~{ arg is a list  ~:{ arg is list of sublists, ~@{  arg is spread ~:@{ spread lists
;;; We have nuked two catch tags. Instead throw two different values:
;;; T if ~^ and 'format-colon-escape if ~:^

(defun format-do-iteration (stream start end max-iter colon atsign at-least-once-p)
  (flet ((do-iteration-1 (stream start end colon at-least-once-p)
           (let (catchp)
             (do* ((count 0 (1+ count)))
                  ((or (= count max-iter)
                       (and (null *format-arguments*)
                            (if (= count 0) (not at-least-once-p) t))))
               (setq catchp
                     (catch 'format-escape
                       (if colon
                         (let* ((args (unless (and at-least-once-p (null *format-arguments*))
                                        (pop-format-arg)))
                                (*format-top-level* nil)
                                (*format-colon-rest* *format-arguments*)
                                (*format-arguments* args)
                                (*format-original-arguments* args))
                           (unless (listp *format-arguments*)
                             (report-bad-arg *format-arguments* 'list))
                           (if (functionp start)
                             (apply start stream args)
                             (sub-format stream start end)))
                         (let ((*format-original-arguments* *format-arguments*))
                           (if (functionp start)
                             (setq *format-arguments* (apply start stream *format-arguments*))
                             (sub-format stream start end))))
                       nil))
               (when (or (eq catchp 'format-colon-escape)
                         (and catchp (null colon)))
                 (return-from do-iteration-1  nil))))))
      (if atsign
        (do-iteration-1 stream start end colon at-least-once-p)        
        ; no atsign - munch on first arg
        (let* ((*format-arguments* (pop-format-arg))
               (*format-top-level* nil)
               (*format-original-arguments* *format-arguments*))
          (unless (listp *format-arguments*)
            (report-bad-arg *format-arguments* 'list))
          (do-iteration-1 stream start end colon at-least-once-p)))))
  

;;; Justification  ~< ... ~>

;;; Parses a list of clauses delimited by ~; and terminated by ~>.
;;; Recursively invoke SUB-FORMAT to process them, and return a list
;;; of the results, the length of this list, and the total number of
;;; characters in the strings composing the list.


(defun format-get-trailing-segments ()
  (format-nextchar)
  (multiple-value-bind (prev tilde parms colon atsign cmd)
                       (format-find-command '(#\; #\>) nil T)
    (with-format-parameters parms ()
      (when colon
        (format-error "~~:; allowed only after first segment in ~~<"))
      (format-no-flags nil atsign))
    (let ((str (catch 'format-escape
                 (with-format-string-output stream
                   (sub-format stream prev tilde)))))      
      (if (stringp str)
        (if (eq cmd #\;)
          (multiple-value-bind
            (segments numsegs numchars)
            (format-get-trailing-segments)
            (values (cons str segments)
                    (1+ numsegs)
                    (+ numchars
                       (length str))))
          (values (list str)
                  1
                  (length str)))
        (progn
          (unless (eq cmd #\>) (format-find-command '(#\>) nil T))
          (values () 0 0))))))


;;; Gets the first segment, which is treated specially.  Call 
;;; FORMAT-GET-TRAILING-SEGMENTS to get the rest.

(defun format-get-segments ()
  (let (ignore)
    (declare (ignore-if-unused ignore)) ; why??
    (multiple-value-bind (prev tilde parms colon atsign cmd)
                         (format-find-command '(#\; #\>) nil T) ; skipping
      (when atsign
        (format-error "Atsign flag not allowed"))
      ;(setq *format-arguments* blech)
      (let ((first-seg (catch 'format-escape
                         (with-format-string-output stream
                           (sub-format stream prev tilde)))))
        (if (stringp first-seg)
          (if (eq cmd #\;)
            (progn
              (when parms
                (setq *format-index* tilde)
                ; now get the parameters if any - do this way cause of the V thingies
                ; maybe only necessary in the : case
                (multiple-value-setq (ignore ignore parms)
                                     (format-find-command '(#\; #\>) t T)))              
              (multiple-value-bind
                (segments numsegs numchars)
                (format-get-trailing-segments)
                (if colon
                  (values first-seg parms segments numsegs numchars)
                  (values nil nil (cons first-seg segments)
                          (1+ numsegs)
                          (+ (length first-seg) numchars)))))
            (values nil nil (list first-seg) 1 (length first-seg)))
          (progn
            (unless (eq cmd #\>) (format-find-command '(#\>) nil T))
            (values nil nil () 0 0)))))))


#|
;;; Given the total number of SPACES needed for padding, and the number
;;; of padding segments needed (PADDINGS), returns a list of such segments.
;;; We try to allocate the spaces equally to each segment.  When this is
;;; not possible, we allocate the left-over spaces randomly, to improve the
;;; appearance of many successive lines of justified text.
;;; 
;;; Query:  Is this right?  Perhaps consistency might be better for the kind
;;; of applications ~<~> is used for.

(defun make-pad-segs (spaces paddings)
  (do* ((extra-space () (and (plusp extra-spaces)
                             (< (random (float 1)) (/ segs extra-spaces))))
        (result () (cons (if extra-space (1+ min-space) min-space) result))
        (min-space (truncate spaces paddings))
        (extra-spaces (- spaces (* paddings min-space))
                      (if extra-space (1- extra-spaces) extra-spaces))
        (segs paddings (1- segs)))
       ((zerop segs) result)))
|#
(defun make-pad-segs (spaces segments)
  (multiple-value-bind (min-space extra-spaces) (truncate spaces segments)
    (declare (fixnum min-space extra-spaces))
    (let* ((result (make-list segments :initial-element min-space))
           (res result))
      (setq min-space (1+ min-space))
      (dotimes (i extra-spaces)
        (rplaca res min-space)
        (setq res (%cdr res)))
      result)))

;;; Determine the actual width to be used for a field requiring WIDTH
;;; characters according to the following rule:  If WIDTH is less than or
;;; equal to MINCOL, use WIDTH as the actual width.  Otherwise, round up 
;;; to MINCOL + k * COLINC for the smallest possible positive integer k.

(defun format-round-columns (width mincol colinc)
  (if (< width mincol)
    (+ width (* colinc (ceiling (- mincol width) colinc)))
    width))

(defun format-justification-round-columns (width mincol colinc)
  (if (< width mincol)
    mincol
    (+ mincol (* colinc (ceiling (- width mincol) colinc)))))

(defformat #\< format-justification (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (multiple-value-bind (start tilde ecmd ecolon eatsign)
                       (format-find-command-no-params '(#\>)) ; bumps format-index
    (declare (ignore tilde ecmd))
    (cond
     (ecolon
      (format-logical-block stream colon atsign eatsign start *format-index* parms))
     (t (setq *format-index* start)
        (with-format-parameters parms ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
          (unless (integerp mincol)
            (format-error "Mincol must be an integer - ~S" mincol))
          (unless (and (integerp colinc) (plusp colinc))
            (format-error "Colinc must be a positive integer - ~S" colinc))
          (unless (integerp minpad)
            (format-error "Minpad must be an integer - ~S" minpad))
          (unless (characterp padchar)
            (if (typep padchar `(integer 0 #.char-code-limit))
              (setq padchar (code-char padchar))
              (format-error "Padchar must be a character or integer from 0 to ~a - ~S"
                            char-code-limit padchar)))
          (format-nextchar)
          (multiple-value-bind (special-arg special-parms segments numsegs numchars)
                               (format-get-segments)
            (when (= numsegs 1) (setq minpad 0))
            (when segments
              (let* ((padsegs (+ (if (or colon (= numsegs 1)) 1 0)
                                 (1- numsegs)
                                 (if atsign 1 0)))
                     (width (format-justification-round-columns (+ numchars (* minpad padsegs))
                                                  mincol colinc))
                     (spaces (if (and atsign (not colon) (= numsegs 1)) ;dirty but works
                                 (list 0 (- width numchars))
                                 (append (if (or colon (= numsegs 1)) () '(0))
                                         (make-pad-segs (- width numchars) padsegs)
                                         (if atsign () '(0))))))
                (when special-arg
                  (if *format-pprint*
                      (format-error "Justification illegal in this context"))
                  (setq *format-justification-semi* t)
                  (with-format-parameters special-parms ((spare 0)
                                                         (linel (stream-line-length stream)))
                      
                    (let ((pos (column stream)))
                      (when (> (+ pos width spare) linel)
                        (stream-write-entire-string stream special-arg)))))
                (do ((segs segments (cdr segs))
                     (spcs spaces (cdr spcs)))
                    ((null segs) (dotimes (i (car spcs)) (write-char padchar stream)))
                  (dotimes (i (car spcs)) (write-char padchar stream))
                  (stream-write-entire-string stream (car segs)))))))))))


(defun format-logical-block (stream colon atsign end-atsign start end &rest parms)
  (declare (ignore parms))
  (flet ((format-check-simple (str)
           (when (and str (or (%str-member #\~ str) (%str-member #\newline str)))
             (format-error "Suffix and prefix must be simple")))
         (first-block-p (start)
           (let* ((*format-index* 0))
             (loop
               (parse-format-operation)
               (when (eq (format-peek) #\<)
                 (cond ((eq *format-index* start)
                        (return t))
                       (t (return nil))))))))
    (format-no-semi #\<)
    (let ((format-string *format-control-string*)
          (prefix (if colon "(" ""))
          (suffix (if colon ")" ""))
          body-string start1 tilde ignore colon1 atsign1 per-line-p)
      (declare (ignore-if-unused ignore colon1))
      (setq *format-index* start)
      (multiple-value-setq (start1 tilde ignore colon1 atsign1)
        (format-find-command  '(#\; #\>)))
      (setq body-string (%substr format-string (1+ start) tilde))
      (when (not (eql *format-index* end)) ; > 1 segment
        (setq prefix body-string)
        (if atsign1 (setq per-line-p t))
        (multiple-value-setq (start1 tilde)
          (format-find-command '(#\; #\>)))
        (setq body-string (%substr format-string (1+ start1) tilde))
        (when (neq *format-index* end)
          (multiple-value-setq (start1 tilde)(format-find-command  '(#\; #\>)))
          (setq suffix (%substr format-string (1+ start1) tilde))
          (when (neq *format-index* end)
            (format-error "Too many chunks"))))
      (when end-atsign (setq body-string (format-fill-transform body-string)))
      (format-check-simple prefix)
      (format-check-simple suffix)
      (unless *format-arguments*
	(setq *format-index* start)
	(format-error "Missing argument"))
      (let ((args (if (not atsign)
                    ; This piece of garbage is needed to avoid double length counting from (formatter ...) things
                    ; but also to allow (flet . t) not to barf.
                    ; Was formerly simply  (if *format-arguments* (pop-format-arg))
                    ; Actually wanna not count the arg iff the ~< is at the top level
                    ; in a format string i.e. "is this the first ~< in THIS string?"                    
                    (when *format-arguments*
                      (if  (and (listp *format-arguments*)
                                (first-block-p start))
                        (pop *format-arguments*)  ; dont count
                        (pop-format-arg))) ; unless not listp or not first
                    (prog1 *format-arguments*
                      (setq *format-arguments* nil))))
            (*format-control-string* body-string)
            (*format-top-level* (and atsign *format-top-level*)))
        (let ((*logical-block-p* t)
              (xp-struct (cond ((xp-structure-p stream) stream)
                               ((typep stream 'xp-stream)
                                (slot-value stream 'xp-structure)))))
          ; lets avoid unnecessary closures
          (cond (xp-struct (logical-block-sub xp-struct args  prefix suffix per-line-p atsign))
                (t (maybe-initiate-xp-printing
                    #'(lambda (s o)
                        (logical-block-sub s o  prefix suffix per-line-p atsign))
                    stream args))))))))


    
; flet?
(defun logical-block-sub (stream args  prefix suffix per-line-p atsign)
  ;(push (list args body-string) barf)
  (let ((circle-chk (not (or *format-top-level* (and atsign (eq *current-length* -1)))))) ; i.e. ~<~@<
    (let ((*current-level* (1+ *current-level*)) ; these are for pprint
          (*current-length* -1))
      (declare (special *current-level* *current-length*))
      (unless (check-block-abbreviation stream args circle-chk) ;(neq args *format-original-arguments*)) ;??
        (start-block stream prefix per-line-p suffix)
        (let ((*logical-block-xp* stream)    ; for pop-format-arg
              (my-stream (if (xp-structure-p stream) (get-xp-stream stream) stream)))
          (catch 'logical-block
            (do-sub-format-1 my-stream args)))
        (end-block stream suffix)))))

; bash in fill conditional newline after white space (except blanks after ~<newline>)
; I think this is silly!
(defun format-fill-transform (string)
  (let ((pos 0)(end (length (the string string)))(result "") ch)
    (while (%i< pos end)
      (let ((wsp-pos (min (or (%str-member #\space string pos) end)
                          (or (%str-member #\tab string pos) end)))
            (yes nil))
        (when (%i< wsp-pos end)
          (when (not (and (%i> wsp-pos 1)
                          (eq (schar string (%i- wsp-pos 1)) #\newline)
                          (or (eq (setq ch (schar string (%i- wsp-pos 2))) #\~)
                              (and (%i> wsp-pos 2)
                                   (memq ch '(#\: #\@))
                                   (eq (schar string (%i- wsp-pos 3)) #\~)))))
            (setq yes t))
          (loop 
            (while (%i< wsp-pos end)
              (setq ch (schar string wsp-pos))
              (when (Not (%str-member ch wsp)) (return))
              (setq wsp-pos (%i+ 1 wsp-pos)))
            (return)))
        (setq result (%str-cat result (%substr string pos  wsp-pos) (if yes "~:_" "")))
      (setq pos wsp-pos)))
    result))


;;;;some functions needed for dealing with floats

;;;; Floating Point printing
;;;
;;;  Written by Bill Maddox
;;;
;;;
;;;
;;; FLONUM-TO-STRING (and its subsidiary function FLOAT-STRING) does most of 
;;; the work for all printing of floating point numbers in the printer and in
;;; FORMAT.  It converts a floating point number to a string in a free or 
;;; fixed format with no exponent.  The interpretation of the arguments is as 
;;; follows:
;;;
;;;     X        - The floating point number to convert, which must not be
;;;                negative.
;;;     WIDTH    - The preferred field width, used to determine the number
;;;                of fraction digits to produce if the FDIGITS parameter
;;;                is unspecified or NIL.  If the non-fraction digits and the
;;;                decimal point alone exceed this width, no fraction digits
;;;                will be produced unless a non-NIL value of FDIGITS has been
;;;                specified.  Field overflow is not considerd an error at this
;;;                level.
;;;     FDIGITS  - The number of fractional digits to produce. Insignificant
;;;                trailing zeroes may be introduced as needed.  May be
;;;                unspecified or NIL, in which case as many digits as possible
;;;                are generated, subject to the constraint that there are no
;;;                trailing zeroes.
;;;     SCALE    - If this parameter is specified or non-NIL, then the number
;;;                printed is (* x (expt 10 scale)).  This scaling is exact,
;;;                and cannot lose precision.
;;;     FMIN     - This parameter, if specified or non-NIL, is the minimum
;;;                number of fraction digits which will be produced, regardless
;;;                of the value of WIDTH or FDIGITS.  This feature is used by
;;;                the ~E format directive to prevent complete loss of
;;;                significance in the printed value due to a bogus choice of
;;;                scale factor.
;;;
;;; Most of the optional arguments are for the benefit for FORMAT and are not
;;; used by the printer.
;;;
;;; Returns:
;;; (VALUES DIGIT-STRING DIGIT-LENGTH LEADING-POINT TRAILING-POINT DECPNT)
;;; where the results have the following interpretation:
;;;
;;;     DIGIT-STRING    - The decimal representation of X, with decimal point.
;;;     DIGIT-LENGTH    - The length of the string DIGIT-STRING.
;;;     LEADING-POINT   - True if the first character of DIGIT-STRING is the
;;;                       decimal point.
;;;     TRAILING-POINT  - True if the last character of DIGIT-STRING is the
;;;                       decimal point.
;;;     POINT-POS       - The position of the digit preceding the decimal
;;;                       point.  Zero indicates point before first digit.
;;;     NZEROS          - number of zeros after point
;;;
;;; WARNING: For efficiency, there is a single string object *digit-string*
;;; which is modified destructively and returned as the value of
;;; FLONUM-TO-STRING.  Thus the returned value is not valid across multiple 
;;; calls.
;;;
;;; NOTE:  FLONUM-TO-STRING goes to a lot of trouble to guarantee accuracy.
;;; Specifically, the decimal number printed is the closest possible 
;;; approximation to the true value of the binary number to be printed from 
;;; among all decimal representations  with the same number of digits.  In
;;; free-format output, i.e. with the number of digits unconstrained, it is 
;;; guaranteed that all the information is preserved, so that a properly-
;;; rounding reader can reconstruct the original binary number, bit-for-bit, 
;;; from its printed decimal representation. Furthermore, only as many digits
;;; as necessary to satisfy this condition will be printed.
;;;
;;;
;;; FLOAT-STRING actually generates the digits for positive numbers.  The
;;; algorithm is essentially that of algorithm Dragon4 in "How to Print 
;;; Floating-Point Numbers Accurately" by Steele and White.  The current 
;;; (draft) version of this paper may be found in [CMUC]<steele>tradix.press.
;;; DO NOT EVEN THINK OF ATTEMPTING TO UNDERSTAND THIS CODE WITHOUT READING 
;;; THE PAPER!

#| Improvements beyond Steele and White:
 Steele and White (original and retrospective included): http://kurtstephens.com/files/p372-steele.pdf
 Bryan O'Sullivan: http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/
 Burger and Dybvig: http://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
 Loitsch: http://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf
 Ryan Juckett: http://www.ryanjuckett.com/programming/printing-floating-point-numbers/part-2/
 Gay: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.4049
|#

(defun flonum-to-string (n &optional width fdigits scale)
  (let ((*print-radix* nil))
    (cond ((zerop n)(values "" 0 0))
          ((and (not (or width fdigits scale))
                (double-float-p n)
                ; cheat for the only (?) number that fails to be aesthetically pleasing
                (= n 1e23))
           (values "1" 24 23))
          (t (let ((string (make-array 12 :element-type 'base-char
                                       :fill-pointer 0 :adjustable t)))
               (multiple-value-bind (sig exp)(integer-decode-float n)
                 (float-string string sig exp (integer-length sig) width fdigits scale)))))))

;;; if width given and fdigits nil then if exponent is >= 0 returns at
;;; most width-1 digits if exponent is < 0 returns (- width (- exp) 1)
;;; digits if fdigits given width is ignored, returns fdigits after
;;; (implied) point The Steele/White algorithm can produce a leading
;;; zero for 1e23 which lies exactly between two double floats -
;;; rounding picks the float whose rational is
;;; 99999999999999991611392. This guy wants to print as
;;; 9.999999999999999E+22. The untweaked algorithm generates a leading
;;; zero in this case.  (actually wants to print as 1e23!)  If we
;;; choose s such that r < s - m/2, and r = s/10 - m/2 (which it does
;;; in this case) then r * 10 < s => first digit is zero and
;;; (remainder (* r 10) s) is r * 10 = new-r, 10 * m = new-m new-r = s
;;; - new-m/2 so high will be false and she won't round up we do r *
;;; (expt 2 (- e (- scale))) and s * (expt 5 (- scale)) i.e. both less
;;; by (expt 2 (- scale))

(defun float-string (string f e p &optional width fdigits scale)
  (macrolet ((nth-digit (n) `(%code-char (%i+ ,n (%char-code #\0)))))    
    (let ((r f)(s 1)(m- 1)(m+ 1)(k 0) cutoff roundup (mm nil))
      (when (= f (if (eql p 53) #.(ash 1 52) (ash 1 (1- p))))
        (setq mm t))
      (when (or (null scale)(zerop scale))
        ; approximate k
        (let ((fudge 0))
          (setq fudge (truncate (*  (%i+ e p) .301)))
          (when (neq fudge 0)
            (setq k fudge)
            (setq scale (- k)))))
      (when (and scale (not (eql scale 0)))      
        (if (minusp scale)
          (setq s (* s (5-to-e  (- scale))))
          (let ((scale-factor (5-to-e scale)))
            (setq r (* r scale-factor))
            (setq m+ scale-factor)
            (when mm (setq m- scale-factor)))))
      (let ((shift (- e (if scale (- scale) 0))))
        (declare (fixnum shift))
        ;(print (list e scale shift))
        (cond ((> shift 0)
               (setq r (ash f shift))
               (setq m+ (ash m+ shift))
               (when mm (setq m- (ash m- shift))))
              ((< shift 0)
               (setq s (ash s (- shift))))))
      (when mm
        (setq m+ (+ m+ m+))
        (setq r (+ r r))
        (setq s (+ s s)))    
      (let ((ceil (ceiling s 10))(fudge 1))
        (while (< r ceil)
          (setq k (1- k))
          (setq r (* r 10))
          (setq fudge (* fudge 10)))
        (when (> fudge 1)
          (setq m+ (* m+ fudge))
          (when mm (setq m- (* m- fudge)))))    
      (let ((2r (+ r r)))
        (loop
          (let ((2rm+ (+ 2r m+)))          
            (while
              (if (not roundup)  ; guarantee no leading zero
                (> 2rm+ (+ s s))
                (>=  2rm+ (+ s s)))
              (setq s (* s 10))
              (setq k (1+ k))))
          (when (not (or fdigits width))(return))
          (cond 
           (fdigits (setq cutoff (- fdigits)))
           (width
            (setq cutoff
                  (if (< k 0) (- 1 width)(1+ (- k width))))
            ;(if (and fmin (> cutoff (- fmin))) (setq cutoff (- fmin)))
            ))
          (let ((a (if cutoff (- cutoff k) 0))
                (y s))
            (DECLARE (FIXNUM A))
            (if (>= a 0)
              (when (> a 0)(setq y (* y (10-to-e a))))
              (setq y (ceiling y (10-to-e (the fixnum (- a))))))
            (when mm (setq m- (max y m-)))
            (setq m+ (max y m+))
            (when (= m+ y) (setq roundup t)))
          (when (if (not roundup)   ; tweak as above
                  (<= (+ 2r m+)(+ s s))
                  (< (+ 2r m+)(+ s s)))
            (return))))
      (let* ((h k)
             (half-m+ (* m+ 5))  ; 10 * m+/2
             (half-m- (if mm (* m- 5)))
             u high low 
             )
        ;(print (list r s m+ roundup))
        (unless (and fdigits (>= (- k) fdigits))
          (loop
            (setq k (1- k))
            (multiple-value-setq (u r) (truncate (* r 10) s))          
            (setq low (< r (if mm half-m- half-m+)))
            (setq high 
                  (if (not roundup)
                    (> r (- s half-m+))
                    (>= r (- s half-m+))))                   
            (if (or low high)
              (return)
              (progn
                (vector-push-extend (nth-digit u) string)))
            (when mm (setq half-m- (* half-m- 10) ))
            (setq half-m+ (* half-m+ 10)))
          ;(print (list r s  high low h k))
          (vector-push-extend
           (nth-digit (cond
                       ((and low (not high)) u) 
                       ((and high (not low))(+ u 1))
                       
                       (t ;(and high low)
                        (if (<= (+ r r) s) u (1+ u)))))
           string))
        ; second value is exponent, third is exponent - # digits generated
        (values string h k)))))


(defparameter integer-powers-of-10 (make-array (+ 12 (floor 324 12))))

; e better be positive
(defun 10-to-e (e)
  (declare (fixnum e)(optimize (speed 3)(safety 0)))
  (if (> e 335)
    (* (10-to-e 334) (10-to-e (%i- e 334)))
    (if (< e 12)
      (svref integer-powers-of-10 e)
      (multiple-value-bind (q r) (truncate e 12)
        (declare (fixnum q r))        
        (if (eql r 0)
          (svref integer-powers-of-10 (%i+ q 11))
          (* (svref integer-powers-of-10 r)
             (svref integer-powers-of-10 (%i+ q 11))))))))


(let ((array integer-powers-of-10))
  (dotimes (i 12)
    (setf (svref array i)  (expt 10 i)))
  (dotimes (i (floor 324 12))
    (setf (svref array (+ i 12)) (expt 10 (* 12 (1+ i))))))
#|
(defun 10-to-e (e)
  (ash (5-to-e e) e))
|#
      
;;; Given a non-negative floating point number, SCALE-EXPONENT returns a
;;; new floating point number Z in the range (0.1, 1.0] and and exponent
;;; E such that Z * 10^E is (approximately) equal to the original number.
;;; There may be some loss of precision due the floating point representation.
;;; JUST do the EXPONENT since thats all we use

(defconstant single-float-min-e
  (nth-value 1 (decode-float least-positive-single-float)))
(defconstant double-float-min-e
  (nth-value 1 (decode-float least-positive-double-float)))

;;; Adapted from CMUCL.

;; This is a modified version of the scale computation from Burger and
;; Dybvig's paper "Printing floating-point quickly and accurately."
;; We only want the exponent, so most things not needed for the
;; computation of the exponent have been removed.  We also implemented
;; the floating-point log approximation given in Burger and Dybvig.
;; This is very noticeably faster for large and small numbers.  It is
;; slower for intermediate sized numbers.
(defun accurate-scale-exponent (v)
  (declare (type float v))
  (if (zerop v)
      1
      (let ((float-radix 2)		; b
	    (float-digits (float-digits v)) ; p
	    (min-e
	     (etypecase v
	       (single-float single-float-min-e)
	       (double-float double-float-min-e))))
	(multiple-value-bind (f e)
	    (integer-decode-float v)
	  (let ( ;; FIXME: these even tests assume normal IEEE rounding
		;; mode.  I wonder if we should cater for non-normal?
		(high-ok (evenp f)))
	    ;; We only want the exponent here.
	    (labels ((flog (x)
		       (declare (type (float (0.0)) x))
		       (let ((xd (etypecase x
				   (single-float
				    (float x 1d0))
				   (double-float
				    x))))
			 (ceiling (- (the (double-float -400d0 400d0)
					  (log xd 10d0))
				     1d-10))))
		     (fixup (r s m+ k)
		       (if (if high-ok
			       (>= (+ r m+) s)
			       (> (+ r m+) s))
			   (+ k 1)
			   k))
		     (scale (r s m+)
		       (let* ((est (flog v))
			      (scale (the integer (10-to-e (abs est)))))
			 (if (>= est 0)
			     (fixup r (* s scale) m+ est)
			     (fixup (* r scale) s (* m+ scale) est)))))
	      (let (r s m+)
		(if (>= e 0)
		    (let* ((be (expt float-radix e))
			   (be1 (* be float-radix)))
		      (if (/= f (expt float-radix (1- float-digits)))
			  (setf r (* f be 2)
				s 2
				m+ be)
			  (setf r (* f be1 2)
				s (* float-radix 2)
				m+ be1)))
		    (if (or (= e min-e) 
			    (/= f (expt float-radix (1- float-digits))))
			(setf r (* f 2)
			      s (* (expt float-radix (- e)) 2)
			      m+ 1)
			(setf r (* f float-radix 2)
			      s (* (expt float-radix (- 1 e)) 2)
			      m+ float-radix)))
		(scale r s m+))))))))

;;; Page  ~|

(defformat #\| format-page (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-no-flags colon atsign)
  (with-format-parameters parms ((repeat-count 1))
    (declare (fixnum repeat-count))
    (dotimes (i repeat-count) (write-char #\page stream))))


(defun format-eat-whitespace ()
  (do* ((i *format-index* (1+ i))
        (s *format-control-string*)
        (n *format-length*))
       ((or (= i n)
            (not (whitespacep (schar s i))))
        (setq *format-index* (1- i)))))

(defun format-newline (stream colon atsign parms)
  (with-format-parameters parms ()
    (cond (colon
           (when atsign
             (format-error "~:@<newline> is undefined")))
          (atsign (terpri stream) (format-eat-whitespace))
          (t (format-eat-whitespace)))))
  
(defformat  #\newline format-newline (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-newline stream colon atsign parms))

(defformat #\return format-newline (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-newline stream colon atsign parms))

;;; Indirection  ~?

(defformat #\? format-indirection (stream colon atsign)
  (format-no-flags colon nil)
  (let ((string (pop-format-arg)))
    (unless (or (stringp string)(functionp string))
      (format-error "Indirected control string is not a string or function"))
    (when (and (stringp string) (not (simple-string-p string)))
      (setq string (coerce string 'simple-string)))
    (catch 'format-escape
      (let ((error 
             (catch 'format-error
               (cond 
                ((stringp string)
                 (let* ((length (length (the simple-string string)))
                        (*format-control-string* string)
                        (*format-length* length)
                        (*format-index* 0))
                    (if atsign
                      (sub-format stream 0 length)
                      (let ((args (pop-format-arg)))
                        (let ((*format-top-level* nil)
                              (*format-arguments* args)
                              (*format-original-arguments* args))
                          (sub-format stream 0 length))))))
                (T ;(functionp string)
                 (if (not atsign)
                   (apply string stream (pop-format-arg))
                   ; account for the args it eats
                   (setq *format-arguments* (apply string stream *format-arguments*)))))
               nil)))
        (when error (format-indirect-error error))))))




;;; Ascii  ~A

(defformat #\A format-princ (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (let ((arg (pop-format-arg)))
    (if (null parms)
      (princ (or arg (if colon "()" nil)) stream)
      (with-format-parameters parms ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
        (format-write-field
         stream
         (if (or arg (not colon))
           (princ-to-string arg)
           "()")
         mincol colinc minpad padchar atsign)))))



;;; S-expression  ~S
	    
(defformat #\S format-prin1 (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (let ((arg (pop-format-arg)))
    (if (null parms)
      (if (or arg (not colon)) (prin1 arg stream) (princ "()" stream))
      (with-format-parameters parms ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
        (format-write-field
         stream
         (if (or arg (not colon))
           (prin1-to-string arg)
           "()")
         mincol colinc minpad padchar atsign)))))



;;; Character  ~C

(defformat #\C format-print-character (stream colon atsign)
  (let* ((char (character (pop-format-arg)))
         (code (char-code char))
         (name (char-name char)))
    (cond ((and atsign (not colon))
           (prin1 char stream))
          (colon
           (if (or (eql char #\space)
                   (not (graphic-char-p char)))
             (princ name stream)
             (write-char char stream)))
          ((not (or atsign colon))
           (write-char char stream))
          ((and (< code 32) atsign)
	   (setq char (code-char (logxor code 64)))
           (if (or colon (%str-member char "@CGHIJKLM[\\]^_"))
               (princ name stream)
               (progn
                 (write-char #\^ stream)
                 (write-char char stream)))
           (princ " (" stream)
           (princ "Control " stream)
           (write-char char stream)
           (write-char #\) stream))
          (name (princ name stream))
          (t (write-char char stream)))))


;;; NUMERIC PRINTING



;;; Output a string in a field at MINCOL wide, padding with PADCHAR.
;;; Pads on the left if PADLEFT is true, else on the right.  If the
;;; length of the string plus the minimum permissible padding, MINPAD,
;;; is greater than MINCOL, the actual field size is rounded up to
;;; MINCOL + k * COLINC for the smallest possible positive integer k.

(defun format-write-field (stream string mincol colinc minpad padchar padleft)
  (unless (or (null mincol)
              (integerp mincol))
    (format-error "Mincol must be an integer - ~S" mincol))
  (unless (and (integerp colinc) (plusp colinc))
    (format-error "Colinc must be a positive integer - ~S" colinc))
  (unless (integerp minpad)
    (format-error "Minpad must be an integer - ~S" minpad))
  (unless (characterp padchar)
    (if (typep padchar `(integer 0 #.char-code-limit))
      (setq padchar (code-char padchar))
      (format-error "Padchar must be a character or integer from 0 to ~a - ~S"
                    char-code-limit padchar)))
  (let* ((strlen (length (the string string)))
         (strwid (+ strlen minpad))
         (width (if mincol
                  (format-round-columns strwid mincol colinc)
                  strwid)))
    (if padleft
      (dotimes (i (the fixnum (- width strlen))) (write-char padchar stream)))
    (write-string string stream :start  0 :end strlen)
    (unless padleft
      (dotimes (i (the fixnum (- width strlen))) (write-char padchar stream)))))


;;; This functions does most of the work for the numeric printing
;;; directives.  The parameters are interpreted as defined for ~D.

(defun format-print-number (stream number radix print-commas-p print-sign-p parms)
  (declare (dynamic-extent parms))
  (declare (type t number) (type fixnum radix))
  #+wrong
  (when (> (length parms) 2) (setq print-commas-p t)) ; print commas if char or interval provided
  (if (not (integerp number))
      (let ((*print-base* radix)
            (*print-escape* nil)
            (*print-radix* nil))
        (declare (special *print-base* *print-radix*))
        (princ number stream))
    (with-format-parameters parms
          ((mincol 0) (padchar #\space) (commachar #\,) (commainterval 3))
      ; look out for ",0D" - should be ",'0D"
      (unless (characterp padchar)
        (error "Use '~A instead of ~A for padchar in format directive" padchar padchar))
       (setq print-sign-p 
             (cond ((and print-sign-p (>= number 0)) #\+)
                   ((< number 0) #\-)))
       (setq number (abs number))
       (block HAIRY
         (block SIMPLE
           (if (and (not print-commas-p) (eql 0 mincol))
             (return-from SIMPLE))
           (let ((lg 0)
                 (commas 0))
             (declare (type fixnum lg commas))
             (do ((n (abs number) (floor n radix)))
                 ((%i< n radix))
               (declare (type integer n))
               (setq lg (%i+ lg 1))) ; lg is 1- significant digits             
             (setq commas (if print-commas-p
                              (floor lg commainterval)
                              0))
             (when print-sign-p
               (setq lg (1+ lg)))
             (when (and (eq commas 0)
                        (%i<= mincol lg))
               (return-from SIMPLE))
             ;; Cons-o-rama no more !
             (let* ((s (make-string-output-stream)))
               (when  (neq padchar #\space)
                 (dotimes (i (- mincol (+ lg commas) 1))
                   (write-char padchar s)))
               (when print-sign-p (write-char print-sign-p s))
               (%pr-integer  number radix s)                           
               (dotimes (i (the fixnum commas)) (write-char commachar s))
               (let ((text (get-output-stream-string s)))
                 (declare (type string text))
                 ;; -1234567,, => -1,234,567
                 (when (%i> commas 0)
                   (do* ((dest (%i- (length text) 1))
                         (source (%i- dest commas)))
                        ((= source dest))
                     (declare (type fixnum dest source))
                     (dotimes (i (the fixnum commainterval))
                       (setf (char text dest) (char text source)
                             dest (1- dest) 
                             source (1- source)))
                     (setf (char text dest) commachar
                           dest (1- dest))))
                 (format-write-field stream text mincol 1 0 padchar t)
                 (return-from HAIRY)))))
         ;; SIMPLE case         
         (when print-sign-p (write-char print-sign-p stream))
         (%pr-integer number radix stream))))
  nil)

;;; Print a cardinal number in English

(eval-when (:compile-toplevel :execute)
(defmacro cardinal-ones ()
  "Table of cardinal ones-place digits in English"
        '#(nil "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))
(defmacro cardinal-tens ()
  "Table of cardinal tens-place digits in English"
        '#(nil nil "twenty" "thirty" "forty"
           "fifty" "sixty" "seventy" "eighty" "ninety"))
(defmacro cardinal-teens ()
        '#("ten" "eleven" "twelve" "thirteen" "fourteen"  ;;; RAD
	   "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))
)


(defun format-print-small-cardinal (stream n)
  (multiple-value-bind (hundreds rem) (truncate n 100)
    (when (plusp hundreds)
      (write-string (svref (cardinal-ones) hundreds) stream)
      (write-string " hundred" stream)
      (when (plusp rem) (write-char #\space stream)))    ; ; ; RAD
    (when (plusp rem)
      (multiple-value-bind (tens ones) (truncate rem 10)
        (cond ((< 1 tens)
               (write-string (svref (cardinal-tens) tens) stream)
               (when (plusp ones)
                 (write-char #\- stream)
                 (write-string (svref (cardinal-ones) ones) stream)))
              ((= tens 1)
               (write-string (svref (cardinal-teens) ones) stream))
              ((plusp ones)
               (write-string (svref (cardinal-ones) ones) stream)))))))

(eval-when (:compile-toplevel :execute)
  (defmacro cardinal-periods ()
    "Table of cardinal 'teens' digits in English"
    '#("" " thousand" " million" " billion" " trillion" " quadrillion"
       " quintillion" " sextillion" " septillion" " octillion" " nonillion" 
       " decillion"))
)


(defun format-print-cardinal (stream n)
  (cond ((minusp n)
         (stream-write-entire-string stream "negative ")
         (format-print-cardinal-aux stream (- n) 0 n))
        ((zerop n)
         (stream-write-entire-string stream "zero"))
        (t (format-print-cardinal-aux stream n 0 n))))

(defun format-print-cardinal-aux (stream n period err)
  (multiple-value-bind (beyond here) (truncate n 1000)
    (unless (<= period 10)
      (format-error "Number too large to print in English: ~:D" err))
    (unless (zerop beyond)
      (format-print-cardinal-aux stream beyond (1+ period) err))
    (unless (zerop here)
      (unless (zerop beyond) (write-char #\space stream))
      (format-print-small-cardinal stream here)
      (stream-write-entire-string stream (svref (cardinal-periods) period)))))


;;; Print an ordinal number in English


(eval-when (:compile-toplevel :execute)
(defmacro ordinal-ones ()
  "Table of ordinal ones-place digits in English"
  '#(nil "first" "second" "third" "fourth"
         "fifth" "sixth" "seventh" "eighth" "ninth"))
(defmacro ordinal-tens ()
  "Table of ordinal tens-place digits in English"
  '#(nil "tenth" "twentieth" "thirtieth" "fortieth"
         "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth"))
)

(defun format-print-ordinal (stream n)
  (when (minusp n)
    (stream-write-entire-string stream "negative "))
  (let ((number (abs n)))
    (multiple-value-bind (top bot) (truncate number 100)
      (unless (zerop top) (format-print-cardinal stream (- number bot)))
      (when (and (plusp top) (plusp bot)) (write-char #\space stream))
      (multiple-value-bind (tens ones) (truncate bot 10)
        (cond ((= bot 12) (stream-write-entire-string stream "twelfth"))
              ((= tens 1)
               (stream-write-entire-string stream (svref (cardinal-teens) ones));;;RAD
               (stream-write-entire-string stream "th"))
              ((and (zerop tens) (plusp ones))
               (stream-write-entire-string stream (svref (ordinal-ones) ones)))
              ((and (zerop ones)(plusp tens))
               (stream-write-entire-string stream (svref (ordinal-tens) tens)))
              ((plusp bot)
               (stream-write-entire-string stream (svref (cardinal-tens) tens))
               (write-char #\- stream)
               (stream-write-entire-string stream (svref (ordinal-ones) ones)))
              ((plusp number) (write-string "th" stream :start  0 :end 2))
              (t (stream-write-entire-string stream "zeroth")))))))


;;; Print Roman numerals

(defun format-print-old-roman (stream n)
  (unless (< 0 n 5000)
          (format-error "Number out of range for old Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (start n (do ((i start (progn (write-char cur-char stream) (- i cur-val))))
                    ((< i cur-val) i))))
      ((zerop start))))


(defun format-print-roman (stream n)
  (unless (< 0 n 4000)
          (format-error "Number out of range for Roman numerals: ~:D" n))
  (do ((char-list '(#\D #\C #\L #\X #\V #\I) (cdr char-list))
       (val-list '(500 100 50 10 5 1) (cdr val-list))
       (sub-chars '(#\C #\X #\X #\I #\I) (cdr sub-chars))
       (sub-val '(100 10 10 1 1 0) (cdr sub-val))
       (cur-char #\M (car char-list))
       (cur-val 1000 (car val-list))
       (cur-sub-char #\C (car sub-chars))
       (cur-sub-val 100 (car sub-val))
       (start n (do ((i start (progn (write-char cur-char stream) (- i cur-val))))
                    ((< i cur-val)
                     (cond ((<= (- cur-val cur-sub-val) i)
                            (write-char cur-sub-char stream)
                            (write-char cur-char stream)
                            (- i (- cur-val cur-sub-val)))
                           (t i))))))
      ((zerop start))))


;;; Decimal  ~D

(defformat #\D format-print-decimal (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-print-number stream (pop-format-arg) 10 colon atsign parms))


;;; Binary  ~B

(defformat #\B format-print-binary (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-print-number stream (pop-format-arg) 2 colon atsign parms))


;;; Octal  ~O

(defformat #\O format-print-octal (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-print-number stream (pop-format-arg) 8 colon atsign parms))


;;; Hexadecimal  ~X

(defformat #\X format-print-hexadecimal (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (format-print-number stream (pop-format-arg) 16 colon atsign parms))


;;; Radix  ~R

(defformat #\R format-print-radix (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (let ((number (pop-format-arg))
        (parm (if parms (pop parms) nil)))
    (if parm
        (format-print-number stream number parm colon atsign parms)
        (if atsign
            (if colon
                (format-print-old-roman stream number)
                (format-print-roman stream number))
            (if colon
                (format-print-ordinal stream number)
                (format-print-cardinal stream number))))))

;;; FLOATING-POINT NUMBERS


;;; Fixed-format floating point  ~F

(defformat #\F format-fixed (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms ((w nil) (d nil) (k nil) (ovf nil) (pad #\space))
    ;;Note that the scale factor k defaults to nil.  This is interpreted as
    ;;zero by flonum-to-string, but more efficiently.
    (let ((number (pop-format-arg))(*print-escape* nil))
      (if (floatp number)
        (format-fixed-aux stream number w d k ovf pad atsign)
        (if (rationalp number)
          (format-fixed-aux stream (coerce number 'float) w d k ovf pad atsign)
          (let ((*print-base* 10))
            (format-write-field stream (princ-to-string number) w 1 0 #\space t)))))))

; do something ad hoc if d > w - happens if (format nil "~15g" (- 2.3 .1))
; called with w = 11 d = 16 - dont do it after all.

(defun format-fixed-aux (stream number w d k ovf pad atsign)
  (and w (<= w 0) (setq w nil))  ; if width is unreasonable, ignore it.
  (if (not (or w d))
    (print-float-free-form number stream)
    (let ((spaceleft w)
          (abs-number (abs number))
          strlen zsuppress flonum-to-string-width)
      (when (and w (or atsign (minusp number)))
        (decf spaceleft))
      (when (and d w (<= w (+ 1 d (if atsign 1 0))))
        (setq zsuppress t))
      (when (and d (minusp d))
          (format-error "Illegal value for d"))
      (setq flonum-to-string-width
            (and w
                 (if (and (< abs-number 1) (not zsuppress))
                   (1- spaceleft)   ; room for leading 0
                   spaceleft)))
      (when (and w (not (plusp flonum-to-string-width)))
        (if ovf 
          (progn
            (dotimes (i w) (write-char ovf stream))
            (return-from format-fixed-aux))
          (setq spaceleft nil w nil flonum-to-string-width nil)))
      (multiple-value-bind (str before-pt after-pt)
                           (flonum-to-string abs-number
                                             flonum-to-string-width
                                             d k)
        (setq strlen (length str))
        (cond (w (decf spaceleft (+ (max before-pt 0) 1))
                 (when (and (< before-pt 1) (not zsuppress))
                   (decf spaceleft))
                 (if d
                   (decf spaceleft d)
                   (setq d (max (min spaceleft (- after-pt))
                                (if (> spaceleft 0) 1 0))
                         spaceleft (- spaceleft d))))
              ((null d) (setq d (max (- after-pt) 1))))
        (cond ((and w (< spaceleft 0) ovf)
               ;;field width overflow
               (dotimes (i w) (declare (fixnum i)) (write-char ovf stream)))
              (t (when w (dotimes (i spaceleft) (declare (fixnum i)) (write-char pad stream)))
                 (if (minusp (float-sign number)) ; 5/25
                   (write-char #\- stream)
                   (if atsign (write-char #\+ stream)))
                 (cond
                  ((> before-pt 0)
                   (cond ((> strlen before-pt)
                          (write-string str stream :start  0 :end before-pt)
                          (write-char #\. stream)
                          (write-string str stream :start  before-pt :end strlen)
                          (dotimes (i (- d (- strlen before-pt)))
                            (write-char #\0 stream)))
                         (t ; 0's after
                          (stream-write-entire-string stream str)
                          (dotimes (i (-  before-pt strlen))
                            (write-char #\0 stream))
                          (write-char #\. stream)
                          (dotimes (i d)
                            (write-char #\0 stream)))))
                  (t (unless zsuppress (write-char #\0 stream))
                     (write-char #\. stream)
                     (dotimes (i (- before-pt))	 
                       (write-char #\0 stream))
                     (stream-write-entire-string stream str)
                     (dotimes (i (+ d after-pt)) 
                      (write-char #\0 stream))))))))))
#|
; (format t "~7,3,-2f" 8.88)
; (format t "~10,5,2f" 8.88)
; (format t "~10,5,-2f" 8.88)
; (format t "~10,5,2f" 0.0)
; (format t "~10,5,2f" 9.999999999)
; (format t "~7,,,-2e" 8.88) s.b. .009e+3 ??
; (format t "~10,,2f" 8.88)
; (format t "~10,,-2f" 8.88)
; (format t "~10,,2f" 0.0)
; (format t "~10,,2f" 0.123454)
; (format t "~10,,2f" 9.9999999)
 (defun foo (x)
    (format nil "~6,2f|~6,2,1,'*f|~6,2,,'?f|~6f|~,2f|~F"
     x x x x x x))

|#

                  

;;; Exponential-format floating point  ~E


(defformat #\E format-exponential (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms ((w nil) (d nil) (e nil) (k 1) (ovf nil) (pad #\space) (marker nil))
    (let ((number (pop-format-arg)))
      (if (floatp number)
        (format-exp-aux stream number w d e k ovf pad marker atsign)
        (if (rationalp number)
          (format-exp-aux stream (coerce number 'float) w d e k ovf pad marker atsign)
          (let ((*print-base* 10))
            (format-write-field stream (princ-to-string number) w 1 0 #\space t)))))))
#|
(defun format-exponent-marker (number)
  (if (typep number *read-default-float-format*)
      #\E
      (cond ((double-floatp) #\D)
            ((short-floatp number) #\S)
            ((single-floatp number) #\F)
            ((long-floatp) #\L))))
|#
(eval-when (eval compile #-bccl load)
  (defmacro format-exponent-marker (number)
    `(float-exponent-char ,number))
)

;;;Here we prevent the scale factor from shifting all significance out of
;;;a number to the right.  We allow insignificant zeroes to be shifted in
;;;to the left right, athough it is an error to specify k and d such that this
;;;occurs.  Perhaps we should detect both these condtions and flag them as
;;;errors.  As for now, we let the user get away with it, and merely guarantee
;;;that at least one significant digit will appear.
;;; THE ABOVE COMMENT no longer applies

(defun format-exp-aux (stream number w d e k ovf pad marker atsign &optional string exp)
  (when (not k) (setq k 1))
  (if (not (or w d e marker (neq k 1)))
    (print-a-float number stream t)
    (prog () 
      (when d
        (when (or (minusp d)
                  (and (plusp k)(>= k (+ d 2)))
                  (and (minusp k)(< k (- d))))
          (format-error "incompatible values for k and d")))
      (when (not exp) (setq exp (accurate-scale-exponent (abs number))))
      AGAIN
      (let* ((expt (- exp k))
             (estr (let ((*print-base* 10))
                     (princ-to-string (abs expt))))
             (elen (max (length estr) (or e 0)))
             (spaceleft (if w (- w 2 elen) nil))
             (fwidth) scale)
        (when (and w (or atsign (minusp (float-sign number)))) ; 5/25
          (setq spaceleft (1- spaceleft)))
        (if w
          (progn 
          (setq fwidth (if d 
                         (if (> k 0)(+ d 2)(+ d k 1))
                         (if (> k 0) spaceleft (+ spaceleft k))))
          (when (minusp exp) ; i don't claim to understand this
            (setq fwidth (- fwidth exp))
            (when (< k 0) (setq fwidth (1- fwidth)))))          
          (when (and d  (not (zerop number))) ; d and no w
            (setq scale (- 2  k exp))))  ; 2 used to be 1  - 5/31
        (when (or (and w e ovf (> elen e))(and w fwidth (not (plusp fwidth))))
          ;;exponent overflow
          (dotimes (i w) (declare (fixnum i)) (write-char ovf stream))
          (if (plusp fwidth)
            (return-from format-exp-aux nil)
            (setq fwidth nil)))
        (when (not string)
          (multiple-value-bind (new-string before-pt) (flonum-to-string number fwidth 
                                                                        (if (not fwidth) d)
                                                                        (if (not fwidth) scale))
            (setq string new-string)
            (when scale (setq before-pt (- (+ 1 before-pt) k scale))) ; sign right?            
            (when (neq exp before-pt)
              ;(print (list 'agn exp before-pt))
              ;(setq string new-string)
              (setq exp before-pt)
              (go again))))
          (let ((strlen (length string)))
            (when w
              (if d 
                (setq spaceleft (- spaceleft (+ d 2)))
                (if (< k 1)
                  (setq spaceleft (- spaceleft (+ 2 (- k)(max strlen 1))))
                  (setq spaceleft (- spaceleft (+ 1 k (max 1 (- strlen k))))))))
            (when (and w (< spaceleft 0))
              (if (and ovf (or (plusp k)(< spaceleft -1)))            
                (progn (dotimes (i w) (declare (fixnum i)) (write-char ovf stream))
                       (return-from format-exp-aux nil))))
            (when w
              (dotimes (i  spaceleft)
                (declare (fixnum i))
                (write-char pad stream)))
            (if (minusp (float-sign number)) ; 5/25
              (write-char #\- stream)
              (if atsign (write-char #\+ stream)))
            (cond 
             ((< k 1)
              (when (not (minusp spaceleft))(write-char #\0 stream))
              (write-char #\. stream)
              (dotimes (i (- k))
                (write-char #\0 stream))
              (if (and (eq strlen 0)(not d))
                (write-char #\0 stream)
                (stream-write-entire-string stream string))
              (if d
                (dotimes (i (- (+ d k) strlen))
                  (write-char #\0 stream))))
             (t 
              (write-string string stream :start 0 :end (min k strlen))
              (dotimes (i (- k strlen))
                (write-char #\0 stream))                    
              (write-char #\. stream)
              (when (> strlen k)
                (write-string string stream :start k :end strlen))
              (if (not d) 
                (when (<= strlen k)(write-char #\0 stream))
                (dotimes (i (1+ (- d k (max 0 (- strlen k)))))
                  (write-char #\0 stream)))))
            (write-char (if marker
                          marker
                          (format-exponent-marker number))
                        stream)
            (write-char (if (minusp expt) #\- #\+) stream)
            (when e 
              ;;zero-fill before exponent if necessary
              (dotimes (i (- e (length estr)))
                (declare (fixnum i))
                (write-char #\0 stream)))
            (stream-write-entire-string stream estr))))))
#|
; (format t "~7,3,,-2e" 8.88) s.b. .009e+3 
; (format t "~10,5,,2e" 8.888888888) ; "88.8889E-1"
; (format t "~10,5,,-2e" 8.88)   "0.00888E+3"
; (format t "~10,5,,-2e" .00123445) ; "0.00123E+0"
; (format t "~10,5,,-3e" .00123445) ; "0.00012E+1"
; (format t "~10,,,-2e" .123445)
; (format t "~10,5,,2e" .0012349999e-4)
; (format t "~10,5,,2e" 9.9999999)
; (format t "~10,5,,2e" 0.0)
; (format t "~10,5,,0e" 40000000.0)
; (format t "~10,5,,2e" 9.9999999)
; (format t "~7,,,-2e" 8.88) s.b. .009e+3 ??
; (format t "~10,,,2e" 8.888888)
; (format t "~10,,,-2e" 8.88)
; (format t "~10,,,-2e" 0.0)
; (format t "~10,,,2e" 0.0) 
; (format t "~10,,,2e" 9.9999999)
; (format t "~10,,,2e" 9.9999999e100)
; (format t "~10,5,3,2,'xe" 10e100)
; (format t "~9,3,2,-2e" 1100.0)
(defun foo (x)
  (format nil
          "~9,2,1,,'*e|~10,3,2,2,'?,,'$e|~9,3,2,-2,'%@e|~9,2e"
          x x x x))
|#


;;; General Floating Point -  ~G

(defformat #\G format-general-float (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (when colon
    (format-error "Colon flag not allowed"))
  (with-format-parameters parms ((w nil) (d nil) (e nil) (k nil) (ovf nil) (pad #\space) (marker nil))
    (let ((number (pop-format-arg)))
      ;;The Excelsior edition does not say what to do if
      ;;the argument is not a float.  Here, we adopt the
      ;;conventions used by ~F and ~E.
      (if (floatp number)
        (format-general-aux stream number w d e k ovf pad marker atsign)
        (if (rationalp number)
          (format-general-aux stream (coerce number 'float) w d e k ovf pad marker atsign)
          (let ((*print-base* 10))
            (format-write-field stream (princ-to-string number) w 1 0 #\space t)))))))

#|
; completely broken
(defun foo (x)
  (format nil
          "~9,2,1,,'*g|~10,3,2,2,'?,,'$g|~9,3,2,-2,'%@g|~9,2g"
          x x x x))
|#


(defun format-general-aux (stream number w d e k ovf pad marker atsign)
  (multiple-value-bind (str n #|after-pt|#)(flonum-to-string number)
    ;;Default d if omitted.  The procedure is taken directly
    ;;from the definition given in the manual, and is not
    ;;very efficient, since we generate the digits twice.
    ;;Future maintainers are encouraged to improve on this.
    (let* ((d2 (or d (max (length str) (min n 7))))
           (ee (if e (+ e 2) 4))
           (ww (if w (- w ee) nil))
           (dd (- d2 n)))
      (cond ((<= 0 dd d2)
             ; this causes us to print 1.0 as 1. - seems weird
             (format-fixed-aux stream number ww dd nil ovf pad atsign)
             (dotimes (i ee) (declare (fixnum i)) (write-char #\space stream)))
            (t (format-exp-aux stream number w d e (or k 1) ovf pad marker atsign nil n))))))


;;; Dollars floating-point format  ~$

(defformat #\$ format-dollars (stream colon atsign &rest parms)
  (declare (dynamic-extent parms))
  (with-format-parameters parms ((d 2) (n 1) (w 0) (pad #\space))
    (let* ((number (float (pop-format-arg)))
           (signstr (if (minusp (float-sign number)) "-" (if atsign "+" "")))
           (spaceleft)
           strlen)
      (multiple-value-bind (str before-pt after-pt) (flonum-to-string number nil d)
        (setq strlen (length str))
        (setq spaceleft (- w (+ (length signstr) (max before-pt n) 1 d)))
        (when colon (stream-write-entire-string stream signstr))
        (dotimes (i spaceleft) (write-char pad stream))
        (unless colon (stream-write-entire-string stream signstr))
        (cond
         ((> before-pt 0)
          (dotimes (i (- n before-pt))
            (write-char #\0 stream))
          (cond ((> strlen before-pt)
                 (write-string str stream :start 0 :end before-pt)
                 (write-char #\. stream)
                 (write-string str stream :start before-pt :end strlen)
                 (dotimes (i (- d (- strlen before-pt)))
                   (write-char #\0 stream)))
                (t ; 0's after
                 (stream-write-entire-string stream str)
                 (dotimes (i (-  before-pt strlen))
                   (write-char #\0 stream))
                 (write-char #\. stream)
                 (dotimes (i d)
                   (write-char #\0 stream)))))
         (t (dotimes (i n)
              (write-char #\0 stream))
            (write-char #\. stream)
            (dotimes (i (- before-pt))
              (write-char #\0 stream))
            (stream-write-entire-string stream str)
            (dotimes (i (+ d after-pt))
              (write-char #\0 stream))))))))

(defun y-or-n-p (&optional format-string &rest arguments &aux response)
  "Y-OR-N-P prints the message, if any, and reads characters from
   *QUERY-IO* until the user enters y or Y as an affirmative, or either
   n or N as a negative answer. It asks again if you enter any other
   characters."
  (declare (dynamic-extent arguments))
  (with-terminal-input
      (clear-input *query-io*)
      (loop
        (when format-string
          (fresh-line *query-io*)
          (apply 'format *query-io* format-string arguments))
        (princ " (y or n)  " *query-io*)
	(setq response (read-char *query-io*))
        ;; Consume input up to trailing newline
        (when (peek-char #\NewLine *query-io* nil)
          ;; And consume the #\newline
          (read-char *query-io*))
        (clear-input *query-io*)
	(if (char-equal response #\y) (return t))
	(if (char-equal response #\n) (return nil))
	(format *query-io* "Please answer y or n."))))

(defun yes-or-no-p (&optional format-string &rest arguments &aux response)
  "YES-OR-NO-P is similar to Y-OR-N-P, except that it clears the
   input buffer, beeps, and uses READ-LINE to get the strings
   YES or NO."
  (declare (dynamic-extent arguments))
  (with-terminal-input
      (loop
        (when format-string
          (fresh-line *query-io*)
          (apply 'format *query-io* format-string arguments))
        (princ " (yes or no)  " *query-io*)
        (format *query-io* "~A" #\Bell)
        (setq response (read-line *query-io*))
        (clear-input *query-io*)
	(when response
	  (setq response (string-trim wsp response))
	  (if (string-equal response "yes") (return t))
	  (if (string-equal response "no") (return nil))
          (format *query-io* "Please answer yes or no.")))))


;; Compile-time format-scanning support.
;;
;; All this assumes it's called from the compiler, but it has to be kept in sync with code
;; here more than with the code in the compiler, so keep it in here.

(defun note-format-scan-option (cell)
  (when cell
    (if (null (cdr cell))
      (setf (car cell) *format-arguments* (cdr cell) *format-arguments-variance*)
      (let* ((new-args *format-arguments*)
             (new-var *format-arguments-variance*)
             (new-max (length new-args))
             (old-args (car cell))
             (old-var (cdr cell))
             (old-max (length old-args))
             (min (min (- new-max new-var) (- old-max old-var))))
        (if (>= new-max old-max)
          (setf (car cell) new-args (cdr cell) (- new-max min))
          (setf (cdr cell) (- old-max min))))))
  cell)

(defmacro with-format-scan-options ((var) &body body)
  (let ((cell (gensym)))
    ;; CELL is used to record range of arg variations that should be deferred til the end
    ;; of BODY because they represent possible non-local exits.
    `(let* ((,cell (cons nil nil))
            (,var ,cell))
       (declare (dynamic-extent ,cell))
       (prog1
           (progn
             ,@body)
         (setq *format-arguments* (car ,cell)
               *format-arguments-variance* (cdr ,cell))))))

(defvar *format-escape-options* nil)

(defun nx1-check-format-call (control-string format-arguments &optional (env *nx-lexical-environment*))
  "Format-arguments are expressions that will evaluate to the actual arguments.
  Pre-scan process the format string, nx1-whine if find errors"
  (let* ((*nx-lexical-environment* env)
         (*format-top-level* t)
         (*logical-block-xp* nil)
         (*format-pprint* nil)
         (*format-justification-semi* nil))
    (let ((error (catch 'format-error
		   (format-scan control-string format-arguments 0)
                   nil)))
      (when error
	(setf (cadar error) (concatenate 'string (cadar error) " in format string:"))
	(nx1-whine :format-error (nreverse error))
	t))))

(defun format-scan (string args var)
  (let ((*format-original-arguments* args)
	(*format-arguments* args)
	(*format-arguments-variance* var)
	(*format-colon-rest* 'error)
	(*format-control-string* (ensure-simple-string string)))
    (with-format-scan-options (*format-escape-options*)
      (catch 'format-escape
	(sub-format-scan 0 (length *format-control-string*))
	(note-format-scan-option *format-escape-options*)))
    (when (> (length *format-arguments*) *format-arguments-variance*)
      (format-error "Too many format arguments"))))

(defun sub-format-scan (i end)
  (let ((*format-index* i)
        (*format-length* end)
        (string *format-control-string*))
    (loop while (setq *format-index* (position #\~ string :start *format-index* :end end)) do
      (multiple-value-bind (params colon atsign char) (parse-format-operation t)
	(setq char (char-upcase char))
	(let ((code (%char-code char)))
	  (unless (and (< -1 code (length *format-char-table*))
		       (svref *format-char-table* code))
	    (format-error "Unknown directive ~c" char)))
        (format-scan-directive char colon atsign params)
        (incf *format-index*)))))

(defun nx-could-be-type (form type &optional transformed &aux (env *nx-lexical-environment*))
  (unless transformed (setq form (nx-transform form env)))
  (if (nx-form-constant-p form env)
    (typep (nx-form-constant-value form env) type env)
    (not (types-disjoint-p (nx-form-type form env) type env))))

(defun format-require-type (form type &optional description)
  (unless (nx-could-be-type form type)
    (format-error "~a must be of type ~s" (or description form) type)))


(defun format-scan-directive (char colon atsign parms)
  (ecase char
    ((#\% #\& #\~ #\|)
     (with-format-parameters parms ((repeat-count 1))
       (format-no-flags colon atsign)
       (format-require-type repeat-count '(integer 0))))
    ((#\newline #\return)
     (with-format-parameters parms ()
       (when (and atsign colon) (format-error "~:@<newline> is undefined"))
       (unless colon
	 (format-eat-whitespace))))
    ((#\P)
     (with-format-parameters parms ()
       (when colon
	 (loop with end = *format-arguments*
	    for list on *format-original-arguments*
	    when (eq (cdr list) end) return (setq *format-arguments* list)
	    finally (if (> (or *format-arguments-variance* 0) 0)
			(decf *format-arguments-variance*)
			(format-error "No previous argument"))))
       (pop-format-arg)))
    ((#\A #\S)
     (with-format-parameters parms ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
       (format-require-type mincol 'integer "mincol (first parameter)")
       (format-require-type colinc '(integer 1) "colinc (second parameter)")
       (format-require-type minpad 'integer "minpad (third parameter)")
       (format-require-type padchar '(or (integer 0 #.char-code-limit) character) "padchar (fourth parameter)"))
     (pop-format-arg))
    ((#\I)
     (with-format-parameters parms ((n 0))
       (format-no-flags nil atsign)
       (format-no-semi char)
       (format-require-type n 'real)))
    ((#\_)
     (with-format-parameters parms ()
       (format-no-semi char)))
    ((#\T)
     (with-format-parameters parms ((colnum 1) (colinc 1))
       (when colon
	 (format-no-semi char t))
       (format-require-type colnum 'integer "colnum (first parameter)")
       (format-require-type colinc 'integer "colinc (second parameter)")))
    ((#\W)
     (with-format-parameters parms ()
       (format-no-semi #\W))
     (pop-format-arg))
    ((#\C)
     (with-format-parameters parms ())
     (format-require-type (pop-format-arg) '(or character fixnum (string 1))))
    ((#\D #\B #\O #\X #\R)
     (when (eql char #\R)
       (let ((radix (pop parms)))
	 (when radix
	   (format-require-type radix '(integer 2 36)))))
     (with-format-parameters parms ((mincol 0) (padchar #\space) (commachar #\,) (commainterval 3))
       (format-require-type mincol 'integer "mincol (first parameter)")
       (format-require-type padchar 'character "padchar (second parameter)")
       (format-require-type commachar 'character "comma char (third parameter)")
       (format-require-type commainterval 'integer "comma interval (fourth parameter)"))
     (pop-format-arg))
    ((#\F)
     (format-no-flags colon nil)
     (with-format-parameters parms ((w nil) (d nil) (k nil) (ovf nil) (pad #\space))
       (format-require-type w '(or null (integer 0)) "w (first parameter)")
       (format-require-type d '(or null (integer 0)) "d (second parameter)")
       (format-require-type k '(or null integer) "k (third parameter)")
       (format-require-type ovf '(or null character) "overflowchar (fourth parameter)")
       (format-require-type pad '(or null character) "padchar (fifth parameter)"))
     (pop-format-arg))
    ((#\E #\G)
     (format-no-flags colon nil)
     (with-format-parameters parms ((w nil) (d nil) (e nil) (k 1) (ovf nil) (pad #\space) (marker nil))
       (format-require-type w '(or null (integer 0)) "w (first parameter)")
       (format-require-type d '(or null (integer 0)) "d (second parameter)")
       (format-require-type e '(or null (integer 0)) "e (third parameter)")
       (format-require-type k '(or null integer) "k (fourth parameter)")
       (format-require-type ovf '(or null character) "overflowchar (fifth parameter)")
       (format-require-type pad '(or null character) "padchar (sixth parameter)")
       (format-require-type marker '(or null character) "exponentchar (seventh parameter)"))
     (pop-format-arg))
    ((#\$)
     (with-format-parameters parms ((d 2) (n 1) (w 0) (pad #\space))
       (format-require-type d '(or null (integer 0)) "d (first parameter)")
       (format-require-type n '(or null (integer 0)) "n (second parameter)")
       (format-require-type w '(or null (integer 0)) "w (third parameter)")
       (format-require-type pad '(or null character) "pad (fourth parameter)"))
     (format-require-type (pop-format-arg) 'real))
    ((#\*)
     (with-format-parameters parms ((count nil))
       (when count
	 (format-require-type count 'integer "count parameter"))
       (if (typep (setq count (nx-transform count)) '(or null integer))
	 (format-scan-goto colon atsign count)
	 ;; Else can't tell how much going back or forth, could be anywhere.
	 (setq *format-arguments* *format-original-arguments*
	       *format-arguments-variance* (length *format-arguments*)))))
    ((#\?)
     (with-format-parameters parms ()
       (format-no-flags colon nil))
     (let ((string (pop-format-arg)))
       (format-require-type string '(or string function))
       (if atsign
	 (setq *format-arguments-variance* (length *format-arguments*))
	 (let ((arg (pop-format-arg)))
	   (format-require-type arg 'list)))))
    ((#\/)
     (let* ((string *format-control-string*)
	    (ipos (1+ *format-index*))
	    (epos (format-find-char #\/ ipos *format-length*)))
       (when (not epos) (format-error "Unmatched ~~/"))
       (let* ((cpos (format-find-char #\: ipos epos))
	      (name (if cpos
		      (prog1
			  (string-upcase (%substr string ipos cpos))
			(when (eql #\: (schar string (%i+ 1 cpos)))
			  (setq cpos (%i+ cpos 1)))
			(setq ipos (%i+ cpos 1)))
		      "CL-USER"))
	      (package (find-package name))
	      (sym (and package (find-symbol (string-upcase (%substr string ipos epos)) package)))
	      (arg (pop-format-arg)))
	 (setq *format-index* epos) ; or 1+ epos?
	 ;; TODO: should we complain if the symbol doesn't exit?  Perhaps it will be defined
	 ;; later, and to detect that would need to intern it.  What if the package doesn't exist?
	 ;; Would need to extend :undefined-function warnings to handle previously-undefined package.
	 (when sym
	   (when (nx1-check-typed-call sym (list* '*standard-output* arg colon atsign parms))
	     ;; Whined, just get out now.
	     (throw 'format-error nil))))))
    ((#\[)
     (when (and colon atsign) (format-error  "~~:@[ undefined"))
     (format-nextchar)
     (cond (colon
	    (format-scan-boolean-condition parms))
	   (atsign
	    (format-scan-funny-condition parms))
	   (t (format-scan-untagged-condition parms))))
    ((#\()
     (with-format-parameters parms ()
       (format-nextchar)
       (multiple-value-bind (prev tilde parms colon atsign) (format-find-command '(#\)))
	 (with-format-parameters parms () (format-no-flags colon atsign))
	 (sub-format-scan prev tilde))))
    ((#\^)
     (format-no-flags nil atsign)
     (with-format-parameters parms ((p1 nil) (p2 nil) (p3 nil))
       (let ((val (nx-transform (cond (p3
				       (if (every (lambda (p) (nx-could-be-type p 'real)) parms)
					 ;; If the params could also be chars, don't know enough to constant fold
					 ;; anyway, so this test will do.
					 `(< ,p1 ,p2 ,p3)
					 (if (every (lambda (p) (nx-could-be-type p 'character)) parms)
					   `(char< ,p1 ,p2 ,p3)
					   ;; At least one can't be real, at least one can't be char.
					   (format-error "Wrong type of parameters for three-way comparison"))))
				      (p2 `(equal ,p1 ,p2))
				      (p1 `(eq ,p1 0))
				      (t (null (if colon *format-colon-rest* *format-arguments*)))))))
	 (when val
	   (note-format-scan-option *format-escape-options*)
	   (unless (nx-could-be-type val 'null t)
	     (throw 'format-escape t))))))
    ((#\{)
     (with-format-parameters parms ((max-iter -1))
       (format-require-type max-iter 'integer "max-iter parameter")
       (format-nextchar)
       (multiple-value-bind (prev tilde end-parms end-colon end-atsign) (format-find-command '(#\}))
	 (declare (ignore end-colon))
	 (with-format-parameters end-parms () (format-no-flags nil end-atsign))
	 (when (= prev tilde)
	   ;; Use an argument as the control string if ~{~} is empty
	   (let ((string (pop-format-arg)))
	     (unless (nx-could-be-type string '(or string function))
	       (format-error "Control string is not a string or function"))))
	 ;; Could try to actually scan the iteration if string is a compile-time string,
	 ;; by that seems unlikely.
	 (if atsign
	   (setq *format-arguments-variance* (length *format-arguments*))
	   (format-require-type (pop-format-arg) 'list)))))
    ((#\<)
     (multiple-value-bind (start tilde eparms ecolon eatsign) (format-find-command '(#\>))
       (declare (ignore tilde eparms eatsign))
       (setq *format-index* start)
       (if ecolon
	 (format-logical-block-scan colon atsign parms)
	 (format-justification-scan colon atsign parms))))
    ))

(defun format-justification-scan (colon atsign parms)
  (declare (ignore colon atsign))
  (with-format-parameters parms ((mincol 0) (colinc 1) (minpad 0) (padchar #\space))
    (format-require-type mincol 'integer "mincol (first parameter)")
    (format-require-type colinc '(integer 1) "colinc (second parameter)")
    (format-require-type minpad 'integer "minpad (third parameter)")
    (format-require-type padchar `(or character (integer 0 #.char-code-limit)) "padchar (fourth parameter)"))
  (let ((first-parms nil) (first-colon nil) (count 0))
    (with-format-scan-options (*format-escape-options*)
      (loop
	 (format-nextchar)
	 (multiple-value-bind (prev tilde parms colon atsign cmd)
	     (format-find-command '(#\; #\>) nil T)
	   (if (and (eql count 0) (eql cmd #\;) colon)
	     (progn
	       (format-no-flags nil atsign)
	       (setq first-colon t)
	       (setq *format-index* tilde)
	       (setq first-parms (nth-value 2 (format-find-command '(#\; #\>) t T))))
	     (with-format-parameters parms ()
	       (format-no-flags colon atsign)))
	   (when (catch 'format-escape
		   (sub-format-scan prev tilde)
		   nil)
	     (unless (eq cmd #\>) (format-find-command '(#\>) nil t))
	     (return))
	   (incf count)
	   (when (eq cmd #\>)
	     (return))))
      (note-format-scan-option *format-escape-options*))
    (when first-colon
      (when *format-pprint*
	(format-error "Justification illegal in this context"))
      (setq *format-justification-semi* t)
      (with-format-parameters first-parms ((spare 0) (linel 0))
	(format-require-type spare 'integer "spare (first parameter)")
	(format-require-type linel 'integer "line length (second parameter)")))))
      


(defun format-logical-block-scan (colon atsign params)
  (declare (ignore colon))
  (with-format-parameters params ()
    (format-no-semi #\<))
    ;; First section can be termined by ~@;
  (let ((format-string *format-control-string*)
	(prefix "")
	(suffix "")
	(body-string nil))
    (multiple-value-bind (start1 tilde parms1 colon1 atsign1 cmd) (format-find-command  '(#\; #\>))
      (setq body-string (%substr format-string (1+ start1) tilde))
      (with-format-parameters parms1 ())
      (when (eq cmd #\;)
	(format-no-flags colon1 nil)
	(setq prefix body-string)
	(multiple-value-setq (start1 tilde parms1 colon1 atsign1 cmd) (format-find-command '(#\; #\>)))
	(with-format-parameters parms1 ())
	(setq body-string (%substr format-string (1+ start1) tilde))
	(when (eq cmd #\;)
	  (format-no-flags colon1 atsign1)
	  (multiple-value-setq (start1 tilde parms1 colon1 atsign1 cmd) (format-find-command  '(#\; #\>)))
	  (with-format-parameters parms1 ())
	  (setq suffix (%substr format-string (1+ start1) tilde))
	  (when (eq cmd #\;)
	    (format-error "Too many sections")))))
    (flet ((format-check-simple (str where)
	     (when (and str (or (%str-member #\~ str) (%str-member #\newline str)))
	       (format-error "~A must be simple" where))))
      (format-check-simple prefix "Prefix")
      (format-check-simple suffix "Suffix"))
    (if atsign
      (let ((*logical-block-p* t))
	(format-scan body-string *format-arguments* *format-arguments-variance*)
	(setq *format-arguments* nil *format-arguments-variance* 0))
      ;; If no atsign, we just use up an arg.  Don't bother trying to scan it, unlikely to be a constant.
      (when *format-arguments*
	(pop-format-arg)))))


(defun format-scan-untagged-condition (parms)
  (with-format-parameters parms ((index nil))
    (unless index (setq index (pop-format-arg)))
    (format-require-type index 'integer)
    (with-format-scan-options (cond-options)
      (loop with default = nil do
	   (multiple-value-bind (prev tilde parms colon atsign cmd)
	       (format-find-command '(#\; #\]))
	     (when (and default (eq cmd #\;))
	       (format-error "~:; must be the last clause"))
	     (with-format-parameters parms ()
	       (format-no-flags (if (eq cmd #\]) colon) atsign)
	       (when colon (setq default t)))
	     (format-scan-optional-clause prev tilde cond-options)
	     (when (eq cmd #\])
	       (unless default 	  ;; Could just skip the whole thing
		 (note-format-scan-option cond-options))
	       (return))
	     (format-nextchar))))))

(defun format-scan-funny-condition (parms)
  (with-format-parameters parms ())
  (multiple-value-bind (prev tilde parms colon atsign) (format-find-command '(#\]))
    (with-format-parameters parms ()
      (format-no-flags colon atsign))
    (when (null *format-arguments*) (pop-format-arg)) ;; invoke std error
    (with-format-scan-options (cond-options)
      (let ((arg (nx-transform (car *format-arguments*))))
	(when (nx-could-be-type arg 'null t)
	  (let ((*format-arguments* *format-arguments*)
		(*format-arguments-variance* *format-arguments-variance*))
	    (when (eql *format-arguments-variance* (length *format-arguments*))
	      (decf *format-arguments-variance*))
	    (pop *format-arguments*)
	    (note-format-scan-option cond-options)))
	(when arg
	  (format-scan-optional-clause prev tilde cond-options))))))


(defun format-scan-boolean-condition (parms)
  (with-format-parameters parms ())
  (multiple-value-bind (prev tilde parms colon atsign cmd) (format-find-command '(#\; #\]))
    (when (eq cmd #\])
      (format-error "Two clauses separated by ~~; are required for ~~:["))
    (with-format-parameters parms () (format-no-flags colon atsign))
    (format-nextchar)
    (with-format-scan-options (cond-options)
      (let ((arg (nx-transform (pop-format-arg))))
	(when (nx-could-be-type arg 'null t)
	  (format-scan-optional-clause prev tilde cond-options))
	(multiple-value-bind (prev tilde parms colon atsign) (format-find-command '(#\]))
	  (with-format-parameters parms () (format-no-flags colon atsign))
	  (when arg
	    (format-scan-optional-clause prev tilde cond-options)))))))


(defun format-scan-optional-clause (start end cond-option)
  (let ((*format-arguments* *format-arguments*)
	(*format-arguments-variance* *format-arguments-variance*))
    ;; Let the branch points collect in outer *format-escape-options*, but don't
    ;; throw there because need to consider the other clauses.
    (catch 'format-escape
      (sub-format-scan start end)
      (note-format-scan-option cond-option)
      nil)))

(defun format-scan-goto (colon atsign count)
  (if atsign 
    (let* ((orig *format-original-arguments*)
           (orig-pos (- (length orig) (length *format-arguments*)))
           (new-pos (or count 0)))
      (format-no-flags colon nil)
      ;; After backing up, we may not use up all the arguments we backed over,
      ;; so even though real variance here is 0, increase variance so we don't
      ;; complain.
      (setq *format-arguments-variance* (max 0 (- orig-pos new-pos)))
      (setq *format-arguments* (nthcdr-no-overflow new-pos orig)))
    (progn
      (when (null count)(setq count 1))
      (when colon (setq count (- count)))
      (cond ((> count 0)
	     (when (> count (length *format-arguments*))
	       (format-error "Target position for ~~* out of bounds"))
	     (setq *format-arguments* (nthcdr count *format-arguments*))
	     (when *format-arguments-variance*
	       (setq *format-arguments-variance*
		     (min *format-arguments-variance* (length *format-arguments*)))))
	    ((< count 0)
	     (let* ((orig *format-original-arguments*)
		    (orig-pos (- (length orig) (length *format-arguments*)))
		    (pos (+ orig-pos count))
		    (max-pos (+ pos (or *format-arguments-variance* 0))))
	       (when (< max-pos 0)
		 (format-error "Target position for ~~* out of bounds"))
	       ;; After backing up, we may not use up all the arguments we backed over.
	       ;; Increase the variance allowed to cover those arguments, so we don't
	       ;; complain about not using them.  E.g. (format t "~a ~a ~2:*~a" 1 2) should
	       ;; be ok, (format t "~a ~a ~2:*" 1 2) should warn.
	       (setq max-pos (1- (- max-pos count)))
	       (if (< pos 0)
		 (setq *format-arguments* orig
		       *format-arguments-variance* max-pos)
		 (setq *format-arguments* (nthcdr pos orig)
		       *format-arguments-variance* (- max-pos pos)))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/hash.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;  This is just the stuff (make-load-form, print-object) that can't be fasloaded earlier.


;;;;;;;;;;;;;
;;
;; hash.lisp
;; New hash table implementation

;;;;;;;;;;;;;
;;
;; Things I didn't do
;;
;; Save the 32-bit hash code along with the key so that growing the table can
;; avoid calling the hashing function (at least until a GC happens during growing).
;;
;; Maybe use Knuth's better method for hashing:
;; find two primes N-2, N.  N is the table size.
;; First probe is at primary = (mod (funcall (nhash.keytransF h) key) N)
;; Secondary probes are spaced by (mod (funcall (nhash.keytransF h) key) N-2)
;; This does a bit better scrambling of the secondary probes, but costs another divide.
;;
;; Rethink how finalization is reported to the user.  Maybe have a finalization function which
;; is called with the hash table and the deleted key & value.


;;;;;;;;;;;;;
;;
;; Documentation
;;
;; MAKE-HASH-TABLE is extended to accept a :HASH-FUNCTION keyword arg which
;; defaults for the 4 Common Lisp defined :TEST's.  Also, any fbound symbol can
;; be used for the :TEST argument.  The HASH-FUNCTION is a function of one
;; argument, the key, which returns one or two values:
;;
;; 1) HASH-CODE
;; 2) ADDRESSP
;;
;; The HASH-CODE can be any object.  If it is a relocateable object (not a
;; fixnum, short float, or immediate) then ADDRESSP will default to :KEY
;; and it is an error if NIL is returned for ADDRESSP.
;;
;; If ADDRESSP is NIL, the hashing code assumes that no addresses were used
;; in computing the HASH-CODE.  If ADDRESSP is :KEY (which is the default
;; if the hash function returns only one value and it is relocateable) then
;; the hashing code assumes that only the KEY's address was used to compute
;; the HASH-CODE.  Otherwise, it is assumed that the address of a
;; component of the key was used to compute the HASH-CODE.
;;
;;
;;
;; Some (proposed) functions for using in user hashing functions:
;;
;; (HASH-CODE object)
;;
;; returns two values:
;;
;; 1) HASH-CODE
;; 2) ADDRESSP
;;
;; HASH-CODE is the object transformed into a fixnum by changing its tag
;; bits to a fixnum's tag.  ADDRESSP is true if the object was
;; relocateable. ;;
;;
;; (FIXNUM-ADD o1 o2)
;; Combines two objects additively and returns a fixnum.
;; If the two objects are fixnums, will be the same as (+ o1 o2) except
;; that the result can not be a bignum.
;;
;; (FIXNUM-MULTIPLY o1 o2)
;; Combines two objects multiplicatively and returns a fixnum.
;;
;; (FIXNUM-FLOOR dividend &optional divisor)
;; Same as Common Lisp's FLOOR function, but converts the objects into
;; fixnums before doing the divide and returns two fixnums: quotient &
;; remainder.
;;
;;;;;;;;;;;;;
;;
;; Implementation details.
;;
;; Hash table vectors have a header that the garbage collector knows
;; about followed by alternating keys and values.  Empty slots have a
;; key of (%UNBOUND-MARKER), deleted slots are denoted by a key of
;; (%SLOT-UNBOUND-MARKER), except in the case of "lock-free" hash
;; tables, which see below.
;;
;; Four bits in the nhash.vector.flags fixnum interact with the garbage
;; collector.  This description uses the symbols that represent bit numbers
;; in a fixnum.  $nhash_xxx_bit has a corresponding $nhash_lap_xxx_bit which
;; gives the byte offset of the bit for LAP code.  The two bytes in
;; question are at offsets $nhash.vector-weak-byte and
;; $nhash.vector-track-keys-byte offsets from the tagged vector.
;; The raw 32 bits of the fixnum at nhash.vector.flags look like:
;;
;;     TKEC0000 00000000 WVFZ0000 00000000
;;
;;
;; $nhash_track_keys_bit         "T" in the diagram above
;;                               Sign bit of the longword at $nhash.vector.flags
;;                               or the byte at $nhash.vector-track-keys-byte.
;;                               If set, GC tracks relocation of keys in the
;;                               vector.
;; $nhash_key_moved_bit          "K" in the diagram above
;;                               Set by GC to indicate that a key moved.
;;                               If $nhash_track_keys_bit is clear, this bit is set to
;;                               indicate that any GC will require a rehash.
;;                               GC never clears this bit, but may set it if
;;                               $nhash_track_keys_bit is set.
;; $nhash_component_address_bit  "C" in the diagram above.
;;                               Ignored by GC.  Set to indicate that the
;;                               address of a component of a key was used. 
;;                               Means that $nhash_track_keys_bit will
;;                               never be set until all such keys are
;;                               removed.
;; $nhash_weak_bit               "W" in the diagram above
;;                               Sign bit of the byte at $nhash.vector-weak-byte
;;                               Set to indicate a weak hash table
;; $nhash_weak_value_bit         "V" in the diagram above
;;                               If clear, the table is weak on key
;;                               If set, the table is weak on value
;; $nhash_finalizeable_bit       "F" in the diagram above
;;                               If set the table is finalizeable:
;;                               If any key/value pairs are removed, they will be added to
;;                               the nhash.vector.finalization-alist using cons cells
;;                               from nhash.vector.free-alist
;; $nhash_keys_frozen_bit       "Z" in diagram above.
;;                               If set, GC will remove weak entries by setting the
;;                               value to (%slot-unbound-marker), leaving key unchanged.

(in-package "CCL")


(eval-when (:compile-toplevel :execute)
  (require "HASHENV" "ccl:xdump;hashenv")
  (require "LISPEQU"))

(defvar *hash-table-class*
  (progn
;    #+sparc-target (dbg)
    (find-class 'hash-table)))

(setf (type-predicate 'hash-table) 'hash-table-p)


(defmethod print-object ((table hash-table) stream)
  (print-unreadable-object (table stream :type t :identity t)
    (format stream "~S ~S size ~D/~D"
            ':test (hash-table-test table)
            (hash-table-count table)
            (hash-table-size table))
    (when (readonly-hash-table-p table)
      (format stream " (Readonly)"))))


#+vaporware
;;; Of course, the lisp version of this would be too slow ...
(defun hash-table-finalization-list (hash-table)
  (unless (hash-table-p hash-table)
    (report-bad-arg hash-table 'hash-table))
  (let* ((vector (nhash.vector hash-table))
         (flags (nhash.vector.flags vector)))
    (declare (fixnum flags))
    (if (logbitp $nhash_finalizeable_bit flags)
      (nhash.vector.finalization-alist vector)
      (error "~S is not a finalizeable hash table" hash-table))))

#+vaporware
(defun (setf hash-table-finalization-list) (value hash-table)
  (unless (hash-table-p hash-table)
    (report-bad-arg hash-table 'hash-table))
  (let* ((vector (nhash.vector hash-table))
         (flags (nhash.vector.flags vector)))
    (declare (fixnum flags))
    (if (logbitp $nhash_finalizeable_bit flags)
      (setf (nhash.vector.finalization-alist vector) value)
      (error "~S is not a finalizeable hash table" hash-table))))

(defsetf gethash puthash)

; Returns nil, :key or :value
(defun hash-table-weak-p (hash)
  (unless (hash-table-p hash)
    (setq hash (require-type hash 'hash-table)))
  (let* ((vector (nhash.vector hash))
         (flags (nhash.vector.flags vector)))
    (when (logbitp $nhash_weak_bit flags)
      (if (logbitp $nhash_weak_value_bit flags)
        :value
        :key))))

;;; It would be pretty complicated to offer a way of doing (SETF
;;; HASH-TABLE-WEAK-P) after the hash-table's been created, and
;;; it's not clear that that'd be incredibly useful.



;;;;;;;;;;;;;
;;
;; Mapping functions
;;



(defun next-hash-table-iteration-1 (state)
  (do* ((index (nhti.index state) (1+ index))
        (keys (nhti.keys state))
        (values (nhti.values state))
        (nkeys (nhti.nkeys state)))
       ((>= index nkeys)
        (setf (nhti.index state) nkeys)
        nil)
    (declare (fixnum index nkeys)
             (simple-vector keys))
    (let* ((key (svref keys index))
           (value (svref values index)))
        (setf (nhti.index state) (1+ index))
        (return (values t key value)))))



(defun maphash (function hash-table)
  "For each entry in HASH-TABLE, call the designated two-argument function
   on the key and value of the entry. Return NIL."
  (with-hash-table-iterator (m hash-table)
    (loop
      (multiple-value-bind (found key value) (m)
        (unless found (return))
        (funcall function key value)))))


(defmethod make-load-form ((hash hash-table) &optional env)
  (declare (ignore env))
  (let ((keytransF (nhash.keytransF hash))
        (compareF (nhash.compareF hash))
        (vector (nhash.vector hash))
        (private (if (nhash.owner hash) '*current-process*))
        (lock-free-p (hash-lock-free-p hash)))

    (flet ((convert (f)
             (if (or (fixnump f) (symbolp f))
               `',f
               `(symbol-function ',(function-name f)))))
      (values
       `(%cons-hash-table
         nil nil nil ,(nhash.grow-threshold hash) ,(nhash.rehash-ratio hash) ,(nhash.rehash-size hash)
        nil nil ,private ,lock-free-p ,(nhash.min-size hash))
       `(%initialize-hash-table ,hash ,(convert keytransF) ,(convert compareF) ',vector)))))

(defun needs-rehashing (hash)
  (%set-needs-rehashing hash))

(defun %initialize-hash-table (hash keytransF compareF vector)
  (setf (nhash.keytransF hash) keytransF
        (nhash.compareF hash) compareF)
  (setf (nhash.find hash)
        (case comparef
          (0 #'eq-hash-find)
          (-1 #'eql-hash-find)
          (t #'general-hash-find))
        (nhash.find-new hash)
        (case comparef
          (0 #'eq-hash-find-for-put)
          (-1 #'eql-hash-find-for-put)
          (t #'general-hash-find-for-put)))
  (setf (nhash.vector hash) vector)
  (%set-needs-rehashing hash))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Support for locking hash tables while fasdumping
;;


(defun fasl-lock-hash-table (hash-table)
  (setq hash-table (require-type hash-table 'hash-table))
  (without-interrupts
   (let* ((lock (nhash.exclusion-lock hash-table)))
     (if lock
       (progn
         (if (hash-lock-free-p hash-table)
           ;; For lock-free hash tables, this only makes sure nobody is
           ;; rehashing the table.  It doesn't necessarily stop readers
           ;; or writers (unless they need to rehash).
           (grab-lock lock)
           (write-lock-rwlock lock))
         (push hash-table *fcomp-locked-hash-tables*))
       (unless (eq (nhash.owner hash-table) *current-process*)
         (error "Current process doesn't own hash-table ~s" hash-table))))))

(defun fasl-unlock-hash-tables ()
  (dolist (h *fcomp-locked-hash-tables*)
    (let* ((lock (nhash.exclusion-lock h)))
      (if (hash-lock-free-p h)
        (release-lock lock)
        (unlock-rwlock lock)))))

; end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/hash.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/lists.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (eval compile)
  (require 'backquote)
  (require 'level-2))

(defun caaaar (list) (car (caaar list)))
(defun caaadr (list) (car (caadr list)))
(defun caadar (list) (car (cadar list)))
(defun caaddr (list) (car (caddr list)))
(defun cadaar (list) (car (cdaar list)))
(defun cadadr (list) (car (cdadr list)))
(defun caddar (list) (car (cddar list)))
(defun cadddr (list) (car (cdddr list)))
(defun cdaaar (list) (cdr (caaar list)))
(defun cdaadr (list) (cdr (caadr list)))
(defun cdadar (list) (cdr (cadar list)))
(defun cdaddr (list) (cdr (caddr list)))
(defun cddaar (list) (cdr (cdaar list)))
(defun cddadr (list) (cdr (cdadr list)))
(defun cdddar (list) (cdr (cddar list)))
(defun cddddr (list) (cdr (cdddr list)))

(defun tree-equal (x y &key (test (function eql)) test-not)
  "Returns T if X and Y are isomorphic trees with identical leaves."
  (if test-not
      (tree-equal-test-not x y test-not)
      (tree-equal-test x y test)))

(defun tree-equal-test-not (x y test-not)
  (cond ((and (atom x) (atom y))
         (if (and (not x) (not y)) ;must special case end of both lists.
           t
           (if (not (funcall test-not x y)) t)))
	((consp x)
	 (and (consp y)
	      (tree-equal-test-not (car x) (car y) test-not)
	      (tree-equal-test-not (cdr x) (cdr y) test-not)))
	(t ())))

(defun tree-equal-test (x y test)
  (if (atom x)
    (if (atom y)
      (if (funcall test x y) t))
    (and (consp y)
         (tree-equal-test (car x) (car y) test)
         (tree-equal-test (cdr x) (cdr y) test))))

(defun first (list)
  "Return the 1st object in a list or NIL if the list is empty."
  (car list))

(defun second (list)
  "Return the 2nd object in a list or NIL if there is no 2nd object."
  (cadr list))

(defun third (list)
  "Return the 3rd object in a list or NIL if there is no 3rd object."
  (caddr list))

(defun fourth (list)
  "Return the 4th object in a list or NIL if there is no 4th object."
  (cadddr list))

(defun fifth (list)
  "Return the 5th object in a list or NIL if there is no 5th object."
  (car (cddddr list)))

(defun sixth (list)
  "Return the 6th object in a list or NIL if there is no 6th object."
  (cadr (cddddr list)))

(defun seventh (list)
  "Return the 7th object in a list or NIL if there is no 7th object."
  (caddr (cddddr list)))

(defun eighth (list)
  "Return the 8th object in a list or NIL if there is no 8th object."
  (cadddr (cddddr list)))

(defun ninth (list)
  "Return the 9th object in a list or NIL if there is no 9th object."
  (car (cddddr (cddddr list))))

(defun tenth (list)
  "Return the 10th object in a list or NIL if there is no 10th object."
  (cadr (cddddr (cddddr list))))

(defun rest (list)
  "Means the same as the cdr of a list."
  (cdr list))
;;; List* is done the same as list, except that the last cons is made a
;;; dotted pair


;;; List Copying Functions

;;; The list is copied correctly even if the list is not terminated by ()
;;; The new list is built by cdr'ing splice which is always at the tail
;;; of the new list


(defun copy-alist (alist)
  "Return a new association list which is EQUAL to ALIST."
  (unless (endp alist)
    (let ((result
           (cons (if (endp (car alist))
                   (car alist)
                   (cons (caar alist) (cdar alist)) )
                 '() )))	      
      (do ((x (cdr alist) (cdr x))
           (splice result
                   (cdr (rplacd splice
                                (cons
                                 (if (endp (car x)) 
                                   (car x)
                                   (cons (caar x) (cdar x)))
                                 '() ))) ))
          ((endp x) result)))))

;;; More Commonly-used List Functions

(defun revappend (x y)
  "Return (append (reverse x) y)."
  (dolist (a x y) (push a y)))




(defun butlast (list &optional (n 1 n-p))
  "Returns a new list the same as List without the N last elements."
  (setq list (require-type list 'list))
  (when (and n-p
	     (if (typep n 'fixnum)
	       (< (the fixnum n) 0)
	       (not (typep n 'unsigned-byte))))
    (report-bad-arg n 'unsigned-byte))
  (let* ((length (alt-list-length list)))
    (declare (fixnum length))		;guaranteed
    (when (< n length)
      (let* ((count (- length (the fixnum n)))
	     (head (cons nil nil))
	     (tail head))
	(declare (fixnum count) (cons head tail) (dynamic-extent head))
	;; Return a list of the first COUNT elements of list
	(dotimes (i count (cdr head))
	  (setq tail (cdr (rplacd tail (cons (pop list) nil)))))))))


(defun nbutlast (list &optional (n 1 n-p))
  "Modifies List to remove the last N elements."
  (setq list (require-type list 'list))
  (when (and n-p
	     (if (typep n 'fixnum)
	       (< (the fixnum n) 0)
	       (not (typep n 'unsigned-byte))))
    (report-bad-arg n 'unsigned-byte))
  (let* ((length (alt-list-length list)))
    (declare (fixnum length))		;guaranteed
    (when (< n length)
      (let* ((count (1- (the fixnum (- length (the fixnum n)))))
	     (tail list))
	(declare (fixnum count) (list tail))
	(dotimes (i count (rplacd tail nil))
	  (setq tail (cdr tail)))
	list))))
      

(defun ldiff (list object)
  "Return a new list, whose elements are those of LIST that appear before
   OBJECT. If OBJECT is not a tail of LIST, a copy of LIST is returned.
   LIST must be a proper list or a dotted list."
  (do* ((list (require-type list 'list) (cdr list)) 
        (result (cons nil nil))
        (splice result))
       ((atom list) 
        (if (eql list object) 
	  (cdr result) 
	  (progn (rplacd splice list) (cdr result))))
    (declare (dynamic-extent result)
	     (cons splice result))
    (if (eql list object) 
      (return (cdr result)) 
      (setq splice (cdr (rplacd splice (list (car list))))))))


;;; Functions to alter list structure

;;; The following are for use by SETF.

(defun %setnth (n list newval)
  "Sets the Nth element of List (zero based) to Newval."
  (if (%i< n 0)
      (error "~S is an illegal N for SETF of NTH." n)
      (do ((count n (%i- count 1)))
          ((%izerop count) (rplaca list newval) newval)
        (if (endp (cdr list))
            (error "~S is too large an index for SETF of NTH." n)
            (setq list (cdr list))))))

(defun test-not-error (test test-not)
  (%err-disp $xkeyconflict :test test :test-not test-not))

;;; Use this with the following keyword args:
;;;  (&key (key #'identity) (test #'eql testp) (test-not nil notp))

(eval-when (eval compile #-bccl load)
 (defmacro with-set-keys (funcall)
   `(cond (notp ,(append funcall '(:key key :test-not test-not)))
          (t ,(append funcall '(:key key :test test)))))

;;; Works with the above keylist.  We do three clauses so that if only test-not
;;; is supplied, then we don't test eql.  In each case, the args should be 
;;; multiply evaluable.

(defmacro elements-match-p (elt1 elt2)
  `(or (and testp
	    (funcall test (funcall key ,elt1) (funcall key ,elt2)))
       (and notp
	    (not (funcall test-not (funcall key ,elt1) (funcall key ,elt2))))
       (eql (funcall key ,elt1) (funcall key ,elt2))))



)
;;; Substitution of expressions

;subst that doesn't call labels
(defun subst (new old tree &key key
		           (test #'eql testp) (test-not nil notp))
  "Substitutes new for subtrees matching old."
  (if (and testp notp)
    (test-not-error test test-not))
  (subst-aux new old tree key test test-not))

(defun subst-aux (new old subtree key test test-not)
  (flet ((satisfies-the-test (item elt)
           (let* ((val (if key (funcall key elt) elt)))
             (if test-not
               (not (funcall test-not item val))
               (funcall test item val)))))
    (declare (inline satisfies-the-test))
    (cond ((satisfies-the-test old subtree) new)
          ((atom subtree) subtree)
          (t (let ((car (subst-aux new old (car subtree)
                                   key test test-not ))
                   (cdr (subst-aux new old (cdr subtree)
                                   key test test-not)))
               (if (and (eq car (car subtree))
                        (eq cdr (cdr subtree)))
                 subtree
                 (cons car cdr)))))))

;;;subst-if without a call to labels
;;; I've always wondered how those calls to a special operator
;;; should best be avoided.  Clearly, the answer involves
;;; lots of recursion.
(defun subst-if (new test tree &key key)
  "Substitutes new for subtrees for which test is true."
  (unless key (setq key #'identity))
  (cond ((funcall test (funcall key tree)) new)
        ((atom tree) tree)
        (t (let ((car (subst-if new test (car tree) :key key))
                 (cdr (subst-if new test (cdr tree) :key key)))
             (if (and (eq car (car tree))
                      (eq cdr (cdr tree)))
               tree
               (cons car cdr))))))

;subst-if-not without a call to labels
(defun subst-if-not (new test tree &key key)
  "Substitutes new for subtrees for which test is false."
  (unless key (setq key #'identity))
  (cond ((not (funcall test (funcall key tree))) new)
        ((atom tree) tree)
        (t (let ((car (subst-if-not new test (car tree) :key key))
                 (cdr (subst-if-not new test (cdr tree) :key key)))
             (if (and (eq car (car tree))
                      (eq cdr (cdr tree)))
               tree
               (cons car cdr))))))

(defun nsubst (new old tree &key key
                   (test #'eql testp) (test-not nil notp))
  "Substitute NEW for subtrees matching OLD."
  (if (and testp notp)
    (test-not-error test test-not))
  (nsubst-aux new old tree (or key #'identity) test test-not))

(defun nsubst-aux (new old subtree key test test-not)
  (flet ((satisfies-the-test (item elt)
           (let* ((val (if key (funcall key elt) elt)))
             (if test-not
               (not (funcall test-not item val))
               (funcall test item val)))))
    (declare (inline satisfies-the-test))
    (cond ((satisfies-the-test old subtree) new)
          ((atom subtree) subtree)
          (t (do* ((last nil subtree)
                   (subtree subtree (cdr subtree)))
                  ((atom subtree)
                   (if (satisfies-the-test old subtree)
                     (set-cdr last new)))
               (if (satisfies-the-test old subtree)
                 (return (set-cdr last new))
                 (set-car subtree 
                          (nsubst-aux new old (car subtree)
                                      key test test-not))))
             subtree))))

(defun nsubst-if (new test tree &key key)
  "Substitute NEW for subtrees of TREE for which TEST is true."
  (unless key (setq key #'identity))
  (cond ((funcall test (funcall key tree)) new)
        ((atom tree) tree)
        (t (do* ((last nil tree)
                 (tree tree (cdr tree)))
                ((atom tree)
                 (if (funcall test (funcall key tree))
                   (set-cdr last new)))
             (if (funcall test (funcall key tree))
               (return (set-cdr last new))
               (set-car tree 
                        (nsubst-if new test (car tree) :key key))))
           tree)))

(defun nsubst-if-not (new test tree &key key)
  "Substitute NEW for subtrees of TREE for which TEST is false."
  (unless key (setq key #'identity))
  (cond ((not (funcall test (funcall key tree))) new)
        ((atom tree) tree)
        (t (do* ((last nil tree)
                 (tree tree (cdr tree)))
                ((atom tree)
                 (if (not (funcall test (funcall key tree)))
                   (set-cdr last new)))
             (if (not (funcall test (funcall key tree)))
               (return (set-cdr (cdr last) new))
               (set-car tree 
                        (nsubst-if-not new test (car tree) :key key))))
           tree)))

(defun sublis (alist tree &key key
                     (test #'eql testp) (test-not nil notp))
  "Substitute from ALIST into TREE nondestructively."
  (if (and testp notp)
    (test-not-error test test-not))
  (sublis-aux alist tree (or key #'identity) test test-not notp))

(defun sublis-aux  (alist subtree key test test-not notp) 
  (let ((assoc (if notp
                 (assoc (funcall key subtree) alist :test-not test-not)
                 (assoc (funcall key subtree) alist :test test))))
    (cond (assoc (cdr assoc))
          ((atom subtree) subtree)
          (t (let ((car (sublis-aux alist (car subtree)
                                    key test test-not notp))
                   (cdr (sublis-aux alist (cdr subtree)
                                    key test test-not notp)))
               (if (and (eq car (car subtree))
                        (eq cdr (cdr subtree)))
                 subtree
                 (cons car cdr)))))))

(eval-when (compile eval)
  (defmacro nsublis-macro ()
    '(if notp
       (assoc (funcall key subtree) alist :test-not test-not)
       (assoc (funcall key subtree) alist :test test)))
  )

(defun nsublis (alist tree &key key
                      (test #'eql testp) (test-not nil notp))
  "Substitute from ALIST into TRUE destructively."
  (if (and testp notp)
    (test-not-error test test-not))
  (nsublis-aux alist tree (or key #'identity) test test-not notp))

(defun nsublis-aux (alist subtree key test test-not notp &optional temp)
  (cond ((setq temp (nsublis-macro))
         (cdr temp))
        ((atom subtree) subtree)
        (t (do*  ((last nil subtree)
                  (subtree subtree (cdr subtree)))
                 ((atom subtree)
                  (if (setq temp (nsublis-macro))
                    (set-cdr last (cdr temp))))
             (if (setq temp (nsublis-macro))
               (return (set-cdr last (cdr temp)))
               (set-car subtree 
                        (nsublis-aux alist (car subtree) key test
                                     test-not notp temp))))
           subtree)))

;;; Functions for using lists as sets


(defun member-if (test list &key key )
  "Return tail of LIST beginning with first element satisfying TEST."
  (unless key (setq key #'identity))
  (do ((list list (Cdr list)))
      ((endp list) nil)
    (if (funcall test (funcall key (car list)))
      (return list))))

(defun member-if-not (test list &key key)
  "Return tail of LIST beginning with first element not satisfying TEST."
  (unless key (setq key #'identity))
  (do ((list list (cdr list)))
      ((endp list) ())
    (if (not (funcall test (funcall key (car list))))
      (return list))))

(defun tailp (sublist list)                  ;Definition "B"
  "Return true if OBJECT is the same as some tail of LIST, otherwise
   returns false. LIST must be a proper list or a dotted list."
  (do ((list list (%cdr list)))
      ((atom list) (eql list sublist))
    (if (eq sublist list)
      (return t))))


 
(defun union (list1 list2  &key
                    key
                    (test #'eql testp)
                    (test-not nil notp))
  "Returns the union of LIST1 and LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res list2))
    (dolist (elt list1)
      (if (not (with-set-keys (member (funcall key elt) list2)))
        (push elt res)))
    res))






(eval-when (eval compile #-bccl load)
;;; Destination and source are setf-able and many-evaluable.
;;; Sets the source to the cdr, and "conses" the 1st elt of 
;;; source to destination.
(defmacro steve-splice (source destination)
  `(let ((temp ,source))
     (setf ,source (cdr ,source)
           (cdr temp) ,destination
           ,destination temp)))
)

(defun nunion (list1 list2 &key key
                     (test #'eql testp) (test-not nil notp))
  "Destructively return the union of LIST1 and LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res list2))
    (do ()
        ((endp list1))
      (if (not (with-set-keys (member (funcall key (car list1)) list2)))
        (steve-splice list1 res)
        (setq list1 (cdr list1))))
    res))




(defun intersection (list1 list2  &key key
                           (test #'eql testp) (test-not nil notp))
  "Return the intersection of LIST1 and LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res nil))
    (dolist (elt list1)
      (if (with-set-keys (member (funcall key elt) list2))
        (push elt res)))
    res))

(defun nintersection (list1 list2 &key key
                            (test #'eql testp) (test-not nil notp))
  "Destructively return the intersection of LIST1 and LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res nil))
    (do () ((endp list1))
      (if (with-set-keys (member (funcall key (car list1)) list2))
        (steve-splice list1 res)
        (setq list1 (Cdr list1))))
    res))

(defun set-difference (list1 list2 &key key
                             (test #'eql testp) (test-not nil notp))
  "Return the elements of LIST1 which are not in LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res nil))
    (dolist (elt list1)
      (if (not (with-set-keys (member (funcall key elt) list2)))
        (push elt res)))
    res))

(defun nset-difference (list1 list2 &key key
                              (test #'eql testp) (test-not nil notp))
  "Destructively return the elements of LIST1 which are not in LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (let ((res nil))
    (do () ((endp list1))
      (if (not (with-set-keys (member (funcall key (car list1)) list2)))
	  (steve-splice list1 res)
          (setq list1 (cdr list1))))
    res))

#| spice version
(defun set-exclusive-or (list1 list2 &key (key #'identity)
                               (test #'eql testp) (test-not nil notp))
  "Returns new list of elements appearing exactly  once in List1 and List2.
  If an element appears > once in a list and does not appear at all in the
  other list, that element will appear >1 in the output list."
  (let ((result nil))
    (dolist (elt list1)
      (unless (with-set-keys (member (funcall key elt) list2))
        (setq result (cons elt result))))
    (dolist (elt list2)
      (unless (with-set-keys (member (funcall key elt) list1))
        (setq result (cons elt result))))
    result))
|#

(defun set-exclusive-or (list1 list2 &key key
                               (test #'eql testp) (test-not nil notp)
                               &aux result elt1-compare elt2-compare)
  "Return new list of elements appearing exactly once in LIST1 and LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (dolist (elt1 list1)
    (setq elt1-compare (funcall key elt1))
    (if (if notp
           (dolist (elt2 list2 t)
            (if (not (funcall test-not elt1-compare (funcall key elt2)))
              (return nil)))
          (dolist (elt2 list2 t)
            (if (funcall test elt1-compare (funcall key elt2))
              (return nil))))
      (push elt1 result)))
  (dolist (elt2 list2)
    (setq elt2-compare (funcall key elt2))
    (if (if notp
          (dolist (elt1 list1 t)
            (if (not (funcall test-not (funcall key elt1) elt2-compare))
              (return nil)))
          (dolist (elt1 list1 t)
            (if (funcall test (funcall key elt1) elt2-compare)
              (return nil))))
      (push elt2 result)))
  result)

#| the description of the below SpiceLisp algorthm used for implementing
 nset-exclusive-or sounds counter to CLtL. Furthermore, it fails 
on the example (nset-exclusive-or (list 1 1) (list 1))
  [returns (1) but should return NIL.] ... fry

;;; The outer loop examines list1 while the inner loop examines list2. If an
;;; element is found in list2 "equal" to the element in list1, both are
;;; spliced out. When the end of list1 is reached, what is left of list2 is
;;; tacked onto what is left of list1.  The splicing operation ensures that
;;; the correct operation is performed depending on whether splice is at the
;;; top of the list or not

(defun nset-exclusive-or (list1 list2 &key (test #'eql) (test-not nil notp)
                                (key #'identity))
  "Return a list with elements which appear but once in List1 and List2."
  (do ((x list1 (cdr x))
       (splicex ()))
      ((endp x)
       (if (null splicex)
         (setq list1 list2)
         (rplacd splicex list2))
       list1)
    (do ((y list2 (cdr y))
         (splicey ()))
        ((endp y) (setq splicex x))
      (cond ((if notp 
               (not (funcall test-not (funcall key (car x))
                             (funcall key (car y))))
               (funcall test (funcall key (car x)) 
                        (funcall key (car y))))
             (if (null splicex)
               (setq list1 (cdr x))
               (rplacd splicex (cdr x)))
             (if (null splicey) 
               (setq list2 (cdr y))
               (rplacd splicey (cdr y)))
             (return ()))			; assume lists are really sets
            (t (setq splicey y))))))
|#

(defun nset-exclusive-or (list1 list2 &key key
                               (test #'eql testp) (test-not nil notp))
  "Destructively return a list with elements which appear but once in LIST1
   and LIST2."
   (if (and testp notp)
     (test-not-error test test-not))
   (unless key (setq key #'identity))
   (if notp
     (set-exclusive-or list1 list2 :key key :test-not test-not)
     (set-exclusive-or list1 list2 :key key :test test)
     ))

(defun subsetp (list1 list2 &key key
                      (test #'eql testp) (test-not nil notp))
  "Return T if every element in LIST1 is also in LIST2."
  (if (and testp notp)
    (test-not-error test test-not))
  (unless key (setq key #'identity))
  (dolist (elt list1)
    (unless (with-set-keys (member (funcall key elt) list2))
      (return-from subsetp nil)))
  T)


;;; Functions that operate on association lists

(defun acons (key datum a-list)
  "Construct a new alist by adding the pair (KEY . DATUM) to ALIST."
  (cons (cons key datum) a-list))

(defun pairlis (keys data &optional (alist '()))
  "Construct an association list from KEYS and DATA (adding to ALIST)."
  (do ((x keys (cdr x))
       (y data (cdr y)))
      ((and (endp x) (endp y)) alist)
    (if (or (endp x) (endp y)) 
      (error "The lists of keys and data are of unequal length."))
    (setq alist (acons (car x) (car y) alist))))

(defun default-identity-key (key)
  (and key (neq key 'identity) (neq key #'identity) (coerce-to-function key)))

(defun assoc-if (predicate alist &key key)
  "Return the first cons in ALIST whose CAR satisfies PREDICATE. If
   KEY is supplied, apply it to the CAR of each cons before testing."
  (setq key (default-identity-key key))
  (dolist (pair alist)
    (when (and pair
               (funcall predicate 
                        (if key (funcall key (car pair))
                            (car pair))))
      (return pair))))

(defun assoc-if-not (predicate alist &key key)
  "Return the first cons in ALIST whose CAR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CAR of each cons before testing."
  (setq key (default-identity-key key))
  (dolist (pair alist)
    (when (and pair
               (not (funcall predicate 
                        (if key (funcall key (car pair))
                            (car pair)))))
      (return pair))))

(defun rassoc-if (predicate alist &key key)
  "Return the first cons in ALIST whose CDR satisfies PREDICATE. If KEY
  is supplied, apply it to the CDR of each cons before testing."
  (setq key (default-identity-key key))
  (dolist (pair alist)
    (when (and pair
               (funcall predicate 
                        (if key (funcall key (cdr pair))
                            (cdr pair))))
      (return pair))))

(defun rassoc-if-not (predicate alist &key key)
  "Return the first cons in ALIST whose CDR does not satisfy PREDICATE.
  If KEY is supplied, apply it to the CDR of each cons before testing."
  (setq key (default-identity-key key))
  (dolist (pair alist)
    (when (and pair
               (not (funcall predicate 
                        (if key (funcall key (cdr pair))
                            (cdr pair)))))
      (return pair))))


(defun map1 (function original-arglists accumulate take-car)
 "This function is called by mapc, mapcar, mapcan, mapl, maplist, and mapcon.
 It Maps function over the arglists in the appropriate way. It is done when any
 of the arglists runs out.  Until then, it CDRs down the arglists calling the
 function and accumulating results as desired."
  (let* ((length (length original-arglists))
         (arglists (make-list length))
         (args (make-list length))
         (ret-list (list nil))
         (temp ret-list))
    (declare (dynamic-extent arglists args ret-list))
    (let ((argstail arglists))
      (dolist (arg original-arglists)
        (setf (car (the cons argstail)) arg)
        (pop argstail)))
    (do ((res nil)
         (argstail args args))
        ((memq nil arglists)
         (if accumulate
             (cdr ret-list)
             (car original-arglists)))
      (do ((l arglists (cdr l)))
          ((not l))
        (setf (car (the cons argstail)) (if take-car (car (car l)) (car l)))
        (rplaca l (cdr (car l)))
        (pop argstail))
      (setq res (apply function args))
      (case accumulate
        (:nconc 
         (setq temp (last (nconc temp res))))
        (:list  (rplacd temp (list res))
                (setq temp (cdr temp)))))))

(defun mapc (function list &rest more-lists)
  "Apply FUNCTION to successive elements of lists. Return the second argument."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists nil t))))

(defun mapcar (function list &rest more-lists)
  "Apply FUNCTION to successive elements of LIST. Return list of FUNCTION
   return values."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists :list t))))

(defun mapcan (function list &rest more-lists)
  "Apply FUNCTION to successive elements of LIST. Return NCONC of FUNCTION
   results."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists :nconc t))))

(defun mapl (function list &rest more-lists)
  "Apply FUNCTION to successive CDRs of list. Return NIL."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists nil nil))))

(defun maplist (function list &rest more-lists)
  "Apply FUNCTION to successive CDRs of list. Return list of results."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists :list nil))))

(defun mapcon (function list &rest more-lists)
  "Apply FUNCTION to successive CDRs of lists. Return NCONC of results."
  (declare (dynamic-extent more-lists))
  (let ((arglists (cons list more-lists)))
    (declare (dynamic-extent arglists))
    (values (map1 function arglists :nconc nil))))

;;; Functions for compatibility sake:

(defun delq (item a-list &optional (n 0 np))  
  "Returns list with all (up to n) elements with all elements EQ to ITEM
   deleted"
   ;(%print "a-list = " a-list) 
  (declare (type list a-list) (type integer n))
  ;(%print "a-list = " a-list) 
  (do ((x a-list (cdr x))
       (splice '()))
      ((or (endp x)
           (and np (zerop n))) 
       a-list)
    ; (%print "a-list = " a-list)
    (cond ((eq item (car x))
           (setq n (- n 1))
           (if (null splice) 
             (setq a-list (cdr x))
             (rplacd splice (cdr x))))
          (T (setq splice x)))))	; move splice along to include element

(defun list-length-and-final-cdr (list)
  "First value reutrned is length of regular list.
    [for (a b . c), returns 2]
    [for circular lists, returns NIL]
   Second value is the final cdr.
    [ for (a b), returns NIL
      for (a b . c), returns c
      for circular lists, returns NIL]
   Third value only returned if we have a circular list. It is
   the MAX possible length of the list until the repeat."
   (do* ((n 0 (+ n 2))
         (fast list (cddr fast))
         (slow list (cdr slow)))
        ()
     (declare (fixnum n))
     (cond ((null fast)
            (return (values n nil)))
           ((not (consp fast))
            (return (values n fast)))
           ((null (cdr fast))
            (return (values (1+ n) nil)))
           ((and (eq fast slow) (> n 0)) ;circular list
            (return (values nil nil n)))          
           ((not (consp (cdr fast)))
            (return (values (1+ n) (cdr fast)))))))

(provide 'lists)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/lists.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/nfcomp.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;; :lib:nfcomp.lisp - New fasl compiler.

(eval-when (:compile-toplevel :load-toplevel :execute)
   (require 'level-2))

(require 'optimizers)
(require 'hash)

(eval-when (:compile-toplevel :execute)

(require 'backquote)
(require 'defstruct-macros)

(defmacro short-fixnum-p (fixnum)
  `(and (fixnump ,fixnum) (< (integer-length ,fixnum) 16)))

(require "FASLENV" "ccl:xdump;faslenv")

#+ppc32-target
(require "PPC32-ARCH")
#+ppc64-target
(require "PPC64-ARCH")
#+x8632-target
(require "X8632-ARCH")
#+x8664-target
(require "X8664-ARCH")
) ;eval-when (:compile-toplevel :execute)


;File compiler options.  Not all of these need to be exported/documented, but
;they should be in the product just in case we need them for patches....
(defvar *fasl-save-local-symbols* t)
(defvar *fasl-save-doc-strings*  t)
(defvar *fasl-save-definitions* nil)

(defvar *fasl-deferred-warnings* nil)
(defvar *fasl-non-style-warnings-signalled-p* nil)
(defvar *fasl-warnings-signalled-p* nil)

(defvar *compile-verbose* nil ; Might wind up getting called *compile-FILE-verbose*
  "The default for the :VERBOSE argument to COMPILE-FILE.")
(defvar *compile-file-pathname* nil
  "The defaulted pathname of the file currently being compiled, or NIL if not
  compiling.") ; pathname of src arg to COMPILE-FILE
(defvar *compile-file-truename* nil
  "The TRUENAME of the file currently being compiled, or NIL if not
  compiling.") ; truename ...
(defvar *fasl-target* (backend-name *host-backend*))
(defvar *fasl-backend* *host-backend*)
(defvar *fasl-host-big-endian*
  (arch::target-big-endian (backend-target-arch *host-backend*)))
(defvar *fasl-target-big-endian* *fasl-host-big-endian*)
(defvar *fcomp-external-format* :default)

(defvar *fasl-break-on-program-errors* :defer
  "Controls what happens when the compiler detects PROGRAM-ERROR's during file compilation.

  If T, the compiler signals an error immediately when it detects the program-error.

  If :DEFER, program errors are reported as compiler warnings, and in addition, an error
    is signalled at the end of file compilation.  This allows all warnings for the file
    to be reported, but prevents the creation of a fasl file.

  If NIL, program errors are treated the same as any other error condition detected by
   the compiler, i.e. they are reported as compiler warnings and do not cause any
   error to be signalled at compile time.")
  

(defvar *compile-print* nil ; Might wind up getting called *compile-FILE-print*
  "The default for the :PRINT argument to COMPILE-FILE.")

;Note: errors need to rebind this to NIL if they do any reading without
; unwinding the stack!
(declaim (special *compiling-file*)) ; defined in l1-init.

(defvar *fasl-source-file* nil "Name of file currently being read from.
Will differ from *compiling-file* during an INCLUDE")

(defparameter *fasl-package-qualified-symbols* '(*loading-file-source-file* set-package %define-package)
  "These symbols are always fasdumped with full package qualification.")

(defvar *fasl-setf-name-alias-alist* ())

(defun setup-target-features (backend features)
  (if (eq backend *host-backend*)
    features
    (let* ((new nil)
	   (nope (backend-target-specific-features *host-backend*)))
      (dolist (f features)
	(unless (memq f nope) (pushnew f new)))
      (dolist (f (backend-target-specific-features backend)
	       (progn (pushnew :cross-compiling new) new))
	(pushnew f new)))))

(defun compile-file-pathname (pathname &rest ignore &key output-file &allow-other-keys)
  "Return a pathname describing what file COMPILE-FILE would write to given
   these arguments."
  (declare (ignore ignore))
  (setq pathname (merge-pathnames pathname))
  (merge-pathnames (if output-file
                     (merge-pathnames output-file *.fasl-pathname*)
                     *.fasl-pathname*) 
                   pathname))

(defun compile-file (src &key output-file
                         (verbose *compile-verbose*)
                         (print *compile-print*)
                         load
                         (features nil features-p)
                         (target *fasl-target* target-p)
                         (save-local-symbols *fasl-save-local-symbols*)
                         (save-doc-strings *fasl-save-doc-strings*)
                         (save-definitions *fasl-save-definitions*)
                         (save-source-locations *save-source-locations*)
                         (external-format :default)
                         force
                         ;; src may be a temp file with a section of the real source,
                         ;; then this is the real source file name.
                         compile-file-original-truename
                         (compile-file-original-buffer-offset 0)
                         (break-on-program-errors (if compile-file-original-truename
                                                    t  ;; really SLIME being interactive...
                                                    *fasl-break-on-program-errors*))
                         (load-preserves-optimization-settings *load-preserves-optimization-settings*))
  "Compile SRC, producing a corresponding fasl file and returning its filename."
  (let* ((backend *target-backend*)
         (symbols ())
         (values ())
         (*load-preserves-optimization-settings* load-preserves-optimization-settings))
    (when (and target-p (not (setq backend (find-backend target))))
      (warn "Unknown :TARGET : ~S.  Reverting to ~s ..." target *fasl-target*)
      (setq target *fasl-target*  backend *target-backend*))
    (if (eq *target-backend* *host-backend*)
      (when features-p
        (setq symbols '(*features*)
              values (list (append (if (listp features) features (list features)) *features*))))
      (setq symbols '(*features*)
            values (list (setup-target-features *target-backend* *features*))
            save-source-locations nil))
    (multiple-value-bind (output-file truename warnings-p serious-p)
        (loop
          (restart-case
              (return (progv symbols values
                        (%compile-file src output-file verbose print
                                       save-local-symbols save-doc-strings save-definitions
                                       save-source-locations break-on-program-errors
                                       force backend external-format
                                       compile-file-original-truename compile-file-original-buffer-offset)))
            (retry-compile-file ()
              :report (lambda (stream) (format stream "Retry compiling ~s" src))
              nil)
            (skip-compile-file ()
              :report (lambda (stream)
                        (if load
                          (format stream "Skip compiling and loading ~s" src)
                          (format stream "Skip compiling ~s" src)))
              (return-from compile-file))))
      (when load (load output-file :verbose (or verbose *load-verbose*)))
      (values truename warnings-p serious-p))))


(defvar *fasl-compile-time-env* nil)

(defun %compile-file (src output-file verbose print
                          save-local-symbols save-doc-strings save-definitions
                          save-source-locations break-on-program-errors
                          force target-backend external-format
                          compile-file-original-truename compile-file-original-buffer-offset)
  (let* ((orig-src (merge-pathnames src))
         (output-default-type (backend-target-fasl-pathname target-backend))
         (*fasl-non-style-warnings-signalled-p* nil)
         (*fasl-warnings-signalled-p* nil))
    (setq src (fcomp-find-file orig-src))
    (let* ((newtype (pathname-type src)))
      (when (and newtype (not (pathname-type orig-src)))
        (setq orig-src (merge-pathnames orig-src (make-pathname :type newtype :defaults nil)))))
    (setq output-file (merge-pathnames
		       (if output-file  ; full-pathname in case output-file is relative
			 (full-pathname (merge-pathnames output-file output-default-type) :no-error nil) 
			 output-default-type)
		       orig-src))
    ;; This should not be necessary, but it is.
    (setq output-file (namestring output-file))
    (when (physical-pathname-p orig-src) ; only back-translate to things likely to exist at load time
      (setq orig-src (back-translate-pathname orig-src '("home" "ccl"))))
    (when (and (not force)
               (probe-file output-file)
               (not (fasl-file-p output-file)))
      (cerror "overwrite it anyway"
              "Compile destination ~S is not a ~A file!"
              output-file (pathname-type
                           (backend-target-fasl-pathname
                            *target-backend*))))
    (let* ((*fasl-deferred-warnings* nil) ; !!! WITH-COMPILATION-UNIT ...
           (*fasl-save-local-symbols* save-local-symbols)
           (*save-source-locations* save-source-locations)
           (*fasl-save-doc-strings* save-doc-strings)
           (*fasl-save-definitions* save-definitions)
           (*fasl-break-on-program-errors* break-on-program-errors)
           (*fcomp-warnings-header* nil)
           (*compile-file-pathname* orig-src)
           (*compile-file-truename* (truename src))
           (*package* *package*)
           (*readtable* *readtable*)
           (*compile-print* print)
           (*compile-verbose* verbose)
           (*fasl-target* (backend-name target-backend))
           (*fasl-backend* target-backend)
           (*fasl-target-big-endian* (arch::target-big-endian
                                      (backend-target-arch target-backend)))
           (*target-ftd* (backend-target-foreign-type-data target-backend))
           (defenv (new-definition-environment))
           (lexenv (new-lexical-environment defenv))
           (*fasl-compile-time-env* (new-lexical-environment (new-definition-environment)))
           (*fcomp-external-format* (if (eq external-format :default)
                                      :inferred
                                      external-format))
           (*fasl-setf-name-alias-alist* ())
           (forms nil))
      (let ((current *outstanding-deferred-warnings*) last)
        (when (and current
                   (setq last (deferred-warnings.last-file current))
                   (equalp *compile-file-pathname* (cdr last)))
          ;; Discard previous deferred warnings when recompiling exactly the same file again,
          ;; since most likely this is due to an interactive "retry compilation" request and
          ;; we want to avoid duplicate warnings.
          (setf (deferred-warnings.last-file current) nil)))

      (let* ((*outstanding-deferred-warnings* (%defer-warnings nil)))
        (rplacd (defenv.type defenv) *outstanding-deferred-warnings*)
        (setf (defenv.defined defenv) (deferred-warnings.defs *outstanding-deferred-warnings*))

        (setq forms (fcomp-file src
                                (or compile-file-original-truename (namestring orig-src))
                                compile-file-original-buffer-offset
                                lexenv))

        (setf (deferred-warnings.warnings *outstanding-deferred-warnings*) 
              (append *fasl-deferred-warnings* (deferred-warnings.warnings *outstanding-deferred-warnings*)))
        (when *compile-verbose* (fresh-line))
        (multiple-value-bind (any harsh) (report-deferred-warnings *compile-file-pathname*)
          (setq *fasl-warnings-signalled-p* (or *fasl-warnings-signalled-p* any)
                *fasl-non-style-warnings-signalled-p* (if (eq harsh :very) :very
                                                        (or *fasl-non-style-warnings-signalled-p* harsh)))))
      (when (and *fasl-break-on-program-errors* (eq *fasl-non-style-warnings-signalled-p* :very))
        (cerror "create the output file despite the errors"
                "Serious errors encountered during compilation of ~s"
                src))
      (fasl-scan-forms-and-dump-file forms output-file lexenv)
      (values output-file
              (truename (pathname output-file)) 
              *fasl-warnings-signalled-p* 
              (and *fasl-non-style-warnings-signalled-p* t)))))

(defvar *fcomp-locked-hash-tables*)
(defvar *fcomp-load-forms-environment* nil)

; This is separated out so that dump-forms-to-file can use it
(defun fasl-scan-forms-and-dump-file (forms output-file &optional env)
  (let ((*fcomp-locked-hash-tables* nil)
	(*fcomp-load-forms-environment* env))
    (unwind-protect
      (multiple-value-bind (hash gnames goffsets) (fasl-scan forms)
        (fasl-dump-file gnames goffsets forms hash output-file))
      (fasl-unlock-hash-tables))))

#-bccl
(defun nfcomp (src &optional dest &rest keys)
  (when (keywordp dest) (setq keys (cons dest keys) dest nil))
  (apply #'compile-file src :output-file dest keys))

#-bccl
(%fhave 'fcomp #'nfcomp)

(defparameter *default-file-compilation-policy* (new-compiler-policy))

(defun current-file-compiler-policy ()
  *default-file-compilation-policy*)

(defun set-current-file-compiler-policy (&optional new-policy)
  (setq *default-file-compilation-policy* 
        (if new-policy (require-type new-policy 'compiler-policy) (new-compiler-policy))))

(defparameter *compile-time-evaluation-policy*
  (new-compiler-policy :force-boundp-checks t))

(defun %compile-time-eval (form env)
  (declare (ignore env))
  (let* ((*target-backend* *host-backend*)
         (*loading-toplevel-location* (or (fcomp-source-note form)
                                          *loading-toplevel-location*))
         (lambda `(lambda () ,form)))
    (fcomp-note-source-transformation form lambda)
    ;; The HANDLER-BIND here is supposed to note WARNINGs that're
    ;; signaled during (eval-when (:compile-toplevel) processing; this
    ;; in turn is supposed to satisfy a pedantic interpretation of the
    ;; spec's requirement that COMPILE-FILE's second and third return
    ;; values reflect (all) conditions "detected by the compiler."
    ;; (It's kind of sad that CL language design is influenced so
    ;; strongly by the views of pedants these days.)
    (handler-bind ((warning (lambda (c)
                              (setq *fasl-warnings-signalled-p* t)
                              (unless (typep c 'style-warning)
                                (setq *fasl-non-style-warnings-signalled-p* t))
                              (signal c))))
      (funcall (compile-named-function
                lambda
                :compile-code-coverage nil
                :source-notes *fcomp-source-note-map*
                :env *fasl-compile-time-env*
                :policy *compile-time-evaluation-policy*)))))


;;; No methods by default, not even for structures.  This really sux.
(defgeneric make-load-form (object &optional environment))

;;; Well, no usable methods by default.  How this is better than
;;; getting a NO-APPLICABLE-METHOD error frankly escapes me,
;;; [Hint: this is called even when there is an applicable method]
(defun no-make-load-form-for (object)
  (error "No ~S method is defined for ~s" 'make-load-form object))

(defmethod make-load-form ((s standard-object) &optional environment)
  (declare (ignore environment))
  (no-make-load-form-for s))

(defmethod make-load-form ((s structure-object) &optional environment)
  (declare (ignore environment))
  (no-make-load-form-for s))

(defmethod make-load-form ((c condition) &optional environment)
  (declare (ignore environment))
  (no-make-load-form-for c))

(defmethod make-load-form ((c class) &optional environment)
  (let* ((name (class-name c))
	 (found (if name (find-class name nil environment))))
    (if (eq found c)
      `(find-class ',name)
      (error "Class ~s does not have a proper name." c))))


;;;;          FCOMP-FILE - read & compile file
;;;;          Produces a list of (opcode . args) to run on loading, intermixed
;;;;          with read packages.

(defparameter *fasl-eof-forms* nil)

(defparameter cfasl-load-time-eval-sym (make-symbol "LOAD-TIME-EVAL"))
(%macro-have cfasl-load-time-eval-sym
    #'(lambda (call env) (declare (ignore env)) (list 'eval (list 'quote call))))
;Make it a constant so compiler will barf if try to bind it, e.g. (LET #,foo ...)
(define-constant cfasl-load-time-eval-sym cfasl-load-time-eval-sym)


(defparameter *reading-for-cfasl* nil "Used by the reader for #,")



(declaim (special *nx-compile-time-types*
;The following are the global proclaimed values.  Since compile-file binds
;them, this means you can't ever globally proclaim these things from within a
;file compile (e.g. from within eval-when compile, or loading a file) - the
;proclamations get lost when compile-file exits.  This is sort of intentional
;(or at least the set of things which fall in this category as opposed to
;having a separate compile-time variable is sort of intentional).
                    *nx-proclaimed-inline*    ; inline and notinline
                    *nx-proclaimed-ignore*    ; ignore and unignore
                    *nx-known-declarations*   ; declaration
                    *nx-speed*                ; optimize speed
                    *nx-space*                ; optimize space
                    *nx-safety*               ; optimize safety
                    *nx-cspeed*))             ; optimize compiler-speed

(defvar *fcomp-load-time*)
(defvar *fcomp-inside-eval-always* nil)
(defvar *fcomp-eval-always-functions* nil)   ; used by the LISP package
(defvar *fcomp-output-list*)
(defvar *fcomp-toplevel-forms*)
(defvar *fcomp-source-note-map* nil)
(defvar *fcomp-loading-toplevel-location*)
(defvar *fcomp-warnings-header*)
(defvar *fcomp-stream-position* nil)
(defvar *fcomp-previous-position* nil)
(defvar *fcomp-indentation*)
(defvar *fcomp-print-handler-plist* nil)
(defvar *fcomp-last-compile-print*
  '(INCLUDE (NIL . T)
    DEFSTRUCT ("Defstruct" . T) 
    DEFCONSTANT "Defconstant" 
    DEFSETF "Defsetf" 
    DEFTYPE "Deftype" 
    DEFCLASS "Defclass" 
    DEFGENERIC "Defgeneric"
    DEFMETHOD "Defmethod"
    DEFMACRO "Defmacro" 
    DEFPARAMETER "Defparameter" 
    DEFVAR "Defvar" 
    DEFUN ""))

(setf (getf *fcomp-print-handler-plist* 'defun) ""
      (getf *fcomp-print-handler-plist* 'defvar) "Defvar"
      (getf *fcomp-print-handler-plist* 'defparameter) "Defparameter"
      (getf *fcomp-print-handler-plist* 'defmacro) "Defmacro"
      (getf *fcomp-print-handler-plist* 'defmethod) "Defmethod"  ; really want more than name (use the function option)
      (getf *fcomp-print-handler-plist* 'defgeneric) "Defgeneric"
      (getf *fcomp-print-handler-plist* 'defclass) "Defclass"
      (getf *fcomp-print-handler-plist* 'deftype) "Deftype"
      (getf *fcomp-print-handler-plist* 'defsetf) "Defsetf"
      (getf *fcomp-print-handler-plist* 'defconstant) "Defconstant"
      (getf *fcomp-print-handler-plist* 'defstruct) '("Defstruct" . t)
      (getf *fcomp-print-handler-plist* 'include) '(nil . t))


(defun fcomp-file (filename orig-file orig-offset env)  ; orig-file is back-translated
  (let* ((*package* *package*)
         (*compiling-file* filename)
         (*nx-compile-time-types* *nx-compile-time-types*)
         (*nx-proclaimed-inline* *nx-proclaimed-inline*)
         (*nx-known-declarations* *nx-known-declarations*)
         (*nx-proclaimed-ignore* *nx-proclaimed-ignore*)
         (*nx-speed* *nx-speed*)
         (*nx-space* *nx-space*)
         (*nx-debug* *nx-debug*)
         (*nx-safety* *nx-safety*)
         (*nx-cspeed* *nx-cspeed*)
         (*fcomp-load-time* t)
         (*fcomp-output-list* nil)
         (*fcomp-indentation* 0)
         (*fcomp-last-compile-print* (cons nil (cons nil nil))))
    (push (list $fasl-platform (backend-target-platform *fasl-backend*)) *fcomp-output-list*)
    (fcomp-read-loop filename orig-file orig-offset env :not-compile-time)
    (nreverse *fcomp-output-list*)))

(defun fcomp-find-file (file &aux path)
  (unless (or (and (setq path (probe-file file))
		   (not (directoryp path)))
              (setq path (probe-file (merge-pathnames file *.lisp-pathname*))))
    (error 'file-error :pathname file :error-type "File ~S not found"))
  (namestring path))

;;; orig-file is back-translated when from fcomp-file
;;; when from fcomp-include it's included filename merged with *compiling-file*
;;; which is not back translated
(defun fcomp-read-loop (filename orig-file orig-offset env processing-mode)
  (when *compile-verbose*
    (format t "~&;~A ~S..."
            (if (eq filename *compiling-file*) "Compiling" " Including")
            filename))
  (with-open-file (stream filename
                          :element-type 'base-char
                          :external-format *fcomp-external-format*)
    (let* ((old-file (and (neq filename *compiling-file*) *fasl-source-file*))
           (*fasl-source-file* (or orig-file filename))
           (*fcomp-toplevel-forms* nil)
           (*fasl-eof-forms* nil)
           (*loading-file-source-file* orig-file)
           (*fcomp-source-note-map* (and (or *save-source-locations* *compile-code-coverage*)
                                         (make-hash-table :test #'eq :shared nil)))
           (*loading-toplevel-location* nil)
           (*fcomp-loading-toplevel-location* nil)
           (eofval (cons nil nil))
           (read-package nil)
           form)

      (fcomp-output-form $fasl-src env *loading-file-source-file*)
      (let* ((*fcomp-previous-position* nil))
        (loop
          (let* ((*fcomp-stream-position* (file-position stream))
                 (*nx-warnings* nil)) ;; catch any warnings from :compile-toplevel forms
            (when (and *fcomp-stream-position* orig-offset)
              (incf *fcomp-stream-position* orig-offset))
            (unless (eq read-package *package*)
              (fcomp-compile-toplevel-forms env)
              (setq read-package *package*))
            (let ((*reading-for-cfasl*
                   (and *fcomp-load-time* cfasl-load-time-eval-sym)))
              (declare (special *reading-for-cfasl*))
              (let ((pos (file-position stream)))
                (handler-bind
                    ((error #'(lambda (c) ; we should distinguish read errors from others?
                                (format *error-output* "~&Read error between positions ~a and ~a in ~a." pos (file-position stream) filename)
                                (signal c))))
                  (multiple-value-setq (form *loading-toplevel-location*)
                    (read-recording-source stream
                                           :eofval eofval
                                           :file-name *loading-file-source-file*
                                           :start-offset orig-offset
                                           :map *fcomp-source-note-map*
                                           :save-source-text (neq *save-source-locations* :no-text))))))
            (when (eq eofval form)
	      (require-type *loading-toplevel-location* 'null)
	      (return))
            (fcomp-form form env processing-mode)
            (fcomp-signal-or-defer-warnings *nx-warnings* env)
            (setq *fcomp-previous-position* *fcomp-stream-position*))))
      (when *compile-code-coverage*
	(fcomp-compile-toplevel-forms env)
        (let* ((fns (fcomp-code-covered-functions))
	       (v (nreverse (coerce fns 'vector)))
               (id (fcomp-file-checksum stream)))
	  (map nil #'fcomp-digest-code-notes v)
          (fcomp-random-toplevel-form `(register-code-covered-functions ',v
                                                                        ',*fcomp-external-format*
                                                                        ,id)
                                      env)))
      (while (setq form *fasl-eof-forms*)
        (setq *fasl-eof-forms* nil)
        (fcomp-form-list form env processing-mode))
      (when old-file
        (fcomp-output-form $fasl-src env (namestring *compile-file-pathname*)))
      (fcomp-compile-toplevel-forms env))))

(defvar *crc32-table* (let ((crc-table (make-array 256 :element-type '(unsigned-byte 32))))
                        (loop for i from 0 below 255 as crc = i
                              do (loop for j from 0 below 8
                                       do (setq crc (ash crc -1))
                                       do (when (oddp crc)
                                            (setq crc (logxor crc  #xEDB88320))))
                              do (setf (aref crc-table i) crc))
                        crc-table))
(declaim (type (simple-array (unsigned-byte 32) (256)) *crc32-table*))

(defun fcomp-stream-checksum (stream)
  ;; Could consider crc16 for 32-bit targets, but this is only used with code
  ;; coverage so don't worry about efficiency anyway.
  (file-position stream 0)
  (let ((crc 0))
    (declare (type (unsigned-byte 32) crc))
    (loop for char base-char = (read-char stream nil) while char
          do (setq crc (logxor
                         (%ilogand (ash crc -8) #x00FFFFFF)
                         (aref *crc32-table* (logand (logxor crc (char-code char)) #xFF)))))
    (logior (ash (file-position stream) 32) crc)))

(defun fcomp-file-checksum (filename &key (external-format *fcomp-external-format*))
  (when (setq filename (probe-file filename))
    (with-open-file (stream filename
                            :element-type 'base-char
                            :external-format external-format)
      (fcomp-stream-checksum stream))))

(defun fcomp-code-covered-functions ()
  (loop for op in *fcomp-output-list*
        when (consp op)
          nconc (if (eq (car op) $fasl-lfuncall)
                  ;; Don't collect the toplevel lfun itself, it leads to spurious markings.
                  ;; Instead, descend one level and collect any referenced fns.
                  (destructuring-bind (fn) (cdr op)
                    (lfunloop for imm in fn when (functionp imm) collect imm))
                  (loop for arg in (cdr op) when (functionp arg) collect arg))))


(defun fcomp-form (form env processing-mode
                        &aux print-stuff 
                        (load-time (and processing-mode (neq processing-mode :compile-time)))
                        (compile-time-too (or (eq processing-mode :compile-time) 
                                              (eq processing-mode :compile-time-too))))
  (let* ((*fcomp-indentation* *fcomp-indentation*)
         (*compile-print* *compile-print*))
    (when *compile-print*
      (cond ((and (consp form) (setq print-stuff (getf *fcomp-print-handler-plist* (car form))))
             (rplaca (rplacd (cdr *fcomp-last-compile-print*) nil) nil)
             (rplaca *fcomp-last-compile-print* nil)         
             (let ((print-recurse nil))
               (when (consp print-stuff)
                 (setq print-recurse (cdr print-stuff) print-stuff (car print-stuff)))
               (cond ((stringp print-stuff)
                      (if (equal print-stuff "")
                        (format t "~&~vT~S~%" *fcomp-indentation* (second form))
                        (format t "~&~vT~S [~A]~%" *fcomp-indentation* (second form) print-stuff)))
                     ((not (null print-stuff))
                      (format t "~&~vT" *fcomp-indentation*)
                      (funcall print-stuff form *standard-output*)
                      (terpri *standard-output*)))
               (if print-recurse
                 (setq *fcomp-indentation* (+ *fcomp-indentation* 4))
                 (setq *compile-print* nil))))
            (t (unless (and (eq load-time (car *fcomp-last-compile-print*))
                            (eq compile-time-too (cadr *fcomp-last-compile-print*))
                            (eq *fcomp-indentation* (cddr *fcomp-last-compile-print*)))
                 (rplaca *fcomp-last-compile-print* load-time)
                 (rplaca (rplacd (cdr *fcomp-last-compile-print*) compile-time-too) *fcomp-indentation*)
                 (format t "~&~vTToplevel Forms...~A~%"
                         *fcomp-indentation*
                         (if load-time
                           (if compile-time-too
                             "  (Compiletime, Loadtime)"
                             "")
                           (if compile-time-too
                             "  (Compiletime)"
                             "")))))))
    (fcomp-form-1 form env processing-mode)))

(defun fcomp-form-1 (form env processing-mode &aux sym body)
  (if (consp form) (setq sym (%car form) body (%cdr form)))
  (case sym
    (progn (fcomp-form-list body env processing-mode))
    (eval-when (fcomp-eval-when form env processing-mode))
    (compiler-let (fcomp-compiler-let form env processing-mode))
    (locally (fcomp-locally form env processing-mode))
    (macrolet (fcomp-macrolet form env processing-mode))
    (symbol-macrolet (fcomp-symbol-macrolet form env processing-mode))
    ((%include include) (fcomp-include form env processing-mode))
    (t
     ;;Need to macroexpand to see if get more progn's/eval-when's and so should
     ;;stay at toplevel.  But don't expand if either the evaluator or the
     ;;compiler might not - better safe than sorry... 
     ;; Good advice, but the hard part is knowing which is which.
     (cond 
       ((and (non-nil-symbol-p sym)
             (macro-function sym env)
             (not (compiler-macro-function sym env))
             (not (eq sym '%defvar-init)) ;  a macro that we want to special-case
             (multiple-value-bind (new win) (fcomp-macroexpand-1 form env)
               (if win (setq form new))
               win))
        (fcomp-form form env processing-mode))
       ((and (not *fcomp-inside-eval-always*)
             (memq sym *fcomp-eval-always-functions*))
        (let* ((*fcomp-inside-eval-always* t)
               (new `(eval-when (:execute :compile-toplevel :load-toplevel) ,form)))
          (fcomp-form-1 new env processing-mode)))
       (t
        (when (or (eq processing-mode :compile-time) (eq processing-mode :compile-time-too))
          (%compile-time-eval form env))
        (when (and processing-mode (neq processing-mode :compile-time))
          (case sym
            ((%defconstant) (fcomp-load-%defconstant form env))
            ((%defparameter) (fcomp-load-%defparameter form env))
            ((%defvar %defvar-init) (fcomp-load-defvar form env))
            ((%defun) (fcomp-load-%defun form env))
            ((set-package %define-package)
             (fcomp-random-toplevel-form form env)
             (fcomp-compile-toplevel-forms env))
            ((%macro) (fcomp-load-%macro form env))
            ;; ((%deftype) (fcomp-load-%deftype form))
            ;; ((define-setf-method) (fcomp-load-define-setf-method form))
            (t (fcomp-random-toplevel-form form env)))))))))

(defun fcomp-form-list (forms env processing-mode)
  (let* ((outer *loading-toplevel-location*))
    (dolist (form forms)
      (setq *loading-toplevel-location* (or (fcomp-source-note form) outer))
      (fcomp-form form env processing-mode))
    (setq *loading-toplevel-location* outer)))

(defun fcomp-compiler-let (form env processing-mode &aux vars varinits (body (%cdr form)))
  (fcomp-compile-toplevel-forms env)
  (dolist (pair (car body))
    (push (nx-pair-name pair) vars)
    (push (%compile-time-eval (nx-pair-initform pair) env) varinits))
  (progv (nreverse vars) (nreverse varinits)
    (fcomp-form-list (cdr body) env processing-mode)
    (fcomp-compile-toplevel-forms env)))

(defun fcomp-locally (form env processing-mode &aux (body (%cdr form)))
  (fcomp-compile-toplevel-forms env)
  (multiple-value-bind (body decls) (parse-body body env)
    (let* ((decl-specs (decl-specs-from-declarations decls))
           (env (augment-environment env :declare decl-specs))
           (*fasl-compile-time-env* (augment-environment *fasl-compile-time-env*
                                                         :declare decl-specs)))
      (fcomp-form-list body env processing-mode)
      (fcomp-compile-toplevel-forms env))))

(defun fcomp-macrolet (form env processing-mode &aux (body (%cdr form)))
  (fcomp-compile-toplevel-forms env)
  (flet ((augment-with-macros (e defs)
           (augment-environment e
                                :macro
                                (mapcar #'(lambda (m)
                                            (destructuring-bind (name arglist &body body) m
                                              (list name (enclose (parse-macro name arglist body env)
                                                                  e))))
                                        defs))))
           
    (let* ((macros (car body))
           (outer-env (augment-with-macros env macros)))
      (multiple-value-bind (body decls) (parse-body (cdr body) outer-env)
        (let* ((decl-specs (decl-specs-from-declarations decls))
               (env (augment-environment 
                     outer-env
                     :declare decl-specs))
               (*fasl-compile-time-env* (augment-environment
                                         (augment-with-macros
                                          *fasl-compile-time-env*
                                          macros)
                                         :declare decl-specs)))
          (fcomp-form-list body env processing-mode)
          (fcomp-compile-toplevel-forms env))))))

(defun fcomp-symbol-macrolet (form env processing-mode &aux (body (%cdr form)))
  (fcomp-compile-toplevel-forms env)
  (let* ((defs (car body))
         (outer-env (augment-environment env :symbol-macro defs)))
    (multiple-value-bind (body decls) (parse-body (cdr body) env)
      (let* ((decl-specs (decl-specs-from-declarations decls))
             (env (augment-environment outer-env 
                                       :declare decl-specs))
             (*fasl-compile-time-env* (augment-environment *fasl-compile-time-env*
                                                           :symbol-macro defs
                                                           :declare decl-specs)))
        (fcomp-form-list body env processing-mode)
        (fcomp-compile-toplevel-forms env)))))

(defun fcomp-eval-when (form env processing-mode &aux (body (%cdr form)) (eval-times (pop body)))
  (let* ((compile-time-too  (eq processing-mode :compile-time-too))
         (compile-time-only (eq processing-mode :compile-time))
         (at-compile-time nil)
         (at-load-time nil)
         (at-eval-time nil))
    (dolist (when eval-times)
      (if (or (eq when 'compile) (eq when :compile-toplevel))
        (setq at-compile-time t)
        (if (or (eq when 'eval) (eq when :execute))
          (setq at-eval-time t)
          (if (or (eq when 'load) (eq when :load-toplevel))
            (setq at-load-time t)
            (warn "Unknown EVAL-WHEN time ~s in ~S while compiling ~S."
                  when eval-times *fasl-source-file*)))))
    (fcomp-compile-toplevel-forms env)        ; always flush the suckers
    (cond (compile-time-only
           (if at-eval-time (fcomp-form-list body env :compile-time)))
          (at-load-time
           (fcomp-form-list body env (if (or at-compile-time (and at-eval-time compile-time-too))
                                       :compile-time-too
                                       :not-compile-time)))
          ((or at-compile-time (and at-eval-time compile-time-too))
           (fcomp-form-list body env :compile-time))))
  (fcomp-compile-toplevel-forms env))

(defun fcomp-include (form env processing-mode &aux file)
  (fcomp-compile-toplevel-forms env)
  (verify-arg-count form 1 1)
  (setq file (nx-transform (%cadr form) env))
  (unless (constantp file) (report-bad-arg file '(or string pathname)))
  (let ((actual (merge-pathnames (eval-constant file)
                                 (directory-namestring *compiling-file*))))
    (when *compile-print* (format t "~&~vTIncluding file ~A~%" *fcomp-indentation* actual))
    (let ((*fcomp-indentation* (+ 4 *fcomp-indentation*))
          (*package* *package*))
      (fcomp-read-loop (fcomp-find-file actual) actual 0 env processing-mode)
      (fcomp-output-form $fasl-src env *loading-file-source-file*))
    (when *compile-print* (format t "~&~vTFinished included file ~A~%" *fcomp-indentation* actual))))

(defun define-compile-time-constant (symbol initform env)
  (note-variable-info symbol t env)
  (let ((compile-time-defenv (definition-environment *fasl-compile-time-env*))
        (definition-env (definition-environment env)))
    (when (or compile-time-defenv definition-env)
      (multiple-value-bind (value error) 
                           (ignore-errors (values (%compile-time-eval initform env) nil))
        (when error
          (warn "Compile-time evaluation of DEFCONSTANT initial value form for ~S while ~
                 compiling ~S signalled the error: ~&~A" symbol *fasl-source-file* error))
        (let ((cell (cons symbol (if error (%unbound-marker-8) value))))
          (when definition-env
            (push cell (defenv.constants definition-env)))
          (when compile-time-defenv
            (push cell (defenv.constants compile-time-defenv))))))
    symbol))

(defun fcomp-load-%defconstant (form env)
  (destructuring-bind (sym valform &optional doc) (cdr form)
    (unless *fasl-save-doc-strings*
      (setq doc nil))
    (if (quoted-form-p sym)
      (setq sym (%cadr sym)))
    (if (and (typep sym 'symbol) (or (quoted-form-p valform) (self-evaluating-p valform)))
      (fcomp-output-form $fasl-defconstant env sym (eval-constant valform) (eval-constant doc))
      (fcomp-random-toplevel-form form env))))

(defun fcomp-load-%defparameter (form env)
  (destructuring-bind (sym valform &optional doc) (cdr form)
    (unless *fasl-save-doc-strings*
      (setq doc nil))
    (if (quoted-form-p sym)
      (setq sym (%cadr sym)))
    (let* ((sym-p (typep sym 'symbol))
           (fn (and sym-p (fcomp-function-arg valform env))))
      (if (and sym-p (or fn (constantp valform)))
        (fcomp-output-form $fasl-defparameter env sym (or fn (eval-constant valform)) (eval-constant doc))
        (fcomp-random-toplevel-form form env)))))

; Both the simple %DEFVAR and the initial-value case (%DEFVAR-INIT) come here.
; Only try to dump this as a special fasl operator if the initform is missing
;  or is "harmless" to evaluate whether needed or not (constant or function.)
; Hairier initforms could be handled by another fasl operator that takes a thunk
; and conditionally calls it.
(defun fcomp-load-defvar (form env)
  (destructuring-bind (sym &optional (valform nil val-p) doc) (cdr form)
    (unless *fasl-save-doc-strings*
      (setq doc nil))
    (if (quoted-form-p sym)             ; %defvar quotes its arg, %defvar-init doesn't.
      (setq sym (%cadr sym)))
    (let* ((sym-p (typep sym 'symbol)))
      (if (and sym-p (not val-p))
        (fcomp-output-form $fasl-defvar env sym)
        (let* ((fn (if sym-p (fcomp-function-arg valform env))))
          (if (and sym-p (or fn (constantp valform)))
            (fcomp-output-form $fasl-defvar-init env sym (or fn (eval-constant valform)) (eval-constant doc))
            (fcomp-random-toplevel-form form env)))))))
      
(defun define-compile-time-macro (name lambda-expression env)
  (let ((compile-time-defenv (definition-environment *fasl-compile-time-env*))
        (definition-env (definition-environment env)))
    (when (or definition-env compile-time-defenv)
      (let ((cell (list* name 
                         'macro 
                         (compile-named-function lambda-expression :name name :env env))))
        (when compile-time-defenv
          (push cell (defenv.functions compile-time-defenv)))
        (when definition-env
          (push cell (defenv.functions definition-env))))
      (record-function-info name (%cons-def-info 'defmacro) env))
    name))

(defun define-compile-time-symbol-macro (name expansion env)
  (let ((compile-time-defenv (definition-environment *fasl-compile-time-env*))
        (definition-env (definition-environment env)))
    (let* ((info (variable-information name env)))
      (when (or (eq info :special)
                (eq info :constant))
        (signal-program-error "Can't define ~s as a symbol-macro; already defined as a ~a." name (string-downcase info))))
    (when (or definition-env compile-time-defenv)
      (let ((cell (cons name expansion)))
        (when compile-time-defenv
          (push cell (defenv.symbol-macros compile-time-defenv)))
        (when definition-env
          (push cell (defenv.symbol-macros definition-env)))))
    name))


(defun fcomp-proclaim-type (type syms env)
  (if (every #'symbolp syms)
    (progn
      (specifier-type-if-known type env :whine t)
      (dolist (sym syms)
        (push (cons sym type) *nx-compile-time-types*)))
    (nx-bad-decls `(,type ,@syms))))

(defun compile-time-proclamation (specs env &aux  sym (defenv (definition-environment env)))
  (when defenv
    (dolist (spec specs)
      (setq sym (pop spec))
      (case sym
        (type
         (fcomp-proclaim-type (car spec) (cdr spec) env))
        (special
         (if (every #'symbolp spec)
           (dolist (sym spec)
             (push (cons sym nil) (defenv.specials defenv)))
           (nx-bad-decls `(,sym ,@spec))))
        (notspecial
         (if (every #'symbolp spec)
           (let ((specials (defenv.specials defenv)))
             (dolist (sym spec (setf (defenv.specials defenv) specials))
               (let ((pair (assq sym specials)))
                 (when pair (setq specials (nremove pair specials))))))
           (nx-bad-decls `(,sym ,@spec))))
        (optimize
           (handler-case (%proclaim-optimize spec)
             (program-error () (nx-bad-decls `(,sym ,@spec)))))
        (inline
         (if (every (lambda (v) (or (symbolp v) (setf-function-name-p v))) spec)
           (dolist (sym spec)
             (push (cons (maybe-setf-function-name sym) (cons 'inline 'inline)) (lexenv.fdecls defenv)))
           (nx-bad-decls `(,sym ,@spec))))
        (notinline
         (if (every (lambda (v) (or (symbolp v) (setf-function-name-p v))) spec)
           (dolist (sym spec)
             (unless (compiler-special-form-p sym)
               (push (cons (maybe-setf-function-name sym) (cons 'inline 'notinline)) (lexenv.fdecls defenv))))
           (nx-bad-decls `(,sym ,@spec))))
        (declaration
         (if (every #'symbolp spec)
           (dolist (sym spec)
             (pushnew sym *nx-known-declarations*))
           (nx-bad-decls `(,sym ,@spec))))
        (ignore
         (if (every #'symbolp spec)
           (dolist (sym spec)
             (push (cons sym t) *nx-proclaimed-ignore*))
           (nx-bad-decls `(,sym ,@spec))))
        (unignore
         (if (every #'symbolp spec)
           (dolist (sym spec)
             (push (cons sym nil) *nx-proclaimed-ignore*))
           (nx-bad-decls `(,sym ,@spec))))
        (ftype 
         (let ((ftype (car spec))
               (fnames (cdr spec)))
           (if (every (lambda (v) (or (symbolp v) (setf-function-name-p v))) fnames)
             (when (specifier-type-if-known ftype env :whine t)
               ;; ----- this part may be redundant, now that the lexenv.fdecls part is being done
               (if (and (consp ftype)
                        (consp fnames)
                        (eq (%car ftype) 'function))
                 (dolist (fname fnames)
                   (note-function-info fname nil env)))
               (dolist (fname fnames)
                 (push (list* (maybe-setf-function-name fname) sym ftype) (lexenv.fdecls defenv))))
             (nx-bad-decls `(ftype ,@spec)))))
        (otherwise
	 (unless (memq sym *nx-known-declarations*)
	   ;; Any type name is now (ANSI CL) a valid declaration.
	   (if (specifier-type-if-known sym env)
	     (fcomp-proclaim-type sym spec env)
	     (nx-bad-decls `(,sym ,@spec)))))))))

(defun fcomp-load-%defun (form env)
  (destructuring-bind (fn &optional doc) (cdr form)
    (unless *fasl-save-doc-strings*
      (if (consp doc)
        (if (and (eq (car doc) 'quote) (consp (cadr doc)))
          (setf (car (cadr doc)) nil))
        (setq doc nil)))
    (when (and (consp fn) (eq (%car fn) 'nfunction))
      (note-function-info (cadr fn) (caddr fn) env))
    (if (and (constantp doc)
             (setq fn (fcomp-function-arg fn env)))
      (progn
        (setq doc (eval-constant doc))
        (fcomp-output-form $fasl-defun env fn doc))
      (fcomp-random-toplevel-form form env))))

(defun fcomp-load-%macro (form env &aux fn doc)
  (verify-arg-count form 1 2)
  (if (and (constantp (setq doc (caddr form)))
           (setq fn (fcomp-function-arg (cadr form) env)))
    (progn
      (setq doc (eval-constant doc))
      (fcomp-output-form $fasl-macro env fn doc))
    (fcomp-random-toplevel-form form env)))

(defun define-compile-time-structure (sd refnames predicate env)
  (let ((defenv (definition-environment env))
        (class-name (and (not (sd-type sd)) (symbolp (sd-name sd)) (sd-name sd))))
    (when defenv
      (when class-name
	(note-type-info class-name 'class env)
        (push (make-instance 'compile-time-class :name class-name)
              (defenv.classes defenv)))
      (setf (defenv.structures defenv) (alist-adjoin (sd-name sd) sd (defenv.structures defenv)))
      (let* ((structrefs (defenv.structrefs defenv)))
        (when (and predicate class-name)
          (setq structrefs (alist-adjoin predicate class-name structrefs)))
        (dolist (slot (sd-slots sd))
	  (cond
	    ((fixnump (ssd-name slot)))	;skip
	    ((ssd-inherited slot)
	     (when refnames (pop refnames)))
	    (t
	     (setq structrefs
		   ;; structrefs isn't a proper alist
		   (alist-adjoin (if refnames (pop refnames) (ssd-name slot))
				 (cons (ssd-type-and-refinfo slot) class-name)
				 structrefs)))))
        (setf (defenv.structrefs defenv) structrefs)))))

(defun fcomp-source-note (form &aux (notes *fcomp-source-note-map*))
  (and notes (gethash form notes)))

(defun (setf fcomp-source-note) (note form &aux (notes *fcomp-source-note-map*))
  (and notes (setf (gethash form notes) note)))

(defun fcomp-note-source-transformation (original new)
  (let* ((*nx-source-note-map* *fcomp-source-note-map*))
    (nx-note-source-transformation original new)))

(defun fcomp-macroexpand-1 (form env)
  (handler-bind ((warning (lambda (c)
                            (nx1-whine :program-error c)
                            (muffle-warning c)))
                 (program-error (lambda (c)
                                  (if *fasl-break-on-program-errors*
                                    (cerror "continue compilation ignoring this form" c)
                                    (progn
                                      (when (typep c 'compile-time-program-error)
                                        (setq c (make-condition 'simple-program-error
                                                  :format-control (simple-condition-format-control c)
                                                  :format-arguments (simple-condition-format-arguments c))))
                                      (nx1-whine :program-error c)))
                                  (return-from fcomp-macroexpand-1 (values nil t)))))
    (let* ((*nx-source-note-map* *fcomp-source-note-map*))
      (multiple-value-bind (new win)
          (macroexpand-1 form env)
        (when win
          (nx-note-source-transformation form new))
        (values new win)))))

(defun fcomp-transform (form env)
  (let* ((*nx-source-note-map* *fcomp-source-note-map*))
    (nx-transform form env)))


(defun fcomp-random-toplevel-form (form env)
  (unless (constantp form)
    (unless (or (atom form)
                (compiler-special-form-p (%car form)))
      ;;Pre-compile any lfun args.  This is an efficiency hack, since compiler
      ;;reentering itself for inner lambdas tends to be more expensive than
      ;;top-level compiles.
      ;;This assumes the form has been macroexpanded, or at least none of the
      ;;non-evaluated macro arguments could look like functions.
      (let ((new-form (make-list (length form))))
        (declare (dynamic-extent new-form))
        (loop for arg in (%cdr form) for newptr on (%cdr new-form)
              do (setf (%car newptr)
                       (multiple-value-bind (new win) (fcomp-transform arg env)
                         (let ((lfun (fcomp-function-arg new env)))
                           (when lfun
                             (setq new `',lfun win t)
                             (fcomp-note-source-transformation arg new)))
                         (if win new arg))))
        (unless (every #'eq (%cdr form) (%cdr new-form))
          (setf (%car new-form) (%car form))
          (fcomp-note-source-transformation form (setq form (copy-list new-form))))))
    ;; At some point we will dump the toplevel forms, make sure that when that happens,
    ;;; the loading location for this form is stored in *fcomp-loading-toplevel-location*,
    ;; because *loading-toplevel-location* will be long gone by then.
    (fcomp-ensure-source env)
    (push form *fcomp-toplevel-forms*)))

(defun fcomp-function-arg (expr env)
  (when (consp expr)
    (multiple-value-bind (lambda-expr name win)
        (cond ((and (eq (%car expr) 'nfunction)
                    (lambda-expression-p (cadr (%cdr expr))))
               (values (%caddr expr) (%cadr expr) t))
              ((and (eq (%car expr) 'function)
                    (lambda-expression-p (car (%cdr expr))))
               (values (%cadr expr) nil t)))
      (when win
        (fcomp-named-function lambda-expr name env
                              (or (fcomp-source-note expr)
                                  (fcomp-source-note lambda-expr)
                                  *loading-toplevel-location*))))))

(defun fcomp-compile-toplevel-forms (env)
  (when *fcomp-toplevel-forms*
    (let* ((forms (nreverse *fcomp-toplevel-forms*))
           (*fcomp-stream-position* *fcomp-previous-position*)
	   (*loading-toplevel-location* *fcomp-loading-toplevel-location*)
           (body (if T ;; (null (cdr forms))
                   `(progn ,@forms)
                   `(macrolet ((load-time-value (value)
                                 (declare (ignore value))
                                 (compiler-function-overflow)))
                      ,@forms)))
           (lambda `(lambda () ,body)))
      ;; Don't assign a location to the lambda so it doesn't confuse acode printing, but
      ;; arrange to assign it to any inner lambdas.
      (setf (fcomp-source-note body) *loading-toplevel-location*)
      (setq *fcomp-toplevel-forms* nil)
      ;(format t "~& Random toplevel form: ~s" lambda)
      (handler-case (fcomp-output-form
                     $fasl-lfuncall
                     env
                     (fcomp-named-function lambda nil env #|*loading-toplevel-location*|#))
        (compiler-function-overflow ()
          (if (null (cdr forms))
            (error "Form ~s cannot be compiled - size exceeds compiler limitation"
                   (%car forms))
            ; else compile each half :
            (progn
              (dotimes (i (floor (length forms) 2))
                (declare (fixnum i))
                (push (pop forms) *fcomp-toplevel-forms*))
              (fcomp-compile-toplevel-forms env)
              (setq *fcomp-toplevel-forms* (nreverse forms))
              (fcomp-compile-toplevel-forms env))))))))

(defun fcomp-ensure-source (env)
  ;; if source location saving is off, both values are NIL, so this will do nothing,
  ;; don't need to check explicitly.
  (unless (eq *fcomp-loading-toplevel-location* *loading-toplevel-location*)
    (fcomp-compile-toplevel-forms env)
    (setq *fcomp-loading-toplevel-location* *loading-toplevel-location*)
    (fcomp-output-form $fasl-toplevel-location env *loading-toplevel-location*)))

(defun fcomp-output-form (opcode env &rest args)
  (fcomp-ensure-source env)
  (when *fcomp-toplevel-forms* (fcomp-compile-toplevel-forms env))
  (push (cons opcode args) *fcomp-output-list*))


;;; Compile a lambda expression for the sole purpose of putting it in a fasl
;;; file.  The result will not be funcalled.  This really shouldn't bother
;;; making an lfun, but it's simpler this way...
(defun fcomp-named-function (def name env &optional source-note)
  (let* ((env (new-lexical-environment env))
         (*nx-break-on-program-errors* (not (memq *fasl-break-on-program-errors* '(nil :defer)))))
    (multiple-value-bind (lfun warnings)
        (compile-named-function def
                                :name name
                                :env env
                                :function-note source-note
                                :keep-lambda *fasl-save-definitions*
                                :keep-symbols *fasl-save-local-symbols*
                                :policy *default-file-compilation-policy*
                                :source-notes *fcomp-source-note-map*
                                :load-time-eval-token cfasl-load-time-eval-sym
                                :target *fasl-target*)
      (fcomp-signal-or-defer-warnings warnings env)
      lfun)))


;; Convert parent-notes to immediate indices.  The reason this is necessary is to avoid hitting
;; the fasdumper's 64K limit on multiply-referenced objects.  This removes the reference
;; from parent slots, making notes less likely to be multiply-referenced.
(defun fcomp-digest-code-notes (lfun &optional refs)
  (unless (memq lfun refs)
    (let ((source (function-source-note lfun)))
      (when (and (source-note-p source)
                 (not (equalp (source-note-filename source) *loading-file-source-file*)))
        ;; Function is from a different file than being compiled, so don't digest it.
        ;; This can happen when #. is used to create arbitrary literal constants.
        #+no (warn "Reference to non-externalizable literal ~s" lfun)
        (return-from fcomp-digest-code-notes)))
    (let* ((lfv (function-to-function-vector lfun))
	   (start #-x86-target 0 #+x86-target (%function-code-words lfun))
	   (refs (cons lfun refs)))
      (declare (dynamic-extent refs))
      (loop for i from start below (uvsize lfv) as imm = (uvref lfv i)
	    do (typecase imm
		 (code-note
		  (let* ((parent (code-note-parent-note imm))
			 (pos (when (code-note-p parent)
				(loop for j from start below i
				      do (when (eq parent (uvref lfv j)) (return j))))))
		    (when pos
		      (setf (code-note-parent-note imm) pos))))
		 (function
		  (fcomp-digest-code-notes imm refs)))))))

; For now, defer only UNDEFINED-REFERENCEs, signal all others via WARN.
; Well, maybe not WARN, exactly.
(defun fcomp-signal-or-defer-warnings (warnings env)
  (let ((init (null *fcomp-warnings-header*))
        (some *fasl-warnings-signalled-p*)
        (harsh *fasl-non-style-warnings-signalled-p*))
    (dolist (w warnings)
      (when (and (not (compiler-warning-source-note w)) *fcomp-stream-position*)
        (setf (compiler-warning-source-note w)
              (make-source-note :source nil
                                :filename *fasl-source-file*
                                :start-pos *fcomp-stream-position*
                                :end-pos *fcomp-stream-position*)))
      (if (and (typep w 'undefined-reference) 
               (eq w (setq w (macro-too-late-p w env))))
        (push w *fasl-deferred-warnings*)
        (progn
          (multiple-value-setq (harsh some *fcomp-warnings-header*)
                               (signal-compiler-warning w init *fcomp-warnings-header* harsh some))
          (setq init nil))))
    (setq *fasl-warnings-signalled-p* some
          *fasl-non-style-warnings-signalled-p* harsh)))

; If W is an UNDEFINED-FUNCTION-REFERENCE which refers to a macro (either at compile-time in ENV
; or globally), cons up a MACRO-USED-BEFORE-DEFINITION warning and return it; else return W.

(defun macro-too-late-p (w env)
  (let* ((args (compiler-warning-args w))
         (name (car args)))
    (if (typep w 'undefined-function-reference)
      (if (or (macro-function name)
	      (let* ((defenv (definition-environment env))
		     (info (if defenv (assq name (defenv.functions defenv)))))
		(and (consp (cdr info))
		     (eq 'macro (cadr info)))))
	  (make-instance 'macro-used-before-definition
	    :source-note (compiler-warning-source-note w)
	    :function-name (compiler-warning-function-name w)
	    :warning-type ':macro-used-before-definition
	    :args args)
	  w)
      w)))


              
;;;;          fasl-scan - dumping reference counting
;;;;
;;;;
;These should be constants, but it's too much trouble when need to change 'em.
(defparameter FASL-FILE-ID #xFF00)  ;Overall file format, shouldn't change much

(defvar *fasdump-hash*)
(defvar *fasdump-read-package*)
(defvar *fasdump-global-offsets*)
(defvar *make-load-form-hash*)

;;;Return a hash table containing subexp's which are referenced more than once.
(defun fasl-scan (forms)
  (let* ((*fasdump-hash* (make-hash-table :size (length forms)          ; Crude estimate
                                          :rehash-threshold 0.9
                                          :test 'eq
					  :shared nil))
         (*make-load-form-hash* (make-hash-table :test 'eq :shared nil))
         (*fasdump-read-package* nil)
         (*fasdump-global-offsets* nil)
         (gsymbols nil))
    (dolist (op forms)
      (if (packagep op) ; old magic treatment of *package*
        (setq *fasdump-read-package* op)
        (dolist (arg (cdr op)) (fasl-scan-form arg))))

    #-bccl (when (eq *compile-verbose* :debug)
             (format t "~&~S forms, ~S entries -> "
                     (length forms)
                     (hash-table-count *fasdump-hash*)))
    (maphash #'(lambda (key val)
                 (when (%izerop val) (remhash key *fasdump-hash*)))
             *fasdump-hash*)
    #-bccl (when (eq *compile-verbose* :debug)
             (format t "~S." (hash-table-count *fasdump-hash*)))
    (values *fasdump-hash*
            gsymbols
            *fasdump-global-offsets*)))

;;; During scanning, *fasdump-hash* values are one of the following:
;;;  nil - form hasn't been referenced yet.
;;;   0 - form has been referenced exactly once
;;;   T - form has been referenced more than once
;;;  (load-form scanning-p referenced-p initform)
;;;     form should be replaced by load-form
;;;     scanning-p is true while we're scanning load-form
;;;     referenced-p is nil if unreferenced,
;;;                     T if referenced but not dumped yet,
;;;                     0 if dumped already (fasl-dump-form uses this)
;;;     initform is a compiled version of the user's initform
(defun fasl-scan-form (form)
  (when form
    (let ((info (gethash form *fasdump-hash*)))
      (cond ((null info)
             (fasl-scan-dispatch form))
            ((eql info 0)
             (puthash form *fasdump-hash* t))
            ((listp info)               ; a make-load-form form
             (when (cadr info)
               (error "Circularity in ~S for ~S" 'make-load-form form))
             (let ((referenced-cell (cddr info)))
               (setf (car referenced-cell) t)   ; referenced-p
               (setf (gethash (car info) *fasdump-hash*) t)))))))




(defun fasl-scan-dispatch (exp)
  (when exp
    (let ((type-code (typecode exp)))
      (declare (fixnum type-code))
      (case type-code
        (#.target::tag-fixnum
         (fasl-scan-fixnum exp))
        (#+ppc64-target #.target::fulltag-cons
         #-ppc64-target #.target::tag-list (fasl-scan-list exp))
        #+ppc32-target
        (#.ppc32::tag-imm)
        #+ppc64-target
        ((#.ppc64::fulltag-imm-0
          #.ppc64::fulltag-imm-1
          #.ppc64::fulltag-imm-2
          #.ppc64::fulltag-imm-3))
	#+x8632-target
	(#.x8632::tag-imm)
        #+x8664-target
        ((#.x8664::fulltag-imm-0
          #.x8664::fulltag-imm-1))
        #+arm-target
        (#.arm::tag-imm)
        (t
         (if
           #+ppc32-target
           (= (the fixnum (logand type-code ppc32::full-tag-mask)) ppc32::fulltag-immheader)
           #+ppc64-target
           (= (the fixnum (logand type-code ppc64::lowtagmask)) ppc64::lowtag-immheader)
	   #+x8632-target
	   (= (the fixnum (logand type-code x8632::fulltagmask)) x8632::fulltag-immheader)
           #+x8664-target
           (and (= (the fixnum (lisptag exp)) x8664::tag-misc)
                (logbitp (the (unsigned-byte 16) (logand type-code x8664::fulltagmask))
                         (logior (ash 1 x8664::fulltag-immheader-0)
                                 (ash 1 x8664::fulltag-immheader-1)
                                 (ash 1 x8664::fulltag-immheader-2))))
           #+arm-target
           (= (the fixnum (logand type-code arm::fulltagmask)) arm::fulltag-immheader)
           (case type-code
             (#.target::subtag-dead-macptr (fasl-unknown exp))
             (#.target::subtag-macptr
              ;; Treat untyped pointers to the high/low 64K of the address
              ;; space as constants.  Refuse to dump other pointers.
              (unless (and (zerop (%macptr-type exp))
                           (<= (%macptr-domain exp) 1))
                (error "Can't dump typed pointer ~s" exp))
              (let* ((addr (%ptr-to-int exp)))
                (unless (or (< addr #x10000)
                            (>= addr (- (ash 1 target::nbits-in-word)
                                        #x10000)))
                  (error "Can't dump pointer ~s : address is not in the low or high 64K of the address space." exp))))
             (t (fasl-scan-ref exp)))
           (case type-code
             ((#.target::subtag-pool #.target::subtag-weak #.target::subtag-lock) (fasl-unknown exp))
             (#+ppc-target #.target::subtag-symbol
              #+x8632-target #.target::subtag-symbol
              #+x8664-target #.target::tag-symbol
              #+arm-target #.target::subtag-symbol (fasl-scan-symbol exp))
             ((#.target::subtag-instance #.target::subtag-struct)
              (fasl-scan-user-form exp))
             (#.target::subtag-package (fasl-scan-ref exp))
             (#.target::subtag-istruct
              (if (memq (istruct-type-name exp) *istruct-make-load-form-types*)
                (progn
                  (if (hash-table-p exp)
                    (fasl-lock-hash-table exp))
                  (fasl-scan-user-form exp))
                (fasl-scan-gvector exp)))
	     #+x8632-target
	     (#.target::subtag-function (fasl-scan-clfun exp))
             #+x8664-target
             (#.target::tag-function (fasl-scan-clfun exp))
             (t (fasl-scan-gvector exp)))))))))
              

(defun fasl-scan-ref (form)
  (puthash form *fasdump-hash* 0))

(defun fasl-scan-fixnum (fixnum)
  (unless (short-fixnum-p fixnum) (fasl-scan-ref fixnum)))

(defparameter *istruct-make-load-form-types*
  '(lexical-environment shared-library-descriptor shared-library-entry-point
    external-entry-point foreign-variable
    ctype unknown-ctype class-ctype foreign-ctype union-ctype member-ctype 
    array-ctype numeric-ctype hairy-ctype named-ctype constant-ctype args-ctype
    hash-table package-ref type-cell class-cell slot-id))




(defun fasl-scan-gvector (vec)
  (fasl-scan-ref vec)
  (dotimes (i (uvsize vec)) 
    (declare (fixnum i))
    (fasl-scan-form (%svref vec i))))

#+x86-target
(defun fasl-scan-clfun (f)
  (let* ((fv (function-to-function-vector f))
         (size (uvsize fv))
         (ncode-words (%function-code-words f)))
    (fasl-scan-ref f)
    (do* ((k ncode-words (1+ k)))
         ((= k size))
      (fasl-scan-form (uvref fv k)))))

(defun funcall-lfun-p (form)
  (and (listp form)
       (eq (%car form) 'funcall)
       (listp (%cdr form))
       (or (functionp (%cadr form))
           (eql (typecode (%cadr form)) target::subtag-xfunction))
       (null (%cddr form))))

;;; We currently represent istruct-cells as conses.  That's not
;;; incredibly efficient (among other things, we have to do this
;;; check when scanning/dumping any list), but it's probably not
;;; worth burning a tag on them.  There are currently about 50
;;; entries on the *istruct-cells* list.
(defun istruct-cell-p (x)
  (and (consp x)
       (typep (%car x) 'symbol)
       (atom (%cdr x))
       (not (null (memq x *istruct-cells*)))))

(defun fasl-scan-list (list)
  (cond ((eq (%car list) cfasl-load-time-eval-sym)
         (let ((form (car (%cdr list))))
           (fasl-scan-form (if (funcall-lfun-p form)
                             (%cadr form)
                             form))))
        ((istruct-cell-p list)
         (fasl-scan-form (%car list)))
        (t (when list
             (fasl-scan-ref list)
             (fasl-scan-form (%car list))
             (fasl-scan-form (%cdr list))))))

(defun fasl-scan-user-form (form)
  (when (or (source-note-p form)
            (code-note-p form))
    (return-from fasl-scan-user-form (fasl-scan-gvector form)))
  (multiple-value-bind (load-form init-form) (make-load-form form *fcomp-load-forms-environment*)
    (labels ((simple-load-form (form)
               (or (atom form)
                   (let ((function (car form)))
                     (or (eq function 'quote)
                         (and (symbolp function)
                              ;; using fboundp instead of symbol-function
                              ;; see comments in symbol-function
                              (or (functionp (fboundp function))
                                  (eq function 'progn))
                              ;; (every #'simple-load-form (cdr form))
                              (dolist (arg (cdr form) t)
                                (unless (simple-load-form arg)
                                  (return nil))))))))
             (load-time-eval-form (load-form form type)
               (cond ((quoted-form-p load-form)
                      (%cadr load-form))
                     ((self-evaluating-p load-form)
                      load-form)
                     ((simple-load-form load-form)
                      `(,cfasl-load-time-eval-sym ,load-form))
                     (t (multiple-value-bind (lfun warnings)
                                             (or
                                              (gethash load-form *make-load-form-hash*)
                                              (fcomp-named-function `(lambda () ,load-form) nil nil))
                          (when warnings
                            (cerror "Ignore the warnings"
                                    "Compiling the ~s ~a form for~%~s~%produced warnings."
                                    'make-load-form type form))
                          (setf (gethash load-form *make-load-form-hash*) lfun)
                          `(,cfasl-load-time-eval-sym (funcall ,lfun)))))))
      (declare (dynamic-extent #'simple-load-form #'load-time-eval-form))
      (let* ((compiled-initform
              (and init-form (load-time-eval-form init-form form "initialization")))
             (info (list (load-time-eval-form load-form form "creation")
                         T              ; scanning-p
                         nil            ; referenced-p
                         compiled-initform  ;initform-info
                         )))
        (puthash form *fasdump-hash* info)
        (fasl-scan-form (%car info))
        (setf (cadr info) nil)        ; no longer scanning load-form
        (when init-form
          (fasl-scan-form compiled-initform))))))

(defun fasl-setf-name-inverse-p (sym &optional create)
  (or (cdr (assoc sym *fasl-setf-name-alias-alist*))
      (and create
           (let* ((pname (symbol-name sym))
                  (namelen (length pname))
                  (setf-for 
                   (and (> namelen 2)
                        (eql (schar pname 0) #\()
                        (eql (schar pname (1- namelen)) #\))
                        (gethash sym %setf-function-name-inverses%))))
           (when setf-for
             (let* ((list `(,cfasl-load-time-eval-sym (setf-function-name ',setf-for))))
               (fasl-scan-list list)
               (push (cons sym list) *fasl-setf-name-alias-alist*)
               list))))))
  
(defun fasl-scan-symbol (form)
  (unless (fasl-setf-name-inverse-p form t)
    (fasl-scan-ref form)
    (fasl-scan-form (symbol-package form))))
  


;;;;          Pass 3 - dumping
;;;;
;;;;
(defvar *fasdump-epush*)
(defvar *fasdump-stream*)
(defvar *fasdump-eref*)

(defun fasl-dump-file (gnames goffsets forms hash filename)
  (let ((opened? nil)
        (finished? nil))
    (unwind-protect
      (with-open-file (*fasdump-stream* filename :direction :output
                                        :element-type '(unsigned-byte 8)
                                        :if-exists :supersede
                                        :if-does-not-exist :create)
        (setq opened? t)
        (fasl-set-filepos 0)
        (fasl-out-word 0)             ;Will become the ID word
        (fasl-out-word 1)             ;One block in the file
        (fasl-out-long 12)            ;Block starts at file pos 12
        (fasl-out-long 0)             ;Length will go here
        (fasl-dump-block gnames goffsets forms hash)  ;Write the block
        (let ((pos (fasl-filepos)))
          (fasl-set-filepos 8)        ;Back to length longword
          (fasl-out-long (- pos 12))) ;Write length
        (fasl-set-filepos 0)          ;Seem to have won, make us legal
        (fasl-out-word FASL-FILE-ID)
        (setq finished? t)
        filename)
      (when (and opened? (not finished?))
        (delete-file filename)))))

(defun target-symbol-value (name)  
  (let* ((package (arch::target-package-name (backend-target-arch *target-backend*)))
         (sym (find-symbol name package)))
    (unless (and sym (boundp sym))
      (error "~a not defined in target package ~s." name package))
    (logior #xff00 (logand #xff (symbol-value sym)))))

;;; This is an exported, public interface.
(defun target-fasl-version ()
  (target-symbol-value "FASL-VERSION"))

;; Redefine the versions of these functions used by the fasloader.

(defun target-fasl-min-version ()
  (target-symbol-value "FASL-MIN-VERSION"))

(defun target-fasl-max-version ()
  (target-symbol-value "FASL-MAX-VERSION"))

(defun fasl-dump-block (gnames goffsets forms hash)
  (let ((etab-size (hash-table-count hash)))
    (fasl-out-word (target-fasl-version))          ; Word 0
    (fasl-out-long  0)
    (fasl-out-byte $fasl-vetab-alloc)
    (fasl-out-count etab-size)
    (fasl-dump gnames goffsets forms hash)
    (fasl-out-byte $fasl-end)))

(defun fasl-dump (gnames goffsets forms hash)
  (let* ((*fasdump-hash* hash)
         (*fasdump-read-package* nil)
         (*fasdump-epush* nil)
         (*fasdump-eref* -1)
         (*fasdump-global-offsets* goffsets))
    (when gnames
      (fasl-out-byte $fasl-globals)
      (fasl-dump-form gnames))
    (dolist (op forms)
      (if (packagep op)
        (setq *fasdump-read-package* op)
        (progn
          (fasl-out-byte (car op))
          (dolist (arg (cdr op)) (fasl-dump-form arg)))))))

;;;During dumping, *fasdump-hash* values are one of the following:
;;;   nil - form has no load form, is referenced at most once.
;;;   fixnum - form has already been dumped, fixnum is the etab index.
;;;   T - form hasn't been dumped yet, is referenced more than once.
;;;  (load-form . nil) - form should be replaced by load-form.
(defun fasl-dump-form (form)
  (let ((info (gethash form *fasdump-hash*)))
    (cond ((fixnump info)
           (fasl-out-byte $fasl-veref)
           (fasl-out-count info))
          ((consp info)
           (fasl-dump-user-form form info))
          (t
           (setq *fasdump-epush* info)
           (fasl-dump-dispatch form)))))

(defun fasl-dump-user-form (form info)
  (let* ((load-form (car info))
         (referenced-p (caddr info))
         (initform (cadddr info)))
    (when referenced-p
      (unless (gethash load-form *fasdump-hash*)
        (error "~s was not in ~s.  This shouldn't happen." 'load-form '*fasdump-hash*)))
    (when initform
      (fasl-out-byte $fasl-prog1))      ; ignore the initform
    (fasl-dump-form load-form)
    (when referenced-p
      (setf (gethash form *fasdump-hash*) (gethash load-form *fasdump-hash*)))
    (when initform
      (fasl-dump-form initform))))

(defun fasl-out-opcode (opcode form)
  (if *fasdump-epush*
    (progn
      (setq *fasdump-epush* nil)
      (fasl-out-byte (fasl-epush-op opcode))
      (fasl-dump-epush form))
    (fasl-out-byte opcode)))

(defun fasl-dump-epush (form)
  #-bccl (when (fixnump (gethash form *fasdump-hash*))
           (error "Bug! Duplicate epush for ~S" form))
  (puthash form *fasdump-hash* (setq *fasdump-eref* (1+ *fasdump-eref*))))


(defun fasl-dump-dispatch (exp)
  (etypecase exp
    ((signed-byte 16) (fasl-dump-s16 exp))
    ((signed-byte 32) (fasl-dump-s32 exp))
    ((signed-byte 64) (fasl-dump-s64 exp))
    (bignum (fasl-dump-32-bit-ivector exp $fasl-bignum32))
    (character (fasl-dump-char exp))
    (list (fasl-dump-list exp))
    (immediate (fasl-dump-t_imm exp))
    (double-float (fasl-dump-dfloat exp))
    (single-float (fasl-dump-sfloat exp))
    (simple-string
     (let* ((nextra (utf-8-extra-bytes exp)))
       (cond ((= 0 nextra)
              (fasl-out-opcode $fasl-nvstr exp)
              (fasl-out-nvstring exp))
             (t (fasl-out-opcode $fasl-vstr exp)
                (fasl-out-vstring exp nextra)))))
    (simple-bit-vector (fasl-dump-bit-vector exp))
    ((simple-array (unsigned-byte 8) (*))
     (fasl-dump-8-bit-ivector exp $fasl-u8-vector))
    ((simple-array (signed-byte 8) (*))
     (fasl-dump-8-bit-ivector exp $fasl-s8-vector))
    ((simple-array (unsigned-byte 16) (*))
     (fasl-dump-16-bit-ivector exp $fasl-u16-vector))
    ((simple-array (signed-byte 16) (*))
     (fasl-dump-16-bit-ivector exp $fasl-s16-vector))
    ((simple-array (unsigned-byte 32) (*))
     (fasl-dump-32-bit-ivector exp $fasl-u32-vector))
    ((simple-array (signed-byte 32) (*))
     (fasl-dump-32-bit-ivector exp $fasl-s32-vector))
    ((simple-array single-float (*))
     (fasl-dump-32-bit-ivector exp $fasl-single-float-vector))
    ((simple-array double-float (*))
     (fasl-dump-double-float-vector exp))
    (symbol (fasl-dump-symbol exp))
    (package (fasl-dump-package exp))
    (function (fasl-dump-function exp))
    (xfunction (fasl-dump-function exp))
    (code-vector (fasl-dump-codevector exp))
    (xcode-vector (fasl-dump-codevector exp))
    (simple-vector (fasl-dump-gvector exp $fasl-t-vector))
    (ratio (fasl-dump-ratio exp))
    (complex (fasl-dump-complex exp))
    #+(and 64-bit-target (not cross-compiling))
    ((simple-array (unsigned-byte 64) (*))
     (fasl-dump-64-bit-ivector exp $fasl-u64-vector))
    #+(and 64-bit-target (not cross-compiling))
    ((simple-array (signed-byte 64) (*))
     (fasl-dump-64-bit-ivector exp $fasl-s64-vector))
    (ivector
     (unless (eq (backend-target-arch-name *target-backend*)
                 (backend-target-arch-name *host-backend*))
       (error "can't cross-compile constant reference to ~s" exp))
     (let* ((typecode (typecode exp))
            (n (uvsize exp))
            (nb (subtag-bytes typecode n)))
       (declare (fixnum n nb typecode))
       (fasl-out-opcode $fasl-vivec exp)
       (fasl-out-byte typecode)
       (fasl-out-count n)
       (fasl-out-ivect exp 0 nb)))
    (vector (fasl-dump-gvector exp $fasl-vector-header))
    (array (fasl-dump-gvector exp $fasl-array-header))

    (gvector
     (if (= (typecode exp) target::subtag-istruct)
       (fasl-dump-gvector exp $fasl-istruct)
       (progn
         (unless (eq (backend-target-arch-name *target-backend*)
                     (backend-target-arch-name *host-backend*))
           (error "can't cross-compile constant reference to ~s" exp))
         (let* ((typecode (typecode exp))
                (n (uvsize exp)))
           (declare (fixnum n typecode))
           (fasl-out-opcode $fasl-vgvec exp)
           (fasl-out-byte typecode)
           (fasl-out-count n)
           (dotimes (i n)
             (fasl-dump-form (%svref exp i)))))))))

(defun fasl-dump-gvector (v op)
  (let* ((n (uvsize v)))
    (fasl-out-opcode op v)
    (fasl-out-count n)
    (dotimes (i n)
      (fasl-dump-form (%svref v i)))))

(defun fasl-dump-ratio (v)
  (fasl-out-opcode $fasl-ratio v)
  (fasl-dump-form (%svref v target::ratio.numer-cell))
  (fasl-dump-form (%svref v target::ratio.denom-cell)))

(defun fasl-dump-complex (v)
  (fasl-out-opcode $fasl-complex v)  
  (fasl-dump-form (realpart v))
  (fasl-dump-form (imagpart v)))

(defun fasl-dump-bit-vector (v)
  (let* ((n (uvsize v)))
    (fasl-out-opcode $fasl-bit-vector v)
    (fasl-out-count n)
    (if (eq *fasl-host-big-endian* *fasl-target-big-endian*)
      (let* ((nb (ash (+ n 7) -3)))
        (fasl-out-ivect v 0 nb))
      (compiler-bug "need to byte-swap ~a" v))))

(defun fasl-dump-8-bit-ivector (v op)
  (let* ((n (uvsize v)))
    (fasl-out-opcode op v)
    (fasl-out-count n)
    (let* ((nb n))
      (fasl-out-ivect v 0 nb))))

(defun fasl-dump-16-bit-ivector (v op)
  (let* ((n (uvsize v)))
    (fasl-out-opcode op v)
    (fasl-out-count n)
    (if (eq *fasl-host-big-endian* *fasl-target-big-endian*)
      (let* ((nb (ash n 1)))
        (fasl-out-ivect v 0 nb))
      (dotimes (i n)
        (let* ((k (uvref v i)))
          (fasl-out-byte (ldb (byte 8 0) k))
          (fasl-out-byte (ldb (byte 8 8) k)))))))

(defun fasl-dump-32-bit-ivector (v op)
  (let* ((n (uvsize v)))
    (fasl-out-opcode op v)
    (fasl-out-count n)
    (if (eq *fasl-host-big-endian* *fasl-target-big-endian*)
      (let* ((nb (ash n 2)))
        (fasl-out-ivect v 0 nb))
      (dotimes (i n)
        (let* ((k (uvref v i)))
          (fasl-out-byte (ldb (byte 8 0) k))
          (fasl-out-byte (ldb (byte 8 8) k))
          (fasl-out-byte (ldb (byte 8 16) k))
          (fasl-out-byte (ldb (byte 8 24) k)))))))


(defun fasl-dump-64-bit-ivector (v op)
  (let* ((n (uvsize v)))
    (fasl-out-opcode op v)
    (fasl-out-count n)
    (if (eq *fasl-host-big-endian* *fasl-target-big-endian*)
      (let* ((nb (ash n 3)))
        (fasl-out-ivect v 0 nb))
      (compiler-bug "need to byte-swap ~a" v))))

(defun fasl-dump-double-float-vector (v)
  (let* ((n (uvsize v)))
    (fasl-out-opcode $fasl-double-float-vector v)
    (fasl-out-count n)
    (if (eq *fasl-host-big-endian* *fasl-target-big-endian*)
      (let* ((nb (ash n 3)))
        (fasl-out-ivect v (- target::misc-dfloat-offset
                             target::misc-data-offset) nb))
      (compiler-bug "need to byte-swap ~a" v))))

;;; This is used to dump functions and "xfunctions".
;;; If we're cross-compiling, we shouldn't reference any
;;; (host) functions as constants; try to detect that
;;; case.
#-x86-target
(defun fasl-dump-function (f)
  (if (and (not (eq *fasl-backend* *host-backend*))
           (typep f 'function))
    (compiler-bug "Dumping a native function constant ~s during cross-compilation." f))
  (if (and (= (typecode f) target::subtag-xfunction)
           (= (typecode (uvref f 0)) target::subtag-u8-vector))
    (fasl-xdump-clfun f)
    (let* ((n (uvsize f)))
      (fasl-out-opcode $fasl-function f)
      (fasl-out-count n)
      (dotimes (i n)
        (if (= i 0)
          (target-arch-case
           (:arm (fasl-dump-form 0))
           (t (fasl-dump-form (%svref f i))))
          (fasl-dump-form (%svref f i)))))))

#+x86-target
(defun fasl-dump-function (f)
  (if (and (not (eq *fasl-backend* *host-backend*))
           (typep f 'function))
    (compiler-bug "Dumping a native function constant ~s during cross-compilation." f))
  (if (and (= (typecode f) target::subtag-xfunction)
           (= (typecode (uvref f 0)) target::subtag-u8-vector))
    (fasl-xdump-clfun f)
    (if (= (typecode f) target::subtag-xfunction)
      (let* ((n (uvsize f)))
        (fasl-out-opcode $fasl-function f)
        (fasl-out-count n)
        (dotimes (i n)
          (fasl-dump-form (%svref f i))))        

      (let* ((code-size (%function-code-words f))
             (function-vector (function-to-function-vector f))
             (function-size (uvsize function-vector)))
        (fasl-out-opcode $fasl-clfun f)
        (fasl-out-count function-size)
        (fasl-out-count code-size)
        (fasl-out-ivect function-vector 0 (ash code-size target::word-shift))
        (do* ((k code-size (1+ k)))
             ((= k function-size))
          (declare (fixnum k))
          (fasl-dump-form (uvref function-vector k)))))))
        

  

;;; Write a "concatenated function".
(defun fasl-xdump-clfun (f)
  (target-arch-case
   (:x8632
    (let* ((code (uvref f 0))
	   (function-size (ash (uvsize code) -2))
	   (encoded-imm-words (dpb (uvref code 1) (byte 8 8) (uvref code 0)))
	   (imm-words (if (logbitp 15 encoded-imm-words)
			(- function-size (ldb (byte 15 0) encoded-imm-words))
			encoded-imm-words))
	   (imm-bytes (ash imm-words 2))
	   (other-words (- function-size imm-words)))
      (assert (= other-words (1- (uvsize f))))
      (fasl-out-opcode $fasl-clfun f)
      (fasl-out-count function-size)
      (fasl-out-count imm-words)
      (fasl-out-ivect code 0 imm-bytes)
      (do ((i 1 (1+ i))
	   (n (uvsize f)))
	  ((= i n))
	(declare (fixnum i n))
	(fasl-dump-form (%svref f i)))))
   (:x8664
    (let* ((code (uvref f 0))
	   (code-size (dpb (uvref code 3)
			   (byte 8 24)
			   (dpb (uvref code 2)
				(byte 8 16)
				(dpb (uvref code 1)
				     (byte 8 8)
				     (uvref code 0)))))
	   (function-size (ash (uvsize code) -3)))
      (assert (= (- function-size code-size) (1- (uvsize f))))
      (fasl-out-opcode $fasl-clfun f)
      (fasl-out-count function-size)
      (fasl-out-count code-size)
      (fasl-out-ivect code 0 (ash code-size 3))
      (do* ((i 1 (1+ i))
	    (n (uvsize f)))
	   ((= i n))
	(declare (fixnum i n))
	(fasl-dump-form (%svref f i)))))))

(defun fasl-dump-codevector (c)
  (if (and (not (eq *fasl-backend* *host-backend*))
           (typep c 'code-vector))
    (compiler-bug "Dumping a native code-vector constant ~s during cross-compilation." c))
  (let* ((n (uvsize c)))
    (fasl-out-opcode $fasl-code-vector c)
    (fasl-out-count n)
    (fasl-out-ivect c)))

(defun fasl-dump-t_imm (imm)
  (fasl-out-opcode $fasl-timm imm)
  (fasl-out-long (%address-of imm)))

(defun fasl-dump-char (char)     ; << maybe not
  (let ((code (%char-code char)))
    (fasl-out-opcode $fasl-char char)
    (fasl-out-count code)))

;;; Always write big-endian.
(defun fasl-dump-s16 (s16)
  (fasl-out-opcode $fasl-word-fixnum s16)
  (fasl-out-word s16))

;;; Always write big-endian
(defun fasl-dump-s32 (s32)
  (fasl-out-opcode $fasl-s32 s32)
  (fasl-out-word (ldb (byte 16 16) s32))
  (fasl-out-word (ldb (byte 16 0) s32)))

;;; Always write big-endian
(defun fasl-dump-s64 (s64)
  (fasl-out-opcode $fasl-s64 s64)
  (fasl-out-word (ldb (byte 16 48) s64))
  (fasl-out-word (ldb (byte 16 32) s64))
  (fasl-out-word (ldb (byte 16 16) s64))
  (fasl-out-word (ldb (byte 16 0) s64)))



(defun fasl-dump-dfloat (float)
  (fasl-out-opcode $fasl-dfloat float)
  (multiple-value-bind (high low) (double-float-bits float)
    (fasl-out-long high)
    (fasl-out-long low)))

(defun fasl-dump-sfloat (float)
  (fasl-out-opcode $fasl-sfloat float)
  (fasl-out-long (single-float-bits float)))


(defun fasl-dump-package (pkg)
  (let* ((name (package-name pkg))
         (nextra (utf-8-extra-bytes name)))
    (cond ((eql nextra 0)
           (fasl-out-opcode $fasl-nvpkg pkg)
           (fasl-out-nvstring name))
          (t
           (fasl-out-opcode $fasl-vpkg pkg)
           (fasl-out-vstring name nextra)))))



(defun fasl-dump-list (list)
  (cond ((null list) (fasl-out-opcode $fasl-nil list))
        ((eq (%car list) cfasl-load-time-eval-sym)
         (let* ((form (car (%cdr list)))
                (opcode $fasl-eval))
           (when (funcall-lfun-p form)
             (setq opcode $fasl-lfuncall
                   form (%cadr form)))
           (if *fasdump-epush*
             (progn
               (fasl-out-byte (fasl-epush-op opcode))
               (fasl-dump-form form)
               (fasl-dump-epush list))
             (progn
               (fasl-out-byte opcode)
               (fasl-dump-form form)))))
        ((istruct-cell-p list)
         (fasl-out-opcode $fasl-istruct-cell (car list))
         (fasl-dump-symbol (car list)))
        (t (fasl-dump-cons list))))

(defun fasl-dump-cons (cons &aux (end cons) (cdr-len 0))
  (declare (fixnum cdr-len))
  (while (and (consp (setq end (%cdr end)))
              (null (gethash end *fasdump-hash*)))
    (incf cdr-len))
  (if (eql 0 cdr-len)
    (fasl-out-opcode $fasl-cons cons)
    (progn
      (fasl-out-opcode (if end $fasl-vlist* $fasl-vlist) cons)
      (fasl-out-count cdr-len)))
  (dotimes (i (the fixnum (1+ cdr-len)))
    (fasl-dump-form (%car cons))
    (setq cons (%cdr cons)))
  (when (or (eql 0 cdr-len) end)      ;cons or list*
    (fasl-dump-form end)))



(defun fasl-dump-symbol (sym)
  (let* ((inverse (fasl-setf-name-inverse-p sym)))
    (if inverse
      (fasl-dump-form inverse)
      (let* ((pkg (symbol-package sym))
             (name (symbol-name sym))
             (nextra (utf-8-extra-bytes name))
             (ascii (eql nextra 0))
             (idx (let* ((i (%svref (symptr->symvector (%symbol->symptr sym)) target::symbol.binding-index-cell)))
                    (declare (fixnum i))
                    (unless (zerop i) i))))
        (cond ((null pkg) 
               (progn 
                 (fasl-out-opcode (if idx
                                    (if ascii $fasl-nvmksym-special $fasl-vmksym-special)
                                    (if ascii $fasl-nvmksym $fasl-vmksym))
                                  sym)
                 (if ascii
                   (fasl-out-nvstring name)
                   (fasl-out-vstring name nextra))))
              (*fasdump-epush*
               (progn
                 (fasl-out-byte (fasl-epush-op (if idx
                                                 (if ascii $fasl-nvpkg-intern-special $fasl-vpkg-intern-special)
                                                 (if ascii $fasl-nvpkg-intern $fasl-vpkg-intern))))
                 (fasl-dump-form pkg)
                 (fasl-dump-epush sym)
                 (if ascii
                   (fasl-out-nvstring name)
                   (fasl-out-vstring name nextra))))
              (t
               (progn
                 (fasl-out-byte (if idx
                                  (if ascii $fasl-nvpkg-intern-special $fasl-vpkg-intern-special)
                                  (if ascii $fasl-nvpkg-intern $fasl-vpkg-intern)))
                 (fasl-dump-form pkg)
                 (if ascii
                   (fasl-out-nvstring name)
                   (fasl-out-vstring name nextra)))))))))


(defun fasl-unknown (exp)
  (error "Can't dump ~S - unknown type" exp))

(defun fasl-out-simple-string (str start end)
  (declare (simple-string str) (fixnum start end))
  (do* ((k start (1+ k)))
       ((= k end))
    (declare (fixnum k))
    (fasl-out-byte (char-code (schar str k)))))

(defun fasl-out-nvstring (str)
  (fasl-out-count (length str))
  (fasl-out-simple-string str 0 (length str)))

(defun utf-8-extra-bytes (string)
  (declare (simple-string string))
  (let* ((extra 0))
    (declare (fixnum extra))
    (dotimes (i (length string) extra)
      (let* ((code (%scharcode string i)))
        (declare ((mod #x110000) code))
        (cond ((>= code #x10000) (incf extra 3))
              ((>= code #x800) (incf extra 2))
              ((>= code #x80) (incf extra 1)))))))

(defun fasl-out-vstring (str nextra)
  (declare (fixnum nextra))
  (let* ((len (length str)))
    (declare (fixnum len))
    (fasl-out-count len)
    (fasl-out-count nextra)
    (dotimes (i len)
      (let* ((code (%scharcode str i)))
        (declare ((mod #x110000) code))
        (cond ((< code #x80) (fasl-out-byte code))
              ((< code #x800)
               (let* ((y (ldb (byte 5 6) code))
                      (z (ldb (byte 6 0) code)))
                 (declare (fixnum y z))
                 (fasl-out-byte (logior #xc0 y))
                 (fasl-out-byte (logior #x80 z))))
              ((< code #x10000)
               (let* ((x (ldb (byte 4 12) code))
                      (y (ldb (byte 6 6) code))
                      (z (ldb (byte 6 0) code)))
                 (declare (fixnum x y z))
                 (fasl-out-byte (logior #xe0 x))
                 (fasl-out-byte (logior #x80 y))
                 (fasl-out-byte (logior #x80 z))))
              (t
                (let* ((w (ldb (byte 3 18) code))
                       (x (ldb (byte 6 12) code))
                       (y (ldb (byte 6 6) code))
                       (z (ldb (byte 6 0) code)))
                  (declare (fixnum w x y z))
                  (fasl-out-byte (logior #xf0 w))
                  (fasl-out-byte (logior #x80 x))
                  (fasl-out-byte (logior #x80 y))
                  (fasl-out-byte (logior #x80 z)))))))))


(defun fasl-out-ivect (iv &optional 
                          (start 0) 
                          (nb 
			   (subtag-bytes (typecode iv) (uvsize iv))))
  (stream-write-ivector *fasdump-stream* iv start nb))


(defun fasl-out-long (long)
  (fasl-out-word (ash long -16))
  (fasl-out-word (logand long #xFFFF)))

(defun fasl-out-word (word)
  (fasl-out-byte (ash word -8))
  (fasl-out-byte word))

(defun fasl-out-byte (byte)
  (write-byte (%ilogand2 byte #xFF) *fasdump-stream*))

;;; Write an unsigned integer in 7-bit chunks.
(defun fasl-out-count (val)
  (do* ((b (ldb (byte 7 0) val) (ldb (byte 7 0) val))
        (done nil))
       (done)
    (when (zerop (setq val (ash val -7)))
      (setq b (logior #x80 b) done t))
    (fasl-out-byte b)))

(defun fasl-filepos ()
  (file-position *fasdump-stream*))

(defun fasl-set-filepos (pos)
  (file-position *fasdump-stream* pos)
  #-bccl (unless (eq (file-position *fasdump-stream*) pos)
           (error "Unable to set file position to ~S" pos)))

;;; Concatenate fasl files.

;;; Format of a fasl file as expected by the fasloader.
;;;
;;; #xFF00         2 bytes - File version
;;; Block Count    2 bytes - Number of blocks in the file
;;; addr[0]        4 bytes - address of 0th block
;;; length[0]      4 bytes - length of 0th block
;;; addr[1]        4 bytes - address of 1st block
;;; length[1]      4 bytes - length of 1st block
;;; ...
;;; addr[n-1]      4 bytes
;;; length[n-1]    4 bytes
;;; length[0] + length[1] + ... + length [n-1] bytes of data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (fasl-concatenate out-file fasl-files &key :if-exists)
;;
;; out-file     name of file in which to store the concatenation
;; fasl-files   list of names of fasl files to concatenate
;; if-exists    as for OPEN, defaults to :error
;;
;; function result: pathname to the output file.
;; It works to use the output of one invocation of fasl-concatenate
;; as an input of another invocation.
;;
(defun fasl-concatenate (out-file fasl-files &key (if-exists :error))
  (%fasl-concatenate out-file fasl-files if-exists (pathname-type *.fasl-pathname*)))

(defun %fasl-concatenate (out-file fasl-files if-exists file-ext)
  (let ((count 0)
        (created? nil)
        (finished? nil)
	(ext-pathname (make-pathname :type file-ext)))
    (declare (fixnum count))
    (flet ((fasl-read-halfword (f)
	     (dpb (read-byte f) (byte 8 8) (read-byte f)))
	   (fasl-write-halfword (h f)
	     (write-byte (ldb (byte 8 8) h) f)
	     (write-byte (ldb (byte 8 0) h) f)
	     h))
      (flet ((fasl-read-fullword (f)
	       (dpb (fasl-read-halfword f) (byte 16 16) (fasl-read-halfword f)))
	     (fasl-write-fullword (w f)
	       (fasl-write-halfword (ldb (byte 16 16) w) f)
	       (fasl-write-halfword (ldb (byte 16 0) w) f)
	       w))
	(dolist (file fasl-files)
	  (setq file (merge-pathnames file ext-pathname))
	  (unless (equal (pathname-type file) file-ext)
	    (error "Not a ~A file: ~s" file-ext file))
	  (with-open-file (instream file :element-type '(unsigned-byte 8))
	    (unless (eql fasl-file-id (fasl-read-halfword instream))
	      (error "Bad ~A file ID in ~s" file-ext file))
	    (incf count (fasl-read-halfword instream))))
	(unwind-protect
	     (with-open-file (outstream
			      (setq out-file (merge-pathnames out-file ext-pathname))
			      :element-type '(unsigned-byte 8)
			      :direction :output
			      :if-does-not-exist :create
			      :if-exists if-exists)
	       (setq created? t)
	       (let ((addr-address 4)
		     (data-address (+ 4 (* count 8))))
		 (fasl-write-halfword 0 outstream) ;  will be $fasl-id
		 (fasl-write-halfword count outstream)
		 (dotimes (i (* 2 count))
		   (fasl-write-fullword 0 outstream)) ; for addresses/lengths
		 (dolist (file fasl-files)
		   (with-open-file (instream (merge-pathnames file ext-pathname)
					     :element-type '(unsigned-byte 8))
		     (fasl-read-halfword instream) ; skip ID
		     (let* ((fasl-count (fasl-read-halfword instream))
			    (addrs (make-array fasl-count))
			    (sizes (make-array fasl-count))
			    addr0)
		       (declare (fixnum fasl-count)
				(dynamic-extent addrs sizes))
		       (dotimes (i fasl-count)
			 (setf (svref addrs i) (fasl-read-fullword instream)
			       (svref sizes i) (fasl-read-fullword instream)))
		       (setq addr0 (svref addrs 0))
		       (file-position outstream addr-address)
		       (dotimes (i fasl-count)
			 (fasl-write-fullword
			  (+ data-address (- (svref addrs i) addr0))
			  outstream)
			 (fasl-write-fullword (svref sizes i) outstream)
			 (incf addr-address 8))
		       (file-position outstream data-address)
		       (dotimes (i fasl-count)
			 (file-position instream (svref addrs i))
			 (let ((fasl-length (svref sizes i)))
			   (dotimes (j fasl-length)
			     (write-byte (read-byte instream) outstream))
			   (incf data-address fasl-length))))))
		 (stream-length outstream data-address)
		 (file-position outstream 0)
		 (fasl-write-halfword fasl-file-id outstream)
		 (setq finished? t)))
	  (when (and created? (not finished?))
	    (delete-file out-file))))
      out-file)))

;;; Cross-compilation environment stuff.  Some of this involves
;;; setting up the TARGET and OS packages.
(defun ensure-package-nickname (name package)
  (let* ((old (find-package name)))
    (unless (eq old package)
      (rename-package old (package-name old) (delete name (package-nicknames old) :test #'string=))
      (rename-package package (package-name package) (cons name (package-nicknames package)))
      old)))

(defmacro with-cross-compilation-package ((name target) &body body)
  (let* ((old-package (gensym))
         (name-var (gensym))
         (target-var (gensym)))
    `(let* ((,name-var ,name)
            (,target-var ,target)
            (,old-package (ensure-package-nickname ,name-var ,target-var)))
      (unwind-protect
           (progn ,@body)
        (when ,old-package (ensure-package-nickname ,name-var
                                                          ,old-package))))))

(defun %with-cross-compilation-target (target thunk)
  (let* ((backend (find-backend target)))
    (if (null backend)
      (error "No known compilation target named ~s." target)
      (let* ((arch (backend-target-arch backend))
             (arch-package-name (arch::target-package-name arch))
             (ftd (backend-target-foreign-type-data backend))
             (ftd-package-name (ftd-interface-package-name ftd)))
        (or (find-package arch-package-name)
            (make-package arch-package-name))
        (or (find-package ftd-package-name)
            (make-package ftd-package-name :use "COMMON-LISP"))
        (with-cross-compilation-package ("OS" ftd-package-name)
          (with-cross-compilation-package ("TARGET" arch-package-name)
            (let* ((*target-ftd* ftd))
               (funcall thunk))))))))

(defmacro with-cross-compilation-target ((target) &body body)
  `(%with-cross-compilation-target ,target #'(lambda () ,@body)))
             

  

(provide 'nfcomp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/nfcomp.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/number-case-macro.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;-*- Mode: Lisp; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;;;;;;;;
;; support fns and vars for number-case

;;; We don't recognize a very large set of type specifiers - just
;;; a few symbols that can be mapped to primitive types.  (Not
;;; all of those symbols are necessarily valid type specifiers!)
(defun type-name-to-code (name)
  (let* ((arch (backend-target-arch *target-backend*)))
    (case name
      (fixnum (arch::target-fixnum-tag arch))
      ((short-float single-float) (arch::target-single-float-tag arch))
      ((double-float long-float) (arch::target-double-float-tag arch))
      (t (let* ((key (case name
                       (ratio :ratio)
                       (bignum :bignum)
                       (complex-rational :complex)
                       (complex-single-float :complex-single-float)
                       (complex-double-float :complex-double-float))))
           (or (and key (cdr (assoc key (arch::target-uvector-subtags arch))))
               (error "Can't determine typecode of ~s for architecture ~a."
                      name (arch::target-name arch))))))))

(defparameter nd-onions `((integer fixnum bignum) (rational fixnum bignum ratio)
                          (float double-float single-float)
                          (real fixnum bignum ratio double-float single-float)
                          (complex complex-single-float complex-double-float complex-rational)
                          (number fixnum bignum ratio double-float short-float complex-single-float complex-double-float complex-rational)))


;;; This is just used to generate more succint error messages.
(defparameter canonical-numeric-union-types
  '((integer fixnum bignum)
    (rational integer ratio)
    (float short-float double-float)
    (float single-float double-float) 
    (float short-float long-float)
    (float single-float long-float)
    (real float rational)
    (complex complex-single-float complex-double-float complex-rational)
    (number real complex)))

(defun nd-diff (x y) ; things in x that are not in y
  (let ((res))
    (dolist (e x)
      (when (not (memq e y))(push e res)))
    res))


;;; Try to use canonical names for things that're effectively
;;; implicit unions.  Rinse.  Repeat.
(defun nd-type-compose (selectors)
  (dolist (union canonical-numeric-union-types)
    (destructuring-bind  (u &rest members) union
      (if (not (memq u selectors))
        (when (dolist (m members t)
              (unless (memq m selectors)
                (return nil)))
          (push u selectors)))
      (when (memq u selectors)
        (dolist (m members)
          (setq selectors (delete m selectors))))))
  (setq selectors
        (nsubst '(complex single-float) 'complex-single-float
                (nsubst '(complex-double-float) 'complex-double-float
                        (nsubst '(complex rational) 'complex-rational
                                selectors))))
  (if (cdr selectors)
    (cons 'or selectors)
    (car selectors)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Simpler number dispatch. Syntax is just like case.
;;
;; (number-case x                 =>         (case (typecode x)
;;     (fixnum (print 4))		        (target::tag-fixnum (print 4)) ; actually tag value
;;     ((bignum ratio)(print 5)))		((target::tag-bignum target::tag-ratio)(print 5))
;;	                      			(t (require-type x 'rational)))) 
;;						  

(defmacro number-case (var &rest cases)
  (let ((selectors-so-far)
        (t-case nil)
        (tag (gensym))
        (block (gensym)))
    (flet ((maybe-compound (selector)
             (let ((compound (cdr (assq selector nd-onions))))
               (when compound
                 (setq compound (nd-diff compound selectors-so-far))
                 (when (not compound)(error "Unreachable case ~s" selector))
                 (setq selectors-so-far
                       (append compound selectors-so-far))
                 compound))))
      (declare (dynamic-extent #'maybe-compound))
      `(block ,block
         (tagbody 
           ,tag
           (return-from ,block              
             (case (typecode ,var)
               ,@(mapcar 
                  #'(lambda (case)
                      (let ((selector (car case)))
                        (if (atom selector)
                          (cond ((eq selector t)(setq t-case t))
                                ((memq selector selectors-so-far)(error "Unreachable case ~s" selector))
                                ((let ((compound (maybe-compound selector)))
                                   (when compound
                                     (setq selector compound))))
                                (t (push selector selectors-so-far)))
                          (progn
                            (setq selector
                                  (mapcan #'(lambda (item)
                                              (cond ((memq item selectors-so-far))
                                                    ((let ((compound (maybe-compound item)))
                                                       (when compound
                                                         (setq item compound))))
                                                    (t (push item selectors-so-far)))
                                              (if (listp item) item (list item)))
                                          selector))))
                        (setq selector (if (listp selector)
                                         (mapcar #'type-name-to-code selector)
                                         (if (eq selector t) t
                                             (type-name-to-code selector))))
                        `(,selector ,@(cdr case))))
                  cases)
               ,@(if (not t-case)
                   `((t (setq ,var (%kernel-restart $xwrongtype ,var ',(nd-type-compose selectors-so-far)))
                        (go ,tag)))))))))))

(provide "NUMBER-CASE-MACRO")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/number-case-macro.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/swink.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;
;;; Copyright 2011 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.
;;;
;;;   Implement a protocol (originally based on swank) for communication between
;;;   a lisp and an external debugger.  This implements the server side, i.e. the lisp
;;;   being debugged.

(eval-when (eval compile load)
  (defpackage :swink
    (:use :cl :ccl)
    (:export
     "START-SERVER"
     "STOP-SERVER"
     "STOP-ALL-SERVERS"
     ;; Some stuff that's also useful on client side
     "THREAD"
     "THREAD-CLASS"
     "THREAD-CONNECTION"
     "THREAD-ID"
     "THREAD-CONTROL-PROCESS"
     "MAKE-NEW-THREAD"

     "CONNECTION"
     "FIND-THREAD"
     "CONNECTION-CONTROL-STREAM"
     "CONNECTION-CONTROL-PROCESS"
     "CLOSE-CONNECTION"

     "TAGGED-OBJECT"
     "TAG-CALLBACK"
     "INVOKE-CALLBACK"
     "ABORT-CALLBACK"

     "DESTRUCTURE-CASE"

     "WITH-CONNECTION-LOCK"
     "WITH-EVENT-HANDLING"
     "SEND-EVENT"
     "SEND-EVENT-FOR-VALUE"
     "SIGNAL-EVENT"
     "HANDLE-EVENT"
     "READ-SEXP"
     )))

(in-package :swink)

(defvar *default-server-port* 4003)

(defvar *dont-close* nil
  "Keep listening for more connections on the same port after get the first one")

(defvar *external-format* :iso-8859-1)


(defvar *swink-lock* (make-lock))

(defmacro with-swink-lock ((&rest lock-options) &body body)
  `(without-interrupts
    (with-lock-grabbed (*swink-lock* ,@lock-options)
      ,@body)))

(defmacro destructure-case (value &rest patterns)
  "Dispatch VALUE to one of PATTERNS.
A cross between `case' and `destructuring-bind'.
The pattern syntax is:
  ((HEAD . ARGS) . BODY)
The list of patterns is searched for a HEAD `eq' to the car of
VALUE. If one is found, the BODY is executed with ARGS bound to the
corresponding values in the CDR of VALUE."
  (let ((operator (gensym "op-"))
	(operands (gensym "rand-"))
	(tmp (gensym "tmp-"))
        (case (if (or (eq (caar (last patterns)) t)
                      (eq (caaar (last patterns)) t)) 'case 'ecase)))
    `(let* ((,tmp ,value)
	    (,operator (car ,tmp))
	    (,operands (cdr ,tmp)))
       (,case ,operator
         ,@(loop for (pattern . body) in patterns collect 
                 (if (eq pattern t)
                     `(t ,@body)
                     (destructuring-bind (op &rest rands) pattern
                       `(,op (destructuring-bind ,rands ,operands 
                               ,@body)))))))))


(defun string-segment (string start end)
  (if (and (eql start 0) (eql end (length string)))
    string
    (make-array (- end start)
                :displaced-to string
                :displaced-index-offset start)))


(defun safe-condition-string (condition)
  (or (ignore-errors (princ-to-string condition))
      (ignore-errors (prin1-to-string condition))
      (ignore-errors (format nil "Condition of type ~s"
                             (type-of condition)))
      (ignore-errors (and (typep condition 'error)
                          "<Unprintable error>"))
      "<Unprintable condition>"))


(defun invoke-restart-if-active (restart &rest values)
  (declare (dynamic-extent values))
  (handler-case
      (apply #'invoke-restart restart values)
    (ccl::inactive-restart () nil)))

(defmethod marshall-argument (conn (process process))
  (declare (ignore conn))
  (process-serial-number process))

(defmethod marshall-argument (conn (condition condition))
  (declare (ignore conn))
  (safe-condition-string condition))

(defmethod marshall-argument (conn thing)
  (declare (ignore conn))
  thing)

(defun marshall-event (conn event)
  (flet ((marshall (thing)           ;; Only check the top level
           (marshall-argument conn thing)))
    (mapcar #'marshall event)))

(defvar *log-events* nil)

(defvar *log-queue*)

(let ((log-lock (make-lock)))
  (defun log-event (format-string &rest format-args)
    (when *log-events*
      (ignore-errors
	(let* ((string (format nil "[~d] ~?" (process-serial-number *current-process*) format-string format-args)))
	  ;; This kludge is so don't have to disable interrupts while printing.
	  ;; There is a tiny timing screw at end of loop; who cares, it's just for debugging...
	  (if (boundp '*log-queue*) ;; recursive call
	      (without-interrupts 
		(setq *log-queue* (nconc *log-queue* (list string))))
	      (let ((stream ccl::*stdout*))
		(with-lock-grabbed (log-lock "Log Output Lock")
		  (let ((*log-queue* (list string)))
		    (fresh-line stream)
		    (loop for string = (without-interrupts (pop *log-queue*)) while string
		       do (write-string string stream)
		       do (terpri stream))))
		(force-output stream))))))))

(defun warn-and-log (format-string &rest format-args)
  (declare (dynamic-extent format-args))
  (apply #'log-event format-string format-args)
  (apply #'warn format-string format-args))

(defclass connection ()
  ((control-process :initform nil :accessor connection-control-process)
   (control-stream :initarg :control-stream :reader connection-control-stream)
   (buffer :initform (make-string 1024) :accessor connection-buffer)
   (lock :initform (make-lock) :reader connection-lock)
   (threads :initform nil :accessor %connection-threads)
   (object-counter :initform most-negative-fixnum :accessor connection-object-counter)
   (objects :initform nil :accessor connection-objects)))

(defmacro with-connection-lock ((conn &rest lock-args) &body body)
  `(without-interrupts ;; without callbacks
    (with-lock-grabbed ((connection-lock ,conn) ,@lock-args)
      ,@body)))

(defmethod close-connection ((conn connection))
  (log-event "closing connection ~s" conn)
  (let ((process (connection-control-process conn)))
    (when process
      (process-interrupt process 'invoke-restart-if-active 'close-connection))))

(defun tag-object (conn object)
  (with-connection-lock (conn)
    (let* ((id (incf (connection-object-counter conn))))
      (push (cons id object) (connection-objects conn))
      id)))

(defun object-tag (conn object)
  (with-connection-lock (conn)
    (car (rassoc object (connection-objects conn)))))

(defun tagged-object (conn id &key keep-tagged)
  (if keep-tagged
    (cdr (assoc id (connection-objects conn)))
    (with-connection-lock (conn)
      (let ((cell (assoc id (connection-objects conn))))
        (unless cell
          (warn-and-log "Missing object for remote reference ~s" id))
        (setf (connection-objects conn) (delq cell (connection-objects conn)))
        (cdr cell)))))

(defun remove-tag (conn id)
  (with-connection-lock (conn)
    (setf (connection-objects conn) (delete id (connection-objects conn) :key #'car))))

(defun tag-callback (conn function)
  (tag-object conn function))

(defun invoke-callback (conn id &rest values)
  (declare (dynamic-extent values))
  (let ((function (tagged-object conn id)))
    (when function (apply function t values))))

(defun abort-callback (conn id)
  (let ((function (tagged-object conn id)))
    (when function
      (funcall function nil))))

(defun write-packet (conn string)
  (let ((stream (connection-control-stream conn)))
     (assert (<= (length string) #xFFFFFF))
    ;; We could have a separate lock for the stream, but we can't really send back anything until
    ;; this write is finished, so it doesn't hurt much if random stuff is held up while we do this.
    (with-connection-lock (conn)
      (format stream "~6,'0,X" (length string))
      (write-string string stream))
    (force-output stream)))

(defvar +swink-io-package+
  (loop as name = (gensym "SwinkIO/") while (find-package name)
    finally (let ((package (make-package name :use nil)))
              (import '(nil t quote) package)
              (return package))))

(defun format-for-swink (fmt-string fmt-args)
  (with-standard-io-syntax
      (let ((*package* +swink-io-package+))
        (apply #'format nil fmt-string fmt-args))))

(defun write-sexp (conn sexp)
  (write-packet conn (with-standard-io-syntax
                         (let ((*package* +swink-io-package+))
                           (prin1-to-string sexp)))))

(defun send-event (target event &key ignore-errors)
  (let* ((conn (thread-connection target))
	 (encoded-event (marshall-event conn event)))
    (log-event "Send-event ~s to ~a" encoded-event (if (eq target conn)
						       "connection"
						       (princ-to-string (thread-id target))))
    (handler-bind ((stream-error (lambda (c)
				   (when (eq (stream-error-stream c) (connection-control-stream conn))
				     (unless ignore-errors
				       (log-event "send-event error: ~a" c)
				       (close-connection conn))
				     (return-from send-event)))))
      (write-sexp conn (cons (thread-id target) encoded-event)))))

(defun send-event-if-open (target event)
  (send-event target event :ignore-errors t))

#-bootstrapped (fmakunbound 'read-sexp)

;;This assumes only one process reads from the command stream or the read-buffer, so don't need locking.
(defmethod read-sexp ((conn connection))
  ;; Returns the sexp or :end-connection event
  (let* ((stream (connection-control-stream conn))
         (buffer (connection-buffer conn))
         (count (stream-read-vector stream buffer 0 6)))
    (handler-bind ((stream-error (lambda (c)
                                   ;; This includes parse errors as well as i/o errors
                                   (when (eql (stream-error-stream c) stream)
                                     (log-event "read-sexp error: ~a" c)
				     ; (setf (connection-io-error conn) t)
                                     (return-from read-sexp
                                       `(nil . (:end-connection ,c)))))))
      (when (< count 6) (ccl::signal-eof-error stream))
      (setq count (parse-integer buffer :end 6 :radix 16))
      (when (< (length buffer) count)
        (setq buffer (setf (connection-buffer conn) (make-string count))))
      (let ((len (stream-read-vector stream buffer 0 count)))
        (when (< len count) (ccl::signal-eof-error stream))
        ;; TODO: verify that there aren't more forms in the string.
        (with-standard-io-syntax
            (let ((*package* +swink-io-package+)
                  (*read-eval* nil))
              (read-from-string buffer t nil :end count)))))))

(defmethod thread-connection ((conn connection)) conn)

;; Data for processes with swink event handling.
(defclass thread ()
  ((connection :initarg :connection :reader thread-connection)
   (lock :initform (make-lock) :reader thread-lock)
   (process :initarg :process :accessor thread-process)
   (event-queue :initform nil :accessor thread-event-queue)))

(defmacro with-thread-lock ((thread &rest lock-args) &rest body)
  `(without-interrupts
    (with-lock-grabbed ((thread-lock ,thread) ,@lock-args)
      ,@body)))

(defmethod thread-id ((thread thread))
  (thread-id (thread-process thread)))

(defmethod thread-id ((process process))
  (process-serial-number process))

(defmethod thread-id ((id integer))
  id)

(defmethod marshall-argument (conn (thread thread))
  (declare (ignore conn))
  (thread-id thread))

(defun connection-threads (conn)
  (with-connection-lock (conn)
    (copy-list (%connection-threads conn))))

(defun find-thread (conn id &key (key #'thread-id))
  (with-connection-lock (conn)
    (find id (%connection-threads conn) :key key)))

(defmethod make-new-thread ((conn connection) &optional (process *current-process*))
  (with-connection-lock (conn)
    (assert (not (find-thread conn process :key #'thread-process)))
    (let ((thread (make-instance (thread-class conn) :connection conn :process process)))
      (push thread (%connection-threads conn))
      thread)))


(defun queue-event (thread event)
  (with-thread-lock (thread)
    (setf (thread-event-queue thread) (nconc (thread-event-queue thread) (list event)))))

(defun dequeue-event (thread)
  (with-thread-lock (thread) (pop (thread-event-queue thread))))


;; Event handling.
;; Built on conditions rather than semaphores, so events can interrupt a process in i/o wait.

(defvar *signal-events* nil)

(define-condition events-available () ())

(defun enable-event-handling (thread)
  (setq *signal-events* t)
  (loop while (thread-event-queue thread)
        do (let ((*signal-events* nil))
             (handle-events thread))))

(defmacro with-event-handling ((thread &key restart) &body body)
  (let ((thread-var (gensym "THREAD")))
    (if restart
      `(let ((,thread-var ,thread))
         (loop
           (handler-case (return (let ((*signal-events* *signal-events*))
                                   (enable-event-handling ,thread-var)
                                   (with-interrupts-enabled
                                       ,@body)))
             (events-available () (let ((*signal-events* nil))
                                   (handle-events ,thread-var))))))
      `(let ((,thread-var ,thread))
         (handler-bind ((events-available (lambda (c)
                                            (declare (ignore c))
                                            (handle-events ,thread-var))))
           (let ((*signal-events* *signal-events*))
             (enable-event-handling ,thread-var)
             (with-interrupts-enabled
                 ,@body)))))))

(defun signal-event (thread event)
  (queue-event thread event)
  (process-interrupt (or (thread-control-process thread)
                         (error "Got event ~s for thread ~s with no process" event thread))
                     (lambda ()
                       (when *signal-events*
                         (let ((*signal-events* nil))
                           (signal 'events-available))))))


(defmethod handle-events ((thread thread))
  (loop as event = (dequeue-event thread) while event
        do (handle-event thread event)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Server side:
;;
;; In any process we can enter a read loop which gets its input from a swink connection
;; and sends output to the connection.  We can also spawn a process that does nothing else.

(defvar *global-debugger* t
  "Use remote debugger on errors and user events even in non-repl threads")

(defclass server-ui-object (ccl::ui-object) ())

(defclass server-connection (connection)
  ((internal-requests :initform nil :accessor connection-internal-requests)))

(defclass server-thread (thread server-ui-object)
  ((io :initform nil :accessor thread-io)))

(defmethod thread-class ((conn server-connection)) 'server-thread)

(defmethod thread-control-process ((thread server-thread))
  (thread-process thread))

(defvar *server-connections* '()
  "List of all active connections, with the most recent at the front.")

(defvar *current-server-thread* nil)

;; TODO: if this process talked to a connection before, we should reuse it
;;  even if not talking to it now.
(defun connection-for-process (process)
  "Return the 'default' connection for implementing a break in a
non-swink process PROCESS."
  (let ((data (ccl::process-ui-object process)))
    (if (typep data 'server-thread)     ;; process is in a swink repl.
      (thread-connection data)
      (car *server-connections*))))

(defmethod thread-id ((conn server-connection))
  (process-serial-number *current-process*))

(defvar *listener-sockets* nil)

(defun start-server (&key (port *default-server-port*)
                          (dont-close *dont-close*) 
                          (external-format *external-format*))
  "Start a SWINK server on PORT.
  If DONT-CLOSE is true then the listen socket will accept multiple
  connections, otherwise it will be closed after the first."
  (let* ((stream-args (and external-format `(:external-format ,external-format)))
         (socket (make-socket :connect :passive
                              ;; :local-host "127.0.0.1"
                              :local-port port
                              :reuse-address t))
         (info (cons socket nil))
         (local-port (local-port socket)))
    (with-swink-lock ()
      (setf (getf *listener-sockets* port) info))
    (setf (cdr info)
          (process-run-function (format nil "Swink Server ~a" local-port)
            (lambda ()
              (setf (cdr info) *current-process*)
              (flet ((serve ()
                       (let ((stream nil))
                         (unwind-protect
                             (progn
                               (setq stream (accept-connection socket :wait t :stream-args stream-args))
                               (spawn-server-connection stream)
                               (setq stream nil))
                           (when stream (close stream :abort t))))))
                (unwind-protect
                    (cond ((not dont-close) (serve))
                          (t (loop (ignore-errors (serve)))))
                  (close socket :abort t)
                  (with-swink-lock ()
                    (remf *listener-sockets* info)))))))
    (log-event "Swink awaiting ~s instructions on port ~s ~s" external-format local-port socket)
    local-port))

(defun stop-server (port)
  "Stop server running on PORT."
  (let* ((info (with-swink-lock () (getf *listener-sockets* port))))
    (when info
      (destructuring-bind (socket . process) info
        (when process
          (process-kill process))
        (close socket :abort t) ;; harmless if already closed.
        (with-swink-lock ()
          (remf *listener-sockets* port)))
      t)))

(defun stop-all-servers ()
  "Stop all swink servers"
  (loop for info on *listener-sockets* by #'cddr do
    (stop-server (car info))))

(defun enqueue-internal-request (conn event)
  (with-connection-lock (conn)
    (push (cons nil event) (connection-internal-requests conn))))

(defmethod read-sexp ((conn server-connection))
  (if (and (connection-internal-requests conn)
           ;; Remote always takes priority
           (not (stream-listen (connection-control-stream conn))))
      (with-connection-lock (conn) (pop (connection-internal-requests conn)))
      (call-next-method)))

(defun server-event-loop (conn)
  (loop
    (let ((thread.event (read-sexp conn)))
      (log-event "received: ~s" thread.event)
      (destructuring-bind (thread-id . event) thread.event
        (if thread-id
          (let ((thread (find-thread conn thread-id)))
            (when thread
              (signal-event thread event)))
          (handle-event conn event))))))

(defun spawn-server-connection (stream)
  (let ((conn (make-instance 'server-connection :control-stream stream))
        (startup-signal (make-semaphore)))
    (setf (connection-control-process conn)
          (process-run-function (format nil "swink-event-loop@~s" (local-port stream))
            (lambda ()
	      (unwind-protect
		   (with-simple-restart (close-connection "Exit server")
		     (setf (connection-control-process conn) *current-process*)
		     (handler-bind ((error (lambda (c)
					     (log-event "Error: ~a" c)
                                             (log-event "Backtrace: ~%~a"
                                                        (ignore-errors
                                                         (with-output-to-string (s)
                                                           (print-call-history :detailed-p nil :stream s :print-length 20 :print-level 4))))
					     (invoke-restart 'close-connection))))
		       (when startup-signal (signal-semaphore startup-signal))
		       (server-event-loop conn)))
		(control-process-cleanup conn)))))
    (wait-on-semaphore startup-signal)
    (with-swink-lock () (push conn *server-connections*))
    (when *global-debugger*
      (use-swink-globally t))
    conn))

;; Note this happens in an unwind-protect, so is without interrupts.  But we've pretty much
;; returned to top level and hold no locks.
(defun control-process-cleanup (conn)
  (with-swink-lock ()
    (setq *server-connections* (delq conn *server-connections*))
    (when (null *server-connections*) (use-swink-globally nil)))
  (flet ((exit-repl ()
	   ;; While exiting, threads may attempt to write to the connection.  That's good, if the
	   ;; connection is still alive and we're attempting an orderly exit.  Don't go into a spiral
	   ;; if the connection is dead.  Once we get any kind of error, just punt.
	   (log-event "Start exit-repl in ~s" (thread-id *current-process*))
	   (handler-case  (invoke-restart-if-active 'exit-repl)
	     (error (c) (log-event "Exit repl error ~a in ~s" c (thread-id *current-process*))))))
    (loop for thread in  (connection-threads conn)
       do (process-interrupt (thread-process thread) #'exit-repl)))
  (let* ((timeout 0.05)
         (end (+ (get-internal-real-time) (* timeout internal-time-units-per-second))))
    (process-wait "closing connection"
      (lambda ()
        (or (null (%connection-threads conn)) (> (get-internal-real-time) end)))))
  (when (%connection-threads conn)
    (warn-and-log "Wasn't able to close these threads: ~s" (connection-threads conn)))

  (close (connection-control-stream conn)))


;; This is only called when this lisp receives an interrupt signal.
(defun select-interactive-process ()
  (when *global-debugger*
    (loop for conn in (with-swink-lock () (copy-list *server-connections*))
      do (loop for thread in (connection-threads conn)
           when (thread-io thread) ;; still active
           do (return-from select-interactive-process (thread-process thread))))))

(defun send-event-for-value (target event &key abort-event (semaphore (make-semaphore)))
  (let* ((returned nil)
         (return-values nil)
         (tag nil)
         (conn (thread-connection target)))
    (unwind-protect
        (progn
          (setq tag (tag-callback conn (lambda (completed? &rest values)
                                         (setq returned t)
                                         (when completed?
                                           ;; Just return 0 values if cancelled.
                                           (setq return-values values))
                                         (signal-semaphore semaphore))))
          ;; In server case, :target is nil, 
          (send-event target `(,@event ,tag))
          (let ((current-thread (find-thread conn *current-process* :key #'thread-control-process)))
            (if current-thread ;; if in repl thread, handle thread events while waiting.
              (with-event-handling (current-thread)
                (wait-on-semaphore semaphore))
              (wait-on-semaphore semaphore)))
          (apply #'values return-values))
      (when (and tag (not returned))
        (remove-tag conn tag)
        (when (and abort-event (not returned))
          ;; inform the other side that not waiting any more.
          (send-event-if-open conn `(,@abort-event ,tag)))))))


(defmethod get-remote-user-input ((thread server-thread))
  ;; Usually this is called from a repl evaluation, but the user could have passed the stream to
  ;; any other process, so we could be running anywhere.  Thread is the thread of the stream.
  (with-simple-restart (abort-read "Abort reading")
    (let ((conn (thread-connection thread)))
      (force-output (thread-io thread))
      (send-event-for-value conn `(:read-string ,thread) :abort-event `(:abort-read ,thread)))))


(defmethod send-remote-user-output ((thread server-thread) string start end)
  (let ((conn (thread-connection thread)))
    (send-event conn `(:write-string ,thread ,(string-segment string start end)))))

(defun swink-repl (conn break-level toplevel-loop)
  (let* ((thread (make-new-thread conn))
         (in (make-input-stream thread #'get-remote-user-input))
         (out (make-output-stream thread #'send-remote-user-output))
         (io (make-two-way-stream in out))
         (ui-object (ccl::process-ui-object *current-process*)))
    (assert (null (thread-io thread)))
    (with-simple-restart (exit-repl "Exit remote read loop")
      (unwind-protect
          (let* ((*current-server-thread* thread)
                 (*standard-input* in)
                 (*standard-output* out)
                 (*trace-output* out)
                 (*debug-io* io)
                 (*query-io* io)
                 (*terminal-io* io)
                 (ccl::*break-level* 0)
                 (ccl::*read-loop-function* 'swink-read-loop))
            (setf (ccl::process-ui-object *current-process*) thread)
            (setf (thread-io thread) io)
            (ccl:add-auto-flush-stream out)
            (send-event conn `(:start-repl ,break-level))
            (funcall toplevel-loop))
        ;; Do we need this?  We've already exited from the outermost level...
	(send-event-if-open conn `(:exit-repl))
        (ccl:remove-auto-flush-stream out)
        (setf (ccl::process-ui-object *current-process*) ui-object)
        (setf (thread-io thread) nil)
        (close in :abort t)
        (close out :abort t)
        (with-connection-lock (conn)
          (setf (%connection-threads conn) (delq thread (%connection-threads conn))))))))


(defclass repl-process (process) ())

(defun spawn-repl (conn name)
  (process-run-function `(:name ,name :class repl-process)
    (lambda ()
      (swink-repl conn 0 #'ccl::toplevel-loop))))

;; Invoked for a break in a non-repl process (can only happen if using swink globally).
(defun swink-debugger-hook (condition hook)
  (declare (ignore hook))
  (when (eq ccl::*read-loop-function* 'swink-read-loop)
    (return-from swink-debugger-hook nil))
  (let ((conn (connection-for-process *current-process*)))
    ;; TODO: set up a restart to pick a different connection, if there is more than one.
    (when conn
      (swink-repl conn 1 (lambda ()
                           (ccl::%break-message ccl::*break-loop-type* condition)
                           ;; Like toplevel-loop but run break-loop to set up error context first
                           (loop
                             (catch :toplevel
                               (ccl::break-loop condition))
                             (when (eq *current-process* ccl::*initial-process*)
                               (toplevel))))))))

(defun marshall-debugger-context (context)
  ;; TODO: neither :GO nor cmd-/ pay attention to the break condition, whereas bt.restarts does...
  (let* ((continuable (ccl::backtrace-context-continuable-p context))
         (restarts (ccl::backtrace-context-restarts context))
         (tcr (ccl::bt.tcr context))
         ;; Context for printing stack-consed refs
         #-arm-target                   ;no TSP on ARM
         (ccl::*aux-tsp-ranges* (ccl::make-tsp-stack-range tcr context))
         (ccl::*aux-vsp-ranges* (ccl::make-vsp-stack-range tcr context))
         (ccl::*aux-csp-ranges* (ccl::make-csp-stack-range tcr context))
         (break-level (ccl::bt.break-level context)))
    (list :break-level break-level
          :continuable-p (and continuable t)
          :restarts (mapcar #'princ-to-string restarts))))
  
(defvar *bt-context* nil)

(defun swink-read-loop (&key (break-level 0) &allow-other-keys)
  (let* ((thread *current-server-thread*)
         (conn (thread-connection thread))
         (ccl::*break-level* break-level)
         (*loading-file-source-file* nil)
         (ccl::*loading-toplevel-location* nil)
         (*bt-context* (find break-level ccl::*backtrace-contexts* :key #'ccl::backtrace-context-break-level))
         *** ** * +++ ++ + /// // / -)
    (when *bt-context*
      (send-event conn `(:enter-break ,(marshall-debugger-context *bt-context*))))

    (flet ((repl-until-abort ()
             (restart-case
                 (catch :abort
                   (catch-cancel
                    ;; everything is done via interrupts ...
                    (with-event-handling (thread)
                      (loop (sleep 60)))))
               (abort ()
                 :report (lambda (stream)
                           (if (eq break-level 0)
                             (format stream "Return to toplevel")
                             (format stream "Return to break level ~D" break-level)))
                 nil)
               (abort-break () (unless (eql break-level 0) (abort))))))
      (unwind-protect
          (loop
            (repl-until-abort)
            (clear-input)
            (terpri)
            (send-event conn `(:read-loop ,break-level)))
	(send-event-if-open conn `(:debug-return ,break-level))))))

(defmacro with-return-values ((conn remote-tag &body abort-forms) &body body)
  (let ((ok-var (gensym))
        (tag-var (gensym))
        (conn-var (gensym)))
    `(let ((,ok-var nil) (,conn-var ,conn) (,tag-var ,remote-tag))
       (send-event ,conn-var `(:return ,,tag-var
                                       ,@(unwind-protect
                                             (prog1 (progn ,@body) (setq ,ok-var t))
                                           (unless ,ok-var
                                             (send-event-if-open ,conn-var `(:cancel-return ,,tag-var))
                                             ,@abort-forms)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; inspector support.

(defmethod ccl::ui-object-do-operation ((o server-ui-object) (operation (eql :inspect)) &rest args)
  (let ((conn (connection-for-process *current-process*)))
    (if conn
      (apply #'remote-inspect conn args)
      (call-next-method))))

(defvar $inspector-segment-size 100)

(defstruct (icell (:constructor %make-icell))
  inspector
  string
  count
  (segments nil) ;; line inspectors, in equal-sized segments.
  (process *current-process*))

(defmethod marshall-argument ((conn connection) (icell icell))
  ;; Send the count and string since they need that right away anyhow.
  (list* (tag-object conn icell) (icell-count icell) (icell-string icell)))

(defun make-icell (inspector)
  (let* ((count (or (inspector::inspector-line-count inspector)
                    (inspector::update-line-count inspector)))
         (seg-size (min count $inspector-segment-size)))
    (%make-icell :inspector inspector
		 :count count
		 :string (inspector::inspector-object-string inspector)
		 :segments (and (> seg-size 0) ;; pre-reserve the initial segment.
				(list (cons 0 seg-size))))))

(defun icell-seg-size (icell)
  (length (cdar (icell-segments icell))))

(defun iseg-end (seg)
  (destructuring-bind (start . ln) seg
    (+ start (if (integerp ln) ln (length ln)))))

(defun compute-lines (icell seg)
  (let* ((inspector::*inspector-disassembly* t)
         (inspector (icell-inspector icell))
         (start-index (car seg))
         (seg-count (cdr seg)))
    (unless (integerp seg-count)
      (warn-and-log "Duplicate request for ~s line ~s" icell seg)
      (setq seg-count (length seg-count)))
    (let ((strings (make-array seg-count))
          (lines (make-array seg-count)))
      (loop for index from 0 below seg-count
            do (multiple-value-bind (line-inspector label-string value-string)
                                    (inspector::inspector-line inspector (+ start-index index))
                 (setf (aref lines index) line-inspector)
                 (setf (aref strings index) (cons label-string value-string))))
      (setf (cdr seg) lines)
      strings)))

(defmethod remote-inspect ((conn server-connection) thing)
  (let* ((inspector (let ((inspector::*inspector-disassembly* t))
                      (inspector::make-inspector thing)))
         (icell (make-icell inspector)))
    (send-event conn `(:inspect ,icell))
    (when (icell-segments icell)
      (send-inspector-data conn icell))
    thing))

(defun send-inspector-data (conn icell &optional (seg (car (icell-segments icell))))
  (let ((strings (compute-lines icell seg)))
    (send-event conn `(:inspector-data ,(object-tag conn icell) (,(car seg) . ,strings))))
  ;; arrange to send the rest later
  (enqueue-internal-request conn `(maybe-send-inspector-data ,icell)))

;; Segment management.
;; Only the control process messes with icell-segments, so don't need to lock.
(defun reserve-next-segment (icell)
  (let* ((segments (icell-segments icell))
         (count (icell-count icell))
         (gapptr nil))
    (loop for last = nil then segs as segs = segments then (cdr segs) while segs
      when (and last (> (caar last) (iseg-end (car segs)))) do (setq gapptr last))
    (when gapptr
      (setq count (caar gapptr) segments (cdr gapptr)))
    (let* ((start-index (iseg-end (car segments)))
           (seg-size (min (icell-seg-size icell) (- count start-index)))
           (new (and (> seg-size 0) (cons start-index seg-size))))
      ;; gapptr = ((5000 . line) (200 . line) ... (0 . line))
      (when new
        (if (null gapptr)
          (setf (icell-segments icell) (cons new segments))
          (setf (cdr gapptr) (cons new segments)))
        new))))

;; Returns NIL if already reserved
(defun reserve-segment-for-index (icell index)
  (let* ((seg-size (icell-seg-size icell))
         (seg-start (- index (mod index seg-size))))
    (loop for last = nil then segs as segs = (icell-segments icell) then (cdr segs)
      while (< seg-start (caar segs)) ;; last seg is always 0.
      finally (return (unless (eql seg-start (caar segs)) ;; already exists.
                        (let ((this-end (iseg-end (car segs)))
                              (new (cons seg-start seg-size)))
                          (assert (>= seg-start this-end))
                          (if (null last)
                            (push new (icell-segments icell))
                            (push new (cdr last)))
                          new))))))

(defun icell-line-inspector (icell index)
  (loop for seg in (icell-segments icell)
    when (and (<= (car seg) index) (< index (iseg-end seg)))
    return (and (vectorp (cdr seg)) (aref (cdr seg) (- index (car seg))))))

(defun maybe-send-inspector-data (conn icell &optional (seg (car (icell-segments icell))))
  (when seg
    (let* ((process (icell-process icell))
           (thread (ccl::process-ui-object process)))
      (if (typep thread 'server-thread)
        ;; Why not just interrupt like any random process?
        (signal-event thread `(send-inspector-data ,icell ,seg))
        (process-interrupt process #'send-inspector-data conn icell seg)))))

(defmethod handle-event ((conn server-connection) event)
  (log-event "handle-event (global): ~s" event)
  (destructure-case event

    ((:end-connection condition)
     (declare (ignore condition))
     (close-connection conn))

    ((:spawn-repl name)
     (spawn-repl conn name))

    ((:return local-tag &rest values)
     (apply #'invoke-callback conn local-tag values))

    ((:connection-info remote-tag)
     (with-return-values (conn remote-tag)
       (list `(:pid ,(ccl::getpid)
                    :lisp-implementation-type ,(lisp-implementation-type)
                    :lisp-implementation-version ,(lisp-implementation-version)
                    :machine-instance ,(machine-instance)
                    :machine-type ,(machine-type)
                    :machine-version ,(machine-version)))))

    ((:describe-more icell-tag index)
     (let* ((icell (tagged-object conn icell-tag :keep-tagged t))
            (seg (reserve-segment-for-index icell index)))
       (when seg
         (maybe-send-inspector-data conn icell seg))))

    ((:line-inspector icell-tag index return-tag)
     (let ((new-icell nil))
       (with-return-values (conn return-tag)
         (let* ((icell (tagged-object conn icell-tag :keep-tagged t))
                (line-inspector  (or (icell-line-inspector icell index)
                                     (error "Requesting undescribed line ~s ~s" icell index))))
           (setq new-icell (make-icell line-inspector))
           (list new-icell)))
       (maybe-send-inspector-data conn new-icell)))

    ((:refresh-inspector icell-tag return-tag)
     (let ((new-icell nil))
       (with-return-values (conn return-tag)
         (let* ((icell (tagged-object conn icell-tag :keep-tagged t))
                (new-inspector (inspector::refresh-inspector (icell-inspector icell))))
           (setq new-icell (make-icell new-inspector))
           (list new-icell)))
       (maybe-send-inspector-data conn new-icell)))

    ((:inspecting-item icell-tag)
     (loop with icell = (tagged-object conn icell-tag :keep-tagged t)
       for thread in (connection-threads conn)
       when (thread-io thread)
       do (signal-event thread `(inspecting-item ,icell))))

    ;; Internal event to send data in segments so it's interruptible
    ((maybe-send-inspector-data icell)
     (let ((seg (reserve-next-segment icell)))
       (when seg
         (maybe-send-inspector-data conn icell seg))))

    #+remote-eval
    ((:eval form)
       ;; It's the caller's responsibility to make this quick...  If they want return values
       ;; or whatever, they can put that in the form.
       (eval form))))
  

;; TODO: toplevel-eval checks package change and invokes application-ui-operation, need to send that back.


;; Eval all forms in string without printing intermediate results
(defun read-eval-all-print-last (string package-name)
  (if package-name
    (let ((*package* (or (find-package package-name) *package*)))
      (read-eval-all-print-last string nil))
    (with-input-from-string (sstream string)
      (let ((values nil))
        (loop
          (let ((form (ccl::read-toplevel-form sstream :eof-value sstream)))
            (when (eq form sstream)
              (ccl::toplevel-print values)
              (force-output)
              (return))
            (unless (ccl::check-toplevel-command form)
              (setq values (ccl::toplevel-eval form nil))
              (setq /// // // / / values)
              (unless (eq (car values) (ccl::%unbound-marker))
                (setq *** ** ** * *  (car values))))))
        (values)))))


(defun read-eval-print-one (conn sstream package)
  (if package
    (let ((*package* package))
      (read-eval-print-one conn sstream nil))
    (let ((form (ccl::read-toplevel-form sstream :eof-value sstream)))
      (unless (eq form sstream)
        (unless (ccl::check-toplevel-command form)
          (ccl::toplevel-print (ccl::toplevel-eval form nil))))
      (cond ((listen sstream)
             (tag-object conn (cons sstream package)))
            (t
             (close sstream)
             nil)))))


;; Events from client to specific thread.  This is running at a safe point inside a repl thread.
(defmethod handle-event ((thread thread) event)
  (log-event "handle-event (thread ~s): ~s" (process-serial-number *current-process*) event)
  (let ((conn (thread-connection thread)))
    (destructure-case event
      
      ((:read-eval-all-print-last string package-name remote-tag)
       (with-return-values (conn remote-tag)
         (read-eval-all-print-last string package-name)))
      
      ((:read-eval-print-one string package-name remote-tag)
       (let* ((sstream (make-string-input-stream string))
              (package (and package-name (or (find-package package-name) *package*))))
         (with-return-values (conn remote-tag (close sstream))
           (read-eval-print-one conn sstream package))))
      
      ((:read-eval-print-next state remote-tag)
       (destructuring-bind (sstream . package) (tagged-object conn state)
         (with-return-values (conn remote-tag (close sstream))
           (read-eval-print-one conn sstream package))))

      ;; Internal events
      ((send-inspector-data icell seg)
       (send-inspector-data conn icell seg))
      ((inspecting-item icell)
       (inspector::note-inspecting-item (icell-inspector icell)))

      ((:interrupt)
       (ccl::force-break-in-listener *current-process*))

      ((:invoke-restart restart-name)
       (invoke-restart restart-name))
      
      ((:invoke-restart-in-context index)
       (invoke-restart-interactively (nth index (ccl::backtrace-context-restarts *bt-context*))))

      ((:toplevel)
       (toplevel)))))

(let (using-swink-globally select-hook debugger-hook break-hook ui-object)
  (defun use-swink-globally (yes-or-no)
    (log-event "use-swink-globally: ~s" yes-or-no)
    (if yes-or-no
      (unless using-swink-globally
        (setq select-hook *select-interactive-process-hook*)
        (setq *select-interactive-process-hook*
              (if select-hook
                (lambda () (or (select-interactive-process) (funcall select-hook)))
                'select-interactive-process))
        (setq debugger-hook *debugger-hook*)
        (setq *debugger-hook*
              (if debugger-hook
                (lambda (condition hook)
                  (swink-debugger-hook condition hook)
                  (funcall debugger-hook condition hook))
                'swink-debugger-hook))
        (setq break-hook *break-hook*)
        (setq *break-hook*
              (if break-hook
                (lambda (condition hook)
                  (swink-debugger-hook condition hook)
                  (funcall break-hook condition hook))
                'swink-debugger-hook))
        ;; This probably should be controlled by something other than use-swink-globally because
        ;; might want to use gui inspector even if not using global debugger.
        (setq ui-object (ccl::application-ui-object *application*))
        (setf (ccl::application-ui-object *application*) (make-instance 'server-ui-object))
        (setq using-swink-globally t))
      (when using-swink-globally
        (setf *select-interactive-process-hook* select-hook
              *debugger-hook* debugger-hook
              *break-hook* break-hook
              (ccl::application-ui-object *application*) ui-object)
        (setq using-swink-globally nil)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Simple buffered stream with a user input/output function.
(defclass swink-stream ()
  ((thread :initarg :thread :reader stream-thread)
   (lock :initform (make-lock))
   (buffer :initform "" :initarg :buffer)
   (index :initform 0)
   (column :initform 0 :reader stream-line-column)
   (line-length :initform ccl::*default-right-margin* :accessor stream-line-length)))
  
(defmethod stream-thread ((stream two-way-stream))
  (stream-thread (two-way-stream-input-stream stream)))

(defmethod stream-thread ((stream stream))
  nil)


(defmacro with-swink-stream (slots stream &body body)
  `(with-slots (lock ,@slots) ,stream
     (with-lock-grabbed (lock)
       ,@body)))

(defclass swink-output-stream (swink-stream fundamental-character-output-stream)
  ((output-fn :initarg :output-fn)
   (buffer :initform (make-string 8000) :initarg :buffer)))

(defun make-output-stream (thread output-fn)
  (make-instance 'swink-output-stream :thread thread :output-fn output-fn))

(defun output-stream-output (stream string start end)
  (with-slots (output-fn thread) stream
    (let ((conn (thread-connection thread)))
      (handler-bind ((stream-error (lambda (c)
				     (when (eql (stream-error-stream c)
						(connection-control-stream conn))
				       (with-slots (ccl::stream) c
					 (setf ccl::stream stream))))))
	(funcall output-fn thread string start end)))))


(defmethod flush-buffer ((stream swink-output-stream)) ;; called with lock hold
  (with-slots (buffer index) stream
    (unless (eql index 0)
      (output-stream-output stream buffer 0 index)
      (setf index 0))))

(defmethod stream-write-char ((stream swink-output-stream) char)
  (with-swink-stream (buffer index column) stream
    (when (eql index (length buffer))
      (flush-buffer stream))
    (setf (schar buffer index) char)
    (incf index)
    (if (eql char #\newline)
      (setf column 0)
      (incf column)))
  char)

(defmethod stream-write-string ((stream swink-output-stream) string &optional start end)
  (with-swink-stream (buffer index column) stream
    (let* ((len (length buffer))
           (start (or start 0))
           (end (ccl::check-sequence-bounds string start end))
           (count (- end start))
           (free (- len index)))
      (when (>= count free)
        (flush-buffer stream))
      (cond ((< count len)
             (replace buffer string :start1 index :start2 start :end2 end)
             (incf index count))
            (t (output-stream-output stream string start end)))
      (let ((last-newline (position #\newline string :from-end t
                                    :start start :end end)))
        (setf column (if last-newline 
                       (- end last-newline 1)
                       (+ column count))))))
  string)

(defmethod stream-force-output ((stream swink-output-stream))
  (with-swink-stream () stream
    (flush-buffer stream)))

(defmethod ccl::stream-finish-output ((stream swink-output-stream))
  (stream-force-output stream))

(defclass swink-input-stream (swink-stream fundamental-character-input-stream)
  ((input-fn :initarg :input-fn)))

(defun make-input-stream (thread input-fn)
  (make-instance 'swink-input-stream :thread thread :input-fn input-fn))

(defun input-stream-input (stream)
  (with-slots (input-fn thread) stream
    (let ((conn (thread-connection thread)))
      (handler-bind ((stream-error (lambda (c)
				     (when (eql (stream-error-stream c)
						(connection-control-stream conn))
				       (with-slots (ccl::stream) c
					 (setf ccl::stream stream))))))
	(funcall input-fn thread)))))

(defmethod stream-read-char ((stream swink-input-stream))
  (with-swink-stream (buffer index column) stream
    (unless (< index (length buffer))
      (let ((string (input-stream-input stream)))
        (cond ((eql (length string) 0)
               (return-from stream-read-char :eof))
              (t
               (setf buffer string  index 0)))))
    (let ((char (aref buffer index)))
      (incf index)
      (if (eql char #\Newline)
        (setf column 0)
        (incf column))
      char)))

(defmethod stream-read-char-no-hang ((stream swink-input-stream))
  (with-swink-stream (buffer index column) stream
    (when (< index (length buffer))
      (let ((char (aref buffer index)))
        (incf index)
        (if (eql char #\Newline)
          (setf column 0)
          (incf column))
        char))))

(defmethod stream-listen ((stream swink-input-stream))
  (with-swink-stream (buffer index) stream
    (< index (length buffer))))

(defmethod stream-unread-char ((stream swink-input-stream) char)
  (with-swink-stream (buffer index) stream
    (if (eql (length buffer) 0) ;; perhaps did clear-input.
      (setf buffer (make-string 1 :initial-element char))
      (if (> index 0)
        (decf index)
        (error "Unread with no preceeding read")))))

(defmethod stream-clear-input ((stream swink-input-stream))
  (with-swink-stream (buffer index) stream
    (setf buffer "" index 0))
  nil)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/swink.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/systems.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

;;; module-name       binary                    (source . files-depends-on)
;;; -----------       ------                    ---------------------------
(defparameter *ccl-system*
  '(
    (level-1          "ccl:ccl;level-1"          ("ccl:l1;level-1.lisp"))
    (runtime          "ccl:ccl;runtime"          ("ccl:l1;runtime.lisp"))
    (level-1-test     "ccl:level-1-test"         ("ccl:l1;level-1-test.lisp"))
    (l1-cl-package    "ccl:l1f;l1-cl-package"    ("ccl:l1;l1-cl-package.lisp"))
    (l1-utils         "ccl:l1f;l1-utils"         ("ccl:l1;l1-utils.lisp"))
    (l1-numbers       "ccl:l1f;l1-numbers"       ("ccl:l1;l1-numbers.lisp"))
    (l1-init          "ccl:l1f;l1-init"          ("ccl:l1;l1-init.lisp"))
    (version          "ccl:l1f;version"          ("ccl:l1;version.lisp"))
    (l1-boot-1        "ccl:l1f;l1-boot-1"        ("ccl:l1;l1-boot-1.lisp"))
    (l1-boot-2        "ccl:l1f;l1-boot-2"        ("ccl:l1;l1-boot-2.lisp"))
    (l1-boot-3        "ccl:l1f;l1-boot-3"        ("ccl:l1;l1-boot-3.lisp"))
    (l1-boot-lds      "ccl:l1f;l1-boot-lds"      ("ccl:l1;l1-boot-lds.lisp"))
    (l1-files         "ccl:l1f;l1-files"         ("ccl:l1;l1-files.lisp"))
    (l1-sort          "ccl:l1f;l1-sort"          ("ccl:l1;l1-sort.lisp"))
    (l1-dcode         "ccl:l1f;l1-dcode"         ("ccl:l1;l1-dcode.lisp"))
    (l1-clos-boot     "ccl:l1f;l1-clos-boot"    ("ccl:l1;l1-clos-boot.lisp"))
    (l1-clos          "ccl:l1f;l1-clos"          ("ccl:l1;l1-clos.lisp"))
    (l1-io            "ccl:l1f;l1-io"            ("ccl:l1;l1-io.lisp"))
    (l1-unicode       "ccl:l1f;l1-unicode"       ("ccl:l1;l1-unicode.lisp"))
    
    (l1-streams       "ccl:l1f;l1-streams"       ("ccl:l1;l1-streams.lisp"))
    (l1-events        "ccl:l1f;l1-events"        ("ccl:l1;l1-events.lisp"))
    (ppc-trap-support "ccl:l1f;ppc-trap-support" ("ccl:l1;ppc-trap-support.lisp"))
    (x86-trap-support "ccl:l1f;x86-trap-support" ("ccl:l1;x86-trap-support.lisp"))

    (arm-trap-support "ccl:l1f;arm-trap-support" ("ccl:l1;arm-trap-support.lisp"))
    (l1-format        "ccl:l1f;l1-format"        ("ccl:l1;l1-format.lisp"))
    (l1-readloop      "ccl:l1f;l1-readloop"      ("ccl:l1;l1-readloop.lisp"))
    (l1-readloop-lds  "ccl:l1f;l1-readloop-lds"  ("ccl:l1;l1-readloop-lds.lisp"))
    (l1-reader        "ccl:l1f;l1-reader"        ("ccl:l1;l1-reader.lisp"))
    (l1-error-system  "ccl:l1f;l1-error-system"  ("ccl:l1;l1-error-system.lisp"))
    (ppc-error-signal "ccl:l1f;ppc-error-signal" ("ccl:l1;ppc-error-signal.lisp"))
    (x86-error-signal "ccl:l1f;x86-error-signal" ("ccl:l1;x86-error-signal.lisp"))
    (arm-error-signal "ccl:l1f;arm-error-signal" ("ccl:l1;arm-error-signal.lisp"))
    (l1-error-signal  "ccl:l1f;l1-error-signal"  ("ccl:l1;l1-error-signal.lisp"))
    (l1-aprims        "ccl:l1f;l1-aprims"        ("ccl:l1;l1-aprims.lisp"))
    (l1-callbacks     "ccl:l1f;l1-callbacks"    ("ccl:l1;l1-callbacks.lisp"))
    (ppc-callback-support "ccl:l1f;ppc-callback-support" ("ccl:l1;ppc-callback-support.lisp"))
    (x86-callback-support "ccl:l1f;x86-callback-support" ("ccl:l1;x86-callback-support.lisp"))
    (arm-callback-support "ccl:l1f;arm-callback-support" ("ccl:l1;arm-callback-support.lisp"))
    (l1-sysio         "ccl:l1f;l1-sysio"         ("ccl:l1;l1-sysio.lisp"))
    (l1-symhash       "ccl:l1f;l1-symhash"       ("ccl:l1;l1-symhash.lisp"))
    (l1-pathnames     "ccl:l1f;l1-pathnames"     ("ccl:l1;l1-pathnames.lisp"))
    (l1-lisp-threads  "ccl:l1f;l1-lisp-threads"  ("ccl:l1;l1-lisp-threads.lisp"))
    (l1-sockets       "ccl:l1f;l1-sockets"       ("ccl:l1;l1-sockets.lisp"))
    (ppc-threads-utils "ccl:l1f;ppc-threads-utils" ("ccl:l1;ppc-threads-utils.lisp"))
    (x86-threads-utils "ccl:l1f;x86-threads-utils" ("ccl:l1;x86-threads-utils.lisp"))
    (arm-threads-utils "ccl:l1f;arm-threads-utils" ("ccl:l1;arm-threads-utils.lisp"))
    (l1-application   "ccl:l1f;l1-application"   ("ccl:l1;l1-application.lisp"))
    (l1-processes     "ccl:l1f;l1-processes"     ("ccl:l1;l1-processes.lisp"))

    (l1-typesys       "ccl:l1f;l1-typesys"       ("ccl:l1;l1-typesys.lisp"))
    (sysutils         "ccl:l1f;sysutils"         ("ccl:l1;sysutils.lisp"))
    (nx               "ccl:l1f;nx"               ("ccl:compiler;nx.lisp"
                                                  "ccl:compiler;nx0.lisp"
                                                  "ccl:compiler;lambda-list.lisp"
                                                  "ccl:compiler;nx-basic.lisp"
                                                  "ccl:compiler;nx1.lisp"))
    (nxenv            "ccl:bin;nxenv"            ("ccl:compiler;nxenv.lisp"))
    (nx2              "ccl:bin;nx2"              ("ccl:compiler;nx2.lisp"))
    (acode-rewrite    "ccl:bin;acode-rewrite"    ("ccl:compiler;acode-rewrite.lisp"))
    (nx-base-app      "ccl:l1f;nx-base-app"      ("ccl:compiler;nx-base-app.lisp"
                                                  "ccl:compiler;lambda-list.lisp"))
    (dll-node         "ccl:bin;dll-node"         ("ccl:compiler;dll-node.lisp"))
    (ppc32-arch       "ccl:bin;ppc32-arch"       ("ccl:compiler;PPC;PPC32;ppc32-arch.lisp"))
    (ppc-arch         "ccl:bin;ppc-arch"         ("ccl:compiler;PPC;ppc-arch.lisp"))
    (x86-arch         "ccl:bin;x86-arch"         ("ccl:compiler;X86;x86-arch.lisp"))
    (ppc64-arch       "ccl:bin;ppc64-arch"       ("ccl:compiler;PPC;PPC64;ppc64-arch.lisp"))
    (x8632-arch       "ccl:bin;x8632-arch"       ("ccl:compiler;X86;X8632;x8632-arch.lisp"))
    (x8664-arch       "ccl:bin;x8664-arch"       ("ccl:compiler;X86;X8664;x8664-arch.lisp"))
    (arm-arch         "ccl:bin;arm-arch"         ("ccl:compiler;ARM;arm-arch.lisp"))
    (arch             "ccl:bin;arch"             ("ccl:compiler;arch.lisp"))
    (ppcenv           "ccl:bin;ppcenv"           ("ccl:lib;ppcenv.lisp"))
    (x8664env         "ccl:bin;x8664env"         ("ccl:lib;x8664env.lisp"))
    (x8632env         "ccl:bin;x8632env"         ("ccl:lib;x8632env.lisp"))
    (armenv           "ccl:bin;armenv"           ("ccl:lib;armenv.lisp"))
    (vreg             "ccl:bin;vreg"             ("ccl:compiler;vreg.lisp"))
    (ppc-asm          "ccl:bin;ppc-asm"          ("ccl:compiler;PPC;ppc-asm.lisp"))
    (x86-asm          "ccl:bin;x86-asm"          ("ccl:compiler;X86;x86-asm.lisp"))
    (arm-asm          "ccl:bin;arm-asm"          ("ccl:compiler;ARM;arm-asm.lisp"))
    (vinsn            "ccl:bin;vinsn"            ("ccl:compiler;vinsn.lisp"))
    (ppc32-vinsns     "ccl:bin;ppc32-vinsns"     ("ccl:compiler;PPC;PPC32;ppc32-vinsns.lisp"))
    (ppc64-vinsns     "ccl:bin;ppc64-vinsns"     ("ccl:compiler;PPC;PPC64;ppc64-vinsns.lisp"))
    (x8632-vinsns     "ccl:bin;x8632-vinsns"     ("ccl:compiler;X86;X8632;x8632-vinsns.lisp"))
    (x8664-vinsns     "ccl:bin;x8664-vinsns"     ("ccl:compiler;X86;X8664;x8664-vinsns.lisp"))
    (arm-vinsns       "ccl:bin;arm-vinsns"       ("ccl:compiler;ARM;arm-vinsns.lisp"))
    (reg              "ccl:bin;reg"              ("ccl:compiler;reg.lisp"))
    (subprims         "ccl:bin;subprims"         ("ccl:compiler;subprims.lisp"))
    (risc-lap         "ccl:bin;risc-lap"         ("ccl:compiler;risc-lap.lisp"))
    (ppc-lap          "ccl:bin;ppc-lap"          ("ccl:compiler;PPC;ppc-lap.lisp"))
    (x86-lap          "ccl:bin;x86-lap"          ("ccl:compiler;X86;x86-lap.lisp"))
    (arm-lap          "ccl:bin;arm-lap"          ("ccl:compiler;ARM;arm-lap.lisp"))
    (backend          "ccl:bin;backend"          ("ccl:compiler;backend.lisp"))
    (ppc32-backend    "ccl:bin;ppc32-backend"    ("ccl:compiler;PPC;PPC32;ppc32-backend.lisp"))			   
    (ppc64-backend    "ccl:bin;ppc64-backend"    ("ccl:compiler;PPC;PPC64;ppc64-backend.lisp"))
    (ppc-backend      "ccl:bin;ppc-backend"      ("ccl:compiler;PPC;ppc-backend.lisp"))
    (x8632-backend    "ccl:bin;x8632-backend"    ("ccl:compiler;X86;X8632;x8632-backend.lisp"))
    (x8664-backend    "ccl:bin;x8664-backend"    ("ccl:compiler;X86;X8664;x8664-backend.lisp"))
    (x86-backend      "ccl:bin;x86-backend"      ("ccl:compiler;X86;x86-backend.lisp"))
    (arm-backend      "ccl:bin;arm-backend"      ("ccl:compiler;ARM;arm-backend.lisp"))
    (ppc2             "ccl:bin;ppc2"             ("ccl:compiler;PPC;ppc2.lisp"))
    (x862             "ccl:bin;x862"             ("ccl:compiler;X86;x862.lisp"))
    (arm2             "ccl:bin;arm2"             ("ccl:compiler;ARM;arm2.lisp"))
    (ppc-lapmacros    "ccl:bin;ppc-lapmacros"    ("ccl:compiler;PPC;ppc-lapmacros.lisp"))
    (x86-lapmacros    "ccl:bin;x86-lapmacros"    ("ccl:compiler;X86;x86-lapmacros.lisp"))
    (arm-lapmacros    "ccl:bin;arm-lapmacros"    ("ccl:compiler;ARM;arm-lapmacros.lisp"))
    (ppc-disassemble  "ccl:bin;ppc-disassemble"  ("ccl:compiler;PPC;ppc-disassemble.lisp"))
    (x86-disassemble  "ccl:bin;x86-disassemble"  ("ccl:compiler;X86;x86-disassemble.lisp"))
    (arm-disassemble  "ccl:bin;arm-disassemble"  ("ccl:compiler;ARM;arm-disassemble.lisp"))
    (xfasload         "ccl:xdump;xfasload"       ("ccl:xdump;xfasload.lisp"))
    (xppcfasload      "ccl:xdump;xppcfasload"    ("ccl:xdump;xppcfasload.lisp"))
    (xx8632fasload    "ccl:xdump;xx8632-fasload"  ("ccl:xdump;xx8632-fasload.lisp"))
    (xx8664fasload    "ccl:xdump;xx8664-fasload"  ("ccl:xdump;xx8664-fasload.lisp"))
    (xarmfasload      "ccl:xdump;xarm-fasload"   ("ccl:xdump;xarmfasload.lisp"))
    (heap-image       "ccl:xdump;heap-image"     ("ccl:xdump;heap-image.lisp"))
    (xsym             "ccl:xdump;xsym"           ("ccl:xdump;xsym.lisp"))
    (number-macros "ccl:bin;number-macros"    ("ccl:lib;number-macros.lisp"))
    (number-case-macro  "ccl:bin;number-case-macro" ("ccl:lib;number-case-macro.lisp"))
    (optimizers       "ccl:bin;optimizers"       ("ccl:compiler;optimizers.lisp")) 
    (backquote        "ccl:bin;backquote"        ("ccl:lib;backquote.lisp"))
    (lispequ          "ccl:library;lispequ"      ("ccl:library;lispequ.lisp"))
    (sysequ           "ccl:bin;sysequ"           ("ccl:lib;sysequ.lisp"))
    (toolequ          "ccl:bin;toolequ"          ("ccl:lib;toolequ.lisp"))
    (level-2          "ccl:bin;level-2"          ("ccl:lib;level-2.lisp"))
    (macros           "ccl:bin;macros"           ("ccl:lib;macros.lisp"))
    (defstruct-macros "ccl:bin;defstruct-macros" ("ccl:lib;defstruct-macros.lisp"))
    (foreign-types    "ccl:bin;foreign-types"    ("ccl:lib;foreign-types.lisp"))
    (ffi-linuxppc32   "ccl:bin;ffi-linuxppc32"   ("ccl:lib;ffi-linuxppc32.lisp"))
    (ffi-darwinppc32  "ccl:bin;ffi-darwinppc32"  ("ccl:lib;ffi-darwinppc32.lisp"))
    (ffi-darwinppc64  "ccl:bin;ffi-darwinppc64"  ("ccl:lib;ffi-darwinppc64.lisp"))
    (ffi-linuxppc64   "ccl:bin;ffi-linuxppc64"   ("ccl:lib;ffi-linuxppc64.lisp"))
    (ffi-darwinx8632  "ccl:bin;ffi-darwinx8632"  ("ccl:lib;ffi-darwinx8632.lisp"))
    (ffi-linuxx8664   "ccl:bin;ffi-linuxx8664"   ("ccl:lib;ffi-linuxx8664.lisp"))
    (ffi-darwinx8664  "ccl:bin;ffi-darwinx8664"  ("ccl:lib;ffi-darwinx8664.lisp"))
    (ffi-freebsdx8664 "ccl:bin;ffi-freebsdx8664" ("ccl:lib;ffi-freebsdx8664.lisp"))
    (ffi-solarisx8664 "ccl:bin;ffi-solarisx8664" ("ccl:lib;ffi-solarisx8664.lisp"))
    (ffi-win64 "ccl:bin;ffi-win64" ("ccl:lib;ffi-win64.lisp"))
    (ffi-linuxx8632  "ccl:bin;ffi-linuxx8632" ("ccl:lib;ffi-linuxx8632.lisp"))
    (ffi-win32 "ccl:bin;ffi-win32" ("ccl:lib;ffi-win32.lisp"))
    (ffi-solarisx8632 "ccl:bin;ffi-solarisx8632" ("ccl:lib;ffi-solarisx8632.lisp"))
    (ffi-freebsdx8632 "ccl:bin;ffi-freebsdx8632" ("ccl:lib;ffi-freebsdx8632.lisp"))
    (ffi-linuxarm     "ccl:bin;ffi-linuxarm"     ("ccl:lib;ffi-linuxarm.lisp"))
    (ffi-darwinarm    "ccl:bin;ffi-darwinarm"    ("ccl:lib;ffi-darwinarm.lisp"))
    (ffi-androidarm     "ccl:bin;ffi-androidarm"     ("ccl:lib;ffi-androidarm.lisp"))
    (db-io            "ccl:bin;db-io"            ("ccl:lib;db-io.lisp"))
    (hash             "ccl:bin;hash"             ("ccl:lib;hash.lisp"))
    (nfcomp           "ccl:bin;nfcomp"           ("ccl:lib;nfcomp.lisp"))
    (lists            "ccl:bin;lists"            ("ccl:lib;lists.lisp"))
    (chars            "ccl:bin;chars"            ("ccl:lib;chars.lisp"))
    (streams          "ccl:bin;streams"          ("ccl:lib;streams.lisp"))
    (pathnames        "ccl:bin;pathnames"        ("ccl:lib;pathnames.lisp"))
    (describe         "ccl:bin;describe"         ("ccl:lib;describe.lisp")) 
    (mcl-compat       "ccl:bin;mcl-compat"       ("ccl:lib;mcl-compat.lisp"))
    (backtrace        "ccl:bin;backtrace"        ("ccl:lib;backtrace.lisp"))
    (ppc-backtrace    "ccl:bin;ppc-backtrace"    ("ccl:lib;ppc-backtrace.lisp"))
    (x86-backtrace    "ccl:bin;x86-backtrace"    ("ccl:lib;x86-backtrace.lisp"))
    (arm-backtrace    "ccl:bin;arm-backtrace"    ("ccl:lib;arm-backtrace.lisp"))
    (x86-watch        "ccl:bin;x86-watch"        ("ccl:lib;x86-watch.lisp"))
    (backtrace-lds    "ccl:bin;backtrace-lds"    ("ccl:lib;backtrace-lds.lisp"))
    (apropos          "ccl:bin;apropos"          ("ccl:lib;apropos.lisp"))
    (numbers          "ccl:bin;numbers"          ("ccl:lib;numbers.lisp"))
    (dumplisp         "ccl:bin;dumplisp"         ("ccl:lib;dumplisp.lisp"))
    (defstruct        "ccl:bin;defstruct"        ("ccl:lib;defstruct.lisp"
                                                  "ccl:lib;defstruct-macros.lisp"))
    (defstruct-lds    "ccl:bin;defstruct-lds"    ("ccl:lib;defstruct-lds.lisp"
                                                  "ccl:lib;defstruct-macros.lisp"))
    (method-combination
     "ccl:bin;method-combination"
     ("ccl:lib;method-combination.lisp"))
    (encapsulate      "ccl:bin;encapsulate"      ("ccl:lib;encapsulate.lisp"))
    (read             "ccl:bin;read"           ("ccl:lib;read.lisp"))
    (misc             "ccl:bin;misc"           ("ccl:lib;misc.lisp"))
    (arrays-fry       "ccl:bin;arrays-fry"     ("ccl:lib;arrays-fry.lisp"))
    (sequences        "ccl:bin;sequences"      ("ccl:lib;sequences.lisp"))
    (sort             "ccl:bin;sort"           ("ccl:lib;sort.lisp"))
    (setf             "ccl:bin;setf"           ("ccl:lib;setf.lisp"))
    (setf-runtime     "ccl:bin;setf-runtime"   ("ccl:lib;setf-runtime.lisp"))
    (format           "ccl:bin;format"         ("ccl:lib;format.lisp"))
    (case-error       "ccl:bin;case-error"     ("ccl:lib;case-error.lisp"))
    (pprint           "ccl:bin;pprint"         ("ccl:lib;pprint.lisp"))
    (time             "ccl:bin;time"           ("ccl:lib;time.lisp"))
    (print-db         "ccl:bin;print-db"       ("ccl:lib;print-db.lisp"))
; (eval             "ccl:bin;eval"           ("ccl:lib;eval.lisp"))

    (arglist          "ccl:bin;arglist"          ("ccl:lib;arglist.lisp"))

    (edit-callers	   "ccl:bin;edit-callers"   ("ccl:lib;edit-callers.lisp"))
    ;; (hash-cons        "ccl:library;hash-cons"    ("ccl:library;hash-cons.lisp"))
    ;; (step             "ccl:bin;step"           ("ccl:lib;step.lisp"))
    (ccl-export-syms  "ccl:bin;ccl-export-syms"  ("ccl:lib;ccl-export-syms.lisp"))
    (systems          "ccl:bin;systems"        ("ccl:lib;systems.lisp"))
    (compile-ccl      "ccl:bin;compile-ccl"    ("ccl:lib;compile-ccl.lisp"))
    (ppc-init-ccl     "ccl:bin;ppc-init-ccl"   ("ccl:lib;ppc-init-ccl.lisp"))
    (distrib-inits    "ccl:bin;distrib-inits"  ("ccl:lib;distrib-inits.lisp"))
    (lisp-package     "ccl:library;lisp-package" ("ccl:library;lisp-package.lisp"))
    ;; need to add swapping, xdump to CCL's *module-search-path*
    (xdump            "ccl:xdump;xdump"          ("ccl:xdump;xdump.lisp"))
    (fasload          "ccl:xdump;fasload"        ("ccl:xdump;fasload.lisp"))
    (loop             "ccl:library;loop"         ("ccl:library;loop.lisp"))
    (linux-files      "ccl:l1f;linux-files"      ("ccl:level-1;linux-files.lisp"))
    (sockets          "ccl:library;sockets"      ("ccl:library;sockets.lisp"))
    (source-files     "ccl:bin;source-files"     ("ccl:lib;source-files.lisp"))
    (swink            "ccl:bin;swink"            ("ccl:lib;swink.lisp"))
    (cover            "ccl:bin;cover"            ("ccl:library;cover.lisp"))
    (leaks            "ccl:bin;leaks"            ("ccl:library;leaks.lisp"))
    (core-files       "ccl:bin;core-files"       ("ccl:library;core-files.lisp"))
    (dominance        "ccl:bin;dominance"        ("ccl:library;dominance.lisp"))
    (swank-loader     "ccl:bin;swank-loader"     ("ccl:library;swank-loader.lisp"))    
    (remote-lisp      "ccl:bin;remote-lisp"      ("ccl:library;remote-lisp.lisp" "ccl:lib;swink.lisp"))
 
    (prepare-mcl-environment "ccl:bin;prepare-mcl-environment" ("ccl:lib;prepare-mcl-environment.lisp"))
    (defsystem        "ccl:tools;defsystem"      ("ccl:tools;defsystem.lisp"))
    (asdf             "ccl:tools;asdf"	    ("ccl:tools;asdf.lisp"))
    (jp-encode        "ccl:bin;jp-encode"        ("ccl:library;jp-encode.lisp"))
    (cn-encode        "ccl:bin;cn-encode"        ("ccl:library;cn-encode.lisp"))
    (hashenv          "ccl:bin;hashenv"          ("ccl:xdump;hashenv.lisp"))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/systems.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/time.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :execute)
  (defconstant seconds-in-week (* 60 60 24 7))
  (defconstant weeks-offset 2145)
  (defconstant seconds-offset 432000)
  (defconstant minutes-per-day (* 24 60))
  (defconstant quarter-days-per-year (1+ (* 365 4)))
  (defconstant quarter-days-per-century 146097)
  (defconstant november-17-1858 678882)
  (defconstant weekday-november-17-1858 2)
)

(defun gctime ()
  (let* ((timeval-size (record-length :timeval)))
    (%stack-block ((copy (* timeval-size 5)))
      (#_memmove copy *total-gc-microseconds* (* timeval-size 5))
      (macrolet ((funk (arg)
                   (ecase internal-time-units-per-second 
                    (1000000 `(timeval->microseconds ,arg))
                    (1000 `(timeval->milliseconds ,arg)))))
        (values
         (funk copy)
         (funk (%incf-ptr copy timeval-size))
         (funk (%incf-ptr copy timeval-size))
         (funk (%incf-ptr copy timeval-size))
         (funk (%incf-ptr copy timeval-size)))))))




;;; This should stop using #_localtime_r: not all times can be represented
;;; as a signed natural offset from the start of Unix time.
;;; For now, if the time won't fit in a :time_t, use an arbitrary time
;;; value to get the time zone and assume that DST was -not- in effect.
#-windows-target
(defun get-timezone (time)
  (let* ((toobig (not (typep time '(signed-byte
                                    #+32-bit-target 32
                                    #+64-bit-target 64)))))
    (when toobig
      (setq time 0))
    (rlet ((when :time_t)
           (tm :tm))
      (setf (pref when :time_t) time)
      (with-macptrs ((ltm (#_localtime_r when tm)))
        (if (%null-ptr-p ltm)
          (values 0 nil)
          (progn
            (values (floor #-solaris-target (pref tm :tm.tm_gmtoff)
                           #+solaris-target #&altzone
                           -60)
                    (unless toobig (not (zerop (pref tm :tm.tm_isdst)))))))))))

#+windows-target
(defun get-timezone (time)
  (declare (ignore time))
  (rlet ((tzinfo #>TIME_ZONE_INFORMATION))
    (let* ((id (#_GetTimeZoneInformation tzinfo))
           (minutes-west (pref tzinfo #>TIME_ZONE_INFORMATION.Bias))
           (is-dst (= id #$TIME_ZONE_ID_DAYLIGHT)))
      (values (floor (+ minutes-west
                        (if is-dst
                          (pref tzinfo #>TIME_ZONE_INFORMATION.DaylightBias)
                          0)))
              is-dst))))



(defun decode-universal-time (universal-time &optional time-zone)
  "Converts a universal-time to decoded time format returning the following
   nine values: second, minute, hour, date, month, year, day of week (0 =
   Monday), T (daylight savings time) or NIL (standard time), and timezone.
   Completely ignores daylight-savings-time when time-zone is supplied."
  (let* ((daylight nil)
         (timezone (if (null time-zone)
                     (multiple-value-bind
                         (minwest dst)
                         (get-timezone (- universal-time
                                          unix-to-universal-time))
                       (declare (fixnum minwest))
                       (setf daylight dst)
                       (the fixnum (* minwest 60)))
                     (* time-zone 60 60))))
    (declare (fixnum timezone))
    (multiple-value-bind (weeks secs)
        (truncate (+ (- universal-time timezone) seconds-offset)
                  seconds-in-week)
      (let* ((weeks (+ weeks weeks-offset))
             (second NIL)
             (minute NIL)
             (hour NIL)
             (date NIL)
             (month NIL)
             (year NIL)
             (day NIL))
        (multiple-value-bind (t1 seconds) (truncate secs 60)
          (setq second seconds)
          (let* ((tday (truncate t1 minutes-per-day)))
            (multiple-value-setq (hour minute)
              (truncate (- t1 (* tday minutes-per-day)) 60))
            (let* ((t2 (1- (* (+ (* weeks 7) tday november-17-1858) 4)))
                   (tcent (truncate t2 quarter-days-per-century)))
              (setq t2 (mod t2 quarter-days-per-century))
              (setq t2 (+ (- t2 (mod t2 4)) 3))
              (setq year (+ (* tcent 100) (truncate t2 quarter-days-per-year)))
              (let ((days-since-mar0 (1+ (truncate (mod t2 quarter-days-per-year)
                                                   4))))
                (setq day (mod (+ tday weekday-november-17-1858) 7))
                (let ((t3 (+ (* days-since-mar0 5) 456)))
                  (cond ((>= t3 1989)
                         (setq t3 (- t3 1836))
                         (setq year (1+ year))))
                  (multiple-value-setq (month t3) (truncate t3 153))
                  (setq date (1+ (truncate t3 5))))))))
        (values second minute hour date month year day
                daylight
                (if daylight
		  (1+ (/ timezone 60 60))
		  (/ timezone 60 60)))))))

(defun get-decoded-time ()
  "Return nine values specifying the current time as follows:
   second, minute, hour, date, month, year, day of week (0 = Monday), T
   (daylight savings times) or NIL (standard time), and timezone."
  (decode-universal-time (get-universal-time)))

(defun current-year ()
  (nth-value 5 (get-decoded-time)))

(defun leap-years-before (year)
  (let ((years (- year 1901)))
    (+ (- (truncate years 4)
	  (truncate years 100))
       (truncate (+ years 300) 400))))

(defvar *days-before-month*
  (let* ((results (list nil)))
    (let ((sum 0))
      (dolist (days-per-month '(31 28 31 30 31 30 31 31 30 31 30 31))
	(push sum results)
	(incf sum days-per-month)))
    (coerce (nreverse results) 'vector)))

(defun check-valid-date (year month day)
  (declare (fixnum year month day))
  (let* ((limit (if (and (eql month 2)
                         (not (logtest year 3))
                         (or (eql 0 (mod year 400))
                             (not (eql 0 (mod year 100)))))
                  29
                  (svref #(31 28 31 30 31 30 31 31 30 31 30 31) (1- month)))))
    (declare (fixnum limit))
    (unless (<= day limit)
      (report-bad-arg day `(integer 1 ,limit)))))

(defun encode-universal-time (second minute hour date month year
				     &optional (time-zone nil tz-p))
  "The time values specified in decoded format are converted to
   universal time, which is returned."
  (check-type second (mod 60))
  (check-type minute (mod 60))
  (check-type hour (mod 24))
  (check-type date (integer 1 31))
  (check-type month (integer 1 12))
  (check-type year unsigned-byte)
  (when time-zone
    (check-type time-zone (rational -24 24)))
  (locally
      (declare (type (mod 60) second)
               (type (mod 60) minute)
               (type (mod 24) hour)
               (type (integer 1 31) date)
               (type (integer 1 12) month)
               (type unsigned-byte year)
               (type (or null rational) time-zone))
    (when (< year 100)
      (let* ((this (current-year))
             (past (- this 50))
             (future (+ this 49))
             (maybe-past (+ (- past (mod past 100)) year))
             (maybe-future (+ (- future (mod future 100)) year)))
        (if (>= maybe-past past)
          (setq year maybe-past)
          (setq year maybe-future))))
    ;; 12/31/1899 in some time zones might yield a date after
    ;; the start of the epoch in UTC.
    (check-type year (integer 1899))
    (check-valid-date year month date)
    (let* ((days (+ (1- date)
                    (aref *days-before-month* month)
                    (if (> month 2)
                      (leap-years-before (1+ year))
                      (leap-years-before year))
                    (* (- year 1900) 365)))
           (hours (+ hour (* days 24)))
           (result
            (if time-zone
              (+ second (* (+ minute (* (+ hours time-zone) 60)) 60))
              (let* ((minwest-guess
                      (get-timezone (- (* hours 60 60)
                                       unix-to-universal-time)))
                     (guess (+ minute (* hours 60) minwest-guess))
                     (minwest
                      (get-timezone (- (* guess 60)
                                       unix-to-universal-time))))
                (+ second (* (+ guess (- minwest minwest-guess)) 60))))))
      (if (< result 0)
        (error "Universal time for MM/DD/YYYY ~2,'0d/~2,'0d/~4,'0d ~2,'0d:~2,'0d:~2,'0d ~%with ~a time zone would be negative." month date year hour minute second (if tz-p "specified" "current"))
        result))))


#+windows-target
(defun %windows-sleep (millis)
  (do* ((start (floor (get-internal-real-time)
                      (floor internal-time-units-per-second 1000))
               (floor (get-internal-real-time)
                      (floor internal-time-units-per-second 1000)))
        (millis millis (- stop start))
        (stop (+ start millis)))
       ((or (<= millis 0)
            (not (eql (#_SleepEx millis #$true) #$WAIT_IO_COMPLETION))))))

(defun sleep (seconds)
  "This function causes execution to be suspended for N seconds. N may
  be any non-negative, non-complex number."
  (when (minusp seconds) (report-bad-arg seconds '(real 0 *)))
  #-windows-target
  (multiple-value-bind (secs nanos)
      (nanoseconds seconds)
    (%nanosleep secs nanos))
  #+windows-target
  (%windows-sleep (round (* seconds 1000))))


(defun %internal-run-time ()
  ;; Returns user and system times in internal-time-units as multiple values.
  #-windows-target
  (rlet ((usage :rusage))
    (%%rusage usage)
    (let* ((user-seconds (pref usage :rusage.ru_utime.tv_sec))
           (system-seconds (pref usage :rusage.ru_stime.tv_sec))
           (user-micros (pref usage :rusage.ru_utime.tv_usec))
           (system-micros (pref usage :rusage.ru_stime.tv_usec)))
      (values (+ (* user-seconds internal-time-units-per-second)
                 (round user-micros (floor 1000000 internal-time-units-per-second)))
              (+ (* system-seconds internal-time-units-per-second)
                 (round system-micros (floor 1000000 internal-time-units-per-second))))))
  #+windows-target
  (rlet ((start #>FILETIME)
         (end #>FILETIME)
         (kernel #>FILETIME)
         (user #>FILETIME))
    (#_GetProcessTimes (#_GetCurrentProcess) start end kernel user)
    (let* ((user-100ns (dpb (pref user #>FILETIME.dwHighDateTime)
                            (byte 32 32)
                            (pref user #>FILETIME.dwLowDateTime)))
           (kernel-100ns (dpb (pref kernel #>FILETIME.dwHighDateTime)
                            (byte 32 32)
                            (pref kernel #>FILETIME.dwLowDateTime)))
           (convert (floor 10000000 internal-time-units-per-second)))
      (values (floor user-100ns convert) (floor kernel-100ns convert)))))

(defun get-internal-run-time ()
  "Return the run time in the internal time format. (See
  INTERNAL-TIME-UNITS-PER-SECOND.) This is useful for finding CPU usage."
  (multiple-value-bind (user sys) (%internal-run-time)
    (+ user sys)))

#-(or darwin-target windows-target)
(defloadvar preferred-posix-clock-id
  (rlet ((ts :timespec))
    (if (eql 0 (#_clock_gettime #$CLOCK_MONOTONIC ts))
      #$CLOCK_MONOTONIC
      #$CLOCK_REALTIME)))    

(defun current-time-in-nanoseconds ()
  #-(or darwin-target windows-target)
  (rlet ((ts :timespec))
    (#_clock_gettime preferred-posix-clock-id ts)
    (+ (* (pref ts :timespec.tv_sec) 1000000000)
       (pref ts :timespec.tv_nsec)))
  #+darwin-target (#_mach_absolute_time)
  #+windows-target
  (rlet ((time #>FILETIME))
    (#_GetSystemTimeAsFileTime time)
    (* (logior (pref time #>FILETIME.dwLowDateTime)
               (ash (pref time #>FILETIME.dwHighDateTime) 32))
       100)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/time.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/xref.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;; -*- Mode: Lisp; Package: CCL; indent-tabs-mode: nil -*-
;;;
;;; Copyright 2003 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (export '(*RECORD-XREF-INFO*
            *LOAD-XREF-INFO*
            XREF-ENTRY
            XREF-ENTRY-NAME
            XREF-ENTRY-TYPE
            XREF-ENTRY-FULL-NAME
            XREF-ENTRY-METHOD-QUALIFIERS
            XREF-ENTRY-METHOD-SPECIALIZERS
            XREF-ENTRY-P
            XREF-ENTRY-EQUAL
            DISCARD-ALL-XREF-INFO
            GET-RELATION
            MACROS-CALLED-BY
            START-XREF
            STOP-XREF
            WHO-BINDS
            WHO-CALLS
            WHO-DIRECTLY-CALLS
            WHO-INDIRECTLY-CALLS
            WHO-REFERENCES
            WHO-SETS
            WHO-USES
            WITH-XREF
            XREF-DESCRIBE)))

(defpackage "CROSS-REFERENCE"
  (:use "CL")
  (:nicknames "XREF")
  (:import-from "CCL"
                "*RECORD-XREF-INFO*"
                "*LOAD-XREF-INFO*"
                "XREF-ENTRY"
                "XREF-ENTRY-NAME"
                "XREF-ENTRY-TYPE"
                "XREF-ENTRY-FULL-NAME"
                "XREF-ENTRY-METHOD-QUALIFIERS"
                "XREF-ENTRY-METHOD-SPECIALIZERS"
                "XREF-ENTRY-P"
                "XREF-ENTRY-EQUAL"
                "DISCARD-ALL-XREF-INFO"
                "GET-RELATION"
                "MACROS-CALLED-BY"
                "START-XREF"
                "STOP-XREF"
                "WHO-BINDS"
                "WHO-CALLS"
                "WHO-DIRECTLY-CALLS"
                "WHO-INDIRECTLY-CALLS"
                "WHO-REFERENCES"
                "WHO-SETS"
                "WHO-USES"
                "WITH-XREF"
                "XREF-DESCRIBE")
  (:export "*RECORD-XREF-INFO*"
           "*LOAD-XREF-INFO*"
           "XREF-ENTRY"
           "XREF-ENTRY-NAME"
           "XREF-ENTRY-TYPE"
           "XREF-ENTRY-FULL-NAME"
           "XREF-ENTRY-METHOD-QUALIFIERS"
           "XREF-ENTRY-METHOD-SPECIALIZERS"
           "XREF-ENTRY-P"
           "XREF-ENTRY-EQUAL"
           "DISCARD-ALL-XREF-INFO"
           "GET-RELATION"
           "MACROS-CALLED-BY"
           "START-XREF"
           "STOP-XREF"
           "WHO-BINDS"
           "WHO-CALLS"
           "WHO-DIRECTLY-CALLS"
           "WHO-INDIRECTLY-CALLS"
           "WHO-REFERENCES"
           "WHO-SETS"
           "WHO-USES"
           "WITH-XREF"
           "XREF-DESCRIBE"))


;; *RECORD-XREF-INFO* -- external
;;
;; Cross-referencing information will only be recorded if this flag
;; is set. It is usually set/unset by START-XREF/STOP-XREF
(defvar *record-xref-info* nil
  "Flag indicating wether cross-referencing information should be recorded.")

;; *LOAD-XREF-INFO* -- external
;;
;; FIXME: We don't save any information yet...
(defvar *load-xref-info* nil
  "Flag indicating wether cross-referencing information should be loaded
from FASLs.")



;; START-XREF -- external
;;
(defun start-xref ()
  "Start recording cross-referencing information while compiling."
  (setf *record-xref-info* t)
  (setf *load-xref-info* t)
  t)

;; STOP-XREF -- external
;;
(defun stop-xref ()
  "Stop recording cross-referencing information while compiling."
  (setf *record-xref-info* nil)
  (setf *load-xref-info* nil)
  nil)

;; WITH-XREF -- external
;;
(defmacro with-xref (&body body)
  "Execute BODY with cross-referencing turned on."
  (let ((return-value (gensym "RETURN-VALUE")))
    `(let ((*record-xref-info* t)
           (*load-xref-info* t)
           (,return-value nil))
       (setf ,return-value (progn ,@body))
       ,return-value)))


;; XREF-ENTRY -- external
;;
(defstruct (xref-entry
            (:constructor %make-xref-entry)
            (:print-function %print-xref-entry))
  name
  type
  (method-qualifiers nil)
  (method-specializers nil))

;; %PRINT-XREF-ENTRY -- internal
;;
(defun %print-xref-entry (struct stream d)
  (declare (ignore d))
  (if *print-readably*
      (format stream "#S(xref::xref-entry :name '~A :type '~A :method-qualifiers ~A :method-specializers ~A)"
              (xref-entry-name struct)
              (xref-entry-type struct)
              (xref-entry-method-qualifiers struct)
              (xref-entry-method-specializers struct))
    (print-unreadable-object (struct stream :type t)
      (format stream "~A ~A~@[ ~A~]~@[ ~A~]"
              (xref-entry-name struct)
              (xref-entry-type struct)
              (xref-entry-method-qualifiers struct)
              (xref-entry-method-specializers struct)))))

;; MAKE-XREF-ENTRY -- internal
;;
;; Takes a simple input form and makes a XREF-ENTRY from it. The input is
;; assumed to be a function, macro or variable when a simple symbol is passed,
;; or a method when it is a cons. Since this needs to also handle the ouput
;; from CCL::CALLERS, there is additional hackery trying to do the right thing.
(defun make-xref-entry (input relation)
  (etypecase input
    (symbol
     (let ((type (ecase relation
                   ((:direct-calls :indirect-calls) 'function)
                   ((:binds :sets :references) 'variable)
                   ((:macro-calls) 'macro))))
       (%make-xref-entry :name input :type type)))
    (method
     (let ((name (method-name input))
           (qualifiers (method-qualifiers input))
           (specializers (canonicalize-specializers (method-specializers input))))
       (%make-xref-entry :name name :type 'method
                         :method-qualifiers (unless (eql qualifiers t) qualifiers)
                         :method-specializers specializers)))
    (cons
     (case (car input)
       ((ppc-lap-macro compiler-macro-function)
        (%make-xref-entry :name (cadr input) :type (car input)))
       ((:internal)
        (make-xref-entry (car (last input)) relation))
       (t
        (multiple-value-bind (type name specializers qualifiers)
            (parse-definition-spec input)
          (%make-xref-entry :name name :type type
                            :method-qualifiers (unless (eql qualifiers t) qualifiers)
                            :method-specializers specializers)))))))

(defun parse-definition-spec (form)
  (let ((type t)
        name classes qualifiers)
    (cond
     ((consp form)
      (cond ((eq (car form) 'setf)
             (setq name form))
            (t
             (when (eq (car form) :method) (pop form))
             (setq name (car form))
             (let* ((last (car (last (cdr form)))))
                 (cond ((and (listp last)(or (null last)(neq (car last) 'eql)))
                        (setq classes last)
                        (setq qualifiers (butlast (cdr form))))
                       (t (setq classes (cdr form)))))                   
               (cond ((null qualifiers)
                      (setq qualifiers t))
                     ((equal qualifiers '(:primary))
                      (setq qualifiers nil))))))
     (t (setq name form)))
    (when (setf-function-name-p name)
      (setq name (canonical-maybe-setf-name name)))
    (when (not (or (symbolp name)
                   (setf-function-name-p name)))
      (return-from parse-definition-spec))
    (when (consp qualifiers)
      (mapc #'(lambda (q)
                (when (listp q)
                  (return-from parse-definition-spec)))
          qualifiers))
    (when classes
      (mapc #'(lambda (c)
                (when (not (and c (or (symbolp c)(and (consp c)(eq (car c) 'eql)))))
                  (return-from parse-definition-spec)))
            classes))            
    (when (or (consp classes)(consp qualifiers))(setq type 'method))
    (values type name classes qualifiers)))

;; XREF-ENTRY-EQUAL -- external
;;
;; Simply compares all slots.
(defun xref-entry-equal (entry1 entry2)
  (and (eql (xref-entry-name entry1) (xref-entry-name entry2))
       (eql (xref-entry-type entry1) (xref-entry-type entry2))
       (equal (xref-entry-method-qualifiers entry1)
              (xref-entry-method-qualifiers entry2))
       (equal (xref-entry-method-specializers entry1)
              (xref-entry-method-specializers entry2))))

;; XREF-ENTRY-FULL-NAME -- external
;;
(defun xref-entry-full-name (entry)
  (if (eql (xref-entry-type entry) 'method)
    `(:method ,(xref-entry-name entry)
              ,@(xref-entry-method-qualifiers entry)
              ,(xref-entry-method-specializers entry))
    (xref-entry-name entry)))


;; %DB-KEY-FROM-XREF-ENTRY -- internal
;;
;; This is mostly the inverse to MAKE-XREF-ENTRY, since it takes an entry
;; and returns either a symbol (for functions, macros and variables) or a
;; list in the form (METHOD-NAME QUALIFIERS (SPECIALIZERS)) for a method.
;; These are used as keys in the database hash-tables.
(defun %db-key-from-xref-entry (entry)
  (if (eql (xref-entry-type entry) 'method)
      `(,(xref-entry-name entry)
        ,@(xref-entry-method-qualifiers entry)
        ,(xref-entry-method-specializers entry))
    (xref-entry-name entry)))

;; %SOURCE-FILE-FOR-XREF-ENTRY -- internal
;;
(defun %source-file-for-xref-entry (entry)
  (multiple-value-bind (files name type specializers qualifiers)
      (edit-definition-p (%db-key-from-xref-entry entry)
                         (if (eql (xref-entry-type entry) 'macro)
                             'function
                           (xref-entry-type entry)))
    (declare (ignore name type specializers qualifiers))
    (let ((filename (if (consp files) (cdar files) files)))
      (when filename
        (truename filename)))))


;; MAKE-XREF-DATABASE -- internal
;;
;; This returns a fresh cross-referencing "database". It's a simple association
;; list with two hash-tables per entry. The CAR hash holds the direct entries
;; e.g. KEY calls/references/etc VALUE, while the CDR holds inverse hash (KEY
;; is called/referenced/etc by VALUE.
(defun make-xref-database ()
  (list :binds (cons (make-hash-table :test #'equal)
                     (make-hash-table :test #'equal))
        :references (cons (make-hash-table :test #'equal)
                          (make-hash-table :test #'equal))
        :sets (cons (make-hash-table :test #'equal)
                    (make-hash-table :test #'equal))
        :direct-calls (cons (make-hash-table :test #'equal)
                            (make-hash-table :test #'equal))
        :indirect-calls (cons (make-hash-table :test #'equal)
                              (make-hash-table :test #'equal))
        :macro-calls (cons (make-hash-table :test #'equal)
                           (make-hash-table :test #'equal))))

;; *XREF-DATABASE* -- internal
;;
;; The one and only cross-referencing database.
(defvar *xref-database* (make-xref-database))


;; %XREF-TABLE -- internal
;;
;; Returns the appropriate table for a given relation.
(defun %xref-table (relation inversep)
  (if inversep
      (cdr (getf *xref-database* relation))
    (car (getf *xref-database* relation))))


;; DISCARD-ALL-XREF-INFO -- external
;;
(defun discard-all-xref-info ()
  "Clear the cross-referencing database."
  (setf *xref-database* (make-xref-database))
  t)


;; %ADD-XREF-ENTRY -- internal
;;
;; The compiler adds cross-referencing information by calling this
;; (see NX-RECORD-XREF-INFO).
(defun %add-xref-entry (relation name1 name2)
  (when (and *record-xref-info* relation name1 name2)
    (pushnew (make-xref-entry name2 relation)
             (gethash name1 (%xref-table relation nil))
             :test #'xref-entry-equal)
    (pushnew (make-xref-entry name1 relation)
             (gethash name2 (%xref-table relation t))
             :test #'xref-entry-equal)
    t))




;; %DISCARD-XREF-INFO-FOR-FUNCTION -- internal
;;
;; This rather expensive operation removes all traces of a given function
;; from the cross-referencing database. It needs to be called whenever a
;; function gets redefined, so we don't pick up stale xref entries.
(defun %discard-xref-info-for-function (func)
  ;; need to go through every possible relation
  (dolist (relation '(:direct-calls :indirect-calls :macro-calls
                      :binds :references :sets))
    ;; get a list of the places to which the func points to...
    (dolist (entry (gethash func (%xref-table relation nil)))
      (let ((key (%db-key-from-xref-entry entry)))
        ;; ... and remove it from there
        (setf (gethash key (%xref-table relation t))
              (delete func (gethash key (%xref-table relation t))))))
    ;; the non-inverse case is easy
    (remhash func (%xref-table relation nil))))


;; GET-RELATION -- external
;;
;; FIXME: Implement filtering by files.
;;        And what the heck should errorp do?
(defun get-relation (relation name1 name2 &key in-files in-functions exhaustive errorp)
  "Returns a list of matches for RELATION between NAME1 and NAME2. Results can
be filtered by passing a list of files in IN-FILES or functions in IN-FUNCTIONS.
If EXHAUSTIVE is true, it will also look for callers for which no xref information
is present by looping through all defined functions in memory."
  (when (and (eql name1 :wild) (eql name2 :wild))
    (error "Only one wildcard allowed in a cross-reference query"))
  (ecase relation
    ((:binds :references :sets :direct-calls :indirect-calls :macro-calls)
     (let ((lookup-table (%xref-table relation nil))
           (inverse-lookup-table (%xref-table relation t)))
       (let ((matches (if (eql name1 :wild)
                          (%do-wild-xref-lookup name2 inverse-lookup-table
                                                in-files in-functions)
                        (if (eql name2 :wild)
                            (%do-wild-xref-lookup name1 lookup-table
                                                  in-files in-functions)
                          (%do-simple-xref-lookup name1 name2 lookup-table
                                                  in-files in-functions)))))
         ;; search all lfuns if exhaustive is t
         (when (and exhaustive (eql name1 :wild) (or (eql relation :direct-calls)
                                                     (eql relation :indirect-calls)))
           (dolist (caller (callers name2))
             (pushnew (make-xref-entry caller relation)
                      matches
                      :test #'xref-entry-equal)))
         matches)))
    (:calls
     (let ((direct-calls (get-relation :direct-calls name1 name2
                                       :in-files in-files :in-functions in-functions
                                       :exhaustive exhaustive :errorp errorp))
           (indirect-calls (get-relation :indirect-calls name1 name2
                                         :in-files in-files :in-functions in-functions
                                         :exhaustive exhaustive :errorp errorp))
           (macro-calls (get-relation :macro-calls name1 name2
                                      :in-files in-files :in-functions in-functions
                                      :exhaustive exhaustive :errorp errorp)))
       (if (or (eql name1 :wild) (eql name2 :wild))
           ;; need to weed out possible duplicates here
           (let ((matches nil))
             (dolist (c direct-calls) (pushnew c matches))
             (dolist (c indirect-calls) (pushnew c matches))
             (dolist (c macro-calls) (pushnew c matches))
             matches)
         (when (or direct-calls indirect-calls macro-calls)
           name2))))
    (:uses
     (let ((binds (get-relation :binds name1 name2 :in-files in-files
                                :in-functions in-functions :errorp errorp
                                :exhaustive exhaustive))
           (references (get-relation :binds name1 name2 :in-files in-files
                                     :in-functions in-functions :errorp errorp
                                     :exhaustive exhaustive))
           (sets (get-relation :sets name1 name2 :in-files in-files
                               :in-functions in-functions :errorp errorp
                               :exhaustive exhaustive)))
       (if (or (eql name1 :wild) (eql name2 :wild))
           (concatenate 'list binds references sets)
         (when (or binds references sets)
           name2))))))

;; %DO-WILD-XREF-LOOKUP -- internal
;;
;; Does a wild lookup into the xref database and returns a list of matches.
;;
;; FIXME: implement filtering by files
(defun %do-wild-xref-lookup (name table in-files in-functions)
  (declare (ignore in-files))
  (multiple-value-bind (value foundp) (gethash name table)
    (declare (ignore foundp))
    (if in-functions
        (remove-if (lambda (x) (not (find x in-functions))) value)
      value)))

;; %DO-SIMPLE-XREF-LOOKUP -- internal
;;
;; Does a simple lookup into the xref database and returns NAME2 if a relation
;; between NAME1 and NAME2 exists.
;;
;; FIXME: implement filtering by files
(defun %do-simple-xref-lookup (name1 name2 table in-files in-functions)
  (declare (ignore in-files))
  (when (some (lambda (x)
                (when in-functions
                  (find x in-functions))
                (eql x name2))
              (gethash name1 table))
    name2))


(defun %print-xref-entries (entries stream verbose)
  (dolist (entry entries)
    (if (eql (xref-entry-type entry) 'method)
        ;; print qualifiers and specializers if it's a method
        (format stream "~5,5T~A ~@[~A ~]~A~%"
                (xref-entry-name entry)
                (xref-entry-method-qualifiers entry)
                (xref-entry-method-specializers entry))
      (format stream "~5,5T~A~%" (xref-entry-name entry)))
    ;; print extra information when verbose
    (when verbose
      (format stream "~5,5T  Type: ~A~%" (xref-entry-type entry))
      (let ((file (%source-file-for-xref-entry entry)))
        (format stream "~5,5T  File: ~A~%~%" (if file file "not recorded"))))))


;; WHO-DIRECTLY-CALLS -- external
;;
(defun who-directly-calls (name &key inverse in-files in-functions verbose
                                (stream *standard-output*))
  "Prints information about direct callers of NAME. If INVERSE is true,
it will print direct callees of NAME instead."
  (let ((callers/callees (if inverse
                             (get-relation :direct-calls name :wild 
                                           :in-files in-files
                                           :in-functions in-functions)
                           (get-relation :direct-calls :wild name
                                         :in-files in-files
                                         :in-functions in-functions
                                         :exhaustive t))))
    (format stream "~%~T")
    (if callers/callees
        (progn
          (format stream "~A ~:[is directly called by~;directly calls~]:~%"
                  name inverse)
          (%print-xref-entries callers/callees stream verbose))
      (format stream "No direct ~:[callers~;callees~] of ~A were found in the database~%"
              inverse name)))
  (values))

;; WHO-INDIRECTLY-CALLS -- external
;;
;; FIXME: Implement this (we can't currently detect indirect calls).
(defun who-indirectly-calls (name &key inverse in-files in-functions verbose
                                  (stream *standard-output*))
  "Prints information about indirect callers of NAME. If INVERSE is true,
it will print indirect callees of NAME instead."
  (let ((callers/callees (if inverse
                             (get-relation :indirect-calls name :wild 
                                           :in-files in-files
                                           :in-functions in-functions)
                           (get-relation :indirect-calls :wild name
                                         :in-files in-files
                                         :in-functions in-functions))))
    (format stream "~%~T")
    (if callers/callees
        (progn
          (format stream "~A ~:[is indirectly called by~;indirectly calls~]:~%"
                  name inverse)
          (%print-xref-entries callers/callees stream verbose))
      (format stream "No indirect ~:[callers~;callees~] of ~A were found in the database~%"
              inverse name)))
  (values))

;; MACROS-CALLED-BY -- external
;;
(defun macros-called-by (name &key inverse in-files in-functions verbose
                              (stream *standard-output*))
  "Prints information about macros which get called by NAME. If INVERSE is true,
it will list all functions which macroexpand NAME instead."
    (let ((callers/callees (if (not inverse)
                             (get-relation :macro-calls name :wild 
                                           :in-files in-files
                                           :in-functions in-functions)
                           (get-relation :macro-calls :wild name
                                         :in-files in-files
                                         :in-functions in-functions))))
    (format stream "~%~T")
    (if callers/callees
        (progn
          (format stream "~A ~:[is macro called by~;macro calls~]:~%"
                name (not inverse))
          (%print-xref-entries callers/callees stream verbose))
      (format stream "No macro ~:[callers~;callees~] of ~A were found in the database~%"
              (not inverse) name)))
    (values))

;; WHO-CALLS -- external
;;
(defun who-calls (name &key inverse in-files in-functions verbose
                       (stream *standard-output*))
  "Shorthand for WHO-DIRECTLY-CALLS, WHO-INDIRECTLY-CALLS and
MACROS-CALLED-BY."
  (who-directly-calls name :inverse inverse :stream stream :verbose verbose
                           :in-files in-files :in-functions in-functions)
  (who-indirectly-calls name :inverse inverse :stream stream :verbose verbose
                             :in-files in-files :in-functions in-functions)
  (macros-called-by name :inverse (not inverse) :stream stream :verbose verbose
                         :in-files in-files :in-functions in-functions)
  (values))


;; WHO-BINDS -- external
;;
(defun who-binds (name &key inverse in-files in-functions verbose
                       (stream *standard-output*))
  "Prints a list of functions which bind NAME. If INVERSE is true, it will
print a list of variables bound by NAME instead."
  (let ((bindings (if inverse
                      (get-relation :binds name :wild :in-files in-files
                                    :in-functions in-functions)
                    (get-relation :binds :wild name :in-files in-files
                                  :in-functions in-functions))))
    (format stream "~%~T")
    (if bindings
        (progn
          (format stream "~A ~:[is bound by~;binds~]:" name inverse)
          (%print-xref-entries bindings stream verbose))
      (format stream "No ~:[bindings of~;symbols bound by~] ~A were found in the database~%"
              inverse name)))
  (values))

;; WHO-REFERENCES -- external
;;
(defun who-references (name &key inverse in-files in-functions verbose
                            (stream *standard-output*))
  "Prints a list of functions which reference NAME. If INVERSE is true, it will
print a list of variables referenced by NAME instead."
  (let ((references (if inverse
                        (get-relation :references name :wild :in-files in-files
                                      :in-functions in-functions)
                      (get-relation :references :wild name :in-files in-files
                                    :in-functions in-functions))))
    (format stream "~%~T")
    (if references
        (progn
          (format stream "~A ~:[is referenced by~;references~]:~%" name inverse)
          (%print-xref-entries references stream verbose))
      (format stream "No ~:[references to~;symbols referenced by~] ~A were found in the database~%"
              inverse name)))
  (values))

;; WHO-SETS -- external
;;
(defun who-sets (name &key inverse in-files in-functions verbose
                      (stream *standard-output*))
    "Prints a list of functions which set NAME. If INVERSE is true, it will
print a list of variables set by NAME instead."
  (let ((sets (if inverse
                  (get-relation :sets name :wild :in-files in-files
                                :in-functions in-functions)
                (get-relation :sets :wild name :in-files in-files
                              :in-functions in-functions))))
    (format stream "~%~T")
    (if sets
        (progn
          (format stream "~A ~:[is set by~;sets~]:~%" name inverse)
          (%print-xref-entries sets stream verbose))
      (format stream "No ~:[settings of~;symbols set by~] ~A were found in the database~%"
              inverse name)))
  (values))

;; WHO-USES -- external
;;
(defun who-uses (name &key inverse in-files in-functions verbose
                      (stream *standard-output*))
  "Shorthand for WHO-BINDS, WHO-REFERENCES and WHO-SETS."
  (who-binds name :inverse inverse :stream stream :verbose verbose
                  :in-files in-files :in-functions in-functions)

  (who-references name :inverse inverse :stream stream :verbose verbose
                       :in-files in-files :in-functions in-functions)

  (who-sets name :inverse inverse :stream stream :verbose verbose
                 :in-files in-files :in-functions in-functions)
  (values))


;; XREF-DESCRIBE -- external
;;
(defun xref-describe (name &key verbose)
  "Prints relevant cross-referencing information about NAME."
  (if (fboundp name)
      (progn
        (who-calls name :stream *terminal-io* :verbose verbose)
        (who-calls name :inverse t :stream *terminal-io* :verbose verbose)
        (who-uses name :inverse t :stream *terminal-io* :verbose verbose))
      (who-uses name :stream *terminal-io* :verbose verbose))
  (values))


;;; Hook into the Clozure CL compiler frontend, by pointing a couple
;;; of its variables at our functions.
(setq ccl::*nx-discard-xref-info-hook* #'%discard-xref-info-for-function)
(setq ccl::*nx-add-xref-entry-hook* #'%add-xref-entry)

(provide :xref)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/xref.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/distrib-inits.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;; distrib-inits.lisp

; Things that are in the development environment that need to be
; added to the distribution environment.

; This needs to be compiled after everything is loaded.

(in-package "CCL")

; *def-accessor-types* is used by the inspector to name slots in uvectors
(dolist (cell '#.*def-accessor-types*)
  (add-accessor-types (list (car cell)) (cdr cell)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/distrib-inits.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/dumplisp.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; Dumplisp.lisp

(in-package "CCL")

(defvar *save-exit-functions* nil 
  "List of (0-arg)functions to call before saving memory image")

(defvar *restore-lisp-functions* nil
  "List of (0-arg)functions to call after restoring saved image")


(declaim (special *lisp-system-pointer-functions*)) ; defined in l1-init.

(defun kill-lisp-pointers ()
  (setq * nil ** nil *** nil + nil ++ nil +++ nil - nil
        / nil // nil /// nil
         @ nil)
  (clear-open-file-streams)
  (setf (*%saved-method-var%*) nil)
  (setq *%periodic-tasks%* nil)
  (setq *event-dispatch-task* nil)
  (setq *interactive-abort-process* nil)
  )

(defun clear-ioblock-streams ()
  (%map-areas (lambda (o)
                  (if (typep o 'basic-stream)
                    (let ((s (basic-stream.state o)))
                      (when (and (typep s 'ioblock)
                                 (ioblock-device s)
                                 (>= (ioblock-device s) 0))
                        (setf (basic-stream.state o) nil)))
                    ;; Have to be careful with use of TYPEP here (and
                    ;; in the little bit of Lisp code that runs before
                    ;; the image is saved.)  We may have just done
                    ;; things to forget about (per-session) foreign
                    ;; class addresses, and calling TYPEP on a pointer
                    ;; to such a class might cause us to remember
                    ;; those per-session addresses and confuse the
                    ;; startup code.
                    (if (and (eql (typecode o) target::subtag-instance)
                             (typep o 'buffered-stream-mixin)
                             (slot-boundp o 'ioblock))
                      (let ((s (slot-value o 'ioblock)))
                        (when (and (typep s 'ioblock)
                                   (ioblock-device s)
                                   (>= (ioblock-device s) 0))
                          (setf (slot-value o 'ioblock) nil))))))))

(defun save-application (filename
                         &rest rest
                         &key toplevel-function
			 init-file
                         error-handler application-class
			 clear-clos-caches
                         (purify t)
                         impurify
			 (mode #o644)
			 prepend-kernel
			 #+windows-target (application-type :console)
                         native)
  (declare (ignore toplevel-function error-handler application-class
                   clear-clos-caches init-file impurify))
  #+windows-target (check-type application-type (member :console :gui))
  (unless (probe-file (make-pathname :defaults nil
                                     :directory (pathname-directory (translate-logical-pathname filename))))
    (error "Directory containing ~s does not exist." filename))
  (let* ((kind (%unix-file-kind (defaulted-native-namestring filename))))
    (when (and kind (not (eq kind :file )))
      (error "~S is not a regular file." filename)))
  (let* ((watched (watch)))
    (when watched
      (cerror "Un-watch them." "There are watched objects.")
      (mapc #'unwatch watched)))
  (when (and native prepend-kernel)
    (error "~S and ~S can't both be specified (yet)." :native :prepend-kernel))
  (let* ((ip *initial-process*)
	 (cp *current-process*))
    (when (process-verify-quit ip)
      (let* ((fd (open-dumplisp-file filename
                                     :mode mode
                                     :prepend-kernel prepend-kernel
                                     #+windows-target  #+windows-target 
                                     :application-type application-type)))
        (when native
          #+(or darwinx8632-target darwinx8664-target) (setq fd (- fd))
          #-(or darwinx8632-target darwinx8664-target)
          (progn
            (warn "native image support not available, ignoring ~s option." :native)))
            
        (process-interrupt ip
                           #'(lambda ()
                               (process-exit-application
                                *current-process*
                                #'(lambda ()
                                    (apply #'%save-application-internal
                                           fd
                                           :purify purify
                                           rest))))))
      (unless (eq cp ip)
	(process-kill cp)))))

(defun %save-application-internal (fd &key
                                      toplevel-function ;???? 
                                      error-handler ; meaningless unless application-class or *application* not lisp-development..
                                      application-class
                                      mode
                                      (purify t)
                                      (impurify nil)
                                      (init-file nil init-file-p)
                                      (clear-clos-caches t)
                                      prepend-kernel
                                      #+windows-target application-type
                                      native)
  (declare (ignore mode prepend-kernel #+windows-target application-type native))
  (when (and application-class (neq  (class-of *application*)
                                     (if (symbolp application-class)
                                       (find-class application-class)
                                       application-class)))
    (setq *application* (make-instance application-class)))
  (if (not toplevel-function)
    (setq toplevel-function 
          #'(lambda ()
              (toplevel-function *application*
				 (if init-file-p
				   init-file
				   (application-init-file *application*)))))
    (let* ((user-toplevel-function (coerce-to-function toplevel-function)))
      (setq toplevel-function
            (lambda ()
              (make-mcl-listener-process
               "toplevel"
                *stdin*
                *stdout*
                 #'false
               :initial-function (lambda ()
                                   (catch :toplevel
                                     (funcall user-toplevel-function)
                                     (quit)))
               :close-streams nil
               )
              (%set-toplevel #'housekeeping-loop)
              (toplevel)))))
  (when error-handler
    (make-application-error-handler *application* error-handler))
  
  (if clear-clos-caches (clear-clos-caches))
  (save-image #'(lambda () (%save-application fd
                                              (logior (if impurify 2 0)
                                                      (if purify 1 0))))
              toplevel-function))

(defun save-image (save-function toplevel-function)
  (let ((toplevel #'(lambda () (#_exit -1))))
      (%set-toplevel #'(lambda ()
                         (setf (interrupt-level) -1)
                         (%set-toplevel toplevel)       ; in case *save-exit-functions* error
                         (dolist (f *save-exit-functions*)
                           (funcall f))
                         (kill-lisp-pointers)
                         (clear-ioblock-streams)
                         (with-deferred-gc
                             (let* ((pop *termination-population*))
                               (with-lock-grabbed (*termination-population-lock*)
                                 (setf (population.data pop) nil
                                       (population.termination-list pop) nil))))
                         (%set-toplevel
                          #'(lambda ()
                              (%set-toplevel #'(lambda ()
                                                 (setf (interrupt-level) 0)
                                                 (funcall toplevel-function)))
                              (restore-lisp-pointers)))   ; do startup stuff
                         (funcall save-function)))
      (toplevel)))

;;; If file in-fd contains an embedded lisp image, return the file position
;;; of the start of that image; otherwise, return the file's length.
(defun skip-embedded-image (in-fd)
  (let* ((len (fd-lseek in-fd 0 #$SEEK_END)))
    (if (< len 0)
      (%errno-disp len)
      (%stack-block ((trailer 16))
	(let* ((trailer-pos (fd-lseek in-fd -16 #$SEEK_CUR)))
	  (if (< trailer-pos 0)
	    len
	    (if (not (= 16 (the fixnum (fd-read in-fd trailer 16))))
	      len
	      (if (not (dotimes (i 12 t)
			 (unless (eql (char-code (schar #+big-endian-target "OpenMCLImage"
                                                        #+little-endian-target "nepOILCMegam" i))
				      (%get-unsigned-byte trailer i))
			   (return nil))))
		len
		(let* ((header-pos (fd-lseek in-fd
					     (%get-signed-long
					      trailer
					      12)
					     #$SEEK_CUR)))
		  (if (< header-pos 0)
		    len
                    #+32-bit-target
		    header-pos
                    #-32-bit-target
                    (%stack-block ((header 64))
                      (if (or (/= (fd-read in-fd header 64) 64)
                              (not (dotimes (i 12 t)
                                     (unless (eql (%get-unsigned-byte trailer i)
                                                  (%get-unsigned-byte header i))
                                       (return)))))
                        len
                        (+ header-pos
                           (logior (ash (%get-signed-long header 36) 32)
                                   (%get-unsigned-long header 40)))))))))))))))
                        

		  
;;; Note that Windows executable files are in what they call "PE"
;;; (= "Portable Executable") format, not to be confused with the "PEF"
;;; (= "PowerPC Executable Format" or "Preferred Executable Format")
;;; executable format that Apple used on Classic MacOS.
(defun %prepend-file (out-fd in-fd len #+windows-target application-type)
  (declare (fixnum out-fd in-fd len))
  (fd-lseek in-fd 0 #$SEEK_SET)
  (let* ((bufsize (ash 1 15))
         #+windows-target (first-buf t))
    (%stack-block ((buf bufsize))
      (loop
	  (when (zerop len) (return))
	  (let* ((nread (fd-read in-fd buf (min len bufsize))))
	    (declare (fixnum nread))
	    (if (< nread 0)
	      (%errno-disp nread))
            #+windows-target
            (when (shiftf first-buf nil)
              (let* ((application-byte (ecase application-type
                                         (:console #$IMAGE_SUBSYSTEM_WINDOWS_CUI)
                                         (:gui #$IMAGE_SUBSYSTEM_WINDOWS_GUI)))
                     (offset (%get-long buf (get-field-offset #>IMAGE_DOS_HEADER.e_lfanew))))
                (assert (< offset bufsize) () "PE header not within first ~D bytes" bufsize)
                (assert (= (%get-byte buf (+ offset 0)) (char-code #\P)) ()
                        "File does not appear to be a PE file")
                (assert (= (%get-byte buf (+ offset 1)) (char-code #\E)) ()
                        "File does not appear to be a PE file")
                (assert (= (%get-byte buf (+ offset 2)) 0) ()
                        "File does not appear to be a PE file")
                (assert (= (%get-byte buf (+ offset 3)) 0) ()
                        "File does not appear to be a PE file")
                ;; File is a PE file -- Windows subsystem byte goes at offset 68 in the
                ;;  "optional header" which appears right after the standard header (20 bytes)
                ;;  and the PE cookie (4 bytes)
                (setf (%get-byte buf (+ offset 4 (record-length #>IMAGE_FILE_HEADER) (get-field-offset #>IMAGE_OPTIONAL_HEADER.Subsystem) )) application-byte)))
            (let* ((nwritten (fd-write out-fd buf nread)))
	      (declare (fixnum nwritten))
	      (unless (= nwritten nread)
		(error "I/O error writing to fd ~d" out-fd)))
	    (decf len nread))))))



(defun kernel-path ()
  (let* ((p (%null-ptr)))
    (declare (dynamic-extent p))
    (%get-kernel-global-ptr 'kernel-path p)
    (if (%null-ptr-p p)
      (%realpath (car *command-line-argument-list*))
      (let* ((string (%get-utf-8-cstring p)))
        #+windows-target (nbackslash-to-forward-slash string)
        #+darwin-target (precompose-simple-string string)
        #-(or windows-target darwin-target) string))))


(defun open-dumplisp-file (path &key (mode #o666) prepend-kernel
                           #+windows-target application-type)
  (let* ((prepend-path (if prepend-kernel
                         (if (eq prepend-kernel t)
                           (kernel-path)
                           (defaulted-native-namestring
                            (pathname prepend-kernel)))))
         (prepend-fd (if prepend-path (fd-open prepend-path #$O_RDONLY)))
	 (prepend-len (if prepend-kernel
                        (if (and prepend-fd (>= prepend-fd 0))
                          (skip-embedded-image prepend-fd)
                          (signal-file-error prepend-fd prepend-path))))
	 (filename (defaulted-native-namestring path)))
    (when (probe-file filename)
      (%delete-file filename))
    (when prepend-fd
      ;; Copy the execute mode bits from the prepended "kernel".
      (let ((prepend-fd-mode (nth-value 1 (%fstat prepend-fd))))
	(setq mode (logior (logand prepend-fd-mode #o111) mode))))
    (let* ((image-fd (fd-open filename (logior #$O_WRONLY #$O_CREAT) mode)))
      (unless (>= image-fd 0) (signal-file-error image-fd filename))
      (when prepend-fd
	(%prepend-file image-fd prepend-fd prepend-len #+windows-target application-type))
      (fd-chmod image-fd mode)
      image-fd)))


(defun %save-application (fd &optional (flags 1))
  (let* ((err (%%save-application flags fd)))
    (unless (eql err 0)
      (%err-disp err))))
  

(defun restore-lisp-pointers ()
  (setq *interactive-streams-initialized* nil)
  (setq *heap-ivectors* nil)
  (setq *batch-flag* (not (eql (%get-kernel-global 'batch-flag) 0)))
  (%revive-system-locks)
  (refresh-external-entrypoints)
  (restore-pascal-functions)
  (initialize-interactive-streams)
  (let ((system-ptr-fns (reverse *lisp-system-pointer-functions*))
        (restore-lisp-fns *restore-lisp-functions*)
        (user-pointer-fns *lisp-user-pointer-functions*)
        (lisp-startup-fns *lisp-startup-functions*))
    (unwind-protect
      (with-simple-restart (abort "Abort (possibly crucial) startup functions.")
        (let ((call-with-restart
               #'(lambda (f)
                   (with-simple-restart 
                     (continue "Skip (possibly crucial) startup function ~s."
                               (if (symbolp f) f (function-name f)))
                     (funcall f)))))
          (dolist (f system-ptr-fns) (funcall call-with-restart f))
          (dolist (f restore-lisp-fns) (funcall call-with-restart f))
          (dolist (f (reverse user-pointer-fns)) (funcall call-with-restart f))
          (dolist (f (reverse lisp-startup-fns)) (funcall call-with-restart f))))
      (setf (interrupt-level) 0)))
  nil)


(defun restore-pascal-functions ()
  (reset-callback-storage)
  (when (simple-vector-p %pascal-functions%)
    (dotimes (i (length %pascal-functions%))
      (let ((pfe (%svref %pascal-functions% i)))
        (when (vectorp pfe)
          (let* ((name (pfe.sym pfe))
		 (descriptor (pfe.routine-descriptor pfe)))
	    (%revive-macptr descriptor)
	    (%setf-macptr descriptor (make-callback-trampoline i (pfe.proc-info pfe)))
            (when name
              (set name descriptor))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/dumplisp.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/arrays-fry.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

(in-package "CCL")

(defun bit (bit-array &rest subscripts)
  "Return the bit from the BIT-ARRAY at the specified SUBSCRIPTS."
  (declare (dynamic-extent subscripts))
  (unless (eq (array-element-type bit-array) 'bit)
    (report-bad-arg bit-array '(array bit)))
  (apply #'aref bit-array subscripts))

(defun %bitset (bit-array &rest stuff)
  (declare (dynamic-extent stuff))
  (unless (eq (array-element-type bit-array) 'bit)
    (report-bad-arg bit-array '(array bit)))
  (apply #'aset bit-array stuff))

(defun sbit (v &optional (sub0 nil sub0-p) &rest others)
  "Return the bit from SIMPLE-BIT-ARRAY at the specified SUBSCRIPTS."
  (declare (dynamic-extent others))
  (if sub0-p
    (if others
      (apply #'bit v sub0 others)
      ( sbit (require-type v 'simple-bit-vector) sub0))
    (bit v)))

(defun %sbitset (v sub0 &optional (newval nil newval-p) &rest newval-was-really-sub1)
  (declare (dynamic-extent newval-was-really-sub1))
  (if newval-p
    (if newval-was-really-sub1
      (apply #'%bitset v sub0 newval newval-was-really-sub1)
      (progn
        (unless (typep v 'simple-bit-vector)
          (report-bad-arg v 'simple-bit-vector))
        (uvset v sub0 newval)))
    (%bitset v sub0)))

(defun bit-and (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
   (bit-boole boole-and bit-array1 bit-array2 result-bit-array))

(defun bit-ior (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGIOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole  boole-ior bit-array1 bit-array2 result-bit-array))

(defun bit-xor (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGXOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
   (bit-boole  boole-xor bit-array1 bit-array2 result-bit-array))

(defun bit-eqv (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGEQV on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-eqv bit-array1 bit-array2 result-bit-array))

(defun bit-nand (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGNAND on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-nand bit-array1 bit-array2 result-bit-array))

(defun bit-nor (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGNOR on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-nor bit-array1 bit-array2 result-bit-array))

(defun bit-andc1 (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGANDC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-andc1 bit-array1 bit-array2 result-bit-array))

(defun bit-andc2 (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGANDC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-andc2 bit-array1 bit-array2 result-bit-array))

(defun bit-orc1 (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGORC1 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-orc1 bit-array1 bit-array2 result-bit-array))

(defun bit-orc2 (bit-array1 bit-array2 &optional result-bit-array)
  "Perform a bit-wise LOGORC2 on the elements of BIT-ARRAY-1 and BIT-ARRAY-2,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY-1 is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. All the arrays must have the same rank and dimensions."
  (bit-boole boole-orc2 bit-array1 bit-array2 result-bit-array))

(defun bit-not (bit-array &optional result-bit-array)
  "Performs a bit-wise logical NOT on the elements of BIT-ARRAY,
  putting the results in RESULT-BIT-ARRAY. If RESULT-BIT-ARRAY is T,
  BIT-ARRAY is used. If RESULT-BIT-ARRAY is NIL or omitted, a new array is
  created. Both arrays must have the same rank and dimensions."
  (bit-boole boole-nor bit-array bit-array result-bit-array))

(defun result-bit-array (bit-array-1 bit-array-2 result)
  ; Check that the two bit-array args are bit-arrays with
  ; compatible dimensions.  If "result" is specified as T,
  ; return bit-array-1.  If result is unspecified, return
  ; a new bit-array of the same dimensions as bit-array-2.
  ; Otherwise, make sure that result is a bit-array of the
  ; same dimensions as the other two arguments and return
  ; it.
  (let* ((typecode-1 (typecode bit-array-1))
         (typecode-2 (typecode bit-array-2)))
    (declare (fixnum typecode-1 typecode-2))
    (flet ((bit-array-dimensions (bit-array typecode)
             (declare (fixnum typecode))
             (if (= typecode target::subtag-bit-vector)
               (uvsize bit-array)
               (let* ((array-p (= typecode target::subtag-arrayH))
                      (vector-p (= typecode target::subtag-vectorH)))
                 (if (and (or array-p vector-p) 
                          (= (the fixnum (%array-header-subtype bit-array)) target::subtag-bit-vector))
                   (if vector-p
                     (array-dimension bit-array 0)
                     (array-dimensions bit-array))
                   (report-bad-arg bit-array '(array bit))))))
           (check-matching-dimensions (a1 d1 a2 d2)
             (unless (equal d1 d2)
               (error "~s and ~s have different dimensions." a1 a2))
             a2))
      (let* ((dims-1 (bit-array-dimensions bit-array-1 typecode-1))
             (dims-2 (bit-array-dimensions bit-array-2 typecode-2)))
        (check-matching-dimensions bit-array-1 dims-1 bit-array-2 dims-2)
        (if result
          (if (eq result t)
            bit-array-1
            (check-matching-dimensions bit-array-2 dims-2 result (bit-array-dimensions result (typecode result))))
          (make-array dims-2 :element-type 'bit :initial-element 0))))))




  
(defun bit-boole (opcode array1 array2 result-array)
  (unless (eql opcode (logand 15 opcode))
    (setq opcode (require-type opcode '(mod 16))))
  (let* ((result (result-bit-array array1 array2 result-array)))
    (if (and (typep array1 'simple-bit-vector)
             (typep array2 'simple-bit-vector)
             (typep result 'simple-bit-vector))
      (%simple-bit-boole opcode array1 array2 result)
      (multiple-value-bind (v1 i1) (array-data-and-offset array1)
        (declare (simple-bit-vector v1) (fixnum i1))
        (multiple-value-bind (v2 i2) (array-data-and-offset array2)
          (declare (simple-bit-vector v2) (fixnum i2))
          (multiple-value-bind (v3 i3) (array-data-and-offset result)
            (declare (simple-bit-vector v3) (fixnum i3))
            (let* ((e3 (+ i3 (the fixnum (array-total-size result)))))
              (declare (fixnum e3))
              (do* ( )
                   ((= i3 e3) result)
                (setf (sbit v3 i3) 
                      (logand (boole opcode (sbit v1 i1) (sbit v2 i2)) 1))
                (incf i1)
                (incf i2)
                (incf i3)))))))))


          
          




; shrink-vector is called only in sequences-2. None of the calls depend on
; the side affect of setting the passed-in symbol to the [possibly new]
; returned vector
; Since there hasn't been such a thing as sequences-2 in about 7 years,
; this is especially puzzling.
(eval-when (:compile-toplevel :execute :load-toplevel)
  (defmacro shrink-vector (vector to-size)
    `(setq ,vector (%shrink-vector ,vector ,to-size)))
  )


; new and faulty def
(defun %shrink-vector (vector to-size)
  (cond ((eq (length vector) to-size)
         vector)
        ((array-has-fill-pointer-p vector)
         (setf (fill-pointer vector) to-size)
         vector)
        (t (subseq vector 0 to-size))))


; this could be put into print-db as it was in ccl-pr-4.2
; Or it (and print-db) could just be flushed ... tough one.
(defun multi-dimension-array-to-list (array)
  "Produces a nested list of the elements in array."
  (mdal-aux array (array-dimensions array) nil 
            (array-dimensions array)))

(defun mdal-aux (array all-dimensions use-dimensions 
                       remaining-dimensions)
  (if (= (length all-dimensions) (length use-dimensions))
    (apply 'aref array use-dimensions)
    (do ((index 0 (1+ index))
         (d-length (car remaining-dimensions))
         (result nil))
        ((= d-length index) result)
      (setq result 
            (append result (list (mdal-aux array all-dimensions
                                           (append use-dimensions 
                                                   (list index))
                                           (cdr remaining-dimensions))))))))

(defun adjust-array (array dims
			   &key (element-type nil element-type-p)
			   (initial-element nil initial-element-p)
			   (initial-contents nil initial-contents-p)
			   (fill-pointer nil fill-pointer-p)
			   displaced-to
			   displaced-index-offset
			   &aux (subtype (array-element-subtype array)))
  "Adjust ARRAY's dimensions to the given DIMENSIONS and stuff."
  (when (and element-type-p
             (neq (element-type-subtype element-type) subtype))
    (error "~S is not of element type ~S" array element-type))
  (when (integerp dims)(setq dims (list dims))) ; because %displace-array wants the list
  (if (neq (list-length dims)(array-rank array))
    (error "~S has wrong rank for adjusting to dimensions ~S" array dims))
  (let ((size 1)
        (explicitp nil))
    (dolist (dim dims)
      (when (< dim 0)(report-bad-arg dims '(integer 0 *)))
      (setq size (* size dim)))
    (when (and (neq fill-pointer t)
               (array-has-fill-pointer-p array)
               (< size (or fill-pointer (fill-pointer array))))
      (error "Cannot adjust array ~S to size less than fill pointer ~S"
             array (or fill-pointer (fill-pointer array))))
    (when (and fill-pointer (not (array-has-fill-pointer-p array)))
      (error "~S does not have a fill pointer" array))
    (when (and displaced-index-offset (null displaced-to))
      (error "Cannot specify ~S without ~S" :displaced-index-offset :displaced-to))
    (when (and initial-element-p initial-contents-p)
      (error "Cannot specify both ~S and ~S" :initial-element :initial-contents))
    (cond 
      ((not (adjustable-array-p array))
       (let ((new-array (make-array-1  dims 
                                       (array-element-type array) T
                                       displaced-to
                                       displaced-index-offset
                                       nil
                                       (or fill-pointer
                                           (and (array-has-fill-pointer-p array)
                                                (fill-pointer array)))
                                       initial-element initial-element-p
                                       initial-contents initial-contents-p
                                       size)))
                     
	 (when (and (null initial-contents-p)
		    (null displaced-to))
	   (multiple-value-bind (array-data offs) (array-data-and-offset array)
	     (let ((new-array-data (array-data-and-offset new-array))) 
	       (cond ((null dims)
		      (uvset new-array-data 0 (uvref array-data offs)))
		     (T
		      (init-array-data array-data offs (array-dimensions array) 
				       new-array-data 0 dims))))))
	 (setq array new-array)))
      (T (cond 
	   (displaced-to
	    (if (and displaced-index-offset 
		     (or (not (fixnump displaced-index-offset))
			 (< displaced-index-offset 0)))
	      (report-bad-arg displaced-index-offset '(integer 0 #.most-positive-fixnum)))
	    (when (or initial-element-p initial-contents-p)
	      (error "Cannot specify initial values for displaced arrays"))
	    (unless (eq subtype (array-element-subtype displaced-to))
	      (error "~S is not of element type ~S"
		     displaced-to (array-element-type array)))
	    (do* ((vec displaced-to (displaced-array-p vec)))
		 ((null vec) ())
	      (when (eq vec array)
		(error "Array cannot be displaced to itself.")))
	    (setq explicitp t))
	   (T
	    (setq displaced-to (%alloc-misc size subtype))
	    (cond (initial-element-p
		   (dotimes (i (the fixnum size)) (uvset displaced-to i initial-element)))
		  (initial-contents-p
		   (if (null dims) (uvset displaced-to 0 initial-contents)
                     (init-uvector-contents displaced-to 0 dims initial-contents))))
	    (cond ((null dims)
		   (uvset displaced-to 0 (aref array)))
		  ((not initial-contents-p)
		   (multiple-value-bind (vec offs) (array-data-and-offset array)
		     (init-array-data vec offs (array-dimensions array) displaced-to 0 dims))))))
	 (%displace-array array dims size displaced-to (or displaced-index-offset 0) explicitp)))
    (when fill-pointer-p
      (cond
        ((eq fill-pointer t)
         (set-fill-pointer array size))
        (fill-pointer
         (set-fill-pointer array fill-pointer))))
    array))

(defun array-dims-sizes (dims)
   (if (or (atom dims) (null (%cdr dims))) dims
     (let ((ndims (array-dims-sizes (%cdr dims))))
       (cons (* (%car dims) (%car ndims)) ndims))))

(defun init-array-data (vec off dims nvec noff ndims)
   (init-array-data-aux vec off dims (array-dims-sizes (cdr dims))
                        nvec noff ndims (array-dims-sizes (cdr ndims))))

(defun init-array-data-aux (vec off dims siz nvec noff ndims nsiz)
   (when (null siz)
      (return-from init-array-data-aux
         (init-vector-data vec off (car dims) nvec noff (car ndims))))
   (let ((count (pop dims))
         (size (pop siz))
         (ncount (pop ndims))
         (nsize (pop nsiz)))
     (dotimes (i (if (%i< count ncount) count ncount))
        (declare (fixnum i))
        (init-array-data-aux vec off dims siz nvec noff ndims nsiz)
        (setq off (%i+ off size) noff (%i+ noff nsize)))))

(defun init-vector-data (vec off len nvec noff nlen)
  (dotimes (i (if (%i< len nlen) len nlen))
     (declare (fixnum i))
     (uvset nvec noff (uvref vec off))
     (setq off (%i+ off 1) noff (%i+ noff 1))))

;;; only caller is adjust-array

(defun %displace-array (array dims size data offset explicitp)
  (let* ((typecode (typecode array))
         (array-p (eql typecode target::subtag-arrayH))
         (vector-p (eql typecode target::subtag-vectorH)))
    (unless (or array-p vector-p)
      (error "Array ~S cannot be displaced" array))
    (unless (fixnump offset) (report-bad-arg offset '(integer 0 #.most-positive-fixnum)))
    (unless (adjustable-array-p data)
      (multiple-value-bind (ndata noffset) (displaced-array-p data)
        (if ndata (setq data ndata offset (%i+ offset noffset)))))
    (unless (and (fixnump size) (%i<= (%i+ offset size) (array-total-size data)))
      (error "Offset ~S + size ~S must be less than size of array displaced-to" offset size))
    (let* ((flags (%svref array target::vectorH.flags-cell)))
      (declare (fixnum flags))
      (setf (%svref array target::vectorH.flags-cell)
            (if (> (the fixnum (typecode data)) target::subtag-vectorH)
              (bitclr $arh_disp_bit flags)
              (bitset $arh_disp_bit flags)))
      (setf (%svref array target::vectorH.flags-cell)
            (if explicitp
              (bitset $arh_exp_disp_bit flags)
              (bitclr $arh_exp_disp_bit flags)))
      (setf (%svref array target::arrayH.data-vector-cell) data)
      (if array-p
        (progn
          (do ((i target::arrayH.dim0-cell (1+ i)))
              ((null dims))
            (declare (fixnum i))
            (setf (%svref array i) (pop dims)))
          (setf (%svref array target::arrayH.physsize-cell) size)
          (setf (%svref array target::arrayH.displacement-cell) offset))
        (progn
          (if (or (not (logbitp $arh_fill_bit flags))
                  (> (the fixnum (%svref array target::vectorH.logsize-cell)) size))
            (setf (%svref array target::vectorH.logsize-cell) size))
          (setf (%svref array target::vectorH.physsize-cell) size)
          (setf (%svref array target::vectorH.displacement-cell) offset)))
      array)))



(defun array-row-major-index (array &lexpr subscripts)
  (let ((rank  (array-rank array))
        (nsubs (%lexpr-count subscripts))
        (sum 0))
    (declare (fixnum sum rank))
    (unless (eql rank nsubs)
      (%err-disp $xndims array nsubs))    
      (if (eql 0 rank)
        0
        (do* ((i (1- rank) (1- i))
              (dim (array-dimension array i) (array-dimension array i))
              (last-size 1 size)
              (size dim (* dim size)))
             (nil)
          (declare (fixnum i last-size size))
          (let ((s (%lexpr-ref subscripts nsubs i)))
            (unless (fixnump s)
              (setq s (require-type s 'fixnum)))
            (when (or (< s 0) (>= s dim))
              (%err-disp $XARROOB (%apply-lexpr 'list subscripts) array))
            (incf sum (the fixnum (* s last-size)))
            (when (eql i 0) (return sum)))))))

(defun array-in-bounds-p (array &lexpr subscripts)
  "Return T if the SUBSCIPTS are in bounds for the ARRAY, NIL otherwise."
  (let ((rank  (array-rank array))
        (nsubs (%lexpr-count subscripts)))
    (declare (fixnum nsubs rank))    
    (if (not (eql nsubs rank))
      (%err-disp $xndims array nsubs)
      (if (eql 0 rank)
        0
        (do* ((i (1- rank) (1- i))
              (dim (array-dimension array i) (array-dimension array i)))
             (nil)
          (declare (fixnum i dim))
          (let ((s  (%lexpr-ref subscripts nsubs i)))
	    (if (typep s 'fixnum)
	      (locally (declare (fixnum s))
		(if (or (< s 0)(>= s dim)) (return nil)))
	      (if (typep s 'bignum)
		(return nil)
		(report-bad-arg s 'integer)))
            (when (eql i 0) (return t))))))))

(defun row-major-aref (array index)
  "Return the element of array corressponding to the row-major index. This is
   SETF'able."
  (multiple-value-bind (displaced-to offset) (displaced-array-p array)
    (aref (or displaced-to array) (+ index offset))))

(defun row-major-aset (array index new)
  (multiple-value-bind (displaced-to offset) (displaced-array-p array)
    (setf (aref (or displaced-to array) (+ index offset)) new)))

(defsetf row-major-aref row-major-aset)
             


; end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/arrays-fry.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/edit-callers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
; -*- Mode:Lisp; Package:CCL; -*-
;;;
;;; Copyright 1994-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

; edit-callers.lisp

(in-package "CCL")

(defun global-function-p (random &optional name)
  (let* ((thing random)
         (name (or name (ignore-errors (function-name thing)))))
    (and name
         (or (not (or (symbolp name) (setf-function-name-p name))) ; maybe its (setf baz)
             (let ((fn  (fboundp name)))
               (and fn
                    (progn
		; maybe this is enough for both cases?
                      (or (eq thing fn)
                          (and (symbolp name)(eq thing (macro-function name))))))))
         name)))

(defvar *function-parent-table* nil)
(defvar *function-parent-pool* (%cons-pool))

(defun copying-gc-p () ; if nz copying gc is on
  nil)

(defun lfun-closure-p (lfun)
  (logbitp $lfbits-trampoline-bit (lfun-bits lfun)))

; make a macro ?
(defun puthash-parent (im fun)
  (when (functionp im) ; was (or (functionp im)(eq imtype $sym.fapply))
    (if (global-function-p fun)
      (setf (gethash im *function-parent-table*) fun)
      (let ((ht (gethash im *function-parent-table*)))
        (if (not ht)
          (setf (gethash im *function-parent-table*) fun)
          (unless (eq ht fun)
            (if (consp ht)
              (when (not (memq fun ht))(nconc ht (list fun)))
              (if (not (global-function-p ht))
                (setf (gethash im *function-parent-table*) (list ht fun))))))))))       


(defun callers (function &aux cfun callers gccount retry)
  ;(declare (special cfun function callers))
  (declare (optimize (speed 3)(safety 0)))

  (let ((*function-parent-table* nil))
    (if (setf-function-name-p function)
      (let ((nm (cadr function)))
        (setq function  (or (%setf-method nm)
                            (and (symbolp nm)
                                 (setq nm (setf-function-name nm))
                                 (fboundp nm)
                                 nm)
                            function))))
    (if (and (symbolp function) (fboundp function))
      (setq cfun (symbol-function function)))
    (when (copying-gc-p) (setq gccount (full-gccount)))
    (flet ((do-it (fun)
             (when (and gccount (neq gccount (full-gccount)))
               (throw 'losing :lost))
             (when (possible-caller-function-p fun)
               (let* ((nm (ignore-errors (lfun-name fun)))
                      (globalp (if nm (global-function-p fun nm))))
                 (flet ((do-imm (im)
                          (when (and (or (eq function im)
                                         (and cfun (eq cfun im)))
                                     (neq im nm))                             
                            (push fun callers)) 
                          (when (functionp im) ; was (or (functionp im)(eq imtype $sym.fapply))
                            (if globalp
                              (setf (gethash im *function-parent-table*) fun)
                              (let ((ht (gethash im *function-parent-table*)))
                                (if (not ht)
                                  (setf (gethash im *function-parent-table*) fun)
                                  (unless (eq ht fun)
                                    (if (consp ht)
                                      (when (not (memq fun ht))(nconc ht (list fun)))
                                      (if (not (global-function-p ht))
                                        (setf (gethash im *function-parent-table*) 
                                              (list ht fun)))))))))))
                   (declare (dynamic-extent #'do-imm))                                
                   (%map-lfimms fun #'do-imm ))))))
      (declare (dynamic-extent #'do-it))
      (unwind-protect
           (progn
             (let* ((pool *function-parent-pool*)
                    (tbl (pool.data pool)))
               (setf (pool.data pool) nil
                     *function-parent-table*
                     (if tbl
                       (clrhash tbl)
                       (make-hash-table :size 700 :test 'eq :weak :value))))
             (loop
               (cond ((eq :lost (catch 'losing      
                                  (%map-lfuns #'do-it)))
                      (when retry (error "Callers is losing"))
                      (setq callers nil)
                      (setq retry t))
                     (t (return))))
             (delete-if #'(lambda (thing)
                            (or (functionp thing)
                                (and (typep thing 'method)
                                     (let ((gf (fboundp (method-name thing))))
                                       (not (and (typep gf 'standard-generic-function)
                                                 (memq thing (%gf-methods gf))))))))
                        (delete-duplicates (mapcar 'top-level-caller callers))))
        (setf (pool.data *function-parent-pool*) *function-parent-table*
              *function-parent-table* nil)))))


(defun top-level-caller (function &optional the-list)
  (or (global-function-p function)
      (pascal-function-p function)
      (let ((name (function-name function)))
        (and name (function-encapsulated-p name) name))
      (let ((caller function) next)
        (loop
          (setq next (gethash caller *function-parent-table*))
          (if  next
            (cond ((consp next)
                   (when (null the-list)(push function the-list))
                   (return
                    (dolist (c next)
                      (when (not (memq c the-list))
                        (let ((res (top-level-caller c the-list)))
                          (when (and res (not (functionp res)))
                            (return res)))))))
                  (t (let ((res (global-function-p next)))
                       (when res (return res)))
                     (when (null the-list)(push function the-list))
                     (when (memq next the-list) (return))
                     (push next the-list)
                     (setq caller next)))
            (return caller))))
      function))

(defun possible-caller-function-p (fun)
  (let ((bits (lfun-bits fun)))
    (declare (fixnum bits))
    (not (or (and (logbitp $lfbits-cm-bit bits)
                  (not (logbitp $lfbits-method-bit bits))) ; combined method
             (and (logbitp $lfbits-trampoline-bit bits)
                  (lfun-closure-p fun)
                  (not (global-function-p fun))))))) ; closure (interp or compiled)

  
(defun caller-functions (function &aux cfun callers gccount retry)
  "Returns a list of all functions (actual function objects, not names) that reference FUNCTION"
  (declare (optimize (speed 3)(safety 0)(debug 0)))
  (when (setf-function-name-p function)
    (let ((nm (cadr function)))
      (setq function  (or (%setf-method nm)
                          (and (setq nm (setf-function-name nm))
                               (fboundp nm)
                               nm)
                          function))))
  (when (valid-function-name-p function)
    (setq cfun (or (and (symbolp function) (macro-function function))
                   (fboundp function))))
  (when (copying-gc-p) (setq gccount (full-gccount)))
  (flet ((do-it (fun)
           (when (and gccount (neq gccount (full-gccount)))
             (throw 'losing :lost))
           (when (possible-caller-function-p fun)
             (let* ((lfv (function-to-function-vector fun))
                    (end (%i- (uvsize lfv) 1))
                    (bits (%svref lfv end)))
               ;; Don't count the function name slot as a reference.
               (unless (logbitp $lfbits-noname-bit bits)
                 (decf end))
               ;; Don't count lfun-info  either
               (when (logbitp $lfbits-info-bit bits)
                 (decf end))
               (loop for i from #+ppc-target 1 #+x86-target (%function-code-words fun) #+arm-target 2 below end
                     as im = (%svref lfv i)
                     when (or (eq function im)
                              (and cfun (eq cfun im)))
                       do (return (pushnew (if (%method-function-p fun)
                                             (%method-function-method fun)
                                             fun)
                                           callers)))))))
    (declare (dynamic-extent #'do-it))
    (loop while (eq :lost (catch 'losing      
                            (%map-lfuns #'do-it)))
          do (when retry (cerror "Try again" "Callers is losing"))
          do (setq callers nil)
          do (setq retry t))
    callers))

; in 3.x the function in pascal-functions calls the actual function
(defun pascal-function-p (function)
  (if (find function %pascal-functions%
            :test #'eq
            :key #'(lambda (elt)
                     (if (consp elt)
                       (let ((one (cdr elt)))
                         (when (and (eq (function-name one)(function-name function))
                                    (block blob
                                      (%map-lfimms one #'(lambda (imm)
                                                           (when (eq imm function)
                                                             (return-from blob function))))))
                           function))
                       (if elt (aref elt 2)))))
    (function-name function)))


;;; Calls function f with args (imm) on each immediate in lfv.

(defun %map-lfimms (function-object f)
  (let* ((lfv (function-to-function-vector function-object))
         (n (- (uvsize lfv) 2)))
    (declare (fixnum n))
    #+ppc-target
    (dotimes (i n)
      (funcall f (%svref lfv (%i+ 1 i))))
    #+x86-target
    (do* ((i (1- (the fixnum (%function-code-words function-object))) (1+ i)))
         ((= i n))
      (declare (fixnum i))
      (funcall f (%svref lfv (%i+ 1 i))))
    #+arm-target
    (do* ((i 2 (1+ i)))
         ((>= i n))
      (declare (fixnum i))
      (funcall f (uvref lfv i)))
    ))
         
    


(provide :edit-callers)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/edit-callers.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n











\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1
;;;; BEGIN FILE ./reference/ccl/lib/late-clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2
;;;-*-Mode: LISP; Package: CCL -*-
;;;
;;; Copyright 2007-2009 Clozure Associates
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;; Maybe compile specialized discriminating code (dcode) for generic
;;; functions, if it seems likely that that might perform better than
;;; the general generic-function-dispatch mechanism.


;;; If the GF accepts a fixed number of arguments, return its
;;; lambda list.
(defun gf-fixed-arg-lambda-list (gf)
  (let* ((lambda-list (generic-function-lambda-list gf)))
    (dolist (arg lambda-list lambda-list)
      (when (member arg lambda-list-keywords)
        (return nil)))))

(defun generate-conformance-test (arg-name specializer)
  (cond ((typep specializer 'eql-specializer)
         `(eql ,arg-name ',(eql-specializer-object specializer)))
        ((eq specializer *t-class*))
        ((typep specializer 'standard-class)
         (let* ((wrapper (gensym)))
           `(let* ((,wrapper (if (= (the fixnum (typecode ,arg-name))
                                    target::subtag-instance)
                               (instance.class-wrapper ,arg-name))))
             (and ,wrapper
              (memq ,specializer (or (%wrapper-cpl ,wrapper)
                                                (%inited-class-cpl
                                                 (%wrapper-class ,wrapper))))))))
        (t `(typep ,arg-name ',(class-name specializer)))))

(defun generate-conformance-clause (args method)
  `((and ,@(mapcar #'generate-conformance-test args (method-specializers method)))
     (funcall ,(method-function method) ,@args)))

;;; Generate code to call the single fixed-arg primary method
;;; defined on GF if all args are conformant, or to call
;;; NO-APPLICABLE-METHOD otherwise.
;;; Note that we can often do better than this for accessor
;;; methods (especially reader methods) as a very late (delivery-time)
;;; optimization.
(defun dcode-for-fixed-arg-singleton-gf (gf)
  (let* ((methods (generic-function-methods gf))
         (method (car methods))
         (args (gf-fixed-arg-lambda-list gf)))
    (when (and method
               args
               (null (cdr methods))
               (null (method-qualifiers method))
               (dolist (spec (method-specializers method))
                 (unless (eq spec *t-class*) (return t))))
      (compile nil
               `(lambda ,args
                 (cond ,(generate-conformance-clause args method)
                       (t (no-applicable-method ,gf ,@args))))))))

(register-non-dt-dcode-function #'dcode-for-fixed-arg-singleton-gf)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3
;;;; END FILE ./reference/ccl/lib/late-clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4n









