
(defun array-type (array)
  (case (ldb '(2 . 0) (ival array))
    (2 (case (iref array 1)
	 (3 2)
	 (4 3)
	 (7 4)
	 (t (error "not an array"))))
    (3 (case (jref array 1)
	 (20 0)
	 (116 1)
	 (t (error "not an array"))))
    (t (error "not an array"))))
(defun initial-contents (array subscripts initial-contents)
  (if (= (length subscripts) (array-rank array))
      (apply #'(setf aref) initial-contents array subscripts)
      (let ((i 0))
	(dolist (elem initial-contents)
	  (initial-contents array (append subscripts (list i)) elem)
	  (setf i (+ 1 i))))))
(defun make-array (dimensions &key (element-type t) initial-element
		   initial-contents adjustable fill-pointer displaced-to
		   (displaced-index-offset 0))
  (setf dimensions (designator-list dimensions))
  (setf element-type (upgraded-array-element-type element-type))
  (let* ((simple-vector-p (and (= (length dimensions) 1)
			       (not adjustable)
			       (not fill-pointer)
			       (not displaced-to)))
	 (total-size (apply #'* dimensions))
	 (content (or displaced-to
		      (case element-type
			(bit (makej total-size 116))
			(character (makej (+ 1 (* 8 total-size)) 20))
			(t (makei total-size 3)))))
	 (array (if simple-vector-p
		    content
		    (makei 4 4 total-size
			   (if (= (length dimensions) 1)
			       fill-pointer
			       dimensions)
			   content
			   (when displaced-to displaced-index-offset)))))
    (unless displaced-to
      (if initial-contents
	  (initial-contents array nil initial-contents)
	  (let ((i 0))
	    (tagbody
	     start
	       (when (< i total-size)
		 (setf (aref content i) initial-element)
		 (incf i)
		 (go start))))))
    array))
(defun adjust-array (array dimensions &key element-type initial-element
		     initial-contents fill-pointer displaced-to
		     (displaced-index-offset 0))
  (setq dimensions (designator-list dimensions))
  (case (array-type array)
    ((0 1 2 4) nil)
    (3 (let ((offset (iref array 5)))
	 (if offset
	     nil
	     (if displaced-to
		 nil
		 (let* ((total-size (apply #'* dimensions))
			(content (makei total-size 3)))
		   (dotimes (i (min (iref array 2) total-size))
		     (setf (iref content (+ 2 i))
			   (iref (iref array 4) (+ 2 i))))
		   (when (> total-size (iref array 2))
		     (dotimes (i (- total-size (iref array 2)))
		       (setf (iref content (+ 2 i (iref array 2)))
			     initial-element)))
		   (setf (iref array 2) total-size)
		   (setf (iref array 3)
			 (if (= (length dimensions) 1)
			     (case fill-pointer
			       ((nil) (iref array 3))
			       ((t) total-size)
			       (t fill-pointer))
			     dimensions))
		   (setf (iref array 4) content)))))
       array)))
(defun adjustable-array-p (array)
  (case (array-type array)
    ((0 1 2) nil)
    ((3 4) t)
    (t (error "not an array"))))
(defun aref (array &rest subscripts)
  (row-major-aref array (apply #'array-row-major-index array subscripts)))
(defun (setf aref) (new-element array &rest subscripts)
  (setf (row-major-aref array (apply #'array-row-major-index array subscripts))
	new-element))
(defun array-dimension (array axis-number)
  (nth axis-number (array-dimensions array)))
(defun array-dimensions (array)
  (case (array-type array)
    (0 (list (- (/ (jref array 0) 64) 4)))
    (1 (list (- (/ (jref array 0) 8) 31)))
    (2 (list (/ (iref array 0) 8)))
    ((3 4) (let ((dims/fill (iref array 3)))
	     (if (consp dims/fill) dims/fill (list (iref array 2)))))))
(defun array-has-fill-pointer-p (array)
  (case (array-type array)
    ((3 4) (atom (iref array 3)))
    ((0 1 2) nil)
    (t (error "not an array"))))
(defun array-displacement (array)
  (case (array-type array)
    ((3 4) (let ((offset (iref array 5)))
	     (if offset
		 (values (iref array 4) offset)
		 (values nil 0))))
    ((0 1 2) (values nil 0))
    (t (error "not an array"))))
(defun array-in-bounds-p (array &rest subscripts)
  (dolist (dim (array-dimensions array) t)
    (let ((subscript (pop subscripts)))
      (unless (< subscript dim)
	(return)))))
(defun array-rank (array)
  (length (array-dimensions array)))
(defun array-row-major-index (array &rest subscripts)
  (let ((index 0)
	(last-dim 1))
    (dolist (dim (array-dimensions array))
      (let ((subscript (pop subscripts)))
	(unless (< subscript dim)
	  (error "index out of bounds"))
	(setf index (+ (* last-dim index) subscript))
	(setf last-dim dim)))
    index))
(defun array-total-size (array)
  (case (array-type array)
    ((0 1 2) (length array))
    ((3 4) (iref array 2))
    (t (error "not an array"))))
(defun arrayp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (case (iref object 1)
	 ((3 4 7) t)))
    (3 (case (jref object 1)
	 ((20 116) t)))))
(defun fill-pointer (vector)
  (case (array-type vector)
    ((3 4) (let ((dims/fill (iref vector 3)))
	     (when (consp dims/fill)
	       (error "not a vector"))
	     (unless dims/fill
	       (error "no fill pointer"))
	     dims/fill))
    (t (error "not a vector with fill pointer"))))
(defun (setf fill-pointer) (new-fill-pointer vector)
  (case (array-type vector)
    ((3 4) (let ((dims/fill (iref vector 3)))
	     (when (consp dims/fill)
	       (error "not a vector"))
	     (unless dims/fill
	       (error "no fill pointer"))
	     (setf (iref vector 3) new-fill-pointer)))
    (t (error "not a vector with fill pointer"))))
(defparameter *big-endian* (= (ldb '(8 . 0) (jref "ABCD" 2)) 68))
(if *big-endian*
    (defun row-major-aref (array index)
      (case (array-type array)
	(0 (code-char (ldb (cons 8 (* 8 (- 3 (ldb '(2 . 0) index))))
			   (jref array (+ 2 (/ index 4))))))
	(1 (ldb (cons 1 (ldb '(5 . 0) index)) (jref array (+ 2 (/ index 32)))))
	(2 (iref array (+ 2 index)))
	(3 (row-major-aref (iref array 4) index))
	(4 (error "accessing nil array"))
	(t (error "not an array"))))
    (defun row-major-aref (array index)
      (case (array-type array)
	(0 (code-char (ldb (cons 8 (* 8 (ldb '(2 . 0) index)))
			   (jref array (+ 2 (/ index 4))))))
	(1 (ldb (cons 1 (ldb '(5 . 0) index)) (jref array (+ 2 (/ index 32)))))
	(2 (iref array (+ 2 index)))
	(3 (row-major-aref (iref array 4) index))
	(4 (error "accessing nil array"))
	(t (error "not an array")))))
(if *big-endian*
    (defun (setf row-major-aref) (new-element array index)
      (case (array-type array)
	(0 (multiple-value-bind (index-major index-minor)
	       (floor index 4)
	     (setf (jref array (+ 2 index-major))
		   (dpb (char-code new-element)
			(cons 8 (* 8 (- 3 index-minor)))
			(jref array (+ 2 index-major))))))
	(1 (multiple-value-bind (index-major index-minor)
	       (floor index 32)
	     (setf (jref array (+ 2 index-major))
		   (dpb new-element
			(cons 1 index-minor)
			(jref array (+ 2 index-major))))))
	(2 (setf (iref array (+ 2 index)) new-element))
	(3 (setf (row-major-aref (iref array 4) index) new-element))
	(4 (error "accessing nil array"))
	(t (error "not an array")))
      new-element)
    (defun (setf row-major-aref) (new-element array index)
      (case (array-type array)
	(0 (multiple-value-bind (index-major index-minor)
	       (floor index 4)
	     (setf (jref array (+ 2 index-major))
		   (dpb (char-code new-element)
			(cons 8 (* 8 index-minor))
			(jref array (+ 2 index-major))))))
	(1 (multiple-value-bind (index-major index-minor)
	       (floor index 32)
	     (setf (jref array (+ 2 index-major))
		   (dpb new-element
			(cons 1 index-minor)
			(jref array (+ 2 index-major))))))
	(2 (setf (iref array (+ 2 index)) new-element))
	(3 (setf (row-major-aref (iref array 4) index) new-element))
	(4 (error "accessing nil array"))
	(t (error "not an array")))
      new-element))
(defun upgraded-array-element-type (typespec &optional environment)
  (setf typespec (designator-list typespec))
  (case (car typespec)
    ((base-char character) 'character)
    ((bit) 'bit)
    ((unsigned-byte) (if (and (= (length typespec) 2)
			      (= (second typespec) 1))
			 'bit
			 't))
    ((integer) (if (and (= (length typespec) 3)
			(= (second typespec) 0)
			(= (third typespec) 1))
		   'bit
		   't))
    (t 't)))
(defun simple-vector-p (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (= (iref object 1) 3))
    (3 (member (jref object 1) '(20 116)))))
(defun svref (simple-vector index)
  (aref simple-vector index))
(defun (setf svref) (new-element simple-vector index)
  (setf (aref simple-vector index) new-element))
(defun vector (&rest objects)
  (let ((vector (makei (length objects) 3))
	(i 2))
    (dolist (object objects)
      (setf (iref vector i) object)
      (setf i (+ 1 i)))
    vector))
(defun vector-pop (vector)
  (aref vector (setf (fill-pointer vector) (- (fill-pointer vector) 1))))
(defun vector-push (new-element vector)
  (let ((fill-pointer (fill-pointer vector)))
    (when (< fill-pointer (array-dimension vector 0))
      (setf (aref vector fill-pointer) new-element)
      (setf (fill-pointer vector) (+ 1 fill-pointer))
      fill-pointer)))
(defun vector-push-extend (new-element vector
			   &optional (extension (array-dimension vector 0)))
  (let ((fill-pointer (fill-pointer vector)))
    (unless (< fill-pointer (array-dimension vector 0))
      (adjust-array vector (+ fill-pointer extension)))
    (setf (aref vector fill-pointer) new-element)
    (setf (fill-pointer vector) (+ 1 fill-pointer))
    fill-pointer))
(defun vectorp (object)
  (case (ldb '(2 . 0) (ival object))
    (2 (case (iref object 1)
	 (3 t)
	 ((4 7) (atom (iref object 3)))))
    (3 (member (jref object 1) '(20 116)))))
(defun simple-bit-vector-p (object)
  (and (= (ldb '(2 . 0) (ival object)) 3) (= (jref object 1) 116)))
(defun bit-vector-p (object)
  (let ((tag (ldb '(2 . 0) (ival object))))
    (or (and (= tag 3) (= (jref object 1) 116))
	(and (= tag 2) (= (iref object 1) 4) (bit-vector-p (iref object 4))))))

