

(defun intersection (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (dolist (item list-1)
      (when (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nintersection (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (tagbody
     start
       (unless list-1 (return-from nintersection result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))
	     (setf list-1 (cdr list-1))))
       (go start))))
(defun set-difference (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (dolist (item list-1)
      (unless (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nset-difference (list-1 list-2 &rest rest &key key)
  (let ((result nil))
    (tagbody
     start
       (unless list-1 (return-from nset-difference result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (setf list-1 (cdr list-1))
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))))
       (go start))))
(defmacro pushnew (item place &rest rest)
  `(unless (member ,item ,place ,@rest)
    (push ,item ,place)))
(defun union (list-1 list-2 &rest rest &key key)
  (let ((result list-2))
    (dolist (item list-1)
      (unless (apply #'member (if key (funcall key item) item) list-2 rest)
	(push item result)))
    result))
(defun nunion (list-1 list-2 &rest rest &key key)
  (let ((result list-2))
    (tagbody
     start
       (unless list-1 (return-from nunion result))
       (let ((item (car list-1)))
	 (if (apply #'member (if key (funcall key item) item) list-2 rest)
	     (setf list-1 (cdr list-1))
	     (progn
	       (setf item (cdr list-1))
	       (setf (cdr list-1) result)
	       (setf result list-1)
	       (setf list-1 item))))
       (go start))))
(defun array-element-type (sequence)
  (if (stringp sequence) 'character 't))
(defun copy-seq (sequence)
  (if (listp sequence)
      (copy-list sequence)
      (let ((new-sequence (make-sequence (type-of sequence)
					 (length sequence)))
	    (index 0))
	(tagbody
	 start
	   (when (< index (length sequence))
	     (setf (aref new-sequence index) (aref sequence index))
	     (setf index (+ 1 index))
	     (go start)))
	new-sequence)))

(defun elt (sequence index)
  (if (listp sequence)
      (nth index sequence)
      (aref sequence index)))
(defun (setf elt) (new-object sequence index)
  (if (listp sequence)
      (setf (nth index sequence) new-object)
      (setf (aref sequence index) new-object)))


(defun make-sequence (result-type size &key initial-element)
  (let ((type-head (car (designator-list result-type))))
    (case type-head
      ((list cons null)	(make-list size :initial-element initial-element))
      (string (make-string size :initial-element initial-element))
      (vector (make-array size :initial-element initial-element))
      (t (error 'type-error :datum result-type :expected-type 'sequence)))))
(defun subseq (sequence start &optional end)
  (if (listp sequence)
      (let ((tail (nthcdr start sequence)))
	(if end
	    (let ((result nil))
	      (tagbody
	       start
		 (when (< start end)
		   (push (pop tail) result)
		   (incf start)
		   (go start)))
	      (reverse result))
	    (copy-list tail)))
      (let ((tag (ldb '(2 . 0) (ival sequence))))
	(unless end (setq end (length sequence)))
	(let ((new-sequence (if (= tag 2)
				(if (= (iref sequence 1) 3)
				    (makei (- end start) 3)
				    (return-from subseq
				      (let ((offset (iref sequence 5)))
					(if offset
					    (subseq (iref sequence 4)
						     (+ start offset)
						     (min (length sequence)
							  (+ end offset)))
					    (subseq (iref sequence 4)
						     start end)))))
				(if (= (jref sequence 1) 20)
				    (makej (+ 1 (* 8 (- end start))) 20)
				    (makej (- end start) 116))))
	      (index 0))
	  (tagbody
	   start
	     (when (< start end)
	       (setf (aref new-sequence index) (aref sequence start))
	       (incf index)
	       (incf start)
	       (go start)))
	  new-sequence))))

(defun (setf subseq) (new-subsequence sequence start &optional end)
  (let ((result new-subsequence))
    (if (listp sequence)
	(let ((tail (nthcdr start sequence)))
	  (tagbody
	   start
	     (when (and tail (or (not end) (< start end)))
	       (setf (car tail) (pop new-subsequence))
	       (incf start)
	       (go start))))
	(let ((index 0))
	  (unless end (setq end (length sequence)))
	  (tagbody
	   start
	     (when (< start end)
	       (setf (aref sequence start) (aref new-subsequence index))
	       (incf index)
	       (incf start)
	       (go start)))))
    result))
(defun conc-string (&rest seq)
  (setq seq (mapcar #'designator-string seq))
  (let ((length 0))
    (mapc #'(lambda (string) (setq length (+ length (length string)))) seq)
    (let ((result-string (make-string length)))
      (setq length 0)
      (mapc #'(lambda (string)
		(let ((new-length (+ length (length string))))
		  (setf (subseq result-string length new-length) string)
		  (setq length new-length)))
	    seq)
      result-string)))
(defun designator-list (designator)
  (if (listp designator) designator (list designator)))

