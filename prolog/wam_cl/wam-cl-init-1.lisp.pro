#!/usr/bin/env swipl
%; WAM-CL translated Lisp File (see https://github.com/TeamSPoon/wam_common_lisp/tree/master/prolog/wam_cl )
%; File: "wam-cl-init-1" (/home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp)
%; PWD: /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/
%; Start time: Thu Dec 28 02:35:43 2017

:-style_check(-discontiguous).
:-style_check(-singleton).
:-use_module(library(wamcl_runtime)).

/*
;; #+BUILTIN Means to ignore since it should already be defined
*/
/*
;; #+WAM-CL Means we want it
*/
/*
;; #+LISP500 Means probably we dont want it
*/
/*
;; #+ALT Alternative definition
*/
/*
;; #+ABCL From ABCL
*/
/*
;; #+SBCL From SBCL
*/
/*
;; #+SICL From SICL
*/
/*
;; #+SICL From SICL
*/
/*
(defmacro apropos-defmacro (name ll &rest body)
   `(putprop ',name 'apropos-defmacro '(defmacro ,name ,ll ,@body)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:264 **********************/
:-lisp_compile_to_prolog(pkg_user,[defmacro,'apropos-defmacro',[name,ll,'&rest',body],['#BQ',[putprop,[quote,['#COMMA',name]],[quote,'apropos-defmacro'],[quote,[defmacro,['#COMMA',name],['#COMMA',ll],['#BQ-COMMA-ELIPSE',body]]]]]]).
wl:lambda_def(defmacro, u_apropos_defmacro, f_u_apropos_defmacro, [sys_name, u_ll, c38_rest, u_body], [progn, ['#BQ', [sys_putprop, [quote, ['#COMMA', sys_name]], [quote, u_apropos_defmacro], [quote, [defmacro, ['#COMMA', sys_name], ['#COMMA', u_ll], ['#BQ-COMMA-ELIPSE', u_body]]]]]]).
wl:arglist_info(u_apropos_defmacro, f_u_apropos_defmacro, [sys_name, u_ll, c38_rest, u_body], arginfo{all:[sys_name, u_ll], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_name, u_ll, u_body], opt:0, req:[sys_name, u_ll], rest:[u_body], sublists:0, whole:0}).
wl: init_args(2, f_u_apropos_defmacro).

/*

### Compiled:  `U::APROPOS-DEFMACRO` 
*/
f_u_apropos_defmacro(Name_In, Ll_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_name, Name_In), bv(u_ll, Ll_In), bv(u_body, RestNKeys)|CDR],
	global_env(CDR),
	catch(( get_var(Env, sys_name, Name_Get8),
		get_var(Env, u_body, Body_Get),
		get_var(Env, u_ll, Ll_Get),
		[sys_putprop, [quote, Name_Get8], [quote, u_apropos_defmacro], [quote, [defmacro, Name_Get8, Ll_Get|Body_Get]]]=MFResult
	      ),
	      block_exit(u_apropos_defmacro, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(f_u_apropos_defmacro, classof, claz_macro),
   set_opv(u_apropos_defmacro, compile_as, kw_operator),
   set_opv(u_apropos_defmacro, function, f_u_apropos_defmacro),
   DefMacroResult=u_apropos_defmacro.
/*
:- side_effect(assert_lsp(u_apropos_defmacro,
			  lambda_def(defmacro,
				     u_apropos_defmacro,
				     f_u_apropos_defmacro,
				     [sys_name, u_ll, c38_rest, u_body],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ sys_putprop,
					   [quote, ['#COMMA', sys_name]],
					   [quote, u_apropos_defmacro],
					   
					   [ quote,
					     
					     [ defmacro,
					       ['#COMMA', sys_name],
					       ['#COMMA', u_ll],
					       ['#BQ-COMMA-ELIPSE', u_body]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(u_apropos_defmacro,
			  arglist_info(u_apropos_defmacro,
				       f_u_apropos_defmacro,
				       [sys_name, u_ll, c38_rest, u_body],
				       arginfo{ all:[sys_name, u_ll],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_name, u_ll, u_body],
						opt:0,
						req:[sys_name, u_ll],
						rest:[u_body],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(u_apropos_defmacro,
			  init_args(2, f_u_apropos_defmacro))).
*/
/*
(defmacro apropos-defun (name ll &rest body)
   `(putprop ',name 'apropos-defun '(defun ,name ,ll ,@body)))


;;; define-modify-macro.lisp
;;;
;;; Copyright (C) 2003-2005 Peter Graves
;;; $Id$
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
;;;
;;; As a special exception, the copyright holders of this library give you
;;; permission to link this library with independent modules to produce an
;;; executable, regardless of the license terms of these independent
;;; modules, and to copy and distribute the resulting executable under
;;; terms of your choice, provided that you also meet, for each linked
;;; independent module, the terms and conditions of the license of that
;;; module.  An independent module is a module which is not derived from
;;; or based on this library.  If you modify this library, you may extend
;;; this exception to your version of the library, but you are not
;;; obligated to do so.  If you do not wish to do so, delete this
;;; exception statement from your version.

;;; Adapted from SBCL.

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:390 **********************/
:-lisp_compile_to_prolog(pkg_user,[defmacro,'apropos-defun',[name,ll,'&rest',body],['#BQ',[putprop,[quote,['#COMMA',name]],[quote,'apropos-defun'],[quote,[defun,['#COMMA',name],['#COMMA',ll],['#BQ-COMMA-ELIPSE',body]]]]]]).
wl:lambda_def(defmacro, u_apropos_defun, f_u_apropos_defun, [sys_name, u_ll, c38_rest, u_body], [progn, ['#BQ', [sys_putprop, [quote, ['#COMMA', sys_name]], [quote, u_apropos_defun], [quote, [defun, ['#COMMA', sys_name], ['#COMMA', u_ll], ['#BQ-COMMA-ELIPSE', u_body]]]]]]).
wl:arglist_info(u_apropos_defun, f_u_apropos_defun, [sys_name, u_ll, c38_rest, u_body], arginfo{all:[sys_name, u_ll], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_name, u_ll, u_body], opt:0, req:[sys_name, u_ll], rest:[u_body], sublists:0, whole:0}).
wl: init_args(2, f_u_apropos_defun).

/*

### Compiled:  `U::APROPOS-DEFUN` 
*/
f_u_apropos_defun(Name_In, Ll_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_name, Name_In), bv(u_ll, Ll_In), bv(u_body, RestNKeys)|CDR],
	global_env(CDR),
	catch(( get_var(Env, sys_name, Name_Get8),
		get_var(Env, u_body, Body_Get),
		get_var(Env, u_ll, Ll_Get),
		[sys_putprop, [quote, Name_Get8], [quote, u_apropos_defun], [quote, [defun, Name_Get8, Ll_Get|Body_Get]]]=MFResult
	      ),
	      block_exit(u_apropos_defun, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(f_u_apropos_defun, classof, claz_macro),
   set_opv(u_apropos_defun, compile_as, kw_operator),
   set_opv(u_apropos_defun, function, f_u_apropos_defun),
   DefMacroResult=u_apropos_defun.
/*
:- side_effect(assert_lsp(u_apropos_defun,
			  lambda_def(defmacro,
				     u_apropos_defun,
				     f_u_apropos_defun,
				     [sys_name, u_ll, c38_rest, u_body],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ sys_putprop,
					   [quote, ['#COMMA', sys_name]],
					   [quote, u_apropos_defun],
					   
					   [ quote,
					     
					     [ defun,
					       ['#COMMA', sys_name],
					       ['#COMMA', u_ll],
					       ['#BQ-COMMA-ELIPSE', u_body]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(u_apropos_defun,
			  arglist_info(u_apropos_defun,
				       f_u_apropos_defun,
				       [sys_name, u_ll, c38_rest, u_body],
				       arginfo{ all:[sys_name, u_ll],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_name, u_ll, u_body],
						opt:0,
						req:[sys_name, u_ll],
						rest:[u_body],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(u_apropos_defun, init_args(2, f_u_apropos_defun))).
*/
/*
;; define-modify-macro.lisp
*/
/*
;;
*/
/*
;; Copyright (C) 2003-2005 Peter Graves
*/
/*
;; $Id$
*/
/*
;;
*/
/*
;; This program is free software; you can redistribute it and/or
*/
/*
;; modify it under the terms of the GNU General Public License
*/
/*
;; as published by the Free Software Foundation; either version 2
*/
/*
;; of the License, or (at your option) any later version.
*/
/*
;;
*/
/*
;; This program is distributed in the hope that it will be useful,
*/
/*
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
*/
/*
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*/
/*
;; GNU General Public License for more details.
*/
/*
;;
*/
/*
;; You should have received a copy of the GNU General Public License
*/
/*
;; along with this program; if not, write to the Free Software
*/
/*
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
/*
;;
*/
/*
;; As a special exception, the copyright holders of this library give you
*/
/*
;; permission to link this library with independent modules to produce an
*/
/*
;; executable, regardless of the license terms of these independent
*/
/*
;; modules, and to copy and distribute the resulting executable under
*/
/*
;; terms of your choice, provided that you also meet, for each linked
*/
/*
;; independent module, the terms and conditions of the license of that
*/
/*
;; module.  An independent module is a module which is not derived from
*/
/*
;; or based on this library.  If you modify this library, you may extend
*/
/*
;; this exception to your version of the library, but you are not
*/
/*
;; obligated to do so.  If you do not wish to do so, delete this
*/
/*
;; exception statement from your version.
*/
/*
;; Adapted from SBCL.
*/
/*
(in-package #:system)

;; FIXME See section 5.1.3.
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:2137 **********************/
:-lisp_compile_to_prolog(pkg_user,['in-package','#:system']).
:- cl_in_package(system1, _Ignored).
/*
; FIXME See section 5.1.3.
*/
/*
#+(or (and ABCL ALT) WAM-CL)
(defmacro define-modify-macro (name lambda-list function &optional doc-string)
  "Creates a new read-modify-write macro like PUSH or INCF."
  (let ((other-args nil)
	(rest-arg nil)
	(env (gensym))
	(reference (gensym)))
    ;; Parse out the variable names and &REST arg from the lambda list.
    (do ((ll lambda-list (cdr ll))
	 (arg nil))
	((null ll))
      (setq arg (car ll))
      (cond ((eq arg '&optional))
	    ((eq arg '&rest)
	     (if (symbolp (cadr ll))
		 (setq rest-arg (cadr ll))
		 (error "Non-symbol &REST arg in definition of "#+(or (and ABCL ALT) WAM-CL)\r\n(defmacro define-modify-macro (name lambda-list function &optional doc-string)\r\n  \"Creates a new read-modify-write macro like PUSH or INCF.\"\r\n  (let ((other-args nil)\r\n\t(rest-arg nil)\r\n\t(env (gensym))\r\n\t(reference (gensym)))\r\n    ;; Parse out the variable names and &REST arg from the lambda list.\r\n    (do ((ll lambda-list (cdr ll))\r\n\t (arg nil))\r\n\t((null ll))\r\n      (setq arg (car ll))\r\n      (cond ((eq arg '&optional))\r\n\t    ((eq arg '&rest)\r\n\t     (if (symbolp (cadr ll))\r\n\t\t (setq rest-arg (cadr ll))\r\n\t\t (error \"Non-symbol &REST arg in definition of ~S.\" name))\r\n\t     (if (null (cddr ll))\r\n\t\t (return nil)\r\n\t\t (error \"Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO.\")))\r\n\t    ((memq arg '(&key &allow-other-keys &aux))\r\n\t     (error \"~S not allowed in DEFINE-MODIFY-MACRO lambda list.\" arg))\r\n\t    ((symbolp arg)\r\n\t     (push arg other-args))\r\n\t    ((and (listp arg) (symbolp (car arg)))\r\n\t     (push (car arg) other-args))\r\n\t    (t (error \"Illegal stuff in DEFINE-MODIFY-MACRO lambda list.\"))))\r\n    (setq other-args (nreverse other-args))\r\n    `(eval-when (:compile-toplevel :load-toplevel :execute)\r\n      (defmacro ,name (,reference ,@lambda-list &environment ,env)\r\n        ,doc-string\r\n        (multiple-value-bind (dummies vals newval setter getter)\r\n            (get-setf-expansion ,reference ,env)\r\n          (do ((d dummies (cdr d))\r\n               (v vals (cdr v))\r\n               (let-list nil (cons (list (car d) (car v)) let-list)))\r\n              ((null d)\r\n               (push (list (car newval)\r\n                           ,(if rest-arg\r\n                                `(list* ',function getter ,@other-args ,rest-arg)\r\n                                `(list ',function getter ,@other-args)))\r\n                     let-list)\r\n               `(let* ,(nreverse let-list)\r\n                 ,setter))))))))\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:2191 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'define-modify-macro',[name,'lambda-list',function,'&optional','doc-string'],'$STRING'("Creates a new read-modify-write macro like PUSH or INCF."),[let,[['other-args',[]],['rest-arg',[]],[env,[gensym]],[reference,[gensym]]],[do,[[ll,'lambda-list',[cdr,ll]],[arg,[]]],[[null,ll]],[setq,arg,[car,ll]],[cond,[[eq,arg,[quote,'&optional']]],[[eq,arg,[quote,'&rest']],[if,[symbolp,[cadr,ll]],[setq,'rest-arg',[cadr,ll]],[error,'$STRING'("Non-symbol &REST arg in definition of ~S."),name]],[if,[null,[cddr,ll]],[return,[]],[error,'$STRING'("Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO.")]]],[[memq,arg,[quote,['&key','&allow-other-keys','&aux']]],[error,'$STRING'("~S not allowed in DEFINE-MODIFY-MACRO lambda list."),arg]],[[symbolp,arg],[push,arg,'other-args']],[[and,[listp,arg],[symbolp,[car,arg]]],[push,[car,arg],'other-args']],[t,[error,'$STRING'("Illegal stuff in DEFINE-MODIFY-MACRO lambda list.")]]]],[setq,'other-args',[nreverse,'other-args']],['#BQ',['eval-when',[':compile-toplevel',':load-toplevel',':execute'],[defmacro,['#COMMA',name],[['#COMMA',reference],['#BQ-COMMA-ELIPSE','lambda-list'],'&environment',['#COMMA',env]],['#COMMA','doc-string'],['multiple-value-bind',[dummies,vals,newval,setter,getter],['get-setf-expansion',['#COMMA',reference],['#COMMA',env]],[do,[[d,dummies,[cdr,d]],[v,vals,[cdr,v]],['let-list',[],[cons,[list,[car,d],[car,v]],'let-list']]],[[null,d],[push,[list,[car,newval],['#COMMA',[if,'rest-arg',['#BQ',['list*',[quote,['#COMMA',function]],getter,['#BQ-COMMA-ELIPSE','other-args'],['#COMMA','rest-arg']]],['#BQ',[list,[quote,['#COMMA',function]],getter,['#BQ-COMMA-ELIPSE','other-args']]]]]],'let-list'],['#BQ',['let*',['#COMMA',[nreverse,'let-list']],['#COMMA',setter]]]]]]]]]]]).
doc: doc_string(define_modify_macro,
	      _8637108,
	      function,
	      "Creates a new read-modify-write macro like PUSH or INCF.").

wl:lambda_def(defmacro, define_modify_macro, cl_define_modify_type_macro, [sys_name, sys_lambda_list, function, c38_optional, sys_doc_string], [progn, [let, [[sys_other_args, []], [sys_rest_arg, []], [env, [gensym]], [sys_reference, [gensym]]], [do, [[sys_ll, sys_lambda_list, [cdr, sys_ll]], [sys_arg, []]], [[null, sys_ll]], [setq, sys_arg, [car, sys_ll]], [cond, [[eq, sys_arg, [quote, c38_optional]]], [[eq, sys_arg, [quote, c38_rest]], [if, [symbolp, [cadr, sys_ll]], [setq, sys_rest_arg, [cadr, sys_ll]], [error, '$ARRAY'([*], claz_base_character, "Non-symbol &REST arg in definition of ~S."), sys_name]], [if, [null, [cddr, sys_ll]], [return, []], [error, '$ARRAY'([*], claz_base_character, "Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO.")]]], [[sys_memq, sys_arg, [quote, [c38_key, c38_allow_other_keys, c38_aux]]], [error, '$ARRAY'([*], claz_base_character, "~S not allowed in DEFINE-MODIFY-MACRO lambda list."), sys_arg]], [[symbolp, sys_arg], [push, sys_arg, sys_other_args]], [[and, [listp, sys_arg], [symbolp, [car, sys_arg]]], [push, [car, sys_arg], sys_other_args]], [t, [error, '$ARRAY'([*], claz_base_character, "Illegal stuff in DEFINE-MODIFY-MACRO lambda list.")]]]], [setq, sys_other_args, [nreverse, sys_other_args]], ['#BQ', [eval_when, [kw_compile_toplevel, kw_load_toplevel, kw_execute], [defmacro, ['#COMMA', sys_name], [['#COMMA', sys_reference], ['#BQ-COMMA-ELIPSE', sys_lambda_list], c38_environment, ['#COMMA', env]], ['#COMMA', sys_doc_string], [multiple_value_bind, [sys_dummies, sys_vals, sys_newval, sys_setter, sys_getter], [get_setf_expansion, ['#COMMA', sys_reference], ['#COMMA', env]], [do, [[sys_d, sys_dummies, [cdr, sys_d]], [sys_v, sys_vals, [cdr, sys_v]], [sys_let_list, [], [cons, [list, [car, sys_d], [car, sys_v]], sys_let_list]]], [[null, sys_d], [push, [list, [car, sys_newval], ['#COMMA', [if, sys_rest_arg, ['#BQ', [list_xx, [quote, ['#COMMA', function]], sys_getter, ['#BQ-COMMA-ELIPSE', sys_other_args], ['#COMMA', sys_rest_arg]]], ['#BQ', [list, [quote, ['#COMMA', function]], sys_getter, ['#BQ-COMMA-ELIPSE', sys_other_args]]]]]], sys_let_list], ['#BQ', [let_xx, ['#COMMA', [nreverse, sys_let_list]], ['#COMMA', sys_setter]]]]]]]]]]]).
wl:arglist_info(define_modify_macro, cl_define_modify_type_macro, [sys_name, sys_lambda_list, function, c38_optional, sys_doc_string], arginfo{all:[sys_name, sys_lambda_list, function, sys_doc_string], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_name, sys_lambda_list, function, sys_doc_string], opt:[sys_doc_string], req:[sys_name, sys_lambda_list, function], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_define_modify_type_macro).

/*

### Compiled:  `CL:DEFINE-MODIFY-MACRO` 
*/
cl_define_modify_type_macro(Name_In, Lambda_list_In, Function_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_name, Name_In), bv(sys_lambda_list, Lambda_list_In), bv(function, Function_In), bv(sys_doc_string, Doc_string_In)|Opt_var_Param],
	global_env(Opt_var_Param),
	opt_var(Opt_var_Param,
		sys_doc_string,
		Doc_string_In,
		true,
		[],
		1,
		RestNKeys),
	catch(( cl_gensym(Env_Init),
		cl_gensym(Reference_Init),
		LEnv=[bv(sys_other_args, []), bv(sys_rest_arg, []), bv(env, Env_Init), bv(sys_reference, Reference_Init)|Env],
		get_var(LEnv, sys_lambda_list, Lambda_list_Get),
		AEnv=[bv(sys_ll, Lambda_list_Get), bv(sys_arg, [])|LEnv],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_1), get_var(AEnv, sys_ll, IFTEST82), (IFTEST82==[]->throw(block_exit([], [])), _TBResult=ThrowResult86;get_var(AEnv, sys_ll, Ll_Get89), cl_car(Ll_Get89, Arg), set_var(AEnv, sys_arg, Arg), get_var(AEnv, sys_arg, Arg_Get91), (is_eq(Arg_Get91, c38_optional)->_8994714=[];get_var(AEnv, sys_arg, Arg_Get95), (is_eq(Arg_Get95, c38_rest)->get_var(AEnv, sys_ll, Ll_Get99), cl_cadr(Ll_Get99, PredArgResult101), (is_symbolp(PredArgResult101)->get_var(AEnv, sys_ll, Ll_Get102), cl_cadr(Ll_Get102, TrueResult104), set_var(AEnv, sys_rest_arg, TrueResult104), _9011088=TrueResult104;get_var(AEnv, sys_name, Name_Get103), cl_error(['$ARRAY'([*], claz_base_character, "Non-symbol &REST arg in definition of ~S."), Name_Get103], ElseResult105), _9011088=ElseResult105), get_var(AEnv, sys_ll, Ll_Get108), cl_cddr(Ll_Get108, IFTEST106), (IFTEST106==[]->throw(block_exit([], [])), TrueResult135=ThrowResult110;cl_error('$ARRAY'([*], claz_base_character, "Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO."), ElseResult112), TrueResult135=ElseResult112), ElseResult137=TrueResult135;get_var(AEnv, sys_arg, Arg_Get115), f_sys_memq(Arg_Get115, [c38_key, c38_allow_other_keys, c38_aux], IFTEST113), (IFTEST113\==[]->get_var(AEnv, sys_arg, Arg_Get116), cl_error(['$ARRAY'([*], claz_base_character, "~S not allowed in DEFINE-MODIFY-MACRO lambda list."), Arg_Get116], TrueResult133), ElseResult136=TrueResult133;get_var(AEnv, sys_arg, Arg_Get118), (is_symbolp(Arg_Get118)->cl_push(sys_arg, sys_other_args, TrueResult131), ElseResult134=TrueResult131;get_var(AEnv, sys_arg, Arg_Get124), (is_listp(Arg_Get124)->get_var(AEnv, sys_arg, Arg_Get127), cl_car(Arg_Get127, Symbolp_Param), cl_symbolp(Symbolp_Param, TrueResult128), IFTEST121=TrueResult128;IFTEST121=[]), (IFTEST121\==[]->cl_push([car, sys_arg], sys_other_args, TrueResult129), ElseResult132=TrueResult129;cl_error('$ARRAY'([*], claz_base_character, "Illegal stuff in DEFINE-MODIFY-MACRO lambda list."), ElseResult130), ElseResult132=ElseResult130), ElseResult134=ElseResult132), ElseResult136=ElseResult134), ElseResult137=ElseResult136), _8994714=ElseResult137), get_var(AEnv, sys_ll, Ll_Get138), cl_cdr(Ll_Get138, Ll), set_var(AEnv, sys_ll, Ll), goto(do_label_1, AEnv), _TBResult=_GORES139)),
					
					[ addr(addr_tagbody_1_do_label_1,
					       do_label_1,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_ll, IFTEST), (IFTEST==[]->throw(block_exit([], [])), _9281486=ThrowResult;get_var(AEnv, sys_ll, Ll_Get27), cl_car(Ll_Get27, Car_Ret), set_var(AEnv, sys_arg, Car_Ret), get_var(AEnv, sys_arg, Arg_Get), (is_eq(Arg_Get, c38_optional)->_9281612=[];get_var(AEnv, sys_arg, Arg_Get33), (is_eq(Arg_Get33, c38_rest)->get_var(AEnv, sys_ll, Ll_Get37), cl_cadr(Ll_Get37, Cadr_Ret), (is_symbolp(Cadr_Ret)->get_var(AEnv, sys_ll, Ll_Get40), cl_cadr(Ll_Get40, Cadr_Ret170), set_var(AEnv, sys_rest_arg, Cadr_Ret170), _9281786=Cadr_Ret170;get_var(AEnv, sys_name, Get_var_Ret), cl_error(['$ARRAY'([*], claz_base_character, "Non-symbol &REST arg in definition of ~S."), Get_var_Ret], Error_Ret), _9281786=Error_Ret), get_var(AEnv, sys_ll, Ll_Get46), cl_cddr(Ll_Get46, IFTEST44), (IFTEST44==[]->throw(block_exit([], [])), TrueResult73=ThrowResult48;cl_error('$ARRAY'([*], claz_base_character, "Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO."), ElseResult50), TrueResult73=ElseResult50), ElseResult75=TrueResult73;get_var(AEnv, sys_arg, Arg_Get53), f_sys_memq(Arg_Get53, [c38_key, c38_allow_other_keys, c38_aux], IFTEST51), (IFTEST51\==[]->get_var(AEnv, sys_arg, Arg_Get54), cl_error(['$ARRAY'([*], claz_base_character, "~S not allowed in DEFINE-MODIFY-MACRO lambda list."), Arg_Get54], TrueResult71), ElseResult74=TrueResult71;get_var(AEnv, sys_arg, Arg_Get56), (is_symbolp(Arg_Get56)->cl_push(sys_arg, sys_other_args, TrueResult69), ElseResult72=TrueResult69;get_var(AEnv, sys_arg, Arg_Get62), (is_listp(Arg_Get62)->get_var(AEnv, sys_arg, Arg_Get65), cl_car(Arg_Get65, Symbolp_Param167), cl_symbolp(Symbolp_Param167, TrueResult66), IFTEST59=TrueResult66;IFTEST59=[]), (IFTEST59\==[]->cl_push([car, sys_arg], sys_other_args, TrueResult67), ElseResult70=TrueResult67;cl_error('$ARRAY'([*], claz_base_character, "Illegal stuff in DEFINE-MODIFY-MACRO lambda list."), ElseResult68), ElseResult70=ElseResult68), ElseResult72=ElseResult70), ElseResult74=ElseResult72), ElseResult75=ElseResult74), _9281612=ElseResult75), get_var(AEnv, sys_ll, Ll_Get76), cl_cdr(Ll_Get76, Cdr_Ret), set_var(AEnv, sys_ll, Cdr_Ret), goto(do_label_1, AEnv), _9281486=_GORES)))
					]),
			[]=LetResult15
		      ),
		      block_exit([], LetResult15),
		      true),
		get_var(LEnv, sys_other_args, Other_args_Get),
		cl_nreverse(Other_args_Get, Other_args),
		set_var(LEnv, sys_other_args, Other_args),
		get_var(LEnv, sys_name, Name_Get145),
		get_var(LEnv, sys_lambda_list, Lambda_list_Get147),
		get_var(LEnv, sys_reference, Reference_Get),
		get_var(LEnv, env, Env_Get),
		bq_append([Reference_Get|Lambda_list_Get147],
			  [c38_environment, Env_Get],
			  Bq_append_Ret),
		get_var(LEnv, sys_doc_string, Doc_string_Get),
		get_var(LEnv, env, Env_Get151),
		get_var(LEnv, sys_reference, Reference_Get150),
		get_var(LEnv, sys_rest_arg, IFTEST152),
		(   IFTEST152\==[]
		->  get_var(LEnv, sys_other_args, Other_args_Get155),
		    get_var(LEnv, sys_rest_arg, Rest_arg_Get156),
		    bq_append([sys_getter|Other_args_Get155],
			      [Rest_arg_Get156],
			      Bq_append_Ret175),
		    CAR=[list_xx, [quote, function]|Bq_append_Ret175]
		;   get_var(LEnv, sys_other_args, Other_args_Get157),
		    CAR=[list, [quote, function], sys_getter|Other_args_Get157]
		),
		get_var(LEnv, sys_let_list, Let_list_Get),
		cl_nreverse(Let_list_Get, Nreverse_Ret),
		get_var(LEnv, sys_setter, Setter_Get),
		[eval_when, [kw_compile_toplevel, kw_load_toplevel, kw_execute], [defmacro, Name_Get145, Bq_append_Ret, Doc_string_Get, [multiple_value_bind, [sys_dummies, sys_vals, sys_newval, sys_setter, sys_getter], [get_setf_expansion, Reference_Get150, Env_Get151], [do, [[sys_d, sys_dummies, [cdr, sys_d]], [sys_v, sys_vals, [cdr, sys_v]], [sys_let_list, [], [cons, [list, [car, sys_d], [car, sys_v]], sys_let_list]]], [[null, sys_d], [push, [list, [car, sys_newval], CAR], sys_let_list], [quote, [let_xx, Nreverse_Ret, Setter_Get]]]]]]]=MFResult
	      ),
	      block_exit(define_modify_macro, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_define_modify_type_macro, classof, claz_macro),
   set_opv(define_modify_macro, compile_as, kw_operator),
   set_opv(define_modify_macro, function, cl_define_modify_type_macro),
   DefMacroResult=define_modify_macro.
/*
:- side_effect(assert_lsp(define_modify_macro,
			  doc_string(define_modify_macro,
				     _8637108,
				     function,
				     "Creates a new read-modify-write macro like PUSH or INCF."))).
*/
/*
:- side_effect(assert_lsp(define_modify_macro,
			  lambda_def(defmacro,
				     define_modify_macro,
				     cl_define_modify_type_macro,
				     
				     [ sys_name,
				       sys_lambda_list,
				       function,
				       c38_optional,
				       sys_doc_string
				     ],
				     
				     [ progn,
				       
				       [ let,
					 
					 [ [sys_other_args, []],
					   [sys_rest_arg, []],
					   [env, [gensym]],
					   [sys_reference, [gensym]]
					 ],
					 
					 [ do,
					   
					   [ 
					     [ sys_ll,
					       sys_lambda_list,
					       [cdr, sys_ll]
					     ],
					     [sys_arg, []]
					   ],
					   [[null, sys_ll]],
					   [setq, sys_arg, [car, sys_ll]],
					   
					   [ cond,
					     
					     [ 
					       [ eq,
						 sys_arg,
						 [quote, c38_optional]
					       ]
					     ],
					     
					     [ [eq, sys_arg, [quote, c38_rest]],
					       
					       [ if,
						 [symbolp, [cadr, sys_ll]],
						 
						 [ setq,
						   sys_rest_arg,
						   [cadr, sys_ll]
						 ],
						 
						 [ error,
						   '$ARRAY'([*],
							    claz_base_character,
							    "Non-symbol &REST arg in definition of ~S."),
						   sys_name
						 ]
					       ],
					       
					       [ if,
						 [null, [cddr, sys_ll]],
						 [return, []],
						 
						 [ error,
						   '$ARRAY'([*],
							    claz_base_character,
							    "Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO.")
						 ]
					       ]
					     ],
					     
					     [ 
					       [ sys_memq,
						 sys_arg,
						 
						 [ quote,
						   
						   [ c38_key,
						     c38_allow_other_keys,
						     c38_aux
						   ]
						 ]
					       ],
					       
					       [ error,
						 '$ARRAY'([*],
							  claz_base_character,
							  "~S not allowed in DEFINE-MODIFY-MACRO lambda list."),
						 sys_arg
					       ]
					     ],
					     
					     [ [symbolp, sys_arg],
					       [push, sys_arg, sys_other_args]
					     ],
					     
					     [ 
					       [ and,
						 [listp, sys_arg],
						 [symbolp, [car, sys_arg]]
					       ],
					       
					       [ push,
						 [car, sys_arg],
						 sys_other_args
					       ]
					     ],
					     
					     [ t,
					       
					       [ error,
						 '$ARRAY'([*],
							  claz_base_character,
							  "Illegal stuff in DEFINE-MODIFY-MACRO lambda list.")
					       ]
					     ]
					   ]
					 ],
					 
					 [ setq,
					   sys_other_args,
					   [nreverse, sys_other_args]
					 ],
					 
					 [ '#BQ',
					   
					   [ eval_when,
					     
					     [ kw_compile_toplevel,
					       kw_load_toplevel,
					       kw_execute
					     ],
					     
					     [ defmacro,
					       ['#COMMA', sys_name],
					       
					       [ ['#COMMA', sys_reference],
						 
						 [ '#BQ-COMMA-ELIPSE',
						   sys_lambda_list
						 ],
						 c38_environment,
						 ['#COMMA', env]
					       ],
					       ['#COMMA', sys_doc_string],
					       
					       [ multiple_value_bind,
						 
						 [ sys_dummies,
						   sys_vals,
						   sys_newval,
						   sys_setter,
						   sys_getter
						 ],
						 
						 [ get_setf_expansion,
						   ['#COMMA', sys_reference],
						   ['#COMMA', env]
						 ],
						 
						 [ do,
						   
						   [ 
						     [ sys_d,
						       sys_dummies,
						       [cdr, sys_d]
						     ],
						     
						     [ sys_v,
						       sys_vals,
						       [cdr, sys_v]
						     ],
						     
						     [ sys_let_list,
						       [],
						       
						       [ cons,
							 
							 [ list,
							   [car, sys_d],
							   [car, sys_v]
							 ],
							 sys_let_list
						       ]
						     ]
						   ],
						   
						   [ [null, sys_d],
						     
						     [ push,
						       
						       [ list,
							 [car, sys_newval],
							 
							 [ '#COMMA',
							   
							   [ if,
							     sys_rest_arg,
							     
							     [ '#BQ',
							       
							       [ list_xx,
								 
								 [ quote,
								   ['#COMMA', function]
								 ],
								 sys_getter,
								 
								 [ '#BQ-COMMA-ELIPSE',
								   sys_other_args
								 ],
								 
								 [ '#COMMA',
								   sys_rest_arg
								 ]
							       ]
							     ],
							     
							     [ '#BQ',
							       
							       [ list,
								 
								 [ quote,
								   ['#COMMA', function]
								 ],
								 sys_getter,
								 
								 [ '#BQ-COMMA-ELIPSE',
								   sys_other_args
								 ]
							       ]
							     ]
							   ]
							 ]
						       ],
						       sys_let_list
						     ],
						     
						     [ '#BQ',
						       
						       [ let_xx,
							 
							 [ '#COMMA',
							   
							   [ nreverse,
							     sys_let_list
							   ]
							 ],
							 ['#COMMA', sys_setter]
						       ]
						     ]
						   ]
						 ]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(define_modify_macro,
			  arglist_info(define_modify_macro,
				       cl_define_modify_type_macro,
				       
				       [ sys_name,
					 sys_lambda_list,
					 function,
					 c38_optional,
					 sys_doc_string
				       ],
				       arginfo{ all:
						    [ sys_name,
						      sys_lambda_list,
						      function,
						      sys_doc_string
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_name,
							sys_lambda_list,
							function,
							sys_doc_string
						      ],
						opt:[sys_doc_string],
						req:
						    [ sys_name,
						      sys_lambda_list,
						      function
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(define_modify_macro,
			  init_args(3, cl_define_modify_type_macro))).
*/
/*
; Parse out the variable names and &REST arg from the lambda list.
*/
/*
#+ALT #+ABCL
(define-modify-macro incf-complex (&optional (delta 1)) +
  "The first argument is some location holding a number.  This number is
   incremented by the second argument, DELTA, which defaults to 1.")

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:4066 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':ALT'],[#+,':ABCL',['define-modify-macro','incf-complex',['&optional',[delta,1]],+,'$STRING'("The first argument is some location holding a number.  This number is\r\n   incremented by the second argument, DELTA, which defaults to 1.")]]]))
/*
#+ALT #+ABCL
(define-modify-macro decf-complex (&optional (delta 1)) -
  "The first argument is some location holding a number.  This number is
   decremented by the second argument, DELTA, which defaults to 1.")

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:4285 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':ALT'],[#+,':ABCL',['define-modify-macro','decf-complex',['&optional',[delta,1]],-,'$STRING'("The first argument is some location holding a number.  This number is\r\n   decremented by the second argument, DELTA, which defaults to 1.")]]]))
/*
#+ALT #+ABCL
(defmacro incf (place &optional (delta 1))
  (cond ((symbolp place)
         (cond ((constantp delta)
                `(setq ,place (+ ,place ,delta)))
               (t
                ;; See section 5.1.3.
                (let ((temp (gensym)))
                  `(let ((,temp ,delta))
                     (setq ,place (+ ,place ,temp)))))))
        ((and (consp place) (eq (car place) 'THE))
         (let ((res (gensym)))
           `(let ((,res (the ,(second place) (+ ,place ,delta))))
              (setf ,(third place) ,res))))
        (t
         `(incf-complex ,place ,delta))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:4504 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':ALT'],[#+,':ABCL',[defmacro,incf,[place,'&optional',[delta,1]],[cond,[[symbolp,place],[cond,[[constantp,delta],['#BQ',[setq,['#COMMA',place],[+,['#COMMA',place],['#COMMA',delta]]]]],[t,[let,[[temp,[gensym]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA',delta]]],[setq,['#COMMA',place],[+,['#COMMA',place],['#COMMA',temp]]]]]]]]],[[and,[consp,place],[eq,[car,place],[quote,'THE']]],[let,[[res,[gensym]]],['#BQ',[let,[[['#COMMA',res],[the,['#COMMA',[second,place]],[+,['#COMMA',place],['#COMMA',delta]]]]],[setf,['#COMMA',[third,place]],['#COMMA',res]]]]]],[t,['#BQ',['incf-complex',['#COMMA',place],['#COMMA',delta]]]]]]]]))
/*
; See section 5.1.3.
*/
/*
#+WAM-CL
(defmacro incf (place &optional (delta 1) &environment env)
  "The first argument is some location holding a number.  This number is
incremented by the second argument, DELTA, which defaults to 1."
  (if (and (symbolp (setq place (%symbol-macroexpand place env)))
           (or (constantp delta)
               (and (symbolp delta)
                    (not (nth-value 1 (%symbol-macroexpand delta env))))))
    `(setq ,place (+ ,place ,delta))
    (multiple-value-bind (dummies vals newval setter getter)
        (get-setf-method place env)
      (let ((d (gensym)))
        `(let* (,@(mapcar #'list dummies vals)
                (,d ,delta)
                (,(car newval) (+ ,getter ,d)))
           ,setter)))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:5125 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,incf,[place,'&optional',[delta,1],'&environment',env],'$STRING'("The first argument is some location holding a number.  This number is\r\nincremented by the second argument, DELTA, which defaults to 1."),[if,[and,[symbolp,[setq,place,['%symbol-macroexpand',place,env]]],[or,[constantp,delta],[and,[symbolp,delta],[not,['nth-value',1,['%symbol-macroexpand',delta,env]]]]]],['#BQ',[setq,['#COMMA',place],[+,['#COMMA',place],['#COMMA',delta]]]],['multiple-value-bind',[dummies,vals,newval,setter,getter],['get-setf-method',place,env],[let,[[d,[gensym]]],['#BQ',['let*',[['#BQ-COMMA-ELIPSE',[mapcar,function(list),dummies,vals]],[['#COMMA',d],['#COMMA',delta]],[['#COMMA',[car,newval]],[+,['#COMMA',getter],['#COMMA',d]]]],['#COMMA',setter]]]]]]]).
doc: doc_string(incf,
	      _15624006,
	      function,
	      "The first argument is some location holding a number.  This number is\r\nincremented by the second argument, DELTA, which defaults to 1.").

wl:lambda_def(defmacro, incf, cl_incf, [sys_place, c38_optional, [sys_delta, 1], c38_environment, env], [progn, [if, [and, [symbolp, [setq, sys_place, [sys_pf_symbol_macroexpand, sys_place, env]]], [or, [constantp, sys_delta], [and, [symbolp, sys_delta], [not, [nth_value, 1, [sys_pf_symbol_macroexpand, sys_delta, env]]]]]], ['#BQ', [setq, ['#COMMA', sys_place], [+, ['#COMMA', sys_place], ['#COMMA', sys_delta]]]], [multiple_value_bind, [sys_dummies, sys_vals, sys_newval, sys_setter, sys_getter], [ext_get_setf_method, sys_place, env], [let, [[sys_d, [gensym]]], ['#BQ', [let_xx, [['#BQ-COMMA-ELIPSE', [mapcar, function(list), sys_dummies, sys_vals]], [['#COMMA', sys_d], ['#COMMA', sys_delta]], [['#COMMA', [car, sys_newval]], [+, ['#COMMA', sys_getter], ['#COMMA', sys_d]]]], ['#COMMA', sys_setter]]]]]]]).
wl: declared(cl_incf, env_arg1).

wl:arglist_info(incf, cl_incf, [sys_place, c38_optional, [sys_delta, 1], c38_environment, env], arginfo{all:[sys_place, sys_delta], allow_other_keys:0, aux:0, body:0, complex:[environment], env:[env], key:0, names:[sys_place, sys_delta, env], opt:[sys_delta], req:[sys_place], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_incf).

/*

### Compiled:  `CL:INCF` 
*/
cl_incf(Place_In, RestNKeys, FnResult) :-
	nop(defmacro),
	AEnv=[bv(sys_place, Place_In), bv(sys_delta, Delta_In), bv(env, Env_In)|Opt_var_Param],
	global_env(Opt_var_Param),
	opt_var(Opt_var_Param, sys_delta, Delta_In, true, 1, 1, RestNKeys),
	parent_env(Env_In),
	catch(( get_var(AEnv, env, Env_Get),
		get_var(AEnv, sys_place, Place_Get),
		f_sys_pf_symbol_macroexpand(Place_Get, Env_Get, PredArgResult),
		set_var(AEnv, sys_place, PredArgResult),
		(   is_symbolp(PredArgResult)
		->  (   get_var(AEnv, sys_delta, Delta_Get),
			cl_constantp(Delta_Get, FORM1_Res),
			FORM1_Res\==[],
			TrueResult23=FORM1_Res
		    ->  true
		    ;   get_var(AEnv, sys_delta, Delta_Get18),
			(   is_symbolp(Delta_Get18)
			->  cl_nth_value(1,
					 
					 [ sys_pf_symbol_macroexpand,
					   sys_delta,
					   env
					 ],
					 Not_Param),
			    cl_not(Not_Param, TrueResult),
			    _15651516=TrueResult
			;   _15651516=[]
			),
			TrueResult23=_15651516
		    ),
		    IFTEST=TrueResult23
		;   IFTEST=[]
		),
		(   IFTEST\==[]
		->  get_var(AEnv, sys_delta, Delta_Get26),
		    get_var(AEnv, sys_place, Place_Get24),
		    _15634562=[setq, Place_Get24, [+, Place_Get24, Delta_Get26]]
		;   LEnv=[bv(sys_dummies, []), bv(sys_vals, []), bv(sys_newval, []), bv(sys_setter, []), bv(sys_getter, [])|AEnv],
		    get_var(LEnv, env, Env_Get31),
		    get_var(LEnv, sys_place, Place_Get30),
		    f_ext_get_setf_method(Place_Get30,
					  Env_Get31,
					  Setf_method_Ret),
		    setq_from_values(LEnv,
				     
				     [ sys_dummies,
				       sys_vals,
				       sys_newval,
				       sys_setter,
				       sys_getter
				     ]),
		    cl_gensym(D_Init),
		    LEnv34=[bv(sys_d, D_Init)|LEnv],
		    get_var(LEnv34, sys_dummies, Dummies_Get),
		    get_var(LEnv34, sys_vals, Vals_Get),
		    cl_mapcar(cl_list, [Dummies_Get, Vals_Get], Bq_append_Param),
		    get_var(LEnv34, sys_d, D_Get),
		    get_var(LEnv34, sys_delta, Delta_Get39),
		    get_var(LEnv34, sys_newval, Newval_Get),
		    cl_car(Newval_Get, Car_Ret),
		    get_var(LEnv34, sys_d, D_Get42),
		    get_var(LEnv34, sys_getter, Getter_Get),
		    bq_append(Bq_append_Param,
			      
			      [ [D_Get, Delta_Get39],
				[Car_Ret, [+, Getter_Get, D_Get42]]
			      ],
			      Bq_append_Ret),
		    get_var(LEnv34, sys_setter, Setter_Get),
		    _15634562=[let_xx, Bq_append_Ret, Setter_Get]
		),
		_15634562=MFResult
	      ),
	      block_exit(incf, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_incf, classof, claz_macro),
   set_opv(incf, compile_as, kw_operator),
   set_opv(incf, function, cl_incf),
   DefMacroResult=incf.
/*
:- side_effect(assert_lsp(incf,
			  doc_string(incf,
				     _15624006,
				     function,
				     "The first argument is some location holding a number.  This number is\r\nincremented by the second argument, DELTA, which defaults to 1."))).
*/
/*
:- side_effect(assert_lsp(incf,
			  lambda_def(defmacro,
				     incf,
				     cl_incf,
				     
				     [ sys_place,
				       c38_optional,
				       [sys_delta, 1],
				       c38_environment,
				       env
				     ],
				     
				     [ progn,
				       
				       [ if,
					 
					 [ and,
					   
					   [ symbolp,
					     
					     [ setq,
					       sys_place,
					       
					       [ sys_pf_symbol_macroexpand,
						 sys_place,
						 env
					       ]
					     ]
					   ],
					   
					   [ or,
					     [constantp, sys_delta],
					     
					     [ and,
					       [symbolp, sys_delta],
					       
					       [ not,
						 
						 [ nth_value,
						   1,
						   
						   [ sys_pf_symbol_macroexpand,
						     sys_delta,
						     env
						   ]
						 ]
					       ]
					     ]
					   ]
					 ],
					 
					 [ '#BQ',
					   
					   [ setq,
					     ['#COMMA', sys_place],
					     
					     [ (+),
					       ['#COMMA', sys_place],
					       ['#COMMA', sys_delta]
					     ]
					   ]
					 ],
					 
					 [ multiple_value_bind,
					   
					   [ sys_dummies,
					     sys_vals,
					     sys_newval,
					     sys_setter,
					     sys_getter
					   ],
					   [ext_get_setf_method, sys_place, env],
					   
					   [ let,
					     [[sys_d, [gensym]]],
					     
					     [ '#BQ',
					       
					       [ let_xx,
						 
						 [ 
						   [ '#BQ-COMMA-ELIPSE',
						     
						     [ mapcar,
						       function(list),
						       sys_dummies,
						       sys_vals
						     ]
						   ],
						   
						   [ ['#COMMA', sys_d],
						     ['#COMMA', sys_delta]
						   ],
						   
						   [ 
						     [ '#COMMA',
						       [car, sys_newval]
						     ],
						     
						     [ (+),
						       ['#COMMA', sys_getter],
						       ['#COMMA', sys_d]
						     ]
						   ]
						 ],
						 ['#COMMA', sys_setter]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(incf,
			  arglist_info(incf,
				       cl_incf,
				       
				       [ sys_place,
					 c38_optional,
					 [sys_delta, 1],
					 c38_environment,
					 env
				       ],
				       arginfo{ all:[sys_place, sys_delta],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[environment],
						env:[env],
						key:0,
						names:
						      [ sys_place,
							sys_delta,
							env
						      ],
						opt:[sys_delta],
						req:[sys_place],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(incf, init_args(1, cl_incf))).
*/
/*
#+WAM-CL
(defmacro decf (place &optional (delta 1))
  `(incf ,place (- 0 ,delta)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:5869 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,decf,[place,'&optional',[delta,1]],['#BQ',[incf,['#COMMA',place],[-,0,['#COMMA',delta]]]]]).
wl:lambda_def(defmacro, decf, cl_decf, [sys_place, c38_optional, [sys_delta, 1]], [progn, ['#BQ', [incf, ['#COMMA', sys_place], [-, 0, ['#COMMA', sys_delta]]]]]).
wl:arglist_info(decf, cl_decf, [sys_place, c38_optional, [sys_delta, 1]], arginfo{all:[sys_place, sys_delta], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_place, sys_delta], opt:[sys_delta], req:[sys_place], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_decf).

/*

### Compiled:  `CL:DECF` 
*/
cl_decf(Place_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_place, Place_In), bv(sys_delta, Delta_In)|Opt_var_Param],
	global_env(Opt_var_Param),
	opt_var(Opt_var_Param, sys_delta, Delta_In, true, 1, 1, RestNKeys),
	catch(( get_var(Env, sys_delta, Delta_Get),
		get_var(Env, sys_place, Place_Get),
		[incf, Place_Get, [-, 0, Delta_Get]]=MFResult
	      ),
	      block_exit(decf, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_decf, classof, claz_macro),
   set_opv(decf, compile_as, kw_operator),
   set_opv(decf, function, cl_decf),
   DefMacroResult=decf.
/*
:- side_effect(assert_lsp(decf,
			  lambda_def(defmacro,
				     decf,
				     cl_decf,
				     [sys_place, c38_optional, [sys_delta, 1]],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ incf,
					   ['#COMMA', sys_place],
					   [-, 0, ['#COMMA', sys_delta]]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(decf,
			  arglist_info(decf,
				       cl_decf,
				       [sys_place, c38_optional, [sys_delta, 1]],
				       arginfo{ all:[sys_place, sys_delta],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_place, sys_delta],
						opt:[sys_delta],
						req:[sys_place],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(decf, init_args(1, cl_decf))).
*/
/*
#+ALT #+ABCL
(defmacro decf (place &optional (delta 1))
  (cond ((symbolp place)
         (cond ((constantp delta)
                `(setq ,place (- ,place ,delta)))
               (t
                ;; See section 5.1.3.
                (let ((temp (gensym)))
                  `(let ((,temp ,delta))
                     (setq ,place (- ,place ,temp)))))))
        ((and (consp place) (eq (car place) 'THE))
         (let ((res (gensym)))
           `(let ((,res (the ,(second place) (- ,place ,delta))))
              (setf ,(third place) ,res))))
        (t
         `(decf-complex ,place ,delta))))

;;; setf.lisp
;;;
;;; Copyright (C) 2003-2006 Peter Graves
;;; $Id$
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
;;;
;;; As a special exception, the copyright holders of this library give you
;;; permission to link this library with independent modules to produce an
;;; executable, regardless of the license terms of these independent
;;; modules, and to copy and distribute the resulting executable under
;;; terms of your choice, provided that you also meet, for each linked
;;; independent module, the terms and conditions of the license of that
;;; module.  An independent module is a module which is not derived from
;;; or based on this library.  If you modify this library, you may extend
;;; this exception to your version of the library, but you are not
;;; obligated to do so.  If you do not wish to do so, delete this
;;; exception statement from your version.

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:5957 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':ALT'],[#+,':ABCL',[defmacro,decf,[place,'&optional',[delta,1]],[cond,[[symbolp,place],[cond,[[constantp,delta],['#BQ',[setq,['#COMMA',place],[-,['#COMMA',place],['#COMMA',delta]]]]],[t,[let,[[temp,[gensym]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA',delta]]],[setq,['#COMMA',place],[-,['#COMMA',place],['#COMMA',temp]]]]]]]]],[[and,[consp,place],[eq,[car,place],[quote,'THE']]],[let,[[res,[gensym]]],['#BQ',[let,[[['#COMMA',res],[the,['#COMMA',[second,place]],[-,['#COMMA',place],['#COMMA',delta]]]]],[setf,['#COMMA',[third,place]],['#COMMA',res]]]]]],[t,['#BQ',['decf-complex',['#COMMA',place],['#COMMA',delta]]]]]]]]))
/*
; See section 5.1.3.
*/
/*
;; setf.lisp
*/
/*
;;
*/
/*
;; Copyright (C) 2003-2006 Peter Graves
*/
/*
;; $Id$
*/
/*
;;
*/
/*
;; This program is free software; you can redistribute it and/or
*/
/*
;; modify it under the terms of the GNU General Public License
*/
/*
;; as published by the Free Software Foundation; either version 2
*/
/*
;; of the License, or (at your option) any later version.
*/
/*
;;
*/
/*
;; This program is distributed in the hope that it will be useful,
*/
/*
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
*/
/*
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*/
/*
;; GNU General Public License for more details.
*/
/*
;;
*/
/*
;; You should have received a copy of the GNU General Public License
*/
/*
;; along with this program; if not, write to the Free Software
*/
/*
;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
/*
;;
*/
/*
;; As a special exception, the copyright holders of this library give you
*/
/*
;; permission to link this library with independent modules to produce an
*/
/*
;; executable, regardless of the license terms of these independent
*/
/*
;; modules, and to copy and distribute the resulting executable under
*/
/*
;; terms of your choice, provided that you also meet, for each linked
*/
/*
;; independent module, the terms and conditions of the license of that
*/
/*
;; module.  An independent module is a module which is not derived from
*/
/*
;; or based on this library.  If you modify this library, you may extend
*/
/*
;; this exception to your version of the library, but you are not
*/
/*
;; obligated to do so.  If you do not wish to do so, delete this
*/
/*
;; exception statement from your version.
*/
/*
(in-package "SYSTEM")

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:8170 **********************/
:-lisp_compile_to_prolog(pkg_sys,['in-package','$STRING'("SYSTEM")]).
:- cl_in_package('$ARRAY'([*], claz_base_character, "SYSTEM"), _Ignored).
/*
#+(or ABCL WAM-CL)
(defun get-setf-method-inverse (form inverse setf-function)
  (let ((new-var (gensym))
        (vars nil)
        (vals nil))
    (dolist (x (cdr form))
      (push (gensym) vars)
      (push x vals))
    (setq vals (nreverse vals))
    (values vars vals (list new-var)
            (if setf-function
                `(,@inverse ,new-var ,@vars)
                (if (functionp (car inverse))
                    `(funcall ,@inverse ,@vars ,new-var)
                    `(,@inverse ,@vars ,new-var)))
            `(,(car form) ,@vars))))

;;; If a macro, expand one level and try again.  If not, go for the
;;; SETF function.
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:8195 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'get-setf-method-inverse',[form,inverse,'setf-function'],[let,[['new-var',[gensym]],[vars,[]],[vals,[]]],[dolist,[x,[cdr,form]],[push,[gensym],vars],[push,x,vals]],[setq,vals,[nreverse,vals]],[values,vars,vals,[list,'new-var'],[if,'setf-function',['#BQ',[['#BQ-COMMA-ELIPSE',inverse],['#COMMA','new-var'],['#BQ-COMMA-ELIPSE',vars]]],[if,[functionp,[car,inverse]],['#BQ',[funcall,['#BQ-COMMA-ELIPSE',inverse],['#BQ-COMMA-ELIPSE',vars],['#COMMA','new-var']]],['#BQ',[['#BQ-COMMA-ELIPSE',inverse],['#BQ-COMMA-ELIPSE',vars],['#COMMA','new-var']]]]],['#BQ',[['#COMMA',[car,form]],['#BQ-COMMA-ELIPSE',vars]]]]]]).
wl:lambda_def(defun, sys_get_setf_method_inverse, f_sys_get_setf_method_inverse, [sys_form, sys_inverse, sys_setf_function], [[let, [[sys_new_var, [gensym]], [sys_vars, []], [sys_vals, []]], [dolist, [sys_x, [cdr, sys_form]], [push, [gensym], sys_vars], [push, sys_x, sys_vals]], [setq, sys_vals, [nreverse, sys_vals]], [values, sys_vars, sys_vals, [list, sys_new_var], [if, sys_setf_function, ['#BQ', [['#BQ-COMMA-ELIPSE', sys_inverse], ['#COMMA', sys_new_var], ['#BQ-COMMA-ELIPSE', sys_vars]]], [if, [functionp, [car, sys_inverse]], ['#BQ', [funcall, ['#BQ-COMMA-ELIPSE', sys_inverse], ['#BQ-COMMA-ELIPSE', sys_vars], ['#COMMA', sys_new_var]]], ['#BQ', [['#BQ-COMMA-ELIPSE', sys_inverse], ['#BQ-COMMA-ELIPSE', sys_vars], ['#COMMA', sys_new_var]]]]], ['#BQ', [['#COMMA', [car, sys_form]], ['#BQ-COMMA-ELIPSE', sys_vars]]]]]]).
wl:arglist_info(sys_get_setf_method_inverse, f_sys_get_setf_method_inverse, [sys_form, sys_inverse, sys_setf_function], arginfo{all:[sys_form, sys_inverse, sys_setf_function], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_form, sys_inverse, sys_setf_function], opt:0, req:[sys_form, sys_inverse, sys_setf_function], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_get_setf_method_inverse).

/*

### Compiled:  `SYS::GET-SETF-METHOD-INVERSE` 
*/
f_sys_get_setf_method_inverse(Form_In, Inverse_In, Setf_function_In, FnResult) :-
	Env43=[bv(sys_form, Form_In), bv(sys_inverse, Inverse_In), bv(sys_setf_function, Setf_function_In)|Env],
	global_env(Env),
	catch(( cl_gensym(New_var_Init),
		LEnv=[bv(sys_new_var, New_var_Init), bv(sys_vars, []), bv(sys_vals, [])|Env43],
		get_var(LEnv, sys_form, Form_Get),
		cl_cdr(Form_Get, List),
		BV=bv(sys_x, Ele),
		Env2=[BV|LEnv],
		forall(member(Ele, List),
		       ( nb_setarg(2, BV, Ele),
			 cl_push([gensym], sys_vars, Vars),
			 cl_push(sys_x, sys_vals, Vals)
		       )),
		get_var(LEnv, sys_vals, Vals_Get),
		cl_nreverse(Vals_Get, Vals46),
		set_var(LEnv, sys_vals, Vals46),
		get_var(LEnv, sys_new_var, New_var_Get),
		get_var(LEnv, sys_vals, Vals_Get17),
		CAR51=New_var_Get,
		get_var(LEnv, sys_setf_function, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sys_inverse, Inverse_Get),
		    get_var(LEnv, sys_new_var, New_var_Get23),
		    get_var(LEnv, sys_vars, Vars_Get),
		    bq_append(Inverse_Get,
			      [New_var_Get23|Vars_Get],
			      TrueResult37),
		    CAR=TrueResult37
		;   get_var(LEnv, sys_inverse, Inverse_Get26),
		    cl_car(Inverse_Get26, PredArgResult),
		    (   is_functionp(PredArgResult)
		    ->  get_var(LEnv, sys_inverse, Inverse_Get29),
			get_var(LEnv, sys_new_var, New_var_Get31),
			get_var(LEnv, sys_vars, Vars_Get30),
			bq_append(Vars_Get30, [New_var_Get31], Bq_append_Ret),
			bq_append([funcall|Inverse_Get29],
				  Bq_append_Ret,
				  TrueResult),
			ElseResult38=TrueResult
		    ;   get_var(LEnv, sys_inverse, Inverse_Get32),
			get_var(LEnv, sys_new_var, New_var_Get34),
			get_var(LEnv, sys_vars, Vars_Get33),
			bq_append(Vars_Get33, [New_var_Get34], Bq_append_Ret48),
			bq_append(Inverse_Get32, Bq_append_Ret48, ElseResult),
			ElseResult38=ElseResult
		    ),
		    CAR=ElseResult38
		),
		get_var(LEnv, sys_form, Form_Get39),
		cl_car(Form_Get39, Car_Ret),
		get_var(LEnv, sys_vars, Vars_Get40),
		nb_setval('$mv_return',
			  [sys_vars, Vals_Get17, CAR51, CAR, [Car_Ret|Vars_Get40]]),
		sys_vars=FnResult
	      ),
	      block_exit(sys_get_setf_method_inverse, FnResult),
	      true).
:- set_opv(f_sys_get_setf_method_inverse, classof, claz_function),
   set_opv(sys_get_setf_method_inverse, compile_as, kw_function),
   set_opv(sys_get_setf_method_inverse, function, f_sys_get_setf_method_inverse),
   DefunResult=sys_get_setf_method_inverse.

/*
;; If a macro, expand one level and try again.  If not, go for the
*/
/*
;; SETF function.
*/
/*
#+(or ABCL WAM-CL)
(defun expand-or-get-setf-inverse (form environment)
  (multiple-value-bind (expansion expanded)
      (macroexpand-1 form environment)
    (if expanded
        (get-setf-expansion expansion environment)
        (get-setf-method-inverse form `(funcall #'(setf ,(car form)))
                                 t))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:8857 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'expand-or-get-setf-inverse',[form,environment],['multiple-value-bind',[expansion,expanded],['macroexpand-1',form,environment],[if,expanded,['get-setf-expansion',expansion,environment],['get-setf-method-inverse',form,['#BQ',[funcall,function([setf,['#COMMA',[car,form]]])]],t]]]]).
wl:lambda_def(defun, sys_expand_or_get_setf_inverse, f_sys_expand_or_get_setf_inverse, [sys_form, sys_environment], [[multiple_value_bind, [sys_expansion, sys_expanded], [macroexpand_1, sys_form, sys_environment], [if, sys_expanded, [get_setf_expansion, sys_expansion, sys_environment], [sys_get_setf_method_inverse, sys_form, ['#BQ', [funcall, function([setf, ['#COMMA', [car, sys_form]]])]], t]]]]).
wl:arglist_info(sys_expand_or_get_setf_inverse, f_sys_expand_or_get_setf_inverse, [sys_form, sys_environment], arginfo{all:[sys_form, sys_environment], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_form, sys_environment], opt:0, req:[sys_form, sys_environment], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_expand_or_get_setf_inverse).

/*

### Compiled:  `SYS::EXPAND-OR-GET-SETF-INVERSE` 
*/
f_sys_expand_or_get_setf_inverse(Form_In, Environment_In, FnResult) :-
	Env20=[bv(sys_form, Form_In), bv(sys_environment, Environment_In)|Env],
	global_env(Env),
	catch(( LEnv=[bv(sys_expansion, []), bv(sys_expanded, [])|Env20],
		get_var(LEnv, sys_environment, Environment_Get),
		get_var(LEnv, sys_form, Form_Get),
		cl_macroexpand_1([Form_Get, Environment_Get], Macroexpand_1_Ret),
		setq_from_values(LEnv, [sys_expansion, sys_expanded]),
		get_var(LEnv, sys_expanded, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sys_environment, Environment_Get14),
		    get_var(LEnv, sys_expansion, Expansion_Get),
		    cl_get_setf_expansion(Expansion_Get,
					  Environment_Get14,
					  TrueResult),
		    LetResult=TrueResult
		;   get_var(LEnv, sys_form, Form_Get15),
		    f_sys_get_setf_method_inverse(Form_Get15,
						  
						  [ funcall,
						    function(
							     [ setf,
							       
							       [ '#COMMA',
								 [car, sys_form]
							       ]
							     ]).
						  ],
						  t,
						  ElseResult),
		    LetResult=ElseResult
		),
		LetResult=FnResult
	      ),
	      block_exit(sys_expand_or_get_setf_inverse, FnResult),
	      true).
:- set_opv(f_sys_expand_or_get_setf_inverse, classof, claz_function),
   set_opv(sys_expand_or_get_setf_inverse, compile_as, kw_function),
   set_opv(sys_expand_or_get_setf_inverse,
	   function,
	   f_sys_expand_or_get_setf_inverse),
   DefunResult=sys_expand_or_get_setf_inverse.

/*
#+(or ABCL WAM-CL)
(defun get-setf-expansion (form &optional environment)
  (let (temp)
    (cond ((symbolp form)
           (multiple-value-bind (expansion expanded)
               (macroexpand-1 form environment)
             (if expanded
                 (get-setf-expansion expansion environment)
                 (let ((new-var (gensym)))
                   (values nil nil (list new-var)
                           `(setq ,form ,new-var) form)))))
          ((setq temp (get (car form) 'setf-inverse))
           (get-setf-method-inverse form `(,temp) nil))
          ((setq temp (get (car form) 'setf-expander))
           (funcall temp form environment))
          (t
           (expand-or-get-setf-inverse form environment)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:9199 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'get-setf-expansion',[form,'&optional',environment],[let,[temp],[cond,[[symbolp,form],['multiple-value-bind',[expansion,expanded],['macroexpand-1',form,environment],[if,expanded,['get-setf-expansion',expansion,environment],[let,[['new-var',[gensym]]],[values,[],[],[list,'new-var'],['#BQ',[setq,['#COMMA',form],['#COMMA','new-var']]],form]]]]],[[setq,temp,[get,[car,form],[quote,'setf-inverse']]],['get-setf-method-inverse',form,['#BQ',[['#COMMA',temp]]],[]]],[[setq,temp,[get,[car,form],[quote,'setf-expander']]],[funcall,temp,form,environment]],[t,['expand-or-get-setf-inverse',form,environment]]]]]).
wl:lambda_def(defun, get_setf_expansion, cl_get_setf_expansion, [sys_form, c38_optional, sys_environment], [[let, [sys_temp], [cond, [[symbolp, sys_form], [multiple_value_bind, [sys_expansion, sys_expanded], [macroexpand_1, sys_form, sys_environment], [if, sys_expanded, [get_setf_expansion, sys_expansion, sys_environment], [let, [[sys_new_var, [gensym]]], [values, [], [], [list, sys_new_var], ['#BQ', [setq, ['#COMMA', sys_form], ['#COMMA', sys_new_var]]], sys_form]]]]], [[setq, sys_temp, [get, [car, sys_form], [quote, sys_setf_inverse]]], [sys_get_setf_method_inverse, sys_form, ['#BQ', [['#COMMA', sys_temp]]], []]], [[setq, sys_temp, [get, [car, sys_form], [quote, sys_setf_expander]]], [funcall, sys_temp, sys_form, sys_environment]], [t, [sys_expand_or_get_setf_inverse, sys_form, sys_environment]]]]]).
wl:arglist_info(get_setf_expansion, cl_get_setf_expansion, [sys_form, c38_optional, sys_environment], arginfo{all:[sys_form, sys_environment], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_form, sys_environment], opt:[sys_environment], req:[sys_form], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_get_setf_expansion).

/*

### Compiled:  `CL:GET-SETF-EXPANSION` 
*/
cl_get_setf_expansion(Form_In, RestNKeys, FnResult) :-
	Env55=[bv(sys_form, Form_In), bv(sys_environment, Environment_In)|Env],
	global_env(Env),
	opt_var(Env, sys_environment, Environment_In, true, [], 1, RestNKeys),
	catch(( LEnv=[bv(sys_temp, [])|Env55],
		get_var(LEnv, sys_form, Form_Get),
		(   is_symbolp(Form_Get)
		->  LEnv16=[bv(sys_expansion, []), bv(sys_expanded, [])|LEnv],
		    get_var(LEnv16, sys_environment, Environment_Get),
		    get_var(LEnv16, sys_form, Form_Get17),
		    cl_macroexpand_1([Form_Get17, Environment_Get],
				     Macroexpand_1_Ret),
		    setq_from_values(LEnv16, [sys_expansion, sys_expanded]),
		    get_var(LEnv16, sys_expanded, IFTEST19),
		    (   IFTEST19\==[]
		    ->  get_var(LEnv16, sys_environment, Environment_Get23),
			get_var(LEnv16, sys_expansion, Expansion_Get),
			cl_get_setf_expansion(Expansion_Get,
					      Environment_Get23,
					      TrueResult),
			LetResult15=TrueResult
		    ;   cl_gensym(New_var_Init),
			LEnv26=[bv(sys_new_var, New_var_Init)|LEnv16],
			get_var(LEnv26, sys_new_var, New_var_Get),
			CAR=New_var_Get,
			get_var(LEnv26, sys_form, Form_Get29),
			get_var(LEnv26, sys_form, Form_Get31),
			get_var(LEnv26, sys_new_var, New_var_Get30),
			nb_setval('$mv_return',
				  
				  [ [],
				    [],
				    CAR,
				    [setq, Form_Get29, New_var_Get30],
				    Form_Get31
				  ]),
			LetResult15=[]
		    ),
		    LetResult=LetResult15
		;   get_var(LEnv, sys_form, Form_Get36),
		    cl_car(Form_Get36, Get_Param),
		    cl_get(Get_Param, sys_setf_inverse, [], IFTEST33),
		    set_var(LEnv, sys_temp, IFTEST33),
		    (   IFTEST33\==[]
		    ->  get_var(LEnv, sys_form, Form_Get37),
			get_var(LEnv, sys_temp, Temp_Get),
			f_sys_get_setf_method_inverse(Form_Get37,
						      [Temp_Get],
						      [],
						      TrueResult49),
			ElseResult52=TrueResult49
		    ;   get_var(LEnv, sys_form, Form_Get41),
			cl_car(Form_Get41, Get_Param57),
			cl_get(Get_Param57, sys_setf_expander, [], IFTEST39),
			set_var(LEnv, sys_temp, IFTEST39),
			(   IFTEST39\==[]
			->  get_var(LEnv, sys_form, Form_Get43),
			    get_var(LEnv, sys_temp, Temp_Get42),
			    get_var(LEnv, sys_environment, Environment_Get44),
			    cl_apply(Temp_Get42,
				     [Form_Get43, Environment_Get44],
				     TrueResult47),
			    ElseResult50=TrueResult47
			;   get_var(LEnv, sys_environment, Environment_Get46),
			    get_var(LEnv, sys_form, Form_Get45),
			    f_sys_expand_or_get_setf_inverse(Form_Get45,
							     Environment_Get46,
							     ElseResult),
			    ElseResult50=ElseResult
			),
			ElseResult52=ElseResult50
		    ),
		    LetResult=ElseResult52
		),
		LetResult=FnResult
	      ),
	      block_exit(get_setf_expansion, FnResult),
	      true).
:- set_opv(cl_get_setf_expansion, classof, claz_function),
   set_opv(get_setf_expansion, compile_as, kw_function),
   set_opv(get_setf_expansion, function, cl_get_setf_expansion),
   DefunResult=get_setf_expansion.

/*
#+(or ABCL WAM-CL)
(defmacro setf (&rest args &environment environment)
  (let ((numargs (length args)))
    (cond
     ((= numargs 2)
      (let ((place (first args))
            (value-form (second args)))
        (if (atom place)
            `(setq ,place ,value-form)
            (progn
              (multiple-value-bind (dummies vals store-vars setter getter)
                  (get-setf-expansion place environment)
                (let ((inverse (get (car place) 'setf-inverse)))
                  (if (and inverse (eq inverse (car setter)))
                      (if (functionp inverse)
                          `(funcall ,inverse ,@(cdr place) ,value-form)
                          `(,inverse ,@(cdr place) ,value-form))
                      (if (or (null store-vars) (cdr store-vars))
                          `(let* (,@(mapcar #'list dummies vals))
                             (multiple-value-bind ,store-vars ,value-form
                               ,setter))
                          `(let* (,@(mapcar #'list dummies vals)
                                    ,(list (car store-vars) value-form))
                               ,setter)))))))))
     ((oddp numargs)
      (error "Odd number of arguments to SETF."))
     (t
      (do ((a args (cddr a)) (l nil))
          ((null a) `(progn ,@(nreverse l)))
        (setq l (cons (list 'setf (car a) (cadr a)) l)))))))


;; (defsetf subseq (sequence start &optional (end nil)) (v)
;;   `(progn (replace ,sequence ,v :start1 ,start :end1 ,end)
;;      ,v))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:9955 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,setf,['&rest',args,'&environment',environment],[let,[[numargs,[length,args]]],[cond,[[=,numargs,2],[let,[[place,[first,args]],['value-form',[second,args]]],[if,[atom,place],['#BQ',[setq,['#COMMA',place],['#COMMA','value-form']]],[progn,['multiple-value-bind',[dummies,vals,'store-vars',setter,getter],['get-setf-expansion',place,environment],[let,[[inverse,[get,[car,place],[quote,'setf-inverse']]]],[if,[and,inverse,[eq,inverse,[car,setter]]],[if,[functionp,inverse],['#BQ',[funcall,['#COMMA',inverse],['#BQ-COMMA-ELIPSE',[cdr,place]],['#COMMA','value-form']]],['#BQ',[['#COMMA',inverse],['#BQ-COMMA-ELIPSE',[cdr,place]],['#COMMA','value-form']]]],[if,[or,[null,'store-vars'],[cdr,'store-vars']],['#BQ',['let*',[['#BQ-COMMA-ELIPSE',[mapcar,function(list),dummies,vals]]],['multiple-value-bind',['#COMMA','store-vars'],['#COMMA','value-form'],['#COMMA',setter]]]],['#BQ',['let*',[['#BQ-COMMA-ELIPSE',[mapcar,function(list),dummies,vals]],['#COMMA',[list,[car,'store-vars'],'value-form']]],['#COMMA',setter]]]]]]]]]]],[[oddp,numargs],[error,'$STRING'("Odd number of arguments to SETF.")]],[t,[do,[[a,args,[cddr,a]],[l,[]]],[[null,a],['#BQ',[progn,['#BQ-COMMA-ELIPSE',[nreverse,l]]]]],[setq,l,[cons,[list,[quote,setf],[car,a],[cadr,a]],l]]]]]]]).
wl:lambda_def(defmacro, setf, cl_setf, [c38_rest, args, c38_environment, sys_environment], [progn, [let, [[sys_numargs, [length, args]]], [cond, [[=, sys_numargs, 2], [let, [[sys_place, [first, args]], [sys_value_form, [second, args]]], [if, [atom, sys_place], ['#BQ', [setq, ['#COMMA', sys_place], ['#COMMA', sys_value_form]]], [progn, [multiple_value_bind, [sys_dummies, sys_vals, sys_store_vars, sys_setter, sys_getter], [get_setf_expansion, sys_place, sys_environment], [let, [[sys_inverse, [get, [car, sys_place], [quote, sys_setf_inverse]]]], [if, [and, sys_inverse, [eq, sys_inverse, [car, sys_setter]]], [if, [functionp, sys_inverse], ['#BQ', [funcall, ['#COMMA', sys_inverse], ['#BQ-COMMA-ELIPSE', [cdr, sys_place]], ['#COMMA', sys_value_form]]], ['#BQ', [['#COMMA', sys_inverse], ['#BQ-COMMA-ELIPSE', [cdr, sys_place]], ['#COMMA', sys_value_form]]]], [if, [or, [null, sys_store_vars], [cdr, sys_store_vars]], ['#BQ', [let_xx, [['#BQ-COMMA-ELIPSE', [mapcar, function(list), sys_dummies, sys_vals]]], [multiple_value_bind, ['#COMMA', sys_store_vars], ['#COMMA', sys_value_form], ['#COMMA', sys_setter]]]], ['#BQ', [let_xx, [['#BQ-COMMA-ELIPSE', [mapcar, function(list), sys_dummies, sys_vals]], ['#COMMA', [list, [car, sys_store_vars], sys_value_form]]], ['#COMMA', sys_setter]]]]]]]]]]], [[oddp, sys_numargs], [error, '$ARRAY'([*], claz_base_character, "Odd number of arguments to SETF.")]], [t, [do, [[sys_a, args, [cddr, sys_a]], [sys_l, []]], [[null, sys_a], ['#BQ', [progn, ['#BQ-COMMA-ELIPSE', [nreverse, sys_l]]]]], [setq, sys_l, [cons, [list, [quote, setf], [car, sys_a], [cadr, sys_a]], sys_l]]]]]]]).
wl: declared(cl_setf, env_arg1).

wl:arglist_info(setf, cl_setf, [c38_rest, args, c38_environment, sys_environment], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest, environment], env:[sys_environment], key:0, names:[args, sys_environment], opt:0, req:0, rest:[args], sublists:0, whole:0}).
wl: init_args(0, cl_setf).

/*

### Compiled:  `CL:SETF` 
*/
cl_setf(RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(args, RestNKeys), bv(sys_environment, Environment_In)|CDR],
	global_env(CDR),
	parent_env(Environment_In),
	catch(( get_var(Env, args, Args_Get),
		cl_length(Args_Get, Numargs_Init),
		LEnv=[bv(sys_numargs, Numargs_Init)|Env],
		get_var(LEnv, sys_numargs, Numargs_Get),
		(   Numargs_Get=:=2
		->  get_var(LEnv, args, Args_Get18),
		    cl_car(Args_Get18, Place_Init),
		    get_var(LEnv, args, Args_Get19),
		    cl_second(Args_Get19, Value_form_Init),
		    LEnv17=[bv(sys_place, Place_Init), bv(sys_value_form, Value_form_Init)|LEnv],
		    get_var(LEnv17, sys_place, Place_Get),
		    (   Place_Get\=[CAR|CDR131]
		    ->  get_var(LEnv17, sys_place, Place_Get26),
			get_var(LEnv17, sys_value_form, Value_form_Get),
			LetResult16=[setq, Place_Get26, Value_form_Get]
		    ;   LEnv30=[bv(sys_dummies, []), bv(sys_vals, []), bv(sys_store_vars, []), bv(sys_setter, []), bv(sys_getter, [])|LEnv17],
			get_var(LEnv30, sys_environment, Environment_Get),
			get_var(LEnv30, sys_place, Place_Get31),
			cl_get_setf_expansion(Place_Get31,
					      Environment_Get,
					      Setf_expansion_Ret),
			setq_from_values(LEnv30,
					 
					 [ sys_dummies,
					   sys_vals,
					   sys_store_vars,
					   sys_setter,
					   sys_getter
					 ]),
			get_var(LEnv30, sys_place, Place_Get36),
			cl_car(Place_Get36, Get_Param),
			cl_get(Get_Param, sys_setf_inverse, [], Inverse_Init),
			LEnv35=[bv(sys_inverse, Inverse_Init)|LEnv30],
			get_var(LEnv35, sys_inverse, IFTEST40),
			(   IFTEST40\==[]
			->  get_var(LEnv35, sys_inverse, Inverse_Get43),
			    get_var(LEnv35, sys_setter, Setter_Get),
			    cl_car(Setter_Get, Car_Ret),
			    cl_eq(Inverse_Get43, Car_Ret, TrueResult),
			    IFTEST38=TrueResult
			;   IFTEST38=[]
			),
			(   IFTEST38\==[]
			->  get_var(LEnv35, sys_inverse, Inverse_Get47),
			    (   is_functionp(Inverse_Get47)
			    ->  get_var(LEnv35, sys_inverse, Inverse_Get50),
				get_var(LEnv35, sys_place, Place_Get51),
				cl_cdr(Place_Get51, Cdr_Ret),
				get_var(LEnv35,
					sys_value_form,
					Value_form_Get52),
				bq_append([Inverse_Get50|Cdr_Ret],
					  [Value_form_Get52],
					  Bq_append_Ret),
				TrueResult72=[funcall|Bq_append_Ret]
			    ;   get_var(LEnv35, sys_inverse, Inverse_Get53),
				get_var(LEnv35, sys_place, Place_Get54),
				cl_cdr(Place_Get54, Cdr_Ret136),
				get_var(LEnv35,
					sys_value_form,
					Value_form_Get55),
				bq_append([Inverse_Get53|Cdr_Ret136],
					  [Value_form_Get55],
					  ElseResult),
				TrueResult72=ElseResult
			    ),
			    LetResult34=TrueResult72
			;   (   get_var(LEnv35, sys_store_vars, Store_vars_Get),
				cl_null(Store_vars_Get, FORM1_Res),
				FORM1_Res\==[],
				IFTEST57=FORM1_Res
			    ->  true
			    ;   get_var(LEnv35,
					sys_store_vars,
					Store_vars_Get60),
				cl_cdr(Store_vars_Get60, Cdr_Ret137),
				IFTEST57=Cdr_Ret137
			    ),
			    (   IFTEST57\==[]
			    ->  get_var(LEnv35, sys_dummies, Dummies_Get),
				get_var(LEnv35, sys_vals, Vals_Get),
				cl_mapcar(cl_list,
					  [Dummies_Get, Vals_Get],
					  Mapcar_Ret),
				get_var(LEnv35,
					sys_store_vars,
					Store_vars_Get64),
				get_var(LEnv35, sys_setter, Setter_Get66),
				get_var(LEnv35,
					sys_value_form,
					Value_form_Get65),
				ElseResult73=[let_xx, Mapcar_Ret, [multiple_value_bind, Store_vars_Get64, Value_form_Get65, Setter_Get66]]
			    ;   get_var(LEnv35, sys_dummies, Dummies_Get67),
				get_var(LEnv35, sys_vals, Vals_Get68),
				cl_mapcar(cl_list,
					  [Dummies_Get67, Vals_Get68],
					  Bq_append_Param),
				get_var(LEnv35,
					sys_store_vars,
					Store_vars_Get69),
				cl_car(Store_vars_Get69, Car_Ret139),
				get_var(LEnv35,
					sys_value_form,
					Value_form_Get70),
				CAR141=[Car_Ret139, Value_form_Get70],
				bq_append(Bq_append_Param,
					  [CAR141],
					  Bq_append_Ret140),
				get_var(LEnv35, sys_setter, Setter_Get71),
				ElseResult73=[let_xx, Bq_append_Ret140, Setter_Get71]
			    ),
			    LetResult34=ElseResult73
			),
			LetResult16=LetResult34
		    ),
		    LetResult=LetResult16
		;   get_var(LEnv, sys_numargs, Numargs_Get76),
		    (   mth:is_oddp(Numargs_Get76)
		    ->  cl_error('$ARRAY'([*],
					  claz_base_character,
					  "Odd number of arguments to SETF."),
				 TrueResult118),
			ElseResult121=TrueResult118
		    ;   get_var(LEnv, args, Args_Get82),
			AEnv=[bv(sys_a, Args_Get82), bv(sys_l, [])|LEnv],
			catch(( call_addr_block(AEnv,
						(push_label(do_label_2), get_var(AEnv, sys_a, IFTEST102), (IFTEST102==[]->get_var(AEnv, sys_l, L_Get107), cl_nreverse(L_Get107, Nreverse_Ret), throw(block_exit([], [progn|Nreverse_Ret])), _TBResult=ThrowResult106;get_var(AEnv, sys_a, A_Get110), cl_car(A_Get110, Car_Ret143), get_var(AEnv, sys_a, A_Get111), cl_cadr(A_Get111, Cadr_Ret), CAR145=[setf, Car_Ret143, Cadr_Ret], get_var(AEnv, sys_l, L_Get112), L=[CAR145|L_Get112], set_var(AEnv, sys_l, L), get_var(AEnv, sys_a, A_Get113), cl_cddr(A_Get113, A), set_var(AEnv, sys_a, A), goto(do_label_2, AEnv), _TBResult=_GORES114)),
						
						[ addr(addr_tagbody_2_do_label_2,
						       do_label_2,
						       '$unused',
						       AEnv,
						       (get_var(AEnv, sys_a, IFTEST85), (IFTEST85==[]->get_var(AEnv, sys_l, Nreverse_Param), cl_nreverse(Nreverse_Param, Nreverse_Ret146), throw(block_exit([], [progn|Nreverse_Ret146])), _26513298=ThrowResult;get_var(AEnv, sys_a, A_Get93), cl_car(A_Get93, Car_Ret147), get_var(AEnv, sys_a, A_Get94), cl_cadr(A_Get94, Cadr_Ret148), cl_list([setf, Car_Ret147, Cadr_Ret148], List_Ret), get_var(AEnv, sys_l, L_Get95), Set_var_Ret=[List_Ret|L_Get95], set_var(AEnv, sys_l, Set_var_Ret), get_var(AEnv, sys_a, A_Get96), cl_cddr(A_Get96, Cddr_Ret), set_var(AEnv, sys_a, Cddr_Ret), goto(do_label_2, AEnv), _26513298=_GORES)))
						]),
				[]=LetResult80
			      ),
			      block_exit([], LetResult80),
			      true),
			ElseResult121=LetResult80
		    ),
		    LetResult=ElseResult121
		),
		LetResult=MFResult
	      ),
	      block_exit(setf, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_setf, classof, claz_macro),
   set_opv(setf, compile_as, kw_operator),
   set_opv(setf, function, cl_setf),
   DefMacroResult=setf.
/*
:- side_effect(assert_lsp(setf,
			  lambda_def(defmacro,
				     setf,
				     cl_setf,
				     
				     [ c38_rest,
				       args,
				       c38_environment,
				       sys_environment
				     ],
				     
				     [ progn,
				       
				       [ let,
					 [[sys_numargs, [length, args]]],
					 
					 [ cond,
					   
					   [ [=, sys_numargs, 2],
					     
					     [ let,
					       
					       [ [sys_place, [first, args]],
						 
						 [ sys_value_form,
						   [second, args]
						 ]
					       ],
					       
					       [ if,
						 [atom, sys_place],
						 
						 [ '#BQ',
						   
						   [ setq,
						     ['#COMMA', sys_place],
						     ['#COMMA', sys_value_form]
						   ]
						 ],
						 
						 [ progn,
						   
						   [ multiple_value_bind,
						     
						     [ sys_dummies,
						       sys_vals,
						       sys_store_vars,
						       sys_setter,
						       sys_getter
						     ],
						     
						     [ get_setf_expansion,
						       sys_place,
						       sys_environment
						     ],
						     
						     [ let,
						       
						       [ 
							 [ sys_inverse,
							   
							   [ get,
							     [car, sys_place],
							     
							     [ quote,
							       sys_setf_inverse
							     ]
							   ]
							 ]
						       ],
						       
						       [ if,
							 
							 [ and,
							   sys_inverse,
							   
							   [ eq,
							     sys_inverse,
							     [car, sys_setter]
							   ]
							 ],
							 
							 [ if,
							   
							   [ functionp,
							     sys_inverse
							   ],
							   
							   [ '#BQ',
							     
							     [ funcall,
							       
							       [ '#COMMA',
								 sys_inverse
							       ],
							       
							       [ '#BQ-COMMA-ELIPSE',
								 [cdr, sys_place]
							       ],
							       
							       [ '#COMMA',
								 sys_value_form
							       ]
							     ]
							   ],
							   
							   [ '#BQ',
							     
							     [ 
							       [ '#COMMA',
								 sys_inverse
							       ],
							       
							       [ '#BQ-COMMA-ELIPSE',
								 [cdr, sys_place]
							       ],
							       
							       [ '#COMMA',
								 sys_value_form
							       ]
							     ]
							   ]
							 ],
							 
							 [ if,
							   
							   [ or,
							     
							     [ null,
							       sys_store_vars
							     ],
							     
							     [ cdr,
							       sys_store_vars
							     ]
							   ],
							   
							   [ '#BQ',
							     
							     [ let_xx,
							       
							       [ 
								 [ '#BQ-COMMA-ELIPSE',
								   
								   [ mapcar,
								     function(list),
								     sys_dummies,
								     sys_vals
								   ]
								 ]
							       ],
							       
							       [ multiple_value_bind,
								 
								 [ '#COMMA',
								   sys_store_vars
								 ],
								 
								 [ '#COMMA',
								   sys_value_form
								 ],
								 
								 [ '#COMMA',
								   sys_setter
								 ]
							       ]
							     ]
							   ],
							   
							   [ '#BQ',
							     
							     [ let_xx,
							       
							       [ 
								 [ '#BQ-COMMA-ELIPSE',
								   
								   [ mapcar,
								     function(list),
								     sys_dummies,
								     sys_vals
								   ]
								 ],
								 
								 [ '#COMMA',
								   
								   [ list,
								     
								     [ car,
								       sys_store_vars
								     ],
								     sys_value_form
								   ]
								 ]
							       ],
							       
							       [ '#COMMA',
								 sys_setter
							       ]
							     ]
							   ]
							 ]
						       ]
						     ]
						   ]
						 ]
					       ]
					     ]
					   ],
					   
					   [ [oddp, sys_numargs],
					     
					     [ error,
					       '$ARRAY'([*],
							claz_base_character,
							"Odd number of arguments to SETF.")
					     ]
					   ],
					   
					   [ t,
					     
					     [ do,
					       
					       [ [sys_a, args, [cddr, sys_a]],
						 [sys_l, []]
					       ],
					       
					       [ [null, sys_a],
						 
						 [ '#BQ',
						   
						   [ progn,
						     
						     [ '#BQ-COMMA-ELIPSE',
						       [nreverse, sys_l]
						     ]
						   ]
						 ]
					       ],
					       
					       [ setq,
						 sys_l,
						 
						 [ cons,
						   
						   [ list,
						     [quote, setf],
						     [car, sys_a],
						     [cadr, sys_a]
						   ],
						   sys_l
						 ]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(setf,
			  arglist_info(setf,
				       cl_setf,
				       
				       [ c38_rest,
					 args,
					 c38_environment,
					 sys_environment
				       ],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest, environment],
						env:[sys_environment],
						key:0,
						names:[args, sys_environment],
						opt:0,
						req:0,
						rest:[args],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(setf, init_args(0, cl_setf))).
*/
/*
; (defsetf subseq (sequence start &optional (end nil)) (v)
*/
/*
;   `(progn (replace ,sequence ,v :start1 ,start :end1 ,end)
*/
/*
;      ,v))
*/
/*
#+(or ABCL WAM-CL)
(defun %set-subseq (sequence start &rest rest)
  (let ((end nil) v)
    (ecase (length rest)
      (1
       (setq v (car rest)))
      (2
       (setq end (car rest)
             v (cadr rest))))
    (progn
      (replace sequence v :start1 start :end1 end)
      v)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:11516 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'%set-subseq',[sequence,start,'&rest',rest],[let,[[end,[]],v],[ecase,[length,rest],[1,[setq,v,[car,rest]]],[2,[setq,end,[car,rest],v,[cadr,rest]]]],[progn,[replace,sequence,v,':start1',start,':end1',end],v]]]).
/*
% ecase:-[[1,[setq,sys_v,[car,rest]]],[2,[setq,end,[car,rest],sys_v,[cadr,rest]]]].
*/
/*
% conds:-[[[eq,_30106580,[quote,1]],[progn,[setq,sys_v,[car,rest]]]],[[eq,_30106580,[quote,2]],[progn,[setq,end,[car,rest],sys_v,[cadr,rest]]]],[t,[type_error,_30106816,[quote,[member,1,2]]]]].
*/
wl:lambda_def(defun, sys_pf_set_subseq, f_sys_pf_set_subseq, [sequence, start, c38_rest, rest], [[let, [[end, []], sys_v], [ecase, [length, rest], [1, [setq, sys_v, [car, rest]]], [2, [setq, end, [car, rest], sys_v, [cadr, rest]]]], [progn, [replace, sequence, sys_v, kw_start1, start, kw_end1, end], sys_v]]]).
wl:arglist_info(sys_pf_set_subseq, f_sys_pf_set_subseq, [sequence, start, c38_rest, rest], arginfo{all:[sequence, start], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sequence, start, rest], opt:0, req:[sequence, start], rest:[rest], sublists:0, whole:0}).
wl: init_args(2, f_sys_pf_set_subseq).

/*

### Compiled:  `SYS::%SET-SUBSEQ` 
*/
f_sys_pf_set_subseq(Sequence_In, Start_In, RestNKeys, FnResult) :-
	Env33=[bv(sequence, Sequence_In), bv(start, Start_In), bv(rest, RestNKeys)|Env],
	global_env(Env),
	catch(( LEnv=[bv(end, []), bv(sys_v, [])|Env33],
		get_var(LEnv, rest, Rest_Get),
		cl_length(Rest_Get, Key),
		(   is_eq(Key, 1)
		->  get_var(LEnv, rest, Rest_Get17),
		    cl_car(Rest_Get17, TrueResult24),
		    set_var(LEnv, sys_v, TrueResult24),
		    _30104514=TrueResult24
		;   (   is_eq(Key, 2)
		    ->  get_var(LEnv, rest, Rest_Get20),
			cl_car(Rest_Get20, End),
			set_var(LEnv, end, End),
			get_var(LEnv, rest, Rest_Get21),
			cl_cadr(Rest_Get21, TrueResult),
			set_var(LEnv, sys_v, TrueResult),
			ElseResult25=TrueResult
		    ;   cl_type_error(CAR, [member, 1, 2], ElseResult),
			ElseResult25=ElseResult
		    ),
		    _30104514=ElseResult25
		),
		get_var(LEnv, sequence, Sequence_Get),
		get_var(LEnv, start, Start_Get),
		get_var(LEnv, sys_v, V_Get),
		get_var(LEnv, end, End_Get),
		cl_replace(Sequence_Get,
			   V_Get,
			   [kw_start1, Start_Get, kw_end1, End_Get],
			   Replace_Ret),
		get_var(LEnv, sys_v, V_Get30),
		V_Get30=FnResult
	      ),
	      block_exit(sys_pf_set_subseq, FnResult),
	      true).
:- set_opv(f_sys_pf_set_subseq, classof, claz_function),
   set_opv(sys_pf_set_subseq, compile_as, kw_function),
   set_opv(sys_pf_set_subseq, function, f_sys_pf_set_subseq),
   DefunResult=sys_pf_set_subseq.
/*
:- side_effect(assert_lsp(sys_pf_set_subseq,
			  lambda_def(defun,
				     sys_pf_set_subseq,
				     f_sys_pf_set_subseq,
				     [sequence, start, c38_rest, rest],
				     
				     [ 
				       [ let,
					 [[end, []], sys_v],
					 
					 [ ecase,
					   [length, rest],
					   [1, [setq, sys_v, [car, rest]]],
					   
					   [ 2,
					     
					     [ setq,
					       end,
					       [car, rest],
					       sys_v,
					       [cadr, rest]
					     ]
					   ]
					 ],
					 
					 [ progn,
					   
					   [ replace,
					     sequence,
					     sys_v,
					     kw_start1,
					     start,
					     kw_end1,
					     end
					   ],
					   sys_v
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_subseq,
			  arglist_info(sys_pf_set_subseq,
				       f_sys_pf_set_subseq,
				       [sequence, start, c38_rest, rest],
				       arginfo{ all:[sequence, start],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sequence, start, rest],
						opt:0,
						req:[sequence, start],
						rest:[rest],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_subseq, init_args(2, f_sys_pf_set_subseq))).
*/
/*
#+(or ABCL WAM-CL)
(defun %define-setf-macro (name expander inverse doc)
  (declare (ignore doc)) ; FIXME
  (when inverse
    (put-sysprop name 'setf-inverse inverse))
  (when expander
    (put-sysprop name 'setf-expander expander))
  name)


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:11819 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'%define-setf-macro',[name,expander,inverse,doc],[declare,[ignore,doc]],[when,inverse,['put-sysprop',name,[quote,'setf-inverse'],inverse]],[when,expander,['put-sysprop',name,[quote,'setf-expander'],expander]],name]).
wl:lambda_def(defun, sys_pf_define_setf_macro, f_sys_pf_define_setf_type_macro, [sys_name, sys_expander, sys_inverse, sys_doc], [[declare, [ignore, sys_doc]], [when, sys_inverse, [sys_put_sysprop, sys_name, [quote, sys_setf_inverse], sys_inverse]], [when, sys_expander, [sys_put_sysprop, sys_name, [quote, sys_setf_expander], sys_expander]], sys_name]).
wl:arglist_info(sys_pf_define_setf_macro, f_sys_pf_define_setf_type_macro, [sys_name, sys_expander, sys_inverse, sys_doc], arginfo{all:[sys_name, sys_expander, sys_inverse, sys_doc], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_name, sys_expander, sys_inverse, sys_doc], opt:0, req:[sys_name, sys_expander, sys_inverse, sys_doc], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_pf_define_setf_type_macro).

/*

### Compiled:  `SYS::%DEFINE-SETF-MACRO` 
*/
f_sys_pf_define_setf_type_macro(Name_In, Expander_In, Inverse_In, Doc_In, FnResult) :-
	Env22=[bv(sys_name, Name_In), bv(sys_expander, Expander_In), bv(sys_inverse, Inverse_In), bv(sys_doc, Doc_In)|Env],
	global_env(Env),
	catch(( cl_declare([ignore, sys_doc], Declare_Ret),
		get_var(Env22, sys_inverse, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env22, sys_inverse, Inverse_Get11),
		    get_var(Env22, sys_name, Name_Get),
		    f_sys_put_sysprop(Name_Get,
				      sys_setf_inverse,
				      Inverse_Get11,
				      [],
				      TrueResult),
		    _31706364=TrueResult
		;   _31706364=[]
		),
		get_var(Env22, sys_expander, IFTEST13),
		(   IFTEST13\==[]
		->  get_var(Env22, sys_expander, Expander_Get17),
		    get_var(Env22, sys_name, Name_Get16),
		    f_sys_put_sysprop(Name_Get16,
				      sys_setf_expander,
				      Expander_Get17,
				      [],
				      TrueResult18),
		    _31720996=TrueResult18
		;   _31720996=[]
		),
		get_var(Env22, sys_name, Name_Get19),
		Name_Get19=FnResult
	      ),
	      block_exit(sys_pf_define_setf_macro, FnResult),
	      true).
:- set_opv(f_sys_pf_define_setf_type_macro, classof, claz_function),
   set_opv(sys_pf_define_setf_macro, compile_as, kw_function),
   set_opv(sys_pf_define_setf_macro, function, f_sys_pf_define_setf_type_macro),
   DefunResult=sys_pf_define_setf_macro.
/*
:- side_effect(assert_lsp(sys_pf_define_setf_macro,
			  lambda_def(defun,
				     sys_pf_define_setf_macro,
				     f_sys_pf_define_setf_type_macro,
				     
				     [ sys_name,
				       sys_expander,
				       sys_inverse,
				       sys_doc
				     ],
				     
				     [ [declare, [ignore, sys_doc]],
				       
				       [ when,
					 sys_inverse,
					 
					 [ sys_put_sysprop,
					   sys_name,
					   [quote, sys_setf_inverse],
					   sys_inverse
					 ]
				       ],
				       
				       [ when,
					 sys_expander,
					 
					 [ sys_put_sysprop,
					   sys_name,
					   [quote, sys_setf_expander],
					   sys_expander
					 ]
				       ],
				       sys_name
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_define_setf_macro,
			  arglist_info(sys_pf_define_setf_macro,
				       f_sys_pf_define_setf_type_macro,
				       
				       [ sys_name,
					 sys_expander,
					 sys_inverse,
					 sys_doc
				       ],
				       arginfo{ all:
						    [ sys_name,
						      sys_expander,
						      sys_inverse,
						      sys_doc
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_name,
							sys_expander,
							sys_inverse,
							sys_doc
						      ],
						opt:0,
						req:
						    [ sys_name,
						      sys_expander,
						      sys_inverse,
						      sys_doc
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_define_setf_macro,
			  init_args(exact_only,
				    f_sys_pf_define_setf_type_macro))).
*/
/*
 FIXME
*/
/*
#+(or ABCL WAM-CL)
(defmacro defsetf (access-function update-function)
  `(eval-when (:load-toplevel :compile-toplevel :execute)
     (put-sysprop ',access-function 'setf-inverse ',update-function)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:12072 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,defsetf,['access-function','update-function'],['#BQ',['eval-when',[':load-toplevel',':compile-toplevel',':execute'],['put-sysprop',[quote,['#COMMA','access-function']],[quote,'setf-inverse'],[quote,['#COMMA','update-function']]]]]]).
wl:lambda_def(defmacro, defsetf, cl_defsetf, [sys_access_function, sys_update_function], [progn, ['#BQ', [eval_when, [kw_load_toplevel, kw_compile_toplevel, kw_execute], [sys_put_sysprop, [quote, ['#COMMA', sys_access_function]], [quote, sys_setf_inverse], [quote, ['#COMMA', sys_update_function]]]]]]).
wl:arglist_info(defsetf, cl_defsetf, [sys_access_function, sys_update_function], arginfo{all:[sys_access_function, sys_update_function], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_access_function, sys_update_function], opt:0, req:[sys_access_function, sys_update_function], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_defsetf).

/*

### Compiled:  `CL:DEFSETF` 
*/
cl_defsetf(Access_function_In, Update_function_In, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_access_function, Access_function_In), bv(sys_update_function, Update_function_In)|CDR],
	global_env(CDR),
	catch(( get_var(Env, sys_access_function, Access_function_Get),
		get_var(Env, sys_update_function, Update_function_Get),
		[eval_when, [kw_load_toplevel, kw_compile_toplevel, kw_execute], [sys_put_sysprop, [quote, Access_function_Get], [quote, sys_setf_inverse], [quote, Update_function_Get]]]=MFResult
	      ),
	      block_exit(defsetf, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_defsetf, classof, claz_macro),
   set_opv(defsetf, compile_as, kw_operator),
   set_opv(defsetf, function, cl_defsetf),
   DefMacroResult=defsetf.
/*
:- side_effect(assert_lsp(defsetf,
			  lambda_def(defmacro,
				     defsetf,
				     cl_defsetf,
				     [sys_access_function, sys_update_function],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ eval_when,
					   
					   [ kw_load_toplevel,
					     kw_compile_toplevel,
					     kw_execute
					   ],
					   
					   [ sys_put_sysprop,
					     
					     [ quote,
					       ['#COMMA', sys_access_function]
					     ],
					     [quote, sys_setf_inverse],
					     
					     [ quote,
					       ['#COMMA', sys_update_function]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(defsetf,
			  arglist_info(defsetf,
				       cl_defsetf,
				       
				       [ sys_access_function,
					 sys_update_function
				       ],
				       arginfo{ all:
						    [ sys_access_function,
						      sys_update_function
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_access_function,
							sys_update_function
						      ],
						opt:0,
						req:
						    [ sys_access_function,
						      sys_update_function
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(defsetf, init_args(exact_only, cl_defsetf))).
*/
/*
#+(or ABCL WAM-CL) (flet () ;; FLET BEGIN

(defun %set-caar (x v) (set-car (car x) v))
(defun %set-cadr (x v) (set-car (cdr x) v))
(defun %set-cdar (x v) (set-cdr (car x) v))
(defun %set-cddr (x v) (set-cdr (cdr x) v))
(defun %set-caaar (x v) (set-car (caar x) v))
(defun %set-cadar (x v) (set-car (cdar x) v))
(defun %set-cdaar (x v) (set-cdr (caar x) v))
(defun %set-cddar (x v) (set-cdr (cdar x) v))
(defun %set-caadr (x v) (set-car (cadr x) v))
(defun %set-caddr (x v) (set-car (cddr x) v))
(defun %set-cdadr (x v) (set-cdr (cadr x) v))
(defun %set-cdddr (x v) (set-cdr (cddr x) v))
(defun %set-caaaar (x v) (set-car (caaar x) v))
(defun %set-cadaar (x v) (set-car (cdaar x) v))
(defun %set-cdaaar (x v) (set-cdr (caaar x) v))
(defun %set-cddaar (x v) (set-cdr (cdaar x) v))
(defun %set-caadar (x v) (set-car (cadar x) v))
(defun %set-caddar (x v) (set-car (cddar x) v))
(defun %set-cdadar (x v) (set-cdr (cadar x) v))
(defun %set-cdddar (x v) (set-cdr (cddar x) v))
(defun %set-caaadr (x v) (set-car (caadr x) v))
(defun %set-cadadr (x v) (set-car (cdadr x) v))
(defun %set-cdaadr (x v) (set-cdr (caadr x) v))
(defun %set-cddadr (x v) (set-cdr (cdadr x) v))
(defun %set-caaddr (x v) (set-car (caddr x) v))
(defun %set-cadddr (x v) (set-car (cdddr x) v))
(defun %set-cdaddr (x v) (set-cdr (caddr x) v))
(defun %set-cddddr (x v) (set-cdr (cdddr x) v))

(defsetf car set-car)
(defsetf cdr set-cdr)
(defsetf caar %set-caar)
(defsetf cadr %set-cadr)
(defsetf cdar %set-cdar)
(defsetf cddr %set-cddr)
(defsetf caaar %set-caaar)
(defsetf cadar %set-cadar)
(defsetf cdaar %set-cdaar)
(defsetf cddar %set-cddar)
(defsetf caadr %set-caadr)
(defsetf caddr %set-caddr)
(defsetf cdadr %set-cdadr)
(defsetf cdddr %set-cdddr)
(defsetf caaaar %set-caaaar)
(defsetf cadaar %set-cadaar)
(defsetf cdaaar %set-cdaaar)
(defsetf cddaar %set-cddaar)
(defsetf caadar %set-caadar)
(defsetf caddar %set-caddar)
(defsetf cdadar %set-cdadar)
(defsetf cdddar %set-cdddar)
(defsetf caaadr %set-caaadr)
(defsetf cadadr %set-cadadr)
(defsetf cdaadr %set-cdaadr)
(defsetf cddadr %set-cddadr)
(defsetf caaddr %set-caaddr)
(defsetf cadddr %set-cadddr)
(defsetf cdaddr %set-cdaddr)
(defsetf cddddr %set-cddddr)

(defsetf first set-car)
(defsetf second %set-cadr)
(defsetf third %set-caddr)
(defsetf fourth %set-cadddr)
(defun %set-fifth (x v) (set-car (cddddr x) v))
(defsetf fifth %set-fifth)
(defun %set-sixth (x v) (set-car (cdr (cddddr x)) v))
(defsetf sixth %set-sixth)
(defun %set-seventh (x v) (set-car (cddr (cddddr x)) v))
(defsetf seventh %set-seventh)
(defun %set-eighth (x v) (set-car (cdddr (cddddr x)) v))
(defsetf eighth %set-eighth)
(defun %set-ninth (x v) (set-car (cddddr (cddddr x)) v))
(defsetf ninth %set-ninth)
(defun %set-tenth (x v) (set-car (cdr (cddddr (cddddr x))) v))
(defsetf tenth %set-tenth)

(defsetf rest set-cdr)
;;Redefined in extensible-sequences-base.lisp
(defsetf elt %set-elt)
(defsetf nth %set-nth)
(defsetf svref svset)
(defsetf fill-pointer %set-fill-pointer)
(defsetf subseq %set-subseq)
(defsetf symbol-value set)
(defsetf symbol-function %set-symbol-function)
(defsetf symbol-plist %set-symbol-plist)
(defsetf get put)
(defsetf gethash puthash)
(defsetf char set-char)
(defsetf schar set-schar)
(defsetf logical-pathname-translations %set-logical-pathname-translations)
(defsetf readtable-case %set-readtable-case)

(defsetf function-info %set-function-info)

(defsetf stream-external-format %set-stream-external-format)

(defsetf structure-ref structure-set)

) ;; FLET END


;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
;;;;  Copyright (c) 1990, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.

;;;;         
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:12280 **********************/
:-lisp_compile_to_prolog(pkg_sys,[flet,[],[defun,'%set-caar',[x,v],['set-car',[car,x],v]],[defun,'%set-cadr',[x,v],['set-car',[cdr,x],v]],[defun,'%set-cdar',[x,v],['set-cdr',[car,x],v]],[defun,'%set-cddr',[x,v],['set-cdr',[cdr,x],v]],[defun,'%set-caaar',[x,v],['set-car',[caar,x],v]],[defun,'%set-cadar',[x,v],['set-car',[cdar,x],v]],[defun,'%set-cdaar',[x,v],['set-cdr',[caar,x],v]],[defun,'%set-cddar',[x,v],['set-cdr',[cdar,x],v]],[defun,'%set-caadr',[x,v],['set-car',[cadr,x],v]],[defun,'%set-caddr',[x,v],['set-car',[cddr,x],v]],[defun,'%set-cdadr',[x,v],['set-cdr',[cadr,x],v]],[defun,'%set-cdddr',[x,v],['set-cdr',[cddr,x],v]],[defun,'%set-caaaar',[x,v],['set-car',[caaar,x],v]],[defun,'%set-cadaar',[x,v],['set-car',[cdaar,x],v]],[defun,'%set-cdaaar',[x,v],['set-cdr',[caaar,x],v]],[defun,'%set-cddaar',[x,v],['set-cdr',[cdaar,x],v]],[defun,'%set-caadar',[x,v],['set-car',[cadar,x],v]],[defun,'%set-caddar',[x,v],['set-car',[cddar,x],v]],[defun,'%set-cdadar',[x,v],['set-cdr',[cadar,x],v]],[defun,'%set-cdddar',[x,v],['set-cdr',[cddar,x],v]],[defun,'%set-caaadr',[x,v],['set-car',[caadr,x],v]],[defun,'%set-cadadr',[x,v],['set-car',[cdadr,x],v]],[defun,'%set-cdaadr',[x,v],['set-cdr',[caadr,x],v]],[defun,'%set-cddadr',[x,v],['set-cdr',[cdadr,x],v]],[defun,'%set-caaddr',[x,v],['set-car',[caddr,x],v]],[defun,'%set-cadddr',[x,v],['set-car',[cdddr,x],v]],[defun,'%set-cdaddr',[x,v],['set-cdr',[caddr,x],v]],[defun,'%set-cddddr',[x,v],['set-cdr',[cdddr,x],v]],[defsetf,car,'set-car'],[defsetf,cdr,'set-cdr'],[defsetf,caar,'%set-caar'],[defsetf,cadr,'%set-cadr'],[defsetf,cdar,'%set-cdar'],[defsetf,cddr,'%set-cddr'],[defsetf,caaar,'%set-caaar'],[defsetf,cadar,'%set-cadar'],[defsetf,cdaar,'%set-cdaar'],[defsetf,cddar,'%set-cddar'],[defsetf,caadr,'%set-caadr'],[defsetf,caddr,'%set-caddr'],[defsetf,cdadr,'%set-cdadr'],[defsetf,cdddr,'%set-cdddr'],[defsetf,caaaar,'%set-caaaar'],[defsetf,cadaar,'%set-cadaar'],[defsetf,cdaaar,'%set-cdaaar'],[defsetf,cddaar,'%set-cddaar'],[defsetf,caadar,'%set-caadar'],[defsetf,caddar,'%set-caddar'],[defsetf,cdadar,'%set-cdadar'],[defsetf,cdddar,'%set-cdddar'],[defsetf,caaadr,'%set-caaadr'],[defsetf,cadadr,'%set-cadadr'],[defsetf,cdaadr,'%set-cdaadr'],[defsetf,cddadr,'%set-cddadr'],[defsetf,caaddr,'%set-caaddr'],[defsetf,cadddr,'%set-cadddr'],[defsetf,cdaddr,'%set-cdaddr'],[defsetf,cddddr,'%set-cddddr'],[defsetf,first,'set-car'],[defsetf,second,'%set-cadr'],[defsetf,third,'%set-caddr'],[defsetf,fourth,'%set-cadddr'],[defun,'%set-fifth',[x,v],['set-car',[cddddr,x],v]],[defsetf,fifth,'%set-fifth'],[defun,'%set-sixth',[x,v],['set-car',[cdr,[cddddr,x]],v]],[defsetf,sixth,'%set-sixth'],[defun,'%set-seventh',[x,v],['set-car',[cddr,[cddddr,x]],v]],[defsetf,seventh,'%set-seventh'],[defun,'%set-eighth',[x,v],['set-car',[cdddr,[cddddr,x]],v]],[defsetf,eighth,'%set-eighth'],[defun,'%set-ninth',[x,v],['set-car',[cddddr,[cddddr,x]],v]],[defsetf,ninth,'%set-ninth'],[defun,'%set-tenth',[x,v],['set-car',[cdr,[cddddr,[cddddr,x]]],v]],[defsetf,tenth,'%set-tenth'],[defsetf,rest,'set-cdr'],[defsetf,elt,'%set-elt'],[defsetf,nth,'%set-nth'],[defsetf,svref,svset],[defsetf,'fill-pointer','%set-fill-pointer'],[defsetf,subseq,'%set-subseq'],[defsetf,'symbol-value',set],[defsetf,'symbol-function','%set-symbol-function'],[defsetf,'symbol-plist','%set-symbol-plist'],[defsetf,get,put],[defsetf,gethash,puthash],[defsetf,char,'set-char'],[defsetf,schar,'set-schar'],[defsetf,'logical-pathname-translations','%set-logical-pathname-translations'],[defsetf,'readtable-case','%set-readtable-case'],[defsetf,'function-info','%set-function-info'],[defsetf,'stream-external-format','%set-stream-external-format'],[defsetf,'structure-ref','structure-set']]).
:- [].
wl:lambda_def(defun, sys_pf_set_caar, f_sys_pf_set_caar, [sys_x, sys_v], [[sys_set_car, [car, sys_x], sys_v]]).
wl:arglist_info(sys_pf_set_caar, f_sys_pf_set_caar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_pf_set_caar).

/*

### Compiled:  `SYS::%SET-CAAR` 
*/
f_sys_pf_set_caar(X_In, V_In, FnResult) :-
	Env=[bv(sys_x, X_In), bv(sys_v, V_In)|CDR],
	global_env([[]|CDR]),
	catch(( get_var(Env, sys_x, X_Get),
		cl_car(X_Get, Set_car_Param),
		get_var(Env, sys_v, V_Get),
		f_sys_set_car(Set_car_Param, V_Get, Set_car_Ret),
		Set_car_Ret=FnResult
	      ),
	      block_exit(sys_pf_set_caar, FnResult),
	      true).
:- set_opv(f_sys_pf_set_caar, classof, claz_function),
   set_opv(sys_pf_set_caar, compile_as, kw_function),
   set_opv(sys_pf_set_caar, function, f_sys_pf_set_caar),
   DefunResult=sys_pf_set_caar,
   assert_lsp(sys_pf_set_cadr,
	      wl:lambda_def(defun, sys_pf_set_cadr, f_sys_pf_set_cadr, [sys_x, sys_v], [[sys_set_car, [cdr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cadr,
	      wl:arglist_info(sys_pf_set_cadr, f_sys_pf_set_cadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cadr, wl:init_args(exact_only, f_sys_pf_set_cadr)),
   assert_lsp(sys_pf_set_cadr,
	      (f_sys_pf_set_cadr(X_In9, V_In10, FnResult8):-Env240=[bv(sys_x, X_In9), bv(sys_v, V_In10)|CDR], global_env([[]|CDR]), catch((get_var(Env240, sys_x, X_Get11), cl_cdr(X_Get11, Set_car_Param331), get_var(Env240, sys_v, V_Get12), f_sys_set_car(Set_car_Param331, V_Get12, Set_car_Ret372), Set_car_Ret372=FnResult8), block_exit(sys_pf_set_cadr, FnResult8), true))),
   set_opv(f_sys_pf_set_cadr, classof, claz_function),
   set_opv(sys_pf_set_cadr, compile_as, kw_function),
   set_opv(sys_pf_set_cadr, function, f_sys_pf_set_cadr),
   DefunResult14=sys_pf_set_cadr,
   assert_lsp(sys_pf_set_cdar,
	      wl:lambda_def(defun, sys_pf_set_cdar, f_sys_pf_set_cdar, [sys_x, sys_v], [[sys_set_cdr, [car, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdar,
	      wl:arglist_info(sys_pf_set_cdar, f_sys_pf_set_cdar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdar, wl:init_args(exact_only, f_sys_pf_set_cdar)),
   assert_lsp(sys_pf_set_cdar,
	      (f_sys_pf_set_cdar(X_In16, V_In17, FnResult15):-Env241=[bv(sys_x, X_In16), bv(sys_v, V_In17)|CDR], global_env([[]|CDR]), catch((get_var(Env241, sys_x, X_Get18), cl_car(X_Get18, Set_cdr_Param), get_var(Env241, sys_v, V_Get19), f_sys_set_cdr(Set_cdr_Param, V_Get19, Set_cdr_Ret), Set_cdr_Ret=FnResult15), block_exit(sys_pf_set_cdar, FnResult15), true))),
   set_opv(f_sys_pf_set_cdar, classof, claz_function),
   set_opv(sys_pf_set_cdar, compile_as, kw_function),
   set_opv(sys_pf_set_cdar, function, f_sys_pf_set_cdar),
   DefunResult21=sys_pf_set_cdar,
   assert_lsp(sys_pf_set_cddr,
	      wl:lambda_def(defun, sys_pf_set_cddr, f_sys_pf_set_cddr, [sys_x, sys_v], [[sys_set_cdr, [cdr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cddr,
	      wl:arglist_info(sys_pf_set_cddr, f_sys_pf_set_cddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cddr, wl:init_args(exact_only, f_sys_pf_set_cddr)),
   assert_lsp(sys_pf_set_cddr,
	      (f_sys_pf_set_cddr(X_In23, V_In24, FnResult22):-Env242=[bv(sys_x, X_In23), bv(sys_v, V_In24)|CDR], global_env([[]|CDR]), catch((get_var(Env242, sys_x, X_Get25), cl_cdr(X_Get25, Set_cdr_Param333), get_var(Env242, sys_v, V_Get26), f_sys_set_cdr(Set_cdr_Param333, V_Get26, Set_cdr_Ret374), Set_cdr_Ret374=FnResult22), block_exit(sys_pf_set_cddr, FnResult22), true))),
   set_opv(f_sys_pf_set_cddr, classof, claz_function),
   set_opv(sys_pf_set_cddr, compile_as, kw_function),
   set_opv(sys_pf_set_cddr, function, f_sys_pf_set_cddr),
   DefunResult28=sys_pf_set_cddr,
   assert_lsp(sys_pf_set_caaar,
	      wl:lambda_def(defun, sys_pf_set_caaar, f_sys_pf_set_caaar, [sys_x, sys_v], [[sys_set_car, [caar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caaar,
	      wl:arglist_info(sys_pf_set_caaar, f_sys_pf_set_caaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caaar, wl:init_args(exact_only, f_sys_pf_set_caaar)),
   assert_lsp(sys_pf_set_caaar,
	      (f_sys_pf_set_caaar(X_In30, V_In31, FnResult29):-Env243=[bv(sys_x, X_In30), bv(sys_v, V_In31)|CDR], global_env([[]|CDR]), catch((get_var(Env243, sys_x, X_Get32), cl_caar(X_Get32, Set_car_Param334), get_var(Env243, sys_v, V_Get33), f_sys_set_car(Set_car_Param334, V_Get33, Set_car_Ret375), Set_car_Ret375=FnResult29), block_exit(sys_pf_set_caaar, FnResult29), true))),
   set_opv(f_sys_pf_set_caaar, classof, claz_function),
   set_opv(sys_pf_set_caaar, compile_as, kw_function),
   set_opv(sys_pf_set_caaar, function, f_sys_pf_set_caaar),
   DefunResult35=sys_pf_set_caaar,
   assert_lsp(sys_pf_set_cadar,
	      wl:lambda_def(defun, sys_pf_set_cadar, f_sys_pf_set_cadar, [sys_x, sys_v], [[sys_set_car, [cdar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cadar,
	      wl:arglist_info(sys_pf_set_cadar, f_sys_pf_set_cadar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cadar, wl:init_args(exact_only, f_sys_pf_set_cadar)),
   assert_lsp(sys_pf_set_cadar,
	      (f_sys_pf_set_cadar(X_In37, V_In38, FnResult36):-Env244=[bv(sys_x, X_In37), bv(sys_v, V_In38)|CDR], global_env([[]|CDR]), catch((get_var(Env244, sys_x, X_Get39), cl_cdar(X_Get39, Set_car_Param335), get_var(Env244, sys_v, V_Get40), f_sys_set_car(Set_car_Param335, V_Get40, Set_car_Ret376), Set_car_Ret376=FnResult36), block_exit(sys_pf_set_cadar, FnResult36), true))),
   set_opv(f_sys_pf_set_cadar, classof, claz_function),
   set_opv(sys_pf_set_cadar, compile_as, kw_function),
   set_opv(sys_pf_set_cadar, function, f_sys_pf_set_cadar),
   DefunResult42=sys_pf_set_cadar,
   assert_lsp(sys_pf_set_cdaar,
	      wl:lambda_def(defun, sys_pf_set_cdaar, f_sys_pf_set_cdaar, [sys_x, sys_v], [[sys_set_cdr, [caar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdaar,
	      wl:arglist_info(sys_pf_set_cdaar, f_sys_pf_set_cdaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdaar, wl:init_args(exact_only, f_sys_pf_set_cdaar)),
   assert_lsp(sys_pf_set_cdaar,
	      (f_sys_pf_set_cdaar(X_In44, V_In45, FnResult43):-Env245=[bv(sys_x, X_In44), bv(sys_v, V_In45)|CDR], global_env([[]|CDR]), catch((get_var(Env245, sys_x, X_Get46), cl_caar(X_Get46, Set_cdr_Param336), get_var(Env245, sys_v, V_Get47), f_sys_set_cdr(Set_cdr_Param336, V_Get47, Set_cdr_Ret377), Set_cdr_Ret377=FnResult43), block_exit(sys_pf_set_cdaar, FnResult43), true))),
   set_opv(f_sys_pf_set_cdaar, classof, claz_function),
   set_opv(sys_pf_set_cdaar, compile_as, kw_function),
   set_opv(sys_pf_set_cdaar, function, f_sys_pf_set_cdaar),
   DefunResult49=sys_pf_set_cdaar,
   assert_lsp(sys_pf_set_cddar,
	      wl:lambda_def(defun, sys_pf_set_cddar, f_sys_pf_set_cddar, [sys_x, sys_v], [[sys_set_cdr, [cdar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cddar,
	      wl:arglist_info(sys_pf_set_cddar, f_sys_pf_set_cddar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cddar, wl:init_args(exact_only, f_sys_pf_set_cddar)),
   assert_lsp(sys_pf_set_cddar,
	      (f_sys_pf_set_cddar(X_In51, V_In52, FnResult50):-Env246=[bv(sys_x, X_In51), bv(sys_v, V_In52)|CDR], global_env([[]|CDR]), catch((get_var(Env246, sys_x, X_Get53), cl_cdar(X_Get53, Set_cdr_Param337), get_var(Env246, sys_v, V_Get54), f_sys_set_cdr(Set_cdr_Param337, V_Get54, Set_cdr_Ret378), Set_cdr_Ret378=FnResult50), block_exit(sys_pf_set_cddar, FnResult50), true))),
   set_opv(f_sys_pf_set_cddar, classof, claz_function),
   set_opv(sys_pf_set_cddar, compile_as, kw_function),
   set_opv(sys_pf_set_cddar, function, f_sys_pf_set_cddar),
   DefunResult56=sys_pf_set_cddar,
   assert_lsp(sys_pf_set_caadr,
	      wl:lambda_def(defun, sys_pf_set_caadr, f_sys_pf_set_caadr, [sys_x, sys_v], [[sys_set_car, [cadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caadr,
	      wl:arglist_info(sys_pf_set_caadr, f_sys_pf_set_caadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caadr, wl:init_args(exact_only, f_sys_pf_set_caadr)),
   assert_lsp(sys_pf_set_caadr,
	      (f_sys_pf_set_caadr(X_In58, V_In59, FnResult57):-Env247=[bv(sys_x, X_In58), bv(sys_v, V_In59)|CDR], global_env([[]|CDR]), catch((get_var(Env247, sys_x, X_Get60), cl_cadr(X_Get60, Set_car_Param338), get_var(Env247, sys_v, V_Get61), f_sys_set_car(Set_car_Param338, V_Get61, Set_car_Ret379), Set_car_Ret379=FnResult57), block_exit(sys_pf_set_caadr, FnResult57), true))),
   set_opv(f_sys_pf_set_caadr, classof, claz_function),
   set_opv(sys_pf_set_caadr, compile_as, kw_function),
   set_opv(sys_pf_set_caadr, function, f_sys_pf_set_caadr),
   DefunResult63=sys_pf_set_caadr,
   assert_lsp(sys_pf_set_caddr,
	      wl:lambda_def(defun, sys_pf_set_caddr, f_sys_pf_set_caddr, [sys_x, sys_v], [[sys_set_car, [cddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caddr,
	      wl:arglist_info(sys_pf_set_caddr, f_sys_pf_set_caddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caddr, wl:init_args(exact_only, f_sys_pf_set_caddr)),
   assert_lsp(sys_pf_set_caddr,
	      (f_sys_pf_set_caddr(X_In65, V_In66, FnResult64):-Env248=[bv(sys_x, X_In65), bv(sys_v, V_In66)|CDR], global_env([[]|CDR]), catch((get_var(Env248, sys_x, X_Get67), cl_cddr(X_Get67, Set_car_Param339), get_var(Env248, sys_v, V_Get68), f_sys_set_car(Set_car_Param339, V_Get68, Set_car_Ret380), Set_car_Ret380=FnResult64), block_exit(sys_pf_set_caddr, FnResult64), true))),
   set_opv(f_sys_pf_set_caddr, classof, claz_function),
   set_opv(sys_pf_set_caddr, compile_as, kw_function),
   set_opv(sys_pf_set_caddr, function, f_sys_pf_set_caddr),
   DefunResult70=sys_pf_set_caddr,
   assert_lsp(sys_pf_set_cdadr,
	      wl:lambda_def(defun, sys_pf_set_cdadr, f_sys_pf_set_cdadr, [sys_x, sys_v], [[sys_set_cdr, [cadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdadr,
	      wl:arglist_info(sys_pf_set_cdadr, f_sys_pf_set_cdadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdadr, wl:init_args(exact_only, f_sys_pf_set_cdadr)),
   assert_lsp(sys_pf_set_cdadr,
	      (f_sys_pf_set_cdadr(X_In72, V_In73, FnResult71):-Env249=[bv(sys_x, X_In72), bv(sys_v, V_In73)|CDR], global_env([[]|CDR]), catch((get_var(Env249, sys_x, X_Get74), cl_cadr(X_Get74, Set_cdr_Param340), get_var(Env249, sys_v, V_Get75), f_sys_set_cdr(Set_cdr_Param340, V_Get75, Set_cdr_Ret381), Set_cdr_Ret381=FnResult71), block_exit(sys_pf_set_cdadr, FnResult71), true))),
   set_opv(f_sys_pf_set_cdadr, classof, claz_function),
   set_opv(sys_pf_set_cdadr, compile_as, kw_function),
   set_opv(sys_pf_set_cdadr, function, f_sys_pf_set_cdadr),
   DefunResult77=sys_pf_set_cdadr,
   assert_lsp(sys_pf_set_cdddr,
	      wl:lambda_def(defun, sys_pf_set_cdddr, f_sys_pf_set_cdddr, [sys_x, sys_v], [[sys_set_cdr, [cddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdddr,
	      wl:arglist_info(sys_pf_set_cdddr, f_sys_pf_set_cdddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdddr, wl:init_args(exact_only, f_sys_pf_set_cdddr)),
   assert_lsp(sys_pf_set_cdddr,
	      (f_sys_pf_set_cdddr(X_In79, V_In80, FnResult78):-Env250=[bv(sys_x, X_In79), bv(sys_v, V_In80)|CDR], global_env([[]|CDR]), catch((get_var(Env250, sys_x, X_Get81), cl_cddr(X_Get81, Set_cdr_Param341), get_var(Env250, sys_v, V_Get82), f_sys_set_cdr(Set_cdr_Param341, V_Get82, Set_cdr_Ret382), Set_cdr_Ret382=FnResult78), block_exit(sys_pf_set_cdddr, FnResult78), true))),
   set_opv(f_sys_pf_set_cdddr, classof, claz_function),
   set_opv(sys_pf_set_cdddr, compile_as, kw_function),
   set_opv(sys_pf_set_cdddr, function, f_sys_pf_set_cdddr),
   DefunResult84=sys_pf_set_cdddr,
   assert_lsp(sys_pf_set_caaaar,
	      wl:lambda_def(defun, sys_pf_set_caaaar, f_sys_pf_set_caaaar, [sys_x, sys_v], [[sys_set_car, [caaar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caaaar,
	      wl:arglist_info(sys_pf_set_caaaar, f_sys_pf_set_caaaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caaaar, wl:init_args(exact_only, f_sys_pf_set_caaaar)),
   assert_lsp(sys_pf_set_caaaar,
	      (f_sys_pf_set_caaaar(X_In86, V_In87, FnResult85):-Env251=[bv(sys_x, X_In86), bv(sys_v, V_In87)|CDR], global_env([[]|CDR]), catch((get_var(Env251, sys_x, X_Get88), cl_caaar(X_Get88, Set_car_Param342), get_var(Env251, sys_v, V_Get89), f_sys_set_car(Set_car_Param342, V_Get89, Set_car_Ret383), Set_car_Ret383=FnResult85), block_exit(sys_pf_set_caaaar, FnResult85), true))),
   set_opv(f_sys_pf_set_caaaar, classof, claz_function),
   set_opv(sys_pf_set_caaaar, compile_as, kw_function),
   set_opv(sys_pf_set_caaaar, function, f_sys_pf_set_caaaar),
   DefunResult91=sys_pf_set_caaaar,
   assert_lsp(sys_pf_set_cadaar,
	      wl:lambda_def(defun, sys_pf_set_cadaar, f_sys_pf_set_cadaar, [sys_x, sys_v], [[sys_set_car, [cdaar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cadaar,
	      wl:arglist_info(sys_pf_set_cadaar, f_sys_pf_set_cadaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cadaar, wl:init_args(exact_only, f_sys_pf_set_cadaar)),
   assert_lsp(sys_pf_set_cadaar,
	      (f_sys_pf_set_cadaar(X_In93, V_In94, FnResult92):-Env252=[bv(sys_x, X_In93), bv(sys_v, V_In94)|CDR], global_env([[]|CDR]), catch((get_var(Env252, sys_x, X_Get95), cl_cdaar(X_Get95, Set_car_Param343), get_var(Env252, sys_v, V_Get96), f_sys_set_car(Set_car_Param343, V_Get96, Set_car_Ret384), Set_car_Ret384=FnResult92), block_exit(sys_pf_set_cadaar, FnResult92), true))),
   set_opv(f_sys_pf_set_cadaar, classof, claz_function),
   set_opv(sys_pf_set_cadaar, compile_as, kw_function),
   set_opv(sys_pf_set_cadaar, function, f_sys_pf_set_cadaar),
   DefunResult98=sys_pf_set_cadaar,
   assert_lsp(sys_pf_set_cdaaar,
	      wl:lambda_def(defun, sys_pf_set_cdaaar, f_sys_pf_set_cdaaar, [sys_x, sys_v], [[sys_set_cdr, [caaar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdaaar,
	      wl:arglist_info(sys_pf_set_cdaaar, f_sys_pf_set_cdaaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdaaar, wl:init_args(exact_only, f_sys_pf_set_cdaaar)),
   assert_lsp(sys_pf_set_cdaaar,
	      (f_sys_pf_set_cdaaar(X_In100, V_In101, FnResult99):-Env253=[bv(sys_x, X_In100), bv(sys_v, V_In101)|CDR], global_env([[]|CDR]), catch((get_var(Env253, sys_x, X_Get102), cl_caaar(X_Get102, Set_cdr_Param344), get_var(Env253, sys_v, V_Get103), f_sys_set_cdr(Set_cdr_Param344, V_Get103, Set_cdr_Ret385), Set_cdr_Ret385=FnResult99), block_exit(sys_pf_set_cdaaar, FnResult99), true))),
   set_opv(f_sys_pf_set_cdaaar, classof, claz_function),
   set_opv(sys_pf_set_cdaaar, compile_as, kw_function),
   set_opv(sys_pf_set_cdaaar, function, f_sys_pf_set_cdaaar),
   DefunResult105=sys_pf_set_cdaaar,
   assert_lsp(sys_pf_set_cddaar,
	      wl:lambda_def(defun, sys_pf_set_cddaar, f_sys_pf_set_cddaar, [sys_x, sys_v], [[sys_set_cdr, [cdaar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cddaar,
	      wl:arglist_info(sys_pf_set_cddaar, f_sys_pf_set_cddaar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cddaar, wl:init_args(exact_only, f_sys_pf_set_cddaar)),
   assert_lsp(sys_pf_set_cddaar,
	      (f_sys_pf_set_cddaar(X_In107, V_In108, FnResult106):-Env254=[bv(sys_x, X_In107), bv(sys_v, V_In108)|CDR], global_env([[]|CDR]), catch((get_var(Env254, sys_x, X_Get109), cl_cdaar(X_Get109, Set_cdr_Param345), get_var(Env254, sys_v, V_Get110), f_sys_set_cdr(Set_cdr_Param345, V_Get110, Set_cdr_Ret386), Set_cdr_Ret386=FnResult106), block_exit(sys_pf_set_cddaar, FnResult106), true))),
   set_opv(f_sys_pf_set_cddaar, classof, claz_function),
   set_opv(sys_pf_set_cddaar, compile_as, kw_function),
   set_opv(sys_pf_set_cddaar, function, f_sys_pf_set_cddaar),
   DefunResult112=sys_pf_set_cddaar,
   assert_lsp(sys_pf_set_caadar,
	      wl:lambda_def(defun, sys_pf_set_caadar, f_sys_pf_set_caadar, [sys_x, sys_v], [[sys_set_car, [cadar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caadar,
	      wl:arglist_info(sys_pf_set_caadar, f_sys_pf_set_caadar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caadar, wl:init_args(exact_only, f_sys_pf_set_caadar)),
   assert_lsp(sys_pf_set_caadar,
	      (f_sys_pf_set_caadar(X_In114, V_In115, FnResult113):-Env255=[bv(sys_x, X_In114), bv(sys_v, V_In115)|CDR], global_env([[]|CDR]), catch((get_var(Env255, sys_x, X_Get116), cl_cadar(X_Get116, Set_car_Param346), get_var(Env255, sys_v, V_Get117), f_sys_set_car(Set_car_Param346, V_Get117, Set_car_Ret387), Set_car_Ret387=FnResult113), block_exit(sys_pf_set_caadar, FnResult113), true))),
   set_opv(f_sys_pf_set_caadar, classof, claz_function),
   set_opv(sys_pf_set_caadar, compile_as, kw_function),
   set_opv(sys_pf_set_caadar, function, f_sys_pf_set_caadar),
   DefunResult119=sys_pf_set_caadar,
   assert_lsp(sys_pf_set_caddar,
	      wl:lambda_def(defun, sys_pf_set_caddar, f_sys_pf_set_caddar, [sys_x, sys_v], [[sys_set_car, [cddar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caddar,
	      wl:arglist_info(sys_pf_set_caddar, f_sys_pf_set_caddar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caddar, wl:init_args(exact_only, f_sys_pf_set_caddar)),
   assert_lsp(sys_pf_set_caddar,
	      (f_sys_pf_set_caddar(X_In121, V_In122, FnResult120):-Env256=[bv(sys_x, X_In121), bv(sys_v, V_In122)|CDR], global_env([[]|CDR]), catch((get_var(Env256, sys_x, X_Get123), cl_cddar(X_Get123, Set_car_Param347), get_var(Env256, sys_v, V_Get124), f_sys_set_car(Set_car_Param347, V_Get124, Set_car_Ret388), Set_car_Ret388=FnResult120), block_exit(sys_pf_set_caddar, FnResult120), true))),
   set_opv(f_sys_pf_set_caddar, classof, claz_function),
   set_opv(sys_pf_set_caddar, compile_as, kw_function),
   set_opv(sys_pf_set_caddar, function, f_sys_pf_set_caddar),
   DefunResult126=sys_pf_set_caddar,
   assert_lsp(sys_pf_set_cdadar,
	      wl:lambda_def(defun, sys_pf_set_cdadar, f_sys_pf_set_cdadar, [sys_x, sys_v], [[sys_set_cdr, [cadar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdadar,
	      wl:arglist_info(sys_pf_set_cdadar, f_sys_pf_set_cdadar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdadar, wl:init_args(exact_only, f_sys_pf_set_cdadar)),
   assert_lsp(sys_pf_set_cdadar,
	      (f_sys_pf_set_cdadar(X_In128, V_In129, FnResult127):-Env257=[bv(sys_x, X_In128), bv(sys_v, V_In129)|CDR], global_env([[]|CDR]), catch((get_var(Env257, sys_x, X_Get130), cl_cadar(X_Get130, Set_cdr_Param348), get_var(Env257, sys_v, V_Get131), f_sys_set_cdr(Set_cdr_Param348, V_Get131, Set_cdr_Ret389), Set_cdr_Ret389=FnResult127), block_exit(sys_pf_set_cdadar, FnResult127), true))),
   set_opv(f_sys_pf_set_cdadar, classof, claz_function),
   set_opv(sys_pf_set_cdadar, compile_as, kw_function),
   set_opv(sys_pf_set_cdadar, function, f_sys_pf_set_cdadar),
   DefunResult133=sys_pf_set_cdadar,
   assert_lsp(sys_pf_set_cdddar,
	      wl:lambda_def(defun, sys_pf_set_cdddar, f_sys_pf_set_cdddar, [sys_x, sys_v], [[sys_set_cdr, [cddar, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdddar,
	      wl:arglist_info(sys_pf_set_cdddar, f_sys_pf_set_cdddar, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdddar, wl:init_args(exact_only, f_sys_pf_set_cdddar)),
   assert_lsp(sys_pf_set_cdddar,
	      (f_sys_pf_set_cdddar(X_In135, V_In136, FnResult134):-Env258=[bv(sys_x, X_In135), bv(sys_v, V_In136)|CDR], global_env([[]|CDR]), catch((get_var(Env258, sys_x, X_Get137), cl_cddar(X_Get137, Set_cdr_Param349), get_var(Env258, sys_v, V_Get138), f_sys_set_cdr(Set_cdr_Param349, V_Get138, Set_cdr_Ret390), Set_cdr_Ret390=FnResult134), block_exit(sys_pf_set_cdddar, FnResult134), true))),
   set_opv(f_sys_pf_set_cdddar, classof, claz_function),
   set_opv(sys_pf_set_cdddar, compile_as, kw_function),
   set_opv(sys_pf_set_cdddar, function, f_sys_pf_set_cdddar),
   DefunResult140=sys_pf_set_cdddar,
   assert_lsp(sys_pf_set_caaadr,
	      wl:lambda_def(defun, sys_pf_set_caaadr, f_sys_pf_set_caaadr, [sys_x, sys_v], [[sys_set_car, [caadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caaadr,
	      wl:arglist_info(sys_pf_set_caaadr, f_sys_pf_set_caaadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caaadr, wl:init_args(exact_only, f_sys_pf_set_caaadr)),
   assert_lsp(sys_pf_set_caaadr,
	      (f_sys_pf_set_caaadr(X_In142, V_In143, FnResult141):-Env259=[bv(sys_x, X_In142), bv(sys_v, V_In143)|CDR], global_env([[]|CDR]), catch((get_var(Env259, sys_x, X_Get144), cl_caadr(X_Get144, Set_car_Param350), get_var(Env259, sys_v, V_Get145), f_sys_set_car(Set_car_Param350, V_Get145, Set_car_Ret391), Set_car_Ret391=FnResult141), block_exit(sys_pf_set_caaadr, FnResult141), true))),
   set_opv(f_sys_pf_set_caaadr, classof, claz_function),
   set_opv(sys_pf_set_caaadr, compile_as, kw_function),
   set_opv(sys_pf_set_caaadr, function, f_sys_pf_set_caaadr),
   DefunResult147=sys_pf_set_caaadr,
   assert_lsp(sys_pf_set_cadadr,
	      wl:lambda_def(defun, sys_pf_set_cadadr, f_sys_pf_set_cadadr, [sys_x, sys_v], [[sys_set_car, [cdadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cadadr,
	      wl:arglist_info(sys_pf_set_cadadr, f_sys_pf_set_cadadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cadadr, wl:init_args(exact_only, f_sys_pf_set_cadadr)),
   assert_lsp(sys_pf_set_cadadr,
	      (f_sys_pf_set_cadadr(X_In149, V_In150, FnResult148):-Env260=[bv(sys_x, X_In149), bv(sys_v, V_In150)|CDR], global_env([[]|CDR]), catch((get_var(Env260, sys_x, X_Get151), cl_cdadr(X_Get151, Set_car_Param351), get_var(Env260, sys_v, V_Get152), f_sys_set_car(Set_car_Param351, V_Get152, Set_car_Ret392), Set_car_Ret392=FnResult148), block_exit(sys_pf_set_cadadr, FnResult148), true))),
   set_opv(f_sys_pf_set_cadadr, classof, claz_function),
   set_opv(sys_pf_set_cadadr, compile_as, kw_function),
   set_opv(sys_pf_set_cadadr, function, f_sys_pf_set_cadadr),
   DefunResult154=sys_pf_set_cadadr,
   assert_lsp(sys_pf_set_cdaadr,
	      wl:lambda_def(defun, sys_pf_set_cdaadr, f_sys_pf_set_cdaadr, [sys_x, sys_v], [[sys_set_cdr, [caadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdaadr,
	      wl:arglist_info(sys_pf_set_cdaadr, f_sys_pf_set_cdaadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdaadr, wl:init_args(exact_only, f_sys_pf_set_cdaadr)),
   assert_lsp(sys_pf_set_cdaadr,
	      (f_sys_pf_set_cdaadr(X_In156, V_In157, FnResult155):-Env261=[bv(sys_x, X_In156), bv(sys_v, V_In157)|CDR], global_env([[]|CDR]), catch((get_var(Env261, sys_x, X_Get158), cl_caadr(X_Get158, Set_cdr_Param352), get_var(Env261, sys_v, V_Get159), f_sys_set_cdr(Set_cdr_Param352, V_Get159, Set_cdr_Ret393), Set_cdr_Ret393=FnResult155), block_exit(sys_pf_set_cdaadr, FnResult155), true))),
   set_opv(f_sys_pf_set_cdaadr, classof, claz_function),
   set_opv(sys_pf_set_cdaadr, compile_as, kw_function),
   set_opv(sys_pf_set_cdaadr, function, f_sys_pf_set_cdaadr),
   DefunResult161=sys_pf_set_cdaadr,
   assert_lsp(sys_pf_set_cddadr,
	      wl:lambda_def(defun, sys_pf_set_cddadr, f_sys_pf_set_cddadr, [sys_x, sys_v], [[sys_set_cdr, [cdadr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cddadr,
	      wl:arglist_info(sys_pf_set_cddadr, f_sys_pf_set_cddadr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cddadr, wl:init_args(exact_only, f_sys_pf_set_cddadr)),
   assert_lsp(sys_pf_set_cddadr,
	      (f_sys_pf_set_cddadr(X_In163, V_In164, FnResult162):-Env262=[bv(sys_x, X_In163), bv(sys_v, V_In164)|CDR], global_env([[]|CDR]), catch((get_var(Env262, sys_x, X_Get165), cl_cdadr(X_Get165, Set_cdr_Param353), get_var(Env262, sys_v, V_Get166), f_sys_set_cdr(Set_cdr_Param353, V_Get166, Set_cdr_Ret394), Set_cdr_Ret394=FnResult162), block_exit(sys_pf_set_cddadr, FnResult162), true))),
   set_opv(f_sys_pf_set_cddadr, classof, claz_function),
   set_opv(sys_pf_set_cddadr, compile_as, kw_function),
   set_opv(sys_pf_set_cddadr, function, f_sys_pf_set_cddadr),
   DefunResult168=sys_pf_set_cddadr,
   assert_lsp(sys_pf_set_caaddr,
	      wl:lambda_def(defun, sys_pf_set_caaddr, f_sys_pf_set_caaddr, [sys_x, sys_v], [[sys_set_car, [caddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_caaddr,
	      wl:arglist_info(sys_pf_set_caaddr, f_sys_pf_set_caaddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_caaddr, wl:init_args(exact_only, f_sys_pf_set_caaddr)),
   assert_lsp(sys_pf_set_caaddr,
	      (f_sys_pf_set_caaddr(X_In170, V_In171, FnResult169):-Env263=[bv(sys_x, X_In170), bv(sys_v, V_In171)|CDR], global_env([[]|CDR]), catch((get_var(Env263, sys_x, X_Get172), cl_caddr(X_Get172, Set_car_Param354), get_var(Env263, sys_v, V_Get173), f_sys_set_car(Set_car_Param354, V_Get173, Set_car_Ret395), Set_car_Ret395=FnResult169), block_exit(sys_pf_set_caaddr, FnResult169), true))),
   set_opv(f_sys_pf_set_caaddr, classof, claz_function),
   set_opv(sys_pf_set_caaddr, compile_as, kw_function),
   set_opv(sys_pf_set_caaddr, function, f_sys_pf_set_caaddr),
   DefunResult175=sys_pf_set_caaddr,
   assert_lsp(sys_pf_set_cadddr,
	      wl:lambda_def(defun, sys_pf_set_cadddr, f_sys_pf_set_cadddr, [sys_x, sys_v], [[sys_set_car, [cdddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cadddr,
	      wl:arglist_info(sys_pf_set_cadddr, f_sys_pf_set_cadddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cadddr, wl:init_args(exact_only, f_sys_pf_set_cadddr)),
   assert_lsp(sys_pf_set_cadddr,
	      (f_sys_pf_set_cadddr(X_In177, V_In178, FnResult176):-Env264=[bv(sys_x, X_In177), bv(sys_v, V_In178)|CDR], global_env([[]|CDR]), catch((get_var(Env264, sys_x, X_Get179), cl_cdddr(X_Get179, Set_car_Param355), get_var(Env264, sys_v, V_Get180), f_sys_set_car(Set_car_Param355, V_Get180, Set_car_Ret396), Set_car_Ret396=FnResult176), block_exit(sys_pf_set_cadddr, FnResult176), true))),
   set_opv(f_sys_pf_set_cadddr, classof, claz_function),
   set_opv(sys_pf_set_cadddr, compile_as, kw_function),
   set_opv(sys_pf_set_cadddr, function, f_sys_pf_set_cadddr),
   DefunResult182=sys_pf_set_cadddr,
   assert_lsp(sys_pf_set_cdaddr,
	      wl:lambda_def(defun, sys_pf_set_cdaddr, f_sys_pf_set_cdaddr, [sys_x, sys_v], [[sys_set_cdr, [caddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cdaddr,
	      wl:arglist_info(sys_pf_set_cdaddr, f_sys_pf_set_cdaddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cdaddr, wl:init_args(exact_only, f_sys_pf_set_cdaddr)),
   assert_lsp(sys_pf_set_cdaddr,
	      (f_sys_pf_set_cdaddr(X_In184, V_In185, FnResult183):-Env265=[bv(sys_x, X_In184), bv(sys_v, V_In185)|CDR], global_env([[]|CDR]), catch((get_var(Env265, sys_x, X_Get186), cl_caddr(X_Get186, Set_cdr_Param356), get_var(Env265, sys_v, V_Get187), f_sys_set_cdr(Set_cdr_Param356, V_Get187, Set_cdr_Ret397), Set_cdr_Ret397=FnResult183), block_exit(sys_pf_set_cdaddr, FnResult183), true))),
   set_opv(f_sys_pf_set_cdaddr, classof, claz_function),
   set_opv(sys_pf_set_cdaddr, compile_as, kw_function),
   set_opv(sys_pf_set_cdaddr, function, f_sys_pf_set_cdaddr),
   DefunResult189=sys_pf_set_cdaddr,
   assert_lsp(sys_pf_set_cddddr,
	      wl:lambda_def(defun, sys_pf_set_cddddr, f_sys_pf_set_cddddr, [sys_x, sys_v], [[sys_set_cdr, [cdddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_cddddr,
	      wl:arglist_info(sys_pf_set_cddddr, f_sys_pf_set_cddddr, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_cddddr, wl:init_args(exact_only, f_sys_pf_set_cddddr)),
   assert_lsp(sys_pf_set_cddddr,
	      (f_sys_pf_set_cddddr(X_In191, V_In192, FnResult190):-Env266=[bv(sys_x, X_In191), bv(sys_v, V_In192)|CDR], global_env([[]|CDR]), catch((get_var(Env266, sys_x, X_Get193), cl_cdddr(X_Get193, Set_cdr_Param357), get_var(Env266, sys_v, V_Get194), f_sys_set_cdr(Set_cdr_Param357, V_Get194, Set_cdr_Ret398), Set_cdr_Ret398=FnResult190), block_exit(sys_pf_set_cddddr, FnResult190), true))),
   set_opv(f_sys_pf_set_cddddr, classof, claz_function),
   set_opv(sys_pf_set_cddddr, compile_as, kw_function),
   set_opv(sys_pf_set_cddddr, function, f_sys_pf_set_cddddr),
   DefunResult196=sys_pf_set_cddddr,
   cl_defsetf(car, sys_set_car, Set_car),
   cl_defsetf(cdr, sys_set_cdr, Set_cdr),
   cl_defsetf(caar, sys_pf_set_caar, Set_caar),
   cl_defsetf(cadr, sys_pf_set_cadr, Set_cadr),
   cl_defsetf(cdar, sys_pf_set_cdar, Set_cdar),
   cl_defsetf(cddr, sys_pf_set_cddr, Set_cddr),
   cl_defsetf(caaar, sys_pf_set_caaar, Set_caaar),
   cl_defsetf(cadar, sys_pf_set_cadar, Set_cadar),
   cl_defsetf(cdaar, sys_pf_set_cdaar, Set_cdaar),
   cl_defsetf(cddar, sys_pf_set_cddar, Set_cddar),
   cl_defsetf(caadr, sys_pf_set_caadr, Set_caadr),
   cl_defsetf(caddr, sys_pf_set_caddr, Set_caddr),
   cl_defsetf(cdadr, sys_pf_set_cdadr, Set_cdadr),
   cl_defsetf(cdddr, sys_pf_set_cdddr, Set_cdddr),
   cl_defsetf(caaaar, sys_pf_set_caaaar, Set_caaaar),
   cl_defsetf(cadaar, sys_pf_set_cadaar, Set_cadaar),
   cl_defsetf(cdaaar, sys_pf_set_cdaaar, Set_cdaaar),
   cl_defsetf(cddaar, sys_pf_set_cddaar, Set_cddaar),
   cl_defsetf(caadar, sys_pf_set_caadar, Set_caadar),
   cl_defsetf(caddar, sys_pf_set_caddar, Set_caddar),
   cl_defsetf(cdadar, sys_pf_set_cdadar, Set_cdadar),
   cl_defsetf(cdddar, sys_pf_set_cdddar, Set_cdddar),
   cl_defsetf(caaadr, sys_pf_set_caaadr, Set_caaadr),
   cl_defsetf(cadadr, sys_pf_set_cadadr, Set_cadadr),
   cl_defsetf(cdaadr, sys_pf_set_cdaadr, Set_cdaadr),
   cl_defsetf(cddadr, sys_pf_set_cddadr, Set_cddadr),
   cl_defsetf(caaddr, sys_pf_set_caaddr, Set_caaddr),
   cl_defsetf(cadddr, sys_pf_set_cadddr, Set_cadddr),
   cl_defsetf(cdaddr, sys_pf_set_cdaddr, Set_cdaddr),
   cl_defsetf(cddddr, sys_pf_set_cddddr, Set_cddddr),
   cl_defsetf(first, sys_set_car, Set_car297),
   cl_defsetf(second, sys_pf_set_cadr, Set_cadr298),
   cl_defsetf(third, sys_pf_set_caddr, Set_caddr299),
   cl_defsetf(fourth, sys_pf_set_cadddr, Set_cadddr300),
   assert_lsp(sys_pf_set_fifth,
	      wl:lambda_def(defun, sys_pf_set_fifth, f_sys_pf_set_fifth, [sys_x, sys_v], [[sys_set_car, [cddddr, sys_x], sys_v]])),
   assert_lsp(sys_pf_set_fifth,
	      wl:arglist_info(sys_pf_set_fifth, f_sys_pf_set_fifth, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_fifth, wl:init_args(exact_only, f_sys_pf_set_fifth)),
   assert_lsp(sys_pf_set_fifth,
	      (f_sys_pf_set_fifth(X_In198, V_In199, FnResult197):-Env301=[bv(sys_x, X_In198), bv(sys_v, V_In199)|CDR], global_env([[]|CDR]), catch((get_var(Env301, sys_x, X_Get200), cl_cddddr(X_Get200, Set_car_Param358), get_var(Env301, sys_v, V_Get201), f_sys_set_car(Set_car_Param358, V_Get201, Set_car_Ret399), Set_car_Ret399=FnResult197), block_exit(sys_pf_set_fifth, FnResult197), true))),
   set_opv(f_sys_pf_set_fifth, classof, claz_function),
   set_opv(sys_pf_set_fifth, compile_as, kw_function),
   set_opv(sys_pf_set_fifth, function, f_sys_pf_set_fifth),
   DefunResult203=sys_pf_set_fifth,
   cl_defsetf(fifth, sys_pf_set_fifth, Set_fifth),
   assert_lsp(sys_pf_set_sixth,
	      wl:lambda_def(defun, sys_pf_set_sixth, f_sys_pf_set_sixth, [sys_x, sys_v], [[sys_set_car, [cdr, [cddddr, sys_x]], sys_v]])),
   assert_lsp(sys_pf_set_sixth,
	      wl:arglist_info(sys_pf_set_sixth, f_sys_pf_set_sixth, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_sixth, wl:init_args(exact_only, f_sys_pf_set_sixth)),
   assert_lsp(sys_pf_set_sixth,
	      (f_sys_pf_set_sixth(X_In205, V_In206, FnResult204):-Env303=[bv(sys_x, X_In205), bv(sys_v, V_In206)|CDR], global_env([[]|CDR]), catch((get_var(Env303, sys_x, X_Get207), cl_cddddr(X_Get207, Cdr_Param), cl_cdr(Cdr_Param, Set_car_Param360), get_var(Env303, sys_v, V_Get208), f_sys_set_car(Set_car_Param360, V_Get208, Set_car_Ret400), Set_car_Ret400=FnResult204), block_exit(sys_pf_set_sixth, FnResult204), true))),
   set_opv(f_sys_pf_set_sixth, classof, claz_function),
   set_opv(sys_pf_set_sixth, compile_as, kw_function),
   set_opv(sys_pf_set_sixth, function, f_sys_pf_set_sixth),
   DefunResult210=sys_pf_set_sixth,
   cl_defsetf(sixth, sys_pf_set_sixth, Set_sixth),
   assert_lsp(sys_pf_set_seventh,
	      wl:lambda_def(defun, sys_pf_set_seventh, f_sys_pf_set_seventh, [sys_x, sys_v], [[sys_set_car, [cddr, [cddddr, sys_x]], sys_v]])),
   assert_lsp(sys_pf_set_seventh,
	      wl:arglist_info(sys_pf_set_seventh, f_sys_pf_set_seventh, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_seventh,
	      wl:init_args(exact_only, f_sys_pf_set_seventh)),
   assert_lsp(sys_pf_set_seventh,
	      (f_sys_pf_set_seventh(X_In212, V_In213, FnResult211):-Env305=[bv(sys_x, X_In212), bv(sys_v, V_In213)|CDR], global_env([[]|CDR]), catch((get_var(Env305, sys_x, X_Get214), cl_cddddr(X_Get214, Cddr_Param), cl_cddr(Cddr_Param, Set_car_Param362), get_var(Env305, sys_v, V_Get215), f_sys_set_car(Set_car_Param362, V_Get215, Set_car_Ret401), Set_car_Ret401=FnResult211), block_exit(sys_pf_set_seventh, FnResult211), true))),
   set_opv(f_sys_pf_set_seventh, classof, claz_function),
   set_opv(sys_pf_set_seventh, compile_as, kw_function),
   set_opv(sys_pf_set_seventh, function, f_sys_pf_set_seventh),
   DefunResult217=sys_pf_set_seventh,
   cl_defsetf(seventh, sys_pf_set_seventh, Set_seventh),
   assert_lsp(sys_pf_set_eighth,
	      wl:lambda_def(defun, sys_pf_set_eighth, f_sys_pf_set_eighth, [sys_x, sys_v], [[sys_set_car, [cdddr, [cddddr, sys_x]], sys_v]])),
   assert_lsp(sys_pf_set_eighth,
	      wl:arglist_info(sys_pf_set_eighth, f_sys_pf_set_eighth, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_eighth, wl:init_args(exact_only, f_sys_pf_set_eighth)),
   assert_lsp(sys_pf_set_eighth,
	      (f_sys_pf_set_eighth(X_In219, V_In220, FnResult218):-Env307=[bv(sys_x, X_In219), bv(sys_v, V_In220)|CDR], global_env([[]|CDR]), catch((get_var(Env307, sys_x, X_Get221), cl_cddddr(X_Get221, Cdddr_Param), cl_cdddr(Cdddr_Param, Set_car_Param364), get_var(Env307, sys_v, V_Get222), f_sys_set_car(Set_car_Param364, V_Get222, Set_car_Ret402), Set_car_Ret402=FnResult218), block_exit(sys_pf_set_eighth, FnResult218), true))),
   set_opv(f_sys_pf_set_eighth, classof, claz_function),
   set_opv(sys_pf_set_eighth, compile_as, kw_function),
   set_opv(sys_pf_set_eighth, function, f_sys_pf_set_eighth),
   DefunResult224=sys_pf_set_eighth,
   cl_defsetf(eighth, sys_pf_set_eighth, Set_eighth),
   assert_lsp(sys_pf_set_ninth,
	      wl:lambda_def(defun, sys_pf_set_ninth, f_sys_pf_set_ninth, [sys_x, sys_v], [[sys_set_car, [cddddr, [cddddr, sys_x]], sys_v]])),
   assert_lsp(sys_pf_set_ninth,
	      wl:arglist_info(sys_pf_set_ninth, f_sys_pf_set_ninth, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_ninth, wl:init_args(exact_only, f_sys_pf_set_ninth)),
   assert_lsp(sys_pf_set_ninth,
	      (f_sys_pf_set_ninth(X_In226, V_In227, FnResult225):-Env309=[bv(sys_x, X_In226), bv(sys_v, V_In227)|CDR], global_env([[]|CDR]), catch((get_var(Env309, sys_x, X_Get228), cl_cddddr(X_Get228, Cddddr_Param), cl_cddddr(Cddddr_Param, Set_car_Param366), get_var(Env309, sys_v, V_Get229), f_sys_set_car(Set_car_Param366, V_Get229, Set_car_Ret403), Set_car_Ret403=FnResult225), block_exit(sys_pf_set_ninth, FnResult225), true))),
   set_opv(f_sys_pf_set_ninth, classof, claz_function),
   set_opv(sys_pf_set_ninth, compile_as, kw_function),
   set_opv(sys_pf_set_ninth, function, f_sys_pf_set_ninth),
   DefunResult231=sys_pf_set_ninth,
   cl_defsetf(ninth, sys_pf_set_ninth, Set_ninth),
   assert_lsp(sys_pf_set_tenth,
	      wl:lambda_def(defun, sys_pf_set_tenth, f_sys_pf_set_tenth, [sys_x, sys_v], [[sys_set_car, [cdr, [cddddr, [cddddr, sys_x]]], sys_v]])),
   assert_lsp(sys_pf_set_tenth,
	      wl:arglist_info(sys_pf_set_tenth, f_sys_pf_set_tenth, [sys_x, sys_v], arginfo{all:[sys_x, sys_v], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_v], opt:0, req:[sys_x, sys_v], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_pf_set_tenth, wl:init_args(exact_only, f_sys_pf_set_tenth)),
   assert_lsp(sys_pf_set_tenth,
	      (f_sys_pf_set_tenth(X_In233, V_In234, FnResult232):-Env311=[bv(sys_x, X_In233), bv(sys_v, V_In234)|CDR], global_env([[]|CDR]), catch((get_var(Env311, sys_x, X_Get235), cl_cddddr(X_Get235, Cddddr_Param367), cl_cddddr(Cddddr_Param367, Cdr_Param368), cl_cdr(Cdr_Param368, Set_car_Param369), get_var(Env311, sys_v, V_Get236), f_sys_set_car(Set_car_Param369, V_Get236, Set_car_Ret404), Set_car_Ret404=FnResult232), block_exit(sys_pf_set_tenth, FnResult232), true))),
   set_opv(f_sys_pf_set_tenth, classof, claz_function),
   set_opv(sys_pf_set_tenth, compile_as, kw_function),
   set_opv(sys_pf_set_tenth, function, f_sys_pf_set_tenth),
   DefunResult238=sys_pf_set_tenth,
   cl_defsetf(tenth, sys_pf_set_tenth, Set_tenth),
   cl_defsetf(rest, sys_set_cdr, Set_cdr313),
   cl_defsetf(elt, sys_pf_set_elt, Set_elt),
   cl_defsetf(nth, sys_pf_set_nth, Set_nth),
   cl_defsetf(svref, sys_svset, Svset),
   cl_defsetf(fill_pointer, sys_pf_set_fill_pointer, Set_fill_pointer),
   cl_defsetf(subseq, sys_pf_set_subseq, Set_subseq),
   cl_defsetf(symbol_value, set, Set),
   cl_defsetf(symbol_function, sys_pf_set_symbol_function, Set_symbol_function),
   cl_defsetf(symbol_plist, sys_pf_set_symbol_plist, Set_symbol_plist),
   cl_defsetf(get, sys_put, Put),
   cl_defsetf(gethash, sys_puthash, Puthash),
   cl_defsetf(char, sys_set_char, Set_char),
   cl_defsetf(schar, sys_set_schar, Set_schar),
   cl_defsetf(logical_pathname_translations,
	      sys_pf_set_logical_pathname_translations,
	      Set_logical_pathname_translations),
   cl_defsetf(readtable_case, sys_pf_set_readtable_case, Set_readtable_case),
   cl_defsetf(sys_function_info, sys_pf_set_function_info, Set_function_info),
   cl_defsetf(stream_external_format,
	      sys_pf_set_stream_external_format,
	      Set_stream_external_format),
   cl_defsetf(sys_structure_ref, sys_structure_set, _Ignored).
/*
:- side_effect(assert_lsp(sys_pf_set_caar,
			  lambda_def(defun,
				     sys_pf_set_caar,
				     f_sys_pf_set_caar,
				     [sys_x, sys_v],
				     [[sys_set_car, [car, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caar,
			  arglist_info(sys_pf_set_caar,
				       f_sys_pf_set_caar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caar,
			  init_args(exact_only, f_sys_pf_set_caar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadr,
			  lambda_def(defun,
				     sys_pf_set_cadr,
				     f_sys_pf_set_cadr,
				     [sys_x, sys_v],
				     [[sys_set_car, [cdr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadr,
			  arglist_info(sys_pf_set_cadr,
				       f_sys_pf_set_cadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadr,
			  init_args(exact_only, f_sys_pf_set_cadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdar,
			  lambda_def(defun,
				     sys_pf_set_cdar,
				     f_sys_pf_set_cdar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [car, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdar,
			  arglist_info(sys_pf_set_cdar,
				       f_sys_pf_set_cdar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdar,
			  init_args(exact_only, f_sys_pf_set_cdar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddr,
			  lambda_def(defun,
				     sys_pf_set_cddr,
				     f_sys_pf_set_cddr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cdr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddr,
			  arglist_info(sys_pf_set_cddr,
				       f_sys_pf_set_cddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddr,
			  init_args(exact_only, f_sys_pf_set_cddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaar,
			  lambda_def(defun,
				     sys_pf_set_caaar,
				     f_sys_pf_set_caaar,
				     [sys_x, sys_v],
				     [[sys_set_car, [caar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaar,
			  arglist_info(sys_pf_set_caaar,
				       f_sys_pf_set_caaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaar,
			  init_args(exact_only, f_sys_pf_set_caaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadar,
			  lambda_def(defun,
				     sys_pf_set_cadar,
				     f_sys_pf_set_cadar,
				     [sys_x, sys_v],
				     [[sys_set_car, [cdar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadar,
			  arglist_info(sys_pf_set_cadar,
				       f_sys_pf_set_cadar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadar,
			  init_args(exact_only, f_sys_pf_set_cadar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaar,
			  lambda_def(defun,
				     sys_pf_set_cdaar,
				     f_sys_pf_set_cdaar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [caar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaar,
			  arglist_info(sys_pf_set_cdaar,
				       f_sys_pf_set_cdaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaar,
			  init_args(exact_only, f_sys_pf_set_cdaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddar,
			  lambda_def(defun,
				     sys_pf_set_cddar,
				     f_sys_pf_set_cddar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cdar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddar,
			  arglist_info(sys_pf_set_cddar,
				       f_sys_pf_set_cddar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddar,
			  init_args(exact_only, f_sys_pf_set_cddar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadr,
			  lambda_def(defun,
				     sys_pf_set_caadr,
				     f_sys_pf_set_caadr,
				     [sys_x, sys_v],
				     [[sys_set_car, [cadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadr,
			  arglist_info(sys_pf_set_caadr,
				       f_sys_pf_set_caadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadr,
			  init_args(exact_only, f_sys_pf_set_caadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddr,
			  lambda_def(defun,
				     sys_pf_set_caddr,
				     f_sys_pf_set_caddr,
				     [sys_x, sys_v],
				     [[sys_set_car, [cddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddr,
			  arglist_info(sys_pf_set_caddr,
				       f_sys_pf_set_caddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddr,
			  init_args(exact_only, f_sys_pf_set_caddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadr,
			  lambda_def(defun,
				     sys_pf_set_cdadr,
				     f_sys_pf_set_cdadr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadr,
			  arglist_info(sys_pf_set_cdadr,
				       f_sys_pf_set_cdadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadr,
			  init_args(exact_only, f_sys_pf_set_cdadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddr,
			  lambda_def(defun,
				     sys_pf_set_cdddr,
				     f_sys_pf_set_cdddr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddr,
			  arglist_info(sys_pf_set_cdddr,
				       f_sys_pf_set_cdddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddr,
			  init_args(exact_only, f_sys_pf_set_cdddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaaar,
			  lambda_def(defun,
				     sys_pf_set_caaaar,
				     f_sys_pf_set_caaaar,
				     [sys_x, sys_v],
				     [[sys_set_car, [caaar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaaar,
			  arglist_info(sys_pf_set_caaaar,
				       f_sys_pf_set_caaaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaaar,
			  init_args(exact_only, f_sys_pf_set_caaaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadaar,
			  lambda_def(defun,
				     sys_pf_set_cadaar,
				     f_sys_pf_set_cadaar,
				     [sys_x, sys_v],
				     [[sys_set_car, [cdaar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadaar,
			  arglist_info(sys_pf_set_cadaar,
				       f_sys_pf_set_cadaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadaar,
			  init_args(exact_only, f_sys_pf_set_cadaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaaar,
			  lambda_def(defun,
				     sys_pf_set_cdaaar,
				     f_sys_pf_set_cdaaar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [caaar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaaar,
			  arglist_info(sys_pf_set_cdaaar,
				       f_sys_pf_set_cdaaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaaar,
			  init_args(exact_only, f_sys_pf_set_cdaaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddaar,
			  lambda_def(defun,
				     sys_pf_set_cddaar,
				     f_sys_pf_set_cddaar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cdaar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddaar,
			  arglist_info(sys_pf_set_cddaar,
				       f_sys_pf_set_cddaar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddaar,
			  init_args(exact_only, f_sys_pf_set_cddaar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadar,
			  lambda_def(defun,
				     sys_pf_set_caadar,
				     f_sys_pf_set_caadar,
				     [sys_x, sys_v],
				     [[sys_set_car, [cadar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadar,
			  arglist_info(sys_pf_set_caadar,
				       f_sys_pf_set_caadar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caadar,
			  init_args(exact_only, f_sys_pf_set_caadar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddar,
			  lambda_def(defun,
				     sys_pf_set_caddar,
				     f_sys_pf_set_caddar,
				     [sys_x, sys_v],
				     [[sys_set_car, [cddar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddar,
			  arglist_info(sys_pf_set_caddar,
				       f_sys_pf_set_caddar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caddar,
			  init_args(exact_only, f_sys_pf_set_caddar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadar,
			  lambda_def(defun,
				     sys_pf_set_cdadar,
				     f_sys_pf_set_cdadar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cadar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadar,
			  arglist_info(sys_pf_set_cdadar,
				       f_sys_pf_set_cdadar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdadar,
			  init_args(exact_only, f_sys_pf_set_cdadar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddar,
			  lambda_def(defun,
				     sys_pf_set_cdddar,
				     f_sys_pf_set_cdddar,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cddar, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddar,
			  arglist_info(sys_pf_set_cdddar,
				       f_sys_pf_set_cdddar,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdddar,
			  init_args(exact_only, f_sys_pf_set_cdddar))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaadr,
			  lambda_def(defun,
				     sys_pf_set_caaadr,
				     f_sys_pf_set_caaadr,
				     [sys_x, sys_v],
				     [[sys_set_car, [caadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaadr,
			  arglist_info(sys_pf_set_caaadr,
				       f_sys_pf_set_caaadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaadr,
			  init_args(exact_only, f_sys_pf_set_caaadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadadr,
			  lambda_def(defun,
				     sys_pf_set_cadadr,
				     f_sys_pf_set_cadadr,
				     [sys_x, sys_v],
				     [[sys_set_car, [cdadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadadr,
			  arglist_info(sys_pf_set_cadadr,
				       f_sys_pf_set_cadadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadadr,
			  init_args(exact_only, f_sys_pf_set_cadadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaadr,
			  lambda_def(defun,
				     sys_pf_set_cdaadr,
				     f_sys_pf_set_cdaadr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [caadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaadr,
			  arglist_info(sys_pf_set_cdaadr,
				       f_sys_pf_set_cdaadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaadr,
			  init_args(exact_only, f_sys_pf_set_cdaadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddadr,
			  lambda_def(defun,
				     sys_pf_set_cddadr,
				     f_sys_pf_set_cddadr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cdadr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddadr,
			  arglist_info(sys_pf_set_cddadr,
				       f_sys_pf_set_cddadr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddadr,
			  init_args(exact_only, f_sys_pf_set_cddadr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaddr,
			  lambda_def(defun,
				     sys_pf_set_caaddr,
				     f_sys_pf_set_caaddr,
				     [sys_x, sys_v],
				     [[sys_set_car, [caddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaddr,
			  arglist_info(sys_pf_set_caaddr,
				       f_sys_pf_set_caaddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_caaddr,
			  init_args(exact_only, f_sys_pf_set_caaddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadddr,
			  lambda_def(defun,
				     sys_pf_set_cadddr,
				     f_sys_pf_set_cadddr,
				     [sys_x, sys_v],
				     [[sys_set_car, [cdddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadddr,
			  arglist_info(sys_pf_set_cadddr,
				       f_sys_pf_set_cadddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cadddr,
			  init_args(exact_only, f_sys_pf_set_cadddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaddr,
			  lambda_def(defun,
				     sys_pf_set_cdaddr,
				     f_sys_pf_set_cdaddr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [caddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaddr,
			  arglist_info(sys_pf_set_cdaddr,
				       f_sys_pf_set_cdaddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cdaddr,
			  init_args(exact_only, f_sys_pf_set_cdaddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddddr,
			  lambda_def(defun,
				     sys_pf_set_cddddr,
				     f_sys_pf_set_cddddr,
				     [sys_x, sys_v],
				     [[sys_set_cdr, [cdddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddddr,
			  arglist_info(sys_pf_set_cddddr,
				       f_sys_pf_set_cddddr,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_cddddr,
			  init_args(exact_only, f_sys_pf_set_cddddr))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_fifth,
			  lambda_def(defun,
				     sys_pf_set_fifth,
				     f_sys_pf_set_fifth,
				     [sys_x, sys_v],
				     [[sys_set_car, [cddddr, sys_x], sys_v]]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_fifth,
			  arglist_info(sys_pf_set_fifth,
				       f_sys_pf_set_fifth,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_fifth,
			  init_args(exact_only, f_sys_pf_set_fifth))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_sixth,
			  lambda_def(defun,
				     sys_pf_set_sixth,
				     f_sys_pf_set_sixth,
				     [sys_x, sys_v],
				     
				     [ 
				       [ sys_set_car,
					 [cdr, [cddddr, sys_x]],
					 sys_v
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_sixth,
			  arglist_info(sys_pf_set_sixth,
				       f_sys_pf_set_sixth,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_sixth,
			  init_args(exact_only, f_sys_pf_set_sixth))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_seventh,
			  lambda_def(defun,
				     sys_pf_set_seventh,
				     f_sys_pf_set_seventh,
				     [sys_x, sys_v],
				     
				     [ 
				       [ sys_set_car,
					 [cddr, [cddddr, sys_x]],
					 sys_v
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_seventh,
			  arglist_info(sys_pf_set_seventh,
				       f_sys_pf_set_seventh,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_seventh,
			  init_args(exact_only, f_sys_pf_set_seventh))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_eighth,
			  lambda_def(defun,
				     sys_pf_set_eighth,
				     f_sys_pf_set_eighth,
				     [sys_x, sys_v],
				     
				     [ 
				       [ sys_set_car,
					 [cdddr, [cddddr, sys_x]],
					 sys_v
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_eighth,
			  arglist_info(sys_pf_set_eighth,
				       f_sys_pf_set_eighth,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_eighth,
			  init_args(exact_only, f_sys_pf_set_eighth))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_ninth,
			  lambda_def(defun,
				     sys_pf_set_ninth,
				     f_sys_pf_set_ninth,
				     [sys_x, sys_v],
				     
				     [ 
				       [ sys_set_car,
					 [cddddr, [cddddr, sys_x]],
					 sys_v
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_ninth,
			  arglist_info(sys_pf_set_ninth,
				       f_sys_pf_set_ninth,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_ninth,
			  init_args(exact_only, f_sys_pf_set_ninth))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_tenth,
			  lambda_def(defun,
				     sys_pf_set_tenth,
				     f_sys_pf_set_tenth,
				     [sys_x, sys_v],
				     
				     [ 
				       [ sys_set_car,
					 [cdr, [cddddr, [cddddr, sys_x]]],
					 sys_v
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_tenth,
			  arglist_info(sys_pf_set_tenth,
				       f_sys_pf_set_tenth,
				       [sys_x, sys_v],
				       arginfo{ all:[sys_x, sys_v],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_v],
						opt:0,
						req:[sys_x, sys_v],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_pf_set_tenth,
			  init_args(exact_only, f_sys_pf_set_tenth))).
*/
/*
; FLET BEGIN
*/
/*
;Redefined in extensible-sequences-base.lisp
*/
/*
; FLET END
*/
/*
;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
*/
/*
;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:
*/
/*
;;;
*/
/*
;;;  Copyright (c) 1984, Taiichi Yuasa and Masami Hagiya.
*/
/*
;;;  Copyright (c) 1990, Giuseppe Attardi.
*/
/*
;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
*/
/*
;;;
*/
/*
;;;    This program is free software; you can redistribute it and/or
*/
/*
;;;    modify it under the terms of the GNU Library General Public
*/
/*
;;;    License as published by the Free;;;    License as published by the Free Software Foundation; either
*/
/*
;;;    version 2 of the License, or (at your option) any later version.
*/
/*
;;;
*/
/*
;;;    See file '../Copyright' for full details.
*/
/*
;;;                           sequence routines
*/
/*
al-when 
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16630 **********************/
:-lisp_compile_to_prolog(pkg_sys,'al-when')
:- get_var(GEnv, sys_al_when, Al_when_Get).
/*
(:execute)
  
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16638 **********************/
:-lisp_compile_to_prolog(pkg_sys,[':execute']).
:- cl_apply(kw_execute, [], _Ignored).
/*
(load (merge-pathnames "seqmacros.lsp" *load-truename*))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16652 **********************/
:-lisp_compile_to_prolog(pkg_sys,[load,['merge-pathnames','$STRING'("seqmacros.lsp"),'*load-truename*']]).
:- get_var(GEnv, xx_load_truename_xx, Xx_load_truename_xx_Get),
   cl_merge_pathnames('$ARRAY'([*], claz_base_character, "seqmacros.lsp"),
		      Xx_load_truename_xx_Get,
		      Load_Param),
   cl_load(Load_Param, [], _Ignored).
/*
)


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16708 **********************/
:-lisp_compile_to_prolog(pkg_sys,')')
:- get_var(GEnv, ')', C41_Get).
/*
#+(or WAM-CL ECL) 
(defun error-not-a-sequence (value)
  ; (declare (c-local))
  (signal-type-error value 'sequence))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16715 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'error-not-a-sequence',[value],['signal-type-error',value,[quote,sequence]]]).
wl:lambda_def(defun, sys_error_not_a_sequence, f_sys_error_not_a_sequence, [sys_value], [[sys_signal_type_error, sys_value, [quote, sequence]]]).
wl:arglist_info(sys_error_not_a_sequence, f_sys_error_not_a_sequence, [sys_value], arginfo{all:[sys_value], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_value], opt:0, req:[sys_value], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_error_not_a_sequence).

/*

### Compiled:  `SYS::ERROR-NOT-A-SEQUENCE` 
*/
f_sys_error_not_a_sequence(Value_In, FnResult) :-
	Env7=[bv(sys_value, Value_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, sys_value, Value_Get),
		f_sys_signal_type_error(Value_Get, sequence, Sequence),
		Sequence=FnResult
	      ),
	      block_exit(sys_error_not_a_sequence, FnResult),
	      true).
:- set_opv(f_sys_error_not_a_sequence, classof, claz_function),
   set_opv(sys_error_not_a_sequence, compile_as, kw_function),
   set_opv(sys_error_not_a_sequence, function, f_sys_error_not_a_sequence),
   DefunResult=sys_error_not_a_sequence.
/*
:- side_effect(assert_lsp(sys_error_not_a_sequence,
			  lambda_def(defun,
				     sys_error_not_a_sequence,
				     f_sys_error_not_a_sequence,
				     [sys_value],
				     
				     [ 
				       [ sys_signal_type_error,
					 sys_value,
					 [quote, sequence]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_error_not_a_sequence,
			  arglist_info(sys_error_not_a_sequence,
				       f_sys_error_not_a_sequence,
				       [sys_value],
				       arginfo{ all:[sys_value],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_value],
						opt:0,
						req:[sys_value],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_error_not_a_sequence,
			  init_args(exact_only, f_sys_error_not_a_sequence))).
*/
/*
 (declare (c-local))
*/
/*
#+(or WAM-CL ECL) 
(defun error-sequence-index (sequence index)
  ; (declare (c-local))
  (error 'simple-type-error
         :datum index
         :expected-type 'unsigned-byte
         :format-control "Not a valid index "#+(or WAM-CL ECL) \r\n(defun error-sequence-index (sequence index)\r\n  ; (declare (c-local))\r\n  (error 'simple-type-error\r\n         :datum index\r\n         :expected-type 'unsigned-byte\r\n         :format-control \"Not a valid index ~A into sequence ~A\"\r\n         :format-arguments (list index sequence)))\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:16839 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'error-sequence-index',[sequence,index],[error,[quote,'simple-type-error'],':datum',index,':expected-type',[quote,'unsigned-byte'],':format-control','$STRING'("Not a valid index ~A into sequence ~A"),':format-arguments',[list,index,sequence]]]).
wl:lambda_def(defun, sys_error_sequence_index, f_sys_error_sequence_index, [sequence, index], [[error, [quote, simple_type_error], kw_datum, index, kw_expected_type, [quote, unsigned_byte], kw_format_control, '$ARRAY'([*], claz_base_character, "Not a valid index ~A into sequence ~A"), kw_format_arguments, [list, index, sequence]]]).
wl:arglist_info(sys_error_sequence_index, f_sys_error_sequence_index, [sequence, index], arginfo{all:[sequence, index], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sequence, index], opt:0, req:[sequence, index], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_error_sequence_index).

/*

### Compiled:  `SYS::ERROR-SEQUENCE-INDEX` 
*/
f_sys_error_sequence_index(Sequence_In, Index_In, FnResult) :-
	Env10=[bv(sequence, Sequence_In), bv(index, Index_In)|Env],
	global_env(Env),
	catch(( get_var(Env10, index, Index_Get6),
		get_var(Env10, sequence, Sequence_Get),
		CAR=[Index_Get6, Sequence_Get],
		cl_error(
			 [ simple_type_error,
			   kw_datum,
			   Index_Get6,
			   kw_expected_type,
			   unsigned_byte,
			   kw_format_control,
			   '$ARRAY'([*],
				    claz_base_character,
				    "Not a valid index ~A into sequence ~A"),
			   kw_format_arguments,
			   CAR
			 ],
			 Error_Ret),
		Error_Ret=FnResult
	      ),
	      block_exit(sys_error_sequence_index, FnResult),
	      true).
:- set_opv(f_sys_error_sequence_index, classof, claz_function),
   set_opv(sys_error_sequence_index, compile_as, kw_function),
   set_opv(sys_error_sequence_index, function, f_sys_error_sequence_index),
   DefunResult=sys_error_sequence_index.
/*
:- side_effect(assert_lsp(sys_error_sequence_index,
			  lambda_def(defun,
				     sys_error_sequence_index,
				     f_sys_error_sequence_index,
				     [sequence, index],
				     
				     [ 
				       [ error,
					 [quote, simple_type_error],
					 kw_datum,
					 index,
					 kw_expected_type,
					 [quote, unsigned_byte],
					 kw_format_control,
					 '$ARRAY'([*],
						  claz_base_character,
						  "Not a valid index ~A into sequence ~A"),
					 kw_format_arguments,
					 [list, index, sequence]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_index,
			  arglist_info(sys_error_sequence_index,
				       f_sys_error_sequence_index,
				       [sequence, index],
				       arginfo{ all:[sequence, index],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sequence, index],
						opt:0,
						req:[sequence, index],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_index,
			  init_args(exact_only, f_sys_error_sequence_index))).
*/
/*
 (declare (c-local))
*/
/*
#+(or WAM-CL ECL) 
(defun error-sequence-type (type)
  ; (declare (c-local))
  (error 'simple-type-error
         :datum (vector) ;; Any sequence object will do, because it does not belong to TYPE
         :expected-type type
         :format-control ""#+(or WAM-CL ECL) \r\n(defun error-sequence-type (type)\r\n  ; (declare (c-local))\r\n  (error 'simple-type-error\r\n         :datum (vector) ;; Any sequence object will do, because it does not belong to TYPE\r\n         :expected-type type\r\n         :format-control \"~S does not specify a sequence type\"\r\n         :format-arguments (list type)))\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:17142 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'error-sequence-type',[type],[error,[quote,'simple-type-error'],':datum',[vector],':expected-type',type,':format-control','$STRING'("~S does not specify a sequence type"),':format-arguments',[list,type]]]).
wl:lambda_def(defun, sys_error_sequence_type, f_sys_error_sequence_type, [type], [[error, [quote, simple_type_error], kw_datum, [vector], kw_expected_type, type, kw_format_control, '$ARRAY'([*], claz_base_character, "~S does not specify a sequence type"), kw_format_arguments, [list, type]]]).
wl:arglist_info(sys_error_sequence_type, f_sys_error_sequence_type, [type], arginfo{all:[type], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[type], opt:0, req:[type], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_error_sequence_type).

/*

### Compiled:  `SYS::ERROR-SEQUENCE-TYPE` 
*/
f_sys_error_sequence_type(Type_In, FnResult) :-
	Env8=[bv(type, Type_In)|Env],
	global_env(Env),
	catch(( cl_vector([], Vector_Ret),
		get_var(Env8, type, Type_Get5),
		CAR=Type_Get5,
		cl_error(
			 [ simple_type_error,
			   kw_datum,
			   Vector_Ret,
			   kw_expected_type,
			   Type_Get5,
			   kw_format_control,
			   '$ARRAY'([*],
				    claz_base_character,
				    "~S does not specify a sequence type"),
			   kw_format_arguments,
			   CAR
			 ],
			 Error_Ret),
		Error_Ret=FnResult
	      ),
	      block_exit(sys_error_sequence_type, FnResult),
	      true).
:- set_opv(f_sys_error_sequence_type, classof, claz_function),
   set_opv(sys_error_sequence_type, compile_as, kw_function),
   set_opv(sys_error_sequence_type, function, f_sys_error_sequence_type),
   DefunResult=sys_error_sequence_type.
/*
:- side_effect(assert_lsp(sys_error_sequence_type,
			  lambda_def(defun,
				     sys_error_sequence_type,
				     f_sys_error_sequence_type,
				     [type],
				     
				     [ 
				       [ error,
					 [quote, simple_type_error],
					 kw_datum,
					 [vector],
					 kw_expected_type,
					 type,
					 kw_format_control,
					 '$ARRAY'([*],
						  claz_base_character,
						  "~S does not specify a sequence type"),
					 kw_format_arguments,
					 [list, type]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_type,
			  arglist_info(sys_error_sequence_type,
				       f_sys_error_sequence_type,
				       [type],
				       arginfo{ all:[type],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[type],
						opt:0,
						req:[type],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_type,
			  init_args(exact_only, f_sys_error_sequence_type))).
*/
/*
 (declare (c-local))
*/
/*
; Any sequence object will do, because it does not belong to TYPE
*/
/*
#+(or WAM-CL ECL) 
(defun error-sequence-length (object type size)
  ; (declare (c-local))
  (error 'simple-type-error
         :format-control
         "Cannot create a sequence of size "#+(or WAM-CL ECL) \r\n(defun error-sequence-length (object type size)\r\n  ; (declare (c-local))\r\n  (error 'simple-type-error\r\n         :format-control\r\n         \"Cannot create a sequence of size ~S which matches type ~S.\"\r\n         :format-arguments (list size type)\r\n         :expected-type type\r\n         :datum object))\r\n\r\n\t\t\t\t \r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:17482 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'error-sequence-length',[object,type,size],[error,[quote,'simple-type-error'],':format-control','$STRING'("Cannot create a sequence of size ~S which matches type ~S."),':format-arguments',[list,size,type],':expected-type',type,':datum',object]]).
wl:lambda_def(defun, sys_error_sequence_length, f_sys_error_sequence_length, [sys_object, type, sys_size], [[error, [quote, simple_type_error], kw_format_control, '$ARRAY'([*], claz_base_character, "Cannot create a sequence of size ~S which matches type ~S."), kw_format_arguments, [list, sys_size, type], kw_expected_type, type, kw_datum, sys_object]]).
wl:arglist_info(sys_error_sequence_length, f_sys_error_sequence_length, [sys_object, type, sys_size], arginfo{all:[sys_object, type, sys_size], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object, type, sys_size], opt:0, req:[sys_object, type, sys_size], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_error_sequence_length).

/*

### Compiled:  `SYS::ERROR-SEQUENCE-LENGTH` 
*/
f_sys_error_sequence_length(Object_In, Type_In, Size_In, FnResult) :-
	Env12=[bv(sys_object, Object_In), bv(type, Type_In), bv(sys_size, Size_In)|Env],
	global_env(Env),
	catch(( get_var(Env12, sys_size, Size_Get),
		get_var(Env12, type, Type_Get),
		CAR=[Size_Get, Type_Get],
		get_var(Env12, sys_object, Object_Get),
		get_var(Env12, type, Type_Get8),
		cl_error(
			 [ simple_type_error,
			   kw_format_control,
			   '$ARRAY'([*],
				    claz_base_character,
				    "Cannot create a sequence of size ~S which matches type ~S."),
			   kw_format_arguments,
			   CAR,
			   kw_expected_type,
			   Type_Get8,
			   kw_datum,
			   Object_Get
			 ],
			 Error_Ret),
		Error_Ret=FnResult
	      ),
	      block_exit(sys_error_sequence_length, FnResult),
	      true).
:- set_opv(f_sys_error_sequence_length, classof, claz_function),
   set_opv(sys_error_sequence_length, compile_as, kw_function),
   set_opv(sys_error_sequence_length, function, f_sys_error_sequence_length),
   DefunResult=sys_error_sequence_length.
/*
:- side_effect(assert_lsp(sys_error_sequence_length,
			  lambda_def(defun,
				     sys_error_sequence_length,
				     f_sys_error_sequence_length,
				     [sys_object, type, sys_size],
				     
				     [ 
				       [ error,
					 [quote, simple_type_error],
					 kw_format_control,
					 '$ARRAY'([*],
						  claz_base_character,
						  "Cannot create a sequence of size ~S which matches type ~S."),
					 kw_format_arguments,
					 [list, sys_size, type],
					 kw_expected_type,
					 type,
					 kw_datum,
					 sys_object
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_length,
			  arglist_info(sys_error_sequence_length,
				       f_sys_error_sequence_length,
				       [sys_object, type, sys_size],
				       arginfo{ all:[sys_object, type, sys_size],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_object,
							type,
							sys_size
						      ],
						opt:0,
						req:[sys_object, type, sys_size],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_error_sequence_length,
			  init_args(exact_only, f_sys_error_sequence_length))).
*/
/*
 (declare (c-local))
*/
/*
#+(or WAM-CL ECL) 
(defun make-sequence (type size &key (initial-element nil iesp) &aux sequence)
  "Args: (type length &key initial-element)
Creates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-
ELEMENT is given, then it becomes the elements of the created sequence.  The
default value of INITIAL-ELEMENT depends on TYPE."
  (multiple-value-bind (element-type length)
      (closest-sequence-type type)
    (cond ((eq element-type 'LIST)
           (setq sequence (make-list size :initial-element initial-element))
           (unless (subtypep 'LIST type)
             (when (or (and (subtypep type 'NULL) (plusp size))
                       (and (subtypep type 'CONS) (zerop size)))
               (error-sequence-length (make-list size :initial-element initial-element) type 0))))
          (t
           (setq sequence (sys:make-vector (if (eq element-type '*) T element-type)
                                           size nil nil nil nil))
           (when iesp
             (fill-array-with-elt sequence initial-element 0 nil))
           (unless (or (eql length '*) (eql length size))
             (error-sequence-length sequence type size))))
    sequence))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:17812 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'make-sequence',[type,size,'&key',['initial-element',[],iesp],'&aux',sequence],'$STRING'("Args: (type length &key initial-element)\r\nCreates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-\r\nELEMENT is given, then it becomes the elements of the created sequence.  The\r\ndefault value of INITIAL-ELEMENT depends on TYPE."),['multiple-value-bind',['element-type',length],['closest-sequence-type',type],[cond,[[eq,'element-type',[quote,'LIST']],[setq,sequence,['make-list',size,':initial-element','initial-element']],[unless,[subtypep,[quote,'LIST'],type],[when,[or,[and,[subtypep,type,[quote,'NULL']],[plusp,size]],[and,[subtypep,type,[quote,'CONS']],[zerop,size]]],['error-sequence-length',['make-list',size,':initial-element','initial-element'],type,0]]]],[t,[setq,sequence,['sys:make-vector',[if,[eq,'element-type',[quote,*]],'T','element-type'],size,[],[],[],[]]],[when,iesp,['fill-array-with-elt',sequence,'initial-element',0,[]]],[unless,[or,[eql,length,[quote,*]],[eql,length,size]],['error-sequence-length',sequence,type,size]]]],sequence]]).
doc: doc_string(make_sequence,
	      _66482340,
	      function,
	      "Args: (type length &key initial-element)\r\nCreates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-\r\nELEMENT is given, then it becomes the elements of the created sequence.  The\r\ndefault value of INITIAL-ELEMENT depends on TYPE.").

wl:lambda_def(defun, make_sequence, cl_make_sequence, [type, sys_size, c38_key, [sys_initial_element, [], sys_iesp], c38_aux, sequence], [[multiple_value_bind, [sys_element_type, length], [sys_closest_sequence_type, type], [cond, [[eq, sys_element_type, [quote, list]], [setq, sequence, [make_list, sys_size, kw_initial_element, sys_initial_element]], [unless, [subtypep, [quote, list], type], [when, [or, [and, [subtypep, type, [quote, null]], [plusp, sys_size]], [and, [subtypep, type, [quote, cons]], [zerop, sys_size]]], [sys_error_sequence_length, [make_list, sys_size, kw_initial_element, sys_initial_element], type, 0]]]], [t, [setq, sequence, [sys_make_vector, [if, [eq, sys_element_type, [quote, *]], t, sys_element_type], sys_size, [], [], [], []]], [when, sys_iesp, [sys_fill_array_with_elt, sequence, sys_initial_element, 0, []]], [unless, [or, [eql, length, [quote, *]], [eql, length, sys_size]], [sys_error_sequence_length, sequence, type, sys_size]]]], sequence]]).
wl:arglist_info(make_sequence, cl_make_sequence, [type, sys_size, c38_key, [sys_initial_element, [], sys_iesp], c38_aux, sequence], arginfo{all:[type, sys_size], allow_other_keys:0, aux:[sequence], body:0, complex:0, env:0, key:[kw_initial_element], names:[type, sys_size, sys_initial_element, sys_iesp, sequence], opt:0, req:[type, sys_size], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_make_sequence).

/*

### Compiled:  `CL:MAKE-SEQUENCE` 
*/
cl_make_sequence(Type_In, Size_In, RestNKeys, FnResult) :-
	Env68=[bv(type, Type_In), bv(sys_size, Size_In), bv(sys_initial_element, Initial_element_In), bv(sys_iesp, Initial_element_Present), bv(sequence, Sequence_In)|Env],
	global_env(Env),
	get_kw(Env,
	       RestNKeys,
	       kw_initial_element,
	       sys_initial_element,
	       Initial_element_In,
	       []=Initial_element_In,
	       Initial_element_Present),
	aux_var(Env, sequence, Sequence_In, true, []),
	catch(( LEnv=[bv(sys_element_type, []), bv(length, [])|Env68],
		get_var(LEnv, type, Type_Get),
		f_sys_closest_sequence_type(Type_Get, Sequence_type_Ret),
		setq_from_values(LEnv, [sys_element_type, length]),
		get_var(LEnv, sys_element_type, Element_type_Get),
		(   is_eq(Element_type_Get, list)
		->  get_var(LEnv, sys_initial_element, Initial_element_Get),
		    get_var(LEnv, sys_size, Size_Get),
		    cl_make_list(Size_Get,
				 kw_initial_element,
				 Initial_element_Get,
				 Sequence),
		    set_var(LEnv, sequence, Sequence),
		    get_var(LEnv, type, Type_Get23),
		    cl_subtypep(list, Type_Get23, IFTEST21),
		    (   IFTEST21\==[]
		    ->  TrueResult63=[]
		    ;   (   get_var(LEnv, type, Type_Get28),
			    cl_subtypep(Type_Get28, null, IFTEST26),
			    (   IFTEST26\==[]
			    ->  get_var(LEnv, sys_size, Size_Get29),
				cl_plusp(Size_Get29, TrueResult),
				FORM1_Res=TrueResult
			    ;   FORM1_Res=[]
			    ),
			    FORM1_Res\==[],
			    IFTEST24=FORM1_Res
			->  true
			;   get_var(LEnv, type, Type_Get33),
			    cl_subtypep(Type_Get33, cons, IFTEST31),
			    (   IFTEST31\==[]
			    ->  get_var(LEnv, sys_size, Size_Get34),
				cl_zerop(Size_Get34, TrueResult35),
				_66581356=TrueResult35
			    ;   _66581356=[]
			    ),
			    IFTEST24=_66581356
			),
			(   IFTEST24\==[]
			->  get_var(LEnv,
				    sys_initial_element,
				    Initial_element_Get38),
			    get_var(LEnv, sys_size, Size_Get37),
			    cl_make_list(Size_Get37,
					 kw_initial_element,
					 Initial_element_Get38,
					 Sequence_length_Param),
			    get_var(LEnv, type, Type_Get39),
			    f_sys_error_sequence_length(Sequence_length_Param,
							Type_Get39,
							0,
							TrueResult40),
			    ElseResult=TrueResult40
			;   ElseResult=[]
			),
			TrueResult63=ElseResult
		    ),
		    _66546480=TrueResult63
		;   get_var(LEnv, sys_element_type, Element_type_Get43),
		    (   is_eq(Element_type_Get43, *)
		    ->  Make_vector_Param=t
		    ;   get_var(LEnv, sys_element_type, Element_type_Get46),
			Make_vector_Param=Element_type_Get46
		    ),
		    get_var(LEnv, sys_size, Size_Get48),
		    f_sys_make_vector(Make_vector_Param,
				      Size_Get48,
				      [],
				      [],
				      [],
				      [],
				      Sequence70),
		    set_var(LEnv, sequence, Sequence70),
		    get_var(LEnv, sys_iesp, IFTEST49),
		    (   IFTEST49\==[]
		    ->  get_var(LEnv, sequence, Sequence_Get),
			get_var(LEnv,
				sys_initial_element,
				Initial_element_Get53),
			f_sys_fill_array_with_elt(Sequence_Get,
						  Initial_element_Get53,
						  0,
						  [],
						  TrueResult54),
			_66705008=TrueResult54
		    ;   _66705008=[]
		    ),
		    (   cl_eql(length, *, FORM1_Res58),
			FORM1_Res58\==[],
			IFTEST55=FORM1_Res58
		    ->  true
		    ;   get_var(LEnv, sys_size, Size_Get57),
			cl_eql(length, Size_Get57, Eql_Ret),
			IFTEST55=Eql_Ret
		    ),
		    (   IFTEST55\==[]
		    ->  ElseResult64=[]
		    ;   get_var(LEnv, sequence, Sequence_Get59),
			get_var(LEnv, sys_size, Size_Get61),
			get_var(LEnv, type, Type_Get60),
			f_sys_error_sequence_length(Sequence_Get59,
						    Type_Get60,
						    Size_Get61,
						    ElseResult62),
			ElseResult64=ElseResult62
		    ),
		    _66546480=ElseResult64
		),
		get_var(LEnv, sequence, Sequence_Get65),
		Sequence_Get65=FnResult
	      ),
	      block_exit(make_sequence, FnResult),
	      true).
:- set_opv(cl_make_sequence, classof, claz_function),
   set_opv(make_sequence, compile_as, kw_function),
   set_opv(make_sequence, function, cl_make_sequence),
   DefunResult=make_sequence.
/*
:- side_effect(assert_lsp(make_sequence,
			  doc_string(make_sequence,
				     _66482340,
				     function,
				     "Args: (type length &key initial-element)\r\nCreates and returns a sequence of the given TYPE and LENGTH.  If INITIAL-\r\nELEMENT is given, then it becomes the elements of the created sequence.  The\r\ndefault value of INITIAL-ELEMENT depends on TYPE."))).
*/
/*
:- side_effect(assert_lsp(make_sequence,
			  lambda_def(defun,
				     make_sequence,
				     cl_make_sequence,
				     
				     [ type,
				       sys_size,
				       c38_key,
				       [sys_initial_element, [], sys_iesp],
				       c38_aux,
				       sequence
				     ],
				     
				     [ 
				       [ multiple_value_bind,
					 [sys_element_type, length],
					 [sys_closest_sequence_type, type],
					 
					 [ cond,
					   
					   [ 
					     [ eq,
					       sys_element_type,
					       [quote, list]
					     ],
					     
					     [ setq,
					       sequence,
					       
					       [ make_list,
						 sys_size,
						 kw_initial_element,
						 sys_initial_element
					       ]
					     ],
					     
					     [ unless,
					       [subtypep, [quote, list], type],
					       
					       [ when,
						 
						 [ or,
						   
						   [ and,
						     
						     [ subtypep,
						       type,
						       [quote, null]
						     ],
						     [plusp, sys_size]
						   ],
						   
						   [ and,
						     
						     [ subtypep,
						       type,
						       [quote, cons]
						     ],
						     [zerop, sys_size]
						   ]
						 ],
						 
						 [ sys_error_sequence_length,
						   
						   [ make_list,
						     sys_size,
						     kw_initial_element,
						     sys_initial_element
						   ],
						   type,
						   0
						 ]
					       ]
					     ]
					   ],
					   
					   [ t,
					     
					     [ setq,
					       sequence,
					       
					       [ sys_make_vector,
						 
						 [ if,
						   
						   [ eq,
						     sys_element_type,
						     [quote, *]
						   ],
						   t,
						   sys_element_type
						 ],
						 sys_size,
						 [],
						 [],
						 [],
						 []
					       ]
					     ],
					     
					     [ when,
					       sys_iesp,
					       
					       [ sys_fill_array_with_elt,
						 sequence,
						 sys_initial_element,
						 0,
						 []
					       ]
					     ],
					     
					     [ unless,
					       
					       [ or,
						 [eql, length, [quote, *]],
						 [eql, length, sys_size]
					       ],
					       
					       [ sys_error_sequence_length,
						 sequence,
						 type,
						 sys_size
					       ]
					     ]
					   ]
					 ],
					 sequence
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(make_sequence,
			  arglist_info(make_sequence,
				       cl_make_sequence,
				       
				       [ type,
					 sys_size,
					 c38_key,
					 [sys_initial_element, [], sys_iesp],
					 c38_aux,
					 sequence
				       ],
				       arginfo{ all:[type, sys_size],
						allow_other_keys:0,
						aux:[sequence],
						body:0,
						complex:0,
						env:0,
						key:[kw_initial_element],
						names:
						      [ type,
							sys_size,
							sys_initial_element,
							sys_iesp,
							sequence
						      ],
						opt:0,
						req:[type, sys_size],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(make_sequence, init_args(2, cl_make_sequence))).
*/
/*
#+(or WAM-CL ECL) 
(defun make-seq-iterator (sequence &optional (start 0))
  (declare (optimize (safety 0)))
  (cond ((fixnump start)
         (let ((aux start))
           (declare (fixnum aux))
           (cond ((minusp aux)
                  (error-sequence-index sequence start))
                 ((listp sequence)
                  (nthcdr aux sequence))
                 ((vectorp sequence)
                  (and (< start (length (truly-the vector sequence)))
                       start))
                 (t
                  (error-not-a-sequence sequence)))))
        ((not (or (listp sequence) (vectorp sequence)))
         (error-not-a-sequence sequence))
        ((integerp start)
         nil)
        (t
         (error-sequence-index sequence start))))



#|
TODO PORT

#+(or WAM-CL ECL) 
(defun closest-sequence-type (type)
  (let (elt-type length name args)
    (cond ((consp type)
           (setq name (first type) args (cdr type)))
          ((si::instancep type)
           (setf name (class-name (truly-the class type)) args nil))
          (t
           (setq name type args nil)))
    (case name
      ((LIST)
       ;; This is the only descriptor that does not match a real
       ;; array type.
       (setq elt-type 'LIST length '*))
      ((VECTOR)
       (setq elt-type (if (endp args) 'T (first args))
             length (if (endp (rest args)) '* (second args))))
      ((SIMPLE-VECTOR)
       (setq elt-type 'T
             length (if (endp args) '* (first args))))
      #-unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((BASE-STRING SIMPLE-BASE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'CHARACTER
             length (if (endp args) '* (first args))))
      ((BIT-VECTOR SIMPLE-BIT-VECTOR)
       (setq elt-type 'BIT
             length (if (endp args) '* (first args))))
      ((ARRAY SIMPLE-ARRAY)
       (let ((dimension-spec (second args)))
         (cond
           ((eql dimension-spec 1)
            (setf length '*))
           ((and (consp dimension-spec)
                 (null (cdr dimension-spec)))
            (setf length (car dimension-spec)))
           (T (error-sequence-type type))))
       (setq elt-type (upgraded-array-element-type (first args))))
      (t
       ;; We arrive here when the sequence type is not easy to parse.
       ;; We give up trying to guess the length of the sequence.
       ;; Furthermore, we also give up trying to find if the element
       ;; type is *. Instead we just compare with some specialized
       ;; types and otherwise fail.
       (dolist (i '((NIL . NIL)
                    (LIST . LIST)
                    (STRING . CHARACTER)
                    . #.(mapcar #'(lambda (i) `((VECTOR ,i) . ,i)) +upgraded-array-element-types+)
		  ))
                (if (subtypep type 'vector)
                    ;; Does this have to be a type-error?
                    ;; 17.3 for MAKE-SEQUENCE says it should be an error,
                    ;; but does not specialize what kind.
                    (error "Cannot find the element type in vector type "#+(or WAM-CL ECL) \r\n(defun make-seq-iterator (sequence &optional (start 0))\r\n  (declare (optimize (safety 0)))\r\n  (cond ((fixnump start)\r\n         (let ((aux start))\r\n           (declare (fixnum aux))\r\n           (cond ((minusp aux)\r\n                  (error-sequence-index sequence start))\r\n                 ((listp sequence)\r\n                  (nthcdr aux sequence))\r\n                 ((vectorp sequence)\r\n                  (and (< start (length (truly-the vector sequence)))\r\n                       start))\r\n                 (t\r\n                  (error-not-a-sequence sequence)))))\r\n        ((not (or (listp sequence) (vectorp sequence)))\r\n         (error-not-a-sequence sequence))\r\n        ((integerp start)\r\n         nil)\r\n        (t\r\n         (error-sequence-index sequence start))))\r\n\r\n\r\n\r\n#|\r\nTODO PORT\r\n\r\n#+(or WAM-CL ECL) \r\n(defun closest-sequence-type (type)\r\n  (let (elt-type length name args)\r\n    (cond ((consp type)\r\n           (setq name (first type) args (cdr type)))\r\n          ((si::instancep type)\r\n           (setf name (class-name (truly-the class type)) args nil))\r\n          (t\r\n           (setq name type args nil)))\r\n    (case name\r\n      ((LIST)\r\n       ;; This is the only descriptor that does not match a real\r\n       ;; array type.\r\n       (setq elt-type 'LIST length '*))\r\n      ((VECTOR)\r\n       (setq elt-type (if (endp args) 'T (first args))\r\n             length (if (endp (rest args)) '* (second args))))\r\n      ((SIMPLE-VECTOR)\r\n       (setq elt-type 'T\r\n             length (if (endp args) '* (first args))))\r\n      #-unicode\r\n      ((STRING SIMPLE-STRING)\r\n       (setq elt-type 'BASE-CHAR\r\n             length (if (endp args) '* (first args))))\r\n      #+unicode\r\n      ((BASE-STRING SIMPLE-BASE-STRING)\r\n       (setq elt-type 'BASE-CHAR\r\n             length (if (endp args) '* (first args))))\r\n      #+unicode\r\n      ((STRING SIMPLE-STRING)\r\n       (setq elt-type 'CHARACTER\r\n             length (if (endp args) '* (first args))))\r\n      ((BIT-VECTOR SIMPLE-BIT-VECTOR)\r\n       (setq elt-type 'BIT\r\n             length (if (endp args) '* (first args))))\r\n      ((ARRAY SIMPLE-ARRAY)\r\n       (let ((dimension-spec (second args)))\r\n         (cond\r\n           ((eql dimension-spec 1)\r\n            (setf length '*))\r\n           ((and (consp dimension-spec)\r\n                 (null (cdr dimension-spec)))\r\n            (setf length (car dimension-spec)))\r\n           (T (error-sequence-type type))))\r\n       (setq elt-type (upgraded-array-element-type (first args))))\r\n      (t\r\n       ;; We arrive here when the sequence type is not easy to parse.\r\n       ;; We give up trying to guess the length of the sequence.\r\n       ;; Furthermore, we also give up trying to find if the element\r\n       ;; type is *. Instead we just compare with some specialized\r\n       ;; types and otherwise fail.\r\n       (dolist (i '((NIL . NIL)\r\n                    (LIST . LIST)\r\n                    (STRING . CHARACTER)\r\n                    . #.(mapcar #'(lambda (i) `((VECTOR ,i) . ,i)) +upgraded-array-element-types+)\r\n\t\t  ))\r\n                (if (subtypep type 'vector)\r\n                    ;; Does this have to be a type-error?\r\n                    ;; 17.3 for MAKE-SEQUENCE says it should be an error,\r\n                    ;; but does not specialize what kind.\r\n                    (error \"Cannot find the element type in vector type ~S\" type)\r\n                    (error-sequence-type type))\r\n          (when (subtypep type (car i))\r\n            (setq elt-type (cdr i) length '*)\r\n            ;; The (NIL . NIL) case above\r\n            (unless elt-type\r\n              (error-sequence-type type))\r\n            (return)))))\r\n    (values elt-type length)))\r\n|#\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:19025 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'make-seq-iterator',[sequence,'&optional',[start,0]],[declare,[optimize,[safety,0]]],[cond,[[fixnump,start],[let,[[aux,start]],[declare,[fixnum,aux]],[cond,[[minusp,aux],['error-sequence-index',sequence,start]],[[listp,sequence],[nthcdr,aux,sequence]],[[vectorp,sequence],[and,[<,start,[length,['truly-the',vector,sequence]]],start]],[t,['error-not-a-sequence',sequence]]]]],[[not,[or,[listp,sequence],[vectorp,sequence]]],['error-not-a-sequence',sequence]],[[integerp,start],[]],[t,['error-sequence-index',sequence,start]]]]).
wl:lambda_def(defun, sys_make_seq_iterator, f_sys_make_seq_iterator, [sequence, c38_optional, [start, 0]], [[declare, [optimize, [safety, 0]]], [cond, [[sys_fixnump, start], [let, [[sys_aux, start]], [declare, [fixnum, sys_aux]], [cond, [[minusp, sys_aux], [sys_error_sequence_index, sequence, start]], [[listp, sequence], [nthcdr, sys_aux, sequence]], [[vectorp, sequence], [and, [<, start, [length, [ext_truly_the, vector, sequence]]], start]], [t, [sys_error_not_a_sequence, sequence]]]]], [[not, [or, [listp, sequence], [vectorp, sequence]]], [sys_error_not_a_sequence, sequence]], [[integerp, start], []], [t, [sys_error_sequence_index, sequence, start]]]]).
wl:arglist_info(sys_make_seq_iterator, f_sys_make_seq_iterator, [sequence, c38_optional, [start, 0]], arginfo{all:[sequence, start], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sequence, start], opt:[start], req:[sequence], rest:0, sublists:0, whole:0}).
wl: init_args(1, f_sys_make_seq_iterator).

/*

### Compiled:  `SYS::MAKE-SEQ-ITERATOR` 
*/
f_sys_make_seq_iterator(Sequence_In, RestNKeys, FnResult) :-
	Env65=[bv(sequence, Sequence_In), bv(start, Start_In)|Env],
	global_env(Env),
	opt_var(Env, start, Start_In, true, 0, 1, RestNKeys),
	catch(( cl_declare([optimize, [safety, 0]], Declare_Ret),
		get_var(Env65, start, Start_Get),
		f_sys_fixnump(Start_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env65, start, Start_Get13),
		    LEnv=[bv(sys_aux, Start_Get13)|Env65],
		    cl_declare([fixnum, sys_aux], Declare_Ret68),
		    get_var(LEnv, sys_aux, Aux_Get),
		    (   mth:is_minusp(Aux_Get)
		    ->  get_var(LEnv, sequence, Sequence_Get),
			get_var(LEnv, start, Start_Get20),
			f_sys_error_sequence_index(Sequence_Get,
						   Start_Get20,
						   TrueResult43),
			LetResult=TrueResult43
		    ;   get_var(LEnv, sequence, Sequence_Get22),
			(   is_listp(Sequence_Get22)
			->  get_var(LEnv, sequence, Sequence_Get26),
			    get_var(LEnv, sys_aux, Aux_Get25),
			    cl_nthcdr(Aux_Get25, Sequence_Get26, TrueResult41),
			    ElseResult44=TrueResult41
			;   get_var(LEnv, sequence, Sequence_Get28),
			    (   is_vectorp(Sequence_Get28)
			    ->  get_var(LEnv, start, Start_Get32),
				f_ext_truly_the(vector, sequence, Sequence),
				cl_length(Sequence, PredArg2Result),
				(   Start_Get32<PredArg2Result
				->  get_var(LEnv, start, Start_Get36),
				    TrueResult39=Start_Get36
				;   TrueResult39=[]
				),
				ElseResult42=TrueResult39
			    ;   get_var(LEnv, sequence, Sequence_Get38),
				f_sys_error_not_a_sequence(Sequence_Get38,
							   ElseResult),
				ElseResult42=ElseResult
			    ),
			    ElseResult44=ElseResult42
			),
			LetResult=ElseResult44
		    ),
		    _69265490=LetResult
		;   (   get_var(Env65, sequence, Sequence_Get46),
			cl_listp(Sequence_Get46, FORM1_Res),
			FORM1_Res\==[],
			PredArgResult50=FORM1_Res
		    ->  true
		    ;   get_var(Env65, sequence, Sequence_Get47),
			cl_vectorp(Sequence_Get47, Vectorp_Ret),
			PredArgResult50=Vectorp_Ret
		    ),
		    (   PredArgResult50==[]
		    ->  get_var(Env65, sequence, Sequence_Get51),
			f_sys_error_not_a_sequence(Sequence_Get51,
						   TrueResult59),
			ElseResult62=TrueResult59
		    ;   get_var(Env65, start, Start_Get53),
			(   mth:is_integerp(Start_Get53)
			->  ElseResult60=[]
			;   get_var(Env65, sequence, Sequence_Get56),
			    get_var(Env65, start, Start_Get57),
			    f_sys_error_sequence_index(Sequence_Get56,
						       Start_Get57,
						       ElseResult58),
			    ElseResult60=ElseResult58
			),
			ElseResult62=ElseResult60
		    ),
		    _69265490=ElseResult62
		),
		_69265490=FnResult
	      ),
	      block_exit(sys_make_seq_iterator, FnResult),
	      true).
:- set_opv(f_sys_make_seq_iterator, classof, claz_function),
   set_opv(sys_make_seq_iterator, compile_as, kw_function),
   set_opv(sys_make_seq_iterator, function, f_sys_make_seq_iterator),
   DefunResult=sys_make_seq_iterator.
/*
:- side_effect(assert_lsp(sys_make_seq_iterator,
			  lambda_def(defun,
				     sys_make_seq_iterator,
				     f_sys_make_seq_iterator,
				     [sequence, c38_optional, [start, 0]],
				     
				     [ [declare, [optimize, [safety, 0]]],
				       
				       [ cond,
					 
					 [ [sys_fixnump, start],
					   
					   [ let,
					     [[sys_aux, start]],
					     [declare, [fixnum, sys_aux]],
					     
					     [ cond,
					       
					       [ [minusp, sys_aux],
						 
						 [ sys_error_sequence_index,
						   sequence,
						   start
						 ]
					       ],
					       
					       [ [listp, sequence],
						 [nthcdr, sys_aux, sequence]
					       ],
					       
					       [ [vectorp, sequence],
						 
						 [ and,
						   
						   [ (<),
						     start,
						     
						     [ length,
						       
						       [ ext_truly_the,
							 vector,
							 sequence
						       ]
						     ]
						   ],
						   start
						 ]
					       ],
					       
					       [ t,
						 
						 [ sys_error_not_a_sequence,
						   sequence
						 ]
					       ]
					     ]
					   ]
					 ],
					 
					 [ 
					   [ not,
					     
					     [ or,
					       [listp, sequence],
					       [vectorp, sequence]
					     ]
					   ],
					   [sys_error_not_a_sequence, sequence]
					 ],
					 [[integerp, start], []],
					 
					 [ t,
					   
					   [ sys_error_sequence_index,
					     sequence,
					     start
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_make_seq_iterator,
			  arglist_info(sys_make_seq_iterator,
				       f_sys_make_seq_iterator,
				       [sequence, c38_optional, [start, 0]],
				       arginfo{ all:[sequence, start],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sequence, start],
						opt:[start],
						req:[sequence],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_make_seq_iterator,
			  init_args(1, f_sys_make_seq_iterator))).
*/
/*

TODO PORT

#+(or WAM-CL ECL) 
(defun closest-sequence-type (type)
  (let (elt-type length name args)
    (cond ((consp type)
           (setq name (first type) args (cdr type)))
          ((si::instancep type)
           (setf name (class-name (truly-the class type)) args nil))
          (t
           (setq name type args nil)))
    (case name
      ((LIST)
       ;; This is the only descriptor that does not match a real
       ;; array type.
       (setq elt-type 'LIST length '*))
      ((VECTOR)
       (setq elt-type (if (endp args) 'T (first args))
             length (if (endp (rest args)) '* (second args))))
      ((SIMPLE-VECTOR)
       (setq elt-type 'T
             length (if (endp args) '* (first args))))
      #-unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((BASE-STRING SIMPLE-BASE-STRING)
       (setq elt-type 'BASE-CHAR
             length (if (endp args) '* (first args))))
      #+unicode
      ((STRING SIMPLE-STRING)
       (setq elt-type 'CHARACTER
             length (if (endp args) '* (first args))))
      ((BIT-VECTOR SIMPLE-BIT-VECTOR)
       (setq elt-type 'BIT
             length (if (endp args) '* (first args))))
      ((ARRAY SIMPLE-ARRAY)
       (let ((dimension-spec (second args)))
         (cond
           ((eql dimension-spec 1)
            (setf length '*))
           ((and (consp dimension-spec)
                 (null (cdr dimension-spec)))
            (setf length (car dimension-spec)))
           (T (error-sequence-type type))))
       (setq elt-type (upgraded-array-element-type (first args))))
      (t
       ;; We arrive here when the sequence type is not easy to parse.
       ;; We give up trying to guess the length of the sequence.
       ;; Furthermore, we also give up trying to find if the element
       ;; type is *. Instead we just compare with some specialized
       ;; types and otherwise fail.
       (dolist (i '((NIL . NIL)
                    (LIST . LIST)
                    (STRING . CHARACTER)
                    . #.(mapcar #'(lambda (i) `((VECTOR ,i) . ,i)) +upgraded-array-element-types+)
		  ))
                (if (subtypep type 'vector)
                    ;; Does this have to be a type-error?
                    ;; 17.3 for MAKE-SEQUENCE says it should be an error,
                    ;; but does not specialize what kind.
                    (error "Cannot find the element type in vector type "\r\nTODO PORT\r\n\r\n#+(or WAM-CL ECL) \r\n(defun closest-sequence-type (type)\r\n  (let (elt-type length name args)\r\n    (cond ((consp type)\r\n           (setq name (first type) args (cdr type)))\r\n          ((si::instancep type)\r\n           (setf name (class-name (truly-the class type)) args nil))\r\n          (t\r\n           (setq name type args nil)))\r\n    (case name\r\n      ((LIST)\r\n       ;; This is the only descriptor that does not match a real\r\n       ;; array type.\r\n       (setq elt-type 'LIST length '*))\r\n      ((VECTOR)\r\n       (setq elt-type (if (endp args) 'T (first args))\r\n             length (if (endp (rest args)) '* (second args))))\r\n      ((SIMPLE-VECTOR)\r\n       (setq elt-type 'T\r\n             length (if (endp args) '* (first args))))\r\n      #-unicode\r\n      ((STRING SIMPLE-STRING)\r\n       (setq elt-type 'BASE-CHAR\r\n             length (if (endp args) '* (first args))))\r\n      #+unicode\r\n      ((BASE-STRING SIMPLE-BASE-STRING)\r\n       (setq elt-type 'BASE-CHAR\r\n             length (if (endp args) '* (first args))))\r\n      #+unicode\r\n      ((STRING SIMPLE-STRING)\r\n       (setq elt-type 'CHARACTER\r\n             length (if (endp args) '* (first args))))\r\n      ((BIT-VECTOR SIMPLE-BIT-VECTOR)\r\n       (setq elt-type 'BIT\r\n             length (if (endp args) '* (first args))))\r\n      ((ARRAY SIMPLE-ARRAY)\r\n       (let ((dimension-spec (second args)))\r\n         (cond\r\n           ((eql dimension-spec 1)\r\n            (setf length '*))\r\n           ((and (consp dimension-spec)\r\n                 (null (cdr dimension-spec)))\r\n            (setf length (car dimension-spec)))\r\n           (T (error-sequence-type type))))\r\n       (setq elt-type (upgraded-array-element-type (first args))))\r\n      (t\r\n       ;; We arrive here when the sequence type is not easy to parse.\r\n       ;; We give up trying to guess the length of the sequence.\r\n       ;; Furthermore, we also give up trying to find if the element\r\n       ;; type is *. Instead we just compare with some specialized\r\n       ;; types and otherwise fail.\r\n       (dolist (i '((NIL . NIL)\r\n                    (LIST . LIST)\r\n                    (STRING . CHARACTER)\r\n                    . #.(mapcar #'(lambda (i) `((VECTOR ,i) . ,i)) +upgraded-array-element-types+)\r\n\t\t  ))\r\n                (if (subtypep type 'vector)\r\n                    ;; Does this have to be a type-error?\r\n                    ;; 17.3 for MAKE-SEQUENCE says it should be an error,\r\n                    ;; but does not specialize what kind.\r\n                    (error \"Cannot find the element type in vector type ~S\" type)\r\n                    (error-sequence-type type))\r\n          (when (subtypep type (car i))\r\n            (setq elt-type (cdr i) length '*)\r\n            ;; The (NIL . NIL) case above\r\n            (unless elt-type\r\n              (error-sequence-type type))\r\n            (return)))))\r\n    (values elt-type length)))\r\n".
*/
/*
#+(or WAM-CL ECL) 
(defun seq-iterator-ref (sequence iterator)
  (declare (optimize (safety 0)))
  (if (fixnump iterator)
      (aref (truly-the vector sequence) iterator)
      (car (truly-the cons iterator))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:22706 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'seq-iterator-ref',[sequence,iterator],[declare,[optimize,[safety,0]]],[if,[fixnump,iterator],[aref,['truly-the',vector,sequence],iterator],[car,['truly-the',cons,iterator]]]]).
wl:lambda_def(defun, sys_seq_iterator_ref, f_sys_seq_iterator_ref, [sequence, sys_iterator], [[declare, [optimize, [safety, 0]]], [if, [sys_fixnump, sys_iterator], [aref, [ext_truly_the, vector, sequence], sys_iterator], [car, [ext_truly_the, cons, sys_iterator]]]]).
wl:arglist_info(sys_seq_iterator_ref, f_sys_seq_iterator_ref, [sequence, sys_iterator], arginfo{all:[sequence, sys_iterator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sequence, sys_iterator], opt:0, req:[sequence, sys_iterator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_seq_iterator_ref).

/*

### Compiled:  `SYS::SEQ-ITERATOR-REF` 
*/
f_sys_seq_iterator_ref(Sequence_In, Iterator_In, FnResult) :-
	Env13=[bv(sequence, Sequence_In), bv(sys_iterator, Iterator_In)|Env],
	global_env(Env),
	catch(( cl_declare([optimize, [safety, 0]], Declare_Ret),
		get_var(Env13, sys_iterator, Iterator_Get),
		f_sys_fixnump(Iterator_Get, IFTEST),
		(   IFTEST\==[]
		->  f_ext_truly_the(vector, sequence, Sequence),
		    get_var(Env13, sys_iterator, Iterator_Get8),
		    cl_aref(Sequence, Iterator_Get8, TrueResult),
		    _71212408=TrueResult
		;   f_ext_truly_the(cons, sys_iterator, Iterator),
		    cl_car(Iterator, ElseResult),
		    _71212408=ElseResult
		),
		_71212408=FnResult
	      ),
	      block_exit(sys_seq_iterator_ref, FnResult),
	      true).
:- set_opv(f_sys_seq_iterator_ref, classof, claz_function),
   set_opv(sys_seq_iterator_ref, compile_as, kw_function),
   set_opv(sys_seq_iterator_ref, function, f_sys_seq_iterator_ref),
   DefunResult=sys_seq_iterator_ref.
/*
:- side_effect(assert_lsp(sys_seq_iterator_ref,
			  lambda_def(defun,
				     sys_seq_iterator_ref,
				     f_sys_seq_iterator_ref,
				     [sequence, sys_iterator],
				     
				     [ [declare, [optimize, [safety, 0]]],
				       
				       [ if,
					 [sys_fixnump, sys_iterator],
					 
					 [ aref,
					   [ext_truly_the, vector, sequence],
					   sys_iterator
					 ],
					 
					 [ car,
					   [ext_truly_the, cons, sys_iterator]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_ref,
			  arglist_info(sys_seq_iterator_ref,
				       f_sys_seq_iterator_ref,
				       [sequence, sys_iterator],
				       arginfo{ all:[sequence, sys_iterator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sequence, sys_iterator],
						opt:0,
						req:[sequence, sys_iterator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_ref,
			  init_args(exact_only, f_sys_seq_iterator_ref))).
*/
/*
#+(or WAM-CL ECL) 
(defun seq-iterator-set (sequence iterator value)
  (declare (optimize (safety 0)))
  (if (fixnump iterator)
      (setf (aref (truly-the vector sequence) iterator) value)
      (setf (car (truly-the cons iterator)) value)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:22926 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'seq-iterator-set',[sequence,iterator,value],[declare,[optimize,[safety,0]]],[if,[fixnump,iterator],[setf,[aref,['truly-the',vector,sequence],iterator],value],[setf,[car,['truly-the',cons,iterator]],value]]]).
/*
:- side_effect((compile_each($, _72207160, [sys_iterator], [sys_iterator], true), append([[ext_truly_the, vector, sequence], sys_iterator], [CAR10, CAR], [[ext_truly_the, vector, sequence], sys_iterator, CAR10, CAR]), setf_inverse_op(aref, []))).
*/
/*
:- side_effect((compile_each($, _72207160, [sys_iterator], [sys_iterator], true), append([[ext_truly_the, vector, sequence], sys_iterator], [CAR10, CAR], [[ext_truly_the, vector, sequence], sys_iterator, CAR10, CAR]), setf_inverse_op(aref, setf_aref))).
*/
/*
:- side_effect((compile_each($, _72207160, [sys_iterator], [sys_iterator], true), append([[ext_truly_the, vector, sequence], sys_iterator], [CAR10, CAR], [[ext_truly_the, vector, sequence], sys_iterator, CAR10, CAR]), setf_inverse_op(aref, []))).
*/
/*
:- side_effect((compile_each($, _72207160, [], [], true), append([[ext_truly_the, cons, sys_iterator]], [CAR14, CAR13], [[ext_truly_the, cons, sys_iterator], CAR14, CAR13]), setf_inverse_op(car, rplaca))).
*/
/*
:- side_effect((compile_each($, _72207160, [], [], true), append([[ext_truly_the, cons, sys_iterator]], [CAR14, CAR13], [[ext_truly_the, cons, sys_iterator], CAR14, CAR13]), setf_inverse_op(car, sys_set_car))).
*/
/*
:- side_effect((compile_each($, _72207160, [], [], true), append([[ext_truly_the, cons, sys_iterator]], [CAR14, CAR13], [[ext_truly_the, cons, sys_iterator], CAR14, CAR13]), setf_inverse_op(car, setf_car))).
*/
/*
:- side_effect((compile_each($, _72207160, [], [], true), append([[ext_truly_the, cons, sys_iterator]], [CAR14, CAR13], [[ext_truly_the, cons, sys_iterator], CAR14, CAR13]), setf_inverse_op(car, rplaca))).
*/
wl:lambda_def(defun, sys_seq_iterator_set, f_sys_seq_iterator_set, [sequence, sys_iterator, sys_value], [[declare, [optimize, [safety, 0]]], [if, [sys_fixnump, sys_iterator], [setf, [aref, [ext_truly_the, vector, sequence], sys_iterator], sys_value], [setf, [car, [ext_truly_the, cons, sys_iterator]], sys_value]]]).
wl:arglist_info(sys_seq_iterator_set, f_sys_seq_iterator_set, [sequence, sys_iterator, sys_value], arginfo{all:[sequence, sys_iterator, sys_value], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sequence, sys_iterator, sys_value], opt:0, req:[sequence, sys_iterator, sys_value], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_seq_iterator_set).

/*

### Compiled:  `SYS::SEQ-ITERATOR-SET` 
*/
f_sys_seq_iterator_set(Sequence_In, Iterator_In, Value_In, FnResult) :-
	Env20=[bv(sequence, Sequence_In), bv(sys_iterator, Iterator_In), bv(sys_value, Value_In)|Env],
	global_env(Env),
	catch(( cl_declare([optimize, [safety, 0]], Declare_Ret),
		get_var(Env20, sys_iterator, Iterator_Get),
		f_sys_fixnump(Iterator_Get, IFTEST),
		(   IFTEST\==[]
		->  f_ext_truly_the(vector, sequence, Sequence),
		    get_var(Env20, sys_iterator, Iterator_Get12),
		    get_var(Env20, sys_value, Value_Get),
		    cl_apply([],
			     [Sequence, Iterator_Get12, Value_Get],
			     TrueResult),
		    _72223086=TrueResult
		;   f_ext_truly_the(cons, sys_iterator, Iterator),
		    get_var(Env20, sys_value, Value_Get15),
		    cl_rplaca(Iterator, Value_Get15, ElseResult),
		    _72223086=ElseResult
		),
		_72223086=FnResult
	      ),
	      block_exit(sys_seq_iterator_set, FnResult),
	      true).
:- set_opv(f_sys_seq_iterator_set, classof, claz_function),
   set_opv(sys_seq_iterator_set, compile_as, kw_function),
   set_opv(sys_seq_iterator_set, function, f_sys_seq_iterator_set),
   DefunResult=sys_seq_iterator_set.
/*
:- side_effect(assert_lsp(sys_seq_iterator_set,
			  lambda_def(defun,
				     sys_seq_iterator_set,
				     f_sys_seq_iterator_set,
				     [sequence, sys_iterator, sys_value],
				     
				     [ [declare, [optimize, [safety, 0]]],
				       
				       [ if,
					 [sys_fixnump, sys_iterator],
					 
					 [ setf,
					   
					   [ aref,
					     [ext_truly_the, vector, sequence],
					     sys_iterator
					   ],
					   sys_value
					 ],
					 
					 [ setf,
					   
					   [ car,
					     [ext_truly_the, cons, sys_iterator]
					   ],
					   sys_value
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_set,
			  arglist_info(sys_seq_iterator_set,
				       f_sys_seq_iterator_set,
				       [sequence, sys_iterator, sys_value],
				       arginfo{ all:
						    [ sequence,
						      sys_iterator,
						      sys_value
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sequence,
							sys_iterator,
							sys_value
						      ],
						opt:0,
						req:
						    [ sequence,
						      sys_iterator,
						      sys_value
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_set,
			  init_args(exact_only, f_sys_seq_iterator_set))).
*/
/*
#+(or WAM-CL ECL) 
(defun seq-iterator-next (sequence iterator)
  (declare (optimize (safety 0)))
  (cond ((fixnump iterator)
         (let ((aux (1+ iterator)))
           (declare (fixnum aux))
           (and (< aux (length (truly-the vector sequence)))
                aux)))
        ((atom iterator)
         (error-not-a-sequence iterator))
        (t
         (setf iterator (cdr (truly-the cons iterator)))
         (unless (listp iterator)
           (error-not-a-sequence iterator))
         iterator)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:23178 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'seq-iterator-next',[sequence,iterator],[declare,[optimize,[safety,0]]],[cond,[[fixnump,iterator],[let,[[aux,['1+',iterator]]],[declare,[fixnum,aux]],[and,[<,aux,[length,['truly-the',vector,sequence]]],aux]]],[[atom,iterator],['error-not-a-sequence',iterator]],[t,[setf,iterator,[cdr,['truly-the',cons,iterator]]],[unless,[listp,iterator],['error-not-a-sequence',iterator]],iterator]]]).
wl:lambda_def(defun, sys_seq_iterator_next, f_sys_seq_iterator_next, [sequence, sys_iterator], [[declare, [optimize, [safety, 0]]], [cond, [[sys_fixnump, sys_iterator], [let, [[sys_aux, ['1+', sys_iterator]]], [declare, [fixnum, sys_aux]], [and, [<, sys_aux, [length, [ext_truly_the, vector, sequence]]], sys_aux]]], [[atom, sys_iterator], [sys_error_not_a_sequence, sys_iterator]], [t, [setf, sys_iterator, [cdr, [ext_truly_the, cons, sys_iterator]]], [unless, [listp, sys_iterator], [sys_error_not_a_sequence, sys_iterator]], sys_iterator]]]).
wl:arglist_info(sys_seq_iterator_next, f_sys_seq_iterator_next, [sequence, sys_iterator], arginfo{all:[sequence, sys_iterator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sequence, sys_iterator], opt:0, req:[sequence, sys_iterator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_seq_iterator_next).

/*

### Compiled:  `SYS::SEQ-ITERATOR-NEXT` 
*/
f_sys_seq_iterator_next(Sequence_In, Iterator_In, FnResult) :-
	Env38=[bv(sequence, Sequence_In), bv(sys_iterator, Iterator_In)|Env],
	global_env(Env),
	catch(( cl_declare([optimize, [safety, 0]], Declare_Ret),
		get_var(Env38, sys_iterator, Iterator_Get),
		f_sys_fixnump(Iterator_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env38, sys_iterator, Iterator_Get11),
		    '1+'(Iterator_Get11, Aux_Init),
		    LEnv=[bv(sys_aux, Aux_Init)|Env38],
		    cl_declare([fixnum, sys_aux], Declare_Ret43),
		    get_var(LEnv, sys_aux, Aux_Get),
		    f_ext_truly_the(vector, sequence, Sequence),
		    cl_length(Sequence, PredArg2Result),
		    (   Aux_Get<PredArg2Result
		    ->  get_var(LEnv, sys_aux, Aux_Get18),
			LetResult=Aux_Get18
		    ;   LetResult=[]
		    ),
		    _73759322=LetResult
		;   get_var(Env38, sys_iterator, Iterator_Get21),
		    (   Iterator_Get21\=[CAR|CDR]
		    ->  get_var(Env38, sys_iterator, Iterator_Get24),
			f_sys_error_not_a_sequence(Iterator_Get24,
						   TrueResult32),
			ElseResult35=TrueResult32
		    ;   f_ext_truly_the(cons, sys_iterator, Iterator),
			cl_cdr(Iterator, Iterator41),
			set_var(Env38, sys_iterator, Iterator41),
			get_var(Env38, sys_iterator, Iterator_Get26),
			(   is_listp(Iterator_Get26)
			->  _73827630=[]
			;   get_var(Env38, sys_iterator, Iterator_Get29),
			    f_sys_error_not_a_sequence(Iterator_Get29,
						       ElseResult),
			    _73827630=ElseResult
			),
			get_var(Env38, sys_iterator, Iterator_Get31),
			ElseResult35=Iterator_Get31
		    ),
		    _73759322=ElseResult35
		),
		_73759322=FnResult
	      ),
	      block_exit(sys_seq_iterator_next, FnResult),
	      true).
:- set_opv(f_sys_seq_iterator_next, classof, claz_function),
   set_opv(sys_seq_iterator_next, compile_as, kw_function),
   set_opv(sys_seq_iterator_next, function, f_sys_seq_iterator_next),
   DefunResult=sys_seq_iterator_next.
/*
:- side_effect(assert_lsp(sys_seq_iterator_next,
			  lambda_def(defun,
				     sys_seq_iterator_next,
				     f_sys_seq_iterator_next,
				     [sequence, sys_iterator],
				     
				     [ [declare, [optimize, [safety, 0]]],
				       
				       [ cond,
					 
					 [ [sys_fixnump, sys_iterator],
					   
					   [ let,
					     [[sys_aux, ['1+', sys_iterator]]],
					     [declare, [fixnum, sys_aux]],
					     
					     [ and,
					       
					       [ (<),
						 sys_aux,
						 
						 [ length,
						   
						   [ ext_truly_the,
						     vector,
						     sequence
						   ]
						 ]
					       ],
					       sys_aux
					     ]
					   ]
					 ],
					 
					 [ [atom, sys_iterator],
					   
					   [ sys_error_not_a_sequence,
					     sys_iterator
					   ]
					 ],
					 
					 [ t,
					   
					   [ setf,
					     sys_iterator,
					     
					     [ cdr,
					       
					       [ ext_truly_the,
						 cons,
						 sys_iterator
					       ]
					     ]
					   ],
					   
					   [ unless,
					     [listp, sys_iterator],
					     
					     [ sys_error_not_a_sequence,
					       sys_iterator
					     ]
					   ],
					   sys_iterator
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_next,
			  arglist_info(sys_seq_iterator_next,
				       f_sys_seq_iterator_next,
				       [sequence, sys_iterator],
				       arginfo{ all:[sequence, sys_iterator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sequence, sys_iterator],
						opt:0,
						req:[sequence, sys_iterator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_next,
			  init_args(exact_only, f_sys_seq_iterator_next))).
*/
/*
#+(or WAM-CL ECL) 
(defun seq-iterator-list-pop (values-list seq-list iterator-list)
  (declare (optimize (safety 0)))
  (do* ((it-list iterator-list)
        (v-list values-list))
       ((null v-list)
        values-list)
    (let* ((it (cons-car it-list))
           (sequence (cons-car seq-list)))
      (cond ((null it)
             (return nil))
            ((fixnump it)
             (let* ((n it) (s sequence))
               (declare (fixnum n) (vector s))
               (rplaca v-list (aref s n))
               (rplaca it-list (and (< (incf n) (length s)) n))))
            ((atom it)
             (error-not-a-sequence it))
            (t
             (rplaca v-list (cons-car it))
             (unless (listp (setf it (cons-cdr it)))
               (error-not-a-sequence it))
             (rplaca it-list it)))
      (setf v-list (cons-cdr v-list)
            it-list (cons-cdr it-list)
            seq-list (cons-cdr seq-list)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:23709 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'seq-iterator-list-pop',['values-list','seq-list','iterator-list'],[declare,[optimize,[safety,0]]],['do*',[['it-list','iterator-list'],['v-list','values-list']],[[null,'v-list'],'values-list'],['let*',[[it,['cons-car','it-list']],[sequence,['cons-car','seq-list']]],[cond,[[null,it],[return,[]]],[[fixnump,it],['let*',[[n,it],[s,sequence]],[declare,[fixnum,n],[vector,s]],[rplaca,'v-list',[aref,s,n]],[rplaca,'it-list',[and,[<,[incf,n],[length,s]],n]]]],[[atom,it],['error-not-a-sequence',it]],[t,[rplaca,'v-list',['cons-car',it]],[unless,[listp,[setf,it,['cons-cdr',it]]],['error-not-a-sequence',it]],[rplaca,'it-list',it]]],[setf,'v-list',['cons-cdr','v-list'],'it-list',['cons-cdr','it-list'],'seq-list',['cons-cdr','seq-list']]]]]).
wl:lambda_def(defun, sys_seq_iterator_list_pop, f_sys_seq_iterator_list_pop, [values_list, sys_seq_list, sys_iterator_list], [[declare, [optimize, [safety, 0]]], [do_xx, [[sys_it_list, sys_iterator_list], [sys_v_list, values_list]], [[null, sys_v_list], values_list], [let_xx, [[sys_it, [sys_cons_car, sys_it_list]], [sequence, [sys_cons_car, sys_seq_list]]], [cond, [[null, sys_it], [return, []]], [[sys_fixnump, sys_it], [let_xx, [[n, sys_it], [sys_s, sequence]], [declare, [fixnum, n], [vector, sys_s]], [rplaca, sys_v_list, [aref, sys_s, n]], [rplaca, sys_it_list, [and, [<, [incf, n], [length, sys_s]], n]]]], [[atom, sys_it], [sys_error_not_a_sequence, sys_it]], [t, [rplaca, sys_v_list, [sys_cons_car, sys_it]], [unless, [listp, [setf, sys_it, [sys_cons_cdr, sys_it]]], [sys_error_not_a_sequence, sys_it]], [rplaca, sys_it_list, sys_it]]], [setf, sys_v_list, [sys_cons_cdr, sys_v_list], sys_it_list, [sys_cons_cdr, sys_it_list], sys_seq_list, [sys_cons_cdr, sys_seq_list]]]]]).
wl:arglist_info(sys_seq_iterator_list_pop, f_sys_seq_iterator_list_pop, [values_list, sys_seq_list, sys_iterator_list], arginfo{all:[values_list, sys_seq_list, sys_iterator_list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[values_list, sys_seq_list, sys_iterator_list], opt:0, req:[values_list, sys_seq_list, sys_iterator_list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_seq_iterator_list_pop).

/*

### Compiled:  `SYS::SEQ-ITERATOR-LIST-POP` 
*/
f_sys_seq_iterator_list_pop(Values_list_In, Seq_list_In, Iterator_list_In, FnResult) :-
	Env159=[bv(values_list, Values_list_In), bv(sys_seq_list, Seq_list_In), bv(sys_iterator_list, Iterator_list_In)|Env],
	global_env(Env),
	catch(( cl_declare([optimize, [safety, 0]], Declare_Ret),
		get_var(Env159, sys_iterator_list, Iterator_list_Get),
		get_var(Env159, values_list, Values_list_Get),
		BlockExitEnv=[bv(sys_it_list, Iterator_list_Get), bv(sys_v_list, Values_list_Get)|Env159],
		catch(( call_addr_block(BlockExitEnv,
					(push_label(do_label_3), get_var(BlockExitEnv, sys_v_list, IFTEST86), (IFTEST86==[]->get_var(BlockExitEnv, values_list, RetResult89), throw(block_exit([], RetResult89)), _TBResult=ThrowResult90;get_var(BlockExitEnv, sys_it_list, It_list_Get96), f_sys_cons_car(It_list_Get96, It_Init98), get_var(BlockExitEnv, sys_seq_list, Seq_list_Get97), f_sys_cons_car(Seq_list_Get97, Sequence_Init99), LEnv95=[bv(sys_it, It_Init98), bv(sequence, Sequence_Init99)|BlockExitEnv], get_var(LEnv95, sys_it, IFTEST100), (IFTEST100==[]->throw(block_exit([], [])), _75858012=ThrowResult104;get_var(LEnv95, sys_it, It_Get108), f_sys_fixnump(It_Get108, IFTEST106), (IFTEST106\==[]->get_var(LEnv95, sequence, Sequence_Get113), get_var(LEnv95, sys_it, It_Get112), LEnv111=[bv(n, It_Get112), bv(sys_s, Sequence_Get113)|LEnv95], cl_declare([fixnum, n], [vector, sys_s], Declare_Ret167), get_var(LEnv111, sys_s, S_Get117), get_var(LEnv111, sys_v_list, V_list_Get116), get_var(LEnv111, n, N_Get118), cl_aref(S_Get117, N_Get118, Aref_Ret), cl_rplaca(V_list_Get116, Aref_Ret, Rplaca_Ret), get_var(LEnv111, sys_it_list, It_list_Get119), set_place(LEnv111, incf, [value, n], [], Incf_R121), get_var(LEnv111, sys_s, S_Get123), cl_length(S_Get123, PredArg2Result126), (Incf_R121<PredArg2Result126->get_var(LEnv111, n, N_Get127), _75893274=N_Get127;_75893274=[]), cl_rplaca(It_list_Get119, _75893274, LetResult110), ElseResult149=LetResult110;get_var(LEnv95, sys_it, It_Get130), (It_Get130\=[CAR|CDR]->get_var(LEnv95, sys_it, It_Get133), f_sys_error_not_a_sequence(It_Get133, TrueResult144), ElseResult147=TrueResult144;get_var(LEnv95, sys_it, It_Get135), get_var(LEnv95, sys_v_list, V_list_Get134), f_sys_cons_car(It_Get135, Cons_car_Ret), cl_rplaca(V_list_Get134, Cons_car_Ret, Rplaca_Ret173), get_var(LEnv95, sys_it, It_Get137), f_sys_cons_cdr(It_Get137, PredArgResult139), set_var(LEnv95, sys_it, PredArgResult139), (is_listp(PredArgResult139)->_75962170=[];get_var(LEnv95, sys_it, It_Get140), f_sys_error_not_a_sequence(It_Get140, ElseResult141), _75962170=ElseResult141), get_var(LEnv95, sys_it, It_Get143), get_var(LEnv95, sys_it_list, It_list_Get142), cl_rplaca(It_list_Get142, It_Get143, ElseResult145), ElseResult147=ElseResult145), ElseResult149=ElseResult147), _75858012=ElseResult149), get_var(LEnv95, sys_v_list, V_list_Get150), f_sys_cons_cdr(V_list_Get150, V_list), set_var(LEnv95, sys_v_list, V_list), get_var(LEnv95, sys_it_list, It_list_Get151), f_sys_cons_cdr(It_list_Get151, It_list), set_var(LEnv95, sys_it_list, It_list), get_var(LEnv95, sys_seq_list, Seq_list_Get152), f_sys_cons_cdr(Seq_list_Get152, LetResult94), set_var(LEnv95, sys_seq_list, LetResult94), cl_psetq(Psetq_Ret), goto(do_label_3, BlockExitEnv), _TBResult=_GORES153)),
					
					[ addr(addr_tagbody_3_do_label_3,
					       do_label_3,
					       '$unused',
					       BlockExitEnv,
					       (get_var(BlockExitEnv, sys_v_list, IFTEST), (IFTEST==[]->get_var(BlockExitEnv, values_list, Values_list_Get19), throw(block_exit([], Values_list_Get19)), _76263206=ThrowResult;get_var(BlockExitEnv, sys_it_list, Cons_car_Param), f_sys_cons_car(Cons_car_Param, Cons_car_Ret175), get_var(BlockExitEnv, sys_seq_list, Cons_car_Param163), f_sys_cons_car(Cons_car_Param163, Cons_car_Ret176), LEnv23=[bv(sys_it, Cons_car_Ret175), bv(sequence, Cons_car_Ret176)|BlockExitEnv], get_var(LEnv23, sys_it, IFTEST28), (IFTEST28==[]->throw(block_exit([], [])), _76263386=ThrowResult32;get_var(LEnv23, sys_it, It_Get36), f_sys_fixnump(It_Get36, IFTEST34), (IFTEST34\==[]->get_var(LEnv23, sequence, Sequence_Get), get_var(LEnv23, sys_it, It_Get40), LEnv39=[bv(n, It_Get40), bv(sys_s, Sequence_Get)|LEnv23], cl_declare([fixnum, n], [vector, sys_s], Declare_Ret177), get_var(LEnv39, sys_s, Aref_Param), get_var(LEnv39, sys_v_list, V_list_Get44), get_var(LEnv39, n, KeysNRest), cl_aref(Aref_Param, KeysNRest, Aref_Ret178), cl_rplaca(V_list_Get44, Aref_Ret178, Rplaca_Ret179), get_var(LEnv39, sys_it_list, It_list_Get47), set_place(LEnv39, incf, [value, n], [], Incf_R), get_var(LEnv39, sys_s, S_Get51), cl_length(S_Get51, Length_Ret), (Incf_R<Length_Ret->get_var(LEnv39, n, N_Get55), _76263840=N_Get55;_76263840=[]), cl_rplaca(It_list_Get47, _76263840, LetResult38), ElseResult77=LetResult38;get_var(LEnv23, sys_it, It_Get58), (It_Get58\=[CAR181|CDR182]->get_var(LEnv23, sys_it, It_Get61), f_sys_error_not_a_sequence(It_Get61, TrueResult72), ElseResult75=TrueResult72;get_var(LEnv23, sys_it, It_Get63), get_var(LEnv23, sys_v_list, V_list_Get62), f_sys_cons_car(It_Get63, Cons_car_Ret183), cl_rplaca(V_list_Get62, Cons_car_Ret183, Rplaca_Ret184), get_var(LEnv23, sys_it, It_Get65), f_sys_cons_cdr(It_Get65, PredArgResult67), set_var(LEnv23, sys_it, PredArgResult67), (is_listp(PredArgResult67)->_76264204=[];get_var(LEnv23, sys_it, It_Get68), f_sys_error_not_a_sequence(It_Get68, A_sequence_Ret), _76264204=A_sequence_Ret), get_var(LEnv23, sys_it, It_Get71), get_var(LEnv23, sys_it_list, It_list_Get70), cl_rplaca(It_list_Get70, It_Get71, ElseResult73), ElseResult75=ElseResult73), ElseResult77=ElseResult75), _76263386=ElseResult77), get_var(LEnv23, sys_v_list, V_list_Get78), f_sys_cons_cdr(V_list_Get78, Cons_cdr_Ret), set_var(LEnv23, sys_v_list, Cons_cdr_Ret), get_var(LEnv23, sys_it_list, It_list_Get79), f_sys_cons_cdr(It_list_Get79, Cons_cdr_Ret187), set_var(LEnv23, sys_it_list, Cons_cdr_Ret187), get_var(LEnv23, sys_seq_list, Seq_list_Get80), f_sys_cons_cdr(Seq_list_Get80, LetResult22), set_var(LEnv23, sys_seq_list, LetResult22), cl_psetq(Psetq_Ret188), goto(do_label_3, BlockExitEnv), _76263206=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(sys_seq_iterator_list_pop, FnResult),
	      true).
:- set_opv(f_sys_seq_iterator_list_pop, classof, claz_function),
   set_opv(sys_seq_iterator_list_pop, compile_as, kw_function),
   set_opv(sys_seq_iterator_list_pop, function, f_sys_seq_iterator_list_pop),
   DefunResult=sys_seq_iterator_list_pop.
/*
:- side_effect(assert_lsp(sys_seq_iterator_list_pop,
			  lambda_def(defun,
				     sys_seq_iterator_list_pop,
				     f_sys_seq_iterator_list_pop,
				     
				     [ values_list,
				       sys_seq_list,
				       sys_iterator_list
				     ],
				     
				     [ [declare, [optimize, [safety, 0]]],
				       
				       [ do_xx,
					 
					 [ [sys_it_list, sys_iterator_list],
					   [sys_v_list, values_list]
					 ],
					 [[null, sys_v_list], values_list],
					 
					 [ let_xx,
					   
					   [ 
					     [ sys_it,
					       [sys_cons_car, sys_it_list]
					     ],
					     
					     [ sequence,
					       [sys_cons_car, sys_seq_list]
					     ]
					   ],
					   
					   [ cond,
					     [[null, sys_it], [return, []]],
					     
					     [ [sys_fixnump, sys_it],
					       
					       [ let_xx,
						 [[n, sys_it], [sys_s, sequence]],
						 
						 [ declare,
						   [fixnum, n],
						   [vector, sys_s]
						 ],
						 
						 [ rplaca,
						   sys_v_list,
						   [aref, sys_s, n]
						 ],
						 
						 [ rplaca,
						   sys_it_list,
						   
						   [ and,
						     
						     [ (<),
						       [incf, n],
						       [length, sys_s]
						     ],
						     n
						   ]
						 ]
					       ]
					     ],
					     
					     [ [atom, sys_it],
					       
					       [ sys_error_not_a_sequence,
						 sys_it
					       ]
					     ],
					     
					     [ t,
					       
					       [ rplaca,
						 sys_v_list,
						 [sys_cons_car, sys_it]
					       ],
					       
					       [ unless,
						 
						 [ listp,
						   
						   [ setf,
						     sys_it,
						     [sys_cons_cdr, sys_it]
						   ]
						 ],
						 
						 [ sys_error_not_a_sequence,
						   sys_it
						 ]
					       ],
					       [rplaca, sys_it_list, sys_it]
					     ]
					   ],
					   
					   [ setf,
					     sys_v_list,
					     [sys_cons_cdr, sys_v_list],
					     sys_it_list,
					     [sys_cons_cdr, sys_it_list],
					     sys_seq_list,
					     [sys_cons_cdr, sys_seq_list]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_list_pop,
			  arglist_info(sys_seq_iterator_list_pop,
				       f_sys_seq_iterator_list_pop,
				       
				       [ values_list,
					 sys_seq_list,
					 sys_iterator_list
				       ],
				       arginfo{ all:
						    [ values_list,
						      sys_seq_list,
						      sys_iterator_list
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ values_list,
							sys_seq_list,
							sys_iterator_list
						      ],
						opt:0,
						req:
						    [ values_list,
						      sys_seq_list,
						      sys_iterator_list
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_seq_iterator_list_pop,
			  init_args(exact_only, f_sys_seq_iterator_list_pop))).
*/
/*
#+(or WAM-CL ECL) 
(defun coerce-to-list (object)
  (if (listp object)
      object
      (do ((it (make-seq-iterator object) (seq-iterator-next object it))
           (output nil))
          ((null it) (nreverse output))
        (push (seq-iterator-ref object it) output))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:24683 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'coerce-to-list',[object],[if,[listp,object],object,[do,[[it,['make-seq-iterator',object],['seq-iterator-next',object,it]],[output,[]]],[[null,it],[nreverse,output]],[push,['seq-iterator-ref',object,it],output]]]]).
wl:lambda_def(defun, sys_coerce_to_list, f_sys_coerce_to_list, [sys_object], [[if, [listp, sys_object], sys_object, [do, [[sys_it, [sys_make_seq_iterator, sys_object], [sys_seq_iterator_next, sys_object, sys_it]], [sys_output, []]], [[null, sys_it], [nreverse, sys_output]], [push, [sys_seq_iterator_ref, sys_object, sys_it], sys_output]]]]).
wl:arglist_info(sys_coerce_to_list, f_sys_coerce_to_list, [sys_object], arginfo{all:[sys_object], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object], opt:0, req:[sys_object], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_coerce_to_list).

/*

### Compiled:  `SYS::COERCE-TO-LIST` 
*/
f_sys_coerce_to_list(Object_In, FnResult) :-
	Env48=[bv(sys_object, Object_In)|Env],
	global_env(Env),
	catch(( get_var(Env48, sys_object, Object_Get),
		(   is_listp(Object_Get)
		->  get_var(Env48, sys_object, Object_Get8),
		    _79451866=Object_Get8
		;   get_var(Env48, sys_object, Object_Get12),
		    f_sys_make_seq_iterator(Object_Get12, [], It_Init),
		    AEnv=[bv(sys_it, It_Init), bv(sys_output, [])|Env48],
		    catch(( call_addr_block(AEnv,
					    (push_label(do_label_4), get_var(AEnv, sys_it, IFTEST30), (IFTEST30==[]->get_var(AEnv, sys_output, Output_Get35), cl_nreverse(Output_Get35, RetResult33), throw(block_exit([], RetResult33)), _TBResult=ThrowResult34;cl_push([sys_seq_iterator_ref, sys_object, sys_it], sys_output, Output), get_var(AEnv, sys_it, It_Get39), get_var(AEnv, sys_object, Object_Get38), f_sys_seq_iterator_next(Object_Get38, It_Get39, It), set_var(AEnv, sys_it, It), goto(do_label_4, AEnv), _TBResult=_GORES40)),
					    
					    [ addr(addr_tagbody_4_do_label_4,
						   do_label_4,
						   '$unused',
						   AEnv,
						   (get_var(AEnv, sys_it, IFTEST15), (IFTEST15==[]->get_var(AEnv, sys_output, Nreverse_Param), cl_nreverse(Nreverse_Param, Nreverse_Ret), throw(block_exit([], Nreverse_Ret)), _79565410=ThrowResult;cl_push([sys_seq_iterator_ref, sys_object, sys_it], sys_output, Push_Ret), get_var(AEnv, sys_it, It_Get24), get_var(AEnv, sys_object, Object_Get23), f_sys_seq_iterator_next(Object_Get23, It_Get24, Iterator_next_Ret), set_var(AEnv, sys_it, Iterator_next_Ret), goto(do_label_4, AEnv), _79565410=_GORES)))
					    ]),
			    []=LetResult
			  ),
			  block_exit([], LetResult),
			  true),
		    _79451866=LetResult
		),
		_79451866=FnResult
	      ),
	      block_exit(sys_coerce_to_list, FnResult),
	      true).
:- set_opv(f_sys_coerce_to_list, classof, claz_function),
   set_opv(sys_coerce_to_list, compile_as, kw_function),
   set_opv(sys_coerce_to_list, function, f_sys_coerce_to_list),
   DefunResult=sys_coerce_to_list.
/*
:- side_effect(assert_lsp(sys_coerce_to_list,
			  lambda_def(defun,
				     sys_coerce_to_list,
				     f_sys_coerce_to_list,
				     [sys_object],
				     
				     [ 
				       [ if,
					 [listp, sys_object],
					 sys_object,
					 
					 [ do,
					   
					   [ 
					     [ sys_it,
					       
					       [ sys_make_seq_iterator,
						 sys_object
					       ],
					       
					       [ sys_seq_iterator_next,
						 sys_object,
						 sys_it
					       ]
					     ],
					     [sys_output, []]
					   ],
					   
					   [ [null, sys_it],
					     [nreverse, sys_output]
					   ],
					   
					   [ push,
					     
					     [ sys_seq_iterator_ref,
					       sys_object,
					       sys_it
					     ],
					     sys_output
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_coerce_to_list,
			  arglist_info(sys_coerce_to_list,
				       f_sys_coerce_to_list,
				       [sys_object],
				       arginfo{ all:[sys_object],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_object],
						opt:0,
						req:[sys_object],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_coerce_to_list,
			  init_args(exact_only, f_sys_coerce_to_list))).
*/
/*
#+(or WAM-CL ECL) 
(defun coerce-to-vector (object elt-type length simple-array-p)
  (let ((output object))
    (unless (and (vectorp object)
                 (or (null simple-array-p) (simple-array-p object))
                 (eq (array-element-type object) elt-type))
      (let* ((final-length (if (eq length '*) (length object) length)))
        (setf output (make-vector elt-type final-length nil nil nil 0))
        (do ((i (make-seq-iterator object) (seq-iterator-next output i))
             (j 0 (truly-the index (1+ j))))
            ((= j final-length)
             (setf object output))
          (declare (index j))
          (setf (aref output j) (seq-iterator-ref object i)))))
    (unless (eq length '*)
      (unless (= length (length output))
        (check-type output `(vector ,elt-type (,length)) "coerced object")))
    output))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:24969 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'coerce-to-vector',[object,'elt-type',length,'simple-array-p'],[let,[[output,object]],[unless,[and,[vectorp,object],[or,[null,'simple-array-p'],['simple-array-p',object]],[eq,['array-element-type',object],'elt-type']],['let*',[['final-length',[if,[eq,length,[quote,*]],[length,object],length]]],[setf,output,['make-vector','elt-type','final-length',[],[],[],0]],[do,[[i,['make-seq-iterator',object],['seq-iterator-next',output,i]],[j,0,['truly-the',index,['1+',j]]]],[[=,j,'final-length'],[setf,object,output]],[declare,[index,j]],[setf,[aref,output,j],['seq-iterator-ref',object,i]]]]],[unless,[eq,length,[quote,*]],[unless,[=,length,[length,output]],['check-type',output,['#BQ',[vector,['#COMMA','elt-type'],[['#COMMA',length]]]],'$STRING'("coerced object")]]],output]]).
/*
:- side_effect((compile_each($, BlockExitEnv, [sys_j], [sys_j], true), append([sys_output, sys_j], [CAR54, CAR], [sys_output, sys_j, CAR54, CAR]), setf_inverse_op(aref, []))).
*/
/*
:- side_effect((compile_each($, BlockExitEnv, [sys_j], [sys_j], true), append([sys_output, sys_j], [CAR54, CAR], [sys_output, sys_j, CAR54, CAR]), setf_inverse_op(aref, setf_aref))).
*/
/*
:- side_effect((compile_each($, BlockExitEnv, [sys_j], [sys_j], true), append([sys_output, sys_j], [CAR54, CAR], [sys_output, sys_j, CAR54, CAR]), setf_inverse_op(aref, []))).
*/
/*
:-side_effect((compile_each($,_81103964,[sys_j],[sys_j],true),append([sys_output,sys_j],[_81450776,_81450604],[sys_output,sys_j,_81450776,_81450604]),setf_inverse_op(aref,[]))).
*/
/*
:-side_effect((compile_each($,_81103964,[sys_j],[sys_j],true),append([sys_output,sys_j],[_81488928,_81488756],[sys_output,sys_j,_81488928,_81488756]),setf_inverse_op(aref,setf_aref))).
*/
/*
:-side_effect((compile_each($,_81103964,[sys_j],[sys_j],true),append([sys_output,sys_j],[_81527232,_81527060],[sys_output,sys_j,_81527232,_81527060]),setf_inverse_op(aref,[]))).
*/
wl:lambda_def(defun,sys_coerce_to_vector,f_sys_coerce_to_vector,[sys_object,sys_elt_type,length,sys_simple_array_p],[[let,[[sys_output,sys_object]],[unless,[and,[vectorp,sys_object],[or,[null,sys_simple_array_p],[sys_simple_array_p,sys_object]],[eq,[array_element_type,sys_object],sys_elt_type]],[let_xx,[[sys_final_length,[if,[eq,length,[quote,*]],[length,sys_object],length]]],[setf,sys_output,[sys_make_vector,sys_elt_type,sys_final_length,[],[],[],0]],[do,[[sys_i,[sys_make_seq_iterator,sys_object],[sys_seq_iterator_next,sys_output,sys_i]],[sys_j,0,[ext_truly_the,index,['1+',sys_j]]]],[[=,sys_j,sys_final_length],[setf,sys_object,sys_output]],[declare,[index,sys_j]],[setf,[aref,sys_output,sys_j],[sys_seq_iterator_ref,sys_object,sys_i]]]]],[unless,[eq,length,[quote,*]],[unless,[=,length,[length,sys_output]],[check_type,sys_output,['#BQ',[vector,['#COMMA',sys_elt_type],[['#COMMA',length]]]],'$ARRAY'([*],claz_base_character,"coerced object")]]],sys_output]]).
wl:arglist_info(sys_coerce_to_vector,f_sys_coerce_to_vector,[sys_object,sys_elt_type,length,sys_simple_array_p],arginfo{all:[sys_object,sys_elt_type,length,sys_simple_array_p],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_object,sys_elt_type,length,sys_simple_array_p],opt:0,req:[sys_object,sys_elt_type,length,sys_simple_array_p],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_coerce_to_vector).

/*

### Compiled:  `SYS::COERCE-TO-VECTOR` 
*/
f_sys_coerce_to_vector(_80974192,_80974226,_80974272,_80974330,_82111154):-_82835880=[bv(sys_object,_80974192),bv(sys_elt_type,_80974226),bv(length,_80974272),bv(sys_simple_array_p,_80974330)|_80951988],global_env(_80951988),catch((get_var(_82835880,sys_object,_81010074),_81003630=[bv(sys_output,_81010074)|_82835880],get_var(_81003630,sys_object,_81023766),(is_vectorp(_81023766)->(get_var(_81003630,sys_simple_array_p,_81026852),cl_null(_81026852,_81026784),_81026784\==[],_81026156=_81026784->true;get_var(_81003630,sys_object,_81030000),f_sys_simple_array_p(_81030000,_81029062),_81026156=_81029062),(_81026156\==[]->get_var(_81003630,sys_object,_81034150),cl_array_element_type(_81034150,_81033160),get_var(_81003630,sys_elt_type,_81035158),cl_eq(_81033160,_81035158,_81033092),_81048258=_81033092;_81048258=[]),_81020750=_81048258;_81020750=[]),(_81020750\==[]->_81018264=[];(is_eq(length,*)->get_var(_81003630,sys_object,_81073144),cl_length(_81073144,_81074560),_81070936=_81074560;_81070936=length),_81070632=[bv(sys_final_length,_81070936)|_81003630],get_var(_81070632,sys_elt_type,_81090916),get_var(_81070632,sys_final_length,_81091366),f_sys_make_vector(_81090916,_81091366,[],[],[],0,_81085586),set_var(_81070632,sys_output,_81085586),get_var(_81070632,sys_object,_81105426),f_sys_make_seq_iterator(_81105426,[],_81104436),_81103964=[bv(sys_i,_81104436),bv(sys_j,0)|_81070632],catch((call_addr_block(_81103964,(push_label(do_label_5),get_var(_81103964,sys_final_length,_81422066),get_var(_81103964,sys_j,_81420506),(_81420506=:=_81422066->get_var(_81103964,sys_output,_81424390),set_var(_81103964,sys_object,_81424390),throw(block_exit([],_81424390)),_81121392=_81424754;cl_declare([index,sys_j],_81431926),get_var(_81103964,sys_object,_81550286),get_var(_81103964,sys_output,_81548812),get_var(_81103964,sys_i,_81551432),f_sys_seq_iterator_ref(_81550286,_81551432,_81549348),get_var(_81103964,sys_j,_81553778),cl_apply([],[_81548812,_81553778,_81549348],_81431494),get_var(_81103964,sys_i,_81569108),get_var(_81103964,sys_output,_81567974),f_sys_seq_iterator_next(_81567974,_81569108,_81566966),f_ext_truly_the(index,['1+',sys_j],_81566878),set_var(_81103964,psetq,sys_i,_81566966),set_var(_81103964,psetq,sys_j,_81566878),goto(do_label_5,_81103964),_81121392=_81574336)),[addr(addr_tagbody_5_do_label_5,do_label_5,'$unused',_81616686,(get_var(_81616686,sys_final_length,_81616742),get_var(_81616686,sys_j,_81616714),(_81616714=:=_81616742->get_var(_81616686,sys_output,_81616784),set_var(_81616686,sys_object,_81616784),throw(block_exit([],_81616784)),_81616818=_81616824;cl_declare([index,sys_j],_83150550),get_var(_81616686,sys_object,_81616900),get_var(_81616686,sys_output,_81616864),get_var(_81616686,sys_i,_83153342),f_sys_seq_iterator_ref(_81616900,_83153342,_83155078),get_var(_81616686,sys_j,_81616956),cl_apply([],[_81616864,_81616956,_83155078],_83157124),get_var(_81616686,sys_i,_81617044),get_var(_81616686,sys_output,_81617016),f_sys_seq_iterator_next(_81617016,_81617044,_81617068),f_ext_truly_the(index,['1+',sys_j],_81617082),set_var(_81616686,psetq,sys_i,_81617068),set_var(_81616686,psetq,sys_j,_81617082),goto(do_label_5,_81616686),_81616818=_81617136)))]),[]=_81070420),block_exit([],_81070420),true),_81018264=_81070420),(is_eq(length,*)->_81870354=[];get_var(_81003630,sys_output,_81875368),cl_length(_81875368,_81877100),(length=:=_81877100->_81902742=[];cl_check_type(sys_output,['#BQ',[vector,['#COMMA',sys_elt_type],[['#COMMA',length]]]],'$ARRAY'([*],claz_base_character,"coerced object"),_81886816),_81902742=_81886816),_81870354=_81902742),get_var(_81003630,sys_output,_81911482),_81911482=_82111154),block_exit(sys_coerce_to_vector,_82111154),true).
:-set_opv(f_sys_coerce_to_vector,classof,claz_function),set_opv(sys_coerce_to_vector,compile_as,kw_function),set_opv(sys_coerce_to_vector,function,f_sys_coerce_to_vector),_80937394=sys_coerce_to_vector.
/*
:-side_effect(assert_lsp(sys_coerce_to_vector,lambda_def(defun,sys_coerce_to_vector,f_sys_coerce_to_vector,[sys_object,sys_elt_type,length,sys_simple_array_p],[[let,[[sys_output,sys_object]],[unless,[and,[vectorp,sys_object],[or,[null,sys_simple_array_p],[sys_simple_array_p,sys_object]],[eq,[array_element_type,sys_object],sys_elt_type]],[let_xx,[[sys_final_length,[if,[eq,length,[quote,*]],[length,sys_object],length]]],[setf,sys_output,[sys_make_vector,sys_elt_type,sys_final_length,[],[],[],0]],[do,[[sys_i,[sys_make_seq_iterator,sys_object],[sys_seq_iterator_next,sys_output,sys_i]],[sys_j,0,[ext_truly_the,index,['1+',sys_j]]]],[[=,sys_j,sys_final_length],[setf,sys_object,sys_output]],[declare,[index,sys_j]],[setf,[aref,sys_output,sys_j],[sys_seq_iterator_ref,sys_object,sys_i]]]]],[unless,[eq,length,[quote,*]],[unless,[=,length,[length,sys_output]],[check_type,sys_output,['#BQ',[vector,['#COMMA',sys_elt_type],[['#COMMA',length]]]],'$ARRAY'([*],claz_base_character,"coerced object")]]],sys_output]]))).
*/
/*
:-side_effect(assert_lsp(sys_coerce_to_vector,arglist_info(sys_coerce_to_vector,f_sys_coerce_to_vector,[sys_object,sys_elt_type,length,sys_simple_array_p],arginfo{all:[sys_object,sys_elt_type,length,sys_simple_array_p],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_object,sys_elt_type,length,sys_simple_array_p],opt:0,req:[sys_object,sys_elt_type,length,sys_simple_array_p],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_coerce_to_vector,init_args(exact_only,f_sys_coerce_to_vector))).
*/
/*
#+(or WAM-CL ECL) 
(defun concatenate (result-type &rest sequences)
  "Args: (type &rest sequences)
Returns a new sequence of the specified type, consisting of all elements of
SEQUENCEs."
  (do* ((length-list (mapcar #'length sequences) (rest length-list))
        (output (make-sequence result-type (apply #'+ length-list)))
        (sequences sequences (rest sequences))
        (i (make-seq-iterator output)))
      ((null sequences) output)
    (do* ((s (first sequences))
          (j (make-seq-iterator s) (seq-iterator-next s j)))
         ((null j))
      (seq-iterator-set output i (seq-iterator-ref s j))
      (setq i (seq-iterator-next output i)))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:25840 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,concatenate,['result-type','&rest',sequences],'$STRING'("Args: (type &rest sequences)\r\nReturns a new sequence of the specified type, consisting of all elements of\r\nSEQUENCEs."),['do*',[['length-list',[mapcar,function(length),sequences],[rest,'length-list']],[output,['make-sequence','result-type',[apply,function(+),'length-list']]],[sequences,sequences,[rest,sequences]],[i,['make-seq-iterator',output]]],[[null,sequences],output],['do*',[[s,[first,sequences]],[j,['make-seq-iterator',s],['seq-iterator-next',s,j]]],[[null,j]],['seq-iterator-set',output,i,['seq-iterator-ref',s,j]],[setq,i,['seq-iterator-next',output,i]]]]]).
doc: doc_string(concatenate,
	      _84291368,
	      function,
	      "Args: (type &rest sequences)\r\nReturns a new sequence of the specified type, consisting of all elements of\r\nSEQUENCEs.").

wl:lambda_def(defun, concatenate, cl_concatenate, [sys_result_type, c38_rest, sys_sequences], [[do_xx, [[sys_length_list, [mapcar, function(length), sys_sequences], [rest, sys_length_list]], [sys_output, [make_sequence, sys_result_type, [apply, function(+), sys_length_list]]], [sys_sequences, sys_sequences, [rest, sys_sequences]], [sys_i, [sys_make_seq_iterator, sys_output]]], [[null, sys_sequences], sys_output], [do_xx, [[sys_s, [first, sys_sequences]], [sys_j, [sys_make_seq_iterator, sys_s], [sys_seq_iterator_next, sys_s, sys_j]]], [[null, sys_j]], [sys_seq_iterator_set, sys_output, sys_i, [sys_seq_iterator_ref, sys_s, sys_j]], [setq, sys_i, [sys_seq_iterator_next, sys_output, sys_i]]]]]).
wl:arglist_info(concatenate, cl_concatenate, [sys_result_type, c38_rest, sys_sequences], arginfo{all:[sys_result_type], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_result_type, sys_sequences], opt:0, req:[sys_result_type], rest:[sys_sequences], sublists:0, whole:0}).
wl: init_args(1, cl_concatenate).

/*

### Compiled:  `CL:CONCATENATE` 
*/
cl_concatenate(Result_type_In, RestNKeys, FnResult) :-
	Env142=[bv(sys_result_type, Result_type_In), bv(sys_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env142, sys_sequences, Sequences_Get),
		cl_mapcar(cl_length, Sequences_Get, Length_list_Init),
		get_var(Env142, sys_length_list, Length_list_Get),
		get_var(Env142, sys_result_type, Result_type_Get),
		f_sys_c43(Length_list_Get, C43_Ret),
		cl_make_sequence(Result_type_Get, C43_Ret, [], Output_Init),
		get_var(Env142, sys_output, Output_Get),
		get_var(Env142, sys_sequences, Sequences_Get12),
		f_sys_make_seq_iterator(Output_Get, [], I_Init),
		BlockExitEnv=[bv(sys_length_list, Length_list_Init), bv(sys_output, Output_Init), bv(sys_sequences, Sequences_Get12), bv(sys_i, I_Init)|Env142],
		catch(( call_addr_block(BlockExitEnv,
					(push_label(do_label_6), get_var(BlockExitEnv, sys_sequences, IFTEST80), (IFTEST80==[]->get_var(BlockExitEnv, sys_output, RetResult83), throw(block_exit([], RetResult83)), _TBResult=ThrowResult84;get_var(BlockExitEnv, sys_sequences, Sequences_Get90), cl_car(Sequences_Get90, S_Init92), get_var(BlockExitEnv, sys_s, S_Get91), f_sys_make_seq_iterator(S_Get91, [], J_Init93), AEnv=[bv(sys_s, S_Init92), bv(sys_j, J_Init93)|BlockExitEnv], catch((call_addr_block(AEnv,  (push_label(do_label_8), get_var(AEnv, sys_j, IFTEST115), (IFTEST115==[]->throw(block_exit([], [])), _TBResult94=ThrowResult119;get_var(AEnv, sys_i, I_Get122), get_var(AEnv, sys_output, Output_Get121), get_var(AEnv, sys_j, J_Get124), get_var(AEnv, sys_s, S_Get123), f_sys_seq_iterator_ref(S_Get123, J_Get124, Iterator_ref_Ret), f_sys_seq_iterator_set(Output_Get121, I_Get122, Iterator_ref_Ret, Iterator_set_Ret), get_var(AEnv, sys_i, I_Get127), get_var(AEnv, sys_output, Output_Get126), f_sys_seq_iterator_next(Output_Get126, I_Get127, I), set_var(AEnv, sys_i, I), get_var(AEnv, sys_j, J_Get129), get_var(AEnv, sys_s, S_Get128), f_sys_seq_iterator_next(S_Get128, J_Get129, J), set_var(AEnv, sys_j, J), goto(do_label_8, AEnv), _TBResult94=_GORES130)), [addr(addr_tagbody_8_do_label_8, do_label_8, '$unused', AEnv,  (get_var(AEnv, sys_j, IFTEST95), (IFTEST95==[]->throw(block_exit([], [])), _TBResult94=ThrowResult99;get_var(AEnv, sys_i, I_Get102), get_var(AEnv, sys_output, Output_Get101), get_var(AEnv, sys_j, J_Get104), get_var(AEnv, sys_s, S_Get103), f_sys_seq_iterator_ref(S_Get103, J_Get104, Iterator_ref_Ret151), f_sys_seq_iterator_set(Output_Get101, I_Get102, Iterator_ref_Ret151, Iterator_set_Ret152), get_var(AEnv, sys_i, I_Get107), get_var(AEnv, sys_output, Output_Get106), f_sys_seq_iterator_next(Output_Get106, I_Get107, Iterator_next_Ret), set_var(AEnv, sys_i, Iterator_next_Ret), get_var(AEnv, sys_j, J_Get109), get_var(AEnv, sys_s, S_Get108), f_sys_seq_iterator_next(S_Get108, J_Get109, Iterator_next_Ret154), set_var(AEnv, sys_j, Iterator_next_Ret154), goto(do_label_8, AEnv), _TBResult94=_GORES110)))]), []=LetResult88), block_exit([], LetResult88), true), get_var(BlockExitEnv, sys_length_list, Length_list_Get134), cl_cdr(Length_list_Get134, Length_list), get_var(BlockExitEnv, sys_sequences, Sequences_Get135), cl_cdr(Sequences_Get135, Sequences), set_var(BlockExitEnv, psetq, sys_length_list, Length_list), set_var(BlockExitEnv, psetq, sys_sequences, Sequences), goto(do_label_6, BlockExitEnv), _TBResult=_GORES136)),
					
					[ addr(addr_tagbody_6_do_label_6,
					       do_label_6,
					       '$unused',
					       BlockExitEnv,
					       (get_var(BlockExitEnv, sys_sequences, IFTEST), (IFTEST==[]->get_var(BlockExitEnv, sys_output, Output_Get24), throw(block_exit([], Output_Get24)), _85120116=ThrowResult;get_var(BlockExitEnv, sys_sequences, Sequences_Get29), cl_car(Sequences_Get29, Car_Ret), get_var(BlockExitEnv, sys_s, Seq_iterator_Param), f_sys_make_seq_iterator(Seq_iterator_Param, [], Seq_iterator_Ret), AEnv=[bv(sys_s, Car_Ret), bv(sys_j, Seq_iterator_Ret)|BlockExitEnv], catch((call_addr_block(AEnv,  (push_label(do_label_7), get_var(AEnv, sys_j, IFTEST54), (IFTEST54==[]->throw(block_exit([], [])), _TBResult33=ThrowResult58;get_var(AEnv, sys_i, I_Get61), get_var(AEnv, sys_output, Output_Get60), get_var(AEnv, sys_j, J_Get63), get_var(AEnv, sys_s, S_Get62), f_sys_seq_iterator_ref(S_Get62, J_Get63, Iterator_ref_Ret157), f_sys_seq_iterator_set(Output_Get60, I_Get61, Iterator_ref_Ret157, Iterator_set_Ret158), get_var(AEnv, sys_i, I_Get66), get_var(AEnv, sys_output, Output_Get65), f_sys_seq_iterator_next(Output_Get65, I_Get66, Iterator_next_Ret159), set_var(AEnv, sys_i, Iterator_next_Ret159), get_var(AEnv, sys_j, J_Get68), get_var(AEnv, sys_s, S_Get67), f_sys_seq_iterator_next(S_Get67, J_Get68, Iterator_next_Ret160), set_var(AEnv, sys_j, Iterator_next_Ret160), goto(do_label_7, AEnv), _TBResult33=_GORES69)), [addr(addr_tagbody_7_do_label_7, do_label_7, '$unused', AEnv,  (get_var(AEnv, sys_j, IFTEST34), (IFTEST34==[]->throw(block_exit([], [])), _TBResult33=ThrowResult38;get_var(AEnv, sys_i, Get_var_Ret), get_var(AEnv, sys_output, Output_Get40), get_var(AEnv, sys_j, J_Get43), get_var(AEnv, sys_s, S_Get42), f_sys_seq_iterator_ref(S_Get42, J_Get43, Iterator_ref_Ret162), f_sys_seq_iterator_set(Output_Get40, Get_var_Ret, Iterator_ref_Ret162, Iterator_set_Ret163), get_var(AEnv, sys_i, I_Get46), get_var(AEnv, sys_output, Output_Get45), f_sys_seq_iterator_next(Output_Get45, I_Get46, Iterator_next_Ret164), set_var(AEnv, sys_i, Iterator_next_Ret164), get_var(AEnv, sys_j, J_Get48), get_var(AEnv, sys_s, S_Get47), f_sys_seq_iterator_next(S_Get47, J_Get48, Iterator_next_Ret165), set_var(AEnv, sys_j, Iterator_next_Ret165), goto(do_label_7, AEnv), _TBResult33=_GORES)))]), []=LetResult27), block_exit([], LetResult27), true), get_var(BlockExitEnv, sys_length_list, Length_list_Get73), cl_cdr(Length_list_Get73, Cdr_Ret), get_var(BlockExitEnv, sys_sequences, Sequences_Get74), cl_cdr(Sequences_Get74, Cdr_Ret167), set_var(BlockExitEnv, psetq, sys_length_list, Cdr_Ret), set_var(BlockExitEnv, psetq, sys_sequences, Cdr_Ret167), goto(do_label_6, BlockExitEnv), _85120116=_GORES75)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(concatenate, FnResult),
	      true).
:- set_opv(cl_concatenate, classof, claz_function),
   set_opv(concatenate, compile_as, kw_function),
   set_opv(concatenate, function, cl_concatenate),
   DefunResult=concatenate.
/*
:- side_effect(assert_lsp(concatenate,
			  doc_string(concatenate,
				     _84291368,
				     function,
				     "Args: (type &rest sequences)\r\nReturns a new sequence of the specified type, consisting of all elements of\r\nSEQUENCEs."))).
*/
/*
:- side_effect(assert_lsp(concatenate,
			  lambda_def(defun,
				     concatenate,
				     cl_concatenate,
				     [sys_result_type, c38_rest, sys_sequences],
				     
				     [ 
				       [ do_xx,
					 
					 [ 
					   [ sys_length_list,
					     
					     [ mapcar,
					       function(length),
					       sys_sequences
					     ],
					     [rest, sys_length_list]
					   ],
					   
					   [ sys_output,
					     
					     [ make_sequence,
					       sys_result_type,
					       
					       [ apply,
						 function(+),
						 sys_length_list
					       ]
					     ]
					   ],
					   
					   [ sys_sequences,
					     sys_sequences,
					     [rest, sys_sequences]
					   ],
					   
					   [ sys_i,
					     
					     [ sys_make_seq_iterator,
					       sys_output
					     ]
					   ]
					 ],
					 [[null, sys_sequences], sys_output],
					 
					 [ do_xx,
					   
					   [ [sys_s, [first, sys_sequences]],
					     
					     [ sys_j,
					       [sys_make_seq_iterator, sys_s],
					       
					       [ sys_seq_iterator_next,
						 sys_s,
						 sys_j
					       ]
					     ]
					   ],
					   [[null, sys_j]],
					   
					   [ sys_seq_iterator_set,
					     sys_output,
					     sys_i,
					     
					     [ sys_seq_iterator_ref,
					       sys_s,
					       sys_j
					     ]
					   ],
					   
					   [ setq,
					     sys_i,
					     
					     [ sys_seq_iterator_next,
					       sys_output,
					       sys_i
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(concatenate,
			  arglist_info(concatenate,
				       cl_concatenate,
				       
				       [ sys_result_type,
					 c38_rest,
					 sys_sequences
				       ],
				       arginfo{ all:[sys_result_type],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_result_type,
							sys_sequences
						      ],
						opt:0,
						req:[sys_result_type],
						rest:[sys_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(concatenate, init_args(1, cl_concatenate))).
*/
/*
#+(or WAM-CL ECL) 
(defun map (result-type function sequence &rest more-sequences)
  "Args: (type function sequence &rest more-sequences)
Creates and returns a sequence of TYPE with K elements, with the N-th element
being the value of applying FUNCTION to the N-th elements of the given
SEQUENCEs, where K is the minimum length of the given SEQUENCEs."
  (let* ((sequences (list* sequence more-sequences))
         (function (coerce-to-function function))
         output
         it)
    (when result-type
      (let ((l (length sequence)))
        (when more-sequences
          (setf l (reduce #'min more-sequences
                          :initial-value l
                          :key #'length)))
        (setf output (make-sequence result-type l)
              it (make-seq-iterator output))))
    (do-sequences (elt-list sequences :output output)
      (let ((value (apply function elt-list)))
        (when result-type
          (seq-iterator-set output it value)
          (setf it (seq-iterator-next output it)))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:26521 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,map,['result-type',function,sequence,'&rest','more-sequences'],'$STRING'("Args: (type function sequence &rest more-sequences)\r\nCreates and returns a sequence of TYPE with K elements, with the N-th element\r\nbeing the value of applying FUNCTION to the N-th elements of the given\r\nSEQUENCEs, where K is the minimum length of the given SEQUENCEs."),['let*',[[sequences,['list*',sequence,'more-sequences']],[function,['coerce-to-function',function]],output,it],[when,'result-type',[let,[[l,[length,sequence]]],[when,'more-sequences',[setf,l,[reduce,function(min),'more-sequences',':initial-value',l,':key',function(length)]]],[setf,output,['make-sequence','result-type',l],it,['make-seq-iterator',output]]]],['do-sequences',['elt-list',sequences,':output',output],[let,[[value,[apply,function,'elt-list']]],[when,'result-type',['seq-iterator-set',output,it,value],[setf,it,['seq-iterator-next',output,it]]]]]]]).
doc: doc_string(map,
	      _87981216,
	      function,
	      "Args: (type function sequence &rest more-sequences)\r\nCreates and returns a sequence of TYPE with K elements, with the N-th element\r\nbeing the value of applying FUNCTION to the N-th elements of the given\r\nSEQUENCEs, where K is the minimum length of the given SEQUENCEs.").

wl:lambda_def(defun, map, cl_map, [sys_result_type, function, sequence, c38_rest, sys_more_sequences], [[let_xx, [[sys_sequences, [list_xx, sequence, sys_more_sequences]], [function, [sys_coerce_to_function, function]], sys_output, sys_it], [when, sys_result_type, [let, [[sys_l, [length, sequence]]], [when, sys_more_sequences, [setf, sys_l, [reduce, function(min), sys_more_sequences, kw_initial_value, sys_l, kw_key, function(length)]]], [setf, sys_output, [make_sequence, sys_result_type, sys_l], sys_it, [sys_make_seq_iterator, sys_output]]]], [sys_do_sequences, [sys_elt_list, sys_sequences, kw_output, sys_output], [let, [[sys_value, [apply, function, sys_elt_list]]], [when, sys_result_type, [sys_seq_iterator_set, sys_output, sys_it, sys_value], [setf, sys_it, [sys_seq_iterator_next, sys_output, sys_it]]]]]]]).
wl:arglist_info(map, cl_map, [sys_result_type, function, sequence, c38_rest, sys_more_sequences], arginfo{all:[sys_result_type, function, sequence], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_result_type, function, sequence, sys_more_sequences], opt:0, req:[sys_result_type, function, sequence], rest:[sys_more_sequences], sublists:0, whole:0}).
wl: init_args(3, cl_map).

/*

### Compiled:  `CL:MAP` 
*/
cl_map(Result_type_In, Function_In, Sequence_In, RestNKeys, FnResult) :-
	Env50=[bv(sys_result_type, Result_type_In), bv(function, Function_In), bv(sequence, Sequence_In), bv(sys_more_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env50, sequence, Sequence_Get),
		get_var(Env50, sys_more_sequences, More_sequences_Get),
		cl_list_xx(Sequence_Get, More_sequences_Get, Sequences_Init),
		f_sys_coerce_to_function(function, Function_Init),
		LEnv=[bv(sys_sequences, Sequences_Init), bv(function, Function_Init), bv(sys_output, []), bv(sys_it, [])|Env50],
		get_var(LEnv, sys_result_type, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sequence, Sequence_Get21),
		    cl_length(Sequence_Get21, L_Init),
		    LEnv20=[bv(sys_l, L_Init)|LEnv],
		    get_var(LEnv20, sys_more_sequences, IFTEST23),
		    (   IFTEST23\==[]
		    ->  get_var(LEnv20, sys_l, L_Get),
			get_var(LEnv20,
				sys_more_sequences,
				More_sequences_Get26),
			cl_reduce(cl_min,
				  More_sequences_Get26,
				  kw_initial_value,
				  L_Get,
				  kw_key,
				  cl_length,
				  TrueResult),
			set_var(LEnv20, sys_l, TrueResult),
			_88044392=TrueResult
		    ;   _88044392=[]
		    ),
		    get_var(LEnv20, sys_l, L_Get30),
		    get_var(LEnv20, sys_result_type, Result_type_Get29),
		    cl_make_sequence(Result_type_Get29, L_Get30, [], Output),
		    set_var(LEnv20, sys_output, Output),
		    get_var(LEnv20, sys_output, Output_Get),
		    f_sys_make_seq_iterator(Output_Get, [], LetResult19),
		    set_var(LEnv20, sys_it, LetResult19),
		    _88031258=LetResult19
		;   _88031258=[]
		),
		get_var(LEnv, sys_output, Output_Get34),
		get_var(LEnv, sys_sequences, Sequences_Get),
		f_sys_elt_list(Sequences_Get,
			       kw_output,
			       Output_Get34,
			       Do_sequences_Param),
		cl_function(sys_elt_list, Value_Init),
		LEnv37=[bv(sys_value, Value_Init)|LEnv],
		get_var(LEnv37, sys_result_type, IFTEST39),
		(   IFTEST39\==[]
		->  get_var(LEnv37, sys_it, It_Get),
		    get_var(LEnv37, sys_output, Output_Get42),
		    get_var(LEnv37, sys_value, Value_Get),
		    f_sys_seq_iterator_set(Output_Get42,
					   It_Get,
					   Value_Get,
					   Iterator_set_Ret),
		    get_var(LEnv37, sys_it, It_Get46),
		    get_var(LEnv37, sys_output, Output_Get45),
		    f_sys_seq_iterator_next(Output_Get45,
					    It_Get46,
					    TrueResult47),
		    set_var(LEnv37, sys_it, TrueResult47),
		    LetResult36=TrueResult47
		;   LetResult36=[]
		),
		f_sys_do_sequences(Do_sequences_Param, LetResult36, LetResult),
		LetResult=FnResult
	      ),
	      block_exit(map, FnResult),
	      true).
:- set_opv(cl_map, classof, claz_function),
   set_opv(map, compile_as, kw_function),
   set_opv(map, function, cl_map),
   DefunResult=map.
/*
:- side_effect(assert_lsp(map,
			  doc_string(map,
				     _87981216,
				     function,
				     "Args: (type function sequence &rest more-sequences)\r\nCreates and returns a sequence of TYPE with K elements, with the N-th element\r\nbeing the value of applying FUNCTION to the N-th elements of the given\r\nSEQUENCEs, where K is the minimum length of the given SEQUENCEs."))).
*/
/*
:- side_effect(assert_lsp(map,
			  lambda_def(defun,
				     map,
				     cl_map,
				     
				     [ sys_result_type,
				       function,
				       sequence,
				       c38_rest,
				       sys_more_sequences
				     ],
				     
				     [ 
				       [ let_xx,
					 
					 [ 
					   [ sys_sequences,
					     
					     [ list_xx,
					       sequence,
					       sys_more_sequences
					     ]
					   ],
					   
					   [ function,
					     [sys_coerce_to_function, function]
					   ],
					   sys_output,
					   sys_it
					 ],
					 
					 [ when,
					   sys_result_type,
					   
					   [ let,
					     [[sys_l, [length, sequence]]],
					     
					     [ when,
					       sys_more_sequences,
					       
					       [ setf,
						 sys_l,
						 
						 [ reduce,
						   function(min),
						   sys_more_sequences,
						   kw_initial_value,
						   sys_l,
						   kw_key,
						   function(length)
						 ]
					       ]
					     ],
					     
					     [ setf,
					       sys_output,
					       
					       [ make_sequence,
						 sys_result_type,
						 sys_l
					       ],
					       sys_it,
					       
					       [ sys_make_seq_iterator,
						 sys_output
					       ]
					     ]
					   ]
					 ],
					 
					 [ sys_do_sequences,
					   
					   [ sys_elt_list,
					     sys_sequences,
					     kw_output,
					     sys_output
					   ],
					   
					   [ let,
					     
					     [ 
					       [ sys_value,
						 [apply, function, sys_elt_list]
					       ]
					     ],
					     
					     [ when,
					       sys_result_type,
					       
					       [ sys_seq_iterator_set,
						 sys_output,
						 sys_it,
						 sys_value
					       ],
					       
					       [ setf,
						 sys_it,
						 
						 [ sys_seq_iterator_next,
						   sys_output,
						   sys_it
						 ]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(map,
			  arglist_info(map,
				       cl_map,
				       
				       [ sys_result_type,
					 function,
					 sequence,
					 c38_rest,
					 sys_more_sequences
				       ],
				       arginfo{ all:
						    [ sys_result_type,
						      function,
						      sequence
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_result_type,
							function,
							sequence,
							sys_more_sequences
						      ],
						opt:0,
						req:
						    [ sys_result_type,
						      function,
						      sequence
						    ],
						rest:[sys_more_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(map, init_args(3, cl_map))).
*/
/*
#+(or WAM-CL ECL) 
(defun some (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;
NIL otherwise."
  (reckless
   (do-sequences (elt-list (cons sequence more-sequences) :output nil)
     (let ((x (apply predicate elt-list)))
       (when x (return x))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:27575 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,some,[predicate,sequence,'&rest','more-sequences'],'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;\r\nNIL otherwise."),[reckless,['do-sequences',['elt-list',[cons,sequence,'more-sequences'],':output',[]],[let,[[x,[apply,predicate,'elt-list']]],[when,x,[return,x]]]]]]).
doc: doc_string(some,
	      _89932908,
	      function,
	      "Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;\r\nNIL otherwise.").

wl:lambda_def(defun, some, cl_some, [predicate, sequence, c38_rest, sys_more_sequences], [[sys_reckless, [sys_do_sequences, [sys_elt_list, [cons, sequence, sys_more_sequences], kw_output, []], [let, [[sys_x, [apply, predicate, sys_elt_list]]], [when, sys_x, [return, sys_x]]]]]]).
wl:arglist_info(some, cl_some, [predicate, sequence, c38_rest, sys_more_sequences], arginfo{all:[predicate, sequence], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[predicate, sequence, sys_more_sequences], opt:0, req:[predicate, sequence], rest:[sys_more_sequences], sublists:0, whole:0}).
wl: init_args(2, cl_some).

/*

### Compiled:  `CL:SOME` 
*/
cl_some(Predicate_In, Sequence_In, RestNKeys, FnResult) :-
	Env24=[bv(predicate, Predicate_In), bv(sequence, Sequence_In), bv(sys_more_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env24, sequence, Sequence_Get),
		get_var(Env24, sys_more_sequences, More_sequences_Get),
		Elt_list_Param=[Sequence_Get|More_sequences_Get],
		f_sys_elt_list(Elt_list_Param, kw_output, [], Do_sequences_Param),
		get_var(Env24, sys_elt_list, Elt_list_Get),
		cl_predicate(Elt_list_Get, X_Init),
		LEnv=[bv(sys_x, X_Init)|Env24],
		get_var(LEnv, sys_x, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sys_x, X_Get19),
		    throw(block_exit([], X_Get19)),
		    LetResult=ThrowResult
		;   LetResult=[]
		),
		f_sys_do_sequences(Do_sequences_Param,
				   LetResult,
				   Reckless_Param),
		f_sys_reckless(Reckless_Param, Reckless_Ret),
		Reckless_Ret=FnResult
	      ),
	      block_exit(some, FnResult),
	      true).
:- set_opv(cl_some, classof, claz_function),
   set_opv(some, compile_as, kw_function),
   set_opv(some, function, cl_some),
   DefunResult=some.
/*
:- side_effect(assert_lsp(some,
			  doc_string(some,
				     _89932908,
				     function,
				     "Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs satisfies PREDICATE;\r\nNIL otherwise."))).
*/
/*
:- side_effect(assert_lsp(some,
			  lambda_def(defun,
				     some,
				     cl_some,
				     
				     [ predicate,
				       sequence,
				       c38_rest,
				       sys_more_sequences
				     ],
				     
				     [ 
				       [ sys_reckless,
					 
					 [ sys_do_sequences,
					   
					   [ sys_elt_list,
					     
					     [ cons,
					       sequence,
					       sys_more_sequences
					     ],
					     kw_output,
					     []
					   ],
					   
					   [ let,
					     
					     [ 
					       [ sys_x,
						 
						 [ apply,
						   predicate,
						   sys_elt_list
						 ]
					       ]
					     ],
					     [when, sys_x, [return, sys_x]]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(some,
			  arglist_info(some,
				       cl_some,
				       
				       [ predicate,
					 sequence,
					 c38_rest,
					 sys_more_sequences
				       ],
				       arginfo{ all:[predicate, sequence],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ predicate,
							sequence,
							sys_more_sequences
						      ],
						opt:0,
						req:[predicate, sequence],
						rest:[sys_more_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(some, init_args(2, cl_some))).
*/
/*
#+(or WAM-CL ECL) 
(defun every (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise."
  (reckless
   (do-sequences (elt-list (cons sequence more-sequences) :output t)
     (unless (apply predicate elt-list)
       (return nil)))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:27959 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,every,[predicate,sequence,'&rest','more-sequences'],'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise."),[reckless,['do-sequences',['elt-list',[cons,sequence,'more-sequences'],':output',t],[unless,[apply,predicate,'elt-list'],[return,[]]]]]]).
doc: doc_string(every,
	      _91102000,
	      function,
	      "Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise.").

wl:lambda_def(defun, every, cl_every, [predicate, sequence, c38_rest, sys_more_sequences], [[sys_reckless, [sys_do_sequences, [sys_elt_list, [cons, sequence, sys_more_sequences], kw_output, t], [unless, [apply, predicate, sys_elt_list], [return, []]]]]]).
wl:arglist_info(every, cl_every, [predicate, sequence, c38_rest, sys_more_sequences], arginfo{all:[predicate, sequence], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[predicate, sequence, sys_more_sequences], opt:0, req:[predicate, sequence], rest:[sys_more_sequences], sublists:0, whole:0}).
wl: init_args(2, cl_every).

/*

### Compiled:  `CL:EVERY` 
*/
cl_every(Predicate_In, Sequence_In, RestNKeys, FnResult) :-
	BlockExitEnv=[bv(predicate, Predicate_In), bv(sequence, Sequence_In), bv(sys_more_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(BlockExitEnv, sequence, Sequence_Get),
		get_var(BlockExitEnv, sys_more_sequences, More_sequences_Get),
		Elt_list_Param=[Sequence_Get|More_sequences_Get],
		f_sys_elt_list(Elt_list_Param, kw_output, t, T),
		get_var(BlockExitEnv, sys_elt_list, Elt_list_Get),
		cl_predicate(Elt_list_Get, IFTEST),
		(   IFTEST\==[]
		->  _91126180=[]
		;   throw(block_exit([], [])),
		    _91126180=ThrowResult
		),
		f_sys_do_sequences(T, _91126180, Reckless_Param),
		f_sys_reckless(Reckless_Param, Reckless_Ret),
		Reckless_Ret=FnResult
	      ),
	      block_exit(every, FnResult),
	      true).
:- set_opv(cl_every, classof, claz_function),
   set_opv(every, compile_as, kw_function),
   set_opv(every, function, cl_every),
   DefunResult=every.
/*
:- side_effect(assert_lsp(every,
			  doc_string(every,
				     _91102000,
				     function,
				     "Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE; NIL otherwise."))).
*/
/*
:- side_effect(assert_lsp(every,
			  lambda_def(defun,
				     every,
				     cl_every,
				     
				     [ predicate,
				       sequence,
				       c38_rest,
				       sys_more_sequences
				     ],
				     
				     [ 
				       [ sys_reckless,
					 
					 [ sys_do_sequences,
					   
					   [ sys_elt_list,
					     
					     [ cons,
					       sequence,
					       sys_more_sequences
					     ],
					     kw_output,
					     t
					   ],
					   
					   [ unless,
					     [apply, predicate, sys_elt_list],
					     [return, []]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(every,
			  arglist_info(every,
				       cl_every,
				       
				       [ predicate,
					 sequence,
					 c38_rest,
					 sys_more_sequences
				       ],
				       arginfo{ all:[predicate, sequence],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ predicate,
							sequence,
							sys_more_sequences
						      ],
						opt:0,
						req:[predicate, sequence],
						rest:[sys_more_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(every, init_args(2, cl_every))).
*/
/*
#-WAM-CL #+ECL
(def-seq-bool-parser notany
  "Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise."
  (when that-value (return nil))
  t)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:28319 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[-,':WAM-CL'],[#+,':ECL',['def-seq-bool-parser',notany,'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL\r\notherwise."),[when,'that-value',[return,[]]],t]]]))
/*
#-WAM-CL #+ECL
(def-seq-bool-parser notevery
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise."
  (unless that-value (return t))
  nil)
 
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:28544 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[-,':WAM-CL'],[#+,':ECL',['def-seq-bool-parser',notevery,'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs does not satisfy\r\nPREDICATE; NIL otherwise."),[unless,'that-value',[return,t]],[]]]]))
/*
#+(or WAM-CL ECL) 
(defun every* (predicate &rest sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences
have the same length; NIL otherwise."
  (and (apply #'= (mapcar #'length sequences))
       (apply #'every predicate sequences)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:28789 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'every*',[predicate,'&rest',sequences],'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences\r\nhave the same length; NIL otherwise."),[and,[apply,function(=),[mapcar,function(length),sequences]],[apply,function(every),predicate,sequences]]]).
doc: doc_string(sys_every_xx,
	      _92947534,
	      function,
	      "Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences\r\nhave the same length; NIL otherwise.").

wl:lambda_def(defun, sys_every_xx, f_sys_every_xx, [predicate, c38_rest, sys_sequences], [[and, [apply, function(=), [mapcar, function(length), sys_sequences]], [apply, function(every), predicate, sys_sequences]]]).
wl:arglist_info(sys_every_xx, f_sys_every_xx, [predicate, c38_rest, sys_sequences], arginfo{all:[predicate], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[predicate, sys_sequences], opt:0, req:[predicate], rest:[sys_sequences], sublists:0, whole:0}).
wl: init_args(1, f_sys_every_xx).

/*

### Compiled:  `SYS::EVERY*` 
*/
f_sys_every_xx(Predicate_In, RestNKeys, FnResult) :-
	Env14=[bv(predicate, Predicate_In), bv(sys_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env14, sys_sequences, Sequences_Get),
		cl_mapcar(cl_length, Sequences_Get, Mapcar_Ret),
		Mapcar_Ret=IFTEST,
		(   IFTEST\==[]
		->  get_var(Env14, predicate, Predicate_Get),
		    get_var(Env14, sys_sequences, Sequences_Get10),
		    cl_every(Predicate_Get, Sequences_Get10, [], TrueResult),
		    _92958858=TrueResult
		;   _92958858=[]
		),
		_92958858=FnResult
	      ),
	      block_exit(sys_every_xx, FnResult),
	      true).
:- set_opv(f_sys_every_xx, classof, claz_function),
   set_opv(sys_every_xx, compile_as, kw_function),
   set_opv(sys_every_xx, function, f_sys_every_xx),
   DefunResult=sys_every_xx.
/*
:- side_effect(assert_lsp(sys_every_xx,
			  doc_string(sys_every_xx,
				     _92947534,
				     function,
				     "Args: (predicate sequence &rest more-sequences)\r\nReturns T if every elements of SEQUENCEs satisfy PREDICATE and all sequences\r\nhave the same length; NIL otherwise."))).
*/
/*
:- side_effect(assert_lsp(sys_every_xx,
			  lambda_def(defun,
				     sys_every_xx,
				     f_sys_every_xx,
				     [predicate, c38_rest, sys_sequences],
				     
				     [ 
				       [ and,
					 
					 [ apply,
					   function(=),
					   
					   [ mapcar,
					     function(length),
					     sys_sequences
					   ]
					 ],
					 
					 [ apply,
					   function(every),
					   predicate,
					   sys_sequences
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_every_xx,
			  arglist_info(sys_every_xx,
				       f_sys_every_xx,
				       [predicate, c38_rest, sys_sequences],
				       arginfo{ all:[predicate],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ predicate,
							sys_sequences
						      ],
						opt:0,
						req:[predicate],
						rest:[sys_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_every_xx, init_args(1, f_sys_every_xx))).
*/
/*
#+(or WAM-CL ECL) 
(defun notany (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL
otherwise."
  (not (apply #'some predicate sequence more-sequences)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:29117 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,notany,[predicate,sequence,'&rest','more-sequences'],'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL\r\notherwise."),[not,[apply,function(some),predicate,sequence,'more-sequences']]]).
doc: doc_string(notany,
	      _93919754,
	      function,
	      "Args: (predicate sequence &rest more-sequences)\r\nReturns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL\r\notherwise.").

wl:lambda_def(defun, notany, cl_notany, [predicate, sequence, c38_rest, sys_more_sequences], [[not, [apply, function(some), predicate, sequence, sys_more_sequences]]]).
wl:arglist_info(notany, cl_notany, [predicate, sequence, c38_rest, sys_more_sequences], arginfo{all:[predicate, sequence], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[predicate, sequence, sys_more_sequences], opt:0, req:[predicate, sequence], rest:[sys_more_sequences], sublists:0, whole:0}).
wl: init_args(2, cl_notany).

/*

### Compiled:  `CL:NOTANY` 
*/
cl_notany(Predicate_In, Sequence_In, RestNKeys, FnResult) :-
	Env12=[bv(predicate, Predicate_In), bv(sequence, Sequence_In), bv(sys_more_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env12, predicate, Predicate_Get),
		get_var(Env12, sequence, Sequence_Get),
		get_var(Env12, sys_more_sequences, More_sequences_Get),
		cl_some(Predicate_Get,
			Sequence_Get,
			More_sequences_Get,
			Not_Param),
		cl_not(Not_Param, Not_Ret),
		Not_Ret=FnResult
	      ),
	      block_exit(notany, FnResult),
	      true).
:- set_opv(cl_notany, classof, claz_function),
   set_opv(notany, compile_as, kw_function),
   set_opv(notany, function, cl_notany),
   DefunResult=notany.
/*
:- side_effect(assert_lsp(notany,
			  doc_string(notany,
				     _93919754,
				     function,
				     "Args: (predicate sequence &rest more-sequences)\r\nReturns T if none of the elements in SEQUENCEs satisfies PREDICATE; NIL\r\notherwise."))).
*/
/*
:- side_effect(assert_lsp(notany,
			  lambda_def(defun,
				     notany,
				     cl_notany,
				     
				     [ predicate,
				       sequence,
				       c38_rest,
				       sys_more_sequences
				     ],
				     
				     [ 
				       [ not,
					 
					 [ apply,
					   function(some),
					   predicate,
					   sequence,
					   sys_more_sequences
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(notany,
			  arglist_info(notany,
				       cl_notany,
				       
				       [ predicate,
					 sequence,
					 c38_rest,
					 sys_more_sequences
				       ],
				       arginfo{ all:[predicate, sequence],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ predicate,
							sequence,
							sys_more_sequences
						      ],
						opt:0,
						req:[predicate, sequence],
						rest:[sys_more_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(notany, init_args(2, cl_notany))).
*/
/*
#+(or WAM-CL ECL) 
(defun notevery (predicate sequence &rest more-sequences)
  "Args: (predicate sequence &rest more-sequences)
Returns T if at least one of the elements in SEQUENCEs does not satisfy
PREDICATE; NIL otherwise."
  (not (apply #'every predicate sequence more-sequences)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:29393 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,notevery,[predicate,sequence,'&rest','more-sequences'],'$STRING'("Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs does not satisfy\r\nPREDICATE; NIL otherwise."),[not,[apply,function(every),predicate,sequence,'more-sequences']]]).
doc: doc_string(notevery,
	      _94848216,
	      function,
	      "Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs does not satisfy\r\nPREDICATE; NIL otherwise.").

wl:lambda_def(defun, notevery, cl_notevery, [predicate, sequence, c38_rest, sys_more_sequences], [[not, [apply, function(every), predicate, sequence, sys_more_sequences]]]).
wl:arglist_info(notevery, cl_notevery, [predicate, sequence, c38_rest, sys_more_sequences], arginfo{all:[predicate, sequence], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[predicate, sequence, sys_more_sequences], opt:0, req:[predicate, sequence], rest:[sys_more_sequences], sublists:0, whole:0}).
wl: init_args(2, cl_notevery).

/*

### Compiled:  `CL:NOTEVERY` 
*/
cl_notevery(Predicate_In, Sequence_In, RestNKeys, FnResult) :-
	Env12=[bv(predicate, Predicate_In), bv(sequence, Sequence_In), bv(sys_more_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env12, predicate, Predicate_Get),
		get_var(Env12, sequence, Sequence_Get),
		get_var(Env12, sys_more_sequences, More_sequences_Get),
		cl_every(Predicate_Get,
			 Sequence_Get,
			 More_sequences_Get,
			 Not_Param),
		cl_not(Not_Param, Not_Ret),
		Not_Ret=FnResult
	      ),
	      block_exit(notevery, FnResult),
	      true).
:- set_opv(cl_notevery, classof, claz_function),
   set_opv(notevery, compile_as, kw_function),
   set_opv(notevery, function, cl_notevery),
   DefunResult=notevery.
/*
:- side_effect(assert_lsp(notevery,
			  doc_string(notevery,
				     _94848216,
				     function,
				     "Args: (predicate sequence &rest more-sequences)\r\nReturns T if at least one of the elements in SEQUENCEs does not satisfy\r\nPREDICATE; NIL otherwise."))).
*/
/*
:- side_effect(assert_lsp(notevery,
			  lambda_def(defun,
				     notevery,
				     cl_notevery,
				     
				     [ predicate,
				       sequence,
				       c38_rest,
				       sys_more_sequences
				     ],
				     
				     [ 
				       [ not,
					 
					 [ apply,
					   function(every),
					   predicate,
					   sequence,
					   sys_more_sequences
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(notevery,
			  arglist_info(notevery,
				       cl_notevery,
				       
				       [ predicate,
					 sequence,
					 c38_rest,
					 sys_more_sequences
				       ],
				       arginfo{ all:[predicate, sequence],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ predicate,
							sequence,
							sys_more_sequences
						      ],
						opt:0,
						req:[predicate, sequence],
						rest:[sys_more_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(notevery, init_args(2, cl_notevery))).
*/
/*
#+(or WAM-CL ECL) 
(defun map-into (result-sequence function &rest sequences)
"Fills the output sequence with the values returned by applying FUNCTION to the
elements of the given sequences. The i-th element of RESULT-SEQUENCE is the output
of applying FUNCTION to the i-th element of each of the sequences. The map routine
stops when it reaches the end of one of the given sequences."
  (let ((nel (apply #'min (if (vectorp result-sequence)
                              (array-dimension result-sequence 0)
                              (length result-sequence))
                    (mapcar #'length sequences))))
    (declare (fixnum nel))
    ;; Set the fill pointer to the number of iterations
    (when (and (vectorp result-sequence)
               (array-has-fill-pointer-p result-sequence))
      (setf (fill-pointer result-sequence) nel))
    ;; Perform mapping
    (do ((ir (make-seq-iterator result-sequence) (seq-iterator-next result-sequence ir))
         (it (mapcar #'make-seq-iterator sequences))
         (val (make-sequence 'list (length sequences))))
        ((null ir) result-sequence)
      (do ((i it (cdr i))
           (v val (cdr v))
           (s sequences (cdr s)))
          ((null i))
        (unless (car i) (return-from map-into result-sequence))
        (rplaca v (seq-iterator-ref (car s) (car i)))
        (rplaca i (seq-iterator-next (car s) (car i))))
      (seq-iterator-set result-sequence ir (apply function val)))))


;;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
;;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:

;;;;
;;;;  Copyright (c) 1995, Giuseppe Attardi.
;;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
;;;;
;;;;    This program is free software; you can redistribute it and/or
;;;;    modify it under the terms of the GNU Library General Public
;;;;    License as published by the Free Software Foundation; either
;;;;    version 2 of the License, or (at your option) any later version.
;;;;
;;;;    See file '../Copyright' for full details.
;;;;                        list manipulating routines

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:29687 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'map-into',['result-sequence',function,'&rest',sequences],'$STRING'("Fills the output sequence with the values returned by applying FUNCTION to the\r\nelements of the given sequences. The i-th element of RESULT-SEQUENCE is the output\r\nof applying FUNCTION to the i-th element of each of the sequences. The map routine\r\nstops when it reaches the end of one of the given sequences."),[let,[[nel,[apply,function(min),[if,[vectorp,'result-sequence'],['array-dimension','result-sequence',0],[length,'result-sequence']],[mapcar,function(length),sequences]]]],[declare,[fixnum,nel]],[when,[and,[vectorp,'result-sequence'],['array-has-fill-pointer-p','result-sequence']],[setf,['fill-pointer','result-sequence'],nel]],[do,[[ir,['make-seq-iterator','result-sequence'],['seq-iterator-next','result-sequence',ir]],[it,[mapcar,function('make-seq-iterator'),sequences]],[val,['make-sequence',[quote,list],[length,sequences]]]],[[null,ir],'result-sequence'],[do,[[i,it,[cdr,i]],[v,val,[cdr,v]],[s,sequences,[cdr,s]]],[[null,i]],[unless,[car,i],['return-from','map-into','result-sequence']],[rplaca,v,['seq-iterator-ref',[car,s],[car,i]]],[rplaca,i,['seq-iterator-next',[car,s],[car,i]]]],['seq-iterator-set','result-sequence',ir,[apply,function,val]]]]]).
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([sys_result_sequence], [CAR29, CAR], [sys_result_sequence, CAR29, CAR]), setf_inverse_op(fill_pointer, sys_pf_set_fill_pointer))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([sys_result_sequence], [CAR29, CAR], [sys_result_sequence, CAR29, CAR]), setf_inverse_op(fill_pointer, setf_fill_pointer))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([sys_result_sequence], [CAR29, CAR], [sys_result_sequence, CAR29, CAR]), setf_inverse_op(fill_pointer, sys_pf_set_fill_pointer))).
*/
doc: doc_string(map_into,
	      _95906226,
	      function,
	      "Fills the output sequence with the values returned by applying FUNCTION to the\r\nelements of the given sequences. The i-th element of RESULT-SEQUENCE is the output\r\nof applying FUNCTION to the i-th element of each of the sequences. The map routine\r\nstops when it reaches the end of one of the given sequences.").

wl:lambda_def(defun, map_into, cl_map_into, [sys_result_sequence, function, c38_rest, sys_sequences], [[let, [[sys_nel, [apply, function(min), [if, [vectorp, sys_result_sequence], [array_dimension, sys_result_sequence, 0], [length, sys_result_sequence]], [mapcar, function(length), sys_sequences]]]], [declare, [fixnum, sys_nel]], [when, [and, [vectorp, sys_result_sequence], [array_has_fill_pointer_p, sys_result_sequence]], [setf, [fill_pointer, sys_result_sequence], sys_nel]], [do, [[sys_ir, [sys_make_seq_iterator, sys_result_sequence], [sys_seq_iterator_next, sys_result_sequence, sys_ir]], [sys_it, [mapcar, function(sys_make_seq_iterator), sys_sequences]], [sys_val, [make_sequence, [quote, list], [length, sys_sequences]]]], [[null, sys_ir], sys_result_sequence], [do, [[sys_i, sys_it, [cdr, sys_i]], [sys_v, sys_val, [cdr, sys_v]], [sys_s, sys_sequences, [cdr, sys_s]]], [[null, sys_i]], [unless, [car, sys_i], [return_from, map_into, sys_result_sequence]], [rplaca, sys_v, [sys_seq_iterator_ref, [car, sys_s], [car, sys_i]]], [rplaca, sys_i, [sys_seq_iterator_next, [car, sys_s], [car, sys_i]]]], [sys_seq_iterator_set, sys_result_sequence, sys_ir, [apply, function, sys_val]]]]]).
wl:arglist_info(map_into, cl_map_into, [sys_result_sequence, function, c38_rest, sys_sequences], arginfo{all:[sys_result_sequence, function], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_result_sequence, function, sys_sequences], opt:0, req:[sys_result_sequence, function], rest:[sys_sequences], sublists:0, whole:0}).
wl: init_args(2, cl_map_into).

/*

### Compiled:  `CL:MAP-INTO` 
*/
cl_map_into(Result_sequence_In, Function_In, RestNKeys, FnResult) :-
	Env206=[bv(sys_result_sequence, Result_sequence_In), bv(function, Function_In), bv(sys_sequences, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env206, sys_result_sequence, Result_sequence_Get),
		(   is_vectorp(Result_sequence_Get)
		->  get_var(Env206, sys_result_sequence, Result_sequence_Get14),
		    cl_array_dimension(Result_sequence_Get14, 0, TrueResult),
		    Min_Param=TrueResult
		;   get_var(Env206, sys_result_sequence, Result_sequence_Get15),
		    cl_length(Result_sequence_Get15, ElseResult),
		    Min_Param=ElseResult
		),
		get_var(Env206, sys_sequences, Sequences_Get),
		cl_mapcar(cl_length, Sequences_Get, KeysNRest),
		cl_min(Min_Param, KeysNRest, Nel_Init),
		LEnv=[bv(sys_nel, Nel_Init)|Env206],
		cl_declare([fixnum, sys_nel], Declare_Ret),
		get_var(LEnv, sys_result_sequence, Result_sequence_Get23),
		(   is_vectorp(Result_sequence_Get23)
		->  get_var(LEnv, sys_result_sequence, Result_sequence_Get26),
		    cl_array_has_fill_pointer_p(Result_sequence_Get26,
						TrueResult27),
		    IFTEST20=TrueResult27
		;   IFTEST20=[]
		),
		(   IFTEST20\==[]
		->  get_var(LEnv, sys_nel, Nel_Get),
		    get_var(LEnv, sys_result_sequence, Result_sequence_Get30),
		    f_sys_pf_set_fill_pointer(Result_sequence_Get30,
					      Nel_Get,
					      TrueResult32),
		    _95960128=TrueResult32
		;   _95960128=[]
		),
		get_var(LEnv, sys_result_sequence, Result_sequence_Get36),
		f_sys_make_seq_iterator(Result_sequence_Get36, [], Ir_Init),
		get_var(LEnv, sys_sequences, Sequences_Get37),
		cl_mapcar(f_sys_make_seq_iterator, Sequences_Get37, It_Init),
		get_var(LEnv, sys_sequences, Sequences_Get38),
		cl_length(Sequences_Get38, Length_Ret),
		cl_make_sequence(list, Length_Ret, [], Val_Init),
		AEnv=[bv(sys_ir, Ir_Init), bv(sys_it, It_Init), bv(sys_val, Val_Init)|LEnv],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_9), get_var(AEnv, sys_ir, IFTEST124), (IFTEST124==[]->get_var(AEnv, sys_result_sequence, RetResult127), throw(block_exit([], RetResult127)), _TBResult=ThrowResult128;get_var(AEnv, sys_it, It_Get134), get_var(AEnv, sys_sequences, Sequences_Get136), get_var(AEnv, sys_val, Val_Get135), BlockExitEnv=[bv(sys_i, It_Get134), bv(sys_v, Val_Get135), bv(sys_s, Sequences_Get136)|AEnv], catch((call_addr_block(BlockExitEnv,  (push_label(do_label_11), get_var(BlockExitEnv, sys_i, IFTEST169), (IFTEST169==[]->throw(block_exit([], [])), _TBResult140=ThrowResult173;get_var(BlockExitEnv, sys_i, I_Get177), cl_car(I_Get177, IFTEST175), (IFTEST175\==[]->_96998572=[];get_var(BlockExitEnv, sys_result_sequence, RetResult178), throw(block_exit(map_into, RetResult178)), _96998572=ThrowResult179), get_var(BlockExitEnv, sys_s, S_Get183), get_var(BlockExitEnv, sys_v, V_Get182), cl_car(S_Get183, Iterator_ref_Param), get_var(BlockExitEnv, sys_i, I_Get184), cl_car(I_Get184, Car_Ret), f_sys_seq_iterator_ref(Iterator_ref_Param, Car_Ret, Iterator_ref_Ret), cl_rplaca(V_Get182, Iterator_ref_Ret, Rplaca_Ret), get_var(BlockExitEnv, sys_i, I_Get185), get_var(BlockExitEnv, sys_s, S_Get186), cl_car(S_Get186, Iterator_next_Param), get_var(BlockExitEnv, sys_i, I_Get187), cl_car(I_Get187, Car_Ret228), f_sys_seq_iterator_next(Iterator_next_Param, Car_Ret228, Iterator_next_Ret), cl_rplaca(I_Get185, Iterator_next_Ret, Rplaca_Ret230), get_var(BlockExitEnv, sys_i, I_Get188), cl_cdr(I_Get188, I), get_var(BlockExitEnv, sys_v, V_Get189), cl_cdr(V_Get189, V), get_var(BlockExitEnv, sys_s, S_Get190), cl_cdr(S_Get190, S), set_var(BlockExitEnv, psetq, sys_i, I), set_var(BlockExitEnv, psetq, sys_v, V), set_var(BlockExitEnv, psetq, sys_s, S), goto(do_label_11, BlockExitEnv), _TBResult140=_GORES191)), [addr(addr_tagbody_11_do_label_11, do_label_11, '$unused', BlockExitEnv,  (get_var(BlockExitEnv, sys_i, IFTEST141), (IFTEST141==[]->throw(block_exit([], [])), _TBResult140=ThrowResult145;get_var(BlockExitEnv, sys_i, I_Get149), cl_car(I_Get149, IFTEST147), (IFTEST147\==[]->_97113850=[];get_var(BlockExitEnv, sys_result_sequence, RetResult150), throw(block_exit(map_into, RetResult150)), _97113850=ThrowResult151), get_var(BlockExitEnv, sys_s, S_Get156), get_var(BlockExitEnv, sys_v, V_Get155), cl_car(S_Get156, Iterator_ref_Param214), get_var(BlockExitEnv, sys_i, I_Get157), cl_car(I_Get157, Car_Ret231), f_sys_seq_iterator_ref(Iterator_ref_Param214, Car_Ret231, Iterator_ref_Ret232), cl_rplaca(V_Get155, Iterator_ref_Ret232, Rplaca_Ret233), get_var(BlockExitEnv, sys_i, I_Get158), get_var(BlockExitEnv, sys_s, S_Get159), cl_car(S_Get159, Iterator_next_Param215), get_var(BlockExitEnv, sys_i, I_Get160), cl_car(I_Get160, Car_Ret234), f_sys_seq_iterator_next(Iterator_next_Param215, Car_Ret234, Iterator_next_Ret235), cl_rplaca(I_Get158, Iterator_next_Ret235, Rplaca_Ret236), get_var(BlockExitEnv, sys_i, I_Get161), cl_cdr(I_Get161, Cdr_Ret), get_var(BlockExitEnv, sys_v, V_Get162), cl_cdr(V_Get162, Cdr_Ret238), get_var(BlockExitEnv, sys_s, S_Get163), cl_cdr(S_Get163, Cdr_Ret239), set_var(BlockExitEnv, psetq, sys_i, Cdr_Ret), set_var(BlockExitEnv, psetq, sys_v, Cdr_Ret238), set_var(BlockExitEnv, psetq, sys_s, Cdr_Ret239), goto(do_label_11, BlockExitEnv), _TBResult140=_GORES164)))]), []=LetResult132), block_exit([], LetResult132), true), get_var(AEnv, sys_ir, Ir_Get196), get_var(AEnv, sys_result_sequence, Result_sequence_Get195), cl_function(sys_val, Function_Ret), f_sys_seq_iterator_set(Result_sequence_Get195, Ir_Get196, Function_Ret, Iterator_set_Ret), get_var(AEnv, sys_ir, Ir_Get199), get_var(AEnv, sys_result_sequence, Result_sequence_Get198), f_sys_seq_iterator_next(Result_sequence_Get198, Ir_Get199, Ir), set_var(AEnv, sys_ir, Ir), goto(do_label_9, AEnv), _TBResult=_GORES200)),
					
					[ addr(addr_tagbody_9_do_label_9,
					       do_label_9,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_ir, IFTEST43), (IFTEST43==[]->get_var(AEnv, sys_result_sequence, Result_sequence_Get48), throw(block_exit([], Result_sequence_Get48)), _97455758=ThrowResult;get_var(AEnv, sys_it, It_Get), get_var(AEnv, sys_sequences, Sequences_Get55), get_var(AEnv, sys_val, Val_Get), BlockExitEnv=[bv(sys_i, It_Get), bv(sys_v, Val_Get), bv(sys_s, Sequences_Get55)|AEnv], catch((call_addr_block(BlockExitEnv,  (push_label(do_label_10), get_var(BlockExitEnv, sys_i, IFTEST88), (IFTEST88==[]->throw(block_exit([], [])), _TBResult59=ThrowResult92;get_var(BlockExitEnv, sys_i, I_Get96), cl_car(I_Get96, IFTEST94), (IFTEST94\==[]->_97456122=[];get_var(BlockExitEnv, sys_result_sequence, RetResult97), throw(block_exit(map_into, RetResult97)), _97456122=ThrowResult98), get_var(BlockExitEnv, sys_s, S_Get102), get_var(BlockExitEnv, sys_v, V_Get101), cl_car(S_Get102, Iterator_ref_Param216), get_var(BlockExitEnv, sys_i, I_Get103), cl_car(I_Get103, Car_Ret242), f_sys_seq_iterator_ref(Iterator_ref_Param216, Car_Ret242, Iterator_ref_Ret243), cl_rplaca(V_Get101, Iterator_ref_Ret243, Rplaca_Ret244), get_var(BlockExitEnv, sys_i, I_Get104), get_var(BlockExitEnv, sys_s, S_Get105), cl_car(S_Get105, Iterator_next_Param217), get_var(BlockExitEnv, sys_i, I_Get106), cl_car(I_Get106, Car_Ret245), f_sys_seq_iterator_next(Iterator_next_Param217, Car_Ret245, Iterator_next_Ret246), cl_rplaca(I_Get104, Iterator_next_Ret246, Rplaca_Ret247), get_var(BlockExitEnv, sys_i, I_Get107), cl_cdr(I_Get107, Cdr_Ret248), get_var(BlockExitEnv, sys_v, V_Get108), cl_cdr(V_Get108, Cdr_Ret249), get_var(BlockExitEnv, sys_s, S_Get109), cl_cdr(S_Get109, Cdr_Ret250), set_var(BlockExitEnv, psetq, sys_i, Cdr_Ret248), set_var(BlockExitEnv, psetq, sys_v, Cdr_Ret249), set_var(BlockExitEnv, psetq, sys_s, Cdr_Ret250), goto(do_label_10, BlockExitEnv), _TBResult59=_GORES110)), [addr(addr_tagbody_10_do_label_10, do_label_10, '$unused', BlockExitEnv,  (get_var(BlockExitEnv, sys_i, IFTEST60), (IFTEST60==[]->throw(block_exit([], [])), _TBResult59=ThrowResult64;get_var(BlockExitEnv, sys_i, I_Get68), cl_car(I_Get68, IFTEST66), (IFTEST66\==[]->_97456860=[];get_var(BlockExitEnv, sys_result_sequence, RetResult69), throw(block_exit(map_into, RetResult69)), _97456860=ThrowResult70), get_var(BlockExitEnv, sys_s, Car_Param), get_var(BlockExitEnv, sys_v, Rplaca_Param), cl_car(Car_Param, Iterator_ref_Param219), get_var(BlockExitEnv, sys_i, I_Get76), cl_car(I_Get76, Car_Ret251), f_sys_seq_iterator_ref(Iterator_ref_Param219, Car_Ret251, Iterator_ref_Ret252), cl_rplaca(Rplaca_Param, Iterator_ref_Ret252, Rplaca_Ret253), get_var(BlockExitEnv, sys_i, I_Get77), get_var(BlockExitEnv, sys_s, S_Get78), cl_car(S_Get78, Iterator_next_Param221), get_var(BlockExitEnv, sys_i, I_Get79), cl_car(I_Get79, Car_Ret254), f_sys_seq_iterator_next(Iterator_next_Param221, Car_Ret254, Iterator_next_Ret255), cl_rplaca(I_Get77, Iterator_next_Ret255, Rplaca_Ret256), get_var(BlockExitEnv, sys_i, I_Get80), cl_cdr(I_Get80, Cdr_Ret257), get_var(BlockExitEnv, sys_v, V_Get81), cl_cdr(V_Get81, Cdr_Ret258), get_var(BlockExitEnv, sys_s, S_Get82), cl_cdr(S_Get82, Cdr_Ret259), set_var(BlockExitEnv, psetq, sys_i, Cdr_Ret257), set_var(BlockExitEnv, psetq, sys_v, Cdr_Ret258), set_var(BlockExitEnv, psetq, sys_s, Cdr_Ret259), goto(do_label_10, BlockExitEnv), _TBResult59=_GORES)))]), []=LetResult51), block_exit([], LetResult51), true), get_var(AEnv, sys_ir, Ir_Get115), get_var(AEnv, sys_result_sequence, Result_sequence_Get114), cl_function(sys_val, Function_Ret260), f_sys_seq_iterator_set(Result_sequence_Get114, Ir_Get115, Function_Ret260, Iterator_set_Ret261), get_var(AEnv, sys_ir, Ir_Get118), get_var(AEnv, sys_result_sequence, Result_sequence_Get117), f_sys_seq_iterator_next(Result_sequence_Get117, Ir_Get118, Iterator_next_Ret262), set_var(AEnv, sys_ir, Iterator_next_Ret262), goto(do_label_9, AEnv), _97455758=_GORES119)))
					]),
			[]=LetResult34
		      ),
		      block_exit([], LetResult34),
		      true),
		LetResult34=FnResult
	      ),
	      block_exit(map_into, FnResult),
	      true).
:- set_opv(cl_map_into, classof, claz_function),
   set_opv(map_into, compile_as, kw_function),
   set_opv(map_into, function, cl_map_into),
   DefunResult=map_into.
/*
:- side_effect(assert_lsp(map_into,
			  doc_string(map_into,
				     _95906226,
				     function,
				     "Fills the output sequence with the values returned by applying FUNCTION to the\r\nelements of the given sequences. The i-th element of RESULT-SEQUENCE is the output\r\nof applying FUNCTION to the i-th element of each of the sequences. The map routine\r\nstops when it reaches the end of one of the given sequences."))).
*/
/*
:- side_effect(assert_lsp(map_into,
			  lambda_def(defun,
				     map_into,
				     cl_map_into,
				     
				     [ sys_result_sequence,
				       function,
				       c38_rest,
				       sys_sequences
				     ],
				     
				     [ 
				       [ let,
					 
					 [ 
					   [ sys_nel,
					     
					     [ apply,
					       function(min),
					       
					       [ if,
						 [vectorp, sys_result_sequence],
						 
						 [ array_dimension,
						   sys_result_sequence,
						   0
						 ],
						 [length, sys_result_sequence]
					       ],
					       
					       [ mapcar,
						 function(length),
						 sys_sequences
					       ]
					     ]
					   ]
					 ],
					 [declare, [fixnum, sys_nel]],
					 
					 [ when,
					   
					   [ and,
					     [vectorp, sys_result_sequence],
					     
					     [ array_has_fill_pointer_p,
					       sys_result_sequence
					     ]
					   ],
					   
					   [ setf,
					     
					     [ fill_pointer,
					       sys_result_sequence
					     ],
					     sys_nel
					   ]
					 ],
					 
					 [ do,
					   
					   [ 
					     [ sys_ir,
					       
					       [ sys_make_seq_iterator,
						 sys_result_sequence
					       ],
					       
					       [ sys_seq_iterator_next,
						 sys_result_sequence,
						 sys_ir
					       ]
					     ],
					     
					     [ sys_it,
					       
					       [ mapcar,
						 function(sys_make_seq_iterator),
						 sys_sequences
					       ]
					     ],
					     
					     [ sys_val,
					       
					       [ make_sequence,
						 [quote, list],
						 [length, sys_sequences]
					       ]
					     ]
					   ],
					   [[null, sys_ir], sys_result_sequence],
					   
					   [ do,
					     
					     [ [sys_i, sys_it, [cdr, sys_i]],
					       [sys_v, sys_val, [cdr, sys_v]],
					       
					       [ sys_s,
						 sys_sequences,
						 [cdr, sys_s]
					       ]
					     ],
					     [[null, sys_i]],
					     
					     [ unless,
					       [car, sys_i],
					       
					       [ return_from,
						 map_into,
						 sys_result_sequence
					       ]
					     ],
					     
					     [ rplaca,
					       sys_v,
					       
					       [ sys_seq_iterator_ref,
						 [car, sys_s],
						 [car, sys_i]
					       ]
					     ],
					     
					     [ rplaca,
					       sys_i,
					       
					       [ sys_seq_iterator_next,
						 [car, sys_s],
						 [car, sys_i]
					       ]
					     ]
					   ],
					   
					   [ sys_seq_iterator_set,
					     sys_result_sequence,
					     sys_ir,
					     [apply, function, sys_val]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(map_into,
			  arglist_info(map_into,
				       cl_map_into,
				       
				       [ sys_result_sequence,
					 function,
					 c38_rest,
					 sys_sequences
				       ],
				       arginfo{ all:
						    [ sys_result_sequence,
						      function
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_result_sequence,
							function,
							sys_sequences
						      ],
						opt:0,
						req:
						    [ sys_result_sequence,
						      function
						    ],
						rest:[sys_sequences],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(map_into, init_args(2, cl_map_into))).
*/
/*
; Set the fill pointer to the number of iterations
*/
/*
; Perform mapping
*/
/*
;;; -*- Mode: Lisp; Syntax: Common-Lisp; indent-tabs-mode: nil; Package: SYSTEM -*-
*/
/*
;;; vim: set filetype=lisp tabstop=8 shiftwidth=2 expandtab:
*/
/*
;;;
*/
/*
;;;  Copyright (c) 1995, Giuseppe Attardi.
*/
/*
;;;  Copyright (c) 2001, Juan Jose Garcia Ripoll.
*/
/*
;;;
*/
/*
;;;    This program is free software; you can redistribute it and/or
*/
/*
;;;    modify it under the terms of the GNU Library General Public
*/
/*
;;;    License as published by the Free Software Foundation; either
*/
/*
;;;    version 2 of the License, or (at your option) any later version.
*/
/*
;;;
*/
/*
;;;    See file '../Copyright' for full details.
*/
/*
;;;                        list manipulating routines
*/
/*
(in-package "SYSTEM")


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:31833 **********************/
:-lisp_compile_to_prolog(pkg_sys,['in-package','$STRING'("SYSTEM")]).
:- cl_in_package('$ARRAY'([*], claz_base_character, "SYSTEM"), _Ignored).
/*
#+(or WAM-CL ECL)
(defun union (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, the union of elements in LIST1 and in LIST2."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last list2))
       (or first list2))
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (progn (rplacd last (cons (car x) nil))
                 (setq last (cdr last)))
          (progn (setq first (cons (car x) nil))
                 (setq last first))))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:31860 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,union,[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, the union of elements in LIST1 and in LIST2."),[do,[[x,list1,[cdr,x]],[first],[last]],[[null,x],[when,last,[rplacd,last,list2]],[or,first,list2]],[unless,[member1,[car,x],list2,test,'test-not',key],[if,last,[progn,[rplacd,last,[cons,[car,x],[]]],[setq,last,[cdr,last]]],[progn,[setq,first,[cons,[car,x],[]]],[setq,last,first]]]]]]).
doc: doc_string(union,
	      _102278640,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, the union of elements in LIST1 and in LIST2.").

wl:lambda_def(defun, union, cl_union, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [first], [last]], [[null, sys_x], [when, last, [rplacd, last, sys_list2]], [or, first, sys_list2]], [unless, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [if, last, [progn, [rplacd, last, [cons, [car, sys_x], []]], [setq, last, [cdr, last]]], [progn, [setq, first, [cons, [car, sys_x], []]], [setq, last, first]]]]]]).
wl:arglist_info(union, cl_union, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_union).

/*

### Compiled:  `CL:UNION` 
*/
cl_union(List1_In, List2_In, RestNKeys, FnResult) :-
	Env99=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env99, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([first], []), bv([last], [])|Env99],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_12), get_var(AEnv, sys_x, IFTEST58), (IFTEST58==[]->get_var(AEnv, last, IFTEST63), (IFTEST63\==[]->get_var(AEnv, last, Last_Get66), get_var(AEnv, sys_list2, List2_Get67), cl_rplacd(Last_Get66, List2_Get67, TrueResult68), _102559754=TrueResult68;_102559754=[]), (get_var(AEnv, first, First_Get69), First_Get69\==[], RetResult61=First_Get69->true;get_var(AEnv, sys_list2, List2_Get70), RetResult61=List2_Get70), throw(block_exit([], RetResult61)), _TBResult=ThrowResult62;get_var(AEnv, sys_x, X_Get75), cl_car(X_Get75, Member1_Param), get_var(AEnv, sys_list2, List2_Get76), get_var(AEnv, sys_test_not, Test_not_Get78), get_var(AEnv, test, Test_Get77), get_var(AEnv, key, Key_Get79), f_sys_member1(Member1_Param, List2_Get76, Test_Get77, Test_not_Get78, Key_Get79, IFTEST73), (IFTEST73\==[]->_102593738=[];get_var(AEnv, last, IFTEST80), (IFTEST80\==[]->get_var(AEnv, last, Last_Get83), get_var(AEnv, sys_x, X_Get84), cl_car(X_Get84, Car_Ret), _102612850=[Car_Ret], cl_rplacd(Last_Get83, _102612850, Rplacd_Ret), get_var(AEnv, last, Last_Get86), cl_cdr(Last_Get86, TrueResult89), set_var(AEnv, last, TrueResult89), ElseResult91=TrueResult89;get_var(AEnv, sys_x, X_Get87), cl_car(X_Get87, Car_Ret106), First=[Car_Ret106], set_var(AEnv, first, First), get_var(AEnv, first, First_Get88), set_var(AEnv, last, First_Get88), ElseResult91=First_Get88), _102593738=ElseResult91), get_var(AEnv, sys_x, X_Get92), cl_cdr(X_Get92, X), set_var(AEnv, sys_x, X), goto(do_label_12, AEnv), _TBResult=_GORES93)),
					
					[ addr(addr_tagbody_12_do_label_12,
					       do_label_12,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, last, IFTEST23), (IFTEST23\==[]->get_var(AEnv, last, Last_Get26), get_var(AEnv, sys_list2, Get_var_Ret), cl_rplacd(Last_Get26, Get_var_Ret, Rplacd_Ret108), _102767810=Rplacd_Ret108;_102767810=[]), (get_var(AEnv, first, First_Get), First_Get\==[], Block_exit_Ret=First_Get->true;get_var(AEnv, sys_list2, List2_Get30), Block_exit_Ret=List2_Get30), throw(block_exit([], Block_exit_Ret)), _102767936=ThrowResult;get_var(AEnv, sys_x, X_Get35), cl_car(X_Get35, Member1_Param103), get_var(AEnv, sys_list2, List2_Get36), get_var(AEnv, sys_test_not, Get_var_Ret110), get_var(AEnv, test, Get_var_Ret111), get_var(AEnv, key, Get_var_Ret112), f_sys_member1(Member1_Param103, List2_Get36, Get_var_Ret111, Get_var_Ret110, Get_var_Ret112, IFTEST33), (IFTEST33\==[]->_102768124=[];get_var(AEnv, last, IFTEST40), (IFTEST40\==[]->get_var(AEnv, last, Last_Get43), get_var(AEnv, sys_x, X_Get44), cl_car(X_Get44, Car_Ret113), _102768256=[Car_Ret113], cl_rplacd(Last_Get43, _102768256, Rplacd_Ret114), get_var(AEnv, last, Last_Get46), cl_cdr(Last_Get46, TrueResult49), set_var(AEnv, last, TrueResult49), ElseResult51=TrueResult49;get_var(AEnv, sys_x, X_Get47), cl_car(X_Get47, Car_Ret115), Set_var_Ret=[Car_Ret115], set_var(AEnv, first, Set_var_Ret), get_var(AEnv, first, First_Get48), set_var(AEnv, last, First_Get48), ElseResult51=First_Get48), _102768124=ElseResult51), get_var(AEnv, sys_x, X_Get52), cl_cdr(X_Get52, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_12, AEnv), _102767936=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(union, FnResult),
	      true).
:- set_opv(cl_union, classof, claz_function),
   set_opv(union, compile_as, kw_function),
   set_opv(union, function, cl_union),
   DefunResult=union.
/*
:- side_effect(assert_lsp(union,
			  doc_string(union,
				     _102278640,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, the union of elements in LIST1 and in LIST2."))).
*/
/*
:- side_effect(assert_lsp(union,
			  lambda_def(defun,
				     union,
				     cl_union,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [first],
					   [last]
					 ],
					 
					 [ [null, sys_x],
					   [when, last, [rplacd, last, sys_list2]],
					   [or, first, sys_list2]
					 ],
					 
					 [ unless,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   
					   [ if,
					     last,
					     
					     [ progn,
					       
					       [ rplacd,
						 last,
						 [cons, [car, sys_x], []]
					       ],
					       [setq, last, [cdr, last]]
					     ],
					     
					     [ progn,
					       
					       [ setq,
						 first,
						 [cons, [car, sys_x], []]
					       ],
					       [setq, last, first]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(union,
			  arglist_info(union,
				       cl_union,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(union, init_args(2, cl_union))).
*/
/*
#+(or WAM-CL ECL) 
(defun nunion (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive UNION.  Both LIST1 and LIST2 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last list2))
       (or first list2))
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:32457 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nunion,[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive UNION.  Both LIST1 and LIST2 may be destroyed."),[do,[[x,list1,[cdr,x]],[first],[last]],[[null,x],[when,last,[rplacd,last,list2]],[or,first,list2]],[unless,[member1,[car,x],list2,test,'test-not',key],[if,last,[rplacd,last,x],[setq,first,x]],[setq,last,x]]]]).
doc: doc_string(nunion,
	      _105197924,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive UNION.  Both LIST1 and LIST2 may be destroyed.").

wl:lambda_def(defun, nunion, cl_nunion, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [first], [last]], [[null, sys_x], [when, last, [rplacd, last, sys_list2]], [or, first, sys_list2]], [unless, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [if, last, [rplacd, last, sys_x], [setq, first, sys_x]], [setq, last, sys_x]]]]).
wl:arglist_info(nunion, cl_nunion, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_nunion).

/*

### Compiled:  `CL:NUNION` 
*/
cl_nunion(List1_In, List2_In, RestNKeys, FnResult) :-
	Env97=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env97, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([first], []), bv([last], [])|Env97],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_13), get_var(AEnv, sys_x, IFTEST57), (IFTEST57==[]->get_var(AEnv, last, IFTEST62), (IFTEST62\==[]->get_var(AEnv, last, Last_Get65), get_var(AEnv, sys_list2, List2_Get66), cl_rplacd(Last_Get65, List2_Get66, TrueResult67), _105427236=TrueResult67;_105427236=[]), (get_var(AEnv, first, First_Get68), First_Get68\==[], RetResult60=First_Get68->true;get_var(AEnv, sys_list2, List2_Get69), RetResult60=List2_Get69), throw(block_exit([], RetResult60)), _TBResult=ThrowResult61;get_var(AEnv, sys_x, X_Get74), cl_car(X_Get74, Member1_Param), get_var(AEnv, sys_list2, List2_Get75), get_var(AEnv, sys_test_not, Test_not_Get77), get_var(AEnv, test, Test_Get76), get_var(AEnv, key, Key_Get78), f_sys_member1(Member1_Param, List2_Get75, Test_Get76, Test_not_Get77, Key_Get78, IFTEST72), (IFTEST72\==[]->_105460116=[];get_var(AEnv, last, IFTEST79), (IFTEST79\==[]->get_var(AEnv, last, Last_Get82), get_var(AEnv, sys_x, X_Get83), cl_rplacd(Last_Get82, X_Get83, TrueResult86), _105472822=TrueResult86;get_var(AEnv, sys_x, X_Get85), set_var(AEnv, first, X_Get85), _105472822=X_Get85), get_var(AEnv, sys_x, X_Get88), set_var(AEnv, last, X_Get88), _105460116=X_Get88), get_var(AEnv, sys_x, X_Get90), cl_cdr(X_Get90, X), set_var(AEnv, sys_x, X), goto(do_label_13, AEnv), _TBResult=_GORES91)),
					
					[ addr(addr_tagbody_13_do_label_13,
					       do_label_13,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, last, IFTEST23), (IFTEST23\==[]->get_var(AEnv, last, Last_Get26), get_var(AEnv, sys_list2, Get_var_Ret), cl_rplacd(Last_Get26, Get_var_Ret, Rplacd_Ret), _105586184=Rplacd_Ret;_105586184=[]), (get_var(AEnv, first, First_Get), First_Get\==[], Block_exit_Ret=First_Get->true;get_var(AEnv, sys_list2, List2_Get30), Block_exit_Ret=List2_Get30), throw(block_exit([], Block_exit_Ret)), _105586310=ThrowResult;get_var(AEnv, sys_x, X_Get35), cl_car(X_Get35, Member1_Param100), get_var(AEnv, sys_list2, List2_Get36), get_var(AEnv, sys_test_not, Get_var_Ret104), get_var(AEnv, test, Get_var_Ret105), get_var(AEnv, key, Get_var_Ret106), f_sys_member1(Member1_Param100, List2_Get36, Get_var_Ret105, Get_var_Ret104, Get_var_Ret106, IFTEST33), (IFTEST33\==[]->_105586498=[];get_var(AEnv, last, IFTEST40), (IFTEST40\==[]->get_var(AEnv, last, Last_Get43), get_var(AEnv, sys_x, X_Get44), cl_rplacd(Last_Get43, X_Get44, TrueResult47), _105586640=TrueResult47;get_var(AEnv, sys_x, X_Get46), set_var(AEnv, first, X_Get46), _105586640=X_Get46), get_var(AEnv, sys_x, X_Get49), set_var(AEnv, last, X_Get49), _105586498=X_Get49), get_var(AEnv, sys_x, X_Get51), cl_cdr(X_Get51, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_13, AEnv), _105586310=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(nunion, FnResult),
	      true).
:- set_opv(cl_nunion, classof, claz_function),
   set_opv(nunion, compile_as, kw_function),
   set_opv(nunion, function, cl_nunion),
   DefunResult=nunion.
/*
:- side_effect(assert_lsp(nunion,
			  doc_string(nunion,
				     _105197924,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive UNION.  Both LIST1 and LIST2 may be destroyed."))).
*/
/*
:- side_effect(assert_lsp(nunion,
			  lambda_def(defun,
				     nunion,
				     cl_nunion,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [first],
					   [last]
					 ],
					 
					 [ [null, sys_x],
					   [when, last, [rplacd, last, sys_list2]],
					   [or, first, sys_list2]
					 ],
					 
					 [ unless,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   
					   [ if,
					     last,
					     [rplacd, last, sys_x],
					     [setq, first, sys_x]
					   ],
					   [setq, last, sys_x]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nunion,
			  arglist_info(nunion,
				       cl_nunion,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nunion, init_args(2, cl_nunion))).
*/
/*
#+(or WAM-CL ECL) 
(defun intersection (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns a list consisting of those objects that are elements of both LIST1 and
LIST2."
  (do ((x list1 (cdr x))
       (ans))
      ((null x)
       (nreverse ans)) ; optional nreverse: not required by CLtL
    (when (member1 (car x) list2 test test-not key)
        (push (car x) ans))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:32944 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,intersection,[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns a list consisting of those objects that are elements of both LIST1 and\r\nLIST2."),[do,[[x,list1,[cdr,x]],[ans]],[[null,x],[nreverse,ans]],[when,[member1,[car,x],list2,test,'test-not',key],[push,[car,x],ans]]]]).
doc: doc_string(intersection,
	      _107793592,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns a list consisting of those objects that are elements of both LIST1 and\r\nLIST2.").

wl:lambda_def(defun, intersection, cl_intersection, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [sys_ans]], [[null, sys_x], [nreverse, sys_ans]], [when, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [push, [car, sys_x], sys_ans]]]]).
wl:arglist_info(intersection, cl_intersection, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_intersection).

/*

### Compiled:  `CL:INTERSECTION` 
*/
cl_intersection(List1_In, List2_In, RestNKeys, FnResult) :-
	Env63=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env63, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([sys_ans], [])|Env63],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_14), get_var(AEnv, sys_x, IFTEST40), (IFTEST40==[]->get_var(AEnv, sys_ans, Ans_Get45), cl_nreverse(Ans_Get45, RetResult43), throw(block_exit([], RetResult43)), _TBResult=ThrowResult44;get_var(AEnv, sys_x, X_Get49), cl_car(X_Get49, Member1_Param), get_var(AEnv, sys_list2, List2_Get50), get_var(AEnv, sys_test_not, Test_not_Get52), get_var(AEnv, test, Test_Get51), get_var(AEnv, key, Key_Get53), f_sys_member1(Member1_Param, List2_Get50, Test_Get51, Test_not_Get52, Key_Get53, IFTEST47), (IFTEST47\==[]->cl_push([car, sys_x], sys_ans, TrueResult54), _107939472=TrueResult54;_107939472=[]), get_var(AEnv, sys_x, X_Get56), cl_cdr(X_Get56, X), set_var(AEnv, sys_x, X), goto(do_label_14, AEnv), _TBResult=_GORES57)),
					
					[ addr(addr_tagbody_14_do_label_14,
					       do_label_14,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, sys_ans, Nreverse_Param), cl_nreverse(Nreverse_Param, Nreverse_Ret), throw(block_exit([], Nreverse_Ret)), _108010698=ThrowResult;get_var(AEnv, sys_x, X_Get27), cl_car(X_Get27, Member1_Param67), get_var(AEnv, sys_list2, Get_var_Ret), get_var(AEnv, sys_test_not, Get_var_Ret70), get_var(AEnv, test, Get_var_Ret71), get_var(AEnv, key, Get_var_Ret72), f_sys_member1(Member1_Param67, Get_var_Ret, Get_var_Ret71, Get_var_Ret70, Get_var_Ret72, IFTEST25), (IFTEST25\==[]->cl_push([car, sys_x], sys_ans, Push_Ret), _108010886=Push_Ret;_108010886=[]), get_var(AEnv, sys_x, X_Get34), cl_cdr(X_Get34, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_14, AEnv), _108010698=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(intersection, FnResult),
	      true).
:- set_opv(cl_intersection, classof, claz_function),
   set_opv(intersection, compile_as, kw_function),
   set_opv(intersection, function, cl_intersection),
   DefunResult=intersection.
/*
:- side_effect(assert_lsp(intersection,
			  doc_string(intersection,
				     _107793592,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns a list consisting of those objects that are elements of both LIST1 and\r\nLIST2."))).
*/
/*
:- side_effect(assert_lsp(intersection,
			  lambda_def(defun,
				     intersection,
				     cl_intersection,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [sys_ans]
					 ],
					 [[null, sys_x], [nreverse, sys_ans]],
					 
					 [ when,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   [push, [car, sys_x], sys_ans]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(intersection,
			  arglist_info(intersection,
				       cl_intersection,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(intersection, init_args(2, cl_intersection))).
*/
/*
 optional nreverse: not required by CLtL
*/
/*
#+(or WAM-CL ECL) 
(defun nintersection (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive INTERSECTION.  Only LIST1 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last nil))
       first)
    (when (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:33391 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nintersection,[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive INTERSECTION.  Only LIST1 may be destroyed."),[do,[[x,list1,[cdr,x]],[first],[last]],[[null,x],[when,last,[rplacd,last,[]]],first],[when,[member1,[car,x],list2,test,'test-not',key],[if,last,[rplacd,last,x],[setq,first,x]],[setq,last,x]]]]).
doc: doc_string(nintersection,
	      _109681354,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive INTERSECTION.  Only LIST1 may be destroyed.").

wl:lambda_def(defun, nintersection, cl_nintersection, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [first], [last]], [[null, sys_x], [when, last, [rplacd, last, []]], first], [when, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [if, last, [rplacd, last, sys_x], [setq, first, sys_x]], [setq, last, sys_x]]]]).
wl:arglist_info(nintersection, cl_nintersection, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_nintersection).

/*

### Compiled:  `CL:NINTERSECTION` 
*/
cl_nintersection(List1_In, List2_In, RestNKeys, FnResult) :-
	Env91=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env91, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([first], []), bv([last], [])|Env91],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_15), get_var(AEnv, sys_x, IFTEST54), (IFTEST54==[]->get_var(AEnv, last, IFTEST59), (IFTEST59\==[]->get_var(AEnv, last, Last_Get62), cl_rplacd(Last_Get62, [], TrueResult63), _109894130=TrueResult63;_109894130=[]), get_var(AEnv, first, RetResult57), throw(block_exit([], RetResult57)), _TBResult=ThrowResult58;get_var(AEnv, sys_x, X_Get68), cl_car(X_Get68, Member1_Param), get_var(AEnv, sys_list2, List2_Get69), get_var(AEnv, sys_test_not, Test_not_Get71), get_var(AEnv, test, Test_Get70), get_var(AEnv, key, Key_Get72), f_sys_member1(Member1_Param, List2_Get69, Test_Get70, Test_not_Get71, Key_Get72, IFTEST66), (IFTEST66\==[]->get_var(AEnv, last, IFTEST73), (IFTEST73\==[]->get_var(AEnv, last, Last_Get76), get_var(AEnv, sys_x, X_Get77), cl_rplacd(Last_Get76, X_Get77, TrueResult80), _109927932=TrueResult80;get_var(AEnv, sys_x, X_Get79), set_var(AEnv, first, X_Get79), _109927932=X_Get79), get_var(AEnv, sys_x, X_Get82), set_var(AEnv, last, X_Get82), _109915310=X_Get82;_109915310=[]), get_var(AEnv, sys_x, X_Get84), cl_cdr(X_Get84, X), set_var(AEnv, sys_x, X), goto(do_label_15, AEnv), _TBResult=_GORES85)),
					
					[ addr(addr_tagbody_15_do_label_15,
					       do_label_15,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, last, IFTEST23), (IFTEST23\==[]->get_var(AEnv, last, Last_Get26), cl_rplacd(Last_Get26, [], Rplacd_Ret), _110036308=Rplacd_Ret;_110036308=[]), get_var(AEnv, first, Get_var_Ret), throw(block_exit([], Get_var_Ret)), _110036350=ThrowResult;get_var(AEnv, sys_x, X_Get32), cl_car(X_Get32, Member1_Param94), get_var(AEnv, sys_list2, Get_var_Ret97), get_var(AEnv, sys_test_not, Get_var_Ret98), get_var(AEnv, test, Get_var_Ret99), get_var(AEnv, key, Get_var_Ret100), f_sys_member1(Member1_Param94, Get_var_Ret97, Get_var_Ret99, Get_var_Ret98, Get_var_Ret100, IFTEST30), (IFTEST30\==[]->get_var(AEnv, last, IFTEST37), (IFTEST37\==[]->get_var(AEnv, last, Last_Get40), get_var(AEnv, sys_x, X_Get41), cl_rplacd(Last_Get40, X_Get41, TrueResult44), _110036660=TrueResult44;get_var(AEnv, sys_x, X_Get43), set_var(AEnv, first, X_Get43), _110036660=X_Get43), get_var(AEnv, sys_x, X_Get46), set_var(AEnv, last, X_Get46), _110036756=X_Get46;_110036756=[]), get_var(AEnv, sys_x, X_Get48), cl_cdr(X_Get48, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_15, AEnv), _110036350=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(nintersection, FnResult),
	      true).
:- set_opv(cl_nintersection, classof, claz_function),
   set_opv(nintersection, compile_as, kw_function),
   set_opv(nintersection, function, cl_nintersection),
   DefunResult=nintersection.
/*
:- side_effect(assert_lsp(nintersection,
			  doc_string(nintersection,
				     _109681354,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive INTERSECTION.  Only LIST1 may be destroyed."))).
*/
/*
:- side_effect(assert_lsp(nintersection,
			  lambda_def(defun,
				     nintersection,
				     cl_nintersection,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [first],
					   [last]
					 ],
					 
					 [ [null, sys_x],
					   [when, last, [rplacd, last, []]],
					   first
					 ],
					 
					 [ when,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   
					   [ if,
					     last,
					     [rplacd, last, sys_x],
					     [setq, first, sys_x]
					   ],
					   [setq, last, sys_x]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nintersection,
			  arglist_info(nintersection,
				       cl_nintersection,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nintersection, init_args(2, cl_nintersection))).
*/
/*
#+(or WAM-CL ECL) 
(defun set-difference (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2."
  (do ((x list1 (cdr x))
       (ans))
      ((null x) (nreverse ans))
    (unless (member1 (car x) list2 test test-not key)
      (push (car x) ans))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:33867 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'set-difference',[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2."),[do,[[x,list1,[cdr,x]],[ans]],[[null,x],[nreverse,ans]],[unless,[member1,[car,x],list2,test,'test-not',key],[push,[car,x],ans]]]]).
doc: doc_string(set_difference,
	      _112084354,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2.").

wl:lambda_def(defun, set_difference, cl_set_difference, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [sys_ans]], [[null, sys_x], [nreverse, sys_ans]], [unless, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [push, [car, sys_x], sys_ans]]]]).
wl:arglist_info(set_difference, cl_set_difference, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_set_difference).

/*

### Compiled:  `CL:SET-DIFFERENCE` 
*/
cl_set_difference(List1_In, List2_In, RestNKeys, FnResult) :-
	Env63=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env63, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([sys_ans], [])|Env63],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_16), get_var(AEnv, sys_x, IFTEST40), (IFTEST40==[]->get_var(AEnv, sys_ans, Ans_Get45), cl_nreverse(Ans_Get45, RetResult43), throw(block_exit([], RetResult43)), _TBResult=ThrowResult44;get_var(AEnv, sys_x, X_Get49), cl_car(X_Get49, Member1_Param), get_var(AEnv, sys_list2, List2_Get50), get_var(AEnv, sys_test_not, Test_not_Get52), get_var(AEnv, test, Test_Get51), get_var(AEnv, key, Key_Get53), f_sys_member1(Member1_Param, List2_Get50, Test_Get51, Test_not_Get52, Key_Get53, IFTEST47), (IFTEST47\==[]->_112230234=[];cl_push([car, sys_x], sys_ans, ElseResult54), _112230234=ElseResult54), get_var(AEnv, sys_x, X_Get56), cl_cdr(X_Get56, X), set_var(AEnv, sys_x, X), goto(do_label_16, AEnv), _TBResult=_GORES57)),
					
					[ addr(addr_tagbody_16_do_label_16,
					       do_label_16,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, sys_ans, Nreverse_Param), cl_nreverse(Nreverse_Param, Nreverse_Ret), throw(block_exit([], Nreverse_Ret)), _112301460=ThrowResult;get_var(AEnv, sys_x, X_Get27), cl_car(X_Get27, Member1_Param67), get_var(AEnv, sys_list2, Get_var_Ret), get_var(AEnv, sys_test_not, Get_var_Ret70), get_var(AEnv, test, Get_var_Ret71), get_var(AEnv, key, Get_var_Ret72), f_sys_member1(Member1_Param67, Get_var_Ret, Get_var_Ret71, Get_var_Ret70, Get_var_Ret72, IFTEST25), (IFTEST25\==[]->_112301634=[];cl_push([car, sys_x], sys_ans, Push_Ret), _112301634=Push_Ret), get_var(AEnv, sys_x, X_Get34), cl_cdr(X_Get34, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_16, AEnv), _112301460=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(set_difference, FnResult),
	      true).
:- set_opv(cl_set_difference, classof, claz_function),
   set_opv(set_difference, compile_as, kw_function),
   set_opv(set_difference, function, cl_set_difference),
   DefunResult=set_difference.
/*
:- side_effect(assert_lsp(set_difference,
			  doc_string(set_difference,
				     _112084354,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2."))).
*/
/*
:- side_effect(assert_lsp(set_difference,
			  lambda_def(defun,
				     set_difference,
				     cl_set_difference,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [sys_ans]
					 ],
					 [[null, sys_x], [nreverse, sys_ans]],
					 
					 [ unless,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   [push, [car, sys_x], sys_ans]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(set_difference,
			  arglist_info(set_difference,
				       cl_set_difference,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(set_difference, init_args(2, cl_set_difference))).
*/
/*
#+(or WAM-CL ECL) 
(defun nset-difference (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-DIFFERENCE.  Only LIST1 may be destroyed."
  (do ((x list1 (cdr x))
       (first) (last))
      ((null x)
       (when last (rplacd last nil))
       first)
    (unless (member1 (car x) list2 test test-not key)
      (if last
          (rplacd last x)
          (setq first x))
      (setq last x))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:34255 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'nset-difference',[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-DIFFERENCE.  Only LIST1 may be destroyed."),[do,[[x,list1,[cdr,x]],[first],[last]],[[null,x],[when,last,[rplacd,last,[]]],first],[unless,[member1,[car,x],list2,test,'test-not',key],[if,last,[rplacd,last,x],[setq,first,x]],[setq,last,x]]]]).
doc: doc_string(nset_difference,
	      _113960992,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-DIFFERENCE.  Only LIST1 may be destroyed.").

wl:lambda_def(defun, nset_difference, cl_nset_difference, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_x, sys_list1, [cdr, sys_x]], [first], [last]], [[null, sys_x], [when, last, [rplacd, last, []]], first], [unless, [sys_member1, [car, sys_x], sys_list2, test, sys_test_not, key], [if, last, [rplacd, last, sys_x], [setq, first, sys_x]], [setq, last, sys_x]]]]).
wl:arglist_info(nset_difference, cl_nset_difference, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_nset_difference).

/*

### Compiled:  `CL:NSET-DIFFERENCE` 
*/
cl_nset_difference(List1_In, List2_In, RestNKeys, FnResult) :-
	Env91=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env91, sys_list1, List1_Get),
		AEnv=[bv(sys_x, List1_Get), bv([first], []), bv([last], [])|Env91],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_17), get_var(AEnv, sys_x, IFTEST54), (IFTEST54==[]->get_var(AEnv, last, IFTEST59), (IFTEST59\==[]->get_var(AEnv, last, Last_Get62), cl_rplacd(Last_Get62, [], TrueResult63), _114173768=TrueResult63;_114173768=[]), get_var(AEnv, first, RetResult57), throw(block_exit([], RetResult57)), _TBResult=ThrowResult58;get_var(AEnv, sys_x, X_Get68), cl_car(X_Get68, Member1_Param), get_var(AEnv, sys_list2, List2_Get69), get_var(AEnv, sys_test_not, Test_not_Get71), get_var(AEnv, test, Test_Get70), get_var(AEnv, key, Key_Get72), f_sys_member1(Member1_Param, List2_Get69, Test_Get70, Test_not_Get71, Key_Get72, IFTEST66), (IFTEST66\==[]->_114194948=[];get_var(AEnv, last, IFTEST73), (IFTEST73\==[]->get_var(AEnv, last, Last_Get76), get_var(AEnv, sys_x, X_Get77), cl_rplacd(Last_Get76, X_Get77, TrueResult80), _114207630=TrueResult80;get_var(AEnv, sys_x, X_Get79), set_var(AEnv, first, X_Get79), _114207630=X_Get79), get_var(AEnv, sys_x, X_Get82), set_var(AEnv, last, X_Get82), _114194948=X_Get82), get_var(AEnv, sys_x, X_Get84), cl_cdr(X_Get84, X), set_var(AEnv, sys_x, X), goto(do_label_17, AEnv), _TBResult=_GORES85)),
					
					[ addr(addr_tagbody_17_do_label_17,
					       do_label_17,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_x, IFTEST), (IFTEST==[]->get_var(AEnv, last, IFTEST23), (IFTEST23\==[]->get_var(AEnv, last, Last_Get26), cl_rplacd(Last_Get26, [], Rplacd_Ret), _114315946=Rplacd_Ret;_114315946=[]), get_var(AEnv, first, Get_var_Ret), throw(block_exit([], Get_var_Ret)), _114315988=ThrowResult;get_var(AEnv, sys_x, X_Get32), cl_car(X_Get32, Member1_Param94), get_var(AEnv, sys_list2, Get_var_Ret97), get_var(AEnv, sys_test_not, Get_var_Ret98), get_var(AEnv, test, Get_var_Ret99), get_var(AEnv, key, Get_var_Ret100), f_sys_member1(Member1_Param94, Get_var_Ret97, Get_var_Ret99, Get_var_Ret98, Get_var_Ret100, IFTEST30), (IFTEST30\==[]->_114316162=[];get_var(AEnv, last, IFTEST37), (IFTEST37\==[]->get_var(AEnv, last, Last_Get40), get_var(AEnv, sys_x, X_Get41), cl_rplacd(Last_Get40, X_Get41, TrueResult44), _114316304=TrueResult44;get_var(AEnv, sys_x, X_Get43), set_var(AEnv, first, X_Get43), _114316304=X_Get43), get_var(AEnv, sys_x, X_Get46), set_var(AEnv, last, X_Get46), _114316162=X_Get46), get_var(AEnv, sys_x, X_Get48), cl_cdr(X_Get48, Cdr_Ret), set_var(AEnv, sys_x, Cdr_Ret), goto(do_label_17, AEnv), _114315988=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(nset_difference, FnResult),
	      true).
:- set_opv(cl_nset_difference, classof, claz_function),
   set_opv(nset_difference, compile_as, kw_function),
   set_opv(nset_difference, function, cl_nset_difference),
   DefunResult=nset_difference.
/*
:- side_effect(assert_lsp(nset_difference,
			  doc_string(nset_difference,
				     _113960992,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-DIFFERENCE.  Only LIST1 may be destroyed."))).
*/
/*
:- side_effect(assert_lsp(nset_difference,
			  lambda_def(defun,
				     nset_difference,
				     cl_nset_difference,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 
					 [ [sys_x, sys_list1, [cdr, sys_x]],
					   [first],
					   [last]
					 ],
					 
					 [ [null, sys_x],
					   [when, last, [rplacd, last, []]],
					   first
					 ],
					 
					 [ unless,
					   
					   [ sys_member1,
					     [car, sys_x],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   
					   [ if,
					     last,
					     [rplacd, last, sys_x],
					     [setq, first, sys_x]
					   ],
					   [setq, last, sys_x]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nset_difference,
			  arglist_info(nset_difference,
				       cl_nset_difference,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nset_difference, init_args(2, cl_nset_difference))).
*/
/*
#+(or WAM-CL ECL) 
(defun swap-args (f)
  ; (declare (c-local))
  (and f #'(lambda (x y) (funcall f y x))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:34737 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'swap-args',[f],[and,f,function([lambda,[x,y],[funcall,f,y,x]])]]).
wl:lambda_def(defun, sys_swap_args, f_sys_swap_args, [sys_f], [[and, sys_f, function([lambda, [sys_x, sys_y], [funcall, sys_f, sys_y, sys_x]])]]).
wl:arglist_info(sys_swap_args, f_sys_swap_args, [sys_f], arginfo{all:[sys_f], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_f], opt:0, req:[sys_f], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_swap_args).

/*

### Compiled:  `SYS::SWAP-ARGS` 
*/
f_sys_swap_args(In, FnResult) :-
	Env15=[bv(sys_f, In)|Env],
	global_env(Env),
	catch(( get_var(Env15, sys_f, IFTEST),
		(   IFTEST\==[]
		->  _116354354=closure(LEnv, LResult, [sys_x, sys_y],  (get_var(LEnv, sys_f, Get7), get_var(LEnv, sys_x, X_Get), get_var(LEnv, sys_y, Y_Get), cl_apply(Get7, [Y_Get, X_Get], LResult)))
		;   _116354354=[]
		),
		_116354354=FnResult
	      ),
	      block_exit(sys_swap_args, FnResult),
	      true).
:- set_opv(f_sys_swap_args, classof, claz_function),
   set_opv(sys_swap_args, compile_as, kw_function),
   set_opv(sys_swap_args, function, f_sys_swap_args),
   DefunResult=sys_swap_args.
/*
:- side_effect(assert_lsp(sys_swap_args,
			  lambda_def(defun,
				     sys_swap_args,
				     f_sys_swap_args,
				     [sys_f],
				     
				     [ 
				       [ and,
					 sys_f,
					 function(
						  [ lambda,
						    [sys_x, sys_y],
						    
						    [ funcall,
						      sys_f,
						      sys_y,
						      sys_x
						    ]
						  ]).
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_swap_args,
			  arglist_info(sys_swap_args,
				       f_sys_swap_args,
				       [sys_f],
				       arginfo{ all:[sys_f],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_f],
						opt:0,
						req:[sys_f],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_swap_args, init_args(exact_only, f_sys_swap_args))).
*/
/*
 (declare (c-local))
*/
/*
#+(or WAM-CL ECL) 
(defun set-exclusive-or (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns, as a list, those elements of LIST1 that are not elements of LIST2 and
those elements of LIST2 that are not elements of LIST1."
  (nconc (set-difference list1 list2 :test test :test-not test-not :key key)
         (set-difference list2 list1 :test (swap-args test) :test-not (swap-args test-not) :key key)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:34853 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'set-exclusive-or',[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2 and\r\nthose elements of LIST2 that are not elements of LIST1."),[nconc,['set-difference',list1,list2,':test',test,':test-not','test-not',':key',key],['set-difference',list2,list1,':test',['swap-args',test],':test-not',['swap-args','test-not'],':key',key]]]).
doc: doc_string(set_exclusive_or,
	      _117239964,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2 and\r\nthose elements of LIST2 that are not elements of LIST1.").

wl:lambda_def(defun, set_exclusive_or, cl_set_exclusive_or, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[nconc, [set_difference, sys_list1, sys_list2, kw_test, test, kw_test_not, sys_test_not, kw_key, key], [set_difference, sys_list2, sys_list1, kw_test, [sys_swap_args, test], kw_test_not, [sys_swap_args, sys_test_not], kw_key, key]]]).
wl:arglist_info(set_exclusive_or, cl_set_exclusive_or, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_set_exclusive_or).

/*

### Compiled:  `CL:SET-EXCLUSIVE-OR` 
*/
cl_set_exclusive_or(List1_In, List2_In, RestNKeys, FnResult) :-
	Env24=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env24, sys_list1, List1_Get),
		get_var(Env24, sys_list2, List2_Get),
		get_var(Env24, sys_test_not, Test_not_Get),
		get_var(Env24, test, Test_Get),
		get_var(Env24, key, Key_Get),
		cl_set_difference(List1_Get,
				  List2_Get,
				  
				  [ kw_test,
				    Test_Get,
				    kw_test_not,
				    Test_not_Get,
				    kw_key,
				    Key_Get
				  ],
				  Set_difference_Ret),
		get_var(Env24, sys_list1, List1_Get18),
		get_var(Env24, sys_list2, List2_Get17),
		get_var(Env24, test, Test_Get19),
		f_sys_swap_args(Test_Get19, Swap_args_Ret),
		get_var(Env24, sys_test_not, Test_not_Get20),
		f_sys_swap_args(Test_not_Get20, Swap_args_Ret27),
		get_var(Env24, key, Key_Get21),
		cl_set_difference(List2_Get17,
				  List1_Get18,
				  
				  [ kw_test,
				    Swap_args_Ret,
				    kw_test_not,
				    Swap_args_Ret27,
				    kw_key,
				    Key_Get21
				  ],
				  Set_difference_Ret28),
		cl_nconc([Set_difference_Ret, Set_difference_Ret28], Nconc_Ret),
		Nconc_Ret=FnResult
	      ),
	      block_exit(set_exclusive_or, FnResult),
	      true).
:- set_opv(cl_set_exclusive_or, classof, claz_function),
   set_opv(set_exclusive_or, compile_as, kw_function),
   set_opv(set_exclusive_or, function, cl_set_exclusive_or),
   DefunResult=set_exclusive_or.
/*
:- side_effect(assert_lsp(set_exclusive_or,
			  doc_string(set_exclusive_or,
				     _117239964,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns, as a list, those elements of LIST1 that are not elements of LIST2 and\r\nthose elements of LIST2 that are not elements of LIST1."))).
*/
/*
:- side_effect(assert_lsp(set_exclusive_or,
			  lambda_def(defun,
				     set_exclusive_or,
				     cl_set_exclusive_or,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ nconc,
					 
					 [ set_difference,
					   sys_list1,
					   sys_list2,
					   kw_test,
					   test,
					   kw_test_not,
					   sys_test_not,
					   kw_key,
					   key
					 ],
					 
					 [ set_difference,
					   sys_list2,
					   sys_list1,
					   kw_test,
					   [sys_swap_args, test],
					   kw_test_not,
					   [sys_swap_args, sys_test_not],
					   kw_key,
					   key
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(set_exclusive_or,
			  arglist_info(set_exclusive_or,
				       cl_set_exclusive_or,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(set_exclusive_or, init_args(2, cl_set_exclusive_or))).
*/
/*
#+(or WAM-CL ECL) 
(defun nset-exclusive-or (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Destructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed."
  (nconc (set-difference list1 list2 :test test :test-not test-not :key key)
         (nset-difference list2 list1 :test (swap-args test) :test-not (swap-args test-not) :key key)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:35327 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'nset-exclusive-or',[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed."),[nconc,['set-difference',list1,list2,':test',test,':test-not','test-not',':key',key],['nset-difference',list2,list1,':test',['swap-args',test],':test-not',['swap-args','test-not'],':key',key]]]).
doc: doc_string(nset_exclusive_or,
	      _118498160,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed.").

wl:lambda_def(defun, nset_exclusive_or, cl_nset_exclusive_or, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[nconc, [set_difference, sys_list1, sys_list2, kw_test, test, kw_test_not, sys_test_not, kw_key, key], [nset_difference, sys_list2, sys_list1, kw_test, [sys_swap_args, test], kw_test_not, [sys_swap_args, sys_test_not], kw_key, key]]]).
wl:arglist_info(nset_exclusive_or, cl_nset_exclusive_or, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_nset_exclusive_or).

/*

### Compiled:  `CL:NSET-EXCLUSIVE-OR` 
*/
cl_nset_exclusive_or(List1_In, List2_In, RestNKeys, FnResult) :-
	Env24=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env24, sys_list1, List1_Get),
		get_var(Env24, sys_list2, List2_Get),
		get_var(Env24, sys_test_not, Test_not_Get),
		get_var(Env24, test, Test_Get),
		get_var(Env24, key, Key_Get),
		cl_set_difference(List1_Get,
				  List2_Get,
				  
				  [ kw_test,
				    Test_Get,
				    kw_test_not,
				    Test_not_Get,
				    kw_key,
				    Key_Get
				  ],
				  Set_difference_Ret),
		get_var(Env24, sys_list1, List1_Get18),
		get_var(Env24, sys_list2, List2_Get17),
		get_var(Env24, test, Test_Get19),
		f_sys_swap_args(Test_Get19, Swap_args_Ret),
		get_var(Env24, sys_test_not, Test_not_Get20),
		f_sys_swap_args(Test_not_Get20, Swap_args_Ret27),
		get_var(Env24, key, Key_Get21),
		cl_nset_difference(List2_Get17,
				   List1_Get18,
				   
				   [ kw_test,
				     Swap_args_Ret,
				     kw_test_not,
				     Swap_args_Ret27,
				     kw_key,
				     Key_Get21
				   ],
				   Nset_difference_Ret),
		cl_nconc([Set_difference_Ret, Nset_difference_Ret], Nconc_Ret),
		Nconc_Ret=FnResult
	      ),
	      block_exit(nset_exclusive_or, FnResult),
	      true).
:- set_opv(cl_nset_exclusive_or, classof, claz_function),
   set_opv(nset_exclusive_or, compile_as, kw_function),
   set_opv(nset_exclusive_or, function, cl_nset_exclusive_or),
   DefunResult=nset_exclusive_or.
/*
:- side_effect(assert_lsp(nset_exclusive_or,
			  doc_string(nset_exclusive_or,
				     _118498160,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nDestructive SET-EXCLUSIVE-OR.  Both LIST1 and LIST2 may be destroyed."))).
*/
/*
:- side_effect(assert_lsp(nset_exclusive_or,
			  lambda_def(defun,
				     nset_exclusive_or,
				     cl_nset_exclusive_or,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ nconc,
					 
					 [ set_difference,
					   sys_list1,
					   sys_list2,
					   kw_test,
					   test,
					   kw_test_not,
					   sys_test_not,
					   kw_key,
					   key
					 ],
					 
					 [ nset_difference,
					   sys_list2,
					   sys_list1,
					   kw_test,
					   [sys_swap_args, test],
					   kw_test_not,
					   [sys_swap_args, sys_test_not],
					   kw_key,
					   key
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nset_exclusive_or,
			  arglist_info(nset_exclusive_or,
				       cl_nset_exclusive_or,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nset_exclusive_or, init_args(2, cl_nset_exclusive_or))).
*/
/*
#+(or WAM-CL ECL) 
(defun subsetp (list1 list2 &key test test-not key)
  "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)
Returns T if every element of LIST1 is also an element of LIST2.  Returns NIL
otherwise."
  (do ((l list1 (cdr l)))
      ((null l) t)
    (unless (member1 (car l) list2 test test-not key)
      (return nil))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:35737 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,subsetp,[list1,list2,'&key',test,'test-not',key],'$STRING'("Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns T if every element of LIST1 is also an element of LIST2.  Returns NIL\r\notherwise."),[do,[[l,list1,[cdr,l]]],[[null,l],t],[unless,[member1,[car,l],list2,test,'test-not',key],[return,[]]]]]).
doc: doc_string(subsetp,
	      _119750964,
	      function,
	      "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns T if every element of LIST1 is also an element of LIST2.  Returns NIL\r\notherwise.").

wl:lambda_def(defun, subsetp, cl_subsetp, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], [[do, [[sys_l, sys_list1, [cdr, sys_l]]], [[null, sys_l], t], [unless, [sys_member1, [car, sys_l], sys_list2, test, sys_test_not, key], [return, []]]]]).
wl:arglist_info(subsetp, cl_subsetp, [sys_list1, sys_list2, c38_key, test, sys_test_not, key], arginfo{all:[sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[test, sys_test_not, key], names:[sys_list1, sys_list2, test, sys_test_not, key], opt:0, req:[sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_subsetp).

/*

### Compiled:  `CL:SUBSETP` 
*/
cl_subsetp(List1_In, List2_In, RestNKeys, FnResult) :-
	Env65=[bv(sys_list1, List1_In), bv(sys_list2, List2_In), bv(test, Test_In), bv(sys_test_not, Test_not_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, test, test, Test_In, []=Test_In, Test_P),
	get_kw(Env,
	       RestNKeys,
	       sys_test_not,
	       sys_test_not,
	       Test_not_In,
	       []=Test_not_In,
	       Test_not_P),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env65, sys_list1, List1_Get),
		AEnv=[bv(sys_l, List1_Get)|Env65],
		catch(( call_addr_block(AEnv,
					(push_label(do_label_18), get_var(AEnv, sys_l, IFTEST41), (IFTEST41==[]->throw(block_exit([], t)), _TBResult=ThrowResult45;get_var(AEnv, sys_l, L_Get49), cl_car(L_Get49, Member1_Param), get_var(AEnv, sys_list2, List2_Get50), get_var(AEnv, sys_test_not, Test_not_Get52), get_var(AEnv, test, Test_Get51), get_var(AEnv, key, Key_Get53), f_sys_member1(Member1_Param, List2_Get50, Test_Get51, Test_not_Get52, Key_Get53, IFTEST47), (IFTEST47\==[]->_119867634=[];throw(block_exit([], [])), _119867634=ThrowResult55), get_var(AEnv, sys_l, L_Get58), cl_cdr(L_Get58, L), set_var(AEnv, sys_l, L), goto(do_label_18, AEnv), _TBResult=_GORES59)),
					
					[ addr(addr_tagbody_18_do_label_18,
					       do_label_18,
					       '$unused',
					       AEnv,
					       (get_var(AEnv, sys_l, IFTEST), (IFTEST==[]->throw(block_exit([], t)), _119932716=ThrowResult;get_var(AEnv, sys_l, L_Get26), cl_car(L_Get26, Member1_Param68), get_var(AEnv, sys_list2, Get_var_Ret), get_var(AEnv, sys_test_not, Get_var_Ret70), get_var(AEnv, test, Get_var_Ret71), get_var(AEnv, key, Get_var_Ret72), f_sys_member1(Member1_Param68, Get_var_Ret, Get_var_Ret71, Get_var_Ret70, Get_var_Ret72, IFTEST24), (IFTEST24\==[]->_119932890=[];throw(block_exit([], [])), _119932890=ThrowResult32), get_var(AEnv, sys_l, L_Get35), cl_cdr(L_Get35, Cdr_Ret), set_var(AEnv, sys_l, Cdr_Ret), goto(do_label_18, AEnv), _119932716=_GORES)))
					]),
			[]=LetResult
		      ),
		      block_exit([], LetResult),
		      true),
		LetResult=FnResult
	      ),
	      block_exit(subsetp, FnResult),
	      true).
:- set_opv(cl_subsetp, classof, claz_function),
   set_opv(subsetp, compile_as, kw_function),
   set_opv(subsetp, function, cl_subsetp),
   DefunResult=subsetp.
/*
:- side_effect(assert_lsp(subsetp,
			  doc_string(subsetp,
				     _119750964,
				     function,
				     "Args: (list1 list2 &key (key #'identity) (test #'eql) test-not)\r\nReturns T if every element of LIST1 is also an element of LIST2.  Returns NIL\r\notherwise."))).
*/
/*
:- side_effect(assert_lsp(subsetp,
			  lambda_def(defun,
				     subsetp,
				     cl_subsetp,
				     
				     [ sys_list1,
				       sys_list2,
				       c38_key,
				       test,
				       sys_test_not,
				       key
				     ],
				     
				     [ 
				       [ do,
					 [[sys_l, sys_list1, [cdr, sys_l]]],
					 [[null, sys_l], t],
					 
					 [ unless,
					   
					   [ sys_member1,
					     [car, sys_l],
					     sys_list2,
					     test,
					     sys_test_not,
					     key
					   ],
					   [return, []]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(subsetp,
			  arglist_info(subsetp,
				       cl_subsetp,
				       
				       [ sys_list1,
					 sys_list2,
					 c38_key,
					 test,
					 sys_test_not,
					 key
				       ],
				       arginfo{ all:[sys_list1, sys_list2],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[test, sys_test_not, key],
						names:
						      [ sys_list1,
							sys_list2,
							test,
							sys_test_not,
							key
						      ],
						opt:0,
						req:[sys_list1, sys_list2],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(subsetp, init_args(2, cl_subsetp))).
*/
/*
#+(or WAM-CL ECL) 
(defun rassoc-if (test alist &key key)
  "Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no
such pair exists."
  (rassoc test alist :test #'funcall :key key))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:36099 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'rassoc-if',[test,alist,'&key',key],'$STRING'("Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no\r\nsuch pair exists."),[rassoc,test,alist,':test',function(funcall),':key',key]]).
doc: doc_string(rassoc_if,
	      _121452144,
	      function,
	      "Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no\r\nsuch pair exists.").

wl:lambda_def(defun, rassoc_if, cl_rassoc_if, [test, sys_alist, c38_key, key], [[rassoc, test, sys_alist, kw_test, function(funcall), kw_key, key]]).
wl:arglist_info(rassoc_if, cl_rassoc_if, [test, sys_alist, c38_key, key], arginfo{all:[test, sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, sys_alist, key], opt:0, req:[test, sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_rassoc_if).

/*

### Compiled:  `CL:RASSOC-IF` 
*/
cl_rassoc_if(Test_In, Alist_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(sys_alist, Alist_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, sys_alist, Alist_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_rassoc(Test_Get,
			  Alist_Get,
			  [kw_test, cl_funcall, kw_key, Key_Get],
			  Rassoc_Ret),
		Rassoc_Ret=FnResult
	      ),
	      block_exit(rassoc_if, FnResult),
	      true).
:- set_opv(cl_rassoc_if, classof, claz_function),
   set_opv(rassoc_if, compile_as, kw_function),
   set_opv(rassoc_if, function, cl_rassoc_if),
   DefunResult=rassoc_if.
/*
:- side_effect(assert_lsp(rassoc_if,
			  doc_string(rassoc_if,
				     _121452144,
				     function,
				     "Returns the first pair in ALIST whose cdr satisfies TEST. Returns NIL if no\r\nsuch pair exists."))).
*/
/*
:- side_effect(assert_lsp(rassoc_if,
			  lambda_def(defun,
				     rassoc_if,
				     cl_rassoc_if,
				     [test, sys_alist, c38_key, key],
				     
				     [ 
				       [ rassoc,
					 test,
					 sys_alist,
					 kw_test,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(rassoc_if,
			  arglist_info(rassoc_if,
				       cl_rassoc_if,
				       [test, sys_alist, c38_key, key],
				       arginfo{ all:[test, sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, sys_alist, key],
						opt:0,
						req:[test, sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(rassoc_if, init_args(2, cl_rassoc_if))).
*/
/*
#+(or WAM-CL ECL) 
(defun rassoc-if-not (test alist &key key)
  "Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL
if no such pair exists."
  (rassoc test alist :test-not #'funcall :key key))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:36310 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'rassoc-if-not',[test,alist,'&key',key],'$STRING'("Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL\r\nif no such pair exists."),[rassoc,test,alist,':test-not',function(funcall),':key',key]]).
doc: doc_string(rassoc_if_not,
	      _122352040,
	      function,
	      "Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL\r\nif no such pair exists.").

wl:lambda_def(defun, rassoc_if_not, cl_rassoc_if_not, [test, sys_alist, c38_key, key], [[rassoc, test, sys_alist, kw_test_not, function(funcall), kw_key, key]]).
wl:arglist_info(rassoc_if_not, cl_rassoc_if_not, [test, sys_alist, c38_key, key], arginfo{all:[test, sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, sys_alist, key], opt:0, req:[test, sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_rassoc_if_not).

/*

### Compiled:  `CL:RASSOC-IF-NOT` 
*/
cl_rassoc_if_not(Test_In, Alist_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(sys_alist, Alist_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, sys_alist, Alist_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_rassoc(Test_Get,
			  Alist_Get,
			  [kw_test_not, cl_funcall, kw_key, Key_Get],
			  Rassoc_Ret),
		Rassoc_Ret=FnResult
	      ),
	      block_exit(rassoc_if_not, FnResult),
	      true).
:- set_opv(cl_rassoc_if_not, classof, claz_function),
   set_opv(rassoc_if_not, compile_as, kw_function),
   set_opv(rassoc_if_not, function, cl_rassoc_if_not),
   DefunResult=rassoc_if_not.
/*
:- side_effect(assert_lsp(rassoc_if_not,
			  doc_string(rassoc_if_not,
				     _122352040,
				     function,
				     "Returns the first pair in ALIST whose cdr does not satisfy TEST.  Returns NIL\r\nif no such pair exists."))).
*/
/*
:- side_effect(assert_lsp(rassoc_if_not,
			  lambda_def(defun,
				     rassoc_if_not,
				     cl_rassoc_if_not,
				     [test, sys_alist, c38_key, key],
				     
				     [ 
				       [ rassoc,
					 test,
					 sys_alist,
					 kw_test_not,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(rassoc_if_not,
			  arglist_info(rassoc_if_not,
				       cl_rassoc_if_not,
				       [test, sys_alist, c38_key, key],
				       arginfo{ all:[test, sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, sys_alist, key],
						opt:0,
						req:[test, sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(rassoc_if_not, init_args(2, cl_rassoc_if_not))).
*/
/*
#+(or WAM-CL ECL) 
(defun assoc-if (test alist &key key)
  "Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no
such pair exists."
  (assoc test alist :test #'funcall :key key))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:36539 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'assoc-if',[test,alist,'&key',key],'$STRING'("Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no\r\nsuch pair exists."),[assoc,test,alist,':test',function(funcall),':key',key]]).
doc: doc_string(assoc_if,
	      _123249408,
	      function,
	      "Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no\r\nsuch pair exists.").

wl:lambda_def(defun, assoc_if, cl_assoc_if, [test, sys_alist, c38_key, key], [[assoc, test, sys_alist, kw_test, function(funcall), kw_key, key]]).
wl:arglist_info(assoc_if, cl_assoc_if, [test, sys_alist, c38_key, key], arginfo{all:[test, sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, sys_alist, key], opt:0, req:[test, sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_assoc_if).

/*

### Compiled:  `CL:ASSOC-IF` 
*/
cl_assoc_if(Test_In, Alist_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(sys_alist, Alist_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, sys_alist, Alist_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_assoc(Test_Get,
			 Alist_Get,
			 [kw_test, cl_funcall, kw_key, Key_Get],
			 Assoc_Ret),
		Assoc_Ret=FnResult
	      ),
	      block_exit(assoc_if, FnResult),
	      true).
:- set_opv(cl_assoc_if, classof, claz_function),
   set_opv(assoc_if, compile_as, kw_function),
   set_opv(assoc_if, function, cl_assoc_if),
   DefunResult=assoc_if.
/*
:- side_effect(assert_lsp(assoc_if,
			  doc_string(assoc_if,
				     _123249408,
				     function,
				     "Returns the first pair in ALIST whose car satisfies TEST.  Returns NIL if no\r\nsuch pair exists."))).
*/
/*
:- side_effect(assert_lsp(assoc_if,
			  lambda_def(defun,
				     assoc_if,
				     cl_assoc_if,
				     [test, sys_alist, c38_key, key],
				     
				     [ 
				       [ assoc,
					 test,
					 sys_alist,
					 kw_test,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(assoc_if,
			  arglist_info(assoc_if,
				       cl_assoc_if,
				       [test, sys_alist, c38_key, key],
				       arginfo{ all:[test, sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, sys_alist, key],
						opt:0,
						req:[test, sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(assoc_if, init_args(2, cl_assoc_if))).
*/
/*
#+(or WAM-CL ECL) 
(defun assoc-if-not (test alist &key key)
  "Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL
if no such pair exists."
  (assoc test alist :test-not #'funcall :key key))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:36749 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'assoc-if-not',[test,alist,'&key',key],'$STRING'("Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL\r\nif no such pair exists."),[assoc,test,alist,':test-not',function(funcall),':key',key]]).
doc: doc_string(assoc_if_not,
	      _124146406,
	      function,
	      "Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL\r\nif no such pair exists.").

wl:lambda_def(defun, assoc_if_not, cl_assoc_if_not, [test, sys_alist, c38_key, key], [[assoc, test, sys_alist, kw_test_not, function(funcall), kw_key, key]]).
wl:arglist_info(assoc_if_not, cl_assoc_if_not, [test, sys_alist, c38_key, key], arginfo{all:[test, sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, sys_alist, key], opt:0, req:[test, sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_assoc_if_not).

/*

### Compiled:  `CL:ASSOC-IF-NOT` 
*/
cl_assoc_if_not(Test_In, Alist_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(sys_alist, Alist_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, sys_alist, Alist_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_assoc(Test_Get,
			 Alist_Get,
			 [kw_test_not, cl_funcall, kw_key, Key_Get],
			 Assoc_Ret),
		Assoc_Ret=FnResult
	      ),
	      block_exit(assoc_if_not, FnResult),
	      true).
:- set_opv(cl_assoc_if_not, classof, claz_function),
   set_opv(assoc_if_not, compile_as, kw_function),
   set_opv(assoc_if_not, function, cl_assoc_if_not),
   DefunResult=assoc_if_not.
/*
:- side_effect(assert_lsp(assoc_if_not,
			  doc_string(assoc_if_not,
				     _124146406,
				     function,
				     "Returns the first pair in ALIST whose car does not satisfy TEST.  Returns NIL\r\nif no such pair exists."))).
*/
/*
:- side_effect(assert_lsp(assoc_if_not,
			  lambda_def(defun,
				     assoc_if_not,
				     cl_assoc_if_not,
				     [test, sys_alist, c38_key, key],
				     
				     [ 
				       [ assoc,
					 test,
					 sys_alist,
					 kw_test_not,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(assoc_if_not,
			  arglist_info(assoc_if_not,
				       cl_assoc_if_not,
				       [test, sys_alist, c38_key, key],
				       arginfo{ all:[test, sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, sys_alist, key],
						opt:0,
						req:[test, sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(assoc_if_not, init_args(2, cl_assoc_if_not))).
*/
/*
#+(or WAM-CL ECL) 
(defun member-if (test list &key key)
  "Searches LIST for an element that satisfies TEST.  If found, returns the
sublist of LIST that begins with the element.  If not found, returns NIL."
  (member test list :test #'funcall :key key))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:36976 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'member-if',[test,list,'&key',key],'$STRING'("Searches LIST for an element that satisfies TEST.  If found, returns the\r\nsublist of LIST that begins with the element.  If not found, returns NIL."),[member,test,list,':test',function(funcall),':key',key]]).
doc: doc_string(member_if,
	      _125048608,
	      function,
	      "Searches LIST for an element that satisfies TEST.  If found, returns the\r\nsublist of LIST that begins with the element.  If not found, returns NIL.").

wl:lambda_def(defun, member_if, cl_member_if, [test, list, c38_key, key], [[member, test, list, kw_test, function(funcall), kw_key, key]]).
wl:arglist_info(member_if, cl_member_if, [test, list, c38_key, key], arginfo{all:[test, list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, list, key], opt:0, req:[test, list], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_member_if).

/*

### Compiled:  `CL:MEMBER-IF` 
*/
cl_member_if(Test_In, List_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(list, List_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, list, List_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_member(Test_Get,
			  List_Get,
			  [kw_test, cl_funcall, kw_key, Key_Get],
			  Member_Ret),
		Member_Ret=FnResult
	      ),
	      block_exit(member_if, FnResult),
	      true).
:- set_opv(cl_member_if, classof, claz_function),
   set_opv(member_if, compile_as, kw_function),
   set_opv(member_if, function, cl_member_if),
   DefunResult=member_if.
/*
:- side_effect(assert_lsp(member_if,
			  doc_string(member_if,
				     _125048608,
				     function,
				     "Searches LIST for an element that satisfies TEST.  If found, returns the\r\nsublist of LIST that begins with the element.  If not found, returns NIL."))).
*/
/*
:- side_effect(assert_lsp(member_if,
			  lambda_def(defun,
				     member_if,
				     cl_member_if,
				     [test, list, c38_key, key],
				     
				     [ 
				       [ member,
					 test,
					 list,
					 kw_test,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(member_if,
			  arglist_info(member_if,
				       cl_member_if,
				       [test, list, c38_key, key],
				       arginfo{ all:[test, list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, list, key],
						opt:0,
						req:[test, list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(member_if, init_args(2, cl_member_if))).
*/
/*
#+(or WAM-CL ECL) 
(defun member-if-not (test list &key key)
  "Searches LIST for an element that does not satisfy TEST.  If found, returns
the sublist of LIST that begins with the element.  If not found, returns NIL."
  (member test list :test-not #'funcall :key key))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:37238 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'member-if-not',[test,list,'&key',key],'$STRING'("Searches LIST for an element that does not satisfy TEST.  If found, returns\r\nthe sublist of LIST that begins with the element.  If not found, returns NIL."),[member,test,list,':test-not',function(funcall),':key',key]]).
doc: doc_string(member_if_not,
	      _125949796,
	      function,
	      "Searches LIST for an element that does not satisfy TEST.  If found, returns\r\nthe sublist of LIST that begins with the element.  If not found, returns NIL.").

wl:lambda_def(defun, member_if_not, cl_member_if_not, [test, list, c38_key, key], [[member, test, list, kw_test_not, function(funcall), kw_key, key]]).
wl:arglist_info(member_if_not, cl_member_if_not, [test, list, c38_key, key], arginfo{all:[test, list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[test, list, key], opt:0, req:[test, list], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_member_if_not).

/*

### Compiled:  `CL:MEMBER-IF-NOT` 
*/
cl_member_if_not(Test_In, List_In, RestNKeys, FnResult) :-
	Env13=[bv(test, Test_In), bv(list, List_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env13, list, List_Get),
		get_var(Env13, test, Test_Get),
		get_var(Env13, key, Key_Get),
		cl_member(Test_Get,
			  List_Get,
			  [kw_test_not, cl_funcall, kw_key, Key_Get],
			  Member_Ret),
		Member_Ret=FnResult
	      ),
	      block_exit(member_if_not, FnResult),
	      true).
:- set_opv(cl_member_if_not, classof, claz_function),
   set_opv(member_if_not, compile_as, kw_function),
   set_opv(member_if_not, function, cl_member_if_not),
   DefunResult=member_if_not.
/*
:- side_effect(assert_lsp(member_if_not,
			  doc_string(member_if_not,
				     _125949796,
				     function,
				     "Searches LIST for an element that does not satisfy TEST.  If found, returns\r\nthe sublist of LIST that begins with the element.  If not found, returns NIL."))).
*/
/*
:- side_effect(assert_lsp(member_if_not,
			  lambda_def(defun,
				     member_if_not,
				     cl_member_if_not,
				     [test, list, c38_key, key],
				     
				     [ 
				       [ member,
					 test,
					 list,
					 kw_test_not,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(member_if_not,
			  arglist_info(member_if_not,
				       cl_member_if_not,
				       [test, list, c38_key, key],
				       arginfo{ all:[test, list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:[test, list, key],
						opt:0,
						req:[test, list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(member_if_not, init_args(2, cl_member_if_not))).
*/
/*
#+(or WAM-CL ECL) 
(defun subst-if (new test tree &key key)
  "Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.
The original TREE is not destroyed."
  (subst new test tree :test #'funcall :key key))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:37517 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'subst-if',[new,test,tree,'&key',key],'$STRING'("Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.\r\nThe original TREE is not destroyed."),[subst,new,test,tree,':test',function(funcall),':key',key]]).
doc: doc_string(subst_if,
	      _126844488,
	      function,
	      "Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.\r\nThe original TREE is not destroyed.").

wl:lambda_def(defun, subst_if, cl_subst_if, [sys_new, test, sys_tree, c38_key, key], [[subst, sys_new, test, sys_tree, kw_test, function(funcall), kw_key, key]]).
wl:arglist_info(subst_if, cl_subst_if, [sys_new, test, sys_tree, c38_key, key], arginfo{all:[sys_new, test, sys_tree], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[sys_new, test, sys_tree, key], opt:0, req:[sys_new, test, sys_tree], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_subst_if).

/*

### Compiled:  `CL:SUBST-IF` 
*/
cl_subst_if(New_In, Test_In, Tree_In, RestNKeys, FnResult) :-
	Env15=[bv(sys_new, New_In), bv(test, Test_In), bv(sys_tree, Tree_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env15, sys_new, New_Get),
		get_var(Env15, sys_tree, Tree_Get),
		get_var(Env15, test, Test_Get),
		get_var(Env15, key, Key_Get),
		cl_subst(New_Get,
			 Test_Get,
			 Tree_Get,
			 kw_test,
			 cl_funcall,
			 kw_key,
			 Key_Get,
			 Subst_Ret),
		Subst_Ret=FnResult
	      ),
	      block_exit(subst_if, FnResult),
	      true).
:- set_opv(cl_subst_if, classof, claz_function),
   set_opv(subst_if, compile_as, kw_function),
   set_opv(subst_if, function, cl_subst_if),
   DefunResult=subst_if.
/*
:- side_effect(assert_lsp(subst_if,
			  doc_string(subst_if,
				     _126844488,
				     function,
				     "Substitutes NEW for subtrees of TREE that satisfy TEST and returns the result.\r\nThe original TREE is not destroyed."))).
*/
/*
:- side_effect(assert_lsp(subst_if,
			  lambda_def(defun,
				     subst_if,
				     cl_subst_if,
				     [sys_new, test, sys_tree, c38_key, key],
				     
				     [ 
				       [ subst,
					 sys_new,
					 test,
					 sys_tree,
					 kw_test,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(subst_if,
			  arglist_info(subst_if,
				       cl_subst_if,
				       [sys_new, test, sys_tree, c38_key, key],
				       arginfo{ all:[sys_new, test, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:
						      [ sys_new,
							test,
							sys_tree,
							key
						      ],
						opt:0,
						req:[sys_new, test, sys_tree],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(subst_if, init_args(3, cl_subst_if))).
*/
/*
#+(or WAM-CL ECL) 
(defun subst-if-not (new test tree &key key)
  "Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the
result.  The original TREE is not destroyed."
  (subst new test tree :test-not #'funcall :key key))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:37753 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'subst-if-not',[new,test,tree,'&key',key],'$STRING'("Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the\r\nresult.  The original TREE is not destroyed."),[subst,new,test,tree,':test-not',function(funcall),':key',key]]).
doc: doc_string(subst_if_not,
	      _127774354,
	      function,
	      "Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the\r\nresult.  The original TREE is not destroyed.").

wl:lambda_def(defun, subst_if_not, cl_subst_if_not, [sys_new, test, sys_tree, c38_key, key], [[subst, sys_new, test, sys_tree, kw_test_not, function(funcall), kw_key, key]]).
wl:arglist_info(subst_if_not, cl_subst_if_not, [sys_new, test, sys_tree, c38_key, key], arginfo{all:[sys_new, test, sys_tree], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[sys_new, test, sys_tree, key], opt:0, req:[sys_new, test, sys_tree], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_subst_if_not).

/*

### Compiled:  `CL:SUBST-IF-NOT` 
*/
cl_subst_if_not(New_In, Test_In, Tree_In, RestNKeys, FnResult) :-
	Env15=[bv(sys_new, New_In), bv(test, Test_In), bv(sys_tree, Tree_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env15, sys_new, New_Get),
		get_var(Env15, sys_tree, Tree_Get),
		get_var(Env15, test, Test_Get),
		get_var(Env15, key, Key_Get),
		cl_subst(New_Get,
			 Test_Get,
			 Tree_Get,
			 kw_test_not,
			 cl_funcall,
			 kw_key,
			 Key_Get,
			 Subst_Ret),
		Subst_Ret=FnResult
	      ),
	      block_exit(subst_if_not, FnResult),
	      true).
:- set_opv(cl_subst_if_not, classof, claz_function),
   set_opv(subst_if_not, compile_as, kw_function),
   set_opv(subst_if_not, function, cl_subst_if_not),
   DefunResult=subst_if_not.
/*
:- side_effect(assert_lsp(subst_if_not,
			  doc_string(subst_if_not,
				     _127774354,
				     function,
				     "Substitutes NEW for subtrees of TREE that do not satisfy TEST and returns the\r\nresult.  The original TREE is not destroyed."))).
*/
/*
:- side_effect(assert_lsp(subst_if_not,
			  lambda_def(defun,
				     subst_if_not,
				     cl_subst_if_not,
				     [sys_new, test, sys_tree, c38_key, key],
				     
				     [ 
				       [ subst,
					 sys_new,
					 test,
					 sys_tree,
					 kw_test_not,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(subst_if_not,
			  arglist_info(subst_if_not,
				       cl_subst_if_not,
				       [sys_new, test, sys_tree, c38_key, key],
				       arginfo{ all:[sys_new, test, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:
						      [ sys_new,
							test,
							sys_tree,
							key
						      ],
						opt:0,
						req:[sys_new, test, sys_tree],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(subst_if_not, init_args(3, cl_subst_if_not))).
*/
/*
#+(or WAM-CL ECL) 
(defun nsubst-if (new test tree &key key)
  "Destructive SUBST-IF. TREE may be modified."
  (nsubst new test tree :test #'funcall :key key))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:38007 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'nsubst-if',[new,test,tree,'&key',key],'$STRING'("Destructive SUBST-IF. TREE may be modified."),[nsubst,new,test,tree,':test',function(funcall),':key',key]]).
doc: doc_string(nsubst_if,
	      _128690648,
	      function,
	      "Destructive SUBST-IF. TREE may be modified.").

wl:lambda_def(defun, nsubst_if, cl_nsubst_if, [sys_new, test, sys_tree, c38_key, key], [[nsubst, sys_new, test, sys_tree, kw_test, function(funcall), kw_key, key]]).
wl:arglist_info(nsubst_if, cl_nsubst_if, [sys_new, test, sys_tree, c38_key, key], arginfo{all:[sys_new, test, sys_tree], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[sys_new, test, sys_tree, key], opt:0, req:[sys_new, test, sys_tree], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_nsubst_if).

/*

### Compiled:  `CL:NSUBST-IF` 
*/
cl_nsubst_if(New_In, Test_In, Tree_In, RestNKeys, FnResult) :-
	Env15=[bv(sys_new, New_In), bv(test, Test_In), bv(sys_tree, Tree_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env15, sys_new, New_Get),
		get_var(Env15, sys_tree, Tree_Get),
		get_var(Env15, test, Test_Get),
		get_var(Env15, key, Key_Get),
		cl_nsubst(New_Get,
			  Test_Get,
			  Tree_Get,
			  kw_test,
			  cl_funcall,
			  kw_key,
			  Key_Get,
			  Nsubst_Ret),
		Nsubst_Ret=FnResult
	      ),
	      block_exit(nsubst_if, FnResult),
	      true).
:- set_opv(cl_nsubst_if, classof, claz_function),
   set_opv(nsubst_if, compile_as, kw_function),
   set_opv(nsubst_if, function, cl_nsubst_if),
   DefunResult=nsubst_if.
/*
:- side_effect(assert_lsp(nsubst_if,
			  doc_string(nsubst_if,
				     _128690648,
				     function,
				     "Destructive SUBST-IF. TREE may be modified."))).
*/
/*
:- side_effect(assert_lsp(nsubst_if,
			  lambda_def(defun,
				     nsubst_if,
				     cl_nsubst_if,
				     [sys_new, test, sys_tree, c38_key, key],
				     
				     [ 
				       [ nsubst,
					 sys_new,
					 test,
					 sys_tree,
					 kw_test,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nsubst_if,
			  arglist_info(nsubst_if,
				       cl_nsubst_if,
				       [sys_new, test, sys_tree, c38_key, key],
				       arginfo{ all:[sys_new, test, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:
						      [ sys_new,
							test,
							sys_tree,
							key
						      ],
						opt:0,
						req:[sys_new, test, sys_tree],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nsubst_if, init_args(3, cl_nsubst_if))).
*/
/*
#+(or WAM-CL ECL) 
(defun nsubst-if-not (new test tree &key key)
  "Destructive SUBST-IF-NOT. TREE may be modified."
  (nsubst new test tree :test-not #'funcall :key key))




*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:38173 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'nsubst-if-not',[new,test,tree,'&key',key],'$STRING'("Destructive SUBST-IF-NOT. TREE may be modified."),[nsubst,new,test,tree,':test-not',function(funcall),':key',key]]).
doc: doc_string(nsubst_if_not,
	      _129606956,
	      function,
	      "Destructive SUBST-IF-NOT. TREE may be modified.").

wl:lambda_def(defun, nsubst_if_not, cl_nsubst_if_not, [sys_new, test, sys_tree, c38_key, key], [[nsubst, sys_new, test, sys_tree, kw_test_not, function(funcall), kw_key, key]]).
wl:arglist_info(nsubst_if_not, cl_nsubst_if_not, [sys_new, test, sys_tree, c38_key, key], arginfo{all:[sys_new, test, sys_tree], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[key], names:[sys_new, test, sys_tree, key], opt:0, req:[sys_new, test, sys_tree], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_nsubst_if_not).

/*

### Compiled:  `CL:NSUBST-IF-NOT` 
*/
cl_nsubst_if_not(New_In, Test_In, Tree_In, RestNKeys, FnResult) :-
	Env15=[bv(sys_new, New_In), bv(test, Test_In), bv(sys_tree, Tree_In), bv(key, Key_In)|Env],
	global_env(Env),
	get_kw(Env, RestNKeys, key, key, Key_In, []=Key_In, Key_P),
	catch(( get_var(Env15, sys_new, New_Get),
		get_var(Env15, sys_tree, Tree_Get),
		get_var(Env15, test, Test_Get),
		get_var(Env15, key, Key_Get),
		cl_nsubst(New_Get,
			  Test_Get,
			  Tree_Get,
			  kw_test_not,
			  cl_funcall,
			  kw_key,
			  Key_Get,
			  Nsubst_Ret),
		Nsubst_Ret=FnResult
	      ),
	      block_exit(nsubst_if_not, FnResult),
	      true).
:- set_opv(cl_nsubst_if_not, classof, claz_function),
   set_opv(nsubst_if_not, compile_as, kw_function),
   set_opv(nsubst_if_not, function, cl_nsubst_if_not),
   DefunResult=nsubst_if_not.
/*
:- side_effect(assert_lsp(nsubst_if_not,
			  doc_string(nsubst_if_not,
				     _129606956,
				     function,
				     "Destructive SUBST-IF-NOT. TREE may be modified."))).
*/
/*
:- side_effect(assert_lsp(nsubst_if_not,
			  lambda_def(defun,
				     nsubst_if_not,
				     cl_nsubst_if_not,
				     [sys_new, test, sys_tree, c38_key, key],
				     
				     [ 
				       [ nsubst,
					 sys_new,
					 test,
					 sys_tree,
					 kw_test_not,
					 function(funcall),
					 kw_key,
					 key
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nsubst_if_not,
			  arglist_info(nsubst_if_not,
				       cl_nsubst_if_not,
				       [sys_new, test, sys_tree, c38_key, key],
				       arginfo{ all:[sys_new, test, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[key],
						names:
						      [ sys_new,
							test,
							sys_tree,
							key
						      ],
						opt:0,
						req:[sys_new, test, sys_tree],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nsubst_if_not, init_args(3, cl_nsubst_if_not))).
*/
/*
#+BUILTIN 
#+(or WAM-CL ECL) 
(funcall #'(setf macro-function)
	 #'(lambda (name lambda-list &rest body)
	     (list 'progn
		   (list 'funcall '#'(setf macro-function)
			 (list 'function
			       (cons 'lambda (cons lambda-list body)))
			 (list 'quote name))
		   (list 'quote name)))
	 'defmacro)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:38357 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':ECL'],[funcall,function([setf,'macro-function']),function([lambda,[name,'lambda-list','&rest',body],[list,[quote,progn],[list,[quote,funcall],[quote,function([setf,'macro-function'])],[list,[quote,function],[cons,[quote,lambda],[cons,'lambda-list',body]]],[list,[quote,quote],name]],[list,[quote,quote],name]]]),[quote,defmacro]]]]))
/*
#+(or WAM-CL ECL) 
(defmacro defun500 (name lambda-list &rest body)
  (list 'progn
	(list 'funcall '#'(setf fdefinition)
	      (list 'function
		    (list 'lambda lambda-list
			  (cons 'block (cons (if (consp name)
						 (car (cdr name))
						 name)
					     body))))
	      (list 'quote name))
	(list 'quote name)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:38676 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,defun500,[name,'lambda-list','&rest',body],[list,[quote,progn],[list,[quote,funcall],[quote,function([setf,fdefinition])],[list,[quote,function],[list,[quote,lambda],'lambda-list',[cons,[quote,block],[cons,[if,[consp,name],[car,[cdr,name]],name],body]]]],[list,[quote,quote],name]],[list,[quote,quote],name]]]).
wl:lambda_def(defmacro, sys_defun500, f_sys_defun500, [sys_name, sys_lambda_list, c38_rest, sys_body], [progn, [list, [quote, progn], [list, [quote, funcall], [quote, function([setf, fdefinition])], [list, [quote, function], [list, [quote, lambda], sys_lambda_list, [cons, [quote, block], [cons, [if, [consp, sys_name], [car, [cdr, sys_name]], sys_name], sys_body]]]], [list, [quote, quote], sys_name]], [list, [quote, quote], sys_name]]]).
wl:arglist_info(sys_defun500, f_sys_defun500, [sys_name, sys_lambda_list, c38_rest, sys_body], arginfo{all:[sys_name, sys_lambda_list], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_name, sys_lambda_list, sys_body], opt:0, req:[sys_name, sys_lambda_list], rest:[sys_body], sublists:0, whole:0}).
wl: init_args(2, f_sys_defun500).

/*

### Compiled:  `SYS::DEFUN500` 
*/
f_sys_defun500(Name_In, Lambda_list_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_name, Name_In), bv(sys_lambda_list, Lambda_list_In), bv(sys_body, RestNKeys)|CDR],
	global_env(CDR),
	catch(( get_var(Env, sys_lambda_list, Lambda_list_Get),
		get_var(Env, sys_name, Name_Get),
		(   is_consp(Name_Get)
		->  get_var(Env, sys_name, Name_Get12),
		    cl_cdr(Name_Get12, Car_Param),
		    cl_car(Car_Param, TrueResult),
		    CAR=TrueResult
		;   get_var(Env, sys_name, Name_Get13),
		    CAR=Name_Get13
		),
		get_var(Env, sys_body, Body_Get),
		CDR24=[CAR|Body_Get],
		CAR25=[block|CDR24],
		CAR26=[lambda, Lambda_list_Get, CAR25],
		CAR28=[function, CAR26],
		get_var(Env, sys_name, Name_Get17),
		CAR27=[quote, Name_Get17],
		CAR30=[funcall, function([setf, fdefinition]), CAR28, CAR27],
		get_var(Env, sys_name, Name_Get18),
		CAR29=[quote, Name_Get18],
		_130871632=[progn, CAR30, CAR29],
		_130871632=MFResult
	      ),
	      block_exit(sys_defun500, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(f_sys_defun500, classof, claz_macro),
   set_opv(sys_defun500, compile_as, kw_operator),
   set_opv(sys_defun500, function, f_sys_defun500),
   DefMacroResult=sys_defun500.
/*
:- side_effect(assert_lsp(sys_defun500,
			  lambda_def(defmacro,
				     sys_defun500,
				     f_sys_defun500,
				     
				     [ sys_name,
				       sys_lambda_list,
				       c38_rest,
				       sys_body
				     ],
				     
				     [ progn,
				       
				       [ list,
					 [quote, progn],
					 
					 [ list,
					   [quote, funcall],
					   
					   [ quote,
					     function([setf, fdefinition]).
					   ],
					   
					   [ list,
					     [quote, function],
					     
					     [ list,
					       [quote, lambda],
					       sys_lambda_list,
					       
					       [ cons,
						 [quote, block],
						 
						 [ cons,
						   
						   [ if,
						     [consp, sys_name],
						     [car, [cdr, sys_name]],
						     sys_name
						   ],
						   sys_body
						 ]
					       ]
					     ]
					   ],
					   [list, [quote, quote], sys_name]
					 ],
					 [list, [quote, quote], sys_name]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_defun500,
			  arglist_info(sys_defun500,
				       f_sys_defun500,
				       
				       [ sys_name,
					 sys_lambda_list,
					 c38_rest,
					 sys_body
				       ],
				       arginfo{ all:[sys_name, sys_lambda_list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_name,
							sys_lambda_list,
							sys_body
						      ],
						opt:0,
						req:[sys_name, sys_lambda_list],
						rest:[sys_body],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_defun500, init_args(2, f_sys_defun500))).
*/
/*
#+(or WAM-CL ECL) 
#+BUILTIN
(defmacro setf (place new-value)
  (if (consp place)
      (cons 'funcall (cons (list 'function (list 'setf (car place)))
			   (cons new-value (cdr place))))
      (list 'setq place new-value)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39012 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[defmacro,setf,[place,'new-value'],[if,[consp,place],[cons,[quote,funcall],[cons,[list,[quote,function],[list,[quote,setf],[car,place]]],[cons,'new-value',[cdr,place]]]],[list,[quote,setq],place,'new-value']]]]))
/*
#+WAM-CL
#+(or WAM-CL ECL) 
(defun append (&rest lists)
  (if (cdr lists)
      (let ((list (car lists))
	    (result nil)
	    (end nil))
	(if list
	    (tagbody
	     start
	       (if list
		   (progn
		     (setf end (if end
				   (setf (cdr end) (list (car list)))
				   (setf result (list (car list)))))
		     (setf list (cdr list))
		     (go start)))
	       (setf (cdr end) (apply #'append (cdr lists)))
	       (return-from append result))
	    (apply #'append (cdr lists))))
      (car lists)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39248 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,append,['&rest',lists],[if,[cdr,lists],[let,[[list,[car,lists]],[result,[]],[end,[]]],[if,list,[tagbody,start,[if,list,[progn,[setf,end,[if,end,[setf,[cdr,end],[list,[car,list]]],[setf,result,[list,[car,list]]]]],[setf,list,[cdr,list]],[go,start]]],[setf,[cdr,end],[apply,function(append),[cdr,lists]]],['return-from',append,result]],[apply,function(append),[cdr,lists]]]],[car,lists]]]).
/*
:- side_effect((compile_each($, _132514638, [], [], true), append([end], [CAR24, CAR], [end, CAR24, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, _132514638, [], [], true), append([end], [CAR24, CAR], [end, CAR24, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, _132514638, [], [], true), append([end], [CAR24, CAR], [end, CAR24, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, _132514638, [], [], true), append([end], [CAR24, CAR], [end, CAR24, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:-side_effect((compile_each($,_132514638,[],[],true),append([end],[_132811542,_132811370],[end,_132811542,_132811370]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_132514638,[],[],true),append([end],[_132843384,_132843212],[end,_132843384,_132843212]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_132514638,[],[],true),append([end],[_132875352,_132875180],[end,_132875352,_132875180]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_132514638,[],[],true),append([end],[_132907348,_132907176],[end,_132907348,_132907176]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_132487142,[],[],true),append([end],[_132973140,_132972968],[end,_132973140,_132972968]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_132487142,[],[],true),append([end],[_133004982,_133004810],[end,_133004982,_133004810]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_132487142,[],[],true),append([end],[_133036950,_133036778],[end,_133036950,_133036778]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_132487142,[],[],true),append([end],[_133068946,_133068774],[end,_133068946,_133068774]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_133106678,[],[],true),append([end],[_133144512,_133144340],[end,_133144512,_133144340]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_133106678,[],[],true),append([end],[_133176354,_133176182],[end,_133176354,_133176182]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_133106678,[],[],true),append([end],[_133208322,_133208150],[end,_133208322,_133208150]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_133106678,[],[],true),append([end],[_133240318,_133240146],[end,_133240318,_133240146]),setf_inverse_op(cdr,rplacd))).
*/
wl:lambda_def(defun,append,cl_append,[c38_rest,sys_lists],[[if,[cdr,sys_lists],[let,[[list,[car,sys_lists]],[sys_result,[]],[end,[]]],[if,list,[tagbody,start,[if,list,[progn,[setf,end,[if,end,[setf,[cdr,end],[list,[car,list]]],[setf,sys_result,[list,[car,list]]]]],[setf,list,[cdr,list]],[go,start]]],[setf,[cdr,end],[apply,function(append),[cdr,sys_lists]]],[return_from,append,sys_result]],[apply,function(append),[cdr,sys_lists]]]],[car,sys_lists]]]).
wl:arglist_info(append,cl_append,[c38_rest,sys_lists],arginfo{all:0,allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_lists],opt:0,req:0,rest:[sys_lists],sublists:0,whole:0}).
wl:init_args(0,cl_append).

/*

### Compiled:  `CL:APPEND` 
*/
cl_append(_132476098,_133463510):-_133948982=[bv(sys_lists,_132476098)|_132452812],global_env(_132452812),catch((get_var(_133948982,sys_lists,_132483796),cl_cdr(_132483796,_132483666),(_132483666\==[]->get_var(_133948982,sys_lists,_132489824),cl_car(_132489824,_132488876),_133106678=[bv(list,_132488876),bv(sys_result,[]),bv(end,[])|_133948982],get_var(_133106678,list,_132507370),(_132507370\==[]->call_addr_block(_133106678,(push_label(start),get_var(_133106678,list,_132952976),(_132952976\==[]->get_var(_133106678,end,_132957182),(_132957182\==[]->get_var(_133106678,end,_133087320),get_var(_133106678,list,_133088848),cl_car(_133088848,_133087942),_133087874=_133087942,cl_rplacd(_133087320,_133087874,_133096628),_132956448=_133096628;get_var(_133106678,list,_133093636),cl_car(_133093636,_134152036),_133096976=_134152036,set_var(_133106678,sys_result,_133096976),_132956448=_133096976),set_var(_133106678,end,_132956448),get_var(_133106678,list,_133104386),cl_cdr(_133104386,_133103390),set_var(_133106678,list,_133103390),goto(start,_133106678),_132951944=_133106430;_132951944=[]),get_var(_133106678,end,_133258692),get_var(_133106678,sys_lists,_133260280),cl_cdr(_133260280,_133259332),cl_append(_133259332,_133259270),cl_rplacd(_133258692,_133259270,_133130430),get_var(_133106678,sys_result,_133264428),throw(block_exit(append,_133264428))),[addr(addr_tagbody_19_start,start,'$unused',_133288268,(get_var(_133288268,list,_133288296),(_133288296\==[]->get_var(_133288268,end,_133288348),(_133288348\==[]->get_var(_133288268,end,_133288400),get_var(_133288268,list,_133288436),cl_car(_133288436,_133288458),cl_list(_133288458,_133288470),cl_rplacd(_133288400,_133288470,_134172908),_133288488=_134172908;get_var(_133288268,list,_133288508),cl_car(_133288508,_134038506),cl_list(_134038506,_134175964),set_var(_133288268,sys_result,_134175964),_133288488=_134175964),set_var(_133288268,end,_133288488),get_var(_133288268,list,_133288594),cl_cdr(_133288594,_133288616),set_var(_133288268,list,_133288616),goto(start,_133288268),_133288646=_133288652;_133288646=[]),get_var(_133288268,end,_133288686),get_var(_133288268,sys_lists,_133288722),cl_cdr(_133288722,_134046842),cl_append(_134046842,_134185896),cl_rplacd(_133288686,_134185896,_134187222),get_var(_133288268,sys_result,_133288784),throw(block_exit(append,_133288784))))]),_133370658=[];get_var(_133106678,sys_lists,_133303574),cl_cdr(_133303574,_134051862),cl_append(_134051862,_133305734),_133370658=_133305734),_132478172=_133370658;get_var(_133948982,sys_lists,_133369290),cl_car(_133369290,_133371006),_132478172=_133371006),_132478172=_133463510),block_exit(append,_133463510),true).
:-set_opv(cl_append,classof,claz_function),set_opv(append,compile_as,kw_function),set_opv(append,function,cl_append),_132444592=append.
/*
:-side_effect(assert_lsp(append,lambda_def(defun,append,cl_append,[c38_rest,sys_lists],[[if,[cdr,sys_lists],[let,[[list,[car,sys_lists]],[sys_result,[]],[end,[]]],[if,list,[tagbody,start,[if,list,[progn,[setf,end,[if,end,[setf,[cdr,end],[list,[car,list]]],[setf,sys_result,[list,[car,list]]]]],[setf,list,[cdr,list]],[go,start]]],[setf,[cdr,end],[apply,function(append),[cdr,sys_lists]]],[return_from,append,sys_result]],[apply,function(append),[cdr,sys_lists]]]],[car,sys_lists]]]))).
*/
/*
:-side_effect(assert_lsp(append,arglist_info(append,cl_append,[c38_rest,sys_lists],arginfo{all:0,allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_lists],opt:0,req:0,rest:[sys_lists],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(append,init_args(0,cl_append))).
*/
/*
#+(or WAM-CL ECL) 
(defparameter *type-expanders* nil)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39782 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defparameter,'*type-expanders*',[]]).
:- set_var(AEnv, sys_xx_type_expanders_xx, []).
/*
#+(or WAM-CL ECL) 
(defconstant call-arguments-limit 65536)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39841 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defconstant,'call-arguments-limit',65536]).
:- set_var(AEnv, call_arguments_limit, 65536).
/*
#+(or WAM-CL ECL) 
(defconstant lambda-parameters-limit 65536)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39905 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defconstant,'lambda-parameters-limit',65536]).
:- set_var(AEnv, lambda_parameters_limit, 65536).
/*
#+(or WAM-CL ECL) 
(defconstant multiple-values-limit 65536)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:39972 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defconstant,'multiple-values-limit',65536]).
:- set_var(AEnv, multiple_values_limit, 65536).
/*
#+(or WAM-CL ECL)
(defconstant lambda-list-keywords
  '(&allow-other-keys &aux &body &environment &key &optional &rest &whole))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40037 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defconstant,'lambda-list-keywords',[quote,['&allow-other-keys','&aux','&body','&environment','&key','&optional','&rest','&whole']]]).
:- set_var(AEnv,
	   lambda_list_keywords,
	   
	   [ c38_allow_other_keys,
	     c38_aux,
	     c38_body,
	     c38_environment,
	     c38_key,
	     c38_optional,
	     c38_rest,
	     c38_whole
	   ]).
/*
(apropos-defmacro psetq (&rest rest)
  (let ((inits nil)
	(sets nil)
	(list rest))
    (tagbody
     start
       (when (cddr list)
	 (push (list (gensym) (cadr list)) inits)
	 (setq list (cddr list))
	 (go start)))
    (setq list inits)
    (tagbody
     start
       (when (cddr rest)
	 (push (caar list) sets)
	 (push (car rest) sets)
	 (setq list (cdr list))
	 (setq rest (cddr rest))
	 (go start)))
    `(let ,(reverse inits)
      (setq ,@sets ,@rest))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40170 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',psetq,['&rest',rest],[let,[[inits,[]],[sets,[]],[list,rest]],[tagbody,start,[when,[cddr,list],[push,[list,[gensym],[cadr,list]],inits],[setq,list,[cddr,list]],[go,start]]],[setq,list,inits],[tagbody,start,[when,[cddr,rest],[push,[caar,list],sets],[push,[car,rest],sets],[setq,list,[cdr,list]],[setq,rest,[cddr,rest]],[go,start]]],['#BQ',[let,['#COMMA',[reverse,inits]],[setq,['#BQ-COMMA-ELIPSE',sets],['#BQ-COMMA-ELIPSE',rest]]]]]]).
:- get_var(GEnv, psetq, Psetq_Get),
   get_var(GEnv, rest, Rest_Get),
   cl_c38_rest(Rest_Get, C38_rest_Ret),
   get_var(GEnv, rest, Rest_Get6),
   AEnv=[bv(sys_inits, []), bv(sys_sets, []), bv(list, Rest_Get6)|GEnv],
   call_addr_block(AEnv,
		   (push_label(start), get_var(AEnv, list, List_Get20), cl_cddr(List_Get20, IFTEST18), (IFTEST18\==[]->cl_push([list, [gensym], [cadr, list]], sys_inits, Inits), get_var(AEnv, list, List_Get22), cl_cddr(List_Get22, List), set_var(AEnv, list, List), goto(start, AEnv), _TBResult=_GORES23;_TBResult=[])),
		   
		   [ addr(addr_tagbody_20_start,
			  start,
			  '$unused',
			  AEnv,
			  (get_var(AEnv, list, Cddr_Param), cl_cddr(Cddr_Param, IFTEST), (IFTEST\==[]->cl_push([list, [gensym], [cadr, list]], sys_inits, Push_Ret), get_var(AEnv, list, List_Get13), cl_cddr(List_Get13, Cddr_Ret), set_var(AEnv, list, Cddr_Ret), goto(start, AEnv), _136704016=_GORES;_136704016=[])))
		   ]),
   get_var(AEnv, sys_inits, Inits_Get),
   set_var(AEnv, list, Inits_Get),
   call_addr_block(AEnv,
		   (push_label(start), get_var(AEnv, rest, Rest_Get41), cl_cddr(Rest_Get41, IFTEST39), (IFTEST39\==[]->cl_push([caar, list], sys_sets, Sets), cl_push([car, rest], sys_sets, Sets53), get_var(AEnv, list, List_Get42), cl_cdr(List_Get42, List54), set_var(AEnv, list, List54), get_var(AEnv, rest, Rest_Get43), cl_cddr(Rest_Get43, Rest), set_var(AEnv, rest, Rest), goto(start, AEnv), _TBResult27=_GORES44;_TBResult27=[])),
		   
		   [ addr(addr_tagbody_21_start,
			  start,
			  '$unused',
			  AEnv,
			  (get_var(AEnv, rest, Rest_Get30), cl_cddr(Rest_Get30, IFTEST28), (IFTEST28\==[]->cl_push([caar, list], sys_sets, Push_Ret60), cl_push([car, rest], sys_sets, Push_Ret61), get_var(AEnv, list, List_Get32), cl_cdr(List_Get32, Cdr_Ret), set_var(AEnv, list, Cdr_Ret), get_var(AEnv, rest, Rest_Get34), cl_cddr(Rest_Get34, Cddr_Ret63), set_var(AEnv, rest, Cddr_Ret63), goto(start, AEnv), _TBResult27=_GORES35;_TBResult27=[])))
		   ]),
   get_var(AEnv, sys_inits, Inits_Get46),
   cl_reverse(Inits_Get46, Reverse_Ret),
   get_var(AEnv, rest, Rest_Get48),
   get_var(AEnv, sys_sets, Sets_Get),
   bq_append([setq|Sets_Get], Rest_Get48, Bq_append_Ret),
   f_sys_apropos_defmacro(Psetq_Get,
			  C38_rest_Ret,
			  [let, Reverse_Ret, Bq_append_Ret],
			  _Ignored).
/*
(apropos-defmacro return (&optional result)
  `(return-from nil ,result))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40656 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',return,['&optional',result],['#BQ',['return-from',[],['#COMMA',result]]]]).
:- set_var(BlockExitEnv, 'block_ret_[]', []),
   always('block_exit_[]', BlockExitEnv),
   f_sys_apropos_defmacro(GoBlockResult,
			  _137795410,
			  [return_from, [], Result_Get4],
			  _Ignored).
/*
(apropos-defmacro when (test-form &rest forms)
  `(if ,test-form (progn ,@forms)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40734 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',when,['test-form','&rest',forms],['#BQ',[if,['#COMMA','test-form'],[progn,['#BQ-COMMA-ELIPSE',forms]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, when, When_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_test_form(C38_rest_Get, Forms_Get, Test_form_Ret),
   get_var(GEnv, forms, Forms_Get5),
   get_var(GEnv, sys_test_form, Test_form_Get),
   f_sys_apropos_defmacro(When_Get,
			  Test_form_Ret,
			  [if, Test_form_Get, [progn|Forms_Get5]],
			  _Ignored).
/*
(apropos-defmacro unless (test-form &rest forms)
  `(if (not ,test-form) (progn ,@forms)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40821 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',unless,['test-form','&rest',forms],['#BQ',[if,[not,['#COMMA','test-form']],[progn,['#BQ-COMMA-ELIPSE',forms]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, unless, Unless_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_test_form(C38_rest_Get, Forms_Get, Test_form_Ret),
   get_var(GEnv, forms, Forms_Get5),
   get_var(GEnv, sys_test_form, Test_form_Get),
   f_sys_apropos_defmacro(Unless_Get,
			  Test_form_Ret,
			  [if, [not, Test_form_Get], [progn|Forms_Get5]],
			  _Ignored).
/*
(apropos-defmacro and (&rest forms)
  (if forms
      (if (cdr forms)
	  `(when ,(car forms) (and ,@(cdr forms)))
	(car forms))
    `t))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:40916 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',and,['&rest',forms],[if,forms,[if,[cdr,forms],['#BQ',[when,['#COMMA',[car,forms]],[and,['#BQ-COMMA-ELIPSE',[cdr,forms]]]]],[car,forms]],['#BQ',t]]]).
:- get_var(GEnv, and, And_Get),
   get_var(GEnv, forms, Forms_Get),
   cl_c38_rest(Forms_Get, C38_rest_Ret),
   get_var(GEnv, forms, IFTEST),
   (   IFTEST\==[]
   ->  get_var(GEnv, forms, Forms_Get8),
       cl_cdr(Forms_Get8, IFTEST6),
       (   IFTEST6\==[]
       ->  get_var(GEnv, forms, Forms_Get9),
	   cl_car(Forms_Get9, Car_Ret),
	   get_var(GEnv, forms, Forms_Get10),
	   cl_cdr(Forms_Get10, Cdr_Ret),
	   TrueResult=[when, Car_Ret, [and|Cdr_Ret]]
       ;   get_var(GEnv, forms, Forms_Get11),
	   cl_car(Forms_Get11, ElseResult),
	   TrueResult=ElseResult
       ),
       _138903426=TrueResult
   ;   _138903426=t
   ),
   f_sys_apropos_defmacro(And_Get, C38_rest_Ret, _138903426, _Ignored).
/*
(apropos-defmacro or (&rest forms)
  (if forms
      (if (cdr forms)
	  (let ((temp (gensym)))
	    `(let ((,temp ,(car forms)))
	      (if ,temp
		  ,temp
		(or ,@(cdr forms)))))
	(car forms))
    `nil))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:41061 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',or,['&rest',forms],[if,forms,[if,[cdr,forms],[let,[[temp,[gensym]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA',[car,forms]]]],[if,['#COMMA',temp],['#COMMA',temp],[or,['#BQ-COMMA-ELIPSE',[cdr,forms]]]]]]],[car,forms]],['#BQ',[]]]]).
:- get_var(GEnv, forms, Forms_Get),
   get_var(GEnv, or, Or_Get),
   cl_c38_rest(Forms_Get, C38_rest_Ret),
   get_var(GEnv, forms, IFTEST),
   (   IFTEST\==[]
   ->  get_var(GEnv, forms, Forms_Get8),
       cl_cdr(Forms_Get8, IFTEST6),
       (   IFTEST6\==[]
       ->  cl_gensym(Temp_Init),
	   LEnv=[bv(sys_temp, Temp_Init)|GEnv],
	   get_var(LEnv, forms, Forms_Get14),
	   get_var(LEnv, sys_temp, Temp_Get),
	   cl_car(Forms_Get14, Car_Ret),
	   get_var(LEnv, forms, Forms_Get17),
	   get_var(LEnv, sys_temp, Temp_Get15),
	   cl_cdr(Forms_Get17, Cdr_Ret),
	   TrueResult=[let, [[Temp_Get, Car_Ret]], [if, Temp_Get15, Temp_Get15, [or|Cdr_Ret]]]
       ;   get_var(GEnv, forms, Forms_Get18),
	   cl_car(Forms_Get18, ElseResult),
	   TrueResult=ElseResult
       ),
       _139366548=TrueResult
   ;   _139366548=[]
   ),
   f_sys_apropos_defmacro(Or_Get, C38_rest_Ret, _139366548, _Ignored).
/*
(apropos-defmacro cond (&rest clauses)
  (when clauses
    (if (cdar clauses)
	`(if ,(caar clauses)
	     (progn ,@(cdar clauses))
	     (cond ,@(cdr clauses)))
	`(or ,(caar clauses)
	     (cond ,@(cdr clauses))))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:41278 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',cond,['&rest',clauses],[when,clauses,[if,[cdar,clauses],['#BQ',[if,['#COMMA',[caar,clauses]],[progn,['#BQ-COMMA-ELIPSE',[cdar,clauses]]],[cond,['#BQ-COMMA-ELIPSE',[cdr,clauses]]]]],['#BQ',[or,['#COMMA',[caar,clauses]],[cond,['#BQ-COMMA-ELIPSE',[cdr,clauses]]]]]]]]).
:- get_var(GEnv, cond, Cond_Get),
   get_var(GEnv, sys_clauses, Clauses_Get),
   cl_c38_rest(Clauses_Get, C38_rest_Ret),
   get_var(GEnv, sys_clauses, IFTEST),
   (   IFTEST\==[]
   ->  get_var(GEnv, sys_clauses, Clauses_Get8),
       cl_cdar(Clauses_Get8, IFTEST6),
       (   IFTEST6\==[]
       ->  get_var(GEnv, sys_clauses, Clauses_Get9),
	   cl_caar(Clauses_Get9, Caar_Ret),
	   get_var(GEnv, sys_clauses, Clauses_Get10),
	   cl_cdar(Clauses_Get10, Cdar_Ret),
	   get_var(GEnv, sys_clauses, Clauses_Get11),
	   cl_cdr(Clauses_Get11, Cdr_Ret),
	   TrueResult=[if, Caar_Ret, [progn|Cdar_Ret], [cond|Cdr_Ret]]
       ;   get_var(GEnv, sys_clauses, Clauses_Get12),
	   cl_caar(Clauses_Get12, Caar_Ret20),
	   get_var(GEnv, sys_clauses, Clauses_Get13),
	   cl_cdr(Clauses_Get13, Cdr_Ret21),
	   TrueResult=[or, Caar_Ret20, [cond|Cdr_Ret21]]
       ),
       _139906196=TrueResult
   ;   _139906196=[]
   ),
   f_sys_apropos_defmacro(Cond_Get, C38_rest_Ret, _139906196, _Ignored).
/*
(apropos-defmacro case (keyform &rest clauses)
  (let ((temp (gensym)))
    (labels ((recur (clauses)
	       (when clauses
		 (if (member (caar clauses) '(otherwise t))
		     `(progn ,@(cdar clauses))
		     `(if ,(if (listp (caar clauses))
			       `(member ,temp ',(caar clauses))
			       `(eql ,temp ',(caar clauses)))
		          (progn ,@(cdar clauses))
		          ,(recur (cdr clauses)))))))
      `(let ((,temp ,keyform))
	,(recur clauses)))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:41506 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',case,[keyform,'&rest',clauses],[let,[[temp,[gensym]]],[labels,[[recur,[clauses],[when,clauses,[if,[member,[caar,clauses],[quote,[otherwise,t]]],['#BQ',[progn,['#BQ-COMMA-ELIPSE',[cdar,clauses]]]],['#BQ',[if,['#COMMA',[if,[listp,[caar,clauses]],['#BQ',[member,['#COMMA',temp],[quote,['#COMMA',[caar,clauses]]]]],['#BQ',[eql,['#COMMA',temp],[quote,['#COMMA',[caar,clauses]]]]]]],[progn,['#BQ-COMMA-ELIPSE',[cdar,clauses]]],['#COMMA',[recur,[cdr,clauses]]]]]]]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA',keyform]]],['#COMMA',[recur,clauses]]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, case, Case_Get),
   get_var(GEnv, sys_clauses, Clauses_Get),
   f_sys_keyform(C38_rest_Get, Clauses_Get, Keyform_Ret),
   cl_gensym(Temp_Init),
   LEnv=[bv(sys_temp, Temp_Init)|GEnv],
   assert_lsp(sys_recur,
	      wl:lambda_def(defun, sys_recur, f_sys_recur1, [sys_clauses], [[when, sys_clauses, [if, [member, [caar, sys_clauses], [quote, [otherwise, t]]], ['#BQ', [progn, ['#BQ-COMMA-ELIPSE', [cdar, sys_clauses]]]], ['#BQ', [if, ['#COMMA', [if, [listp, [caar, sys_clauses]], ['#BQ', [member, ['#COMMA', sys_temp], [quote, ['#COMMA', [caar, sys_clauses]]]]], ['#BQ', [eql, ['#COMMA', sys_temp], [quote, ['#COMMA', [caar, sys_clauses]]]]]]], [progn, ['#BQ-COMMA-ELIPSE', [cdar, sys_clauses]]], ['#COMMA', [sys_recur, [cdr, sys_clauses]]]]]]]])),
   assert_lsp(sys_recur,
	      wl:arglist_info(sys_recur, f_sys_recur1, [sys_clauses], arginfo{all:[sys_clauses], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_clauses], opt:0, req:[sys_clauses], rest:0, sublists:0, whole:0})), !,
   assert_lsp(sys_recur, wl:init_args(exact_only, f_sys_recur1)),
   assert_lsp(sys_recur,
	      (f_sys_recur1(Clauses_In, FnResult):-Env34=[bv(sys_clauses, Clauses_In)|LEnv], global_env(LEnv), catch((get_var(Env34, sys_clauses, IFTEST), (IFTEST\==[]->get_var(Env34, sys_clauses, Clauses_Get16), cl_caar(Clauses_Get16, Member_Param), cl_member(Member_Param, [otherwise, t], [], IFTEST14), (IFTEST14\==[]->get_var(Env34, sys_clauses, Clauses_Get17), cl_cdar(Clauses_Get17, Cdar_Ret), TrueResult=[progn|Cdar_Ret];get_var(Env34, sys_clauses, Clauses_Get19), cl_caar(Clauses_Get19, PredArgResult), (is_listp(PredArgResult)->get_var(Env34, sys_clauses, Clauses_Get23), get_var(Env34, sys_temp, Temp_Get), cl_caar(Clauses_Get23, Caar_Ret), CAR=[member, Temp_Get, [quote, Caar_Ret]];get_var(Env34, sys_clauses, Clauses_Get25), get_var(Env34, sys_temp, Temp_Get24), cl_caar(Clauses_Get25, Caar_Ret40), CAR=[eql, Temp_Get24, [quote, Caar_Ret40]]), get_var(Env34, sys_clauses, Clauses_Get26), cl_cdar(Clauses_Get26, Cdar_Ret41), get_var(Env34, sys_clauses, Clauses_Get27), cl_cdr(Clauses_Get27, Recur_Param), f_sys_recur(Recur_Param, Recur_Ret), TrueResult=[if, CAR, [progn|Cdar_Ret41], Recur_Ret]), _140498704=TrueResult;_140498704=[]), _140498704=FnResult), block_exit(sys_recur, FnResult), true))),
   get_var(LEnv, sys_keyform, Keyform_Get),
   get_var(LEnv, sys_temp, Temp_Get30),
   get_var(LEnv, sys_clauses, Clauses_Get32),
   f_sys_recur1(Clauses_Get32, Recur1_Ret),
   f_sys_apropos_defmacro(Case_Get,
			  Keyform_Ret,
			  [let, [[Temp_Get30, Keyform_Get]], Recur1_Ret],
			  _Ignored).
/*
:- side_effect(assert_lsp(sys_recur,
			  lambda_def(defun,
				     sys_recur,
				     f_sys_recur1,
				     [sys_clauses],
				     
				     [ 
				       [ when,
					 sys_clauses,
					 
					 [ if,
					   
					   [ member,
					     [caar, sys_clauses],
					     [quote, [otherwise, t]]
					   ],
					   
					   [ '#BQ',
					     
					     [ progn,
					       
					       [ '#BQ-COMMA-ELIPSE',
						 [cdar, sys_clauses]
					       ]
					     ]
					   ],
					   
					   [ '#BQ',
					     
					     [ if,
					       
					       [ '#COMMA',
						 
						 [ if,
						   [listp, [caar, sys_clauses]],
						   
						   [ '#BQ',
						     
						     [ member,
						       ['#COMMA', sys_temp],
						       
						       [ quote,
							 
							 [ '#COMMA',
							   [caar, sys_clauses]
							 ]
						       ]
						     ]
						   ],
						   
						   [ '#BQ',
						     
						     [ eql,
						       ['#COMMA', sys_temp],
						       
						       [ quote,
							 
							 [ '#COMMA',
							   [caar, sys_clauses]
							 ]
						       ]
						     ]
						   ]
						 ]
					       ],
					       
					       [ progn,
						 
						 [ '#BQ-COMMA-ELIPSE',
						   [cdar, sys_clauses]
						 ]
					       ],
					       
					       [ '#COMMA',
						 [sys_recur, [cdr, sys_clauses]]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_recur,
			  arglist_info(sys_recur,
				       f_sys_recur1,
				       [sys_clauses],
				       arginfo{ all:[sys_clauses],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_clauses],
						opt:0,
						req:[sys_clauses],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_recur, init_args(exact_only, f_sys_recur1))).
*/
/*
(apropos-defmacro ecase (keyform &rest clauses)
  (let ((temp (gensym)))
    `(let ((,temp ,keyform))
      (case ,temp ,@clauses
	    (error 'type-error :datum ,temp
		   :expected-type `(member ,@(mapcan #'(lambda (x)
							 (if (listp (car x))
							     (car x)
							     (list (car x))))
						     clauses)))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:41980 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',ecase,[keyform,'&rest',clauses],[let,[[temp,[gensym]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA',keyform]]],[case,['#COMMA',temp],['#BQ-COMMA-ELIPSE',clauses],[error,[quote,'type-error'],':datum',['#COMMA',temp],':expected-type',['#BQ',[member,['#BQ-COMMA-ELIPSE',[mapcan,function([lambda,[x],[if,[listp,[car,x]],[car,x],[list,[car,x]]]]),clauses]]]]]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, ecase, Ecase_Get),
   get_var(GEnv, sys_clauses, Clauses_Get),
   f_sys_keyform(C38_rest_Get, Clauses_Get, Keyform_Ret),
   cl_gensym(Temp_Init),
   LEnv=[bv(sys_temp, Temp_Init)|GEnv],
   get_var(LEnv, sys_keyform, Keyform_Get),
   get_var(LEnv, sys_temp, Temp_Get),
   get_var(LEnv, sys_clauses, Clauses_Get11),
   get_var(LEnv, sys_temp, Temp_Get10),
   get_var(LEnv, sys_clauses, Clauses_Get24),
   get_var(LEnv, sys_temp, Temp_Get12),
   cl_mapcan(closure(LEnv22,
		     LResult,
		     [sys_x],
		     (get_var(LEnv22, sys_x, X_Get), cl_car(X_Get, PredArgResult), (is_listp(PredArgResult)->get_var(LEnv22, sys_x, X_Get17), cl_car(X_Get17, TrueResult), LResult=TrueResult;get_var(LEnv22, sys_x, X_Get18), cl_car(X_Get18, Car_Ret), ElseResult=Car_Ret, LResult=ElseResult))),
	     Clauses_Get24,
	     Mapcan_Ret),
   bq_append([Temp_Get10|Clauses_Get11],
	     
	     [ 
	       [ error,
		 [quote, type_error],
		 kw_datum,
		 Temp_Get12,
		 kw_expected_type,
		 [quote, [member|Mapcan_Ret]]
	       ]
	     ],
	     Bq_append_Ret),
   f_sys_apropos_defmacro(Ecase_Get,
			  Keyform_Ret,
			  [let, [[Temp_Get, Keyform_Get]], [case|Bq_append_Ret]],
			  _Ignored).
/*
(apropos-defmacromultiple-value-bind (vars values-form &rest forms)
  `(multiple-value-call #'(lambda (&optional ,@vars &rest ,(gensym))
			    ,@forms)
                        ,values-form))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42315 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacromultiple-value-bind',[vars,'values-form','&rest',forms],['#BQ',['multiple-value-call',function([lambda,['&optional',['#BQ-COMMA-ELIPSE',vars],'&rest',['#COMMA',[gensym]]],['#BQ-COMMA-ELIPSE',forms]]),['#COMMA','values-form']]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, sys_values_form, Values_form_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_vars(Values_form_Get, C38_rest_Get, Forms_Get, Value_bind_Param),
   get_var(GEnv, sys_values_form, Values_form_Get4),
   f_sys_apropos_defmacromultiple_value_bind(Value_bind_Param,
					     
					     [ multiple_value_call,
					       function(
							[ lambda,
							  
							  [ c38_optional,
							    
							    [ '#BQ-COMMA-ELIPSE',
							      sys_vars
							    ],
							    c38_rest,
							    ['#COMMA', [gensym]]
							  ],
							  
							  [ '#BQ-COMMA-ELIPSE',
							    forms
							  ]
							]),
					       Values_form_Get4
					     ],
					     _Ignored).
/*
(apropos-defmacro multiple-value-list (form)
  `(multiple-value-call #'list ,form))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42513 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro','multiple-value-list',[form],['#BQ',['multiple-value-call',function(list),['#COMMA',form]]]]).
:- get_var(GEnv, multiple_value_list, Multiple_value_list_Get),
   f_sys_form(Form_Ret),
   get_var(GEnv, sys_form, Form_Get),
   f_sys_apropos_defmacro(Multiple_value_list_Get,
			  Form_Ret,
			  [multiple_value_call, function(list), Form_Get],
			  _Ignored).
/*
(apropos-defun values-list (list) (apply #'values list))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42601 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defun','values-list',[list],[apply,function(values),list]]).
:- get_var(GEnv, values_list, Values_list_Get),
   _143624644=[],
   get_var(GEnv, list, List_Get),
   cl_values(List_Get, Values_Ret),
   f_sys_apropos_defun(Values_list_Get, _143624644, Values_Ret, _Ignored).
/*
#+(or WAM-CL LISP500)
(defmacro nth-value (n form)
  `(nth ,n (multiple-value-list ,form)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42661 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'nth-value',[n,form],['#BQ',[nth,['#COMMA',n],['multiple-value-list',['#COMMA',form]]]]]).
wl:lambda_def(defmacro, nth_value, cl_nth_value, [n, sys_form], [progn, ['#BQ', [nth, ['#COMMA', n], [multiple_value_list, ['#COMMA', sys_form]]]]]).
wl:arglist_info(nth_value, cl_nth_value, [n, sys_form], arginfo{all:[n, sys_form], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[n, sys_form], opt:0, req:[n, sys_form], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_nth_value).

/*

### Compiled:  `CL:NTH-VALUE` 
*/
cl_nth_value(N_In, Form_In, FnResult) :-
	nop(defmacro),
	Env=[bv(n, N_In), bv(sys_form, Form_In)|CDR],
	global_env(CDR),
	catch(( get_var(Env, n, N_Get),
		get_var(Env, sys_form, Form_Get),
		[nth, N_Get, [multiple_value_list, Form_Get]]=MFResult
	      ),
	      block_exit(nth_value, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_nth_value, classof, claz_macro),
   set_opv(nth_value, compile_as, kw_operator),
   set_opv(nth_value, function, cl_nth_value),
   DefMacroResult=nth_value.
/*
:- side_effect(assert_lsp(nth_value,
			  lambda_def(defmacro,
				     nth_value,
				     cl_nth_value,
				     [n, sys_form],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ nth,
					   ['#COMMA', n],
					   
					   [ multiple_value_list,
					     ['#COMMA', sys_form]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nth_value,
			  arglist_info(nth_value,
				       cl_nth_value,
				       [n, sys_form],
				       arginfo{ all:[n, sys_form],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[n, sys_form],
						opt:0,
						req:[n, sys_form],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nth_value, init_args(exact_only, cl_nth_value))).
*/
/*
(apropos-defmacro prog (inits &rest forms)
  `(block nil
    (let ,inits
      (tagbody ,@forms))))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42758 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',prog,[inits,'&rest',forms],['#BQ',[block,[],[let,['#COMMA',inits],[tagbody,['#BQ-COMMA-ELIPSE',forms]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, prog, Prog_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_inits(C38_rest_Get, Forms_Get, Inits_Ret),
   get_var(GEnv, forms, Forms_Get5),
   get_var(GEnv, sys_inits, Inits_Get),
   f_sys_apropos_defmacro(Prog_Get,
			  Inits_Ret,
			  [block, [], [let, Inits_Get, [tagbody|Forms_Get5]]],
			  _Ignored).
/*
(apropos-defmacro prog* (inits &rest forms)
  `(block nil
    (let* ,inits
      (tagbody ,@forms))))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42862 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro','prog*',[inits,'&rest',forms],['#BQ',[block,[],['let*',['#COMMA',inits],[tagbody,['#BQ-COMMA-ELIPSE',forms]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, prog_xx, Prog_xx_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_inits(C38_rest_Get, Forms_Get, Inits_Ret),
   get_var(GEnv, forms, Forms_Get5),
   get_var(GEnv, sys_inits, Inits_Get),
   f_sys_apropos_defmacro(Prog_xx_Get,
			  Inits_Ret,
			  [block, [], [let_xx, Inits_Get, [tagbody|Forms_Get5]]],
			  _Ignored).
/*
(apropos-defmacro prog1 (first-form &rest forms)
  (let ((temp (gensym)))
    `(let ((,temp ,first-form))
      ,@forms
      ,temp)))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:42968 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',prog1,['first-form','&rest',forms],[let,[[temp,[gensym]]],['#BQ',[let,[[['#COMMA',temp],['#COMMA','first-form']]],['#BQ-COMMA-ELIPSE',forms],['#COMMA',temp]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, prog1, Prog1_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_first_form(C38_rest_Get, Forms_Get, First_form_Ret),
   cl_gensym(Temp_Init),
   LEnv=[bv(sys_temp, Temp_Init)|GEnv],
   get_var(LEnv, sys_first_form, First_form_Get),
   get_var(LEnv, sys_temp, Temp_Get),
   get_var(LEnv, forms, Forms_Get10),
   get_var(LEnv, sys_temp, Temp_Get11),
   bq_append([[[Temp_Get, First_form_Get]]|Forms_Get10],
	     [Temp_Get11],
	     Bq_append_Ret),
   f_sys_apropos_defmacro(Prog1_Get,
			  First_form_Ret,
			  [let|Bq_append_Ret],
			  _Ignored).
/*
(apropos-defmacro prog2 (first-form second-form &rest forms)
  (let ((temp (gensym)))
    `(progn
      ,first-form
      (let ((,temp ,second-form))
	,@forms
	,temp))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43108 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',prog2,['first-form','second-form','&rest',forms],[let,[[temp,[gensym]]],['#BQ',[progn,['#COMMA','first-form'],[let,[[['#COMMA',temp],['#COMMA','second-form']]],['#BQ-COMMA-ELIPSE',forms],['#COMMA',temp]]]]]]).
:- get_var(GEnv, prog2, Prog2_Get),
   get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, sys_second_form, Second_form_Get),
   get_var(GEnv, forms, Forms_Get),
   f_sys_first_form(Second_form_Get, C38_rest_Get, Forms_Get, First_form_Ret),
   cl_gensym(Temp_Init),
   LEnv=[bv(sys_temp, Temp_Init)|GEnv],
   get_var(LEnv, sys_first_form, First_form_Get),
   get_var(LEnv, sys_second_form, Second_form_Get11),
   get_var(LEnv, sys_temp, Temp_Get),
   get_var(LEnv, forms, Forms_Get12),
   get_var(LEnv, sys_temp, Temp_Get13),
   bq_append([[[Temp_Get, Second_form_Get11]]|Forms_Get12],
	     [Temp_Get13],
	     Bq_append_Ret),
   f_sys_apropos_defmacro(Prog2_Get,
			  First_form_Ret,
			  [progn, First_form_Get, [let|Bq_append_Ret]],
			  _Ignored).
/*
#+BUILTIN
#+(or WAM-CL LISP500)
(defun equal (a b)
  (or (eql a b)
      (cond
	((not a) nil)
	((consp a) (and (consp b)
			(equal (car a) (car b))
			(equal (cdr a) (cdr b))))
	((stringp a) (and (stringp b)
			  (string= a b)))
	((bit-vector-p a) (and (bit-vector-p b)
			       (= (length a) (length b))
			       (dotimes (i (length a) t)
				 (when (/= (aref a i) (aref b i))
				   (return))))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43287 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,equal,[a,b],[or,[eql,a,b],[cond,[[not,a],[]],[[consp,a],[and,[consp,b],[equal,[car,a],[car,b]],[equal,[cdr,a],[cdr,b]]]],[[stringp,a],[and,[stringp,b],['string=',a,b]]],[['bit-vector-p',a],[and,['bit-vector-p',b],[=,[length,a],[length,b]],[dotimes,[i,[length,a],t],[when,[/=,[aref,a,i],[aref,b,i]],[return]]]]]]]]]]))
/*
#+(or WAM-CL LISP500)
(defun identity (object) object)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43708 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,identity,[object],object]).
wl:lambda_def(defun, identity, cl_identity, [sys_object], [sys_object]).
wl:arglist_info(identity, cl_identity, [sys_object], arginfo{all:[sys_object], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object], opt:0, req:[sys_object], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_identity).

/*

### Compiled:  `CL:IDENTITY` 
*/
cl_identity(Object_In, FnResult) :-
	Env7=[bv(sys_object, Object_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, sys_object, Object_Get),
		Object_Get=FnResult
	      ),
	      block_exit(identity, FnResult),
	      true).
:- set_opv(cl_identity, classof, claz_function),
   set_opv(identity, compile_as, kw_function),
   set_opv(identity, function, cl_identity),
   DefunResult=identity.
/*
:- side_effect(assert_lsp(identity,
			  lambda_def(defun,
				     identity,
				     cl_identity,
				     [sys_object],
				     [sys_object]))).
*/
/*
:- side_effect(assert_lsp(identity,
			  arglist_info(identity,
				       cl_identity,
				       [sys_object],
				       arginfo{ all:[sys_object],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_object],
						opt:0,
						req:[sys_object],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(identity, init_args(exact_only, cl_identity))).
*/
/*
#+(or WAM-CL LISP500)
(defun complement (function)
  #'(lambda (&rest rest) (not (apply function rest))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43767 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,complement,[function],function([lambda,['&rest',rest],[not,[apply,function,rest]]])]).
wl:lambda_def(defun, complement, cl_complement, [function], [function([lambda, [c38_rest, rest], [not, [apply, function, rest]]])]).
wl:arglist_info(complement, cl_complement, [function], arginfo{all:[function], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[function], opt:0, req:[function], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_complement).

/*

### Compiled:  `CL:COMPLEMENT` 
*/
cl_complement(Function_In, FnResult) :-
	Env9=[bv(function, Function_In)|Env],
	global_env(Env),
	catch(closure(LEnv, LResult, [c38_rest, rest],  (cl_function(rest, Not_Param), cl_not(Not_Param, LResult)))=FnResult,
	      block_exit(complement, FnResult),
	      true).
:- set_opv(cl_complement, classof, claz_function),
   set_opv(complement, compile_as, kw_function),
   set_opv(complement, function, cl_complement),
   DefunResult=complement.
/*
:- side_effect(assert_lsp(complement,
			  lambda_def(defun,
				     complement,
				     cl_complement,
				     [function],
				     
				     [ function(
						[ lambda,
						  [c38_rest, rest],
						  [not, [apply, function, rest]]
						]).
				     ]))).
*/
/*
:- side_effect(assert_lsp(complement,
			  arglist_info(complement,
				       cl_complement,
				       [function],
				       arginfo{ all:[function],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[function],
						opt:0,
						req:[function],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(complement, init_args(exact_only, cl_complement))).
*/
/*
#+(or WAM-CL LISP500)
(defun constantly (value) #'(lambda (&rest rest) value))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43878 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,constantly,[value],function([lambda,['&rest',rest],value])]).
wl:lambda_def(defun, constantly, cl_constantly, [sys_value], [function([lambda, [c38_rest, rest], sys_value])]).
wl:arglist_info(constantly, cl_constantly, [sys_value], arginfo{all:[sys_value], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_value], opt:0, req:[sys_value], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_constantly).

/*

### Compiled:  `CL:CONSTANTLY` 
*/
cl_constantly(Value_In, FnResult) :-
	Env10=[bv(sys_value, Value_In)|Env],
	global_env(Env),
	catch(closure(LEnv, Value_Get, [c38_rest, rest], get_var(LEnv, sys_value, Value_Get))=FnResult,
	      block_exit(constantly, FnResult),
	      true).
:- set_opv(cl_constantly, classof, claz_function),
   set_opv(constantly, compile_as, kw_function),
   set_opv(constantly, function, cl_constantly),
   DefunResult=constantly.
/*
:- side_effect(assert_lsp(constantly,
			  lambda_def(defun,
				     constantly,
				     cl_constantly,
				     [sys_value],
				     
				     [ function(
						[ lambda,
						  [c38_rest, rest],
						  sys_value
						]).
				     ]))).
*/
/*
:- side_effect(assert_lsp(constantly,
			  arglist_info(constantly,
				       cl_constantly,
				       [sys_value],
				       arginfo{ all:[sys_value],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_value],
						opt:0,
						req:[sys_value],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(constantly, init_args(exact_only, cl_constantly))).
*/
/*
(apropos-defmacro dotimes ((var count-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(count (gensym)))
    `(block nil
      (let ((,var 0)
	    (,count ,count-form))
	(tagbody
	   ,start
	   (when (< ,var ,count)
	     ,@forms
	     (incf ,var)
	     (go ,start)))
	,result-form))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:43965 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',dotimes,[[var,'count-form','&optional','result-form'],'&rest',forms],[let,[[start,[gensym]],[count,[gensym]]],['#BQ',[block,[],[let,[[['#COMMA',var],0],[['#COMMA',count],['#COMMA','count-form']]],[tagbody,['#COMMA',start],[when,[<,['#COMMA',var],['#COMMA',count]],['#BQ-COMMA-ELIPSE',forms],[incf,['#COMMA',var]],[go,['#COMMA',start]]]],['#COMMA','result-form']]]]]]).
:- get_var(GEnv, dotimes, Dotimes_Get),
   get_var(GEnv, c38_optional, C38_optional_Get),
   get_var(GEnv, sys_count_form, Count_form_Get),
   get_var(GEnv, sys_result_form, Result_form_Get),
   f_sys_var(Count_form_Get, C38_optional_Get, Result_form_Get, Apply_Param),
   get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, forms, Forms_Get),
   cl_apply(Apply_Param, [C38_rest_Get, Forms_Get], Apply_Ret),
   cl_gensym(Start_Init),
   cl_gensym(Count_Init),
   LEnv=[bv(start, Start_Init), bv(count, Count_Init)|GEnv],
   get_var(LEnv, count, Count_Get),
   get_var(LEnv, sys_var, Var_Get),
   get_var(LEnv, start, Start_Get),
   get_var(LEnv, sys_count_form, Count_form_Get14),
   get_var(LEnv, count, Count_Get17),
   get_var(LEnv, sys_var, Var_Get16),
   get_var(LEnv, forms, Forms_Get18),
   get_var(LEnv, start, Start_Get20),
   get_var(LEnv, sys_var, Var_Get19),
   bq_append([[<, Var_Get16, Count_Get17]|Forms_Get18],
	     [[incf, Var_Get19], [go, Start_Get20]],
	     Bq_append_Ret),
   get_var(LEnv, sys_result_form, Result_form_Get21),
   f_sys_apropos_defmacro(Dotimes_Get,
			  Apply_Ret,
			  
			  [ block,
			    [],
			    
			    [ let,
			      [[Var_Get, 0], [Count_Get, Count_form_Get14]],
			      [tagbody, Start_Get, [when|Bq_append_Ret]],
			      Result_form_Get21
			    ]
			  ],
			  _Ignored).
/*
(apropos-defmacro do (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let ,(dolist (var vars (reverse inits))
	    (push (if (consp var)
		      (list (car var) (cadr var))
		      (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((psetq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:44288 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',do,[vars,['end-test-form','&rest','result-forms'],'&rest',forms],[let,[[start,[gensym]],[inits,[]],[steps,[]]],['#BQ',[block,[],[let,['#COMMA',[dolist,[var,vars,[reverse,inits]],[push,[if,[consp,var],[list,[car,var],[cadr,var]],[list,var]],inits]]],[tagbody,['#COMMA',start],[if,['#COMMA','end-test-form'],[return,[progn,['#BQ-COMMA-ELIPSE','result-forms']]]],['#BQ-COMMA-ELIPSE',forms],['#BQ-COMMA-ELIPSE',[dolist,[var,vars,[when,steps,['#BQ',[[psetq,['#BQ-COMMA-ELIPSE',[reverse,steps]]]]]]],[when,[and,[consp,var],[cddr,var]],[push,[car,var],steps],[push,[caddr,var],steps]]]],[go,['#COMMA',start]]]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, do, Do_Get),
   get_var(GEnv, sys_result_forms, Result_forms_Get),
   f_sys_end_test_form(C38_rest_Get, Result_forms_Get, Vars_Param),
   get_var(GEnv, c38_rest, C38_rest_Get4),
   get_var(GEnv, forms, Forms_Get),
   f_sys_vars(Vars_Param, C38_rest_Get4, Forms_Get, Vars_Ret),
   cl_gensym(Start_Init),
   LEnv=[bv(start, Start_Init), bv(sys_inits, []), bv(sys_steps, [])|GEnv],
   get_var(LEnv, sys_inits, Inits_Get),
   LEnv12=[bv(reverse, Inits_Get)|LEnv],
   get_var(LEnv12, sys_vars, Vars_Get),
   BV=bv(sys_var, Ele),
   Env2=[BV|LEnv12],
   forall(member(Ele, Vars_Get),
	  ( nb_setarg(2, BV, Ele),
	    cl_push(
		    [ if,
		      [consp, sys_var],
		      [list, [car, sys_var], [cadr, sys_var]],
		      [list, sys_var]
		    ],
		    sys_inits,
		    Inits)
	  )),
   get_var(LEnv12, sys_inits, Inits_Get20),
   cl_reverse(Inits_Get20, LetResult11),
   get_var(LEnv, start, Start_Get),
   get_var(LEnv, sys_end_test_form, End_test_form_Get),
   get_var(LEnv, forms, Forms_Get24),
   get_var(LEnv, sys_result_forms, Result_forms_Get23),
   LEnv27=[bv([when, sys_steps, ['#BQ', [[psetq, ['#BQ-COMMA-ELIPSE', [reverse, sys_steps]]]]]], [])|LEnv],
   get_var(LEnv27, sys_vars, Vars_Get28),
   BV38=bv(sys_var, Ele40),
   Env239=[BV38|LEnv27],
   forall(member(Ele40, Vars_Get28),
	  ( nb_setarg(2, BV38, Ele40),
	    get_var(Env239, sys_var, Var_Get),
	    (   is_consp(Var_Get)
	    ->  get_var(Env239, sys_var, Var_Get35),
		cl_cddr(Var_Get35, TrueResult),
		IFTEST=TrueResult
	    ;   IFTEST=[]
	    ),
	    (   IFTEST\==[]
	    ->  cl_push([car, sys_var], sys_steps, Steps),
		cl_push([caddr, sys_var], sys_steps, TrueResult37),
		_149502770=TrueResult37
	    ;   _149502770=[]
	    )
	  )),
   get_var(LEnv27, sys_steps, IFTEST42),
   (   IFTEST42\==[]
   ->  get_var(LEnv27, sys_steps, Steps_Get45),
       cl_reverse(Steps_Get45, Reverse_Ret),
       LetResult26=[[psetq|Reverse_Ret]]
   ;   LetResult26=[]
   ),
   get_var(LEnv, start, Start_Get46),
   bq_append(LetResult26, [[go, Start_Get46]], Bq_append_Ret),
   bq_append(
	     [ [if, End_test_form_Get, [return, [progn|Result_forms_Get23]]]
	     | Forms_Get24
	     ],
	     Bq_append_Ret,
	     Bq_append_Ret54),
   f_sys_apropos_defmacro(Do_Get,
			  Vars_Ret,
			  
			  [ block,
			    [],
			    
			    [ let,
			      LetResult11,
			      [tagbody, Start_Get|Bq_append_Ret54]
			    ]
			  ],
			  _Ignored).
/*
(apropos-defmacro do* (vars (end-test-form &rest result-forms) &rest forms)
  (let ((start (gensym))
	(inits nil)
	(steps nil))
  `(block nil
    (let* ,(dolist (var vars (reverse inits))
	     (push (if (consp var)
		       (list (car var) (cadr var))
		       (list var)) inits))
      (tagbody
	 ,start
	 (if ,end-test-form (return (progn ,@result-forms)))
	 ,@forms
	 ,@(dolist (var vars (when steps `((setq ,@(reverse steps)))))
	     (when (and (consp var) (cddr var))
	       (push (car var) steps)
	       (push (caddr var) steps)))
	 (go ,start))))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:44862 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro','do*',[vars,['end-test-form','&rest','result-forms'],'&rest',forms],[let,[[start,[gensym]],[inits,[]],[steps,[]]],['#BQ',[block,[],['let*',['#COMMA',[dolist,[var,vars,[reverse,inits]],[push,[if,[consp,var],[list,[car,var],[cadr,var]],[list,var]],inits]]],[tagbody,['#COMMA',start],[if,['#COMMA','end-test-form'],[return,[progn,['#BQ-COMMA-ELIPSE','result-forms']]]],['#BQ-COMMA-ELIPSE',forms],['#BQ-COMMA-ELIPSE',[dolist,[var,vars,[when,steps,['#BQ',[[setq,['#BQ-COMMA-ELIPSE',[reverse,steps]]]]]]],[when,[and,[consp,var],[cddr,var]],[push,[car,var],steps],[push,[caddr,var],steps]]]],[go,['#COMMA',start]]]]]]]]).
:- get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, do_xx, Do_xx_Get),
   get_var(GEnv, sys_result_forms, Result_forms_Get),
   f_sys_end_test_form(C38_rest_Get, Result_forms_Get, Vars_Param),
   get_var(GEnv, c38_rest, C38_rest_Get4),
   get_var(GEnv, forms, Forms_Get),
   f_sys_vars(Vars_Param, C38_rest_Get4, Forms_Get, Vars_Ret),
   cl_gensym(Start_Init),
   LEnv=[bv(start, Start_Init), bv(sys_inits, []), bv(sys_steps, [])|GEnv],
   get_var(LEnv, sys_inits, Inits_Get),
   LEnv12=[bv(reverse, Inits_Get)|LEnv],
   get_var(LEnv12, sys_vars, Vars_Get),
   BV=bv(sys_var, Ele),
   Env2=[BV|LEnv12],
   forall(member(Ele, Vars_Get),
	  ( nb_setarg(2, BV, Ele),
	    cl_push(
		    [ if,
		      [consp, sys_var],
		      [list, [car, sys_var], [cadr, sys_var]],
		      [list, sys_var]
		    ],
		    sys_inits,
		    Inits)
	  )),
   get_var(LEnv12, sys_inits, Inits_Get20),
   cl_reverse(Inits_Get20, LetResult11),
   get_var(LEnv, start, Start_Get),
   get_var(LEnv, sys_end_test_form, End_test_form_Get),
   get_var(LEnv, forms, Forms_Get24),
   get_var(LEnv, sys_result_forms, Result_forms_Get23),
   LEnv27=[bv([when, sys_steps, ['#BQ', [[setq, ['#BQ-COMMA-ELIPSE', [reverse, sys_steps]]]]]], [])|LEnv],
   get_var(LEnv27, sys_vars, Vars_Get28),
   BV38=bv(sys_var, Ele40),
   Env239=[BV38|LEnv27],
   forall(member(Ele40, Vars_Get28),
	  ( nb_setarg(2, BV38, Ele40),
	    get_var(Env239, sys_var, Var_Get),
	    (   is_consp(Var_Get)
	    ->  get_var(Env239, sys_var, Var_Get35),
		cl_cddr(Var_Get35, TrueResult),
		IFTEST=TrueResult
	    ;   IFTEST=[]
	    ),
	    (   IFTEST\==[]
	    ->  cl_push([car, sys_var], sys_steps, Steps),
		cl_push([caddr, sys_var], sys_steps, TrueResult37),
		_150654198=TrueResult37
	    ;   _150654198=[]
	    )
	  )),
   get_var(LEnv27, sys_steps, IFTEST42),
   (   IFTEST42\==[]
   ->  get_var(LEnv27, sys_steps, Steps_Get45),
       cl_reverse(Steps_Get45, Reverse_Ret),
       LetResult26=[[setq|Reverse_Ret]]
   ;   LetResult26=[]
   ),
   get_var(LEnv, start, Start_Get46),
   bq_append(LetResult26, [[go, Start_Get46]], Bq_append_Ret),
   bq_append(
	     [ [if, End_test_form_Get, [return, [progn|Result_forms_Get23]]]
	     | Forms_Get24
	     ],
	     Bq_append_Ret,
	     Bq_append_Ret54),
   f_sys_apropos_defmacro(Do_xx_Get,
			  Vars_Ret,
			  
			  [ block,
			    [],
			    
			    [ let_xx,
			      LetResult11,
			      [tagbody, Start_Get|Bq_append_Ret54]
			    ]
			  ],
			  _Ignored).
/*
(apropos-defmacro dolist ((var list-form &optional result-form) &rest forms)
  (let ((start (gensym))
	(list (gensym)))
    `(block nil
      (let ((,list ,list-form)
	    (,var nil))
	(tagbody
	   ,start
	   (unless ,list
	     (setf ,var nil)
	     (return-from nil ,result-form))
	   (setf ,var (car ,list))
	   (setf ,list (cdr ,list))
	   ,@forms
	   (go ,start))))))





*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:45446 **********************/
:-lisp_compile_to_prolog(pkg_sys,['apropos-defmacro',dolist,[[var,'list-form','&optional','result-form'],'&rest',forms],[let,[[start,[gensym]],[list,[gensym]]],['#BQ',[block,[],[let,[[['#COMMA',list],['#COMMA','list-form']],[['#COMMA',var],[]]],[tagbody,['#COMMA',start],[unless,['#COMMA',list],[setf,['#COMMA',var],[]],['return-from',[],['#COMMA','result-form']]],[setf,['#COMMA',var],[car,['#COMMA',list]]],[setf,['#COMMA',list],[cdr,['#COMMA',list]]],['#BQ-COMMA-ELIPSE',forms],[go,['#COMMA',start]]]]]]]]).
:- get_var(GEnv, dolist, Dolist_Get),
   get_var(GEnv, c38_optional, C38_optional_Get),
   get_var(GEnv, sys_list_form, List_form_Get),
   get_var(GEnv, sys_result_form, Result_form_Get),
   f_sys_var(List_form_Get, C38_optional_Get, Result_form_Get, Apply_Param),
   get_var(GEnv, c38_rest, C38_rest_Get),
   get_var(GEnv, forms, Forms_Get),
   cl_apply(Apply_Param, [C38_rest_Get, Forms_Get], Apply_Ret),
   cl_gensym(Start_Init),
   cl_gensym(List_Init),
   LEnv=[bv(start, Start_Init), bv(list, List_Init)|GEnv],
   get_var(LEnv, list, List_Get),
   get_var(LEnv, sys_list_form, List_form_Get13),
   get_var(LEnv, start, Start_Get),
   get_var(LEnv, sys_var, Var_Get),
   get_var(LEnv, list, List_Get16),
   get_var(LEnv, sys_result_form, Result_form_Get18),
   get_var(LEnv, sys_var, Var_Get17),
   get_var(LEnv, list, List_Get20),
   get_var(LEnv, sys_var, Var_Get19),
   get_var(LEnv, forms, Forms_Get23),
   get_var(LEnv, list, List_Get21),
   get_var(LEnv, start, Start_Get24),
   bq_append([[setf, List_Get21, [cdr, List_Get21]]|Forms_Get23],
	     [[go, Start_Get24]],
	     Bq_append_Ret),
   f_sys_apropos_defmacro(Dolist_Get,
			  Apply_Ret,
			  
			  [ block,
			    [],
			    
			    [ let,
			      [[List_Get, List_form_Get13], [Var_Get, []]],
			      
			      [ tagbody,
				Start_Get,
				
				[ unless,
				  List_Get16,
				  [setf, Var_Get17, []],
				  [return_from, [], Result_form_Get18]
				],
				[setf, Var_Get19, [car, List_Get20]]
			      | Bq_append_Ret
			      ]
			    ]
			  ],
			  _Ignored).
/*
#+(or WAM-CL LISP500) 
(defmacro check-type (place typespec &optional string)
  `(tagbody
    start
    (unless (typep ,place ',typespec)
      (restart-case
	  (error 'type-error :datum ,place :expected-type ',typespec)
	(store-value (value)
	  (setf ,place value)))
      (go start))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:45844 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'check-type',[place,typespec,'&optional',string],['#BQ',[tagbody,start,[unless,[typep,['#COMMA',place],[quote,['#COMMA',typespec]]],['restart-case',[error,[quote,'type-error'],':datum',['#COMMA',place],':expected-type',[quote,['#COMMA',typespec]]],['store-value',[value],[setf,['#COMMA',place],value]]],[go,start]]]]]).
wl:lambda_def(defmacro, check_type, cl_check_type, [sys_place, sys_typespec, c38_optional, string], [progn, ['#BQ', [tagbody, start, [unless, [typep, ['#COMMA', sys_place], [quote, ['#COMMA', sys_typespec]]], [restart_case, [error, [quote, type_error], kw_datum, ['#COMMA', sys_place], kw_expected_type, [quote, ['#COMMA', sys_typespec]]], [store_value, [sys_value], [setf, ['#COMMA', sys_place], sys_value]]], [go, start]]]]]).
wl:arglist_info(check_type, cl_check_type, [sys_place, sys_typespec, c38_optional, string], arginfo{all:[sys_place, sys_typespec, string], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_place, sys_typespec, string], opt:[string], req:[sys_place, sys_typespec], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_check_type).

/*

### Compiled:  `CL:CHECK-TYPE` 
*/
cl_check_type(Place_In, Typespec_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_place, Place_In), bv(sys_typespec, Typespec_In), bv(string, String_In)|Opt_var_Param],
	global_env(Opt_var_Param),
	opt_var(Opt_var_Param, string, String_In, true, [], 1, RestNKeys),
	catch(( get_var(Env, sys_place, Place_Get),
		get_var(Env, sys_place, Place_Get10),
		get_var(Env, sys_typespec, Typespec_Get),
		get_var(Env, sys_place, Place_Get12),
		get_var(Env, sys_typespec, Typespec_Get11),
		[tagbody, start, [unless, [typep, Place_Get, [quote, Typespec_Get]], [restart_case, [error, [quote, type_error], kw_datum, Place_Get10, kw_expected_type, [quote, Typespec_Get11]], [store_value, [sys_value], [setf, Place_Get12, sys_value]]], [go, start]]]=MFResult
	      ),
	      block_exit(check_type, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_check_type, classof, claz_macro),
   set_opv(check_type, compile_as, kw_operator),
   set_opv(check_type, function, cl_check_type),
   DefMacroResult=check_type.
/*
:- side_effect(assert_lsp(check_type,
			  lambda_def(defmacro,
				     check_type,
				     cl_check_type,
				     
				     [ sys_place,
				       sys_typespec,
				       c38_optional,
				       string
				     ],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ tagbody,
					   start,
					   
					   [ unless,
					     
					     [ typep,
					       ['#COMMA', sys_place],
					       [quote, ['#COMMA', sys_typespec]]
					     ],
					     
					     [ restart_case,
					       
					       [ error,
						 [quote, type_error],
						 kw_datum,
						 ['#COMMA', sys_place],
						 kw_expected_type,
						 
						 [ quote,
						   ['#COMMA', sys_typespec]
						 ]
					       ],
					       
					       [ store_value,
						 [sys_value],
						 
						 [ setf,
						   ['#COMMA', sys_place],
						   sys_value
						 ]
					       ]
					     ],
					     [go, start]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(check_type,
			  arglist_info(check_type,
				       cl_check_type,
				       
				       [ sys_place,
					 sys_typespec,
					 c38_optional,
					 string
				       ],
				       arginfo{ all:
						    [ sys_place,
						      sys_typespec,
						      string
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_place,
							sys_typespec,
							string
						      ],
						opt:[string],
						req:[sys_place, sys_typespec],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(check_type, init_args(2, cl_check_type))).
*/
/*
#+(or WAM-CL LISP500)
(defun designator-condition (default-type datum arguments)
  (if (symbolp datum)
      (apply #'make-condition datum arguments)
      (if (or (stringp datum) (functionp datum))
	  (make-condition default-type
			  :format-control datum
			  :format-arguments arguments)
	  datum)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:46146 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'designator-condition',['default-type',datum,arguments],[if,[symbolp,datum],[apply,function('make-condition'),datum,arguments],[if,[or,[stringp,datum],[functionp,datum]],['make-condition','default-type',':format-control',datum,':format-arguments',arguments],datum]]]).
wl:lambda_def(defun, sys_designator_condition, f_sys_designator_condition, [sys_default_type, sys_datum, sys_arguments], [[if, [symbolp, sys_datum], [apply, function(make_condition), sys_datum, sys_arguments], [if, [or, [stringp, sys_datum], [functionp, sys_datum]], [make_condition, sys_default_type, kw_format_control, sys_datum, kw_format_arguments, sys_arguments], sys_datum]]]).
wl:arglist_info(sys_designator_condition, f_sys_designator_condition, [sys_default_type, sys_datum, sys_arguments], arginfo{all:[sys_default_type, sys_datum, sys_arguments], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_default_type, sys_datum, sys_arguments], opt:0, req:[sys_default_type, sys_datum, sys_arguments], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_designator_condition).

/*

### Compiled:  `SYS::DESIGNATOR-CONDITION` 
*/
f_sys_designator_condition(Default_type_In, Datum_In, Arguments_In, FnResult) :-
	Env27=[bv(sys_default_type, Default_type_In), bv(sys_datum, Datum_In), bv(sys_arguments, Arguments_In)|Env],
	global_env(Env),
	catch(( get_var(Env27, sys_datum, Datum_Get),
		(   is_symbolp(Datum_Get)
		->  get_var(Env27, sys_arguments, Arguments_Get),
		    get_var(Env27, sys_datum, Datum_Get10),
		    cl_make_condition(Datum_Get10, Arguments_Get, TrueResult23),
		    _153370734=TrueResult23
		;   (   get_var(Env27, sys_datum, Datum_Get14),
			cl_stringp(Datum_Get14, FORM1_Res),
			FORM1_Res\==[],
			IFTEST12=FORM1_Res
		    ->  true
		    ;   get_var(Env27, sys_datum, Datum_Get15),
			cl_functionp(Datum_Get15, Functionp_Ret),
			IFTEST12=Functionp_Ret
		    ),
		    (   IFTEST12\==[]
		    ->  get_var(Env27, sys_datum, Datum_Get18),
			get_var(Env27, sys_default_type, Default_type_Get),
			get_var(Env27, sys_arguments, Arguments_Get19),
			cl_make_condition(Default_type_Get,
					  kw_format_control,
					  Datum_Get18,
					  kw_format_arguments,
					  Arguments_Get19,
					  TrueResult),
			ElseResult24=TrueResult
		    ;   get_var(Env27, sys_datum, Datum_Get20),
			ElseResult24=Datum_Get20
		    ),
		    _153370734=ElseResult24
		),
		_153370734=FnResult
	      ),
	      block_exit(sys_designator_condition, FnResult),
	      true).
:- set_opv(f_sys_designator_condition, classof, claz_function),
   set_opv(sys_designator_condition, compile_as, kw_function),
   set_opv(sys_designator_condition, function, f_sys_designator_condition),
   DefunResult=sys_designator_condition.
/*
:- side_effect(assert_lsp(sys_designator_condition,
			  lambda_def(defun,
				     sys_designator_condition,
				     f_sys_designator_condition,
				     
				     [ sys_default_type,
				       sys_datum,
				       sys_arguments
				     ],
				     
				     [ 
				       [ if,
					 [symbolp, sys_datum],
					 
					 [ apply,
					   function(make_condition),
					   sys_datum,
					   sys_arguments
					 ],
					 
					 [ if,
					   
					   [ or,
					     [stringp, sys_datum],
					     [functionp, sys_datum]
					   ],
					   
					   [ make_condition,
					     sys_default_type,
					     kw_format_control,
					     sys_datum,
					     kw_format_arguments,
					     sys_arguments
					   ],
					   sys_datum
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_designator_condition,
			  arglist_info(sys_designator_condition,
				       f_sys_designator_condition,
				       
				       [ sys_default_type,
					 sys_datum,
					 sys_arguments
				       ],
				       arginfo{ all:
						    [ sys_default_type,
						      sys_datum,
						      sys_arguments
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_default_type,
							sys_datum,
							sys_arguments
						      ],
						opt:0,
						req:
						    [ sys_default_type,
						      sys_datum,
						      sys_arguments
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_designator_condition,
			  init_args(exact_only, f_sys_designator_condition))).
*/
/*
#+(or WAM-CL LISP500) 
(defun error (datum &rest arguments)
  (let ((condition (designator-condition 'simple-error datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    (invoke-debugger condition)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:46461 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,error,[datum,'&rest',arguments],[let,[[condition,['designator-condition',[quote,'simple-error'],datum,arguments]]],[when,[typep,condition,'*break-on-signals*'],['invoke-debugger',condition]],['invoke-handler',condition],['invoke-debugger',condition]]]).
wl:lambda_def(defun, error, cl_error, [sys_datum, c38_rest, sys_arguments], [[let, [[condition, [sys_designator_condition, [quote, simple_error], sys_datum, sys_arguments]]], [when, [typep, condition, xx_break_on_signals_xx], [invoke_debugger, condition]], [sys_invoke_handler, condition], [invoke_debugger, condition]]]).
wl:arglist_info(error, cl_error, [sys_datum, c38_rest, sys_arguments], arginfo{all:[sys_datum], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_datum, sys_arguments], opt:0, req:[sys_datum], rest:[sys_arguments], sublists:0, whole:0}).
wl: init_args(0, cl_error).

/*

### Compiled:  `CL:ERROR` 
*/
cl_error(Error_Param, FnResult) :-
	Env22=[bv(sys_datum, Datum_In), bv(sys_arguments, RestNKeys)|Env],
	global_env(Env),
	append([Datum_In], RestNKeys, Error_Param),
	catch(( get_var(Env22, sys_arguments, Arguments_Get),
		get_var(Env22, sys_datum, Datum_Get),
		f_sys_designator_condition(simple_error,
					   Datum_Get,
					   Arguments_Get,
					   Condition_Init),
		LEnv=[bv(condition, Condition_Init)|Env22],
		get_var(LEnv, condition, Condition_Get),
		get_var(LEnv,
			xx_break_on_signals_xx,
			Xx_break_on_signals_xx_Get),
		cl_typep(Condition_Get, Xx_break_on_signals_xx_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, condition, Condition_Get16),
		    cl_invoke_debugger(Condition_Get16, TrueResult),
		    _154425240=TrueResult
		;   _154425240=[]
		),
		get_var(LEnv, condition, Condition_Get18),
		f_sys_invoke_handler(Condition_Get18, Invoke_handler_Ret),
		get_var(LEnv, condition, Condition_Get19),
		cl_invoke_debugger(Condition_Get19, LetResult),
		LetResult=FnResult
	      ),
	      block_exit(error, FnResult),
	      true).
:- set_opv(cl_error, classof, claz_function),
   set_opv(error, compile_as, kw_function),
   set_opv(error, function, cl_error),
   DefunResult=error.
/*
:- side_effect(assert_lsp(error,
			  lambda_def(defun,
				     error,
				     cl_error,
				     [sys_datum, c38_rest, sys_arguments],
				     
				     [ 
				       [ let,
					 
					 [ 
					   [ condition,
					     
					     [ sys_designator_condition,
					       [quote, simple_error],
					       sys_datum,
					       sys_arguments
					     ]
					   ]
					 ],
					 
					 [ when,
					   
					   [ typep,
					     condition,
					     xx_break_on_signals_xx
					   ],
					   [invoke_debugger, condition]
					 ],
					 [sys_invoke_handler, condition],
					 [invoke_debugger, condition]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(error,
			  arglist_info(error,
				       cl_error,
				       [sys_datum, c38_rest, sys_arguments],
				       arginfo{ all:[sys_datum],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_datum,
							sys_arguments
						      ],
						opt:0,
						req:[sys_datum],
						rest:[sys_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(error, init_args(0, cl_error))).
*/
/*
#+(or WAM-CL LISP500) 
(defun cerror (continue-format-control datum &rest arguments)
  `(with-simple-restart (continue continue-format-control)
    (apply #'error datum arguments)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:46751 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,cerror,['continue-format-control',datum,'&rest',arguments],['#BQ',['with-simple-restart',[continue,'continue-format-control'],[apply,function(error),datum,arguments]]]]).
wl:lambda_def(defun, cerror, cl_cerror, [sys_continue_format_control, sys_datum, c38_rest, sys_arguments], [['#BQ', [with_simple_restart, [continue, sys_continue_format_control], [apply, function(error), sys_datum, sys_arguments]]]]).
wl:arglist_info(cerror, cl_cerror, [sys_continue_format_control, sys_datum, c38_rest, sys_arguments], arginfo{all:[sys_continue_format_control, sys_datum], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_continue_format_control, sys_datum, sys_arguments], opt:0, req:[sys_continue_format_control, sys_datum], rest:[sys_arguments], sublists:0, whole:0}).
wl: init_args(2, cl_cerror).

/*

### Compiled:  `CL:CERROR` 
*/
cl_cerror(Continue_format_control_In, Datum_In, RestNKeys, FnResult) :-
	Env9=[bv(sys_continue_format_control, Continue_format_control_In), bv(sys_datum, Datum_In), bv(sys_arguments, RestNKeys)|Env],
	global_env(Env),
	catch([with_simple_restart, [continue, sys_continue_format_control], [apply, function(error), sys_datum, sys_arguments]]=FnResult,
	      block_exit(cerror, FnResult),
	      true).
:- set_opv(cl_cerror, classof, claz_function),
   set_opv(cerror, compile_as, kw_function),
   set_opv(cerror, function, cl_cerror),
   DefunResult=cerror.
/*
:- side_effect(assert_lsp(cerror,
			  lambda_def(defun,
				     cerror,
				     cl_cerror,
				     
				     [ sys_continue_format_control,
				       sys_datum,
				       c38_rest,
				       sys_arguments
				     ],
				     
				     [ 
				       [ '#BQ',
					 
					 [ with_simple_restart,
					   
					   [ continue,
					     sys_continue_format_control
					   ],
					   
					   [ apply,
					     function(error),
					     sys_datum,
					     sys_arguments
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(cerror,
			  arglist_info(cerror,
				       cl_cerror,
				       
				       [ sys_continue_format_control,
					 sys_datum,
					 c38_rest,
					 sys_arguments
				       ],
				       arginfo{ all:
						    [ sys_continue_format_control,
						      sys_datum
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_continue_format_control,
							sys_datum,
							sys_arguments
						      ],
						opt:0,
						req:
						    [ sys_continue_format_control,
						      sys_datum
						    ],
						rest:[sys_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(cerror, init_args(2, cl_cerror))).
*/
/*
#+(or WAM-CL LISP500) 
(defun signal (datum &rest arguments)
  (let ((condition (designator-condition 'simple-condition datum arguments)))
    (when (typep condition *break-on-signals*)
      (invoke-debugger condition))
    (invoke-handler condition)
    nil))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:46939 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,signal,[datum,'&rest',arguments],[let,[[condition,['designator-condition',[quote,'simple-condition'],datum,arguments]]],[when,[typep,condition,'*break-on-signals*'],['invoke-debugger',condition]],['invoke-handler',condition],[]]]).
wl:lambda_def(defun, signal, cl_signal, [sys_datum, c38_rest, sys_arguments], [[let, [[condition, [sys_designator_condition, [quote, simple_condition], sys_datum, sys_arguments]]], [when, [typep, condition, xx_break_on_signals_xx], [invoke_debugger, condition]], [sys_invoke_handler, condition], []]]).
wl:arglist_info(signal, cl_signal, [sys_datum, c38_rest, sys_arguments], arginfo{all:[sys_datum], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_datum, sys_arguments], opt:0, req:[sys_datum], rest:[sys_arguments], sublists:0, whole:0}).
wl: init_args(1, cl_signal).

/*

### Compiled:  `CL:SIGNAL` 
*/
cl_signal(Datum_In, RestNKeys, FnResult) :-
	Env21=[bv(sys_datum, Datum_In), bv(sys_arguments, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env21, sys_arguments, Arguments_Get),
		get_var(Env21, sys_datum, Datum_Get),
		f_sys_designator_condition(simple_condition,
					   Datum_Get,
					   Arguments_Get,
					   Condition_Init),
		LEnv=[bv(condition, Condition_Init)|Env21],
		get_var(LEnv, condition, Condition_Get),
		get_var(LEnv,
			xx_break_on_signals_xx,
			Xx_break_on_signals_xx_Get),
		cl_typep(Condition_Get, Xx_break_on_signals_xx_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, condition, Condition_Get16),
		    cl_invoke_debugger(Condition_Get16, TrueResult),
		    _156178000=TrueResult
		;   _156178000=[]
		),
		get_var(LEnv, condition, Condition_Get18),
		f_sys_invoke_handler(Condition_Get18, Invoke_handler_Ret),
		[]=FnResult
	      ),
	      block_exit(signal, FnResult),
	      true).
:- set_opv(cl_signal, classof, claz_function),
   set_opv(signal, compile_as, kw_function),
   set_opv(signal, function, cl_signal),
   DefunResult=signal.
/*
:- side_effect(assert_lsp(signal,
			  lambda_def(defun,
				     signal,
				     cl_signal,
				     [sys_datum, c38_rest, sys_arguments],
				     
				     [ 
				       [ let,
					 
					 [ 
					   [ condition,
					     
					     [ sys_designator_condition,
					       [quote, simple_condition],
					       sys_datum,
					       sys_arguments
					     ]
					   ]
					 ],
					 
					 [ when,
					   
					   [ typep,
					     condition,
					     xx_break_on_signals_xx
					   ],
					   [invoke_debugger, condition]
					 ],
					 [sys_invoke_handler, condition],
					 []
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(signal,
			  arglist_info(signal,
				       cl_signal,
				       [sys_datum, c38_rest, sys_arguments],
				       arginfo{ all:[sys_datum],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_datum,
							sys_arguments
						      ],
						opt:0,
						req:[sys_datum],
						rest:[sys_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(signal, init_args(1, cl_signal))).
*/
/*
#+(or WAM-CL LISP500) 
(defun warn (datum &rest arguments)
  (restart-case
      (let ((warning (if (symbolp datum)
			 (apply #'make-condition 'warning datum arguments)
			 datum)))
	(signal warning)
	(print-object warning *error-output*))
    (muffle-warning () nil))
  nil)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:47210 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,warn,[datum,'&rest',arguments],['restart-case',[let,[[warning,[if,[symbolp,datum],[apply,function('make-condition'),[quote,warning],datum,arguments],datum]]],[signal,warning],['print-object',warning,'*error-output*']],['muffle-warning',[],[]]],[]]).
wl:lambda_def(defun, warn, cl_warn, [sys_datum, c38_rest, sys_arguments], [[restart_case, [let, [[warning, [if, [symbolp, sys_datum], [apply, function(make_condition), [quote, warning], sys_datum, sys_arguments], sys_datum]]], [signal, warning], [print_object, warning, xx_error_output_xx]], [muffle_warning, [], []]], []]).
wl:arglist_info(warn, cl_warn, [sys_datum, c38_rest, sys_arguments], arginfo{all:[sys_datum], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_datum, sys_arguments], opt:0, req:[sys_datum], rest:[sys_arguments], sublists:0, whole:0}).
wl: init_args(1, cl_warn).

/*

### Compiled:  `CL:WARN` 
*/
cl_warn(Datum_In, RestNKeys, FnResult) :-
	Env8=[bv(sys_datum, Datum_In), bv(sys_arguments, RestNKeys)|Env],
	global_env(Env),
	catch(( cl_restart_case(
				[ let,
				  
				  [ 
				    [ warning,
				      
				      [ if,
					[symbolp, sys_datum],
					
					[ apply,
					  function(make_condition),
					  [quote, warning],
					  sys_datum,
					  sys_arguments
					],
					sys_datum
				      ]
				    ]
				  ],
				  [signal, warning],
				  [print_object, warning, xx_error_output_xx]
				],
				[muffle_warning, [], []],
				Restart_case_Ret),
		[]=FnResult
	      ),
	      block_exit(warn, FnResult),
	      true).
:- set_opv(cl_warn, classof, claz_function),
   set_opv(warn, compile_as, kw_function),
   set_opv(warn, function, cl_warn),
   DefunResult=warn.
/*
:- side_effect(assert_lsp(warn,
			  lambda_def(defun,
				     warn,
				     cl_warn,
				     [sys_datum, c38_rest, sys_arguments],
				     
				     [ 
				       [ restart_case,
					 
					 [ let,
					   
					   [ 
					     [ warning,
					       
					       [ if,
						 [symbolp, sys_datum],
						 
						 [ apply,
						   function(make_condition),
						   [quote, warning],
						   sys_datum,
						   sys_arguments
						 ],
						 sys_datum
					       ]
					     ]
					   ],
					   [signal, warning],
					   
					   [ print_object,
					     warning,
					     xx_error_output_xx
					   ]
					 ],
					 [muffle_warning, [], []]
				       ],
				       []
				     ]))).
*/
/*
:- side_effect(assert_lsp(warn,
			  arglist_info(warn,
				       cl_warn,
				       [sys_datum, c38_rest, sys_arguments],
				       arginfo{ all:[sys_datum],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_datum,
							sys_arguments
						      ],
						opt:0,
						req:[sys_datum],
						rest:[sys_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(warn, init_args(1, cl_warn))).
*/
/*
#+(or WAM-CL LISP500) 
(defun invoke-debugger (condition)
  (let ((debugger-hook *debugger-hook*)
	(*debugger-hook* nil))
    (when debugger-hook
      (funcall debugger-hook condition debugger-hook))
    (format *debug-io* "Entering debugger."#+(or WAM-CL LISP500) \r\n(defun invoke-debugger (condition)\r\n  (let ((debugger-hook *debugger-hook*)\r\n\t(*debugger-hook* nil))\r\n    (when debugger-hook\r\n      (funcall debugger-hook condition debugger-hook))\r\n    (format *debug-io* \"Entering debugger.~%\")\r\n    (princ condition *debug-io*)\r\n    (terpri *debug-io*)\r\n    (let ((restarts (compute-restarts condition))\r\n\t  (stack (makef))\r\n\t  (frame-depth 0)\r\n\t  (active-frame nil))\r\n      (let ((count 0))\r\n\t(dolist (restart restarts)\r\n\t  (format *debug-io* \"~A: \" count)\r\n\t  (princ restart *debug-io*)\r\n\t  (terpri *debug-io*)\r\n\t  (incf count)))\r\n      (setq active-frame (next-function-frame (- stack 20)))\r\n      (show-frame active-frame 0)\r\n      (tagbody\r\n       start\r\n\t (format *debug-io* \";~A> \" frame-depth)\r\n\t (let ((form (read)))\r\n\t   (case form\r\n\t     (:help (format *debug-io* \"Type :help to get help.~%\")\r\n\t\t    (format *debug-io* \"Type :continue <index> to invoke the indexed restart.~%\"))\r\n\t     (:back (do ((frame (next-function-frame (- stack 20))\r\n\t\t\t\t(next-function-frame frame))\r\n\t\t\t (index 0 (+ 1 index)))\r\n\t\t\t((not frame))\r\n\t\t      (show-frame frame index)))\r\n\t     (:up (if (plusp frame-depth)\r\n\t\t      (progn\r\n\t\t\t(decf frame-depth)\r\n\t\t\t(do ((frame (next-function-frame (- stack 20))\r\n\t\t\t\t    (next-function-frame frame))\r\n\t\t\t     (index 0 (+ 1 index)))\r\n\t\t\t    ((= index frame-depth) (setq active-frame frame)))\r\n\t\t\t(show-frame active-frame frame-depth))\r\n\t\t      (format *debug-io* \"Top of stack.~%\")))\r\n\t     (:down (let ((frame (next-function-frame active-frame)))\r\n\t\t      (if frame\r\n\t\t\t  (progn\r\n\t\t\t    (incf frame-depth)\r\n\t\t\t    (setq active-frame frame)\r\n\t\t\t    (show-frame active-frame frame-depth))\r\n\t\t\t  (format *debug-io* \"Bottom of stack.~%\"))))\r\n\t     (:locals (do ((env (fref (- active-frame 1)) (cdr env)))\r\n\t\t\t  ((not env))\r\n\t\t\t(when (symbolp (caar env))\r\n\t\t\t  (format *debug-io* \"~A~%\" (caar env)))))\r\n\t     (:continue (let ((index (read)))\r\n\t\t\t  (invoke-restart-interactively (nth index restarts))))\r\n\t     (t (let ((values (multiple-value-list\r\n\t\t\t       (eval form (fref (- active-frame 1)))))\r\n\t\t      (count 0))\r\n\t\t  (if values\r\n\t\t      (dolist (value values)\r\n\t\t\t(format *debug-io* \";~A: ~S~%\" count value)\r\n\t\t\t(incf count))\r\n\t\t      (format *debug-io* \";No values.~%\")))))\r\n\t   (go start))))))\r\n\r\n\r\n\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:47503 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'invoke-debugger',[condition],[let,[['debugger-hook','*debugger-hook*'],['*debugger-hook*',[]]],[when,'debugger-hook',[funcall,'debugger-hook',condition,'debugger-hook']],[format,'*debug-io*','$STRING'("Entering debugger.~%")],[princ,condition,'*debug-io*'],[terpri,'*debug-io*'],[let,[[restarts,['compute-restarts',condition]],[stack,[makef]],['frame-depth',0],['active-frame',[]]],[let,[[count,0]],[dolist,[restart,restarts],[format,'*debug-io*','$STRING'("~A: "),count],[princ,restart,'*debug-io*'],[terpri,'*debug-io*'],[incf,count]]],[setq,'active-frame',['next-function-frame',[-,stack,20]]],['show-frame','active-frame',0],[tagbody,start,[format,'*debug-io*','$STRING'(";~A> "),'frame-depth'],[let,[[form,[read]]],[case,form,[':help',[format,'*debug-io*','$STRING'("Type :help to get help.~%")],[format,'*debug-io*','$STRING'("Type :continue <index> to invoke the indexed restart.~%")]],[':back',[do,[[frame,['next-function-frame',[-,stack,20]],['next-function-frame',frame]],[index,0,[+,1,index]]],[[not,frame]],['show-frame',frame,index]]],[':up',[if,[plusp,'frame-depth'],[progn,[decf,'frame-depth'],[do,[[frame,['next-function-frame',[-,stack,20]],['next-function-frame',frame]],[index,0,[+,1,index]]],[[=,index,'frame-depth'],[setq,'active-frame',frame]]],['show-frame','active-frame','frame-depth']],[format,'*debug-io*','$STRING'("Top of stack.~%")]]],[':down',[let,[[frame,['next-function-frame','active-frame']]],[if,frame,[progn,[incf,'frame-depth'],[setq,'active-frame',frame],['show-frame','active-frame','frame-depth']],[format,'*debug-io*','$STRING'("Bottom of stack.~%")]]]],[':locals',[do,[[env,[fref,[-,'active-frame',1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,'*debug-io*','$STRING'("~A~%"),[caar,env]]]]],[':continue',[let,[[index,[read]]],['invoke-restart-interactively',[nth,index,restarts]]]],[t,[let,[[values,['multiple-value-list',[eval,form,[fref,[-,'active-frame',1]]]]],[count,0]],[if,values,[dolist,[value,values],[format,'*debug-io*','$STRING'(";~A: ~S~%"),count,value],[incf,count]],[format,'*debug-io*','$STRING'(";No values.~%")]]]]],[go,start]]]]]]).
/*
% case:-[[kw_help,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]],[kw_back,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]],[kw_up,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]],[kw_down,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]],[kw_locals,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]],[kw_continue,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]],[t,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]].
*/
/*
% conds:-[[[eq,_158510974,[quote,kw_help]],[progn,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]]],[[eq,_158510974,[quote,kw_back]],[progn,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]]],[[eq,_158510974,[quote,kw_up]],[progn,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]]],[[eq,_158510974,[quote,kw_down]],[progn,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]]],[[eq,_158510974,[quote,kw_locals]],[progn,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]]],[[eq,_158510974,[quote,kw_continue]],[progn,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]]],[t,[progn,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]]].
*/
/*
% case:-[[kw_help,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]],[kw_back,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]],[kw_up,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]],[kw_down,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]],[kw_locals,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]],[kw_continue,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]],[t,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]].
*/
/*
% conds:-[[[eq,_161452978,[quote,kw_help]],[progn,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]]],[[eq,_161452978,[quote,kw_back]],[progn,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]]],[[eq,_161452978,[quote,kw_up]],[progn,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]]],[[eq,_161452978,[quote,kw_down]],[progn,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]]],[[eq,_161452978,[quote,kw_locals]],[progn,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]]],[[eq,_161452978,[quote,kw_continue]],[progn,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]]],[t,[progn,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]]].
*/
wl:lambda_def(defun,invoke_debugger,cl_invoke_debugger,[condition],[[let,[[sys_debugger_hook,xx_debugger_hook_xx],[xx_debugger_hook_xx,[]]],[when,sys_debugger_hook,[funcall,sys_debugger_hook,condition,sys_debugger_hook]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Entering debugger.~%")],[princ,condition,xx_debug_io_xx],[terpri,xx_debug_io_xx],[let,[[sys_restarts,[compute_restarts,condition]],[sys_stack,[sys_makef]],[sys_frame_depth,0],[sys_active_frame,[]]],[let,[[count,0]],[dolist,[restart,sys_restarts],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A: "),count],[princ,restart,xx_debug_io_xx],[terpri,xx_debug_io_xx],[incf,count]]],[setq,sys_active_frame,[sys_next_function_frame,[-,sys_stack,20]]],[sys_show_frame,sys_active_frame,0],[tagbody,start,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A> "),sys_frame_depth],[let,[[sys_form,[read]]],[case,sys_form,[kw_help,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]],[kw_back,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]],[kw_up,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]],[kw_down,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]],[kw_locals,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]],[kw_continue,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]],[t,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]],[go,start]]]]]]).
wl:arglist_info(invoke_debugger,cl_invoke_debugger,[condition],arginfo{all:[condition],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[condition],opt:0,req:[condition],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,cl_invoke_debugger).

/*

### Compiled:  `CL:INVOKE-DEBUGGER` 
*/
cl_invoke_debugger(_158183862,_166451566):-_168981976=[bv(condition,_158183862)|_158138654],global_env(_158138654),catch((get_var(_168981976,xx_debugger_hook_xx,_158231580),_158215442=[bv(sys_debugger_hook,_158231580)|_168981976],save_special(sv(xx_debugger_hook_xx,[],value,_158243278)),get_var(_158215442,sys_debugger_hook,_158250480),(_158250480\==[]->get_var(_158215442,condition,_158261538),get_var(_158215442,sys_debugger_hook,_158261106),get_var(_158215442,sys_debugger_hook,_158264116),cl_apply(_158261106,[_158261538,_158264116],_158259334),_158249542=_158259334;_158249542=[]),get_var(_158215442,xx_debug_io_xx,_158280494),cl_format([_158280494,'$ARRAY'([*],claz_base_character,"Entering debugger.~%")],_158280426),get_var(_158215442,condition,_158296922),get_var(_158215442,xx_debug_io_xx,_158298578),cl_princ(_158296922,_158298578,_158295858),get_var(_158215442,xx_debug_io_xx,_158306520),cl_terpri(_158306520,_158305246),get_var(_158215442,condition,_158321212),cl_compute_restarts(_158321212,_158320096),f_sys_makef(_158322214),_158319288=[bv(sys_restarts,_158320096),bv(sys_stack,_158322214),bv(sys_frame_depth,0),bv(sys_active_frame,[])|_158215442],_158365258=[bv(count,0)|_158319288],get_var(_158365258,sys_restarts,_158414760),_158414070=bv(restart,_158414416),_158414390=[_158414070|_158365258],forall(member(_158414416,_158414760),(nb_setarg(2,_158414070,_158414416),get_var(_158414390,count,_158382634),get_var(_158414390,xx_debug_io_xx,_158382076),cl_format([_158382076,'$ARRAY'([*],claz_base_character,"~A: "),_158382634],_169885700),get_var(_158414390,restart,_158385576),get_var(_158414390,xx_debug_io_xx,_158395552),cl_princ(_158385576,_158395552,_169888884),get_var(_158414390,xx_debug_io_xx,_158398352),cl_terpri(_158398352,_169890966),set_place(_158414390,incf,[value,count],[],_158365046))),get_var(_158319288,sys_stack,_158445562),-(_158445562,20,_158445424),f_sys_next_function_frame(_158445424,_158437460),set_var(_158319288,sys_active_frame,_158437460),get_var(_158319288,sys_active_frame,_158461810),f_sys_show_frame(_158461810,0,_158461742),call_addr_block(_158319288,(push_label(start),get_var(_158319288,sys_frame_depth,_161425224),get_var(_158319288,xx_debug_io_xx,_161423514),cl_format([_161423514,'$ARRAY'([*],claz_base_character,";~A> "),_161425224],_169900540),cl_read(_161444068),_161436468=[bv(sys_form,_161444068)|_158319288],get_var(_161436468,sys_form,_161452978),(is_eq(_161452978,kw_help)->get_var(_161436468,xx_debug_io_xx,_162679268),cl_format([_162679268,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],_169906464),get_var(_161436468,xx_debug_io_xx,_162682304),cl_format([_162682304,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")],_163933956),_161452146=_163933956;(is_eq(_161452978,kw_back)->get_var(_161436468,sys_stack,_162706026),-(_162706026,20,_169208010),f_sys_next_function_frame(_169208010,_162715704),_162704414=[bv(sys_frame,_162715704),bv(index,0)|_161436468],catch((call_addr_block(_162704414,(push_label(do_label_22),get_var(_162704414,sys_frame,_162770190),(_162770190==[]->throw(block_exit([],[])),_162724856=_162772392;get_var(_162704414,index,_162776804),get_var(_162704414,sys_frame,_162775442),f_sys_show_frame(_162775442,_162776804,_169921004),get_var(_162704414,sys_frame,_162782416),f_sys_next_function_frame(_162782416,_162781468),get_var(_162704414,index,_162785130),+(1,_162785130,_162781380),set_var(_162704414,psetq,sys_frame,_162781468),set_var(_162704414,psetq,index,_162781380),goto(do_label_22,_162704414),_162724856=_162788320)),[addr(addr_tagbody_26_do_label_22,do_label_22,'$unused',_162813320,(get_var(_162813320,sys_frame,_162813348),(_162813348==[]->throw(block_exit([],[])),_162813392=_162813406;get_var(_162813320,index,_162813462),get_var(_162813320,sys_frame,_162813434),f_sys_show_frame(_162813434,_162813462,_169932768),get_var(_162813320,sys_frame,_162813504),f_sys_next_function_frame(_162813504,_162813526),get_var(_162813320,index,_162813544),+(1,_162813544,_162813568),set_var(_162813320,psetq,sys_frame,_162813526),set_var(_162813320,psetq,index,_162813568),goto(do_label_22,_162813320),_162813392=_162813622)))]),[]=_162704202),block_exit([],_162704202),true),_163934304=_162704202;(is_eq(_161452978,kw_up)->get_var(_161436468,sys_frame_depth,_162936752),(mth:is_plusp(_162936752)->set_place(_161436468,decf,[value,sys_frame_depth],[],_162939966),get_var(_161436468,sys_stack,_162946292),-(_162946292,20,_169240488),f_sys_next_function_frame(_169240488,_162956216),_162944680=[bv(sys_frame,_162956216),bv(index,0)|_161436468],catch((call_addr_block(_162944680,(push_label(do_label_23),get_var(_162944680,index,_163008676),get_var(_162944680,sys_frame_depth,_163010272),(_163008676=:=_163010272->get_var(_162944680,sys_frame,_163012638),set_var(_162944680,sys_active_frame,_163012638),throw(block_exit([],_163012638)),_162965698=_163013002;get_var(_162944680,sys_frame,_163020778),f_sys_next_function_frame(_163020778,_169013526),get_var(_162944680,index,_163023516),+(1,_163023516,_169013918),set_var(_162944680,psetq,sys_frame,_169013526),set_var(_162944680,psetq,index,_169013918),goto(do_label_23,_162944680),_162965698=_163026730)),[addr(addr_tagbody_27_do_label_23,do_label_23,'$unused',_163049616,(get_var(_163049616,index,_163049644),get_var(_163049616,sys_frame_depth,_163049672),(_163049644=:=_163049672->get_var(_163049616,sys_frame,_163049718),set_var(_163049616,sys_active_frame,_163049718),throw(block_exit([],_163049718)),_163049768=_163049782;get_var(_163049616,sys_frame,_163049810),f_sys_next_function_frame(_163049810,_169968744),get_var(_163049616,index,_163049850),+(1,_163049850,_169972262),set_var(_163049616,psetq,sys_frame,_169968744),set_var(_163049616,psetq,index,_169972262),goto(do_label_23,_163049616),_163049768=_163049928)))]),[]=_162944468),block_exit([],_162944468),true),get_var(_161436468,sys_active_frame,_163102988),get_var(_161436468,sys_frame_depth,_163104548),f_sys_show_frame(_163102988,_163104548,_163155350),_163839698=_163155350;get_var(_161436468,xx_debug_io_xx,_163153432),cl_format([_163153432,'$ARRAY'([*],claz_base_character,"Top of stack.~%")],_163155698),_163839698=_163155698),_163881784=_163839698;(is_eq(_161452978,kw_down)->get_var(_161436468,sys_active_frame,_163258226),f_sys_next_function_frame(_163258226,_163267448),_163256680=[bv(sys_frame,_163267448)|_161436468],get_var(_163256680,sys_frame,_163268828),(_163268828\==[]->set_place(_163256680,incf,[value,sys_frame_depth],[],_163271858),get_var(_163256680,sys_frame,_163274662),set_var(_163256680,sys_active_frame,_163274662),get_var(_163256680,sys_active_frame,_163277132),get_var(_163256680,sys_frame_depth,_163278704),f_sys_show_frame(_163277132,_163278704,_163291436),_163256468=_163291436;get_var(_163256680,xx_debug_io_xx,_163289512),cl_format([_163289512,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")],_163291784),_163256468=_163291784),_163840046=_163256468;(is_eq(_161452978,kw_locals)->get_var(_161436468,sys_active_frame,_163344742),-(_163344742,1,_163343482),f_sys_fref(_163343482,_163354662),_163343004=[bv(env,_163354662)|_161436468],catch((call_addr_block(_163343004,(push_label(do_label_24),get_var(_163343004,env,_163423976),(_163423976==[]->throw(block_exit([],[])),_163357724=_163426190;get_var(_163343004,env,_163430610),cl_caar(_163430610,_163432350),(is_symbolp(_163432350)->get_var(_163343004,env,_163435670),get_var(_163343004,xx_debug_io_xx,_163434140),cl_caar(_163435670,_163434806),cl_format([_163434140,'$ARRAY'([*],claz_base_character,"~A~%"),_163434806],_163442694),_163428482=_163442694;_163428482=[]),get_var(_163343004,env,_163456462),cl_cdr(_163456462,_169028952),set_var(_163343004,env,_169028952),goto(do_label_24,_163343004),_163357724=_163458592)),[addr(addr_tagbody_28_do_label_24,do_label_24,'$unused',_163488608,(get_var(_163488608,env,_163488636),(_163488636==[]->throw(block_exit([],[])),_163488680=_163488694;get_var(_163488608,env,_163488722),cl_caar(_163488722,_163488748),(is_symbolp(_163488748)->get_var(_163488608,env,_163488826),get_var(_163488608,xx_debug_io_xx,_163488798),cl_caar(_163488826,_170019326),cl_format([_163488798,'$ARRAY'([*],claz_base_character,"~A~%"),_170019326],_163488882),_163488896=_163488882;_163488896=[]),get_var(_163488608,env,_163488922),cl_cdr(_163488922,_163488944),set_var(_163488608,env,_163488944),goto(do_label_24,_163488608),_163488680=_163488980)))]),[]=_163342792),block_exit([],_163342792),true),_163812262=_163342792;(is_eq(_161452978,kw_continue)->cl_read(_163632916),_163624346=[bv(index,_163632916)|_161436468],get_var(_163624346,index,_163634528),get_var(_163624346,sys_restarts,_163636022),cl_nth(_163634528,_163636022,_163633562),cl_invoke_restart_interactively(_163633562,_163624134),_163789720=_163624134;get_var(_161436468,sys_active_frame,_163660614),get_var(_161436468,sys_form,_163658712),-(_163660614,1,_169329144),f_sys_fref(_169329144,_163659180),cl_eval(_163658712,_163659180,_163657688),nb_current('$mv_return',_163657348),_163655958=[bv(values,_163657348),bv(count,0)|_161436468],get_var(_163655958,values,_163682212),(_163682212\==[]->get_var(_163655958,values,_163685200),_163702212=bv(sys_value,_163702580),_163693774=[_163702212|_163655958],forall(member(_163702580,_163685200),(nb_setarg(2,_163702212,_163702580),get_var(_163693774,count,_163688962),get_var(_163693774,xx_debug_io_xx,_163687462),get_var(_163693774,sys_value,_163690246),cl_format([_163687462,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),_163688962,_163690246],_170047388),set_place(_163693774,incf,[value,count],[],_163693146))),_163655746=_163693146;get_var(_163655958,xx_debug_io_xx,_163707840),cl_format([_163707840,'$ARRAY'([*],claz_base_character,";No values.~%")],_163710136),_163655746=_163710136),_163789720=_163655746),_163812262=_163789720),_163840046=_163812262),_163881784=_163840046),_163934304=_163881784),_161452146=_163934304),goto(start,_161436468)),[addr(addr_tagbody_22_start,start,'$unused',_164376776,(get_var(_164376776,sys_frame_depth,_164376820),get_var(_164376776,xx_debug_io_xx,_164376796),cl_format([_164376796,'$ARRAY'([*],claz_base_character,";~A> "),_164376820],_170057758),cl_read(_164376860),_164376876=[bv(sys_form,_164376860)|_164376776],get_var(_164376876,sys_form,_164376916),(is_eq(_164376916,kw_help)->get_var(_164376876,xx_debug_io_xx,_164376976),cl_format([_164376976,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],_170064272),get_var(_164376876,xx_debug_io_xx,_164377022),cl_format([_164377022,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")],_164377054),_164377068=_164377054;(is_eq(_164376916,kw_back)->get_var(_164376876,sys_stack,_164377112),-(_164377112,20,_169367080),f_sys_next_function_frame(_169367080,_170071162),_164377164=[bv(sys_frame,_170071162),bv(index,0)|_164376876],catch((call_addr_block(_164377164,(push_label(do_label_19),get_var(_164377164,sys_frame,_164377244),(_164377244==[]->throw(block_exit([],[])),_164377288=_164377302;get_var(_164377164,index,_164377358),get_var(_164377164,sys_frame,_164377330),f_sys_show_frame(_164377330,_164377358,_170079920),get_var(_164377164,sys_frame,_164377400),f_sys_next_function_frame(_164377400,_170082446),get_var(_164377164,index,_164377440),+(1,_164377440,_170085964),set_var(_164377164,psetq,sys_frame,_170082446),set_var(_164377164,psetq,index,_170085964),goto(do_label_19,_164377164),_164377288=_164377518)),[addr(addr_tagbody_23_do_label_19,do_label_19,'$unused',_164377550,(get_var(_164377550,sys_frame,_164377578),(_164377578==[]->throw(block_exit([],[])),_164377622=_164377636;get_var(_164377550,index,_170091794),get_var(_164377550,sys_frame,_164377664),f_sys_show_frame(_164377664,_170091794,_170094116),get_var(_164377550,sys_frame,_164377720),f_sys_next_function_frame(_164377720,_170096642),get_var(_164377550,index,_164377760),+(1,_164377760,_170100160),set_var(_164377550,psetq,sys_frame,_170096642),set_var(_164377550,psetq,index,_170100160),goto(do_label_19,_164377550),_164377622=_164377838)))]),[]=_164377858),block_exit([],_164377858),true),_164377884=_164377858;(is_eq(_164376916,kw_up)->get_var(_164376876,sys_frame_depth,_164377936),(mth:is_plusp(_164377936)->set_place(_164376876,decf,[value,sys_frame_depth],[],_164377992),get_var(_164376876,sys_stack,_164378010),-(_164378010,20,_169399558),f_sys_next_function_frame(_169399558,_164378050),_164378076=[bv(sys_frame,_164378050),bv(index,0)|_164376876],catch((call_addr_block(_164378076,(push_label(do_label_20),get_var(_164378076,index,_164378156),get_var(_164378076,sys_frame_depth,_164378184),(_164378156=:=_164378184->get_var(_164378076,sys_frame,_164378230),set_var(_164378076,sys_active_frame,_164378230),throw(block_exit([],_164378230)),_164378280=_164378294;get_var(_164378076,sys_frame,_164378322),f_sys_next_function_frame(_164378322,_170119970),get_var(_164378076,index,_164378362),+(1,_164378362,_170123488),set_var(_164378076,psetq,sys_frame,_170119970),set_var(_164378076,psetq,index,_170123488),goto(do_label_20,_164378076),_164378280=_164378440)),[addr(addr_tagbody_24_do_label_20,do_label_20,'$unused',_164378472,(get_var(_164378472,index,_164378500),get_var(_164378472,sys_frame_depth,_164378528),(_164378500=:=_164378528->get_var(_164378472,sys_frame,_164378574),set_var(_164378472,sys_active_frame,_164378574),throw(block_exit([],_164378574)),_164378624=_164378638;get_var(_164378472,sys_frame,_164378666),f_sys_next_function_frame(_164378666,_170132658),get_var(_164378472,index,_164378706),+(1,_164378706,_170136176),set_var(_164378472,psetq,sys_frame,_170132658),set_var(_164378472,psetq,index,_170136176),goto(do_label_20,_164378472),_164378624=_164378784)))]),[]=_164378804),block_exit([],_164378804),true),get_var(_164376876,sys_active_frame,_164378838),get_var(_164376876,sys_frame_depth,_164378866),f_sys_show_frame(_164378838,_164378866,_164378894),_164378914=_164378894;get_var(_164376876,xx_debug_io_xx,_164378942),cl_format([_164378942,'$ARRAY'([*],claz_base_character,"Top of stack.~%")],_164378974),_164378914=_164378974),_164379000=_164378914;(is_eq(_164376916,kw_down)->get_var(_164376876,sys_active_frame,_164379052),f_sys_next_function_frame(_164379052,_164379078),_164379104=[bv(sys_frame,_164379078)|_164376876],get_var(_164379104,sys_frame,_164379144),(_164379144\==[]->set_place(_164379104,incf,[value,sys_frame_depth],[],_164379200),get_var(_164379104,sys_frame,_164379228),set_var(_164379104,sys_active_frame,_164379228),get_var(_164379104,sys_active_frame,_164379270),get_var(_164379104,sys_frame_depth,_164379298),f_sys_show_frame(_164379270,_164379298,_164379326),_164379346=_164379326;get_var(_164379104,xx_debug_io_xx,_164379374),cl_format([_164379374,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")],_164379406),_164379346=_164379406),_164379432=_164379346;(is_eq(_164376916,kw_locals)->get_var(_164376876,sys_active_frame,_164379484),-(_164379484,1,_169447496),f_sys_fref(_169447496,_170159798),_164379536=[bv(env,_170159798)|_164376876],catch((call_addr_block(_164379536,(push_label(do_label_21),get_var(_164379536,env,_164379610),(_164379610==[]->throw(block_exit([],[])),_164379654=_164379668;get_var(_164379536,env,_164379696),cl_caar(_164379696,_164379722),(is_symbolp(_164379722)->get_var(_164379536,env,_164379800),get_var(_164379536,xx_debug_io_xx,_164379772),cl_caar(_164379800,_170170404),cl_format([_164379772,'$ARRAY'([*],claz_base_character,"~A~%"),_170170404],_164379856),_164379870=_164379856;_164379870=[]),get_var(_164379536,env,_164379896),cl_cdr(_164379896,_170174178),set_var(_164379536,env,_170174178),goto(do_label_21,_164379536),_164379654=_164379954)),[addr(addr_tagbody_25_do_label_21,do_label_21,'$unused',_164379986,(get_var(_164379986,env,_164380014),(_164380014==[]->throw(block_exit([],[])),_164380058=_164380072;get_var(_164379986,env,_164380100),cl_caar(_164380100,_164380126),(is_symbolp(_164380126)->get_var(_164379986,env,_164380204),get_var(_164379986,xx_debug_io_xx,_164380176),cl_caar(_164380204,_170184388),cl_format([_164380176,'$ARRAY'([*],claz_base_character,"~A~%"),_170184388],_164380260),_164380274=_164380260;_164380274=[]),get_var(_164379986,env,_164380300),cl_cdr(_164380300,_170188162),set_var(_164379986,env,_170188162),goto(do_label_21,_164379986),_164380058=_164380358)))]),[]=_164380378),block_exit([],_164380378),true),_164380404=_164380378;(is_eq(_164376916,kw_continue)->cl_read(_170193534),_164380464=[bv(index,_170193534)|_164376876],get_var(_164380464,index,_164380504),get_var(_164380464,sys_restarts,_164380532),cl_nth(_164380504,_164380532,_169484492),cl_invoke_restart_interactively(_169484492,_164380572),_164380592=_164380572;get_var(_164376876,sys_active_frame,_164380648),get_var(_164376876,sys_form,_164380620),-(_164380648,1,_169488254),f_sys_fref(_169488254,_170201088),cl_eval(_164380620,_170201088,_164380698),nb_current('$mv_return',_164380714),_164380740=[bv(values,_164380714),bv(count,0)|_164376876],get_var(_164380740,values,_164380786),(_164380786\==[]->get_var(_164380740,values,_164380838),_164380864=bv(sys_value,_164380884),_164380910=[_164380864|_164380740],forall(member(_164380884,_164380838),(nb_setarg(2,_164380864,_164380884),get_var(_164380910,count,_164381004),get_var(_164380910,xx_debug_io_xx,_164380976),get_var(_164380910,sys_value,_170212946),cl_format([_164380976,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),_164381004,_170212946],_170214316),set_place(_164380910,incf,[value,count],[],_164381080))),_164381100=_164381080;get_var(_164380740,xx_debug_io_xx,_164381128),cl_format([_164381128,'$ARRAY'([*],claz_base_character,";No values.~%")],_164381160),_164381100=_164381160),_164380592=_164381100),_164380404=_164380592),_164379432=_164380404),_164379000=_164379432),_164377884=_164379000),_164377068=_164377884),goto(start,_164376876)))]),restore_special(sv(xx_debugger_hook_xx,[],value,_158243278)),[]=_166451566),block_exit(invoke_debugger,_166451566),true).
:-set_opv(cl_invoke_debugger,classof,claz_function),set_opv(invoke_debugger,compile_as,kw_function),set_opv(invoke_debugger,function,cl_invoke_debugger),_158098920=invoke_debugger.
/*
:-side_effect(assert_lsp(invoke_debugger,lambda_def(defun,invoke_debugger,cl_invoke_debugger,[condition],[[let,[[sys_debugger_hook,xx_debugger_hook_xx],[xx_debugger_hook_xx,[]]],[when,sys_debugger_hook,[funcall,sys_debugger_hook,condition,sys_debugger_hook]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Entering debugger.~%")],[princ,condition,xx_debug_io_xx],[terpri,xx_debug_io_xx],[let,[[sys_restarts,[compute_restarts,condition]],[sys_stack,[sys_makef]],[sys_frame_depth,0],[sys_active_frame,[]]],[let,[[count,0]],[dolist,[restart,sys_restarts],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A: "),count],[princ,restart,xx_debug_io_xx],[terpri,xx_debug_io_xx],[incf,count]]],[setq,sys_active_frame,[sys_next_function_frame,[-,sys_stack,20]]],[sys_show_frame,sys_active_frame,0],[tagbody,start,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A> "),sys_frame_depth],[let,[[sys_form,[read]]],[case,sys_form,[kw_help,[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :help to get help.~%")],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Type :continue <index> to invoke the indexed restart.~%")]],[kw_back,[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[not,sys_frame]],[sys_show_frame,sys_frame,index]]],[kw_up,[if,[plusp,sys_frame_depth],[progn,[decf,sys_frame_depth],[do,[[sys_frame,[sys_next_function_frame,[-,sys_stack,20]],[sys_next_function_frame,sys_frame]],[index,0,[+,1,index]]],[[=,index,sys_frame_depth],[setq,sys_active_frame,sys_frame]]],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Top of stack.~%")]]],[kw_down,[let,[[sys_frame,[sys_next_function_frame,sys_active_frame]]],[if,sys_frame,[progn,[incf,sys_frame_depth],[setq,sys_active_frame,sys_frame],[sys_show_frame,sys_active_frame,sys_frame_depth]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"Bottom of stack.~%")]]]],[kw_locals,[do,[[env,[sys_fref,[-,sys_active_frame,1]],[cdr,env]]],[[not,env]],[when,[symbolp,[caar,env]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,"~A~%"),[caar,env]]]]],[kw_continue,[let,[[index,[read]]],[invoke_restart_interactively,[nth,index,sys_restarts]]]],[t,[let,[[values,[multiple_value_list,[eval,sys_form,[sys_fref,[-,sys_active_frame,1]]]]],[count,0]],[if,values,[dolist,[sys_value,values],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";~A: ~S~%"),count,sys_value],[incf,count]],[format,xx_debug_io_xx,'$ARRAY'([*],claz_base_character,";No values.~%")]]]]],[go,start]]]]]]))).
*/
/*
:-side_effect(assert_lsp(invoke_debugger,arglist_info(invoke_debugger,cl_invoke_debugger,[condition],arginfo{all:[condition],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[condition],opt:0,req:[condition],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(invoke_debugger,init_args(exact_only,cl_invoke_debugger))).
*/
/*
#+(or WAM-CL LISP500) 
(defun break (&optional format-control &rest format-arguments)
  (with-simple-restart (continue "Return from BREAK.")
    (let ((*debugger-hook* nil))
      (invoke-debugger (make-condition 'simple-condition
				       :format-control format-control
				       :format-arguments format-arguments))))
  nil)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:49800 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,break,['&optional','format-control','&rest','format-arguments'],['with-simple-restart',[continue,'$STRING'("Return from BREAK.")],[let,[['*debugger-hook*',[]]],['invoke-debugger',['make-condition',[quote,'simple-condition'],':format-control','format-control',':format-arguments','format-arguments']]]],[]]).
wl:lambda_def(defun, break, cl_break, [c38_optional, sys_format_control, c38_rest, sys_format_arguments], [[with_simple_restart, [continue, '$ARRAY'([*], claz_base_character, "Return from BREAK.")], [let, [[xx_debugger_hook_xx, []]], [invoke_debugger, [make_condition, [quote, simple_condition], kw_format_control, sys_format_control, kw_format_arguments, sys_format_arguments]]]], []]).
wl:arglist_info(break, cl_break, [c38_optional, sys_format_control, c38_rest, sys_format_arguments], arginfo{all:[sys_format_control], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_format_control, sys_format_arguments], opt:[sys_format_control], req:0, rest:[sys_format_arguments], sublists:0, whole:0}).
wl: init_args(0, cl_break).

/*

### Compiled:  `CL:BREAK` 
*/
cl_break(Break_Param, FnResult) :-
	Env9=[bv(sys_format_control, Format_control_In), bv(sys_format_arguments, Optionals)|Env],
	global_env(Env),
	append([], Optionals, Break_Param),
	opt_var(Env, sys_format_control, Format_control_In, true, [], 1, Optionals),
	catch(( cl_with_simple_restart(
				       [ continue,
					 '$ARRAY'([*],
						  claz_base_character,
						  "Return from BREAK.")
				       ],
				       
				       [ let,
					 [[xx_debugger_hook_xx, []]],
					 
					 [ invoke_debugger,
					   
					   [ make_condition,
					     [quote, simple_condition],
					     kw_format_control,
					     sys_format_control,
					     kw_format_arguments,
					     sys_format_arguments
					   ]
					 ]
				       ],
				       Simple_restart_Ret),
		[]=FnResult
	      ),
	      block_exit(break, FnResult),
	      true).
:- set_opv(cl_break, classof, claz_function),
   set_opv(break, compile_as, kw_function),
   set_opv(break, function, cl_break),
   DefunResult=break.
/*
:- side_effect(assert_lsp(break,
			  lambda_def(defun,
				     break,
				     cl_break,
				     
				     [ c38_optional,
				       sys_format_control,
				       c38_rest,
				       sys_format_arguments
				     ],
				     
				     [ 
				       [ with_simple_restart,
					 
					 [ continue,
					   '$ARRAY'([*],
						    claz_base_character,
						    "Return from BREAK.")
					 ],
					 
					 [ let,
					   [[xx_debugger_hook_xx, []]],
					   
					   [ invoke_debugger,
					     
					     [ make_condition,
					       [quote, simple_condition],
					       kw_format_control,
					       sys_format_control,
					       kw_format_arguments,
					       sys_format_arguments
					     ]
					   ]
					 ]
				       ],
				       []
				     ]))).
*/
/*
:- side_effect(assert_lsp(break,
			  arglist_info(break,
				       cl_break,
				       
				       [ c38_optional,
					 sys_format_control,
					 c38_rest,
					 sys_format_arguments
				       ],
				       arginfo{ all:[sys_format_control],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_format_control,
							sys_format_arguments
						      ],
						opt:[sys_format_control],
						req:0,
						rest:[sys_format_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(break, init_args(0, cl_break))).
*/
/*
#+(or WAM-CL LISP500) 
(defparameter *debugger-hook* nil)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50144 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defparameter,'*debugger-hook*',[]]).
:- set_var(AEnv, xx_debugger_hook_xx, []).
/*
#+(or WAM-CL LISP500) 
(defparameter *break-on-signals* nil)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50206 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defparameter,'*break-on-signals*',[]]).
:- set_var(AEnv, xx_break_on_signals_xx, []).
/*
#+(or WAM-CL LISP500) 
(defparameter *handlers* nil)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50271 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defparameter,'*handlers*',[]]).
:- set_var(AEnv, sys_xx_handlers_xx, []).
/*
#+(or WAM-CL LISP500) 
(defun invoke-handler (condition)
  (dolist (handler *handlers*)
    (when (typep condition (car handler))
      (setq *handlers* (caddr handler))
      (funcall (cadr handler) condition))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50328 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'invoke-handler',[condition],[dolist,[handler,'*handlers*'],[when,[typep,condition,[car,handler]],[setq,'*handlers*',[caddr,handler]],[funcall,[cadr,handler],condition]]]]).
wl:lambda_def(defun, sys_invoke_handler, f_sys_invoke_handler, [condition], [[dolist, [sys_handler, sys_xx_handlers_xx], [when, [typep, condition, [car, sys_handler]], [setq, sys_xx_handlers_xx, [caddr, sys_handler]], [funcall, [cadr, sys_handler], condition]]]]).
wl:arglist_info(sys_invoke_handler, f_sys_invoke_handler, [condition], arginfo{all:[condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[condition], opt:0, req:[condition], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_invoke_handler).

/*

### Compiled:  `SYS::INVOKE-HANDLER` 
*/
f_sys_invoke_handler(Condition_In, FnResult) :-
	Env20=[bv(condition, Condition_In)|Env],
	global_env(Env),
	catch(( get_var(Env20, sys_xx_handlers_xx, Xx_handlers_xx_Get),
		BV=bv(sys_handler, Ele),
		AEnv=[BV|Env20],
		forall(member(Ele, Xx_handlers_xx_Get),
		       ( nb_setarg(2, BV, Ele),
			 get_var(AEnv, condition, Condition_Get),
			 get_var(AEnv, sys_handler, Handler_Get),
			 cl_car(Handler_Get, Car_Ret),
			 cl_typep(Condition_Get, Car_Ret, IFTEST),
			 (   IFTEST\==[]
			 ->  get_var(AEnv, sys_handler, Handler_Get10),
			     cl_caddr(Handler_Get10, Xx_handlers_xx),
			     set_var(AEnv, sys_xx_handlers_xx, Xx_handlers_xx),
			     get_var(AEnv, sys_handler, Handler_Get11),
			     cl_cadr(Handler_Get11, Apply_Param),
			     get_var(AEnv, condition, Condition_Get12),
			     cl_apply(Apply_Param,
				      [Condition_Get12],
				      TrueResult),
			     _174478024=TrueResult
			 ;   _174478024=[]
			 )
		       )),
		_174478024=FnResult
	      ),
	      block_exit(sys_invoke_handler, FnResult),
	      true).
:- set_opv(f_sys_invoke_handler, classof, claz_function),
   set_opv(sys_invoke_handler, compile_as, kw_function),
   set_opv(sys_invoke_handler, function, f_sys_invoke_handler),
   DefunResult=sys_invoke_handler.
/*
:- side_effect(assert_lsp(sys_invoke_handler,
			  lambda_def(defun,
				     sys_invoke_handler,
				     f_sys_invoke_handler,
				     [condition],
				     
				     [ 
				       [ dolist,
					 [sys_handler, sys_xx_handlers_xx],
					 
					 [ when,
					   [typep, condition, [car, sys_handler]],
					   
					   [ setq,
					     sys_xx_handlers_xx,
					     [caddr, sys_handler]
					   ],
					   
					   [ funcall,
					     [cadr, sys_handler],
					     condition
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_invoke_handler,
			  arglist_info(sys_invoke_handler,
				       f_sys_invoke_handler,
				       [condition],
				       arginfo{ all:[condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[condition],
						opt:0,
						req:[condition],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_invoke_handler,
			  init_args(exact_only, f_sys_invoke_handler))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro handler-bind (bindings &rest forms)
  (let ((form '*handlers*)
	(handlers (gensym)))
    (dolist (binding (reverse bindings))
      (setq form
	    `(cons (list ',(car binding) ,(cadr binding) ',handlers) ,form)))
    `(let ((handlers *handlers*)
	   (*handlers* ,form))
      ,@forms)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50552 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'handler-bind',[bindings,'&rest',forms],[let,[[form,[quote,'*handlers*']],[handlers,[gensym]]],[dolist,[binding,[reverse,bindings]],[setq,form,['#BQ',[cons,[list,[quote,['#COMMA',[car,binding]]],['#COMMA',[cadr,binding]],[quote,['#COMMA',handlers]]],['#COMMA',form]]]]],['#BQ',[let,[[handlers,'*handlers*'],['*handlers*',['#COMMA',form]]],['#BQ-COMMA-ELIPSE',forms]]]]]).
wl:lambda_def(defmacro, handler_bind, cl_handler_bind, [bindings, c38_rest, forms], [progn, [let, [[sys_form, [quote, sys_xx_handlers_xx]], [sys_handlers, [gensym]]], [dolist, [binding, [reverse, bindings]], [setq, sys_form, ['#BQ', [cons, [list, [quote, ['#COMMA', [car, binding]]], ['#COMMA', [cadr, binding]], [quote, ['#COMMA', sys_handlers]]], ['#COMMA', sys_form]]]]], ['#BQ', [let, [[sys_handlers, sys_xx_handlers_xx], [sys_xx_handlers_xx, ['#COMMA', sys_form]]], ['#BQ-COMMA-ELIPSE', forms]]]]]).
wl:arglist_info(handler_bind, cl_handler_bind, [bindings, c38_rest, forms], arginfo{all:[bindings], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[bindings, forms], opt:0, req:[bindings], rest:[forms], sublists:0, whole:0}).
wl: init_args(1, cl_handler_bind).

/*

### Compiled:  `CL:HANDLER-BIND` 
*/
cl_handler_bind(Bindings_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(bindings, Bindings_In), bv(forms, RestNKeys)|CDR],
	global_env(CDR),
	catch(( cl_gensym(Handlers_Init),
		LEnv=[bv(sys_form, sys_xx_handlers_xx), bv(sys_handlers, Handlers_Init)|Env],
		get_var(LEnv, bindings, Bindings_Get),
		cl_reverse(Bindings_Get, List),
		BV=bv(binding, Ele),
		AEnv=[BV|LEnv],
		forall(member(Ele, List),
		       ( nb_setarg(2, BV, Ele),
			 get_var(AEnv, binding, Binding_Get),
			 cl_car(Binding_Get, Car_Ret),
			 get_var(AEnv, binding, Binding_Get13),
			 cl_cadr(Binding_Get13, Cadr_Ret),
			 get_var(AEnv, sys_form, Form_Get),
			 get_var(AEnv, sys_handlers, Handlers_Get),
			 set_var(AEnv,
				 sys_form,
				 
				 [ cons,
				   
				   [ list,
				     [quote, Car_Ret],
				     Cadr_Ret,
				     [quote, Handlers_Get]
				   ],
				   Form_Get
				 ]).
		       )),
		get_var(LEnv, forms, Forms_Get),
		get_var(LEnv, sys_form, Form_Get20),
		[let, [[sys_handlers, sys_xx_handlers_xx], [sys_xx_handlers_xx, Form_Get20]]|Forms_Get]=MFResult
	      ),
	      block_exit(handler_bind, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_handler_bind, classof, claz_macro),
   set_opv(handler_bind, compile_as, kw_operator),
   set_opv(handler_bind, function, cl_handler_bind),
   DefMacroResult=handler_bind.
/*
:- side_effect(assert_lsp(handler_bind,
			  lambda_def(defmacro,
				     handler_bind,
				     cl_handler_bind,
				     [bindings, c38_rest, forms],
				     
				     [ progn,
				       
				       [ let,
					 
					 [ 
					   [ sys_form,
					     [quote, sys_xx_handlers_xx]
					   ],
					   [sys_handlers, [gensym]]
					 ],
					 
					 [ dolist,
					   [binding, [reverse, bindings]],
					   
					   [ setq,
					     sys_form,
					     
					     [ '#BQ',
					       
					       [ cons,
						 
						 [ list,
						   
						   [ quote,
						     ['#COMMA', [car, binding]]
						   ],
						   ['#COMMA', [cadr, binding]],
						   
						   [ quote,
						     ['#COMMA', sys_handlers]
						   ]
						 ],
						 ['#COMMA', sys_form]
					       ]
					     ]
					   ]
					 ],
					 
					 [ '#BQ',
					   
					   [ let,
					     
					     [ 
					       [ sys_handlers,
						 sys_xx_handlers_xx
					       ],
					       
					       [ sys_xx_handlers_xx,
						 ['#COMMA', sys_form]
					       ]
					     ],
					     ['#BQ-COMMA-ELIPSE', forms]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(handler_bind,
			  arglist_info(handler_bind,
				       cl_handler_bind,
				       [bindings, c38_rest, forms],
				       arginfo{ all:[bindings],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[bindings, forms],
						opt:0,
						req:[bindings],
						rest:[forms],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(handler_bind, init_args(1, cl_handler_bind))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro handler-case (expression &rest clauses)
  (let ((tag (gensym))
	(bindings nil))
    `(handler-bind
      ,(dolist (clause clauses (reverse bindings))
	 (let ((typespec (car clause))
	       (var-list (cadr clause))
	       (forms (cddr clauses)))
	   (push `(typespec #'(lambda (,(if var-list (car var-list) (gensym)))
				(return-from tag (progn ,@forms))))
		 bindings)))
      ,expression)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:50885 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'handler-case',[expression,'&rest',clauses],[let,[[tag,[gensym]],[bindings,[]]],['#BQ',['handler-bind',['#COMMA',[dolist,[clause,clauses,[reverse,bindings]],[let,[[typespec,[car,clause]],['var-list',[cadr,clause]],[forms,[cddr,clauses]]],[push,['#BQ',[typespec,function([lambda,[['#COMMA',[if,'var-list',[car,'var-list'],[gensym]]]],['return-from',tag,[progn,['#BQ-COMMA-ELIPSE',forms]]]])]],bindings]]]],['#COMMA',expression]]]]]).
wl:lambda_def(defmacro, handler_case, cl_handler_case, [sys_expression, c38_rest, sys_clauses], [progn, [let, [[sys_tag, [gensym]], [bindings, []]], ['#BQ', [handler_bind, ['#COMMA', [dolist, [sys_clause, sys_clauses, [reverse, bindings]], [let, [[sys_typespec, [car, sys_clause]], [sys_var_list, [cadr, sys_clause]], [forms, [cddr, sys_clauses]]], [push, ['#BQ', [sys_typespec, function([lambda, [['#COMMA', [if, sys_var_list, [car, sys_var_list], [gensym]]]], [return_from, sys_tag, [progn, ['#BQ-COMMA-ELIPSE', forms]]]])]], bindings]]]], ['#COMMA', sys_expression]]]]]).
wl:arglist_info(handler_case, cl_handler_case, [sys_expression, c38_rest, sys_clauses], arginfo{all:[sys_expression], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_expression, sys_clauses], opt:0, req:[sys_expression], rest:[sys_clauses], sublists:0, whole:0}).
wl: init_args(1, cl_handler_case).

/*

### Compiled:  `CL:HANDLER-CASE` 
*/
cl_handler_case(Expression_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_expression, Expression_In), bv(sys_clauses, RestNKeys)|CDR],
	global_env(CDR),
	catch(( cl_gensym(Tag_Init),
		LEnv=[bv(sys_tag, Tag_Init), bv(bindings, [])|Env],
		get_var(LEnv, bindings, Bindings_Get),
		LEnv12=[bv(reverse, Bindings_Get)|LEnv],
		get_var(LEnv12, sys_clauses, Clauses_Get),
		BV=bv(sys_clause, Ele),
		Env2=[BV|LEnv12],
		forall(member(Ele, Clauses_Get),
		       ( nb_setarg(2, BV, Ele),
			 get_var(Env2, sys_clause, Clause_Get),
			 cl_car(Clause_Get, Typespec_Init),
			 get_var(Env2, sys_clause, Clause_Get20),
			 cl_cadr(Clause_Get20, Var_list_Init),
			 get_var(Env2, sys_clauses, Clauses_Get21),
			 cl_cddr(Clauses_Get21, Forms_Init),
			 LEnv18=[bv(sys_typespec, Typespec_Init), bv(sys_var_list, Var_list_Init), bv(forms, Forms_Init)|Env2],
			 cl_push(
				 [ '#BQ',
				   
				   [ sys_typespec,
				     function(
					      [ lambda,
						
						[ 
						  [ '#COMMA',
						    
						    [ if,
						      sys_var_list,
						      [car, sys_var_list],
						      [gensym]
						    ]
						  ]
						],
						
						[ return_from,
						  sys_tag,
						  
						  [ progn,
						    ['#BQ-COMMA-ELIPSE', forms]
						  ]
						]
					      ]).
				   ]
				 ],
				 bindings,
				 LetResult17)
		       )),
		get_var(LEnv12, bindings, Bindings_Get29),
		cl_reverse(Bindings_Get29, LetResult11),
		get_var(LEnv, sys_expression, Expression_Get),
		[handler_bind, LetResult11, Expression_Get]=MFResult
	      ),
	      block_exit(handler_case, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_handler_case, classof, claz_macro),
   set_opv(handler_case, compile_as, kw_operator),
   set_opv(handler_case, function, cl_handler_case),
   DefMacroResult=handler_case.
/*
:- side_effect(assert_lsp(handler_case,
			  lambda_def(defmacro,
				     handler_case,
				     cl_handler_case,
				     [sys_expression, c38_rest, sys_clauses],
				     
				     [ progn,
				       
				       [ let,
					 [[sys_tag, [gensym]], [bindings, []]],
					 
					 [ '#BQ',
					   
					   [ handler_bind,
					     
					     [ '#COMMA',
					       
					       [ dolist,
						 
						 [ sys_clause,
						   sys_clauses,
						   [reverse, bindings]
						 ],
						 
						 [ let,
						   
						   [ 
						     [ sys_typespec,
						       [car, sys_clause]
						     ],
						     
						     [ sys_var_list,
						       [cadr, sys_clause]
						     ],
						     
						     [ forms,
						       [cddr, sys_clauses]
						     ]
						   ],
						   
						   [ push,
						     
						     [ '#BQ',
						       
						       [ sys_typespec,
							 function(
								  [ lambda,
								    
								    [ 
								      [ '#COMMA',
									
									[ if,
									  sys_var_list,
									  [car, sys_var_list],
									  [gensym]
									]
								      ]
								    ],
								    
								    [ return_from,
								      sys_tag,
								      
								      [ progn,
									
									[ '#BQ-COMMA-ELIPSE',
									  forms
									]
								      ]
								    ]
								  ]).
						       ]
						     ],
						     bindings
						   ]
						 ]
					       ]
					     ],
					     ['#COMMA', sys_expression]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(handler_case,
			  arglist_info(handler_case,
				       cl_handler_case,
				       [sys_expression, c38_rest, sys_clauses],
				       arginfo{ all:[sys_expression],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_expression,
							sys_clauses
						      ],
						opt:0,
						req:[sys_expression],
						rest:[sys_clauses],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(handler_case, init_args(1, cl_handler_case))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro ignore-errors (&rest forms)
  `(handler-case (progn ,@forms)
    (error (condition) (values nil condition))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:51328 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'ignore-errors',['&rest',forms],['#BQ',['handler-case',[progn,['#BQ-COMMA-ELIPSE',forms]],[error,[condition],[values,[],condition]]]]]).
wl:lambda_def(defmacro, ignore_errors, cl_ignore_errors, [c38_rest, forms], [progn, ['#BQ', [handler_case, [progn, ['#BQ-COMMA-ELIPSE', forms]], [error, [condition], [values, [], condition]]]]]).
wl:arglist_info(ignore_errors, cl_ignore_errors, [c38_rest, forms], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[forms], opt:0, req:0, rest:[forms], sublists:0, whole:0}).
wl: init_args(0, cl_ignore_errors).

/*

### Compiled:  `CL:IGNORE-ERRORS` 
*/
cl_ignore_errors(RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(forms, RestNKeys)|CDR],
	global_env(CDR),
	catch(( get_var(Env, forms, Forms_Get),
		[handler_case, [progn|Forms_Get], [error, [condition], [values, [], condition]]]=MFResult
	      ),
	      block_exit(ignore_errors, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_ignore_errors, classof, claz_macro),
   set_opv(ignore_errors, compile_as, kw_operator),
   set_opv(ignore_errors, function, cl_ignore_errors),
   DefMacroResult=ignore_errors.
/*
:- side_effect(assert_lsp(ignore_errors,
			  lambda_def(defmacro,
				     ignore_errors,
				     cl_ignore_errors,
				     [c38_rest, forms],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ handler_case,
					   [progn, ['#BQ-COMMA-ELIPSE', forms]],
					   
					   [ error,
					     [condition],
					     [values, [], condition]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(ignore_errors,
			  arglist_info(ignore_errors,
				       cl_ignore_errors,
				       [c38_rest, forms],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[forms],
						opt:0,
						req:0,
						rest:[forms],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(ignore_errors, init_args(0, cl_ignore_errors))).
*/
/*
#+(or WAM-CL LISP500) 
(defparameter *restarts* nil)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:51477 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defparameter,'*restarts*',[]]).
:- set_var(AEnv, sys_xx_restarts_xx, []).
/*
#+(or WAM-CL LISP500) 
(defun compute-restarts (&optional condition)
  "FIXME restarts associated with conditions"
  (if condition
      *restarts*
      *restarts*))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:51534 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'compute-restarts',['&optional',condition],'$STRING'("FIXME restarts associated with conditions"),[if,condition,'*restarts*','*restarts*']]).
doc: doc_string(compute_restarts,
	      _179118546,
	      function,
	      "FIXME restarts associated with conditions").

wl:lambda_def(defun, compute_restarts, cl_compute_restarts, [c38_optional, condition], [[if, condition, sys_xx_restarts_xx, sys_xx_restarts_xx]]).
wl:arglist_info(compute_restarts, cl_compute_restarts, [c38_optional, condition], arginfo{all:[condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[condition], opt:[condition], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, cl_compute_restarts).

/*

### Compiled:  `CL:COMPUTE-RESTARTS` 
*/
cl_compute_restarts(Compute_restarts_Param, FnResult) :-
	Env15=[bv(condition, Condition_In)|Env],
	global_env(Env),
	append([], RestNKeys, Compute_restarts_Param),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env15, condition, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env15, sys_xx_restarts_xx, Xx_restarts_xx_Get),
		    _179129982=Xx_restarts_xx_Get
		;   get_var(Env15, sys_xx_restarts_xx, Xx_restarts_xx_Get10),
		    _179129982=Xx_restarts_xx_Get10
		),
		_179129982=FnResult
	      ),
	      block_exit(compute_restarts, FnResult),
	      true).
:- set_opv(cl_compute_restarts, classof, claz_function),
   set_opv(compute_restarts, compile_as, kw_function),
   set_opv(compute_restarts, function, cl_compute_restarts),
   DefunResult=compute_restarts.
/*
:- side_effect(assert_lsp(compute_restarts,
			  doc_string(compute_restarts,
				     _179118546,
				     function,
				     "FIXME restarts associated with conditions"))).
*/
/*
:- side_effect(assert_lsp(compute_restarts,
			  lambda_def(defun,
				     compute_restarts,
				     cl_compute_restarts,
				     [c38_optional, condition],
				     
				     [ 
				       [ if,
					 condition,
					 sys_xx_restarts_xx,
					 sys_xx_restarts_xx
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(compute_restarts,
			  arglist_info(compute_restarts,
				       cl_compute_restarts,
				       [c38_optional, condition],
				       arginfo{ all:[condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[condition],
						opt:[condition],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(compute_restarts, init_args(0, cl_compute_restarts))).
*/
/*
#+(or WAM-CL LISP500) 
(defun find-restart (identifier &optional condition)
  (dolist (restart *restarts*)
    (when (eq restart identifier)
      (return restart))
    (when (eq (restart-name restart) identifier)
      (return restart))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:51709 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'find-restart',[identifier,'&optional',condition],[dolist,[restart,'*restarts*'],[when,[eq,restart,identifier],[return,restart]],[when,[eq,['restart-name',restart],identifier],[return,restart]]]]).
wl:lambda_def(defun, find_restart, cl_find_restart, [sys_identifier, c38_optional, condition], [[dolist, [restart, sys_xx_restarts_xx], [when, [eq, restart, sys_identifier], [return, restart]], [when, [eq, [restart_name, restart], sys_identifier], [return, restart]]]]).
wl:arglist_info(find_restart, cl_find_restart, [sys_identifier, c38_optional, condition], arginfo{all:[sys_identifier, condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_identifier, condition], opt:[condition], req:[sys_identifier], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_find_restart).

/*

### Compiled:  `CL:FIND-RESTART` 
*/
cl_find_restart(Identifier_In, RestNKeys, FnResult) :-
	Env35=[bv(sys_identifier, Identifier_In), bv(condition, Condition_In)|Env],
	global_env(Env),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env35, sys_xx_restarts_xx, Xx_restarts_xx_Get),
		BV=bv(restart, Ele),
		BlockExitEnv=[BV|Env35],
		forall(member(Ele, Xx_restarts_xx_Get),
		       ( nb_setarg(2, BV, Ele),
			 get_var(BlockExitEnv, restart, Restart_Get),
			 get_var(BlockExitEnv, sys_identifier, Identifier_Get),
			 (   is_eq(Restart_Get, Identifier_Get)
			 ->  get_var(BlockExitEnv, restart, Restart_Get16),
			     throw(block_exit([], Restart_Get16)),
			     _179894362=ThrowResult
			 ;   _179894362=[]
			 ),
			 get_var(BlockExitEnv, restart, Restart_Get20),
			 cl_restart_name(Restart_Get20, PredArg1Result23),
			 get_var(BlockExitEnv, sys_identifier, Identifier_Get21),
			 (   is_eq(PredArg1Result23, Identifier_Get21)
			 ->  get_var(BlockExitEnv, restart, RetResult25),
			     throw(block_exit([], RetResult25)),
			     _179890226=ThrowResult26
			 ;   _179890226=[]
			 )
		       )),
		_179890226=FnResult
	      ),
	      block_exit(find_restart, FnResult),
	      true).
:- set_opv(cl_find_restart, classof, claz_function),
   set_opv(find_restart, compile_as, kw_function),
   set_opv(find_restart, function, cl_find_restart),
   DefunResult=find_restart.
/*
:- side_effect(assert_lsp(find_restart,
			  lambda_def(defun,
				     find_restart,
				     cl_find_restart,
				     [sys_identifier, c38_optional, condition],
				     
				     [ 
				       [ dolist,
					 [restart, sys_xx_restarts_xx],
					 
					 [ when,
					   [eq, restart, sys_identifier],
					   [return, restart]
					 ],
					 
					 [ when,
					   
					   [ eq,
					     [restart_name, restart],
					     sys_identifier
					   ],
					   [return, restart]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(find_restart,
			  arglist_info(find_restart,
				       cl_find_restart,
				       [sys_identifier, c38_optional, condition],
				       arginfo{ all:[sys_identifier, condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_identifier,
							condition
						      ],
						opt:[condition],
						req:[sys_identifier],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(find_restart, init_args(1, cl_find_restart))).
*/
/*
#+(or WAM-CL LISP500) 
(defun designator-restart (designator)
  (if (restartp designator)
      designator
      (dolist (restart *restarts* (error 'type-error :datum designator
					 :expected-type 'restart))
	(when (eq (restart-name restart) designator)
	  (return restart)))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:51962 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'designator-restart',[designator],[if,[restartp,designator],designator,[dolist,[restart,'*restarts*',[error,[quote,'type-error'],':datum',designator,':expected-type',[quote,restart]]],[when,[eq,['restart-name',restart],designator],[return,restart]]]]]).
wl:lambda_def(defun, sys_designator_restart, f_sys_designator_restart, [sys_designator], [[if, [sys_restartp, sys_designator], sys_designator, [dolist, [restart, sys_xx_restarts_xx, [error, [quote, type_error], kw_datum, sys_designator, kw_expected_type, [quote, restart]]], [when, [eq, [restart_name, restart], sys_designator], [return, restart]]]]]).
wl:arglist_info(sys_designator_restart, f_sys_designator_restart, [sys_designator], arginfo{all:[sys_designator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_designator], opt:0, req:[sys_designator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_designator_restart).

/*

### Compiled:  `SYS::DESIGNATOR-RESTART` 
*/
f_sys_designator_restart(Designator_In, FnResult) :-
	Env32=[bv(sys_designator, Designator_In)|Env],
	global_env(Env),
	catch(( get_var(Env32, sys_designator, Designator_Get),
		f_sys_restartp(Designator_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env32, sys_designator, Designator_Get7),
		    _180883252=Designator_Get7
		;   LEnv=[bv([error, [quote, type_error], kw_datum, sys_designator, kw_expected_type, [quote, restart]], [])|Env32],
		    get_var(LEnv, sys_xx_restarts_xx, Xx_restarts_xx_Get),
		    BV=bv(restart, Ele),
		    BlockExitEnv=[BV|LEnv],
		    forall(member(Ele, Xx_restarts_xx_Get),
			   ( nb_setarg(2, BV, Ele),
			     get_var(BlockExitEnv, restart, Restart_Get),
			     cl_restart_name(Restart_Get, PredArg1Result),
			     get_var(BlockExitEnv,
				     sys_designator,
				     Designator_Get14),
			     (   is_eq(PredArg1Result, Designator_Get14)
			     ->  get_var(BlockExitEnv, restart, Restart_Get20),
				 throw(block_exit([], Restart_Get20)),
				 _180898492=ThrowResult
			     ;   _180898492=[]
			     )
			   )),
		    get_var(LEnv, sys_designator, Designator_Get27),
		    cl_error(
			     [ type_error,
			       kw_datum,
			       Designator_Get27,
			       kw_expected_type,
			       restart
			     ],
			     LetResult),
		    _180883252=LetResult
		),
		_180883252=FnResult
	      ),
	      block_exit(sys_designator_restart, FnResult),
	      true).
:- set_opv(f_sys_designator_restart, classof, claz_function),
   set_opv(sys_designator_restart, compile_as, kw_function),
   set_opv(sys_designator_restart, function, f_sys_designator_restart),
   DefunResult=sys_designator_restart.
/*
:- side_effect(assert_lsp(sys_designator_restart,
			  lambda_def(defun,
				     sys_designator_restart,
				     f_sys_designator_restart,
				     [sys_designator],
				     
				     [ 
				       [ if,
					 [sys_restartp, sys_designator],
					 sys_designator,
					 
					 [ dolist,
					   
					   [ restart,
					     sys_xx_restarts_xx,
					     
					     [ error,
					       [quote, type_error],
					       kw_datum,
					       sys_designator,
					       kw_expected_type,
					       [quote, restart]
					     ]
					   ],
					   
					   [ when,
					     
					     [ eq,
					       [restart_name, restart],
					       sys_designator
					     ],
					     [return, restart]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_designator_restart,
			  arglist_info(sys_designator_restart,
				       f_sys_designator_restart,
				       [sys_designator],
				       arginfo{ all:[sys_designator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_designator],
						opt:0,
						req:[sys_designator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_designator_restart,
			  init_args(exact_only, f_sys_designator_restart))).
*/
/*
#+(or WAM-CL LISP500) 
(defun invoke-restart (restart &rest arguments)
  (setq restart (designator-restart restart))
  (apply (restart-function restart) arguments))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:52254 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'invoke-restart',[restart,'&rest',arguments],[setq,restart,['designator-restart',restart]],[apply,['restart-function',restart],arguments]]).
wl:lambda_def(defun, invoke_restart, cl_invoke_restart, [restart, c38_rest, sys_arguments], [[setq, restart, [sys_designator_restart, restart]], [apply, [sys_restart_function, restart], sys_arguments]]).
wl:arglist_info(invoke_restart, cl_invoke_restart, [restart, c38_rest, sys_arguments], arginfo{all:[restart], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[restart, sys_arguments], opt:0, req:[restart], rest:[sys_arguments], sublists:0, whole:0}).
wl: init_args(1, cl_invoke_restart).

/*

### Compiled:  `CL:INVOKE-RESTART` 
*/
cl_invoke_restart(Restart_In, RestNKeys, FnResult) :-
	AEnv=[bv(restart, Restart_In), bv(sys_arguments, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(AEnv, restart, Restart_Get),
		f_sys_designator_restart(Restart_Get, Restart),
		set_var(AEnv, restart, Restart),
		get_var(AEnv, sys_arguments, Arguments_Get),
		cl_apply([sys_restart_function, restart],
			 [Arguments_Get],
			 Apply_Ret),
		Apply_Ret=FnResult
	      ),
	      block_exit(invoke_restart, FnResult),
	      true).
:- set_opv(cl_invoke_restart, classof, claz_function),
   set_opv(invoke_restart, compile_as, kw_function),
   set_opv(invoke_restart, function, cl_invoke_restart),
   DefunResult=invoke_restart.
/*
:- side_effect(assert_lsp(invoke_restart,
			  lambda_def(defun,
				     invoke_restart,
				     cl_invoke_restart,
				     [restart, c38_rest, sys_arguments],
				     
				     [ 
				       [ setq,
					 restart,
					 [sys_designator_restart, restart]
				       ],
				       
				       [ apply,
					 [sys_restart_function, restart],
					 sys_arguments
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(invoke_restart,
			  arglist_info(invoke_restart,
				       cl_invoke_restart,
				       [restart, c38_rest, sys_arguments],
				       arginfo{ all:[restart],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[restart, sys_arguments],
						opt:0,
						req:[restart],
						rest:[sys_arguments],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(invoke_restart, init_args(1, cl_invoke_restart))).
*/
/*
#+(or WAM-CL LISP500) 
(defun invoke-restart-interactively (restart)
  (setq restart (designator-restart restart))
  (apply (restart-function restart)
	 (funcall (restart-interactive-function restart))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:52425 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'invoke-restart-interactively',[restart],[setq,restart,['designator-restart',restart]],[apply,['restart-function',restart],[funcall,['restart-interactive-function',restart]]]]).
wl:lambda_def(defun, invoke_restart_interactively, cl_invoke_restart_interactively, [restart], [[setq, restart, [sys_designator_restart, restart]], [apply, [sys_restart_function, restart], [funcall, [sys_restart_interactive_function, restart]]]]).
wl:arglist_info(invoke_restart_interactively, cl_invoke_restart_interactively, [restart], arginfo{all:[restart], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[restart], opt:0, req:[restart], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_invoke_restart_interactively).

/*

### Compiled:  `CL:INVOKE-RESTART-INTERACTIVELY` 
*/
cl_invoke_restart_interactively(Restart_In, FnResult) :-
	AEnv=[bv(restart, Restart_In)|Env],
	global_env(Env),
	catch(( get_var(AEnv, restart, Restart_Get),
		f_sys_designator_restart(Restart_Get, Restart),
		set_var(AEnv, restart, Restart),
		get_var(AEnv, restart, Restart_Get6),
		f_sys_restart_interactive_function(Restart_Get6, Apply_Param),
		cl_apply(Apply_Param, [], Apply_Ret),
		cl_apply([sys_restart_function, restart],
			 [Apply_Ret],
			 Apply_Ret12),
		Apply_Ret12=FnResult
	      ),
	      block_exit(invoke_restart_interactively, FnResult),
	      true).
:- set_opv(cl_invoke_restart_interactively, classof, claz_function),
   set_opv(invoke_restart_interactively, compile_as, kw_function),
   set_opv(invoke_restart_interactively,
	   function,
	   cl_invoke_restart_interactively),
   DefunResult=invoke_restart_interactively.
/*
:- side_effect(assert_lsp(invoke_restart_interactively,
			  lambda_def(defun,
				     invoke_restart_interactively,
				     cl_invoke_restart_interactively,
				     [restart],
				     
				     [ 
				       [ setq,
					 restart,
					 [sys_designator_restart, restart]
				       ],
				       
				       [ apply,
					 [sys_restart_function, restart],
					 
					 [ funcall,
					   
					   [ sys_restart_interactive_function,
					     restart
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(invoke_restart_interactively,
			  arglist_info(invoke_restart_interactively,
				       cl_invoke_restart_interactively,
				       [restart],
				       arginfo{ all:[restart],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[restart],
						opt:0,
						req:[restart],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(invoke_restart_interactively,
			  init_args(exact_only,
				    cl_invoke_restart_interactively))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro restart-bind (restart-bindings &rest forms)
  (let ((form '*restarts*))
    (dolist (binding (reverse restart-bindings))
      (setq form
	    `(cons (make-restart ',(car binding) ,@(cdr binding)) ,form)))
    `(let ((*restarts* ,form))
      ,@forms)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:52636 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'restart-bind',['restart-bindings','&rest',forms],[let,[[form,[quote,'*restarts*']]],[dolist,[binding,[reverse,'restart-bindings']],[setq,form,['#BQ',[cons,['make-restart',[quote,['#COMMA',[car,binding]]],['#BQ-COMMA-ELIPSE',[cdr,binding]]],['#COMMA',form]]]]],['#BQ',[let,[['*restarts*',['#COMMA',form]]],['#BQ-COMMA-ELIPSE',forms]]]]]).
wl:lambda_def(defmacro, restart_bind, cl_restart_bind, [sys_restart_bindings, c38_rest, forms], [progn, [let, [[sys_form, [quote, sys_xx_restarts_xx]]], [dolist, [binding, [reverse, sys_restart_bindings]], [setq, sys_form, ['#BQ', [cons, [sys_make_restart, [quote, ['#COMMA', [car, binding]]], ['#BQ-COMMA-ELIPSE', [cdr, binding]]], ['#COMMA', sys_form]]]]], ['#BQ', [let, [[sys_xx_restarts_xx, ['#COMMA', sys_form]]], ['#BQ-COMMA-ELIPSE', forms]]]]]).
wl:arglist_info(restart_bind, cl_restart_bind, [sys_restart_bindings, c38_rest, forms], arginfo{all:[sys_restart_bindings], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_restart_bindings, forms], opt:0, req:[sys_restart_bindings], rest:[forms], sublists:0, whole:0}).
wl: init_args(1, cl_restart_bind).

/*

### Compiled:  `CL:RESTART-BIND` 
*/
cl_restart_bind(Restart_bindings_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_restart_bindings, Restart_bindings_In), bv(forms, RestNKeys)|CDR],
	global_env(CDR),
	catch(( LEnv=[bv(sys_form, sys_xx_restarts_xx)|Env],
		get_var(LEnv, sys_restart_bindings, Restart_bindings_Get),
		cl_reverse(Restart_bindings_Get, List),
		BV=bv(binding, Ele),
		AEnv=[BV|LEnv],
		forall(member(Ele, List),
		       ( nb_setarg(2, BV, Ele),
			 get_var(AEnv, binding, Binding_Get),
			 cl_car(Binding_Get, Car_Ret),
			 get_var(AEnv, binding, Binding_Get12),
			 cl_cdr(Binding_Get12, Cdr_Ret),
			 get_var(AEnv, sys_form, Form_Get),
			 set_var(AEnv,
				 sys_form,
				 
				 [ cons,
				   [sys_make_restart, [quote, Car_Ret]|Cdr_Ret],
				   Form_Get
				 ]).
		       )),
		get_var(LEnv, forms, Forms_Get),
		get_var(LEnv, sys_form, Form_Get18),
		[let, [[sys_xx_restarts_xx, Form_Get18]]|Forms_Get]=MFResult
	      ),
	      block_exit(restart_bind, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_restart_bind, classof, claz_macro),
   set_opv(restart_bind, compile_as, kw_operator),
   set_opv(restart_bind, function, cl_restart_bind),
   DefMacroResult=restart_bind.
/*
:- side_effect(assert_lsp(restart_bind,
			  lambda_def(defmacro,
				     restart_bind,
				     cl_restart_bind,
				     [sys_restart_bindings, c38_rest, forms],
				     
				     [ progn,
				       
				       [ let,
					 
					 [ 
					   [ sys_form,
					     [quote, sys_xx_restarts_xx]
					   ]
					 ],
					 
					 [ dolist,
					   
					   [ binding,
					     [reverse, sys_restart_bindings]
					   ],
					   
					   [ setq,
					     sys_form,
					     
					     [ '#BQ',
					       
					       [ cons,
						 
						 [ sys_make_restart,
						   
						   [ quote,
						     ['#COMMA', [car, binding]]
						   ],
						   
						   [ '#BQ-COMMA-ELIPSE',
						     [cdr, binding]
						   ]
						 ],
						 ['#COMMA', sys_form]
					       ]
					     ]
					   ]
					 ],
					 
					 [ '#BQ',
					   
					   [ let,
					     
					     [ 
					       [ sys_xx_restarts_xx,
						 ['#COMMA', sys_form]
					       ]
					     ],
					     ['#BQ-COMMA-ELIPSE', forms]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(restart_bind,
			  arglist_info(restart_bind,
				       cl_restart_bind,
				       [sys_restart_bindings, c38_rest, forms],
				       arginfo{ all:[sys_restart_bindings],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_restart_bindings,
							forms
						      ],
						opt:0,
						req:[sys_restart_bindings],
						rest:[forms],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(restart_bind, init_args(1, cl_restart_bind))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro restart-case (restartable-form &rest clauses)
  (let ((catch-tag (gensym))
	(bindings nil))
    `(catch ',catch-tag
      (restart-bind
	  ,(dolist (clause clauses (reverse bindings))
	     (let ((name (car clause))
		   (lambda-list (cadr clause))
		   (rest (cddr clause))
		   (interactive '#'(lambda () nil))
		   (report '#'(lambda (stream)
				(format stream ""#+(or WAM-CL LISP500) \r\n(defmacro restart-case (restartable-form &rest clauses)\r\n  (let ((catch-tag (gensym))\r\n\t(bindings nil))\r\n    `(catch ',catch-tag\r\n      (restart-bind\r\n\t  ,(dolist (clause clauses (reverse bindings))\r\n\t     (let ((name (car clause))\r\n\t\t   (lambda-list (cadr clause))\r\n\t\t   (rest (cddr clause))\r\n\t\t   (interactive '#'(lambda () nil))\r\n\t\t   (report '#'(lambda (stream)\r\n\t\t\t\t(format stream \"~A\" (car clause))))\r\n\t\t   (test '#'(lambda (condition) t)))\r\n\t       (tagbody\r\n\t\tstart\r\n\t\t  (when (member (car rest) '(:interactive :report :test))\r\n\t\t    (let ((value (cadr rest)))\r\n\t\t      (case (car rest)\r\n\t\t\t(:interactive (setq interactive `(function ,value)))\r\n\t\t\t(:report (setq report\r\n\t\t\t\t       (if (stringp value)\r\n\t\t\t\t\t   `#'(lambda (stream)\r\n\t\t\t\t\t\t(write-string ,value stream))\r\n\t\t\t\t\t   `(function ,value))))\r\n\t\t\t(:test (setq test `(function ,value)))))\r\n\t\t    (setq rest (cddr rest))\r\n\t\t    (go start)))\r\n\t       (push `(,(car clause)\r\n\t\t       #'(lambda ,(cadr clause)\r\n\t\t\t   (throw ',catch-tag (progn ,@rest)))\r\n\t\t       :interactive-function ,interactive\r\n\t\t       :report-function ,report\r\n\t\t       :test-function ,test)\r\n\t\t     bindings)))\r\n\t,restartable-form))))\r\n\r\n\r\n\r\n".
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:52935 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'restart-case',['restartable-form','&rest',clauses],[let,[['catch-tag',[gensym]],[bindings,[]]],['#BQ',[catch,[quote,['#COMMA','catch-tag']],['restart-bind',['#COMMA',[dolist,[clause,clauses,[reverse,bindings]],[let,[[name,[car,clause]],['lambda-list',[cadr,clause]],[rest,[cddr,clause]],[interactive,[quote,function([lambda,[],[]])]],[report,[quote,function([lambda,[stream],[format,stream,'$STRING'("~A"),[car,clause]]])]],[test,[quote,function([lambda,[condition],t])]]],[tagbody,start,[when,[member,[car,rest],[quote,[':interactive',':report',':test']]],[let,[[value,[cadr,rest]]],[case,[car,rest],[':interactive',[setq,interactive,['#BQ',[function,['#COMMA',value]]]]],[':report',[setq,report,[if,[stringp,value],['#BQ',function([lambda,[stream],['write-string',['#COMMA',value],stream]])],['#BQ',[function,['#COMMA',value]]]]]],[':test',[setq,test,['#BQ',[function,['#COMMA',value]]]]]]],[setq,rest,[cddr,rest]],[go,start]]],[push,['#BQ',[['#COMMA',[car,clause]],function([lambda,['#COMMA',[cadr,clause]],[throw,[quote,['#COMMA','catch-tag']],[progn,['#BQ-COMMA-ELIPSE',rest]]]]),':interactive-function',['#COMMA',interactive],':report-function',['#COMMA',report],':test-function',['#COMMA',test]]],bindings]]]],['#COMMA','restartable-form']]]]]]).
/*
% case:-[[kw_interactive,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]],[kw_report,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]],[kw_test,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]].
*/
/*
% conds:-[[[eq,_184755666,[quote,kw_interactive]],[progn,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]]],[[eq,_184755666,[quote,kw_report]],[progn,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]]],[[eq,_184755666,[quote,kw_test]],[progn,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]]].
*/
/*
% case:-[[kw_interactive,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]],[kw_report,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]],[kw_test,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]].
*/
/*
% conds:-[[[eq,_185319736,[quote,kw_interactive]],[progn,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]]],[[eq,_185319736,[quote,kw_report]],[progn,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]]],[[eq,_185319736,[quote,kw_test]],[progn,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]]].
*/
wl:lambda_def(defmacro,restart_case,cl_restart_case,[sys_restartable_form,c38_rest,sys_clauses],[progn,[let,[[sys_catch_tag,[gensym]],[bindings,[]]],['#BQ',[catch,[quote,['#COMMA',sys_catch_tag]],[restart_bind,['#COMMA',[dolist,[sys_clause,sys_clauses,[reverse,bindings]],[let,[[sys_name,[car,sys_clause]],[sys_lambda_list,[cadr,sys_clause]],[rest,[cddr,sys_clause]],[sys_interactive,[quote,function([lambda,[],[]])]],[sys_report,[quote,function([lambda,[stream],[format,stream,'$ARRAY'([*],claz_base_character,"~A"),[car,sys_clause]]])]],[test,[quote,function([lambda,[condition],t])]]],[tagbody,start,[when,[member,[car,rest],[quote,[kw_interactive,kw_report,kw_test]]],[let,[[sys_value,[cadr,rest]]],[case,[car,rest],[kw_interactive,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]],[kw_report,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]],[kw_test,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]]],[setq,rest,[cddr,rest]],[go,start]]],[push,['#BQ',[['#COMMA',[car,sys_clause]],function([lambda,['#COMMA',[cadr,sys_clause]],[throw,[quote,['#COMMA',sys_catch_tag]],[progn,['#BQ-COMMA-ELIPSE',rest]]]]),kw_interactive_function,['#COMMA',sys_interactive],kw_report_function,['#COMMA',sys_report],kw_test_function,['#COMMA',test]]],bindings]]]],['#COMMA',sys_restartable_form]]]]]]).
wl:arglist_info(restart_case,cl_restart_case,[sys_restartable_form,c38_rest,sys_clauses],arginfo{all:[sys_restartable_form],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_restartable_form,sys_clauses],opt:0,req:[sys_restartable_form],rest:[sys_clauses],sublists:0,whole:0}).
wl:init_args(1,cl_restart_case).

/*

### Compiled:  `CL:RESTART-CASE` 
*/
cl_restart_case(_184572814,_184582572,_184571676):-nop(defmacro),_184572074=[bv(sys_restartable_form,_184572814),bv(sys_clauses,_184582572)|_184558846],global_env(_184558846),catch((cl_gensym(_184597488),_184595922=[bv(sys_catch_tag,_184597488),bv(bindings,[])|_184572074],get_var(_184595922,bindings,_184656906),get_var(_184595922,sys_catch_tag,_184622118),_184649640=[bv(reverse,_184656906)|_184595922],get_var(_184649640,sys_clauses,_186060888),_186060240=bv(sys_clause,_186060544),_184674156=[_186060240|_184649640],forall(member(_186060544,_186060888),(nb_setarg(2,_186060240,_186060544),get_var(_184674156,sys_clause,_184681798),cl_car(_184681798,_184681678),get_var(_184674156,sys_clause,_184684622),cl_cadr(_184684622,_184683632),get_var(_184674156,sys_clause,_184686608),cl_cddr(_184686608,_184685618),_184680534=[bv(sys_name,_184681678),bv(sys_lambda_list,_184683632),bv(rest,_184685618),bv(sys_interactive,function([lambda,[],[]])),bv(sys_report,function([lambda,[stream],[format,stream,'$ARRAY'([*],claz_base_character,"~A"),[car,sys_clause]]])),bv(test,function([lambda,[condition],t]))|_184674156],call_addr_block(_184680534,(push_label(start),get_var(_184680534,rest,_185300054),cl_car(_185300054,_185299148),cl_member(_185299148,[kw_interactive,kw_report,kw_test],[],_185298472),(_185298472\==[]->get_var(_184680534,rest,_185308682),cl_cadr(_185308682,_185315530),_185307472=[bv(sys_value,_185315530)|_184680534],get_var(_185307472,rest,_185318530),cl_car(_185318530,_185319736),(is_eq(_185319736,kw_interactive)->get_var(_185307472,sys_value,_185634836),set_var(_185307472,sys_interactive,[function,_185634836]),_185307260=[function,_185634836];(is_eq(_185319736,kw_report)->get_var(_185307472,sys_value,_185649908),(is_stringp(_185649908)->_185699948=function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]]);get_var(_185307472,sys_value,_185653116),_185699948=[function,_185653116]),set_var(_185307472,sys_report,_185699948),_185706778=_185699948;(is_eq(_185319736,kw_test)->get_var(_185307472,sys_value,_185687530),set_var(_185307472,test,[function,_185687530]),_185700296=[function,_185687530];_185697476=[],_185700296=_185697476),_185706778=_185700296),_185307260=_185706778),get_var(_184680534,rest,_185742528),cl_cddr(_185742528,_185741360),set_var(_184680534,rest,_185741360),goto(start,_184680534),_184721752=_185744616;_184721752=[])),[addr(addr_tagbody_29_start,start,'$unused',_185836276,(get_var(_185836276,rest,_185836300),cl_car(_185836300,_188075708),cl_member(_188075708,[kw_interactive,kw_report,kw_test],[],_185836332),(_185836332\==[]->get_var(_185836276,rest,_185836378),cl_cadr(_185836378,_185836400),_185836416=[bv(sys_value,_185836400)|_185836276],get_var(_185836416,rest,_185836456),cl_car(_185836456,_185836482),(is_eq(_185836482,kw_interactive)->get_var(_185836416,sys_value,_185836538),set_var(_185836416,sys_interactive,[function,_185836538]),_185836574=[function,_185836538];(is_eq(_185836482,kw_report)->get_var(_185836416,sys_value,_185836638),(is_stringp(_185836638)->_185836674=function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]]);get_var(_185836416,sys_value,_185836694),_185836674=[function,_185836694]),set_var(_185836416,sys_report,_185836674),_185836746=_185836674;(is_eq(_185836482,kw_test)->get_var(_185836416,sys_value,_185836798),set_var(_185836416,test,[function,_185836798]),_185836844=[function,_185836798];_185836876=[],_185836844=_185836876),_185836746=_185836844),_185836574=_185836746),get_var(_185836276,rest,_185836914),cl_cddr(_185836914,_185836936),set_var(_185836276,rest,_185836936),goto(start,_185836276),_185836966=_185836972;_185836966=[])))]),cl_push(['#BQ',[['#COMMA',[car,sys_clause]],function([lambda,['#COMMA',[cadr,sys_clause]],[throw,[quote,['#COMMA',sys_catch_tag]],[progn,['#BQ-COMMA-ELIPSE',rest]]]]),kw_interactive_function,['#COMMA',sys_interactive],kw_report_function,['#COMMA',sys_report],kw_test_function,['#COMMA',test]]],bindings,_184680322))),get_var(_184649640,bindings,_186100436),cl_reverse(_186100436,_184649428),get_var(_184595922,sys_restartable_form,_186604360),[catch,[quote,_184622118],[restart_bind,_184649428,_186604360]]=_184571404),block_exit(restart_case,_184571404),true),cl_eval(_184571404,_184571676).
:-set_opv(cl_restart_case,classof,claz_macro),set_opv(restart_case,compile_as,kw_operator),set_opv(restart_case,function,cl_restart_case),_184541744=restart_case.
/*
:-side_effect(assert_lsp(restart_case,lambda_def(defmacro,restart_case,cl_restart_case,[sys_restartable_form,c38_rest,sys_clauses],[progn,[let,[[sys_catch_tag,[gensym]],[bindings,[]]],['#BQ',[catch,[quote,['#COMMA',sys_catch_tag]],[restart_bind,['#COMMA',[dolist,[sys_clause,sys_clauses,[reverse,bindings]],[let,[[sys_name,[car,sys_clause]],[sys_lambda_list,[cadr,sys_clause]],[rest,[cddr,sys_clause]],[sys_interactive,[quote,function([lambda,[],[]])]],[sys_report,[quote,function([lambda,[stream],[format,stream,'$ARRAY'([*],claz_base_character,"~A"),[car,sys_clause]]])]],[test,[quote,function([lambda,[condition],t])]]],[tagbody,start,[when,[member,[car,rest],[quote,[kw_interactive,kw_report,kw_test]]],[let,[[sys_value,[cadr,rest]]],[case,[car,rest],[kw_interactive,[setq,sys_interactive,['#BQ',[function,['#COMMA',sys_value]]]]],[kw_report,[setq,sys_report,[if,[stringp,sys_value],['#BQ',function([lambda,[stream],[write_string,['#COMMA',sys_value],stream]])],['#BQ',[function,['#COMMA',sys_value]]]]]],[kw_test,[setq,test,['#BQ',[function,['#COMMA',sys_value]]]]]]],[setq,rest,[cddr,rest]],[go,start]]],[push,['#BQ',[['#COMMA',[car,sys_clause]],function([lambda,['#COMMA',[cadr,sys_clause]],[throw,[quote,['#COMMA',sys_catch_tag]],[progn,['#BQ-COMMA-ELIPSE',rest]]]]),kw_interactive_function,['#COMMA',sys_interactive],kw_report_function,['#COMMA',sys_report],kw_test_function,['#COMMA',test]]],bindings]]]],['#COMMA',sys_restartable_form]]]]]]))).
*/
/*
:-side_effect(assert_lsp(restart_case,arglist_info(restart_case,cl_restart_case,[sys_restartable_form,c38_rest,sys_clauses],arginfo{all:[sys_restartable_form],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_restartable_form,sys_clauses],opt:0,req:[sys_restartable_form],rest:[sys_clauses],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(restart_case,init_args(1,cl_restart_case))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro with-simple-restart ((name format-control &rest format-arguments)
			       &rest forms)
  (let ((tag (gensym)))
    `(block ,tag
      (restart-bind
	  ((,name
	    #'(lambda () (return-from ,tag (values nil t)))
	     :interactive-function #'(lambda () nil)
	     :report-function #'(lambda (stream)
				  (apply #'format stream ',format-control
					 ',format-arguments))
	     :test-function #'(lambda () t)))
	,@forms))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:54134 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,'with-simple-restart',[[name,'format-control','&rest','format-arguments'],'&rest',forms],[let,[[tag,[gensym]]],['#BQ',[block,['#COMMA',tag],['restart-bind',[[['#COMMA',name],function([lambda,[],['return-from',['#COMMA',tag],[values,[],t]]]),':interactive-function',function([lambda,[],[]]),':report-function',function([lambda,[stream],[apply,function(format),stream,[quote,['#COMMA','format-control']],[quote,['#COMMA','format-arguments']]]]),':test-function',function([lambda,[],t])]],['#BQ-COMMA-ELIPSE',forms]]]]]]).
wl:lambda_def(defmacro, with_simple_restart, cl_with_simple_restart, [[sys_name, sys_format_control, c38_rest, sys_format_arguments], c38_rest, forms], [progn, [let, [[sys_tag, [gensym]]], ['#BQ', [block, ['#COMMA', sys_tag], [restart_bind, [[['#COMMA', sys_name], function([lambda, [], [return_from, ['#COMMA', sys_tag], [values, [], t]]]), kw_interactive_function, function([lambda, [], []]), kw_report_function, function([lambda, [stream], [apply, function(format), stream, [quote, ['#COMMA', sys_format_control]], [quote, ['#COMMA', sys_format_arguments]]]]), kw_test_function, function([lambda, [], t])]], ['#BQ-COMMA-ELIPSE', forms]]]]]]).
wl:arglist_info(with_simple_restart, cl_with_simple_restart, [[sys_name, sys_format_control, c38_rest, sys_format_arguments], c38_rest, forms], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[forms, sys_name, sys_format_control, sys_format_arguments], opt:0, req:0, rest:[forms], sublists:0, whole:0}).
wl: init_args(1, cl_with_simple_restart).

/*

### Compiled:  `CL:WITH-SIMPLE-RESTART` 
*/
cl_with_simple_restart([Name_In, Format_control_In|Format_arguments_In], RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(forms, RestNKeys), bv(sys_name, Name_In), bv(sys_format_control, Format_control_In), bv(sys_format_arguments, Format_arguments_In)|SubEnv],
	global_env(SubEnv),
	catch(( cl_gensym(Tag_Init),
		LEnv=[bv(sys_tag, Tag_Init)|Env],
		get_var(LEnv, sys_name, Name_Get),
		get_var(LEnv, sys_tag, Tag_Get),
		get_var(LEnv, forms, Forms_Get),
		[block, Tag_Get, [restart_bind, [[Name_Get, function([lambda, [], [return_from, ['#COMMA', sys_tag], [values, [], t]]]), kw_interactive_function, function([lambda, [], []]), kw_report_function, function([lambda, [stream], [apply, function(format), stream, [quote, ['#COMMA', sys_format_control]], [quote, ['#COMMA', sys_format_arguments]]]]), kw_test_function, function([lambda, [], t])]]|Forms_Get]]=MFResult
	      ),
	      block_exit(with_simple_restart, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_with_simple_restart, classof, claz_macro),
   set_opv(with_simple_restart, compile_as, kw_operator),
   set_opv(with_simple_restart, function, cl_with_simple_restart),
   DefMacroResult=with_simple_restart.
/*
:- side_effect(assert_lsp(with_simple_restart,
			  lambda_def(defmacro,
				     with_simple_restart,
				     cl_with_simple_restart,
				     
				     [ 
				       [ sys_name,
					 sys_format_control,
					 c38_rest,
					 sys_format_arguments
				       ],
				       c38_rest,
				       forms
				     ],
				     
				     [ progn,
				       
				       [ let,
					 [[sys_tag, [gensym]]],
					 
					 [ '#BQ',
					   
					   [ block,
					     ['#COMMA', sys_tag],
					     
					     [ restart_bind,
					       
					       [ 
						 [ ['#COMMA', sys_name],
						   function(
							    [ lambda,
							      [],
							      
							      [ return_from,
								['#COMMA', sys_tag],
								[values, [], t]
							      ]
							    ]),
						   kw_interactive_function,
						   function([lambda, [], []]),
						   kw_report_function,
						   function(
							    [ lambda,
							      [stream],
							      
							      [ apply,
								function(format),
								stream,
								
								[ quote,
								  
								  [ '#COMMA',
								    sys_format_control
								  ]
								],
								
								[ quote,
								  
								  [ '#COMMA',
								    sys_format_arguments
								  ]
								]
							      ]
							    ]),
						   kw_test_function,
						   function([lambda, [], t]).
						 ]
					       ],
					       ['#BQ-COMMA-ELIPSE', forms]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(with_simple_restart,
			  arglist_info(with_simple_restart,
				       cl_with_simple_restart,
				       
				       [ 
					 [ sys_name,
					   sys_format_control,
					   c38_rest,
					   sys_format_arguments
					 ],
					 c38_rest,
					 forms
				       ],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ forms,
							sys_name,
							sys_format_control,
							sys_format_arguments
						      ],
						opt:0,
						req:0,
						rest:[forms],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(with_simple_restart,
			  init_args(1, cl_with_simple_restart))).
*/
/*
#+(or WAM-CL LISP500) 
(defun abort (&optional condition)
  (invoke-restart (find-restart 'abort condition))
  (error 'control-error))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:54614 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,abort,['&optional',condition],['invoke-restart',['find-restart',[quote,abort],condition]],[error,[quote,'control-error']]]).
wl:lambda_def(defun, abort, cl_abort, [c38_optional, condition], [[invoke_restart, [find_restart, [quote, abort], condition]], [error, [quote, control_error]]]).
wl:arglist_info(abort, cl_abort, [c38_optional, condition], arginfo{all:[condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[condition], opt:[condition], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, cl_abort).

/*

### Compiled:  `CL:ABORT` 
*/
cl_abort(Abort_Param, FnResult) :-
	Env9=[bv(condition, Condition_In)|Env],
	global_env(Env),
	append([], RestNKeys, Abort_Param),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env9, condition, Condition_Get),
		cl_find_restart(abort, Condition_Get, Invoke_restart_Param),
		cl_invoke_restart(Invoke_restart_Param, [], Invoke_restart_Ret),
		cl_error(control_error, Error_Ret),
		Error_Ret=FnResult
	      ),
	      block_exit(abort, FnResult),
	      true).
:- set_opv(cl_abort, classof, claz_function),
   set_opv(abort, compile_as, kw_function),
   set_opv(abort, function, cl_abort),
   DefunResult=abort.
/*
:- side_effect(assert_lsp(abort,
			  lambda_def(defun,
				     abort,
				     cl_abort,
				     [c38_optional, condition],
				     
				     [ 
				       [ invoke_restart,
					 
					 [ find_restart,
					   [quote, abort],
					   condition
					 ]
				       ],
				       [error, [quote, control_error]]
				     ]))).
*/
/*
:- side_effect(assert_lsp(abort,
			  arglist_info(abort,
				       cl_abort,
				       [c38_optional, condition],
				       arginfo{ all:[condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[condition],
						opt:[condition],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(abort, init_args(0, cl_abort))).
*/
/*
#+(or WAM-CL LISP500) 
(defun continue (&optional condition)
  (invoke-restart (find-restart 'continue condition)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:54755 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,continue,['&optional',condition],['invoke-restart',['find-restart',[quote,continue],condition]]]).
wl:lambda_def(defun, continue, cl_continue, [c38_optional, condition], [[invoke_restart, [find_restart, [quote, continue], condition]]]).
wl:arglist_info(continue, cl_continue, [c38_optional, condition], arginfo{all:[condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[condition], opt:[condition], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, cl_continue).

/*

### Compiled:  `CL:CONTINUE` 
*/
cl_continue(Continue_Param, FnResult) :-
	Env9=[bv(condition, Condition_In)|Env],
	global_env(Env),
	append([], RestNKeys, Continue_Param),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env9, condition, Condition_Get),
		cl_find_restart(continue, Condition_Get, Invoke_restart_Param),
		cl_invoke_restart(Invoke_restart_Param, [], Invoke_restart_Ret),
		Invoke_restart_Ret=FnResult
	      ),
	      block_exit(continue, FnResult),
	      true).
:- set_opv(cl_continue, classof, claz_function),
   set_opv(continue, compile_as, kw_function),
   set_opv(continue, function, cl_continue),
   DefunResult=continue.
/*
:- side_effect(assert_lsp(continue,
			  lambda_def(defun,
				     continue,
				     cl_continue,
				     [c38_optional, condition],
				     
				     [ 
				       [ invoke_restart,
					 
					 [ find_restart,
					   [quote, continue],
					   condition
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(continue,
			  arglist_info(continue,
				       cl_continue,
				       [c38_optional, condition],
				       arginfo{ all:[condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[condition],
						opt:[condition],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(continue, init_args(0, cl_continue))).
*/
/*
#+(or WAM-CL LISP500) 
(defun muffle-warning (&optional condition)
  (invoke-restart (find-restart 'muffle-warning condition))
  (error 'control-error))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:54876 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'muffle-warning',['&optional',condition],['invoke-restart',['find-restart',[quote,'muffle-warning'],condition]],[error,[quote,'control-error']]]).
wl:lambda_def(defun, muffle_warning, cl_muffle_warning, [c38_optional, condition], [[invoke_restart, [find_restart, [quote, muffle_warning], condition]], [error, [quote, control_error]]]).
wl:arglist_info(muffle_warning, cl_muffle_warning, [c38_optional, condition], arginfo{all:[condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[condition], opt:[condition], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, cl_muffle_warning).

/*

### Compiled:  `CL:MUFFLE-WARNING` 
*/
cl_muffle_warning(Muffle_warning_Param, FnResult) :-
	Env9=[bv(condition, Condition_In)|Env],
	global_env(Env),
	append([], RestNKeys, Muffle_warning_Param),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env9, condition, Condition_Get),
		cl_find_restart(muffle_warning,
				Condition_Get,
				Invoke_restart_Param),
		cl_invoke_restart(Invoke_restart_Param, [], Invoke_restart_Ret),
		cl_error(control_error, Error_Ret),
		Error_Ret=FnResult
	      ),
	      block_exit(muffle_warning, FnResult),
	      true).
:- set_opv(cl_muffle_warning, classof, claz_function),
   set_opv(muffle_warning, compile_as, kw_function),
   set_opv(muffle_warning, function, cl_muffle_warning),
   DefunResult=muffle_warning.
/*
:- side_effect(assert_lsp(muffle_warning,
			  lambda_def(defun,
				     muffle_warning,
				     cl_muffle_warning,
				     [c38_optional, condition],
				     
				     [ 
				       [ invoke_restart,
					 
					 [ find_restart,
					   [quote, muffle_warning],
					   condition
					 ]
				       ],
				       [error, [quote, control_error]]
				     ]))).
*/
/*
:- side_effect(assert_lsp(muffle_warning,
			  arglist_info(muffle_warning,
				       cl_muffle_warning,
				       [c38_optional, condition],
				       arginfo{ all:[condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[condition],
						opt:[condition],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(muffle_warning, init_args(0, cl_muffle_warning))).
*/
/*
#+(or WAM-CL LISP500) 
(defun store-value (value &optional condition)
  (invoke-restart (find-restart 'store-value condition) value))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55035 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'store-value',[value,'&optional',condition],['invoke-restart',['find-restart',[quote,'store-value'],condition],value]]).
wl:lambda_def(defun, store_value, cl_store_value, [sys_value, c38_optional, condition], [[invoke_restart, [find_restart, [quote, store_value], condition], sys_value]]).
wl:arglist_info(store_value, cl_store_value, [sys_value, c38_optional, condition], arginfo{all:[sys_value, condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_value, condition], opt:[condition], req:[sys_value], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_store_value).

/*

### Compiled:  `CL:STORE-VALUE` 
*/
cl_store_value(Value_In, RestNKeys, FnResult) :-
	Env11=[bv(sys_value, Value_In), bv(condition, Condition_In)|Env],
	global_env(Env),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env11, condition, Condition_Get),
		cl_find_restart(store_value,
				Condition_Get,
				Invoke_restart_Param),
		get_var(Env11, sys_value, Value_Get),
		cl_invoke_restart(Invoke_restart_Param,
				  Value_Get,
				  Invoke_restart_Ret),
		Invoke_restart_Ret=FnResult
	      ),
	      block_exit(store_value, FnResult),
	      true).
:- set_opv(cl_store_value, classof, claz_function),
   set_opv(store_value, compile_as, kw_function),
   set_opv(store_value, function, cl_store_value),
   DefunResult=store_value.
/*
:- side_effect(assert_lsp(store_value,
			  lambda_def(defun,
				     store_value,
				     cl_store_value,
				     [sys_value, c38_optional, condition],
				     
				     [ 
				       [ invoke_restart,
					 
					 [ find_restart,
					   [quote, store_value],
					   condition
					 ],
					 sys_value
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(store_value,
			  arglist_info(store_value,
				       cl_store_value,
				       [sys_value, c38_optional, condition],
				       arginfo{ all:[sys_value, condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_value, condition],
						opt:[condition],
						req:[sys_value],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(store_value, init_args(1, cl_store_value))).
*/
/*
#+(or WAM-CL LISP500) 
(defun use-value (value &optional condition)
  (invoke-restart (find-restart 'use-value condition) value))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55174 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'use-value',[value,'&optional',condition],['invoke-restart',['find-restart',[quote,'use-value'],condition],value]]).
wl:lambda_def(defun, use_value, cl_use_value, [sys_value, c38_optional, condition], [[invoke_restart, [find_restart, [quote, use_value], condition], sys_value]]).
wl:arglist_info(use_value, cl_use_value, [sys_value, c38_optional, condition], arginfo{all:[sys_value, condition], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_value, condition], opt:[condition], req:[sys_value], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_use_value).

/*

### Compiled:  `CL:USE-VALUE` 
*/
cl_use_value(Value_In, RestNKeys, FnResult) :-
	Env11=[bv(sys_value, Value_In), bv(condition, Condition_In)|Env],
	global_env(Env),
	opt_var(Env, condition, Condition_In, true, [], 1, RestNKeys),
	catch(( get_var(Env11, condition, Condition_Get),
		cl_find_restart(use_value, Condition_Get, Invoke_restart_Param),
		get_var(Env11, sys_value, Value_Get),
		cl_invoke_restart(Invoke_restart_Param,
				  Value_Get,
				  Invoke_restart_Ret),
		Invoke_restart_Ret=FnResult
	      ),
	      block_exit(use_value, FnResult),
	      true).
:- set_opv(cl_use_value, classof, claz_function),
   set_opv(use_value, compile_as, kw_function),
   set_opv(use_value, function, cl_use_value),
   DefunResult=use_value.
/*
:- side_effect(assert_lsp(use_value,
			  lambda_def(defun,
				     use_value,
				     cl_use_value,
				     [sys_value, c38_optional, condition],
				     
				     [ 
				       [ invoke_restart,
					 
					 [ find_restart,
					   [quote, use_value],
					   condition
					 ],
					 sys_value
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(use_value,
			  arglist_info(use_value,
				       cl_use_value,
				       [sys_value, c38_optional, condition],
				       arginfo{ all:[sys_value, condition],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_value, condition],
						opt:[condition],
						req:[sys_value],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(use_value, init_args(1, cl_use_value))).
*/
/*
#+(or WAM-CL LISP500) 
(defun integer-string (integer &optional (radix 10))
  (if (= integer 0)
      "0"
      (labels ((recur (i l)
		 (if (= i 0)
		     l
		     (multiple-value-bind (ni r)
			 (floor i radix)
		       (recur ni (cons (code-char (+ (if (< r 10) 48 55) r))
				       l))))))
	(apply #'string (if (< 0 integer)
			    (recur integer nil)
			    (cons (code-char 45) (recur (- integer) nil)))))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55311 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'integer-string',[integer,'&optional',[radix,10]],[if,[=,integer,0],'$STRING'("0"),[labels,[[recur,[i,l],[if,[=,i,0],l,['multiple-value-bind',[ni,r],[floor,i,radix],[recur,ni,[cons,['code-char',[+,[if,[<,r,10],48,55],r]],l]]]]]],[apply,function(string),[if,[<,0,integer],[recur,integer,[]],[cons,['code-char',45],[recur,[-,integer],[]]]]]]]]).
wl:lambda_def(defun, sys_integer_string, f_sys_integer_string, [integer, c38_optional, [sys_radix, 10]], [[if, [=, integer, 0], '$ARRAY'([*], claz_base_character, "0"), [labels, [[sys_recur, [sys_i, sys_l], [if, [=, sys_i, 0], sys_l, [multiple_value_bind, [sys_ni, sys_r], [floor, sys_i, sys_radix], [sys_recur, sys_ni, [cons, [code_char, [+, [if, [<, sys_r, 10], 48, 55], sys_r]], sys_l]]]]]], [apply, function(string), [if, [<, 0, integer], [sys_recur, integer, []], [cons, [code_char, 45], [sys_recur, [-, integer], []]]]]]]]).
wl:arglist_info(sys_integer_string, f_sys_integer_string, [integer, c38_optional, [sys_radix, 10]], arginfo{all:[integer, sys_radix], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[integer, sys_radix], opt:[sys_radix], req:[integer], rest:0, sublists:0, whole:0}).
wl: init_args(1, f_sys_integer_string).

/*

### Compiled:  `SYS::INTEGER-STRING` 
*/
f_sys_integer_string(Integer_In, RestNKeys, FnResult) :-
	Env9=[bv(integer, Integer_In), bv(sys_radix, Radix_In)|Env],
	global_env(Env),
	opt_var(Env, sys_radix, Radix_In, true, 10, 1, RestNKeys),
	catch(( (   integer=:=0
		->  _194081930='$ARRAY'([*], claz_base_character, "0")
		;   assert_lsp(sys_recur,
			       wl:lambda_def(defun, sys_recur, f_sys_recur11, [sys_i, sys_l], [[if, [=, sys_i, 0], sys_l, [multiple_value_bind, [sys_ni, sys_r], [floor, sys_i, sys_radix], [sys_recur, sys_ni, [cons, [code_char, [+, [if, [<, sys_r, 10], 48, 55], sys_r]], sys_l]]]]])),
		    assert_lsp(sys_recur,
			       wl:arglist_info(sys_recur, f_sys_recur11, [sys_i, sys_l], arginfo{all:[sys_i, sys_l], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_i, sys_l], opt:0, req:[sys_i, sys_l], rest:0, sublists:0, whole:0})), !,
		    assert_lsp(sys_recur,
			       wl:init_args(exact_only, f_sys_recur11)),
		    assert_lsp(sys_recur,
			       (f_sys_recur11(I_In, L_In, FnResult10):-Env40=[bv(sys_i, I_In), bv(sys_l, L_In)|Env9], global_env(Env9), catch((get_var(Env40, sys_i, I_Get), (I_Get=:=0->get_var(Env40, sys_l, L_Get), _194100038=L_Get;LEnv=[bv(sys_ni, []), bv(sys_r, [])|Env40], get_var(LEnv, sys_i, I_Get21), get_var(LEnv, sys_radix, Radix_Get), cl_floor(I_Get21, Radix_Get, Floor_Ret), setq_from_values(LEnv, [sys_ni, sys_r]), get_var(LEnv, sys_ni, Ni_Get), get_var(LEnv, sys_r, R_Get), (R_Get<10->_194136924=48;_194136924=55), get_var(LEnv, sys_r, R_Get28), +(_194136924, R_Get28, Code_char_Param), cl_code_char(Code_char_Param, Code_char_Ret), get_var(LEnv, sys_l, L_Get29), _194136052=[Code_char_Ret|L_Get29], f_sys_recur1(Ni_Get, _194136052, LetResult), _194100038=LetResult), _194100038=FnResult10), block_exit(sys_recur, FnResult10), true))),
		    (   0<integer
		    ->  f_sys_recur11(integer, [], TrueResult35),
			String_Param=TrueResult35
		    ;   cl_code_char(45, Code_char_Ret46),
			-(0, integer, Integer),
			f_sys_recur11(Integer, [], Recur11_Ret),
			ElseResult36=[Code_char_Ret46|Recur11_Ret],
			String_Param=ElseResult36
		    ),
		    cl_string(String_Param, ElseResult37),
		    _194081930=ElseResult37
		),
		_194081930=FnResult
	      ),
	      block_exit(sys_integer_string, FnResult),
	      true).
:- set_opv(f_sys_integer_string, classof, claz_function),
   set_opv(sys_integer_string, compile_as, kw_function),
   set_opv(sys_integer_string, function, f_sys_integer_string),
   DefunResult=sys_integer_string.
/*
:- side_effect(assert_lsp(sys_integer_string,
			  lambda_def(defun,
				     sys_integer_string,
				     f_sys_integer_string,
				     [integer, c38_optional, [sys_radix, 10]],
				     
				     [ 
				       [ if,
					 [=, integer, 0],
					 '$ARRAY'([*], claz_base_character, "0"),
					 
					 [ labels,
					   
					   [ 
					     [ sys_recur,
					       [sys_i, sys_l],
					       
					       [ if,
						 [=, sys_i, 0],
						 sys_l,
						 
						 [ multiple_value_bind,
						   [sys_ni, sys_r],
						   [floor, sys_i, sys_radix],
						   
						   [ sys_recur,
						     sys_ni,
						     
						     [ cons,
						       
						       [ code_char,
							 
							 [ (+),
							   
							   [ if,
							     [<, sys_r, 10],
							     48,
							     55
							   ],
							   sys_r
							 ]
						       ],
						       sys_l
						     ]
						   ]
						 ]
					       ]
					     ]
					   ],
					   
					   [ apply,
					     function(string),
					     
					     [ if,
					       [<, 0, integer],
					       [sys_recur, integer, []],
					       
					       [ cons,
						 [code_char, 45],
						 [sys_recur, [-, integer], []]
					       ]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_integer_string,
			  arglist_info(sys_integer_string,
				       f_sys_integer_string,
				       [integer, c38_optional, [sys_radix, 10]],
				       arginfo{ all:[integer, sys_radix],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[integer, sys_radix],
						opt:[sys_radix],
						req:[integer],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_integer_string,
			  init_args(1, f_sys_integer_string))).
*/
/*
#+(or WAM-CL LISP500)
(defun designator-symbol (designator)
  (if (symbolp designator)
      designator
      (find-symbol designator)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55746 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'designator-symbol',[designator],[if,[symbolp,designator],designator,['find-symbol',designator]]]).
wl:lambda_def(defun, sys_designator_symbol, f_sys_designator_symbol, [sys_designator], [[if, [symbolp, sys_designator], sys_designator, [find_symbol, sys_designator]]]).
wl:arglist_info(sys_designator_symbol, f_sys_designator_symbol, [sys_designator], arginfo{all:[sys_designator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_designator], opt:0, req:[sys_designator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_designator_symbol).

/*

### Compiled:  `SYS::DESIGNATOR-SYMBOL` 
*/
f_sys_designator_symbol(Designator_In, FnResult) :-
	Env14=[bv(sys_designator, Designator_In)|Env],
	global_env(Env),
	catch(( get_var(Env14, sys_designator, Designator_Get),
		(   is_symbolp(Designator_Get)
		->  get_var(Env14, sys_designator, Designator_Get8),
		    _195881830=Designator_Get8
		;   get_var(Env14, sys_designator, Designator_Get9),
		    cl_find_symbol(Designator_Get9, ElseResult),
		    _195881830=ElseResult
		),
		_195881830=FnResult
	      ),
	      block_exit(sys_designator_symbol, FnResult),
	      true).
:- set_opv(f_sys_designator_symbol, classof, claz_function),
   set_opv(sys_designator_symbol, compile_as, kw_function),
   set_opv(sys_designator_symbol, function, f_sys_designator_symbol),
   DefunResult=sys_designator_symbol.
/*
:- side_effect(assert_lsp(sys_designator_symbol,
			  lambda_def(defun,
				     sys_designator_symbol,
				     f_sys_designator_symbol,
				     [sys_designator],
				     
				     [ 
				       [ if,
					 [symbolp, sys_designator],
					 sys_designator,
					 [find_symbol, sys_designator]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_designator_symbol,
			  arglist_info(sys_designator_symbol,
				       f_sys_designator_symbol,
				       [sys_designator],
				       arginfo{ all:[sys_designator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_designator],
						opt:0,
						req:[sys_designator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_designator_symbol,
			  init_args(exact_only, f_sys_designator_symbol))).
*/
/*
#+BUILTIN 
(defun symbolp (object) (or (null object) (eq (type-of object) 'symbol)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55890 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[defun,symbolp,[object],[or,[null,object],[eq,['type-of',object],[quote,symbol]]]]]))
/*
#+BUILTIN 
(defun keywordp (object) 
(and (symbolp object)
       (string= (package-name (symbol-package object)) "KEYwORD")))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:55979 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[defun,keywordp,[object],[and,[symbolp,object],['string=',['package-name',['symbol-package',object]],'$STRING'("KEYwORD")]]]]))
/*
#+BUILTIN 
(defun make-symbol (name)
  (let ((symbol (makei 9 0 name nil nil nil nil (- 1) 0)))
    (imakunbound symbol 4)
    (imakunbound symbol 5)
    (imakunbound symbol 6)
    symbol))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:56112 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[defun,'make-symbol',[name],[let,[[symbol,[makei,9,0,name,[],[],[],[],[-,1],0]]],[imakunbound,symbol,4],[imakunbound,symbol,5],[imakunbound,symbol,6],symbol]]]))
/*
#+(or WAM-CL LISP500)
(defvar *gensym-counter* 0)
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:56311 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defvar,'*gensym-counter*',0]).
:- set_var(AEnv, xx_gensym_counter_xx, 0).
/*
#+(or WAM-CL LISP500)
(defun gen-sym (&optional x)
  (let ((prefix (if (stringp x) x "G"))
	(suffix (if (fixnump x)
		    x
		    (let ((x *gensym-counter*))
		      (setf *gensym-counter* (+ 1 *gensym-counter*))))))
    (make-symbol (conc-string prefix (integer-string suffix)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:56363 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'gen-sym',['&optional',x],[let,[[prefix,[if,[stringp,x],x,'$STRING'("G")]],[suffix,[if,[fixnump,x],x,[let,[[x,'*gensym-counter*']],[setf,'*gensym-counter*',[+,1,'*gensym-counter*']]]]]],['make-symbol',['conc-string',prefix,['integer-string',suffix]]]]]).
wl:lambda_def(defun, sys_gen_sym, f_sys_gen_sym, [c38_optional, sys_x], [[let, [[sys_prefix, [if, [stringp, sys_x], sys_x, '$ARRAY'([*], claz_base_character, "G")]], [sys_suffix, [if, [sys_fixnump, sys_x], sys_x, [let, [[sys_x, xx_gensym_counter_xx]], [setf, xx_gensym_counter_xx, [+, 1, xx_gensym_counter_xx]]]]]], [make_symbol, [sys_conc_string, sys_prefix, [sys_integer_string, sys_suffix]]]]]).
wl:arglist_info(sys_gen_sym, f_sys_gen_sym, [c38_optional, sys_x], arginfo{all:[sys_x], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x], opt:[sys_x], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, f_sys_gen_sym).

/*

### Compiled:  `SYS::GEN-SYM` 
*/
f_sys_gen_sym(Gen_sym_Param, FnResult) :-
	Env33=[bv(sys_x, X_In)|Env],
	global_env(Env),
	append([], RestNKeys, Gen_sym_Param),
	opt_var(Env, sys_x, X_In, true, [], 1, RestNKeys),
	catch(( get_var(Env33, sys_x, X_Get),
		(   is_stringp(X_Get)
		->  get_var(Env33, sys_x, X_Get13),
		    Prefix_Init=X_Get13
		;   Prefix_Init='$ARRAY'([*], claz_base_character, "G")
		),
		get_var(Env33, sys_x, X_Get17),
		f_sys_fixnump(X_Get17, IFTEST15),
		(   IFTEST15\==[]
		->  get_var(Env33, sys_x, X_Get18),
		    Suffix_Init=X_Get18
		;   get_var(Env33,
			    xx_gensym_counter_xx,
			    Xx_gensym_counter_xx_Get),
		    LEnv21=[bv(sys_x, Xx_gensym_counter_xx_Get)|Env33],
		    get_var(LEnv21,
			    xx_gensym_counter_xx,
			    Xx_gensym_counter_xx_Get24),
		    +(1, Xx_gensym_counter_xx_Get24, LetResult20),
		    set_var(LEnv21, xx_gensym_counter_xx, LetResult20),
		    Suffix_Init=LetResult20
		),
		LEnv=[bv(sys_prefix, Prefix_Init), bv(sys_suffix, Suffix_Init)|Env33],
		get_var(LEnv, sys_prefix, Prefix_Get),
		get_var(LEnv, sys_suffix, Suffix_Get),
		f_sys_integer_string(Suffix_Get, [], Integer_string_Ret),
		f_sys_conc_string(Prefix_Get,
				  Integer_string_Ret,
				  Make_symbol_Param),
		cl_make_symbol(Make_symbol_Param, LetResult),
		LetResult=FnResult
	      ),
	      block_exit(sys_gen_sym, FnResult),
	      true).
:- set_opv(f_sys_gen_sym, classof, claz_function),
   set_opv(sys_gen_sym, compile_as, kw_function),
   set_opv(sys_gen_sym, function, f_sys_gen_sym),
   DefunResult=sys_gen_sym.
/*
:- side_effect(assert_lsp(sys_gen_sym,
			  lambda_def(defun,
				     sys_gen_sym,
				     f_sys_gen_sym,
				     [c38_optional, sys_x],
				     
				     [ 
				       [ let,
					 
					 [ 
					   [ sys_prefix,
					     
					     [ if,
					       [stringp, sys_x],
					       sys_x,
					       '$ARRAY'([*],
							claz_base_character,
							"G")
					     ]
					   ],
					   
					   [ sys_suffix,
					     
					     [ if,
					       [sys_fixnump, sys_x],
					       sys_x,
					       
					       [ let,
						 
						 [ 
						   [ sys_x,
						     xx_gensym_counter_xx
						   ]
						 ],
						 
						 [ setf,
						   xx_gensym_counter_xx,
						   [+, 1, xx_gensym_counter_xx]
						 ]
					       ]
					     ]
					   ]
					 ],
					 
					 [ make_symbol,
					   
					   [ sys_conc_string,
					     sys_prefix,
					     [sys_integer_string, sys_suffix]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_gen_sym,
			  arglist_info(sys_gen_sym,
				       f_sys_gen_sym,
				       [c38_optional, sys_x],
				       arginfo{ all:[sys_x],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x],
						opt:[sys_x],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_gen_sym, init_args(0, f_sys_gen_sym))).
*/
/*
(let ((gentemp-counter 0))
  (defun gentemp (&optional (prefix "T") (package *package*))
    (setf gentemp-counter (+ 1 gentemp-counter))
    (intern (conc-string prefix (integer-string gentemp-counter))
	    package)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:56655 **********************/
:-lisp_compile_to_prolog(pkg_sys,[let,[['gentemp-counter',0]],[defun,gentemp,['&optional',[prefix,'$STRING'("T")],[package,'*package*']],[setf,'gentemp-counter',[+,1,'gentemp-counter']],[intern,['conc-string',prefix,['integer-string','gentemp-counter']],package]]]).
:- LEnv=[bv(sys_gentemp_counter, 0)|CDR].
wl:lambda_def(defun, gentemp, cl_gentemp, [c38_optional, [sys_prefix, '$ARRAY'([*], claz_base_character, "T")], [package, xx_package_xx]], [[setf, sys_gentemp_counter, [+, 1, sys_gentemp_counter]], [intern, [sys_conc_string, sys_prefix, [sys_integer_string, sys_gentemp_counter]], package]]).
wl:arglist_info(gentemp, cl_gentemp, [c38_optional, [sys_prefix, '$ARRAY'([*], claz_base_character, "T")], [package, xx_package_xx]], arginfo{all:[sys_prefix, package], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_prefix, package], opt:[sys_prefix, package], req:0, rest:0, sublists:0, whole:0}).
wl: init_args(0, cl_gentemp).

/*

### Compiled:  `CL:GENTEMP` 
*/
cl_gentemp(Gentemp_Param, FnResult) :-
	Env17=[bv(sys_prefix, Prefix_In), bv(package, Package_In)|LEnv],
	global_env(LEnv),
	append([], RestNKeys, Gentemp_Param),
	opt_var(LEnv,
		sys_prefix,
		Prefix_In,
		true,
		'$ARRAY'([*], claz_base_character, "T"),
		1,
		RestNKeys),
	opt_var(LEnv,
		package,
		Package_In,
		get_var(Get_var_Param, xx_package_xx, Xx_package_xx_Get),
		Xx_package_xx_Get,
		2,
		RestNKeys),
	catch(( get_var(Env17, sys_gentemp_counter, Gentemp_counter_Get),
		+(1, Gentemp_counter_Get, Gentemp_counter),
		set_var(Env17, sys_gentemp_counter, Gentemp_counter),
		get_var(Env17, sys_gentemp_counter, Gentemp_counter_Get13),
		get_var(Env17, sys_prefix, Prefix_Get),
		f_sys_integer_string(Gentemp_counter_Get13,
				     [],
				     Integer_string_Ret),
		f_sys_conc_string(Prefix_Get, Integer_string_Ret, Intern_Param),
		get_var(Env17, package, Package_Get),
		cl_intern(Intern_Param, Package_Get, Intern_Ret),
		Intern_Ret=FnResult
	      ),
	      block_exit(gentemp, FnResult),
	      true).
:- set_opv(cl_gentemp, classof, claz_function),
   set_opv(gentemp, compile_as, kw_function),
   set_opv(gentemp, function, cl_gentemp),
   DefunResult=gentemp.
/*
:- side_effect(assert_lsp(gentemp,
			  lambda_def(defun,
				     gentemp,
				     cl_gentemp,
				     
				     [ c38_optional,
				       
				       [ sys_prefix,
					 '$ARRAY'([*], claz_base_character, "T")
				       ],
				       [package, xx_package_xx]
				     ],
				     
				     [ 
				       [ setf,
					 sys_gentemp_counter,
					 [+, 1, sys_gentemp_counter]
				       ],
				       
				       [ intern,
					 
					 [ sys_conc_string,
					   sys_prefix,
					   
					   [ sys_integer_string,
					     sys_gentemp_counter
					   ]
					 ],
					 package
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(gentemp,
			  arglist_info(gentemp,
				       cl_gentemp,
				       
				       [ c38_optional,
					 
					 [ sys_prefix,
					   '$ARRAY'([*],
						    claz_base_character,
						    "T")
					 ],
					 [package, xx_package_xx]
				       ],
				       arginfo{ all:[sys_prefix, package],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_prefix, package],
						opt:[sys_prefix, package],
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(gentemp, init_args(0, cl_gentemp))).
*/
/*
#+BUILTIN 
#+(or WAM-CL LISP500)
(defun get (symbol indicator &optional default)
  (getf (symbol-plist symbol) indicator default))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:56884 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,get,[symbol,indicator,'&optional',default],[getf,['symbol-plist',symbol],indicator,default]]]]))
/*
#+(or WAM-CL LISP500)
(defun (setf get) (new-value symbol indicator &optional default)
  (setf (getf (symbol-plist symbol) indicator default) new-value))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57021 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,[setf,get],['new-value',symbol,indicator,'&optional',default],[setf,[getf,['symbol-plist',symbol],indicator,default],'new-value']]).
/*
:- side_effect((compile_each($, _199663770, [sys_indicator, sys_default], [sys_indicator, sys_default], true), append([[symbol_plist, symbol], sys_indicator, sys_default], [CAR11, CAR], [[symbol_plist, symbol], sys_indicator, sys_default, CAR11, CAR]), setf_inverse_op(getf, []))).
*/
/*
:- side_effect((compile_each($, _199663770, [sys_indicator, sys_default], [sys_indicator, sys_default], true), append([[symbol_plist, symbol], sys_indicator, sys_default], [CAR11, CAR], [[symbol_plist, symbol], sys_indicator, sys_default, CAR11, CAR]), setf_inverse_op(getf, setf_getf))).
*/
/*
:- side_effect((compile_each($, _199663770, [sys_indicator, sys_default], [sys_indicator, sys_default], true), append([[symbol_plist, symbol], sys_indicator, sys_default], [CAR11, CAR], [[symbol_plist, symbol], sys_indicator, sys_default, CAR11, CAR]), setf_inverse_op(getf, []))).
*/
:- assert_lisp(get, wl:declared(get, defun_setf(setf_get))).
wl:lambda_def(defun, setf_get, cl_setf_get, ['&environment', '$env', sys_new_value, symbol, sys_indicator, c38_optional, sys_default], [[setf, [getf, [symbol_plist, symbol], sys_indicator, sys_default], sys_new_value]]).
wl: declared(cl_setf_get, env_arg1).

wl:arglist_info(setf_get, cl_setf_get, ['&environment', '$env', sys_new_value, symbol, sys_indicator, c38_optional, sys_default], arginfo{all:[sys_new_value, symbol, sys_indicator, sys_default], allow_other_keys:0, aux:0, body:0, complex:[environment], env:['$env'], key:0, names:['$env', sys_new_value, symbol, sys_indicator, sys_default], opt:[sys_default], req:[sys_new_value, symbol, sys_indicator], rest:0, sublists:0, whole:0}).
wl: init_args(3, cl_setf_get).

/*

### Compiled:  `CL::SETF-GET` 
*/
cl_setf_get(New_value_In, Symbol_In, Indicator_In, RestNKeys, FnResult) :-
	Env18=[bv('$env', C36_env_In), bv(sys_new_value, New_value_In), bv(symbol, Symbol_In), bv(sys_indicator, Indicator_In), bv(sys_default, Default_In)|Env],
	global_env(Env),
	parent_env(C36_env_In),
	opt_var(Env, sys_default, Default_In, true, [], 1, RestNKeys),
	catch(( get_var(Env18, symbol, Symbol_Get),
		cl_symbol_plist(Symbol_Get, Symbol_plist_Ret),
		get_var(Env18, sys_indicator, Indicator_Get),
		get_var(Env18, sys_new_value, New_value_Get),
		get_var(Env18, sys_default, Default_Get),
		cl_apply([],
			 
			 [ Symbol_plist_Ret,
			   Indicator_Get,
			   Default_Get,
			   New_value_Get
			 ],
			 Apply_Ret),
		Apply_Ret=FnResult
	      ),
	      block_exit(setf_get, FnResult),
	      true).
:- set_opv(cl_setf_get, classof, claz_function),
   set_opv(setf_get, compile_as, kw_function),
   set_opv(setf_get, function, cl_setf_get),
   DefunResult=setf_get.
/*
:- side_effect(assert_lsp(setf_get,
			  lambda_def(defun,
				     setf_get,
				     cl_setf_get,
				     
				     [ '&environment',
				       '$env',
				       sys_new_value,
				       symbol,
				       sys_indicator,
				       c38_optional,
				       sys_default
				     ],
				     
				     [ 
				       [ setf,
					 
					 [ getf,
					   [symbol_plist, symbol],
					   sys_indicator,
					   sys_default
					 ],
					 sys_new_value
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(setf_get,
			  arglist_info(setf_get,
				       cl_setf_get,
				       
				       [ '&environment',
					 '$env',
					 sys_new_value,
					 symbol,
					 sys_indicator,
					 c38_optional,
					 sys_default
				       ],
				       arginfo{ all:
						    [ sys_new_value,
						      symbol,
						      sys_indicator,
						      sys_default
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[environment],
						env:['$env'],
						key:0,
						names:
						      [ '$env',
							sys_new_value,
							symbol,
							sys_indicator,
							sys_default
						      ],
						opt:[sys_default],
						req:
						    [ sys_new_value,
						      symbol,
						      sys_indicator
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(setf_get, init_args(3, cl_setf_get))).
*/
/*
#+(or WAM-CL LISP500)
(defun (setf rest) (new-tail list) (setf (cdr list) new-tail))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57180 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,[setf,rest],['new-tail',list],[setf,[cdr,list],'new-tail']]).
/*
:- side_effect((compile_each($, _200753808, [], [], true), append([list], [CAR8, CAR], [list, CAR8, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, _200753808, [], [], true), append([list], [CAR8, CAR], [list, CAR8, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, _200753808, [], [], true), append([list], [CAR8, CAR], [list, CAR8, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, _200753808, [], [], true), append([list], [CAR8, CAR], [list, CAR8, CAR]), setf_inverse_op(cdr, rplacd))).
*/
:- assert_lisp(rest, wl:declared(rest, defun_setf(setf_rest))).
wl:lambda_def(defun, setf_rest, cl_setf_rest, ['&environment', '$env', sys_new_tail, list], [[setf, [cdr, list], sys_new_tail]]).
wl: declared(cl_setf_rest, env_arg1).

wl:arglist_info(setf_rest, cl_setf_rest, ['&environment', '$env', sys_new_tail, list], arginfo{all:[sys_new_tail, list], allow_other_keys:0, aux:0, body:0, complex:[environment], env:['$env'], key:0, names:['$env', sys_new_tail, list], opt:0, req:[sys_new_tail, list], rest:0, sublists:0, whole:0}).
wl: init_args(2, cl_setf_rest).

/*

### Compiled:  `CL::SETF-REST` 
*/
cl_setf_rest(New_tail_In, List_In, RestNKeys, FnResult) :-
	Env13=[bv('$env', C36_env_In), bv(sys_new_tail, New_tail_In), bv(list, List_In)|Env],
	global_env(Env),
	parent_env(C36_env_In),
	catch(( get_var(Env13, list, List_Get),
		get_var(Env13, sys_new_tail, New_tail_Get),
		cl_rplacd(List_Get, New_tail_Get, Rplacd_Ret),
		Rplacd_Ret=FnResult
	      ),
	      block_exit(setf_rest, FnResult),
	      true).
:- set_opv(cl_setf_rest, classof, claz_function),
   set_opv(setf_rest, compile_as, kw_function),
   set_opv(setf_rest, function, cl_setf_rest),
   DefunResult=setf_rest.
/*
:- side_effect(assert_lsp(setf_rest,
			  lambda_def(defun,
				     setf_rest,
				     cl_setf_rest,
				     ['&environment', '$env', sys_new_tail, list],
				     [[setf, [cdr, list], sys_new_tail]]))).
*/
/*
:- side_effect(assert_lsp(setf_rest,
			  arglist_info(setf_rest,
				       cl_setf_rest,
				       
				       [ '&environment',
					 '$env',
					 sys_new_tail,
					 list
				       ],
				       arginfo{ all:[sys_new_tail, list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[environment],
						env:['$env'],
						key:0,
						names:
						      [ '$env',
							sys_new_tail,
							list
						      ],
						opt:0,
						req:[sys_new_tail, list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(setf_rest, init_args(2, cl_setf_rest))).
*/
/*
#+(or WAM-CL LISP500)
(defun remprop (symbol indicator) (remf (symbol-plist symbol) indicator))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57269 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,remprop,[symbol,indicator],[remf,['symbol-plist',symbol],indicator]]).
wl:lambda_def(defun, remprop, cl_remprop, [symbol, sys_indicator], [[remf, [symbol_plist, symbol], sys_indicator]]).
wl:arglist_info(remprop, cl_remprop, [symbol, sys_indicator], arginfo{all:[symbol, sys_indicator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[symbol, sys_indicator], opt:0, req:[symbol, sys_indicator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_remprop).

/*

### Compiled:  `CL:REMPROP` 
*/
cl_remprop(Symbol_In, Indicator_In, FnResult) :-
	Env7=[bv(symbol, Symbol_In), bv(sys_indicator, Indicator_In)|Env],
	global_env(Env),
	catch(( cl_remf([symbol_plist, symbol], sys_indicator, Indicator),
		Indicator=FnResult
	      ),
	      block_exit(remprop, FnResult),
	      true).
:- set_opv(cl_remprop, classof, claz_function),
   set_opv(remprop, compile_as, kw_function),
   set_opv(remprop, function, cl_remprop),
   DefunResult=remprop.
/*
:- side_effect(assert_lsp(remprop,
			  lambda_def(defun,
				     remprop,
				     cl_remprop,
				     [symbol, sys_indicator],
				     
				     [ 
				       [ remf,
					 [symbol_plist, symbol],
					 sys_indicator
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(remprop,
			  arglist_info(remprop,
				       cl_remprop,
				       [symbol, sys_indicator],
				       arginfo{ all:[symbol, sys_indicator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[symbol, sys_indicator],
						opt:0,
						req:[symbol, sys_indicator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(remprop, init_args(exact_only, cl_remprop))).
*/
/*
#+BUILTIN 
#+(or WAM-CL LISP500)
(defun makunbound (symbol) (imakunbound symbol 4))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57369 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,makunbound,[symbol],[imakunbound,symbol,4]]]]))
/*
#+BUILTIN 
#+(or WAM-CL LISP500)
(defun set (symbol value) (setf (symbol-value symbol) value))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57458 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,set,[symbol,value],[setf,['symbol-value',symbol],value]]]]))
/*
#+(or WAM-CL LISP500)
(defun designator-string (designator)
  (if (stringp designator)
      designator
      (if (characterp designator)
	  (string designator)
	  (symbol-name designator))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57558 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'designator-string',[designator],[if,[stringp,designator],designator,[if,[characterp,designator],[string,designator],['symbol-name',designator]]]]).
wl:lambda_def(defun, sys_designator_string, f_sys_designator_string, [sys_designator], [[if, [stringp, sys_designator], sys_designator, [if, [characterp, sys_designator], [string, sys_designator], [symbol_name, sys_designator]]]]).
wl:arglist_info(sys_designator_string, f_sys_designator_string, [sys_designator], arginfo{all:[sys_designator], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_designator], opt:0, req:[sys_designator], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_designator_string).

/*

### Compiled:  `SYS::DESIGNATOR-STRING` 
*/
f_sys_designator_string(Designator_In, FnResult) :-
	Env21=[bv(sys_designator, Designator_In)|Env],
	global_env(Env),
	catch(( get_var(Env21, sys_designator, Designator_Get),
		(   is_stringp(Designator_Get)
		->  get_var(Env21, sys_designator, Designator_Get8),
		    _202705926=Designator_Get8
		;   get_var(Env21, sys_designator, Designator_Get10),
		    (   string:is_characterp(Designator_Get10)
		    ->  get_var(Env21, sys_designator, Designator_Get13),
			cl_string(Designator_Get13, TrueResult),
			ElseResult18=TrueResult
		    ;   get_var(Env21, sys_designator, Designator_Get14),
			cl_symbol_name(Designator_Get14, ElseResult),
			ElseResult18=ElseResult
		    ),
		    _202705926=ElseResult18
		),
		_202705926=FnResult
	      ),
	      block_exit(sys_designator_string, FnResult),
	      true).
:- set_opv(f_sys_designator_string, classof, claz_function),
   set_opv(sys_designator_string, compile_as, kw_function),
   set_opv(sys_designator_string, function, f_sys_designator_string),
   DefunResult=sys_designator_string.
/*
:- side_effect(assert_lsp(sys_designator_string,
			  lambda_def(defun,
				     sys_designator_string,
				     f_sys_designator_string,
				     [sys_designator],
				     
				     [ 
				       [ if,
					 [stringp, sys_designator],
					 sys_designator,
					 
					 [ if,
					   [characterp, sys_designator],
					   [string, sys_designator],
					   [symbol_name, sys_designator]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_designator_string,
			  arglist_info(sys_designator_string,
				       f_sys_designator_string,
				       [sys_designator],
				       arginfo{ all:[sys_designator],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_designator],
						opt:0,
						req:[sys_designator],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_designator_string,
			  init_args(exact_only, f_sys_designator_string))).
*/
/*
#+BUILTIN 
#+(or WAM-CL LISP500)
(defvar *package* (car (cdr *packages*)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57759 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defvar,'*package*',[car,[cdr,'*packages*']]]]]))
/*
#+(or WAM-CL LISP500)
(defun list-all-packages ()
  (copy-list *packages*))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57839 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'list-all-packages',[],['copy-list','*packages*']]).
wl:lambda_def(defun, list_all_packages, cl_list_all_packages, [], [[copy_list, sys_xx_packages_xx]]).
wl:arglist_info(list_all_packages, cl_list_all_packages, [], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[], opt:0, req:0, rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_list_all_packages).

/*

### Compiled:  `CL:LIST-ALL-PACKAGES` 
*/
cl_list_all_packages(FnResult) :-
	GEnv=Env,
	global_env(Env),
	catch(( get_var(GEnv, sys_xx_packages_xx, Xx_packages_xx_Get),
		cl_copy_list(Xx_packages_xx_Get, Copy_list_Ret),
		Copy_list_Ret=FnResult
	      ),
	      block_exit(list_all_packages, FnResult),
	      true).
:- set_opv(cl_list_all_packages, classof, claz_function),
   set_opv(list_all_packages, compile_as, kw_function),
   set_opv(list_all_packages, function, cl_list_all_packages),
   DefunResult=list_all_packages.
/*
:- side_effect(assert_lsp(list_all_packages,
			  lambda_def(defun,
				     list_all_packages,
				     cl_list_all_packages,
				     [],
				     [[copy_list, sys_xx_packages_xx]]))).
*/
/*
:- side_effect(assert_lsp(list_all_packages,
			  arglist_info(list_all_packages,
				       cl_list_all_packages,
				       [],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[],
						opt:0,
						req:0,
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(list_all_packages,
			  init_args(exact_only, cl_list_all_packages))).
*/
/*
#+(or WAM-CL LISP500)
(defun /= (number &rest numbers)
  (tagbody
   start
     (when numbers
       (dolist (n numbers)
	 (when (= number n)
	   (return-from /=)))
       (setq number (pop numbers))
       (go start)))
  t)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:57920 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,/=,[number,'&rest',numbers],[tagbody,start,[when,numbers,[dolist,[n,numbers],[when,[=,number,n],['return-from',/=]]],[setq,number,[pop,numbers]],[go,start]]],t]).
wl:lambda_def(defun, /=, f_sys_c47_c61, [number, c38_rest, sys_numbers], [[tagbody, start, [when, sys_numbers, [dolist, [n, sys_numbers], [when, [=, number, n], [return_from, /=]]], [setq, number, [pop, sys_numbers]], [go, start]]], t]).
wl:arglist_info(/=, f_sys_c47_c61, [number, c38_rest, sys_numbers], arginfo{all:[number], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[number, sys_numbers], opt:0, req:[number], rest:[sys_numbers], sublists:0, whole:0}).
wl: init_args(1, f_sys_c47_c61).

/*

### Compiled:  `/=` 
*/
f_sys_c47_c61(Number_In, RestNKeys, FnResult) :-
	AEnv42=[bv(number, Number_In), bv(sys_numbers, RestNKeys)|Env],
	global_env(Env),
	catch(( call_addr_block(AEnv42,
				(push_label(start), get_var(AEnv42, sys_numbers, IFTEST27), (IFTEST27\==[]->get_var(AEnv42, sys_numbers, Numbers_Get30), BV38=bv(n, Ele40), BlockExitEnv36=[BV38|AEnv42], forall(member(Ele40, Numbers_Get30),  (nb_setarg(2, BV38, Ele40), get_var(BlockExitEnv36, n, N_Get32), (number=:=N_Get32->set_var(BlockExitEnv36, 'block_ret_/=', []), always('block_exit_/=', BlockExitEnv36);_204278120=[]))), cl_pop(sys_numbers, Number), set_var(AEnv42, number, Number), goto(start, AEnv42), _TBResult=_GORES43;_TBResult=[])),
				
				[ addr(addr_tagbody_30_start,
				       start,
				       '$unused',
				       AEnv,
				       (get_var(AEnv, sys_numbers, IFTEST), (IFTEST\==[]->get_var(AEnv, sys_numbers, Numbers_Get10), CAR=bv(n, Member_Param), BlockExitEnv=[CAR|AEnv], forall(member(Member_Param, Numbers_Get10),  (nb_setarg(2, CAR, Member_Param), get_var(BlockExitEnv, n, N_Get), (number=:=N_Get->set_var(BlockExitEnv, 'block_ret_/=', []), always('block_exit_/=', BlockExitEnv);_204332116=[]))), cl_pop(sys_numbers, Pop_Ret), set_var(AEnv, number, Pop_Ret), goto(start, AEnv), _204332160=_GORES;_204332160=[])))
				]),
		t=FnResult
	      ),
	      block_exit(/=, FnResult),
	      true).
:- set_opv(f_sys_c47_c61, classof, claz_function),
   set_opv(/=, compile_as, kw_function),
   set_opv(/=, function, f_sys_c47_c61),
   DefunResult= /= .
/*
:- side_effect(assert_lsp(/=,
			  lambda_def(defun,
				     /=,
				     f_sys_c47_c61,
				     [number, c38_rest, sys_numbers],
				     
				     [ 
				       [ tagbody,
					 start,
					 
					 [ when,
					   sys_numbers,
					   
					   [ dolist,
					     [n, sys_numbers],
					     
					     [ when,
					       [=, number, n],
					       [return_from, /=]
					     ]
					   ],
					   [setq, number, [pop, sys_numbers]],
					   [go, start]
					 ]
				       ],
				       t
				     ]))).
*/
/*
:- side_effect(assert_lsp(/=,
			  arglist_info(/=,
				       f_sys_c47_c61,
				       [number, c38_rest, sys_numbers],
				       arginfo{ all:[number],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[number, sys_numbers],
						opt:0,
						req:[number],
						rest:[sys_numbers],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(/=, init_args(1, f_sys_c47_c61))).
*/
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun > (&rest numbers) (apply #'< (reverse numbers)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58162 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,>,['&rest',numbers],[apply,function(<),[reverse,numbers]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun <= (number &rest numbers)
  (dolist (n numbers t)
    (when (< n number)
      (return-from <=))
    (setq number n)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58258 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,<=,[number,'&rest',numbers],[dolist,[n,numbers,t],[when,[<,n,number],['return-from',<=]],[setq,number,n]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun >= (number &rest numbers)
  (dolist (n numbers t)
    (when (< number n)
      (return-from >=))
    (setq number n)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58426 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,>=,[number,'&rest',numbers],[dolist,[n,numbers,t],[when,[<,number,n],['return-from',>=]],[setq,number,n]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun max (real &rest reals)
  (dolist (r reals real)
    (when (< real r)
      (setq real r))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58594 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,max,[real,'&rest',reals],[dolist,[r,reals,real],[when,[<,real,r],[setq,real,r]]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun min (real &rest reals)
  (dolist (r reals real)
    (when (< r real)
      (setq real r))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58734 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,min,[real,'&rest',reals],[dolist,[r,reals,real],[when,[<,r,real],[setq,real,r]]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun oddp (integer)
  (= (mod integer 2) 1))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58874 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,oddp,[integer],[=,[mod,integer,2],1]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun evenp (integer)
  (= (mod integer 2) 0))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:58960 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,evenp,[integer],[=,[mod,integer,2],0]]]]))
/*
#+(or WAM-CL LISP500) 
(defun minusp (real)
  (< real 0))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59049 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,minusp,[real],[<,real,0]]).
wl:lambda_def(defun, minusp, cl_minusp, [real], [[<, real, 0]]).
wl:arglist_info(minusp, cl_minusp, [real], arginfo{all:[real], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[real], opt:0, req:[real], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_minusp).

/*

### Compiled:  `CL:MINUSP` 
*/
cl_minusp(Real_In, FnResult) :-
	Env7=[bv(real, Real_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, real, Real_Get),
		<(Real_Get, 0, _206775442),
		_206775442=FnResult
	      ),
	      block_exit(minusp, FnResult),
	      true).
:- set_opv(cl_minusp, classof, claz_function),
   set_opv(minusp, compile_as, kw_function),
   set_opv(minusp, function, cl_minusp),
   DefunResult=minusp.
/*
:- side_effect(assert_lsp(minusp,
			  lambda_def(defun,
				     minusp,
				     cl_minusp,
				     [real],
				     [[<, real, 0]]))).
*/
/*
:- side_effect(assert_lsp(minusp,
			  arglist_info(minusp,
				       cl_minusp,
				       [real],
				       arginfo{ all:[real],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[real],
						opt:0,
						req:[real],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(minusp, init_args(exact_only, cl_minusp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun plusp (real)
  (< 0 real))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59114 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,plusp,[real],[<,0,real]]).
wl:lambda_def(defun, plusp, cl_plusp, [real], [[<, 0, real]]).
wl:arglist_info(plusp, cl_plusp, [real], arginfo{all:[real], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[real], opt:0, req:[real], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_plusp).

/*

### Compiled:  `CL:PLUSP` 
*/
cl_plusp(Real_In, FnResult) :-
	Env7=[bv(real, Real_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, real, Real_Get),
		<(0, Real_Get, _207334668),
		_207334668=FnResult
	      ),
	      block_exit(plusp, FnResult),
	      true).
:- set_opv(cl_plusp, classof, claz_function),
   set_opv(plusp, compile_as, kw_function),
   set_opv(plusp, function, cl_plusp),
   DefunResult=plusp.
/*
:- side_effect(assert_lsp(plusp,
			  lambda_def(defun, plusp, cl_plusp, [real], [[<, 0, real]]))).
*/
/*
:- side_effect(assert_lsp(plusp,
			  arglist_info(plusp,
				       cl_plusp,
				       [real],
				       arginfo{ all:[real],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[real],
						opt:0,
						req:[real],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(plusp, init_args(exact_only, cl_plusp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun zerop (real)
  (= real 0))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59178 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,zerop,[real],[=,real,0]]).
wl:lambda_def(defun, zerop, cl_zerop, [real], [[=, real, 0]]).
wl:arglist_info(zerop, cl_zerop, [real], arginfo{all:[real], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[real], opt:0, req:[real], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_zerop).

/*

### Compiled:  `CL:ZEROP` 
*/
cl_zerop(Real_In, FnResult) :-
	Env7=[bv(real, Real_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, real, Real_Get),
		=(Real_Get, 0, _207893366),
		_207893366=FnResult
	      ),
	      block_exit(zerop, FnResult),
	      true).
:- set_opv(cl_zerop, classof, claz_function),
   set_opv(zerop, compile_as, kw_function),
   set_opv(zerop, function, cl_zerop),
   DefunResult=zerop.
/*
:- side_effect(assert_lsp(zerop,
			  lambda_def(defun, zerop, cl_zerop, [real], [[=, real, 0]]))).
*/
/*
:- side_effect(assert_lsp(zerop,
			  arglist_info(zerop,
				       cl_zerop,
				       [real],
				       arginfo{ all:[real],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[real],
						opt:0,
						req:[real],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(zerop, init_args(exact_only, cl_zerop))).
*/
/*
#+(or WAM-CL LISP500) 
(defun abs (number)
  (if (< number 0)
      (- number)
      number))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59242 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,abs,[number],[if,[<,number,0],[-,number],number]]).
wl:lambda_def(defun, abs, cl_abs, [number], [[if, [<, number, 0], [-, number], number]]).
wl:arglist_info(abs, cl_abs, [number], arginfo{all:[number], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[number], opt:0, req:[number], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_abs).

/*

### Compiled:  `CL:ABS` 
*/
cl_abs(Number_In, FnResult) :-
	Env9=[bv(number, Number_In)|Env],
	global_env(Env),
	catch(( (   number<0
		->  -(0, number, TrueResult),
		    _208455414=TrueResult
		;   _208455414=number
		),
		_208455414=FnResult
	      ),
	      block_exit(abs, FnResult),
	      true).
:- set_opv(cl_abs, classof, claz_function),
   set_opv(abs, compile_as, kw_function),
   set_opv(abs, function, cl_abs),
   DefunResult=abs.
/*
:- side_effect(assert_lsp(abs,
			  lambda_def(defun,
				     abs,
				     cl_abs,
				     [number],
				     [[if, [<, number, 0], [-, number], number]]))).
*/
/*
:- side_effect(assert_lsp(abs,
			  arglist_info(abs,
				       cl_abs,
				       [number],
				       arginfo{ all:[number],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[number],
						opt:0,
						req:[number],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(abs, init_args(exact_only, cl_abs))).
*/
/*
#+(or WAM-CL LISP500) 
(defun byte (size position)
  (cons size position))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59347 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,byte,[size,position],[cons,size,position]]).
wl:lambda_def(defun, byte, cl_byte, [sys_size, position], [[cons, sys_size, position]]).
wl:arglist_info(byte, cl_byte, [sys_size, position], arginfo{all:[sys_size, position], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_size, position], opt:0, req:[sys_size, position], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_byte).

/*

### Compiled:  `CL:BYTE` 
*/
cl_byte(Size_In, Position_In, FnResult) :-
	Env9=[bv(sys_size, Size_In), bv(position, Position_In)|Env],
	global_env(Env),
	catch(( get_var(Env9, position, Position_Get),
		get_var(Env9, sys_size, Size_Get),
		_209066510=[Size_Get|Position_Get],
		_209066510=FnResult
	      ),
	      block_exit(byte, FnResult),
	      true).
:- set_opv(cl_byte, classof, claz_function),
   set_opv(byte, compile_as, kw_function),
   set_opv(byte, function, cl_byte),
   DefunResult=byte.
/*
:- side_effect(assert_lsp(byte,
			  lambda_def(defun,
				     byte,
				     cl_byte,
				     [sys_size, position],
				     [[cons, sys_size, position]]))).
*/
/*
:- side_effect(assert_lsp(byte,
			  arglist_info(byte,
				       cl_byte,
				       [sys_size, position],
				       arginfo{ all:[sys_size, position],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_size, position],
						opt:0,
						req:[sys_size, position],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(byte, init_args(exact_only, cl_byte))).
*/
/*
#+(or WAM-CL LISP500) 
(defun byte-size (bytespec)
  (car bytespec))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59427 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'byte-size',[bytespec],[car,bytespec]]).
wl:lambda_def(defun, byte_size, cl_byte_size, [sys_bytespec], [[car, sys_bytespec]]).
wl:arglist_info(byte_size, cl_byte_size, [sys_bytespec], arginfo{all:[sys_bytespec], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_bytespec], opt:0, req:[sys_bytespec], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_byte_size).

/*

### Compiled:  `CL:BYTE-SIZE` 
*/
cl_byte_size(Bytespec_In, FnResult) :-
	Env7=[bv(sys_bytespec, Bytespec_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, sys_bytespec, Bytespec_Get),
		cl_car(Bytespec_Get, Car_Ret),
		Car_Ret=FnResult
	      ),
	      block_exit(byte_size, FnResult),
	      true).
:- set_opv(cl_byte_size, classof, claz_function),
   set_opv(byte_size, compile_as, kw_function),
   set_opv(byte_size, function, cl_byte_size),
   DefunResult=byte_size.
/*
:- side_effect(assert_lsp(byte_size,
			  lambda_def(defun,
				     byte_size,
				     cl_byte_size,
				     [sys_bytespec],
				     [[car, sys_bytespec]]))).
*/
/*
:- side_effect(assert_lsp(byte_size,
			  arglist_info(byte_size,
				       cl_byte_size,
				       [sys_bytespec],
				       arginfo{ all:[sys_bytespec],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_bytespec],
						opt:0,
						req:[sys_bytespec],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(byte_size, init_args(exact_only, cl_byte_size))).
*/
/*
#+(or WAM-CL LISP500) 
(defun byte-position (bytespec)
  (cdr bytespec))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59501 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'byte-position',[bytespec],[cdr,bytespec]]).
wl:lambda_def(defun, byte_position, cl_byte_position, [sys_bytespec], [[cdr, sys_bytespec]]).
wl:arglist_info(byte_position, cl_byte_position, [sys_bytespec], arginfo{all:[sys_bytespec], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_bytespec], opt:0, req:[sys_bytespec], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_byte_position).

/*

### Compiled:  `CL:BYTE-POSITION` 
*/
cl_byte_position(Bytespec_In, FnResult) :-
	Env7=[bv(sys_bytespec, Bytespec_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, sys_bytespec, Bytespec_Get),
		cl_cdr(Bytespec_Get, Cdr_Ret),
		Cdr_Ret=FnResult
	      ),
	      block_exit(byte_position, FnResult),
	      true).
:- set_opv(cl_byte_position, classof, claz_function),
   set_opv(byte_position, compile_as, kw_function),
   set_opv(byte_position, function, cl_byte_position),
   DefunResult=byte_position.
/*
:- side_effect(assert_lsp(byte_position,
			  lambda_def(defun,
				     byte_position,
				     cl_byte_position,
				     [sys_bytespec],
				     [[cdr, sys_bytespec]]))).
*/
/*
:- side_effect(assert_lsp(byte_position,
			  arglist_info(byte_position,
				       cl_byte_position,
				       [sys_bytespec],
				       arginfo{ all:[sys_bytespec],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_bytespec],
						opt:0,
						req:[sys_bytespec],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(byte_position,
			  init_args(exact_only, cl_byte_position))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char= (&rest characters)
  (apply #'= (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59579 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char=',['&rest',characters],[apply,function(=),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c61, cl_char_c61, [c38_rest, sys_characters], [[apply, function(=), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c61, cl_char_c61, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c61).

/*

### Compiled:  `CL:CHAR=` 
*/
cl_char_c61(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, Mapcar_Ret),
		Mapcar_Ret=_210772094,
		_210772094=FnResult
	      ),
	      block_exit(char_c61, FnResult),
	      true).
:- set_opv(cl_char_c61, classof, claz_function),
   set_opv(char_c61, compile_as, kw_function),
   set_opv(char_c61, function, cl_char_c61),
   DefunResult=char_c61.
/*
:- side_effect(assert_lsp(char_c61,
			  lambda_def(defun,
				     char_c61,
				     cl_char_c61,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(=),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c61,
			  arglist_info(char_c61,
				       cl_char_c61,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c61, init_args(0, cl_char_c61))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char/= (&rest characters)
  (apply #'/= (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59686 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char/=',['&rest',characters],[apply,function(/=),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c47_c61, cl_char_c47_c61, [c38_rest, sys_characters], [[apply, function(/=), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c47_c61, cl_char_c47_c61, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c47_c61).

/*

### Compiled:  `CL:CHAR/=` 
*/
cl_char_c47_c61(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, C47_c61_Param),
		f_sys_c47_c61(C47_c61_Param, [], C47_c61_Ret),
		C47_c61_Ret=FnResult
	      ),
	      block_exit(char_c47_c61, FnResult),
	      true).
:- set_opv(cl_char_c47_c61, classof, claz_function),
   set_opv(char_c47_c61, compile_as, kw_function),
   set_opv(char_c47_c61, function, cl_char_c47_c61),
   DefunResult=char_c47_c61.
/*
:- side_effect(assert_lsp(char_c47_c61,
			  lambda_def(defun,
				     char_c47_c61,
				     cl_char_c47_c61,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(/=),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c47_c61,
			  arglist_info(char_c47_c61,
				       cl_char_c47_c61,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c47_c61, init_args(0, cl_char_c47_c61))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char< (&rest characters)
  (apply #'< (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59795 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char<',['&rest',characters],[apply,function(<),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c60, cl_char_c60, [c38_rest, sys_characters], [[apply, function(<), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c60, cl_char_c60, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c60).

/*

### Compiled:  `CL:CHAR<` 
*/
cl_char_c60(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, Mapcar_Ret),
		Mapcar_Ret<_211966138,
		_211966138=FnResult
	      ),
	      block_exit(char_c60, FnResult),
	      true).
:- set_opv(cl_char_c60, classof, claz_function),
   set_opv(char_c60, compile_as, kw_function),
   set_opv(char_c60, function, cl_char_c60),
   DefunResult=char_c60.
/*
:- side_effect(assert_lsp(char_c60,
			  lambda_def(defun,
				     char_c60,
				     cl_char_c60,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(<),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c60,
			  arglist_info(char_c60,
				       cl_char_c60,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c60, init_args(0, cl_char_c60))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char> (&rest characters)
  (apply #'> (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:59902 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char>',['&rest',characters],[apply,function(>),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c62, cl_char_c62, [c38_rest, sys_characters], [[apply, function(>), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c62, cl_char_c62, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c62).

/*

### Compiled:  `CL:CHAR>` 
*/
cl_char_c62(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, Mapcar_Ret),
		Mapcar_Ret>_212560328,
		_212560328=FnResult
	      ),
	      block_exit(char_c62, FnResult),
	      true).
:- set_opv(cl_char_c62, classof, claz_function),
   set_opv(char_c62, compile_as, kw_function),
   set_opv(char_c62, function, cl_char_c62),
   DefunResult=char_c62.
/*
:- side_effect(assert_lsp(char_c62,
			  lambda_def(defun,
				     char_c62,
				     cl_char_c62,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(>),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c62,
			  arglist_info(char_c62,
				       cl_char_c62,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c62, init_args(0, cl_char_c62))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char<= (&rest characters)
  (apply #'<= (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60009 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char<=',['&rest',characters],[apply,function(<=),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c60_c61, cl_char_c60_c61, [c38_rest, sys_characters], [[apply, function(<=), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c60_c61, cl_char_c60_c61, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c60_c61).

/*

### Compiled:  `CL:CHAR<=` 
*/
cl_char_c60_c61(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, C60_c61_Param),
		f_sys_c60_c61(C60_c61_Param, C60_c61_Ret),
		C60_c61_Ret=FnResult
	      ),
	      block_exit(char_c60_c61, FnResult),
	      true).
:- set_opv(cl_char_c60_c61, classof, claz_function),
   set_opv(char_c60_c61, compile_as, kw_function),
   set_opv(char_c60_c61, function, cl_char_c60_c61),
   DefunResult=char_c60_c61.
/*
:- side_effect(assert_lsp(char_c60_c61,
			  lambda_def(defun,
				     char_c60_c61,
				     cl_char_c60_c61,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(<=),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c60_c61,
			  arglist_info(char_c60_c61,
				       cl_char_c60_c61,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c60_c61, init_args(0, cl_char_c60_c61))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char>= (&rest characters)
  (apply #'>= (mapcar #'char-code characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60118 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char>=',['&rest',characters],[apply,function(>=),[mapcar,function('char-code'),characters]]]).
wl:lambda_def(defun, char_c62_c61, cl_char_c62_c61, [c38_rest, sys_characters], [[apply, function(>=), [mapcar, function(char_code), sys_characters]]]).
wl:arglist_info(char_c62_c61, cl_char_c62_c61, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_c62_c61).

/*

### Compiled:  `CL:CHAR>=` 
*/
cl_char_c62_c61(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_code, Characters_Get, Mapcar_Ret),
		Mapcar_Ret>=_213749174,
		_213749174=FnResult
	      ),
	      block_exit(char_c62_c61, FnResult),
	      true).
:- set_opv(cl_char_c62_c61, classof, claz_function),
   set_opv(char_c62_c61, compile_as, kw_function),
   set_opv(char_c62_c61, function, cl_char_c62_c61),
   DefunResult=char_c62_c61.
/*
:- side_effect(assert_lsp(char_c62_c61,
			  lambda_def(defun,
				     char_c62_c61,
				     cl_char_c62_c61,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(>=),
					 
					 [ mapcar,
					   function(char_code),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_c62_c61,
			  arglist_info(char_c62_c61,
				       cl_char_c62_c61,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_c62_c61, init_args(0, cl_char_c62_c61))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-equal (&rest characters)
  (apply #'char= (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60227 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-equal',['&rest',characters],[apply,function('char='),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_equal, cl_char_equal, [c38_rest, sys_characters], [[apply, function(char_c61), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_equal, cl_char_equal, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_equal).

/*

### Compiled:  `CL:CHAR-EQUAL` 
*/
cl_char_equal(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, Char_c61_Param),
		cl_char_c61(Char_c61_Param, Char_c61_Ret),
		Char_c61_Ret=FnResult
	      ),
	      block_exit(char_equal, FnResult),
	      true).
:- set_opv(cl_char_equal, classof, claz_function),
   set_opv(char_equal, compile_as, kw_function),
   set_opv(char_equal, function, cl_char_equal),
   DefunResult=char_equal.
/*
:- side_effect(assert_lsp(char_equal,
			  lambda_def(defun,
				     char_equal,
				     cl_char_equal,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c61),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_equal,
			  arglist_info(char_equal,
				       cl_char_equal,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_equal, init_args(0, cl_char_equal))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-not-equal (&rest characters)
  (apply #'char/= (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60345 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-not-equal',['&rest',characters],[apply,function('char/='),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_not_equal, cl_char_not_equal, [c38_rest, sys_characters], [[apply, function(char_c47_c61), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_not_equal, cl_char_not_equal, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_not_equal).

/*

### Compiled:  `CL:CHAR-NOT-EQUAL` 
*/
cl_char_not_equal(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, C47_c61_Param),
		cl_char_c47_c61(C47_c61_Param, C47_c61_Ret),
		C47_c61_Ret=FnResult
	      ),
	      block_exit(char_not_equal, FnResult),
	      true).
:- set_opv(cl_char_not_equal, classof, claz_function),
   set_opv(char_not_equal, compile_as, kw_function),
   set_opv(char_not_equal, function, cl_char_not_equal),
   DefunResult=char_not_equal.
/*
:- side_effect(assert_lsp(char_not_equal,
			  lambda_def(defun,
				     char_not_equal,
				     cl_char_not_equal,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c47_c61),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_not_equal,
			  arglist_info(char_not_equal,
				       cl_char_not_equal,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_not_equal, init_args(0, cl_char_not_equal))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-lessp (&rest characters)
  (apply #'char< (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60468 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-lessp',['&rest',characters],[apply,function('char<'),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_lessp, cl_char_lessp, [c38_rest, sys_characters], [[apply, function(char_c60), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_lessp, cl_char_lessp, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_lessp).

/*

### Compiled:  `CL:CHAR-LESSP` 
*/
cl_char_lessp(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, Char_c60_Param),
		cl_char_c60(Char_c60_Param, Char_c60_Ret),
		Char_c60_Ret=FnResult
	      ),
	      block_exit(char_lessp, FnResult),
	      true).
:- set_opv(cl_char_lessp, classof, claz_function),
   set_opv(char_lessp, compile_as, kw_function),
   set_opv(char_lessp, function, cl_char_lessp),
   DefunResult=char_lessp.
/*
:- side_effect(assert_lsp(char_lessp,
			  lambda_def(defun,
				     char_lessp,
				     cl_char_lessp,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c60),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_lessp,
			  arglist_info(char_lessp,
				       cl_char_lessp,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_lessp, init_args(0, cl_char_lessp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-greaterp (&rest characters)
  (apply #'char> (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60586 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-greaterp',['&rest',characters],[apply,function('char>'),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_greaterp, cl_char_greaterp, [c38_rest, sys_characters], [[apply, function(char_c62), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_greaterp, cl_char_greaterp, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_greaterp).

/*

### Compiled:  `CL:CHAR-GREATERP` 
*/
cl_char_greaterp(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, Char_c62_Param),
		cl_char_c62(Char_c62_Param, Char_c62_Ret),
		Char_c62_Ret=FnResult
	      ),
	      block_exit(char_greaterp, FnResult),
	      true).
:- set_opv(cl_char_greaterp, classof, claz_function),
   set_opv(char_greaterp, compile_as, kw_function),
   set_opv(char_greaterp, function, cl_char_greaterp),
   DefunResult=char_greaterp.
/*
:- side_effect(assert_lsp(char_greaterp,
			  lambda_def(defun,
				     char_greaterp,
				     cl_char_greaterp,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c62),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_greaterp,
			  arglist_info(char_greaterp,
				       cl_char_greaterp,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_greaterp, init_args(0, cl_char_greaterp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-not-greaterp (&rest characters)
  (apply #'char<= (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60707 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-not-greaterp',['&rest',characters],[apply,function('char<='),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_not_greaterp, cl_char_not_greaterp, [c38_rest, sys_characters], [[apply, function(char_c60_c61), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_not_greaterp, cl_char_not_greaterp, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_not_greaterp).

/*

### Compiled:  `CL:CHAR-NOT-GREATERP` 
*/
cl_char_not_greaterp(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, C60_c61_Param),
		cl_char_c60_c61(C60_c61_Param, C60_c61_Ret),
		C60_c61_Ret=FnResult
	      ),
	      block_exit(char_not_greaterp, FnResult),
	      true).
:- set_opv(cl_char_not_greaterp, classof, claz_function),
   set_opv(char_not_greaterp, compile_as, kw_function),
   set_opv(char_not_greaterp, function, cl_char_not_greaterp),
   DefunResult=char_not_greaterp.
/*
:- side_effect(assert_lsp(char_not_greaterp,
			  lambda_def(defun,
				     char_not_greaterp,
				     cl_char_not_greaterp,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c60_c61),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_not_greaterp,
			  arglist_info(char_not_greaterp,
				       cl_char_not_greaterp,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_not_greaterp, init_args(0, cl_char_not_greaterp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-not-lessp (&rest characters)
  (apply #'char>= (mapcar #'char-upcase characters)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60833 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-not-lessp',['&rest',characters],[apply,function('char>='),[mapcar,function('char-upcase'),characters]]]).
wl:lambda_def(defun, char_not_lessp, cl_char_not_lessp, [c38_rest, sys_characters], [[apply, function(char_c62_c61), [mapcar, function(char_upcase), sys_characters]]]).
wl:arglist_info(char_not_lessp, cl_char_not_lessp, [c38_rest, sys_characters], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_characters], opt:0, req:0, rest:[sys_characters], sublists:0, whole:0}).
wl: init_args(0, cl_char_not_lessp).

/*

### Compiled:  `CL:CHAR-NOT-LESSP` 
*/
cl_char_not_lessp(RestNKeys, FnResult) :-
	Env8=[bv(sys_characters, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env8, sys_characters, Characters_Get),
		cl_mapcar(cl_char_upcase, Characters_Get, C62_c61_Param),
		cl_char_c62_c61(C62_c61_Param, C62_c61_Ret),
		C62_c61_Ret=FnResult
	      ),
	      block_exit(char_not_lessp, FnResult),
	      true).
:- set_opv(cl_char_not_lessp, classof, claz_function),
   set_opv(char_not_lessp, compile_as, kw_function),
   set_opv(char_not_lessp, function, cl_char_not_lessp),
   DefunResult=char_not_lessp.
/*
:- side_effect(assert_lsp(char_not_lessp,
			  lambda_def(defun,
				     char_not_lessp,
				     cl_char_not_lessp,
				     [c38_rest, sys_characters],
				     
				     [ 
				       [ apply,
					 function(char_c62_c61),
					 
					 [ mapcar,
					   function(char_upcase),
					   sys_characters
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_not_lessp,
			  arglist_info(char_not_lessp,
				       cl_char_not_lessp,
				       [c38_rest, sys_characters],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_characters],
						opt:0,
						req:0,
						rest:[sys_characters],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_not_lessp, init_args(0, cl_char_not_lessp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun character (character)
  (if (characterp character)
      character
      (let ((string (designator-string character)))
	(if (= (length string) 1)
	    (aref string 0)
	    (error 'type-error :datum string :expected-type '(string 1))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:60956 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,character,[character],[if,[characterp,character],character,[let,[[string,['designator-string',character]]],[if,[=,[length,string],1],[aref,string,0],[error,[quote,'type-error'],':datum',string,':expected-type',[quote,[string,1]]]]]]]).
wl:lambda_def(defun, character, cl_character, [character], [[if, [characterp, character], character, [let, [[string, [sys_designator_string, character]]], [if, [=, [length, string], 1], [aref, string, 0], [error, [quote, type_error], kw_datum, string, kw_expected_type, [quote, [string, 1]]]]]]]).
wl:arglist_info(character, cl_character, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_character).

/*

### Compiled:  `CL:CHARACTER` 
*/
cl_character(Character_In, FnResult) :-
	Env23=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env23, character, Character_Get),
		(   string:is_characterp(Character_Get)
		->  get_var(Env23, character, Character_Get8),
		    _217913112=Character_Get8
		;   get_var(Env23, character, Character_Get12),
		    f_sys_designator_string(Character_Get12, String_Init),
		    LEnv=[bv(string, String_Init)|Env23],
		    cl_length(string, PredArg1Result),
		    (   PredArg1Result=:=1
		    ->  cl_aref(string, 0, TrueResult),
			LetResult=TrueResult
		    ;   cl_error(
				 [ type_error,
				   kw_datum,
				   string,
				   kw_expected_type,
				   [string, 1]
				 ],
				 ElseResult),
			LetResult=ElseResult
		    ),
		    _217913112=LetResult
		),
		_217913112=FnResult
	      ),
	      block_exit(character, FnResult),
	      true).
:- set_opv(cl_character, classof, claz_function),
   set_opv(character, compile_as, kw_function),
   set_opv(character, function, cl_character),
   DefunResult=character.
/*
:- side_effect(assert_lsp(character,
			  lambda_def(defun,
				     character,
				     cl_character,
				     [character],
				     
				     [ 
				       [ if,
					 [characterp, character],
					 character,
					 
					 [ let,
					   
					   [ 
					     [ string,
					       
					       [ sys_designator_string,
						 character
					       ]
					     ]
					   ],
					   
					   [ if,
					     [=, [length, string], 1],
					     [aref, string, 0],
					     
					     [ error,
					       [quote, type_error],
					       kw_datum,
					       string,
					       kw_expected_type,
					       [quote, [string, 1]]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(character,
			  arglist_info(character,
				       cl_character,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(character, init_args(exact_only, cl_character))).
*/
/*
#+LISP500
(defun characterp (object) (= (ldb '(5 . 0) (ival object)) 24))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:61233 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':LISP500'],[defun,characterp,[object],[=,[ldb,[quote,[5|0]],[ival,object]],24]]]))
/*
#+(or WAM-CL LISP500) 
(defun alpha-char-p (character)
  (let ((code (char-code character)))
    (or (< 64 code 91)
	(< 96 code 123)
	(< 159 code))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:61311 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'alpha-char-p',[character],[let,[[code,['char-code',character]]],[or,[<,64,code,91],[<,96,code,123],[<,159,code]]]]).
wl:lambda_def(defun, alpha_char_p, cl_alpha_char_p, [character], [[let, [[sys_code, [char_code, character]]], [or, [<, 64, sys_code, 91], [<, 96, sys_code, 123], [<, 159, sys_code]]]]).
wl:arglist_info(alpha_char_p, cl_alpha_char_p, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_alpha_char_p).

/*

### Compiled:  `CL:ALPHA-CHAR-P` 
*/
cl_alpha_char_p(Character_In, FnResult) :-
	Env16=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env16, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		LEnv=[bv(sys_code, Code_Init)|Env16],
		(   get_var(LEnv, sys_code, Code_Get),
		    f_sys_c60(64, Code_Get, 91, FORM1_Res13),
		    FORM1_Res13\==[],
		    LetResult=FORM1_Res13
		->  true
		;   (   get_var(LEnv, sys_code, Code_Get10),
			f_sys_c60(96, Code_Get10, 123, FORM1_Res),
			FORM1_Res\==[],
			_219006292=FORM1_Res
		    ->  true
		    ;   get_var(LEnv, sys_code, Code_Get11),
			<(159, Code_Get11, _219008950),
			_219006292=_219008950
		    ),
		    LetResult=_219006292
		),
		LetResult=FnResult
	      ),
	      block_exit(alpha_char_p, FnResult),
	      true).
:- set_opv(cl_alpha_char_p, classof, claz_function),
   set_opv(alpha_char_p, compile_as, kw_function),
   set_opv(alpha_char_p, function, cl_alpha_char_p),
   DefunResult=alpha_char_p.
/*
:- side_effect(assert_lsp(alpha_char_p,
			  lambda_def(defun,
				     alpha_char_p,
				     cl_alpha_char_p,
				     [character],
				     
				     [ 
				       [ let,
					 [[sys_code, [char_code, character]]],
					 
					 [ or,
					   [<, 64, sys_code, 91],
					   [<, 96, sys_code, 123],
					   [<, 159, sys_code]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(alpha_char_p,
			  arglist_info(alpha_char_p,
				       cl_alpha_char_p,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(alpha_char_p, init_args(exact_only, cl_alpha_char_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun alphanumericp (character)
  (let ((code (char-code character)))
    (or (< 47 code 58)
	(< 64 code 91)
	(< 96 code 123)
	(< 159 code))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:61469 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,alphanumericp,[character],[let,[[code,['char-code',character]]],[or,[<,47,code,58],[<,64,code,91],[<,96,code,123],[<,159,code]]]]).
wl:lambda_def(defun, alphanumericp, cl_alphanumericp, [character], [[let, [[sys_code, [char_code, character]]], [or, [<, 47, sys_code, 58], [<, 64, sys_code, 91], [<, 96, sys_code, 123], [<, 159, sys_code]]]]).
wl:arglist_info(alphanumericp, cl_alphanumericp, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_alphanumericp).

/*

### Compiled:  `CL:ALPHANUMERICP` 
*/
cl_alphanumericp(Character_In, FnResult) :-
	Env18=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env18, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		LEnv=[bv(sys_code, Code_Init)|Env18],
		(   get_var(LEnv, sys_code, Code_Get),
		    f_sys_c60(47, Code_Get, 58, FORM1_Res15),
		    FORM1_Res15\==[],
		    LetResult=FORM1_Res15
		->  true
		;   (   get_var(LEnv, sys_code, Code_Get10),
			f_sys_c60(64, Code_Get10, 91, FORM1_Res14),
			FORM1_Res14\==[],
			_219824464=FORM1_Res14
		    ->  true
		    ;   (   get_var(LEnv, sys_code, Code_Get11),
			    f_sys_c60(96, Code_Get11, 123, FORM1_Res),
			    FORM1_Res\==[],
			    _219827284=FORM1_Res
			->  true
			;   get_var(LEnv, sys_code, Code_Get12),
			    <(159, Code_Get12, _219829954),
			    _219827284=_219829954
			),
			_219824464=_219827284
		    ),
		    LetResult=_219824464
		),
		LetResult=FnResult
	      ),
	      block_exit(alphanumericp, FnResult),
	      true).
:- set_opv(cl_alphanumericp, classof, claz_function),
   set_opv(alphanumericp, compile_as, kw_function),
   set_opv(alphanumericp, function, cl_alphanumericp),
   DefunResult=alphanumericp.
/*
:- side_effect(assert_lsp(alphanumericp,
			  lambda_def(defun,
				     alphanumericp,
				     cl_alphanumericp,
				     [character],
				     
				     [ 
				       [ let,
					 [[sys_code, [char_code, character]]],
					 
					 [ or,
					   [<, 47, sys_code, 58],
					   [<, 64, sys_code, 91],
					   [<, 96, sys_code, 123],
					   [<, 159, sys_code]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(alphanumericp,
			  arglist_info(alphanumericp,
				       cl_alphanumericp,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(alphanumericp,
			  init_args(exact_only, cl_alphanumericp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun digit-char (weight &optional (radix 10))
  (when (< weight radix)
    (if (< weight 10)
	(code-char (+ 48 weight))
	(code-char (+ 55 weight)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:61645 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'digit-char',[weight,'&optional',[radix,10]],[when,[<,weight,radix],[if,[<,weight,10],['code-char',[+,48,weight]],['code-char',[+,55,weight]]]]]).
wl:lambda_def(defun, digit_char, cl_digit_char, [sys_weight, c38_optional, [sys_radix, 10]], [[when, [<, sys_weight, sys_radix], [if, [<, sys_weight, 10], [code_char, [+, 48, sys_weight]], [code_char, [+, 55, sys_weight]]]]]).
wl:arglist_info(digit_char, cl_digit_char, [sys_weight, c38_optional, [sys_radix, 10]], arginfo{all:[sys_weight, sys_radix], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_weight, sys_radix], opt:[sys_radix], req:[sys_weight], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_digit_char).

/*

### Compiled:  `CL:DIGIT-CHAR` 
*/
cl_digit_char(Weight_In, RestNKeys, FnResult) :-
	Env24=[bv(sys_weight, Weight_In), bv(sys_radix, Radix_In)|Env],
	global_env(Env),
	opt_var(Env, sys_radix, Radix_In, true, 10, 1, RestNKeys),
	catch(( get_var(Env24, sys_radix, Radix_Get),
		get_var(Env24, sys_weight, Weight_Get),
		(   Weight_Get<Radix_Get
		->  get_var(Env24, sys_weight, Weight_Get14),
		    (   Weight_Get14<10
		    ->  get_var(Env24, sys_weight, Weight_Get17),
			+(48, Weight_Get17, Code_char_Param),
			cl_code_char(Code_char_Param, TrueResult),
			TrueResult21=TrueResult
		    ;   get_var(Env24, sys_weight, Weight_Get18),
			+(55, Weight_Get18, Code_char_Param26),
			cl_code_char(Code_char_Param26, ElseResult),
			TrueResult21=ElseResult
		    ),
		    _220701648=TrueResult21
		;   _220701648=[]
		),
		_220701648=FnResult
	      ),
	      block_exit(digit_char, FnResult),
	      true).
:- set_opv(cl_digit_char, classof, claz_function),
   set_opv(digit_char, compile_as, kw_function),
   set_opv(digit_char, function, cl_digit_char),
   DefunResult=digit_char.
/*
:- side_effect(assert_lsp(digit_char,
			  lambda_def(defun,
				     digit_char,
				     cl_digit_char,
				     [sys_weight, c38_optional, [sys_radix, 10]],
				     
				     [ 
				       [ when,
					 [<, sys_weight, sys_radix],
					 
					 [ if,
					   [<, sys_weight, 10],
					   [code_char, [+, 48, sys_weight]],
					   [code_char, [+, 55, sys_weight]]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(digit_char,
			  arglist_info(digit_char,
				       cl_digit_char,
				       
				       [ sys_weight,
					 c38_optional,
					 [sys_radix, 10]
				       ],
				       arginfo{ all:[sys_weight, sys_radix],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_weight, sys_radix],
						opt:[sys_radix],
						req:[sys_weight],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(digit_char, init_args(1, cl_digit_char))).
*/
/*
#+(or WAM-CL LISP500) 
(defun digit-char-p (char &optional (radix 10))
  (let* ((code (char-code char))
	 (weight (if (< 47 code 58)
		     (- code 48)
		     (if (< 64 code 91)
			 (- code 55)
			 (when (< 96 code 123)
			   (- code 87))))))
    (and weight (< weight radix) weight)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:61828 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'digit-char-p',[char,'&optional',[radix,10]],['let*',[[code,['char-code',char]],[weight,[if,[<,47,code,58],[-,code,48],[if,[<,64,code,91],[-,code,55],[when,[<,96,code,123],[-,code,87]]]]]],[and,weight,[<,weight,radix],weight]]]).
wl:lambda_def(defun, digit_char_p, cl_digit_char_p, [char, c38_optional, [sys_radix, 10]], [[let_xx, [[sys_code, [char_code, char]], [sys_weight, [if, [<, 47, sys_code, 58], [-, sys_code, 48], [if, [<, 64, sys_code, 91], [-, sys_code, 55], [when, [<, 96, sys_code, 123], [-, sys_code, 87]]]]]], [and, sys_weight, [<, sys_weight, sys_radix], sys_weight]]]).
wl:arglist_info(digit_char_p, cl_digit_char_p, [char, c38_optional, [sys_radix, 10]], arginfo{all:[char, sys_radix], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[char, sys_radix], opt:[sys_radix], req:[char], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_digit_char_p).

/*

### Compiled:  `CL:DIGIT-CHAR-P` 
*/
cl_digit_char_p(Char_In, RestNKeys, FnResult) :-
	Env44=[bv(char, Char_In), bv(sys_radix, Radix_In)|Env],
	global_env(Env),
	opt_var(Env, sys_radix, Radix_In, true, 10, 1, RestNKeys),
	catch(( get_var(Env44, char, Char_Get),
		cl_char_code(Char_Get, Code_Init),
		get_var(Env44, sys_code, Code_Get),
		f_sys_c60(47, Code_Get, 58, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env44, sys_code, Code_Get14),
		    -(Code_Get14, 48, TrueResult26),
		    Weight_Init=TrueResult26
		;   get_var(Env44, sys_code, Code_Get17),
		    f_sys_c60(64, Code_Get17, 91, IFTEST15),
		    (   IFTEST15\==[]
		    ->  get_var(Env44, sys_code, Code_Get18),
			-(Code_Get18, 55, TrueResult24),
			ElseResult27=TrueResult24
		    ;   get_var(Env44, sys_code, Code_Get21),
			f_sys_c60(96, Code_Get21, 123, IFTEST19),
			(   IFTEST19\==[]
			->  get_var(Env44, sys_code, Code_Get22),
			    -(Code_Get22, 87, TrueResult),
			    ElseResult=TrueResult
			;   ElseResult=[]
			),
			ElseResult27=ElseResult
		    ),
		    Weight_Init=ElseResult27
		),
		LEnv=[bv(sys_code, Code_Init), bv(sys_weight, Weight_Init)|Env44],
		get_var(LEnv, sys_weight, IFTEST30),
		(   IFTEST30\==[]
		->  get_var(LEnv, sys_radix, Radix_Get),
		    get_var(LEnv, sys_weight, Weight_Get34),
		    (   Weight_Get34<Radix_Get
		    ->  get_var(LEnv, sys_weight, Weight_Get39),
			TrueResult41=Weight_Get39
		    ;   TrueResult41=[]
		    ),
		    LetResult=TrueResult41
		;   LetResult=[]
		),
		LetResult=FnResult
	      ),
	      block_exit(digit_char_p, FnResult),
	      true).
:- set_opv(cl_digit_char_p, classof, claz_function),
   set_opv(digit_char_p, compile_as, kw_function),
   set_opv(digit_char_p, function, cl_digit_char_p),
   DefunResult=digit_char_p.
/*
:- side_effect(assert_lsp(digit_char_p,
			  lambda_def(defun,
				     digit_char_p,
				     cl_digit_char_p,
				     [char, c38_optional, [sys_radix, 10]],
				     
				     [ 
				       [ let_xx,
					 
					 [ [sys_code, [char_code, char]],
					   
					   [ sys_weight,
					     
					     [ if,
					       [<, 47, sys_code, 58],
					       [-, sys_code, 48],
					       
					       [ if,
						 [<, 64, sys_code, 91],
						 [-, sys_code, 55],
						 
						 [ when,
						   [<, 96, sys_code, 123],
						   [-, sys_code, 87]
						 ]
					       ]
					     ]
					   ]
					 ],
					 
					 [ and,
					   sys_weight,
					   [<, sys_weight, sys_radix],
					   sys_weight
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(digit_char_p,
			  arglist_info(digit_char_p,
				       cl_digit_char_p,
				       [char, c38_optional, [sys_radix, 10]],
				       arginfo{ all:[char, sys_radix],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[char, sys_radix],
						opt:[sys_radix],
						req:[char],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(digit_char_p, init_args(1, cl_digit_char_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun standard-char-p (character)
  (let ((code (char-code character)))
    (or (= code 10)
	(< 31 code 127))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62126 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'standard-char-p',[character],[let,[[code,['char-code',character]]],[or,[=,code,10],[<,31,code,127]]]]).
wl:lambda_def(defun, standard_char_p, cl_standard_char_p, [character], [[let, [[sys_code, [char_code, character]]], [or, [=, sys_code, 10], [<, 31, sys_code, 127]]]]).
wl:arglist_info(standard_char_p, cl_standard_char_p, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_standard_char_p).

/*

### Compiled:  `CL:STANDARD-CHAR-P` 
*/
cl_standard_char_p(Character_In, FnResult) :-
	Env14=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env14, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		LEnv=[bv(sys_code, Code_Init)|Env14],
		(   get_var(LEnv, sys_code, Code_Get),
		    =(Code_Get, 10, FORM1_Res),
		    FORM1_Res\==[],
		    LetResult=FORM1_Res
		->  true
		;   get_var(LEnv, sys_code, Code_Get10),
		    f_sys_c60(31, Code_Get10, 127, C60_Ret),
		    LetResult=C60_Ret
		),
		LetResult=FnResult
	      ),
	      block_exit(standard_char_p, FnResult),
	      true).
:- set_opv(cl_standard_char_p, classof, claz_function),
   set_opv(standard_char_p, compile_as, kw_function),
   set_opv(standard_char_p, function, cl_standard_char_p),
   DefunResult=standard_char_p.
/*
:- side_effect(assert_lsp(standard_char_p,
			  lambda_def(defun,
				     standard_char_p,
				     cl_standard_char_p,
				     [character],
				     
				     [ 
				       [ let,
					 [[sys_code, [char_code, character]]],
					 
					 [ or,
					   [=, sys_code, 10],
					   [<, 31, sys_code, 127]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(standard_char_p,
			  arglist_info(standard_char_p,
				       cl_standard_char_p,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(standard_char_p,
			  init_args(exact_only, cl_standard_char_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-upcase (character)
  (let ((code (char-code character)))
    (if (< 96 code 123)
	(code-char (- code 32))
	character)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62269 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-upcase',[character],[let,[[code,['char-code',character]]],[if,[<,96,code,123],['code-char',[-,code,32]],character]]]).
wl:lambda_def(defun, char_upcase, cl_char_upcase, [character], [[let, [[sys_code, [char_code, character]]], [if, [<, 96, sys_code, 123], [code_char, [-, sys_code, 32]], character]]]).
wl:arglist_info(char_upcase, cl_char_upcase, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_char_upcase).

/*

### Compiled:  `CL:CHAR-UPCASE` 
*/
cl_char_upcase(Character_In, FnResult) :-
	Env18=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env18, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		LEnv=[bv(sys_code, Code_Init)|Env18],
		get_var(LEnv, sys_code, Code_Get),
		f_sys_c60(96, Code_Get, 123, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sys_code, Code_Get12),
		    -(Code_Get12, 32, Code_char_Param),
		    cl_code_char(Code_char_Param, TrueResult),
		    LetResult=TrueResult
		;   get_var(LEnv, character, Character_Get13),
		    LetResult=Character_Get13
		),
		LetResult=FnResult
	      ),
	      block_exit(char_upcase, FnResult),
	      true).
:- set_opv(cl_char_upcase, classof, claz_function),
   set_opv(char_upcase, compile_as, kw_function),
   set_opv(char_upcase, function, cl_char_upcase),
   DefunResult=char_upcase.
/*
:- side_effect(assert_lsp(char_upcase,
			  lambda_def(defun,
				     char_upcase,
				     cl_char_upcase,
				     [character],
				     
				     [ 
				       [ let,
					 [[sys_code, [char_code, character]]],
					 
					 [ if,
					   [<, 96, sys_code, 123],
					   [code_char, [-, sys_code, 32]],
					   character
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_upcase,
			  arglist_info(char_upcase,
				       cl_char_upcase,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_upcase, init_args(exact_only, cl_char_upcase))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-downcase (character)
  (let ((code (char-code character)))
    (if (< 64 code 91)
	(code-char (+ code 32))
	character)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62432 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-downcase',[character],[let,[[code,['char-code',character]]],[if,[<,64,code,91],['code-char',[+,code,32]],character]]]).
wl:lambda_def(defun, char_downcase, cl_char_downcase, [character], [[let, [[sys_code, [char_code, character]]], [if, [<, 64, sys_code, 91], [code_char, [+, sys_code, 32]], character]]]).
wl:arglist_info(char_downcase, cl_char_downcase, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_char_downcase).

/*

### Compiled:  `CL:CHAR-DOWNCASE` 
*/
cl_char_downcase(Character_In, FnResult) :-
	Env18=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env18, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		LEnv=[bv(sys_code, Code_Init)|Env18],
		get_var(LEnv, sys_code, Code_Get),
		f_sys_c60(64, Code_Get, 91, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, sys_code, Code_Get12),
		    +(Code_Get12, 32, Code_char_Param),
		    cl_code_char(Code_char_Param, TrueResult),
		    LetResult=TrueResult
		;   get_var(LEnv, character, Character_Get13),
		    LetResult=Character_Get13
		),
		LetResult=FnResult
	      ),
	      block_exit(char_downcase, FnResult),
	      true).
:- set_opv(cl_char_downcase, classof, claz_function),
   set_opv(char_downcase, compile_as, kw_function),
   set_opv(char_downcase, function, cl_char_downcase),
   DefunResult=char_downcase.
/*
:- side_effect(assert_lsp(char_downcase,
			  lambda_def(defun,
				     char_downcase,
				     cl_char_downcase,
				     [character],
				     
				     [ 
				       [ let,
					 [[sys_code, [char_code, character]]],
					 
					 [ if,
					   [<, 64, sys_code, 91],
					   [code_char, [+, sys_code, 32]],
					   character
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_downcase,
			  arglist_info(char_downcase,
				       cl_char_downcase,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_downcase,
			  init_args(exact_only, cl_char_downcase))).
*/
/*
#+(or WAM-CL LISP500) 
(defun upper-case-p (character)
  (< 64 (char-code character) 91))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62596 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'upper-case-p',[character],[<,64,['char-code',character],91]]).
wl:lambda_def(defun, upper_case_p, cl_upper_case_p, [character], [[<, 64, [char_code, character], 91]]).
wl:arglist_info(upper_case_p, cl_upper_case_p, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_upper_case_p).

/*

### Compiled:  `CL:UPPER-CASE-P` 
*/
cl_upper_case_p(Character_In, FnResult) :-
	Env7=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, character, Character_Get),
		cl_char_code(Character_Get, Char_code_Ret),
		f_sys_c60(64, Char_code_Ret, 91, C60_Ret),
		C60_Ret=FnResult
	      ),
	      block_exit(upper_case_p, FnResult),
	      true).
:- set_opv(cl_upper_case_p, classof, claz_function),
   set_opv(upper_case_p, compile_as, kw_function),
   set_opv(upper_case_p, function, cl_upper_case_p),
   DefunResult=upper_case_p.
/*
:- side_effect(assert_lsp(upper_case_p,
			  lambda_def(defun,
				     upper_case_p,
				     cl_upper_case_p,
				     [character],
				     [[<, 64, [char_code, character], 91]]))).
*/
/*
:- side_effect(assert_lsp(upper_case_p,
			  arglist_info(upper_case_p,
				       cl_upper_case_p,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(upper_case_p, init_args(exact_only, cl_upper_case_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun lower-case-p (character)
  (< 96 (char-code character) 123))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62691 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'lower-case-p',[character],[<,96,['char-code',character],123]]).
wl:lambda_def(defun, lower_case_p, cl_lower_case_p, [character], [[<, 96, [char_code, character], 123]]).
wl:arglist_info(lower_case_p, cl_lower_case_p, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_lower_case_p).

/*

### Compiled:  `CL:LOWER-CASE-P` 
*/
cl_lower_case_p(Character_In, FnResult) :-
	Env7=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, character, Character_Get),
		cl_char_code(Character_Get, Char_code_Ret),
		f_sys_c60(96, Char_code_Ret, 123, C60_Ret),
		C60_Ret=FnResult
	      ),
	      block_exit(lower_case_p, FnResult),
	      true).
:- set_opv(cl_lower_case_p, classof, claz_function),
   set_opv(lower_case_p, compile_as, kw_function),
   set_opv(lower_case_p, function, cl_lower_case_p),
   DefunResult=lower_case_p.
/*
:- side_effect(assert_lsp(lower_case_p,
			  lambda_def(defun,
				     lower_case_p,
				     cl_lower_case_p,
				     [character],
				     [[<, 96, [char_code, character], 123]]))).
*/
/*
:- side_effect(assert_lsp(lower_case_p,
			  arglist_info(lower_case_p,
				       cl_lower_case_p,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(lower_case_p, init_args(exact_only, cl_lower_case_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun both-case-p (character)
  (or (upper-case-p character) (lower-case-p character)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62787 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'both-case-p',[character],[or,['upper-case-p',character],['lower-case-p',character]]]).
wl:lambda_def(defun, both_case_p, cl_both_case_p, [character], [[or, [upper_case_p, character], [lower_case_p, character]]]).
wl:arglist_info(both_case_p, cl_both_case_p, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_both_case_p).

/*

### Compiled:  `CL:BOTH-CASE-P` 
*/
cl_both_case_p(Character_In, FnResult) :-
	Env9=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( (   get_var(Env9, character, Character_Get),
		    cl_upper_case_p(Character_Get, FORM1_Res),
		    FORM1_Res\==[],
		    _226199048=FORM1_Res
		->  true
		;   get_var(Env9, character, Character_Get5),
		    cl_lower_case_p(Character_Get5, Case_p_Ret),
		    _226199048=Case_p_Ret
		),
		_226199048=FnResult
	      ),
	      block_exit(both_case_p, FnResult),
	      true).
:- set_opv(cl_both_case_p, classof, claz_function),
   set_opv(both_case_p, compile_as, kw_function),
   set_opv(both_case_p, function, cl_both_case_p),
   DefunResult=both_case_p.
/*
:- side_effect(assert_lsp(both_case_p,
			  lambda_def(defun,
				     both_case_p,
				     cl_both_case_p,
				     [character],
				     
				     [ 
				       [ or,
					 [upper_case_p, character],
					 [lower_case_p, character]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(both_case_p,
			  arglist_info(both_case_p,
				       cl_both_case_p,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(both_case_p, init_args(exact_only, cl_both_case_p))).
*/
/*
#+(or WAM-CL LISP500) 
(defun char-int (character)
  (char-code character))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62904 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'char-int',[character],['char-code',character]]).
wl:lambda_def(defun, char_int, cl_char_int, [character], [[char_code, character]]).
wl:arglist_info(char_int, cl_char_int, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_char_int).

/*

### Compiled:  `CL:CHAR-INT` 
*/
cl_char_int(Character_In, FnResult) :-
	Env7=[bv(character, Character_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, character, Character_Get),
		cl_char_code(Character_Get, Char_code_Ret),
		Char_code_Ret=FnResult
	      ),
	      block_exit(char_int, FnResult),
	      true).
:- set_opv(cl_char_int, classof, claz_function),
   set_opv(char_int, compile_as, kw_function),
   set_opv(char_int, function, cl_char_int),
   DefunResult=char_int.
/*
:- side_effect(assert_lsp(char_int,
			  lambda_def(defun,
				     char_int,
				     cl_char_int,
				     [character],
				     [[char_code, character]]))).
*/
/*
:- side_effect(assert_lsp(char_int,
			  arglist_info(char_int,
				       cl_char_int,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_int, init_args(exact_only, cl_char_int))).
*/
/*
#+(or WAM-CL LISP500) 
(defconstant char-code-limit 256)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:62985 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defconstant,'char-code-limit',256]).
:- set_var(AEnv, char_code_limit, 256).
/*
#+(or WAM-CL LISP500) 
(let ((char-names '((0 . "Null")
		    (8 . "Backspace")
		    (9 . "Tab")
		    (10 . "Newline")
		    (12 . "Page")
		    (13 . "Return")
		    (32 . "Space")
		    (127 . "Rubout"))))
  (defun char-name (character)
    (let* ((code (char-code character))
	   (name (cdr (assoc code char-names))))
      (or name (when (< code 32)
		 (conc-string "U+" (integer-string code))))))
  (defun name-char (name)
    (setq name (designator-string name))
    (if (< (length name) 2)
	(aref name 0)
	(if (= (char-code (aref name 0)) 85)
	    (code-char (parse-integer name :start 2))
	    (let ((code (car (rassoc name char-names :test #'string-equal))))
	      (when code (code-char code)))))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:63046 **********************/
:-lisp_compile_to_prolog(pkg_sys,[let,[['char-names',[quote,[[0|'$STRING'("Null")],[8|'$STRING'("Backspace")],[9|'$STRING'("Tab")],[10|'$STRING'("Newline")],[12|'$STRING'("Page")],[13|'$STRING'("Return")],[32|'$STRING'("Space")],[127|'$STRING'("Rubout")]]]]],[defun,'char-name',[character],['let*',[[code,['char-code',character]],[name,[cdr,[assoc,code,'char-names']]]],[or,name,[when,[<,code,32],['conc-string','$STRING'("U+"),['integer-string',code]]]]]],[defun,'name-char',[name],[setq,name,['designator-string',name]],[if,[<,[length,name],2],[aref,name,0],[if,[=,['char-code',[aref,name,0]],85],['code-char',['parse-integer',name,':start',2]],[let,[[code,[car,[rassoc,name,'char-names',':test',function('string-equal')]]]],[when,code,['code-char',code]]]]]]]).
:- LEnv=[bv(sys_char_names, [[0|'$ARRAY'([*], claz_base_character, "Null")], [8|'$ARRAY'([*], claz_base_character, "Backspace")], [9|'$ARRAY'([*], claz_base_character, "Tab")], [10|'$ARRAY'([*], claz_base_character, "Newline")], [12|'$ARRAY'([*], claz_base_character, "Page")], [13|'$ARRAY'([*], claz_base_character, "Return")], [32|'$ARRAY'([*], claz_base_character, "Space")], [127|'$ARRAY'([*], claz_base_character, "Rubout")]])|CDR].
wl:lambda_def(defun, char_name, cl_char_name, [character], [[let_xx, [[sys_code, [char_code, character]], [sys_name, [cdr, [assoc, sys_code, sys_char_names]]]], [or, sys_name, [when, [<, sys_code, 32], [sys_conc_string, '$ARRAY'([*], claz_base_character, "U+"), [sys_integer_string, sys_code]]]]]]).
wl:arglist_info(char_name, cl_char_name, [character], arginfo{all:[character], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[character], opt:0, req:[character], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_char_name).

/*

### Compiled:  `CL:CHAR-NAME` 
*/
cl_char_name(Character_In, FnResult) :-
	Env56=[bv(character, Character_In)|LEnv],
	global_env(LEnv),
	catch(( get_var(Env56, character, Character_Get),
		cl_char_code(Character_Get, Code_Init),
		get_var(Env56, sys_char_names, Char_names_Get),
		get_var(Env56, sys_code, Code_Get),
		cl_assoc(Code_Get, Char_names_Get, [], Cdr_Param),
		cl_cdr(Cdr_Param, Name_Init),
		LEnv9=[bv(sys_code, Code_Init), bv(sys_name, Name_Init)|Env56],
		(   get_var(LEnv9, sys_name, Name_Get),
		    Name_Get\==[],
		    LetResult8=Name_Get
		->  true
		;   get_var(LEnv9, sys_code, Code_Get17),
		    (   Code_Get17<32
		    ->  get_var(LEnv9, sys_code, Code_Get20),
			f_sys_integer_string(Code_Get20, [], Integer_string_Ret),
			f_sys_conc_string('$ARRAY'([*],
						   claz_base_character,
						   "U+"),
					  Integer_string_Ret,
					  TrueResult),
			_227631616=TrueResult
		    ;   _227631616=[]
		    ),
		    LetResult8=_227631616
		),
		LetResult8=FnResult
	      ),
	      block_exit(char_name, FnResult),
	      true).
:- set_opv(cl_char_name, classof, claz_function),
   set_opv(char_name, compile_as, kw_function),
   set_opv(char_name, function, cl_char_name),
   DefunResult=char_name,
   assert_lsp(name_char,
	      wl:lambda_def(defun, name_char, cl_name_char, [sys_name], [[setq, sys_name, [sys_designator_string, sys_name]], [if, [<, [length, sys_name], 2], [aref, sys_name, 0], [if, [=, [char_code, [aref, sys_name, 0]], 85], [code_char, [parse_integer, sys_name, kw_start, 2]], [let, [[sys_code, [car, [rassoc, sys_name, sys_char_names, kw_test, function(string_equal)]]]], [when, sys_code, [code_char, sys_code]]]]]])),
   assert_lsp(name_char,
	      wl:arglist_info(name_char, cl_name_char, [sys_name], arginfo{all:[sys_name], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_name], opt:0, req:[sys_name], rest:0, sublists:0, whole:0})), !,
   assert_lsp(name_char, wl:init_args(exact_only, cl_name_char)),
   assert_lsp(name_char,
	      (cl_name_char(Name_In, FnResult25):-AEnv=[bv(sys_name, Name_In)|LEnv], global_env(LEnv), catch((get_var(AEnv, sys_name, Name_Get28), f_sys_designator_string(Name_Get28, Name), set_var(AEnv, sys_name, Name), get_var(AEnv, sys_name, Name_Get30), cl_length(Name_Get30, PredArg1Result32), (PredArg1Result32<2->get_var(AEnv, sys_name, Name_Get33), cl_aref(Name_Get33, 0, TrueResult52), _227740072=TrueResult52;get_var(AEnv, sys_name, Name_Get35), cl_aref(Name_Get35, 0, Char_code_Param), cl_char_code(Char_code_Param, PredArg1Result37), (PredArg1Result37=:=85->get_var(AEnv, sys_name, Name_Get38), cl_parse_integer(Name_Get38, kw_start, 2, Code_char_Param), cl_code_char(Code_char_Param, TrueResult50), ElseResult53=TrueResult50;get_var(AEnv, sys_char_names, Char_names_Get43), get_var(AEnv, sys_name, Name_Get42), cl_rassoc(Name_Get42, Char_names_Get43, [kw_test, cl_string_equal], Car_Param), cl_car(Car_Param, Code_Init44), LEnv41=[bv(sys_code, Code_Init44)|AEnv], get_var(LEnv41, sys_code, IFTEST45), (IFTEST45\==[]->get_var(LEnv41, sys_code, Code_Get48), cl_code_char(Code_Get48, TrueResult49), LetResult40=TrueResult49;LetResult40=[]), ElseResult53=LetResult40), _227740072=ElseResult53), _227740072=FnResult25), block_exit(name_char, FnResult25), true))),
   set_opv(cl_name_char, classof, claz_function),
   set_opv(name_char, compile_as, kw_function),
   set_opv(name_char, function, cl_name_char),
   DefunResult55=name_char.
/*
:- side_effect(assert_lsp(char_name,
			  lambda_def(defun,
				     char_name,
				     cl_char_name,
				     [character],
				     
				     [ 
				       [ let_xx,
					 
					 [ [sys_code, [char_code, character]],
					   
					   [ sys_name,
					     
					     [ cdr,
					       [assoc, sys_code, sys_char_names]
					     ]
					   ]
					 ],
					 
					 [ or,
					   sys_name,
					   
					   [ when,
					     [<, sys_code, 32],
					     
					     [ sys_conc_string,
					       '$ARRAY'([*],
							claz_base_character,
							"U+"),
					       [sys_integer_string, sys_code]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(char_name,
			  arglist_info(char_name,
				       cl_char_name,
				       [character],
				       arginfo{ all:[character],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[character],
						opt:0,
						req:[character],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(char_name, init_args(exact_only, cl_char_name))).
*/
/*
:- side_effect(assert_lsp(name_char,
			  lambda_def(defun,
				     name_char,
				     cl_name_char,
				     [sys_name],
				     
				     [ 
				       [ setq,
					 sys_name,
					 [sys_designator_string, sys_name]
				       ],
				       
				       [ if,
					 [<, [length, sys_name], 2],
					 [aref, sys_name, 0],
					 
					 [ if,
					   
					   [ (=),
					     [char_code, [aref, sys_name, 0]],
					     85
					   ],
					   
					   [ code_char,
					     
					     [ parse_integer,
					       sys_name,
					       kw_start,
					       2
					     ]
					   ],
					   
					   [ let,
					     
					     [ 
					       [ sys_code,
						 
						 [ car,
						   
						   [ rassoc,
						     sys_name,
						     sys_char_names,
						     kw_test,
						     function(string_equal)
						   ]
						 ]
					       ]
					     ],
					     
					     [ when,
					       sys_code,
					       [code_char, sys_code]
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(name_char,
			  arglist_info(name_char,
				       cl_name_char,
				       [sys_name],
				       arginfo{ all:[sys_name],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_name],
						opt:0,
						req:[sys_name],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(name_char, init_args(exact_only, cl_name_char))).
*/
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun atom (object) (not (consp object)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:63781 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,atom,[object],[not,[consp,object]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun rplaca (cons object) (setf (car cons) object) cons)

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:63862 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,rplaca,[cons,object],[setf,[car,cons],object],cons]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun rplacd (cons object) (setf (cdr cons) object) cons)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:63959 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,rplacd,[cons,object],[setf,[cdr,cons],object],cons]]]))
/*
#+(or WAM-CL LISP500) 
(defun copy-tree (tree)
  (if (consp tree) (cons (copy-tree (car tree)) (copy-tree (cdr tree))) tree))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:64060 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'copy-tree',[tree],[if,[consp,tree],[cons,['copy-tree',[car,tree]],['copy-tree',[cdr,tree]]],tree]]).
wl:lambda_def(defun, copy_tree, cl_copy_tree, [sys_tree], [[if, [consp, sys_tree], [cons, [copy_tree, [car, sys_tree]], [copy_tree, [cdr, sys_tree]]], sys_tree]]).
wl:arglist_info(copy_tree, cl_copy_tree, [sys_tree], arginfo{all:[sys_tree], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_tree], opt:0, req:[sys_tree], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_copy_tree).

/*

### Compiled:  `CL:COPY-TREE` 
*/
cl_copy_tree(Tree_In, FnResult) :-
	Env15=[bv(sys_tree, Tree_In)|Env],
	global_env(Env),
	catch(( get_var(Env15, sys_tree, Tree_Get),
		(   is_consp(Tree_Get)
		->  get_var(Env15, sys_tree, Tree_Get8),
		    cl_car(Tree_Get8, Copy_tree_Param),
		    cl_copy_tree(Copy_tree_Param, Copy_tree_Ret),
		    get_var(Env15, sys_tree, Tree_Get9),
		    cl_cdr(Tree_Get9, Copy_tree_Param17),
		    cl_copy_tree(Copy_tree_Param17, Copy_tree_Ret19),
		    TrueResult=[Copy_tree_Ret|Copy_tree_Ret19],
		    _230215490=TrueResult
		;   get_var(Env15, sys_tree, Tree_Get10),
		    _230215490=Tree_Get10
		),
		_230215490=FnResult
	      ),
	      block_exit(copy_tree, FnResult),
	      true).
:- set_opv(cl_copy_tree, classof, claz_function),
   set_opv(copy_tree, compile_as, kw_function),
   set_opv(copy_tree, function, cl_copy_tree),
   DefunResult=copy_tree.
/*
:- side_effect(assert_lsp(copy_tree,
			  lambda_def(defun,
				     copy_tree,
				     cl_copy_tree,
				     [sys_tree],
				     
				     [ 
				       [ if,
					 [consp, sys_tree],
					 
					 [ cons,
					   [copy_tree, [car, sys_tree]],
					   [copy_tree, [cdr, sys_tree]]
					 ],
					 sys_tree
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(copy_tree,
			  arglist_info(copy_tree,
				       cl_copy_tree,
				       [sys_tree],
				       arginfo{ all:[sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_tree],
						opt:0,
						req:[sys_tree],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(copy_tree, init_args(exact_only, cl_copy_tree))).
*/
/*
#+(or WAM-CL LISP500) 
(defun sublis (alist tree &rest rest)
  (if (consp tree)
      (let ((a (apply #'sublis alist (car tree) rest))
	    (d (apply #'sublis alist (cdr tree) rest)))
	(if (and (eq a (car tree)) (eq d (cdr tree)))
	    tree
	    (cons a d)))
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:64191 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,sublis,[alist,tree,'&rest',rest],[if,[consp,tree],[let,[[a,[apply,function(sublis),alist,[car,tree],rest]],[d,[apply,function(sublis),alist,[cdr,tree],rest]]],[if,[and,[eq,a,[car,tree]],[eq,d,[cdr,tree]]],tree,[cons,a,d]]],[let,[[a,[apply,function(assoc),tree,alist,rest]]],[if,a,[cdr,a],tree]]]]).
wl:lambda_def(defun, sublis, cl_sublis, [sys_alist, sys_tree, c38_rest, rest], [[if, [consp, sys_tree], [let, [[sys_a, [apply, function(sublis), sys_alist, [car, sys_tree], rest]], [sys_d, [apply, function(sublis), sys_alist, [cdr, sys_tree], rest]]], [if, [and, [eq, sys_a, [car, sys_tree]], [eq, sys_d, [cdr, sys_tree]]], sys_tree, [cons, sys_a, sys_d]]], [let, [[sys_a, [apply, function(assoc), sys_tree, sys_alist, rest]]], [if, sys_a, [cdr, sys_a], sys_tree]]]]).
wl:arglist_info(sublis, cl_sublis, [sys_alist, sys_tree, c38_rest, rest], arginfo{all:[sys_alist, sys_tree], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_alist, sys_tree, rest], opt:0, req:[sys_alist, sys_tree], rest:[rest], sublists:0, whole:0}).
wl: init_args(2, cl_sublis).

/*

### Compiled:  `CL:SUBLIS` 
*/
cl_sublis(Alist_In, Tree_In, RestNKeys, FnResult) :-
	Env56=[bv(sys_alist, Alist_In), bv(sys_tree, Tree_In), bv(rest, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env56, sys_tree, Tree_Get),
		(   is_consp(Tree_Get)
		->  get_var(Env56, sys_alist, Alist_Get),
		    get_var(Env56, sys_tree, Tree_Get15),
		    cl_car(Tree_Get15, Car_Ret),
		    get_var(Env56, rest, Rest_Get),
		    cl_sublis(Alist_Get, Car_Ret, Rest_Get, A_Init),
		    get_var(Env56, sys_alist, Alist_Get17),
		    get_var(Env56, sys_tree, Tree_Get18),
		    cl_cdr(Tree_Get18, Cdr_Ret),
		    get_var(Env56, rest, Rest_Get19),
		    cl_sublis(Alist_Get17, Cdr_Ret, Rest_Get19, D_Init),
		    LEnv=[bv(sys_a, A_Init), bv(sys_d, D_Init)|Env56],
		    get_var(LEnv, sys_a, A_Get),
		    get_var(LEnv, sys_tree, Tree_Get26),
		    cl_car(Tree_Get26, PredArg2Result),
		    (   is_eq(A_Get, PredArg2Result)
		    ->  get_var(LEnv, sys_d, D_Get),
			get_var(LEnv, sys_tree, Tree_Get31),
			cl_cdr(Tree_Get31, Cdr_Ret59),
			cl_eq(D_Get, Cdr_Ret59, TrueResult),
			IFTEST22=TrueResult
		    ;   IFTEST22=[]
		    ),
		    (   IFTEST22\==[]
		    ->  get_var(LEnv, sys_tree, Tree_Get33),
			LetResult=Tree_Get33
		    ;   get_var(LEnv, sys_a, A_Get34),
			get_var(LEnv, sys_d, D_Get35),
			ElseResult=[A_Get34|D_Get35],
			LetResult=ElseResult
		    ),
		    _230948358=LetResult
		;   get_var(Env56, sys_alist, Alist_Get42),
		    get_var(Env56, sys_tree, Tree_Get41),
		    get_var(Env56, rest, Rest_Get43),
		    cl_assoc(Tree_Get41, Alist_Get42, Rest_Get43, A_Init44),
		    LEnv40=[bv(sys_a, A_Init44)|Env56],
		    get_var(LEnv40, sys_a, IFTEST45),
		    (   IFTEST45\==[]
		    ->  get_var(LEnv40, sys_a, A_Get48),
			cl_cdr(A_Get48, TrueResult50),
			LetResult39=TrueResult50
		    ;   get_var(LEnv40, sys_tree, Tree_Get49),
			LetResult39=Tree_Get49
		    ),
		    _230948358=LetResult39
		),
		_230948358=FnResult
	      ),
	      block_exit(sublis, FnResult),
	      true).
:- set_opv(cl_sublis, classof, claz_function),
   set_opv(sublis, compile_as, kw_function),
   set_opv(sublis, function, cl_sublis),
   DefunResult=sublis.
/*
:- side_effect(assert_lsp(sublis,
			  lambda_def(defun,
				     sublis,
				     cl_sublis,
				     [sys_alist, sys_tree, c38_rest, rest],
				     
				     [ 
				       [ if,
					 [consp, sys_tree],
					 
					 [ let,
					   
					   [ 
					     [ sys_a,
					       
					       [ apply,
						 function(sublis),
						 sys_alist,
						 [car, sys_tree],
						 rest
					       ]
					     ],
					     
					     [ sys_d,
					       
					       [ apply,
						 function(sublis),
						 sys_alist,
						 [cdr, sys_tree],
						 rest
					       ]
					     ]
					   ],
					   
					   [ if,
					     
					     [ and,
					       [eq, sys_a, [car, sys_tree]],
					       [eq, sys_d, [cdr, sys_tree]]
					     ],
					     sys_tree,
					     [cons, sys_a, sys_d]
					   ]
					 ],
					 
					 [ let,
					   
					   [ 
					     [ sys_a,
					       
					       [ apply,
						 function(assoc),
						 sys_tree,
						 sys_alist,
						 rest
					       ]
					     ]
					   ],
					   [if, sys_a, [cdr, sys_a], sys_tree]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sublis,
			  arglist_info(sublis,
				       cl_sublis,
				       [sys_alist, sys_tree, c38_rest, rest],
				       arginfo{ all:[sys_alist, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_alist,
							sys_tree,
							rest
						      ],
						opt:0,
						req:[sys_alist, sys_tree],
						rest:[rest],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sublis, init_args(2, cl_sublis))).
*/
/*
#+(or WAM-CL LISP500) 
(defun nsublis (alist tree &rest rest)
  (if (consp tree)
      (progn
	(setf (car tree) (apply #'nsublis alist (car tree) rest))
	(setf (cdr tree) (apply #'nsublis alist (cdr tree) rest))
	tree)
      (let ((a (apply #'assoc tree alist rest)))
	(if a (cdr a) tree))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:64535 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nsublis,[alist,tree,'&rest',rest],[if,[consp,tree],[progn,[setf,[car,tree],[apply,function(nsublis),alist,[car,tree],rest]],[setf,[cdr,tree],[apply,function(nsublis),alist,[cdr,tree],rest]],tree],[let,[[a,[apply,function(assoc),tree,alist,rest]]],[if,a,[cdr,a],tree]]]]).
/*
:- side_effect((compile_each($, _232350160, [], [], true), append([sys_tree], [CAR12, CAR], [sys_tree, CAR12, CAR]), setf_inverse_op(car, rplaca))).
*/
/*
:- side_effect((compile_each($, _232350160, [], [], true), append([sys_tree], [CAR12, CAR], [sys_tree, CAR12, CAR]), setf_inverse_op(car, sys_set_car))).
*/
/*
:- side_effect((compile_each($, _232350160, [], [], true), append([sys_tree], [CAR12, CAR], [sys_tree, CAR12, CAR]), setf_inverse_op(car, setf_car))).
*/
/*
:- side_effect((compile_each($, _232350160, [], [], true), append([sys_tree], [CAR12, CAR], [sys_tree, CAR12, CAR]), setf_inverse_op(car, rplaca))).
*/
/*
:-side_effect((compile_each($,_232350160,[],[],true),append([sys_tree],[_232595324,_232595152],[sys_tree,_232595324,_232595152]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_232350160,[],[],true),append([sys_tree],[_232627166,_232626994],[sys_tree,_232627166,_232626994]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_232350160,[],[],true),append([sys_tree],[_232659134,_232658962],[sys_tree,_232659134,_232658962]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_232350160,[],[],true),append([sys_tree],[_232691130,_232690958],[sys_tree,_232691130,_232690958]),setf_inverse_op(cdr,rplacd))).
*/
wl:lambda_def(defun, nsublis, cl_nsublis, [sys_alist, sys_tree, c38_rest, rest], [[if, [consp, sys_tree], [progn, [setf, [car, sys_tree], [apply, function(nsublis), sys_alist, [car, sys_tree], rest]], [setf, [cdr, sys_tree], [apply, function(nsublis), sys_alist, [cdr, sys_tree], rest]], sys_tree], [let, [[sys_a, [apply, function(assoc), sys_tree, sys_alist, rest]]], [if, sys_a, [cdr, sys_a], sys_tree]]]]).
wl:arglist_info(nsublis, cl_nsublis, [sys_alist, sys_tree, c38_rest, rest], arginfo{all:[sys_alist, sys_tree], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_alist, sys_tree, rest], opt:0, req:[sys_alist, sys_tree], rest:[rest], sublists:0, whole:0}).
wl: init_args(2, cl_nsublis).

/*

### Compiled:  `CL:NSUBLIS` 
*/
cl_nsublis(Alist_In, Tree_In, RestNKeys, FnResult) :-
	Env42=[bv(sys_alist, Alist_In), bv(sys_tree, Tree_In), bv(rest, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env42, sys_tree, Tree_Get),
		(   is_consp(Tree_Get)
		->  get_var(Env42, sys_alist, Alist_Get),
		    get_var(Env42, sys_tree, Tree_Get13),
		    get_var(Env42, sys_tree, Tree_Get15),
		    cl_car(Tree_Get15, Car_Ret),
		    get_var(Env42, rest, Rest_Get),
		    cl_nsublis(Alist_Get, Car_Ret, Rest_Get, Nsublis_Ret),
		    cl_rplaca(Tree_Get13, Nsublis_Ret, Rplaca_Ret),
		    get_var(Env42, sys_alist, Alist_Get20),
		    get_var(Env42, sys_tree, Tree_Get19),
		    get_var(Env42, sys_tree, Tree_Get21),
		    cl_cdr(Tree_Get21, Cdr_Ret),
		    get_var(Env42, rest, Rest_Get22),
		    cl_nsublis(Alist_Get20, Cdr_Ret, Rest_Get22, Nsublis_Ret47),
		    cl_rplacd(Tree_Get19, Nsublis_Ret47, Rplacd_Ret),
		    get_var(Env42, sys_tree, Tree_Get23),
		    _232372156=Tree_Get23
		;   get_var(Env42, sys_alist, Alist_Get28),
		    get_var(Env42, sys_tree, Tree_Get27),
		    get_var(Env42, rest, Rest_Get29),
		    cl_assoc(Tree_Get27, Alist_Get28, Rest_Get29, A_Init),
		    LEnv=[bv(sys_a, A_Init)|Env42],
		    get_var(LEnv, sys_a, IFTEST31),
		    (   IFTEST31\==[]
		    ->  get_var(LEnv, sys_a, A_Get34),
			cl_cdr(A_Get34, TrueResult),
			LetResult=TrueResult
		    ;   get_var(LEnv, sys_tree, Tree_Get35),
			LetResult=Tree_Get35
		    ),
		    _232372156=LetResult
		),
		_232372156=FnResult
	      ),
	      block_exit(nsublis, FnResult),
	      true).
:- set_opv(cl_nsublis, classof, claz_function),
   set_opv(nsublis, compile_as, kw_function),
   set_opv(nsublis, function, cl_nsublis),
   DefunResult=nsublis.
/*
:- side_effect(assert_lsp(nsublis,
			  lambda_def(defun,
				     nsublis,
				     cl_nsublis,
				     [sys_alist, sys_tree, c38_rest, rest],
				     
				     [ 
				       [ if,
					 [consp, sys_tree],
					 
					 [ progn,
					   
					   [ setf,
					     [car, sys_tree],
					     
					     [ apply,
					       function(nsublis),
					       sys_alist,
					       [car, sys_tree],
					       rest
					     ]
					   ],
					   
					   [ setf,
					     [cdr, sys_tree],
					     
					     [ apply,
					       function(nsublis),
					       sys_alist,
					       [cdr, sys_tree],
					       rest
					     ]
					   ],
					   sys_tree
					 ],
					 
					 [ let,
					   
					   [ 
					     [ sys_a,
					       
					       [ apply,
						 function(assoc),
						 sys_tree,
						 sys_alist,
						 rest
					       ]
					     ]
					   ],
					   [if, sys_a, [cdr, sys_a], sys_tree]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nsublis,
			  arglist_info(nsublis,
				       cl_nsublis,
				       [sys_alist, sys_tree, c38_rest, rest],
				       arginfo{ all:[sys_alist, sys_tree],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_alist,
							sys_tree,
							rest
						      ],
						opt:0,
						req:[sys_alist, sys_tree],
						rest:[rest],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nsublis, init_args(2, cl_nsublis))).
*/
/*
#+(or WAM-CL LISP500) 
(defun copy-list (list)
  (if (consp list) (cons (car list) (copy-list (cdr list))) list))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:64838 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'copy-list',[list],[if,[consp,list],[cons,[car,list],['copy-list',[cdr,list]]],list]]).
wl:lambda_def(defun, copy_list, cl_copy_list, [list], [[if, [consp, list], [cons, [car, list], [copy_list, [cdr, list]]], list]]).
wl:arglist_info(copy_list, cl_copy_list, [list], arginfo{all:[list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list], opt:0, req:[list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_copy_list).

/*

### Compiled:  `CL:COPY-LIST` 
*/
cl_copy_list(List_In, FnResult) :-
	Env15=[bv(list, List_In)|Env],
	global_env(Env),
	catch(( get_var(Env15, list, List_Get),
		(   is_consp(List_Get)
		->  get_var(Env15, list, List_Get8),
		    cl_car(List_Get8, Car_Ret),
		    get_var(Env15, list, List_Get9),
		    cl_cdr(List_Get9, Copy_list_Param),
		    cl_copy_list(Copy_list_Param, Copy_list_Ret),
		    TrueResult=[Car_Ret|Copy_list_Ret],
		    _233840906=TrueResult
		;   get_var(Env15, list, List_Get10),
		    _233840906=List_Get10
		),
		_233840906=FnResult
	      ),
	      block_exit(copy_list, FnResult),
	      true).
:- set_opv(cl_copy_list, classof, claz_function),
   set_opv(copy_list, compile_as, kw_function),
   set_opv(copy_list, function, cl_copy_list),
   DefunResult=copy_list.
/*
:- side_effect(assert_lsp(copy_list,
			  lambda_def(defun,
				     copy_list,
				     cl_copy_list,
				     [list],
				     
				     [ 
				       [ if,
					 [consp, list],
					 
					 [ cons,
					   [car, list],
					   [copy_list, [cdr, list]]
					 ],
					 list
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(copy_list,
			  arglist_info(copy_list,
				       cl_copy_list,
				       [list],
				       arginfo{ all:[list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list],
						opt:0,
						req:[list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(copy_list, init_args(exact_only, cl_copy_list))).
*/
/*
#+(or WAM-CL LISP500) 
(defun make-list (size &key initial-element)
  (if (= size 0) nil
      (cons initial-element
	    (make-list (- size 1) :initial-element initial-element))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:64957 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'make-list',[size,'&key','initial-element'],[if,[=,size,0],[],[cons,'initial-element',['make-list',[-,size,1],':initial-element','initial-element']]]]).
wl:lambda_def(defun, make_list, cl_make_list, [sys_size, c38_key, sys_initial_element], [[if, [=, sys_size, 0], [], [cons, sys_initial_element, [make_list, [-, sys_size, 1], kw_initial_element, sys_initial_element]]]]).
wl:arglist_info(make_list, cl_make_list, [sys_size, c38_key, sys_initial_element], arginfo{all:[sys_size], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:[sys_initial_element], names:[sys_size, sys_initial_element], opt:0, req:[sys_size], rest:0, sublists:0, whole:0}).
wl: init_args(1, cl_make_list).

/*

### Compiled:  `CL:MAKE-LIST` 
*/
cl_make_list(Size_In, RestNKeys, FnResult) :-
	Env17=[bv(sys_size, Size_In), bv(sys_initial_element, Initial_element_In)|Env],
	global_env(Env),
	get_kw(Env,
	       RestNKeys,
	       sys_initial_element,
	       sys_initial_element,
	       Initial_element_In,
	       []=Initial_element_In,
	       Initial_element_P),
	catch(( get_var(Env17, sys_size, Size_Get),
		(   Size_Get=:=0
		->  _234530974=[]
		;   get_var(Env17, sys_initial_element, Initial_element_Get),
		    get_var(Env17, sys_size, Size_Get12),
		    -(Size_Get12, 1, Make_list_Param),
		    get_var(Env17, sys_initial_element, Initial_element_Get13),
		    cl_make_list(Make_list_Param,
				 [kw_initial_element, Initial_element_Get13],
				 Make_list_Ret),
		    ElseResult=[Initial_element_Get|Make_list_Ret],
		    _234530974=ElseResult
		),
		_234530974=FnResult
	      ),
	      block_exit(make_list, FnResult),
	      true).
:- set_opv(cl_make_list, classof, claz_function),
   set_opv(make_list, compile_as, kw_function),
   set_opv(make_list, function, cl_make_list),
   DefunResult=make_list.
/*
:- side_effect(assert_lsp(make_list,
			  lambda_def(defun,
				     make_list,
				     cl_make_list,
				     [sys_size, c38_key, sys_initial_element],
				     
				     [ 
				       [ if,
					 [=, sys_size, 0],
					 [],
					 
					 [ cons,
					   sys_initial_element,
					   
					   [ make_list,
					     [-, sys_size, 1],
					     kw_initial_element,
					     sys_initial_element
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(make_list,
			  arglist_info(make_list,
				       cl_make_list,
				       [sys_size, c38_key, sys_initial_element],
				       arginfo{ all:[sys_size],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:[sys_initial_element],
						names:
						      [ sys_size,
							sys_initial_element
						      ],
						opt:0,
						req:[sys_size],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(make_list, init_args(1, cl_make_list))).
*/
/*
#+(or WAM-CL LISP500) 
(defun list* (&rest objects)
  (if (cdr objects)
      (cons (car objects) (apply #'list* (cdr objects)))
      (car objects)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:65145 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'list*',['&rest',objects],[if,[cdr,objects],[cons,[car,objects],[apply,function('list*'),[cdr,objects]]],[car,objects]]]).
wl:lambda_def(defun, list_xx, cl_list_xx, [c38_rest, sys_objects], [[if, [cdr, sys_objects], [cons, [car, sys_objects], [apply, function(list_xx), [cdr, sys_objects]]], [car, sys_objects]]]).
wl:arglist_info(list_xx, cl_list_xx, [c38_rest, sys_objects], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_objects], opt:0, req:0, rest:[sys_objects], sublists:0, whole:0}).
wl: init_args(0, cl_list_xx).

/*

### Compiled:  `CL:LIST*` 
*/
cl_list_xx(RestNKeys, FnResult) :-
	Env15=[bv(sys_objects, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env15, sys_objects, Objects_Get),
		cl_cdr(Objects_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env15, sys_objects, Objects_Get8),
		    cl_car(Objects_Get8, Car_Ret),
		    get_var(Env15, sys_objects, Objects_Get9),
		    cl_cdr(Objects_Get9, List_xx_Param),
		    cl_list_xx(List_xx_Param, List_xx_Ret),
		    TrueResult=[Car_Ret|List_xx_Ret],
		    _235270236=TrueResult
		;   get_var(Env15, sys_objects, Objects_Get10),
		    cl_car(Objects_Get10, ElseResult),
		    _235270236=ElseResult
		),
		_235270236=FnResult
	      ),
	      block_exit(list_xx, FnResult),
	      true).
:- set_opv(cl_list_xx, classof, claz_function),
   set_opv(list_xx, compile_as, kw_function),
   set_opv(list_xx, function, cl_list_xx),
   DefunResult=list_xx.
/*
:- side_effect(assert_lsp(list_xx,
			  lambda_def(defun,
				     list_xx,
				     cl_list_xx,
				     [c38_rest, sys_objects],
				     
				     [ 
				       [ if,
					 [cdr, sys_objects],
					 
					 [ cons,
					   [car, sys_objects],
					   
					   [ apply,
					     function(list_xx),
					     [cdr, sys_objects]
					   ]
					 ],
					 [car, sys_objects]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(list_xx,
			  arglist_info(list_xx,
				       cl_list_xx,
				       [c38_rest, sys_objects],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_objects],
						opt:0,
						req:0,
						rest:[sys_objects],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(list_xx, init_args(0, cl_list_xx))).
*/
/*
#+(or WAM-CL LISP500) 
(defun list-length (list)
  (let ((slow list)
	(fast list)
	(odd nil)
	(len 0))
    (tagbody
     start
       (when (atom fast) (return-from list-length len))
       (setf fast (cdr fast))
       (setf len (+ 1 len))
       (when odd (setf slow (cdr slow)))
       (setf odd (not odd))
       (unless (eq slow fast) (go start)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:65303 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'list-length',[list],[let,[[slow,list],[fast,list],[odd,[]],[len,0]],[tagbody,start,[when,[atom,fast],['return-from','list-length',len]],[setf,fast,[cdr,fast]],[setf,len,[+,1,len]],[when,odd,[setf,slow,[cdr,slow]]],[setf,odd,[not,odd]],[unless,[eq,slow,fast],[go,start]]]]]).
wl:lambda_def(defun, list_length, cl_list_length, [list], [[let, [[sys_slow, list], [sys_fast, list], [sys_odd, []], [sys_len, 0]], [tagbody, start, [when, [atom, sys_fast], [return_from, list_length, sys_len]], [setf, sys_fast, [cdr, sys_fast]], [setf, sys_len, [+, 1, sys_len]], [when, sys_odd, [setf, sys_slow, [cdr, sys_slow]]], [setf, sys_odd, [not, sys_odd]], [unless, [eq, sys_slow, sys_fast], [go, start]]]]]).
wl:arglist_info(list_length, cl_list_length, [list], arginfo{all:[list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list], opt:0, req:[list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_list_length).

/*

### Compiled:  `CL:LIST-LENGTH` 
*/
cl_list_length(List_In, FnResult) :-
	Env67=[bv(list, List_In)|Env],
	global_env(Env),
	catch(( get_var(Env67, list, List_Get8),
		BlockExitEnv=[bv(sys_slow, List_Get8), bv(sys_fast, List_Get8), bv(sys_odd, []), bv(sys_len, 0)|Env67],
		call_addr_block(BlockExitEnv,
				(push_label(start), get_var(BlockExitEnv, sys_fast, Fast_Get40), (Fast_Get40\=[CAR|CDR]->get_var(BlockExitEnv, sys_len, RetResult43), throw(block_exit(list_length, RetResult43)), _236158998=ThrowResult44;_236158998=[]), get_var(BlockExitEnv, sys_fast, Fast_Get48), cl_cdr(Fast_Get48, Fast), set_var(BlockExitEnv, sys_fast, Fast), get_var(BlockExitEnv, sys_len, Len_Get49), +(1, Len_Get49, Len), set_var(BlockExitEnv, sys_len, Len), get_var(BlockExitEnv, sys_odd, IFTEST50), (IFTEST50\==[]->get_var(BlockExitEnv, sys_slow, Slow_Get53), cl_cdr(Slow_Get53, TrueResult54), set_var(BlockExitEnv, sys_slow, TrueResult54), _236177748=TrueResult54;_236177748=[]), get_var(BlockExitEnv, sys_odd, Odd_Get55), cl_not(Odd_Get55, Odd), set_var(BlockExitEnv, sys_odd, Odd), get_var(BlockExitEnv, sys_fast, Fast_Get58), get_var(BlockExitEnv, sys_slow, Slow_Get57), (is_eq(Slow_Get57, Fast_Get58)->_TBResult=[];goto(start, BlockExitEnv), _TBResult=_GORES62)),
				
				[ addr(addr_tagbody_31_start,
				       start,
				       '$unused',
				       BlockExitEnv,
				       (get_var(BlockExitEnv, sys_fast, Fast_Get), (Fast_Get\=[CAR74|CDR75]->get_var(BlockExitEnv, sys_len, Get_var_Ret), throw(block_exit(list_length, Get_var_Ret)), _236238962=ThrowResult;_236238962=[]), get_var(BlockExitEnv, sys_fast, Fast_Get21), cl_cdr(Fast_Get21, Cdr_Ret), set_var(BlockExitEnv, sys_fast, Cdr_Ret), get_var(BlockExitEnv, sys_len, Len_Get22), +(1, Len_Get22, Set_var_Ret), set_var(BlockExitEnv, sys_len, Set_var_Ret), get_var(BlockExitEnv, sys_odd, IFTEST23), (IFTEST23\==[]->get_var(BlockExitEnv, sys_slow, Cdr_Param), cl_cdr(Cdr_Param, TrueResult27), set_var(BlockExitEnv, sys_slow, TrueResult27), _236239204=TrueResult27;_236239204=[]), get_var(BlockExitEnv, sys_odd, Odd_Get28), cl_not(Odd_Get28, Not_Ret), set_var(BlockExitEnv, sys_odd, Not_Ret), get_var(BlockExitEnv, sys_fast, Fast_Get31), get_var(BlockExitEnv, sys_slow, Slow_Get30), (is_eq(Slow_Get30, Fast_Get31)->_236239344=[];goto(start, BlockExitEnv), _236239344=_GORES)))
				]),
		[]=FnResult
	      ),
	      block_exit(list_length, FnResult),
	      true).
:- set_opv(cl_list_length, classof, claz_function),
   set_opv(list_length, compile_as, kw_function),
   set_opv(list_length, function, cl_list_length),
   DefunResult=list_length.
/*
:- side_effect(assert_lsp(list_length,
			  lambda_def(defun,
				     list_length,
				     cl_list_length,
				     [list],
				     
				     [ 
				       [ let,
					 
					 [ [sys_slow, list],
					   [sys_fast, list],
					   [sys_odd, []],
					   [sys_len, 0]
					 ],
					 
					 [ tagbody,
					   start,
					   
					   [ when,
					     [atom, sys_fast],
					     [return_from, list_length, sys_len]
					   ],
					   [setf, sys_fast, [cdr, sys_fast]],
					   [setf, sys_len, [+, 1, sys_len]],
					   
					   [ when,
					     sys_odd,
					     [setf, sys_slow, [cdr, sys_slow]]
					   ],
					   [setf, sys_odd, [not, sys_odd]],
					   
					   [ unless,
					     [eq, sys_slow, sys_fast],
					     [go, start]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(list_length,
			  arglist_info(list_length,
				       cl_list_length,
				       [list],
				       arginfo{ all:[list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list],
						opt:0,
						req:[list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(list_length, init_args(exact_only, cl_list_length))).
*/
/*
#+(or WAM-CL LISP500) 
(defun listp (object) (or (consp object) (eq object nil)))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:65674 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,listp,[object],[or,[consp,object],[eq,object,[]]]]).
wl:lambda_def(defun, listp, cl_listp, [sys_object], [[or, [consp, sys_object], [eq, sys_object, []]]]).
wl:arglist_info(listp, cl_listp, [sys_object], arginfo{all:[sys_object], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object], opt:0, req:[sys_object], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_listp).

/*

### Compiled:  `CL:LISTP` 
*/
cl_listp(Object_In, FnResult) :-
	Env9=[bv(sys_object, Object_In)|Env],
	global_env(Env),
	catch(( (   get_var(Env9, sys_object, Object_Get),
		    cl_consp(Object_Get, FORM1_Res),
		    FORM1_Res\==[],
		    _237640004=FORM1_Res
		->  true
		;   get_var(Env9, sys_object, Object_Get5),
		    cl_eq(Object_Get5, [], Eq_Ret),
		    _237640004=Eq_Ret
		),
		_237640004=FnResult
	      ),
	      block_exit(listp, FnResult),
	      true).
:- set_opv(cl_listp, classof, claz_function),
   set_opv(listp, compile_as, kw_function),
   set_opv(listp, function, cl_listp),
   DefunResult=listp.
/*
:- side_effect(assert_lsp(listp,
			  lambda_def(defun,
				     listp,
				     cl_listp,
				     [sys_object],
				     
				     [ 
				       [ or,
					 [consp, sys_object],
					 [eq, sys_object, []]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(listp,
			  arglist_info(listp,
				       cl_listp,
				       [sys_object],
				       arginfo{ all:[sys_object],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_object],
						opt:0,
						req:[sys_object],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(listp, init_args(exact_only, cl_listp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun nth (n list) (if (< n 1) (car list) (nth (- n 1) (cdr list))))
*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:65764 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nth,[n,list],[if,[<,n,1],[car,list],[nth,[-,n,1],[cdr,list]]]]).
wl:lambda_def(defun, nth, cl_nth, [n, list], [[if, [<, n, 1], [car, list], [nth, [-, n, 1], [cdr, list]]]]).
wl:arglist_info(nth, cl_nth, [n, list], arginfo{all:[n, list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[n, list], opt:0, req:[n, list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_nth).

/*

### Compiled:  `CL:NTH` 
*/
cl_nth(N_In, List_In, FnResult) :-
	Env16=[bv(n, N_In), bv(list, List_In)|Env],
	global_env(Env),
	catch(( get_var(Env16, n, N_Get),
		(   N_Get<1
		->  get_var(Env16, list, List_Get),
		    cl_car(List_Get, TrueResult),
		    _238228030=TrueResult
		;   get_var(Env16, n, N_Get10),
		    -(N_Get10, 1, Nth_Param),
		    get_var(Env16, list, List_Get11),
		    cl_cdr(List_Get11, Cdr_Ret),
		    cl_nth(Nth_Param, Cdr_Ret, ElseResult),
		    _238228030=ElseResult
		),
		_238228030=FnResult
	      ),
	      block_exit(nth, FnResult),
	      true).
:- set_opv(cl_nth, classof, claz_function),
   set_opv(nth, compile_as, kw_function),
   set_opv(nth, function, cl_nth),
   DefunResult=nth.
/*
:- side_effect(assert_lsp(nth,
			  lambda_def(defun,
				     nth,
				     cl_nth,
				     [n, list],
				     
				     [ 
				       [ if,
					 [<, n, 1],
					 [car, list],
					 [nth, [-, n, 1], [cdr, list]]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nth,
			  arglist_info(nth,
				       cl_nth,
				       [n, list],
				       arginfo{ all:[n, list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[n, list],
						opt:0,
						req:[n, list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nth, init_args(exact_only, cl_nth))).
*/
/*
'(defun (setf nth) (new-object n list)
  (if (< n 1)
      (setf (car list) new-object)
      (setf (nth (- n 1) (cdr list)) new-object)))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:65859 **********************/
:-lisp_compile_to_prolog(pkg_sys,[quote,[defun,[setf,nth],['new-object',n,list],[if,[<,n,1],[setf,[car,list],'new-object'],[setf,[nth,[-,n,1],[cdr,list]],'new-object']]]]).
/*
#+(or WAM-CL LISP500) 
(defun endp (list) (not list))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:66006 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,endp,[list],[not,list]]).
wl:lambda_def(defun, endp, cl_endp, [list], [[not, list]]).
wl:arglist_info(endp, cl_endp, [list], arginfo{all:[list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list], opt:0, req:[list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_endp).

/*

### Compiled:  `CL:ENDP` 
*/
cl_endp(List_In, FnResult) :-
	Env7=[bv(list, List_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, list, List_Get),
		cl_not(List_Get, Not_Ret),
		Not_Ret=FnResult
	      ),
	      block_exit(endp, FnResult),
	      true).
:- set_opv(cl_endp, classof, claz_function),
   set_opv(endp, compile_as, kw_function),
   set_opv(endp, function, cl_endp),
   DefunResult=endp.
/*
:- side_effect(assert_lsp(endp,
			  lambda_def(defun, endp, cl_endp, [list], [[not, list]]))).
*/
/*
:- side_effect(assert_lsp(endp,
			  arglist_info(endp,
				       cl_endp,
				       [list],
				       arginfo{ all:[list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list],
						opt:0,
						req:[list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(endp, init_args(exact_only, cl_endp))).
*/
/*
#+(or WAM-CL LISP500) 
(defun nconc (&rest lists)
  (if (cdr lists)
      (if (car lists)
	  (progn (setf (cdr (last (car lists))) (apply #'nconc (cdr lists)))
		 (car lists))
	  (apply #'nconc (cdr lists)))
      (car lists)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:66064 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nconc,['&rest',lists],[if,[cdr,lists],[if,[car,lists],[progn,[setf,[cdr,[last,[car,lists]]],[apply,function(nconc),[cdr,lists]]],[car,lists]],[apply,function(nconc),[cdr,lists]]],[car,lists]]]).
/*
:- side_effect((compile_each($, _239597094, [], [], true), append([[last, [car, sys_lists]]], [CAR12, CAR], [[last, [car, sys_lists]], CAR12, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, _239597094, [], [], true), append([[last, [car, sys_lists]]], [CAR12, CAR], [[last, [car, sys_lists]], CAR12, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, _239597094, [], [], true), append([[last, [car, sys_lists]]], [CAR12, CAR], [[last, [car, sys_lists]], CAR12, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, _239597094, [], [], true), append([[last, [car, sys_lists]]], [CAR12, CAR], [[last, [car, sys_lists]], CAR12, CAR]), setf_inverse_op(cdr, rplacd))).
*/
wl:lambda_def(defun, nconc, cl_nconc, [c38_rest, sys_lists], [[if, [cdr, sys_lists], [if, [car, sys_lists], [progn, [setf, [cdr, [last, [car, sys_lists]]], [apply, function(nconc), [cdr, sys_lists]]], [car, sys_lists]], [apply, function(nconc), [cdr, sys_lists]]], [car, sys_lists]]]).
wl:arglist_info(nconc, cl_nconc, [c38_rest, sys_lists], arginfo{all:0, allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_lists], opt:0, req:0, rest:[sys_lists], sublists:0, whole:0}).
wl: init_args(0, cl_nconc).

/*

### Compiled:  `CL:NCONC` 
*/
cl_nconc(Nconc_Param, FnResult) :-
	Env24=[bv(sys_lists, RestNKeys)|Env],
	global_env(Env),
	append([], RestNKeys, Nconc_Param),
	catch(( get_var(Env24, sys_lists, Lists_Get),
		cl_cdr(Lists_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env24, sys_lists, Lists_Get10),
		    cl_car(Lists_Get10, IFTEST8),
		    (   IFTEST8\==[]
		    ->  get_var(Env24, sys_lists, Lists_Get13),
			cl_car(Lists_Get13, Last_Param),
			cl_last(Last_Param, [], Rplacd_Param),
			get_var(Env24, sys_lists, Lists_Get14),
			cl_cdr(Lists_Get14, Nconc_Param27),
			cl_nconc(Nconc_Param27, Nconc_Ret),
			cl_rplacd(Rplacd_Param, Nconc_Ret, Rplacd_Ret),
			get_var(Env24, sys_lists, Lists_Get15),
			cl_car(Lists_Get15, TrueResult),
			TrueResult20=TrueResult
		    ;   get_var(Env24, sys_lists, Lists_Get16),
			cl_cdr(Lists_Get16, Nconc_Param29),
			cl_nconc(Nconc_Param29, ElseResult),
			TrueResult20=ElseResult
		    ),
		    _239608724=TrueResult20
		;   get_var(Env24, sys_lists, Lists_Get19),
		    cl_car(Lists_Get19, ElseResult21),
		    _239608724=ElseResult21
		),
		_239608724=FnResult
	      ),
	      block_exit(nconc, FnResult),
	      true).
:- set_opv(cl_nconc, classof, claz_function),
   set_opv(nconc, compile_as, kw_function),
   set_opv(nconc, function, cl_nconc),
   DefunResult=nconc.
/*
:- side_effect(assert_lsp(nconc,
			  lambda_def(defun,
				     nconc,
				     cl_nconc,
				     [c38_rest, sys_lists],
				     
				     [ 
				       [ if,
					 [cdr, sys_lists],
					 
					 [ if,
					   [car, sys_lists],
					   
					   [ progn,
					     
					     [ setf,
					       [cdr, [last, [car, sys_lists]]],
					       
					       [ apply,
						 function(nconc),
						 [cdr, sys_lists]
					       ]
					     ],
					     [car, sys_lists]
					   ],
					   
					   [ apply,
					     function(nconc),
					     [cdr, sys_lists]
					   ]
					 ],
					 [car, sys_lists]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nconc,
			  arglist_info(nconc,
				       cl_nconc,
				       [c38_rest, sys_lists],
				       arginfo{ all:0,
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[sys_lists],
						opt:0,
						req:0,
						rest:[sys_lists],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nconc, init_args(0, cl_nconc))).
*/
/*
#+(or WAM-CL LISP500) 
(defun revappend (list tail)
  (if list
      (revappend (cdr list) (cons (car list) tail))
      tail))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:66302 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,revappend,[list,tail],[if,list,[revappend,[cdr,list],[cons,[car,list],tail]],tail]]).
wl:lambda_def(defun, revappend, cl_revappend, [list, sys_tail], [[if, list, [revappend, [cdr, list], [cons, [car, list], sys_tail]], sys_tail]]).
wl:arglist_info(revappend, cl_revappend, [list, sys_tail], arginfo{all:[list, sys_tail], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list, sys_tail], opt:0, req:[list, sys_tail], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_revappend).

/*

### Compiled:  `CL:REVAPPEND` 
*/
cl_revappend(List_In, Tail_In, FnResult) :-
	Env16=[bv(list, List_In), bv(sys_tail, Tail_In)|Env],
	global_env(Env),
	catch(( get_var(Env16, list, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env16, list, List_Get8),
		    cl_cdr(List_Get8, Revappend_Param),
		    get_var(Env16, list, List_Get9),
		    cl_car(List_Get9, Car_Ret),
		    get_var(Env16, sys_tail, Tail_Get),
		    _240781040=[Car_Ret|Tail_Get],
		    cl_revappend(Revappend_Param, _240781040, TrueResult),
		    _240775982=TrueResult
		;   get_var(Env16, sys_tail, Tail_Get11),
		    _240775982=Tail_Get11
		),
		_240775982=FnResult
	      ),
	      block_exit(revappend, FnResult),
	      true).
:- set_opv(cl_revappend, classof, claz_function),
   set_opv(revappend, compile_as, kw_function),
   set_opv(revappend, function, cl_revappend),
   DefunResult=revappend.
/*
:- side_effect(assert_lsp(revappend,
			  lambda_def(defun,
				     revappend,
				     cl_revappend,
				     [list, sys_tail],
				     
				     [ 
				       [ if,
					 list,
					 
					 [ revappend,
					   [cdr, list],
					   [cons, [car, list], sys_tail]
					 ],
					 sys_tail
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(revappend,
			  arglist_info(revappend,
				       cl_revappend,
				       [list, sys_tail],
				       arginfo{ all:[list, sys_tail],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list, sys_tail],
						opt:0,
						req:[list, sys_tail],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(revappend, init_args(exact_only, cl_revappend))).
*/
/*
#+(or WAM-CL LISP500) 
(defun nreconc (list tail)
  (if list
      (let ((new-list (cdr list)))
	(setf (cdr list) tail)
	(nreconc new-list list))
      tail))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:66437 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nreconc,[list,tail],[if,list,[let,[['new-list',[cdr,list]]],[setf,[cdr,list],tail],[nreconc,'new-list',list]],tail]]).
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([list], [CAR14, CAR], [list, CAR14, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([list], [CAR14, CAR], [list, CAR14, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([list], [CAR14, CAR], [list, CAR14, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([list], [CAR14, CAR], [list, CAR14, CAR]), setf_inverse_op(cdr, rplacd))).
*/
wl:lambda_def(defun, nreconc, cl_nreconc, [list, sys_tail], [[if, list, [let, [[sys_new_list, [cdr, list]]], [setf, [cdr, list], sys_tail], [nreconc, sys_new_list, list]], sys_tail]]).
wl:arglist_info(nreconc, cl_nreconc, [list, sys_tail], arginfo{all:[list, sys_tail], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list, sys_tail], opt:0, req:[list, sys_tail], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_nreconc).

/*

### Compiled:  `CL:NRECONC` 
*/
cl_nreconc(List_In, Tail_In, FnResult) :-
	Env24=[bv(list, List_In), bv(sys_tail, Tail_In)|Env],
	global_env(Env),
	catch(( get_var(Env24, list, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env24, list, List_Get11),
		    cl_cdr(List_Get11, New_list_Init),
		    LEnv=[bv(sys_new_list, New_list_Init)|Env24],
		    get_var(LEnv, list, List_Get15),
		    get_var(LEnv, sys_tail, Tail_Get),
		    cl_rplacd(List_Get15, Tail_Get, Rplacd_Ret),
		    get_var(LEnv, list, List_Get18),
		    get_var(LEnv, sys_new_list, New_list_Get),
		    cl_nreconc(New_list_Get, List_Get18, LetResult),
		    _241478924=LetResult
		;   get_var(Env24, sys_tail, Tail_Get19),
		    _241478924=Tail_Get19
		),
		_241478924=FnResult
	      ),
	      block_exit(nreconc, FnResult),
	      true).
:- set_opv(cl_nreconc, classof, claz_function),
   set_opv(nreconc, compile_as, kw_function),
   set_opv(nreconc, function, cl_nreconc),
   DefunResult=nreconc.
/*
:- side_effect(assert_lsp(nreconc,
			  lambda_def(defun,
				     nreconc,
				     cl_nreconc,
				     [list, sys_tail],
				     
				     [ 
				       [ if,
					 list,
					 
					 [ let,
					   [[sys_new_list, [cdr, list]]],
					   [setf, [cdr, list], sys_tail],
					   [nreconc, sys_new_list, list]
					 ],
					 sys_tail
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(nreconc,
			  arglist_info(nreconc,
				       cl_nreconc,
				       [list, sys_tail],
				       arginfo{ all:[list, sys_tail],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list, sys_tail],
						opt:0,
						req:[list, sys_tail],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(nreconc, init_args(exact_only, cl_nreconc))).
*/
/*
#+(or WAM-CL LISP500) 
(defun butlast (list &optional (n 1))
  (let* ((r (cons nil nil))
	 (e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e r)
    (tagbody
     start
       (unless (consp list) (return-from butlast nil))
       (unless (< n 1)
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (setf n (- n 1))
	 (go start)))
    (cdr r)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:66605 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,butlast,[list,'&optional',[n,1]],['let*',[[r,[cons,[],[]]],[e,list],[m,0]],[tagbody,start,[when,[consp,e],[setf,m,[+,m,1]],[setf,e,[cdr,e]],[go,start]]],[setf,n,[-,m,n]],[setf,e,r],[tagbody,start,[unless,[consp,list],['return-from',butlast,[]]],[unless,[<,n,1],[setf,e,[setf,[cdr,e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[setf,n,[-,n,1]],[go,start]]],[cdr,r]]]).
/*
:- side_effect((compile_each($, BlockExitEnv, [], [], true), append([sys_e], [CAR50, CAR], [sys_e, CAR50, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, BlockExitEnv, [], [], true), append([sys_e], [CAR50, CAR], [sys_e, CAR50, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, BlockExitEnv, [], [], true), append([sys_e], [CAR50, CAR], [sys_e, CAR50, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, BlockExitEnv, [], [], true), append([sys_e], [CAR50, CAR], [sys_e, CAR50, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:-side_effect((compile_each($,_242595266,[],[],true),append([sys_e],[_242955082,_242954910],[sys_e,_242955082,_242954910]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_242595266,[],[],true),append([sys_e],[_242986924,_242986752],[sys_e,_242986924,_242986752]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_242595266,[],[],true),append([sys_e],[_243018892,_243018720],[sys_e,_243018892,_243018720]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_242595266,[],[],true),append([sys_e],[_243050888,_243050716],[sys_e,_243050888,_243050716]),setf_inverse_op(cdr,rplacd))).
*/
wl:lambda_def(defun,butlast,cl_butlast,[list,c38_optional,[n,1]],[[let_xx,[[sys_r,[cons,[],[]]],[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,sys_r],[tagbody,start,[unless,[consp,list],[return_from,butlast,[]]],[unless,[<,n,1],[setf,sys_e,[setf,[cdr,sys_e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[setf,n,[-,n,1]],[go,start]]],[cdr,sys_r]]]).
wl:arglist_info(butlast,cl_butlast,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}).
wl:init_args(1,cl_butlast).

/*

### Compiled:  `CL:BUTLAST` 
*/
cl_butlast(_242489686,_242490112,_243301358):-_243858460=[bv(list,_242489686),bv(n,_242489726)|_242460898],global_env(_242460898),opt_var(_242460898,n,_242489726,true,1,1,_242490112),catch((_242502184=[[]],get_var(_243858460,list,_242524156),_242595266=[bv(sys_r,_242502184),bv(sys_e,_242524156),bv(sys_m,0)|_243858460],call_addr_block(_242595266,(push_label(start),get_var(_242595266,sys_e,_242587124),(is_consp(_242587124)->get_var(_242595266,sys_m,_242589944),+(_242589944,1,_242589056),set_var(_242595266,sys_m,_242589056),get_var(_242595266,sys_e,_242593004),cl_cdr(_242593004,_242592134),set_var(_242595266,sys_e,_242592134),goto(start,_242595266),_242539664=_242595018;_242539664=[])),[addr(addr_tagbody_32_start,start,'$unused',_242614222,(get_var(_242614222,sys_e,_242614242),(is_consp(_242614242)->get_var(_242614222,sys_m,_242614282),+(_242614282,1,_242614296),set_var(_242614222,sys_m,_242614296),get_var(_242614222,sys_e,_242614328),cl_cdr(_242614328,_242614350),set_var(_242614222,sys_e,_242614350),goto(start,_242614222),_242614380=_242614386;_242614380=[])))]),get_var(_242595266,n,_242617044),get_var(_242595266,sys_m,_242616588),-(_242616588,_242617044,_242615700),set_var(_242595266,n,_242615700),get_var(_242595266,sys_r,_242621060),set_var(_242595266,sys_e,_242621060),call_addr_block(_242595266,(push_label(start),get_var(_242595266,list,_242927898),(is_consp(_242927898)->_242926364=[];throw(block_exit(butlast,[])),_242926364=_242930306),get_var(_242595266,n,_242937938),(_242937938<1->_242632660=[];get_var(_242595266,list,_243070678),get_var(_242595266,sys_e,_243069178),cl_car(_243070678,_243069824),_243069750=[_243069824],cl_rplacd(_243069178,_243069750,_243869040),set_var(_242595266,sys_e,_243869040),get_var(_242595266,list,_243077344),cl_cdr(_243077344,_243076348),set_var(_242595266,list,_243076348),get_var(_242595266,n,_243080316),-(_243080316,1,_243870676),set_var(_242595266,n,_243870676),goto(start,_242595266),_242632660=_243082556)),[addr(addr_tagbody_33_start,start,'$unused',_243122566,(get_var(_243122566,list,_243122594),(is_consp(_243122594)->_243122630=[];throw(block_exit(butlast,[])),_243122630=_243122648),get_var(_243122566,n,_243122676),(_243122676<1->_243122714=[];get_var(_243122566,list,_243122778),get_var(_243122566,sys_e,_243122742),cl_car(_243122778,_244111322),_243122810=[_244111322],cl_rplacd(_243122742,_243122810,_243122832),set_var(_243122566,sys_e,_243122832),get_var(_243122566,list,_243122864),cl_cdr(_243122864,_244115962),set_var(_243122566,list,_244115962),get_var(_243122566,n,_243122918),-(_243122918,1,_244119418),set_var(_243122566,n,_244119418),goto(start,_243122566),_243122714=_243122978)))]),get_var(_242595266,sys_r,_243123880),cl_cdr(_243123880,_242494732),_242494732=_243301358),block_exit(butlast,_243301358),true).
:-set_opv(cl_butlast,classof,claz_function),set_opv(butlast,compile_as,kw_function),set_opv(butlast,function,cl_butlast),_242451346=butlast.
/*
:-side_effect(assert_lsp(butlast,lambda_def(defun,butlast,cl_butlast,[list,c38_optional,[n,1]],[[let_xx,[[sys_r,[cons,[],[]]],[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,sys_r],[tagbody,start,[unless,[consp,list],[return_from,butlast,[]]],[unless,[<,n,1],[setf,sys_e,[setf,[cdr,sys_e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[setf,n,[-,n,1]],[go,start]]],[cdr,sys_r]]]))).
*/
/*
:-side_effect(assert_lsp(butlast,arglist_info(butlast,cl_butlast,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(butlast,init_args(1,cl_butlast))).
*/
/*
#+(or WAM-CL LISP500) 
(defun nbutlast (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (unless (consp list) (return-from nbutlast nil))
       (unless (< n 2)
	 (setf e (cdr e))
	 (setf n (- n 1))
	 (go start)))
    (setf (cdr e) nil)
    list))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:67097 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,nbutlast,[list,'&optional',[n,1]],['let*',[[e,list],[m,0]],[tagbody,start,[when,[consp,e],[setf,m,[+,m,1]],[setf,e,[cdr,e]],[go,start]]],[setf,n,[-,m,n]],[setf,e,list],[tagbody,start,[unless,[consp,list],['return-from',nbutlast,[]]],[unless,[<,n,2],[setf,e,[cdr,e]],[setf,n,[-,n,1]],[go,start]]],[setf,[cdr,e],[]],list]]).
/*
:- side_effect((compile_each($, GoEnv, [], [], true), append([sys_e], [CAR71, CAR], [sys_e, CAR71, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, GoEnv, [], [], true), append([sys_e], [CAR71, CAR], [sys_e, CAR71, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, GoEnv, [], [], true), append([sys_e], [CAR71, CAR], [sys_e, CAR71, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, GoEnv, [], [], true), append([sys_e], [CAR71, CAR], [sys_e, CAR71, CAR]), setf_inverse_op(cdr, rplacd))).
*/
wl:lambda_def(defun,nbutlast,cl_nbutlast,[list,c38_optional,[n,1]],[[let_xx,[[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,list],[tagbody,start,[unless,[consp,list],[return_from,nbutlast,[]]],[unless,[<,n,2],[setf,sys_e,[cdr,sys_e]],[setf,n,[-,n,1]],[go,start]]],[setf,[cdr,sys_e],[]],list]]).
wl:arglist_info(nbutlast,cl_nbutlast,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}).
wl:init_args(1,cl_nbutlast).

/*

### Compiled:  `CL:NBUTLAST` 
*/
cl_nbutlast(_244958724,_244959150,_245534468):-_246018558=[bv(list,_244958724),bv(n,_244958764)|_244930992],global_env(_244930992),opt_var(_244930992,n,_244958764,true,1,1,_244959150),catch((get_var(_246018558,list,_244977014),_245047926=[bv(sys_e,_244977014),bv(sys_m,0)|_246018558],call_addr_block(_245047926,(push_label(start),get_var(_245047926,sys_e,_245039784),(is_consp(_245039784)->get_var(_245047926,sys_m,_245042604),+(_245042604,1,_245041716),set_var(_245047926,sys_m,_245041716),get_var(_245047926,sys_e,_245045664),cl_cdr(_245045664,_245044794),set_var(_245047926,sys_e,_245044794),goto(start,_245047926),_244992324=_245047678;_244992324=[])),[addr(addr_tagbody_34_start,start,'$unused',_245066882,(get_var(_245066882,sys_e,_245066902),(is_consp(_245066902)->get_var(_245066882,sys_m,_245066942),+(_245066942,1,_245066956),set_var(_245066882,sys_m,_245066956),get_var(_245066882,sys_e,_245066988),cl_cdr(_245066988,_245067010),set_var(_245066882,sys_e,_245067010),goto(start,_245066882),_245067040=_245067046;_245067040=[])))]),get_var(_245047926,n,_245069524),get_var(_245047926,sys_m,_245069068),-(_245069068,_245069524,_245068180),set_var(_245047926,n,_245068180),get_var(_245047926,list,_245074236),set_var(_245047926,sys_e,_245074236),call_addr_block(_245047926,(push_label(start),get_var(_245047926,list,_245121234),(is_consp(_245121234)->_245119700=[];throw(block_exit(nbutlast,[])),_245119700=_245123636),get_var(_245047926,n,_245130512),(_245130512<2->_245076316=[];get_var(_245047926,sys_e,_245133510),cl_cdr(_245133510,_246027792),set_var(_245047926,sys_e,_246027792),get_var(_245047926,n,_245136434),-(_245136434,1,_246028612),set_var(_245047926,n,_246028612),goto(start,_245047926),_245076316=_245138674)),[addr(addr_tagbody_35_start,start,'$unused',_245164328,(get_var(_245164328,list,_245164356),(is_consp(_245164356)->_245164392=[];throw(block_exit(nbutlast,[])),_245164392=_245164410),get_var(_245164328,n,_245164438),(_245164438<2->_245164476=[];get_var(_245164328,sys_e,_245164504),cl_cdr(_245164504,_246239182),set_var(_245164328,sys_e,_246239182),get_var(_245164328,n,_245164558),-(_245164558,1,_246242638),set_var(_245164328,n,_246242638),goto(start,_245164328),_245164476=_245164618)))]),get_var(_245047926,sys_e,_245382780),cl_rplacd(_245382780,[],_245164918),get_var(_245047926,list,_245385352),_245385352=_245534468),block_exit(nbutlast,_245534468),true).
:-set_opv(cl_nbutlast,classof,claz_function),set_opv(nbutlast,compile_as,kw_function),set_opv(nbutlast,function,cl_nbutlast),_244923988=nbutlast.
/*
:-side_effect(assert_lsp(nbutlast,lambda_def(defun,nbutlast,cl_nbutlast,[list,c38_optional,[n,1]],[[let_xx,[[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,list],[tagbody,start,[unless,[consp,list],[return_from,nbutlast,[]]],[unless,[<,n,2],[setf,sys_e,[cdr,sys_e]],[setf,n,[-,n,1]],[go,start]]],[setf,[cdr,sys_e],[]],list]]))).
*/
/*
:-side_effect(assert_lsp(nbutlast,arglist_info(nbutlast,cl_nbutlast,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(nbutlast,init_args(1,cl_nbutlast))).
*/
/*
#+(or WAM-CL LISP500) 
(defun last (list &optional (n 1))
  (let* ((e list)
	 (m 0))
    (tagbody
     start
       (when (consp e)
	 (setf m (+ m 1))
	 (setf e (cdr e))
	 (go start)))
    (setf n (- m n))
    (setf e list)
    (tagbody
     start
       (when (< n 1) (return-from last e))
       (setf e (cdr e))
       (setf n (- n 1))
       (go start))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:67538 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,last,[list,'&optional',[n,1]],['let*',[[e,list],[m,0]],[tagbody,start,[when,[consp,e],[setf,m,[+,m,1]],[setf,e,[cdr,e]],[go,start]]],[setf,n,[-,m,n]],[setf,e,list],[tagbody,start,[when,[<,n,1],['return-from',last,e]],[setf,e,[cdr,e]],[setf,n,[-,n,1]],[go,start]]]]).
wl:lambda_def(defun,last,cl_last,[list,c38_optional,[n,1]],[[let_xx,[[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,list],[tagbody,start,[when,[<,n,1],[return_from,last,sys_e]],[setf,sys_e,[cdr,sys_e]],[setf,n,[-,n,1]],[go,start]]]]).
wl:arglist_info(last,cl_last,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}).
wl:init_args(1,cl_last).

/*

### Compiled:  `CL:LAST` 
*/
cl_last(_247012532,_247012958,_247313282):-_247747000=[bv(list,_247012532),bv(n,_247012572)|_246985592],global_env(_246985592),opt_var(_246985592,n,_247012572,true,1,1,_247012958),catch((get_var(_247747000,list,_247029766),_247100462=[bv(sys_e,_247029766),bv(sys_m,0)|_247747000],call_addr_block(_247100462,(push_label(start),get_var(_247100462,sys_e,_247092320),(is_consp(_247092320)->get_var(_247100462,sys_m,_247095140),+(_247095140,1,_247094252),set_var(_247100462,sys_m,_247094252),get_var(_247100462,sys_e,_247098200),cl_cdr(_247098200,_247097330),set_var(_247100462,sys_e,_247097330),goto(start,_247100462),_247044860=_247100214;_247044860=[])),[addr(addr_tagbody_36_start,start,'$unused',_247119418,(get_var(_247119418,sys_e,_247119438),(is_consp(_247119438)->get_var(_247119418,sys_m,_247119478),+(_247119478,1,_247119492),set_var(_247119418,sys_m,_247119492),get_var(_247119418,sys_e,_247119524),cl_cdr(_247119524,_247119546),set_var(_247119418,sys_e,_247119546),goto(start,_247119418),_247119576=_247119582;_247119576=[])))]),get_var(_247100462,n,_247121844),get_var(_247100462,sys_m,_247121388),-(_247121388,_247121844,_247120500),set_var(_247100462,n,_247120500),get_var(_247100462,list,_247126340),set_var(_247100462,sys_e,_247126340),call_addr_block(_247100462,(push_label(start),get_var(_247100462,n,_247158544),(_247158544<1->get_var(_247100462,sys_e,_247160628),throw(block_exit(last,_247160628)),_247157118=_247160992;_247157118=[]),get_var(_247100462,sys_e,_247169138),cl_cdr(_247169138,_247755794),set_var(_247100462,sys_e,_247755794),get_var(_247100462,n,_247172074),-(_247172074,1,_247756614),set_var(_247100462,n,_247756614),goto(start,_247100462)),[addr(addr_tagbody_37_start,start,'$used',_247186644,(get_var(_247186644,n,_247186672),(_247186672<1->get_var(_247186644,sys_e,_247186724),throw(block_exit(last,_247186724)),_247186754=_247186760;_247186754=[]),get_var(_247186644,sys_e,_247186794),cl_cdr(_247186794,_247947636),set_var(_247186644,sys_e,_247947636),get_var(_247186644,n,_247186848),-(_247186848,1,_247951092),set_var(_247186644,n,_247951092),goto(start,_247186644)))]),[]=_247313282),block_exit(last,_247313282),true).
:-set_opv(cl_last,classof,claz_function),set_opv(last,compile_as,kw_function),set_opv(last,function,cl_last),_246979332=last.
/*
:-side_effect(assert_lsp(last,lambda_def(defun,last,cl_last,[list,c38_optional,[n,1]],[[let_xx,[[sys_e,list],[sys_m,0]],[tagbody,start,[when,[consp,sys_e],[setf,sys_m,[+,sys_m,1]],[setf,sys_e,[cdr,sys_e]],[go,start]]],[setf,n,[-,sys_m,n]],[setf,sys_e,list],[tagbody,start,[when,[<,n,1],[return_from,last,sys_e]],[setf,sys_e,[cdr,sys_e]],[setf,n,[-,n,1]],[go,start]]]]))).
*/
/*
:-side_effect(assert_lsp(last,arglist_info(last,cl_last,[list,c38_optional,[n,1]],arginfo{all:[list,n],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,n],opt:[n],req:[list],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(last,init_args(1,cl_last))).
*/
/*
#+(or WAM-CL LISP500) 
(defun ldiff (list object)
  (let* ((r (cons nil nil))
	 (e r))
    (tagbody
     start
       (unless (or (eq object list) (atom list))
	 (setf e (setf (cdr e) (cons (car list) nil)))
	 (setf list (cdr list))
	 (go start)))
    (cdr r)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:67918 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,ldiff,[list,object],['let*',[[r,[cons,[],[]]],[e,r]],[tagbody,start,[unless,[or,[eq,object,list],[atom,list]],[setf,e,[setf,[cdr,e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[go,start]]],[cdr,r]]]).
/*
:- side_effect((compile_each($, _248704630, [], [], true), append([sys_e], [CAR19, CAR], [sys_e, CAR19, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, _248704630, [], [], true), append([sys_e], [CAR19, CAR], [sys_e, CAR19, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, _248704630, [], [], true), append([sys_e], [CAR19, CAR], [sys_e, CAR19, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, _248704630, [], [], true), append([sys_e], [CAR19, CAR], [sys_e, CAR19, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:-side_effect((compile_each($,_248671378,[],[],true),append([sys_e],[_249002234,_249002062],[sys_e,_249002234,_249002062]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_248671378,[],[],true),append([sys_e],[_249034076,_249033904],[sys_e,_249034076,_249033904]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_248671378,[],[],true),append([sys_e],[_249066044,_249065872],[sys_e,_249066044,_249065872]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_248671378,[],[],true),append([sys_e],[_249098040,_249097868],[sys_e,_249098040,_249097868]),setf_inverse_op(cdr,rplacd))).
*/
wl:lambda_def(defun,ldiff,cl_ldiff,[list,sys_object],[[let_xx,[[sys_r,[cons,[],[]]],[sys_e,sys_r]],[tagbody,start,[unless,[or,[eq,sys_object,list],[atom,list]],[setf,sys_e,[setf,[cdr,sys_e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[go,start]]],[cdr,sys_r]]]).
wl:arglist_info(ldiff,cl_ldiff,[list,sys_object],arginfo{all:[list,sys_object],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,sys_object],opt:0,req:[list,sys_object],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,cl_ldiff).

/*

### Compiled:  `CL:LDIFF` 
*/
cl_ldiff(_248656884,_248656918,_249247604):-_249590292=[bv(list,_248656884),bv(sys_object,_248656918)|_248632032],global_env(_248632032),catch((_248672944=[[]],get_var(_249590292,sys_r,_248694670),_249126686=[bv(sys_r,_248672944),bv(sys_e,_248694670)|_249590292],call_addr_block(_249126686,(push_label(start),(get_var(_249126686,list,_248980988),get_var(_249126686,sys_object,_248979752),cl_eq(_248979752,_248980988,_248984608),_248984608\==[],_248978150=_248984608->true;get_var(_249126686,list,_248983250),cl_atom(_248983250,_248982396),_248978150=_248982396),(_248978150\==[]->_248704220=[];get_var(_249126686,list,_249117812),get_var(_249126686,sys_e,_249116330),cl_car(_249117812,_249116958),_249116884=[_249116958],cl_rplacd(_249116330,_249116884,_248987866),set_var(_249126686,sys_e,_248987866),get_var(_249126686,list,_249124358),cl_cdr(_249124358,_249123362),set_var(_249126686,list,_249123362),goto(start,_249126686),_248704220=_249126438)),[addr(addr_tagbody_38_start,start,'$unused',_249159976,((get_var(_249159976,list,_249160024),get_var(_249159976,sys_object,_249160010),cl_eq(_249160010,_249160024,_249160038),_249160038\==[],_249160060=_249160038->true;get_var(_249159976,list,_249160088),cl_atom(_249160088,_249750372),_249160060=_249750372),(_249160060\==[]->_249160138=[];get_var(_249159976,list,_249160186),get_var(_249159976,sys_e,_249160158),cl_car(_249160186,_249754618),_249160218=[_249754618],cl_rplacd(_249160158,_249160218,_249160240),set_var(_249159976,sys_e,_249160240),get_var(_249159976,list,_249160272),cl_cdr(_249160272,_249160294),set_var(_249159976,list,_249160294),goto(start,_249159976),_249160138=_249160330)))]),get_var(_249126686,sys_r,_249161232),cl_cdr(_249161232,_248668306),_248668306=_249247604),block_exit(ldiff,_249247604),true).
:-set_opv(cl_ldiff,classof,claz_function),set_opv(ldiff,compile_as,kw_function),set_opv(ldiff,function,cl_ldiff),_248627340=ldiff.
/*
:-side_effect(assert_lsp(ldiff,lambda_def(defun,ldiff,cl_ldiff,[list,sys_object],[[let_xx,[[sys_r,[cons,[],[]]],[sys_e,sys_r]],[tagbody,start,[unless,[or,[eq,sys_object,list],[atom,list]],[setf,sys_e,[setf,[cdr,sys_e],[cons,[car,list],[]]]],[setf,list,[cdr,list]],[go,start]]],[cdr,sys_r]]]))).
*/
/*
:-side_effect(assert_lsp(ldiff,arglist_info(ldiff,cl_ldiff,[list,sys_object],arginfo{all:[list,sys_object],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[list,sys_object],opt:0,req:[list,sys_object],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(ldiff,init_args(exact_only,cl_ldiff))).
*/
/*
#+(or WAM-CL LISP500) 
(defun tailp (object list)
  (tagbody
   start
     (when (eq object list) (return-from tailp t))
     (unless (consp list) (return-from tailp nil))
     (setf list (cdr list))
     (go start)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:68193 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,tailp,[object,list],[tagbody,start,[when,[eq,object,list],['return-from',tailp,t]],[unless,[consp,list],['return-from',tailp,[]]],[setf,list,[cdr,list]],[go,start]]]).
wl:lambda_def(defun, tailp, cl_tailp, [sys_object, list], [[tagbody, start, [when, [eq, sys_object, list], [return_from, tailp, t]], [unless, [consp, list], [return_from, tailp, []]], [setf, list, [cdr, list]], [go, start]]]).
wl:arglist_info(tailp, cl_tailp, [sys_object, list], arginfo{all:[sys_object, list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object, list], opt:0, req:[sys_object, list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_tailp).

/*

### Compiled:  `CL:TAILP` 
*/
cl_tailp(Object_In, List_In, FnResult) :-
	BlockExitEnv=[bv(sys_object, Object_In), bv(list, List_In)|Env],
	global_env(Env),
	catch(( call_addr_block(BlockExitEnv,
				(push_label(start), get_var(BlockExitEnv, list, List_Get29), get_var(BlockExitEnv, sys_object, Object_Get28), (is_eq(Object_Get28, List_Get29)->throw(block_exit(tailp, t)), _250427470=ThrowResult34;_250427470=[]), get_var(BlockExitEnv, list, List_Get38), (is_consp(List_Get38)->_250438786=[];throw(block_exit(tailp, [])), _250438786=ThrowResult42), get_var(BlockExitEnv, list, List_Get45), cl_cdr(List_Get45, List), set_var(BlockExitEnv, list, List), goto(start, BlockExitEnv)),
				
				[ addr(addr_tagbody_39_start,
				       start,
				       '$used',
				       BlockExitEnv,
				       (get_var(BlockExitEnv, list, List_Get), get_var(BlockExitEnv, sys_object, Object_Get), (is_eq(Object_Get, List_Get)->throw(block_exit(tailp, t)), _250464762=ThrowResult;_250464762=[]), get_var(BlockExitEnv, list, List_Get17), (is_consp(List_Get17)->_250464838=[];throw(block_exit(tailp, [])), _250464838=ThrowResult21), get_var(BlockExitEnv, list, List_Get23), cl_cdr(List_Get23, Cdr_Ret), set_var(BlockExitEnv, list, Cdr_Ret), goto(start, BlockExitEnv)))
				]),
		[]=FnResult
	      ),
	      block_exit(tailp, FnResult),
	      true).
:- set_opv(cl_tailp, classof, claz_function),
   set_opv(tailp, compile_as, kw_function),
   set_opv(tailp, function, cl_tailp),
   DefunResult=tailp.
/*
:- side_effect(assert_lsp(tailp,
			  lambda_def(defun,
				     tailp,
				     cl_tailp,
				     [sys_object, list],
				     
				     [ 
				       [ tagbody,
					 start,
					 
					 [ when,
					   [eq, sys_object, list],
					   [return_from, tailp, t]
					 ],
					 
					 [ unless,
					   [consp, list],
					   [return_from, tailp, []]
					 ],
					 [setf, list, [cdr, list]],
					 [go, start]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(tailp,
			  arglist_info(tailp,
				       cl_tailp,
				       [sys_object, list],
				       arginfo{ all:[sys_object, list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_object, list],
						opt:0,
						req:[sys_object, list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(tailp, init_args(exact_only, cl_tailp))).
*/
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun nthcdr (n list) (if (< n 1) list (nthcdr (- n 1) (cdr list))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:68421 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,nthcdr,[n,list],[if,[<,n,1],list,[nthcdr,[-,n,1],[cdr,list]]]]]]))
/*
#+(or WAM-CL LISP500) 
(defun rest (list) (cdr list))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:68531 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,rest,[list],[cdr,list]]).
wl:lambda_def(defun, rest, cl_rest, [list], [[cdr, list]]).
wl:arglist_info(rest, cl_rest, [list], arginfo{all:[list], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[list], opt:0, req:[list], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_rest).

/*

### Compiled:  `CL:REST` 
*/
cl_rest(List_In, FnResult) :-
	Env7=[bv(list, List_In)|Env],
	global_env(Env),
	catch(( get_var(Env7, list, List_Get),
		cl_cdr(List_Get, Cdr_Ret),
		Cdr_Ret=FnResult
	      ),
	      block_exit(rest, FnResult),
	      true).
:- set_opv(cl_rest, classof, claz_function),
   set_opv(rest, compile_as, kw_function),
   set_opv(rest, function, cl_rest),
   DefunResult=rest.
/*
:- side_effect(assert_lsp(rest,
			  lambda_def(defun, rest, cl_rest, [list], [[cdr, list]]))).
*/
/*
:- side_effect(assert_lsp(rest,
			  arglist_info(rest,
				       cl_rest,
				       [list],
				       arginfo{ all:[list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[list],
						opt:0,
						req:[list],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(rest, init_args(exact_only, cl_rest))).
*/
/*
#+(or WAM-CL LISP500) 
(labels ((all-end (lists)
	   (dolist (elem lists nil)
	     (unless elem (return-from all-end t))))
	 (all-car (lists)
	   (when lists (cons (caar lists) (all-car (cdr lists)))))
	 (all-cdr (lists)
	   (when lists (cons (cdar lists) (all-cdr (cdr lists))))))
  (defun mapc (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapc list-1))
	 (apply function (all-car lists))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapcar (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from mapcar result))
	 (let ((cons (cons (apply function (all-car lists)) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun mapl (function &rest lists)
    (let ((list-1 (car lists)))
      (tagbody
       start
	 (when (all-end lists) (return-from mapl list-1))
	 (apply function lists)
	 (setf lists (all-cdr lists))
	 (go start))))
  (defun maplist (function &rest lists)
    (let ((result nil)
	  (end nil))
      (tagbody
       start
	 (when (all-end lists) (return-from maplist result))
	 (let ((cons (cons (apply function lists) nil)))
	   (setf end (if end (setf (cdr end) cons) (setf result cons))))
	 (setf lists (all-cdr lists))
	 (go start)))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:68591 **********************/
:-lisp_compile_to_prolog(pkg_sys,[labels,[['all-end',[lists],[dolist,[elem,lists,[]],[unless,elem,['return-from','all-end',t]]]],['all-car',[lists],[when,lists,[cons,[caar,lists],['all-car',[cdr,lists]]]]],['all-cdr',[lists],[when,lists,[cons,[cdar,lists],['all-cdr',[cdr,lists]]]]]],[defun,mapc,[function,'&rest',lists],[let,[['list-1',[car,lists]]],[tagbody,start,[when,['all-end',lists],['return-from',mapc,'list-1']],[apply,function,['all-car',lists]],[setf,lists,['all-cdr',lists]],[go,start]]]],[defun,mapcar,[function,'&rest',lists],[let,[[result,[]],[end,[]]],[tagbody,start,[when,['all-end',lists],['return-from',mapcar,result]],[let,[[cons,[cons,[apply,function,['all-car',lists]],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,result,cons]]]],[setf,lists,['all-cdr',lists]],[go,start]]]],[defun,mapl,[function,'&rest',lists],[let,[['list-1',[car,lists]]],[tagbody,start,[when,['all-end',lists],['return-from',mapl,'list-1']],[apply,function,lists],[setf,lists,['all-cdr',lists]],[go,start]]]],[defun,maplist,[function,'&rest',lists],[let,[[result,[]],[end,[]]],[tagbody,start,[when,['all-end',lists],['return-from',maplist,result]],[let,[[cons,[cons,[apply,function,lists],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,result,cons]]]],[setf,lists,['all-cdr',lists]],[go,start]]]]]).
/*
:- side_effect((compile_each($, LEnv91, [], [], true), append([end], [CAR97, CAR], [end, CAR97, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, LEnv91, [], [], true), append([end], [CAR97, CAR], [end, CAR97, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv91, [], [], true), append([end], [CAR97, CAR], [end, CAR97, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv91, [], [], true), append([end], [CAR97, CAR], [end, CAR97, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:-side_effect((compile_each($,_252929364,[],[],true),append([end],[_252955760,_252955588],[end,_252955760,_252955588]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_252929364,[],[],true),append([end],[_252987602,_252987430],[end,_252987602,_252987430]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_252929364,[],[],true),append([end],[_253019570,_253019398],[end,_253019570,_253019398]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_252929364,[],[],true),append([end],[_253051566,_253051394],[end,_253051566,_253051394]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_253554298,[],[],true),append([end],[_253597412,_253597240],[end,_253597412,_253597240]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_253554298,[],[],true),append([end],[_253629254,_253629082],[end,_253629254,_253629082]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_253554298,[],[],true),append([end],[_253661222,_253661050],[end,_253661222,_253661050]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_253554298,[],[],true),append([end],[_253693218,_253693046],[end,_253693218,_253693046]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_253776870,[],[],true),append([end],[_253802578,_253802406],[end,_253802578,_253802406]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_253776870,[],[],true),append([end],[_253834420,_253834248],[end,_253834420,_253834248]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_253776870,[],[],true),append([end],[_253866388,_253866216],[end,_253866388,_253866216]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_253776870,[],[],true),append([end],[_253898384,_253898212],[end,_253898384,_253898212]),setf_inverse_op(cdr,rplacd))).
*/
wl:lambda_def(defun,sys_all_end,f_sys_all_end1,[sys_lists],[[dolist,[sys_elem,sys_lists,[]],[unless,sys_elem,[return_from,sys_all_end,t]]]]).
wl:arglist_info(sys_all_end,f_sys_all_end1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_all_end1).

/*

### Compiled:  `SYS::ALL-END` 
*/
f_sys_all_end1(_252117104,_252186904):-_255798626=[bv(sys_lists,_252117104)|_252097844],global_env(_252097844),catch((_252128366=[bv([],[])|_255798626],get_var(_252128366,sys_lists,_252158340),_252157650=bv(sys_elem,_252157996),_252157970=[_252157650|_252128366],forall(member(_252157996,_252158340),(nb_setarg(2,_252157650,_252157996),get_var(_252157970,sys_elem,_252138322),(_252138322\==[]->_252135616=[];throw(block_exit(sys_all_end,t)),_252135616=_252150990))),[]=_252186904),block_exit(sys_all_end,_252186904),true).
wl:lambda_def(defun,sys_all_car,f_sys_all_car1,[sys_lists],[[when,sys_lists,[cons,[caar,sys_lists],[sys_all_car,[cdr,sys_lists]]]]]).
wl:arglist_info(sys_all_car,f_sys_all_car1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_all_car1).

/*

### Compiled:  `SYS::ALL-CAR` 
*/
f_sys_all_car1(_252201822,_252200920):-_255808678=[bv(sys_lists,_252201822)|_252097844],global_env(_252097844),catch((get_var(_255808678,sys_lists,_252203980),(_252203980\==[]->get_var(_255808678,sys_lists,_252207178),cl_caar(_252207178,_252206282),get_var(_255808678,sys_lists,_252209278),cl_cdr(_252209278,_252208330),f_sys_all_car(_252208330,_252208262),_252205970=[_252206282|_252208262],_252202530=_252205970;_252202530=[]),_252202530=_252200920),block_exit(sys_all_car,_252200920),true).
wl:lambda_def(defun,sys_all_cdr,f_sys_all_cdr1,[sys_lists],[[when,sys_lists,[cons,[cdar,sys_lists],[sys_all_cdr,[cdr,sys_lists]]]]]).
wl:arglist_info(sys_all_cdr,f_sys_all_cdr1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_all_cdr1).

/*

### Compiled:  `SYS::ALL-CDR` 
*/
f_sys_all_cdr1(_252244152,_252243226):-_255818312=[bv(sys_lists,_252244152)|_252097844],global_env(_252097844),catch((get_var(_255818312,sys_lists,_252246310),(_252246310\==[]->get_var(_255818312,sys_lists,_252249532),cl_cdar(_252249532,_252248636),get_var(_255818312,sys_lists,_252251656),cl_cdr(_252251656,_252250708),f_sys_all_cdr(_252250708,_252250640),_252258332=[_252248636|_252250640],_252244860=_252258332;_252244860=[]),_252244860=_252243226),block_exit(sys_all_cdr,_252243226),true).
wl:lambda_def(defun,mapc,cl_mapc,[function,c38_rest,sys_lists],[[let,[[sys_list_1,[car,sys_lists]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapc,sys_list_1]],[apply,function,[sys_all_car,sys_lists]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]]).
wl:arglist_info(mapc,cl_mapc,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0}).
wl:init_args(1,cl_mapc).

/*

### Compiled:  `CL:MAPC` 
*/
cl_mapc(_252338032,_252339720,_252337394):-_255831474=[bv(function,_252338032),bv(sys_lists,_252339720)|_252097844],global_env(_252097844),catch((get_var(_255831474,sys_lists,_252345498),cl_car(_252345498,_252344550),_252344246=[bv(sys_list_1,_252344550)|_255831474],call_addr_block(_252344246,(push_label(start),get_var(_252344246,sys_lists,_252401086),f_sys_all_end1(_252401086,_252399726),(_252399726\==[]->get_var(_252344246,sys_list_1,_252403090),throw(block_exit(mapc,_252403090)),_252399174=_252403454;_252399174=[]),cl_function([sys_all_car,sys_lists],_252411216),get_var(_252344246,sys_lists,_252413692),f_sys_all_cdr1(_252413692,_252412654),set_var(_252344246,sys_lists,_252412654),goto(start,_252344246)),[addr(addr_tagbody_40_start,start,'$used',_252427678,(get_var(_252427678,sys_lists,_252427706),f_sys_all_end1(_252427706,_252427732),(_252427732\==[]->get_var(_252427678,sys_list_1,_252427784),throw(block_exit(mapc,_252427784)),_252427814=_252427820;_252427814=[]),cl_function([sys_all_car,sys_lists],_256498310),get_var(_252427678,sys_lists,_252427866),f_sys_all_cdr1(_252427866,_252427888),set_var(_252427678,sys_lists,_252427888),goto(start,_252427678)))]),[]=_252337394),block_exit(mapc,_252337394),true).
:-set_opv(cl_mapc,classof,claz_function),set_opv(mapc,compile_as,kw_function),set_opv(mapc,function,cl_mapc),_252315500=mapc,assert_lsp(mapcar,wl:lambda_def(defun,mapcar,cl_mapcar,[function,c38_rest,sys_lists],[[let,[[sys_result,[]],[end,[]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapcar,sys_result]],[let,[[cons,[cons,[apply,function,[sys_all_car,sys_lists]],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,sys_result,cons]]]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]])),assert_lsp(mapcar,wl:arglist_info(mapcar,cl_mapcar,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0})),assert_lsp(mapcar,wl:init_args(1,cl_mapcar)),assert_lsp(mapcar,(cl_mapcar(_252554890,_252553662,_252553328):-_255851068=[bv(function,_252554890),bv(sys_lists,_252553662)|_252097844],global_env(_252097844),catch((_252561952=[bv(sys_result,[]),bv(end,[])|_255851068],call_addr_block(_252561952,(push_label(start),get_var(_252561952,sys_lists,_252917070),f_sys_all_end1(_252917070,_252915710),(_252915710\==[]->get_var(_252561952,sys_result,_252919068),throw(block_exit(mapcar,_252919068)),_252915158=_252919432;_252915158=[]),cl_function([sys_all_car,sys_lists],_256522832),_252938442=[_256522832],_252929364=[bv(cons,_252938442)|_252561952],get_var(_252929364,end,_252939880),(_252939880\==[]->get_var(_252929364,cons,_253071186),get_var(_252929364,end,_253069940),cl_rplacd(_253069940,_253071186,_253075214),_252929152=_253075214;get_var(_252929364,cons,_253073924),set_var(_252929364,sys_result,_253073924),_252929152=_253073924),set_var(_252929364,end,_252929152),get_var(_252561952,sys_lists,_253090428),f_sys_all_cdr1(_253090428,_255858086),set_var(_252561952,sys_lists,_255858086),goto(start,_252561952)),[addr(addr_tagbody_41_start,start,'$used',_253117354,(get_var(_253117354,sys_lists,_253117382),f_sys_all_end1(_253117382,_253117408),(_253117408\==[]->get_var(_253117354,sys_result,_253117460),throw(block_exit(mapcar,_253117460)),_253117490=_253117496;_253117490=[]),cl_function([sys_all_car,sys_lists],_256540614),_253117534=[_256540614],_253117558=[bv(cons,_253117534)|_253117354],get_var(_253117558,end,_253117598),(_253117598\==[]->get_var(_253117558,cons,_253117682),get_var(_253117558,end,_253117650),cl_rplacd(_253117650,_253117682,_253117700),_253117720=_253117700;get_var(_253117558,cons,_253117748),set_var(_253117558,sys_result,_253117748),_253117720=_253117748),set_var(_253117558,end,_253117720),get_var(_253117354,sys_lists,_253117810),f_sys_all_cdr1(_253117810,_256552526),set_var(_253117354,sys_lists,_256552526),goto(start,_253117354)))]),[]=_252553328),block_exit(mapcar,_252553328),true))),set_opv(cl_mapcar,classof,claz_function),set_opv(mapcar,compile_as,kw_function),set_opv(mapcar,function,cl_mapcar),_253257582=mapcar,assert_lsp(mapl,wl:lambda_def(defun,mapl,cl_mapl,[function,c38_rest,sys_lists],[[let,[[sys_list_1,[car,sys_lists]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapl,sys_list_1]],[apply,function,sys_lists],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]])),assert_lsp(mapl,wl:arglist_info(mapl,cl_mapl,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0})),assert_lsp(mapl,wl:init_args(1,cl_mapl)),assert_lsp(mapl,(cl_mapl(_253314568,_253313340,_253313006):-_255869764=[bv(function,_253314568),bv(sys_lists,_253313340)|_252097844],global_env(_252097844),catch((get_var(_255869764,sys_lists,_253320984),cl_car(_253320984,_253328282),_253319732=[bv(sys_list_1,_253328282)|_255869764],call_addr_block(_253319732,(push_label(start),get_var(_253319732,sys_lists,_253375436),f_sys_all_end1(_253375436,_253374076),(_253374076\==[]->get_var(_253319732,sys_list_1,_253377440),throw(block_exit(mapl,_253377440)),_253373524=_253377804;_253373524=[]),cl_function(sys_lists,_256575988),get_var(_253319732,sys_lists,_253387662),f_sys_all_cdr1(_253387662,_255874084),set_var(_253319732,sys_lists,_255874084),goto(start,_253319732)),[addr(addr_tagbody_42_start,start,'$used',_253400500,(get_var(_253400500,sys_lists,_253400528),f_sys_all_end1(_253400528,_253400554),(_253400554\==[]->get_var(_253400500,sys_list_1,_253400606),throw(block_exit(mapl,_253400606)),_253400636=_253400642;_253400636=[]),cl_function(sys_lists,_256585202),get_var(_253400500,sys_lists,_253400688),f_sys_all_cdr1(_253400688,_256587384),set_var(_253400500,sys_lists,_256587384),goto(start,_253400500)))]),[]=_253313006),block_exit(mapl,_253313006),true))),set_opv(cl_mapl,classof,claz_function),set_opv(mapl,compile_as,kw_function),set_opv(mapl,function,cl_mapl),_253473654=mapl,assert_lsp(maplist,wl:lambda_def(defun,maplist,cl_maplist,[function,c38_rest,sys_lists],[[let,[[sys_result,[]],[end,[]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,maplist,sys_result]],[let,[[cons,[cons,[apply,function,sys_lists],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,sys_result,cons]]]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]])),assert_lsp(maplist,wl:arglist_info(maplist,cl_maplist,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0})),assert_lsp(maplist,wl:init_args(1,cl_maplist)),assert_lsp(maplist,(cl_maplist(_253518994,_253517766,_253517432):-_255888862=[bv(function,_253518994),bv(sys_lists,_253517766)|_252097844],global_env(_252097844),catch((_253525958=[bv(sys_result,[]),bv(end,[])|_255888862],call_addr_block(_253525958,(push_label(start),get_var(_253525958,sys_lists,_253764648),f_sys_all_end1(_253764648,_253763288),(_253763288\==[]->get_var(_253525958,sys_result,_253766646),throw(block_exit(maplist,_253766646)),_253762736=_253767010;_253762736=[]),cl_function(sys_lists,_256609734),_253785260=[_256609734],_253776870=[bv(cons,_253785260)|_253525958],get_var(_253776870,end,_253786698),(_253786698\==[]->get_var(_253776870,cons,_253918004),get_var(_253776870,end,_253916758),cl_rplacd(_253916758,_253918004,_253922032),_253776658=_253922032;get_var(_253776870,cons,_253920742),set_var(_253776870,sys_result,_253920742),_253776658=_253920742),set_var(_253776870,end,_253776658),get_var(_253525958,sys_lists,_253936938),f_sys_all_cdr1(_253936938,_255895632),set_var(_253525958,sys_lists,_255895632),goto(start,_253525958)),[addr(addr_tagbody_43_start,start,'$used',_253962632,(get_var(_253962632,sys_lists,_253962660),f_sys_all_end1(_253962660,_253962686),(_253962686\==[]->get_var(_253962632,sys_result,_253962738),throw(block_exit(maplist,_253962738)),_253962768=_253962774;_253962768=[]),cl_function(sys_lists,_256627516),_253962818=[_256627516],_253962850=[bv(cons,_253962818)|_253962632],get_var(_253962850,end,_253962890),(_253962890\==[]->get_var(_253962850,cons,_253962978),get_var(_253962850,end,_253962942),cl_rplacd(_253962942,_253962978,_253963006),_253963026=_253963006;get_var(_253962850,cons,_253963054),set_var(_253962850,sys_result,_253963054),_253963026=_253963054),set_var(_253962850,end,_253963026),get_var(_253962632,sys_lists,_253963116),f_sys_all_cdr1(_253963116,_256638266),set_var(_253962632,sys_lists,_256638266),goto(start,_253962632)))]),[]=_253517432),block_exit(maplist,_253517432),true))),set_opv(cl_maplist,classof,claz_function),set_opv(maplist,compile_as,kw_function),set_opv(maplist,function,cl_maplist),_254097036=maplist.
/*
:-side_effect(assert_lsp(sys_all_end,lambda_def(defun,sys_all_end,f_sys_all_end1,[sys_lists],[[dolist,[sys_elem,sys_lists,[]],[unless,sys_elem,[return_from,sys_all_end,t]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_all_end,arglist_info(sys_all_end,f_sys_all_end1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_all_end,init_args(exact_only,f_sys_all_end1))).
*/
/*
:-side_effect(assert_lsp(sys_all_car,lambda_def(defun,sys_all_car,f_sys_all_car1,[sys_lists],[[when,sys_lists,[cons,[caar,sys_lists],[sys_all_car,[cdr,sys_lists]]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_all_car,arglist_info(sys_all_car,f_sys_all_car1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_all_car,init_args(exact_only,f_sys_all_car1))).
*/
/*
:-side_effect(assert_lsp(sys_all_cdr,lambda_def(defun,sys_all_cdr,f_sys_all_cdr1,[sys_lists],[[when,sys_lists,[cons,[cdar,sys_lists],[sys_all_cdr,[cdr,sys_lists]]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_all_cdr,arglist_info(sys_all_cdr,f_sys_all_cdr1,[sys_lists],arginfo{all:[sys_lists],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_lists],opt:0,req:[sys_lists],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_all_cdr,init_args(exact_only,f_sys_all_cdr1))).
*/
/*
:-side_effect(assert_lsp(mapc,lambda_def(defun,mapc,cl_mapc,[function,c38_rest,sys_lists],[[let,[[sys_list_1,[car,sys_lists]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapc,sys_list_1]],[apply,function,[sys_all_car,sys_lists]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]]))).
*/
/*
:-side_effect(assert_lsp(mapc,arglist_info(mapc,cl_mapc,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(mapc,init_args(1,cl_mapc))).
*/
/*
:-side_effect(assert_lsp(mapcar,lambda_def(defun,mapcar,cl_mapcar,[function,c38_rest,sys_lists],[[let,[[sys_result,[]],[end,[]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapcar,sys_result]],[let,[[cons,[cons,[apply,function,[sys_all_car,sys_lists]],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,sys_result,cons]]]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]]))).
*/
/*
:-side_effect(assert_lsp(mapcar,arglist_info(mapcar,cl_mapcar,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(mapcar,init_args(1,cl_mapcar))).
*/
/*
:-side_effect(assert_lsp(mapl,lambda_def(defun,mapl,cl_mapl,[function,c38_rest,sys_lists],[[let,[[sys_list_1,[car,sys_lists]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,mapl,sys_list_1]],[apply,function,sys_lists],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]]))).
*/
/*
:-side_effect(assert_lsp(mapl,arglist_info(mapl,cl_mapl,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(mapl,init_args(1,cl_mapl))).
*/
/*
:-side_effect(assert_lsp(maplist,lambda_def(defun,maplist,cl_maplist,[function,c38_rest,sys_lists],[[let,[[sys_result,[]],[end,[]]],[tagbody,start,[when,[sys_all_end,sys_lists],[return_from,maplist,sys_result]],[let,[[cons,[cons,[apply,function,sys_lists],[]]]],[setf,end,[if,end,[setf,[cdr,end],cons],[setf,sys_result,cons]]]],[setf,sys_lists,[sys_all_cdr,sys_lists]],[go,start]]]]))).
*/
/*
:-side_effect(assert_lsp(maplist,arglist_info(maplist,cl_maplist,[function,c38_rest,sys_lists],arginfo{all:[function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sys_lists],opt:0,req:[function],rest:[sys_lists],sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(maplist,init_args(1,cl_maplist))).
*/
/*
#+(or WAM-CL LISP500) 
(defun mapcan (function &rest lists)
  (apply #'nconc (apply #'mapcar function lists)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70027 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,mapcan,[function,'&rest',lists],[apply,function(nconc),[apply,function(mapcar),function,lists]]]).
wl:lambda_def(defun, mapcan, cl_mapcan, [function, c38_rest, sys_lists], [[apply, function(nconc), [apply, function(mapcar), function, sys_lists]]]).
wl:arglist_info(mapcan, cl_mapcan, [function, c38_rest, sys_lists], arginfo{all:[function], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[function, sys_lists], opt:0, req:[function], rest:[sys_lists], sublists:0, whole:0}).
wl: init_args(1, cl_mapcan).

/*

### Compiled:  `CL:MAPCAN` 
*/
cl_mapcan(Function_In, RestNKeys, FnResult) :-
	Env9=[bv(function, Function_In), bv(sys_lists, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env9, sys_lists, Lists_Get),
		cl_mapcar(function, Lists_Get, Nconc_Param),
		cl_nconc(Nconc_Param, Nconc_Ret),
		Nconc_Ret=FnResult
	      ),
	      block_exit(mapcan, FnResult),
	      true).
:- set_opv(cl_mapcan, classof, claz_function),
   set_opv(mapcan, compile_as, kw_function),
   set_opv(mapcan, function, cl_mapcan),
   DefunResult=mapcan.
/*
:- side_effect(assert_lsp(mapcan,
			  lambda_def(defun,
				     mapcan,
				     cl_mapcan,
				     [function, c38_rest, sys_lists],
				     
				     [ 
				       [ apply,
					 function(nconc),
					 
					 [ apply,
					   function(mapcar),
					   function,
					   sys_lists
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(mapcan,
			  arglist_info(mapcan,
				       cl_mapcan,
				       [function, c38_rest, sys_lists],
				       arginfo{ all:[function],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[function, sys_lists],
						opt:0,
						req:[function],
						rest:[sys_lists],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(mapcan, init_args(1, cl_mapcan))).
*/
/*
#+(or WAM-CL LISP500) 
(defun mapcon (function &rest lists)
  (apply #'nconc (apply #'maplist function lists)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70143 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,mapcon,[function,'&rest',lists],[apply,function(nconc),[apply,function(maplist),function,lists]]]).
wl:lambda_def(defun, mapcon, cl_mapcon, [function, c38_rest, sys_lists], [[apply, function(nconc), [apply, function(maplist), function, sys_lists]]]).
wl:arglist_info(mapcon, cl_mapcon, [function, c38_rest, sys_lists], arginfo{all:[function], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[function, sys_lists], opt:0, req:[function], rest:[sys_lists], sublists:0, whole:0}).
wl: init_args(1, cl_mapcon).

/*

### Compiled:  `CL:MAPCON` 
*/
cl_mapcon(Function_In, RestNKeys, FnResult) :-
	Env9=[bv(function, Function_In), bv(sys_lists, RestNKeys)|Env],
	global_env(Env),
	catch(( get_var(Env9, sys_lists, Lists_Get),
		cl_maplist(function, Lists_Get, Nconc_Param),
		cl_nconc(Nconc_Param, Nconc_Ret),
		Nconc_Ret=FnResult
	      ),
	      block_exit(mapcon, FnResult),
	      true).
:- set_opv(cl_mapcon, classof, claz_function),
   set_opv(mapcon, compile_as, kw_function),
   set_opv(mapcon, function, cl_mapcon),
   DefunResult=mapcon.
/*
:- side_effect(assert_lsp(mapcon,
			  lambda_def(defun,
				     mapcon,
				     cl_mapcon,
				     [function, c38_rest, sys_lists],
				     
				     [ 
				       [ apply,
					 function(nconc),
					 
					 [ apply,
					   function(maplist),
					   function,
					   sys_lists
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(mapcon,
			  arglist_info(mapcon,
				       cl_mapcon,
				       [function, c38_rest, sys_lists],
				       arginfo{ all:[function],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:[function, sys_lists],
						opt:0,
						req:[function],
						rest:[sys_lists],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(mapcon, init_args(1, cl_mapcon))).
*/
/*
#+(or WAM-CL LISP500) 
(defun acons (key datum alist) (cons (cons key datum) alist))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70260 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,acons,[key,datum,alist],[cons,[cons,key,datum],alist]]).
wl:lambda_def(defun, acons, cl_acons, [key, sys_datum, sys_alist], [[cons, [cons, key, sys_datum], sys_alist]]).
wl:arglist_info(acons, cl_acons, [key, sys_datum, sys_alist], arginfo{all:[key, sys_datum, sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[key, sys_datum, sys_alist], opt:0, req:[key, sys_datum, sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_acons).

/*

### Compiled:  `CL:ACONS` 
*/
cl_acons(Key_In, Datum_In, Alist_In, FnResult) :-
	Env11=[bv(key, Key_In), bv(sys_datum, Datum_In), bv(sys_alist, Alist_In)|Env],
	global_env(Env),
	catch(( get_var(Env11, key, Key_Get),
		get_var(Env11, sys_datum, Datum_Get),
		CAR=[Key_Get|Datum_Get],
		get_var(Env11, sys_alist, Alist_Get),
		_259902052=[CAR|Alist_Get],
		_259902052=FnResult
	      ),
	      block_exit(acons, FnResult),
	      true).
:- set_opv(cl_acons, classof, claz_function),
   set_opv(acons, compile_as, kw_function),
   set_opv(acons, function, cl_acons),
   DefunResult=acons.
/*
:- side_effect(assert_lsp(acons,
			  lambda_def(defun,
				     acons,
				     cl_acons,
				     [key, sys_datum, sys_alist],
				     [[cons, [cons, key, sys_datum], sys_alist]]))).
*/
/*
:- side_effect(assert_lsp(acons,
			  arglist_info(acons,
				       cl_acons,
				       [key, sys_datum, sys_alist],
				       arginfo{ all:[key, sys_datum, sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ key,
							sys_datum,
							sys_alist
						      ],
						opt:0,
						req:[key, sys_datum, sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(acons, init_args(exact_only, cl_acons))).
*/
/*
#+(or WAM-CL LISP500) 
(defun copy-alist (alist)
  (when alist (cons (if (consp (car alist))
			(cons (caar alist) (cdar alist))
			(car alist))
		    (copy-alist (cdr alist)))))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70349 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'copy-alist',[alist],[when,alist,[cons,[if,[consp,[car,alist]],[cons,[caar,alist],[cdar,alist]],[car,alist]],['copy-alist',[cdr,alist]]]]]).
wl:lambda_def(defun, copy_alist, cl_copy_alist, [sys_alist], [[when, sys_alist, [cons, [if, [consp, [car, sys_alist]], [cons, [caar, sys_alist], [cdar, sys_alist]], [car, sys_alist]], [copy_alist, [cdr, sys_alist]]]]]).
wl:arglist_info(copy_alist, cl_copy_alist, [sys_alist], arginfo{all:[sys_alist], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_alist], opt:0, req:[sys_alist], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_copy_alist).

/*

### Compiled:  `CL:COPY-ALIST` 
*/
cl_copy_alist(Alist_In, FnResult) :-
	Env20=[bv(sys_alist, Alist_In)|Env],
	global_env(Env),
	catch(( get_var(Env20, sys_alist, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env20, sys_alist, Alist_Get8),
		    cl_car(Alist_Get8, PredArgResult),
		    (   is_consp(PredArgResult)
		    ->  get_var(Env20, sys_alist, Alist_Get11),
			cl_caar(Alist_Get11, Caar_Ret),
			get_var(Env20, sys_alist, Alist_Get12),
			cl_cdar(Alist_Get12, Cdar_Ret),
			TrueResult=[Caar_Ret|Cdar_Ret],
			CAR=TrueResult
		    ;   get_var(Env20, sys_alist, Alist_Get13),
			cl_car(Alist_Get13, ElseResult),
			CAR=ElseResult
		    ),
		    get_var(Env20, sys_alist, Alist_Get16),
		    cl_cdr(Alist_Get16, Copy_alist_Param),
		    cl_copy_alist(Copy_alist_Param, Copy_alist_Ret),
		    TrueResult17=[CAR|Copy_alist_Ret],
		    _260503362=TrueResult17
		;   _260503362=[]
		),
		_260503362=FnResult
	      ),
	      block_exit(copy_alist, FnResult),
	      true).
:- set_opv(cl_copy_alist, classof, claz_function),
   set_opv(copy_alist, compile_as, kw_function),
   set_opv(copy_alist, function, cl_copy_alist),
   DefunResult=copy_alist.
/*
:- side_effect(assert_lsp(copy_alist,
			  lambda_def(defun,
				     copy_alist,
				     cl_copy_alist,
				     [sys_alist],
				     
				     [ 
				       [ when,
					 sys_alist,
					 
					 [ cons,
					   
					   [ if,
					     [consp, [car, sys_alist]],
					     
					     [ cons,
					       [caar, sys_alist],
					       [cdar, sys_alist]
					     ],
					     [car, sys_alist]
					   ],
					   [copy_alist, [cdr, sys_alist]]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(copy_alist,
			  arglist_info(copy_alist,
				       cl_copy_alist,
				       [sys_alist],
				       arginfo{ all:[sys_alist],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_alist],
						opt:0,
						req:[sys_alist],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(copy_alist, init_args(exact_only, cl_copy_alist))).
*/
/*
#+(or WAM-CL LISP500) 
(defun pairlis (keys data &optional alist)
  (tagbody
   start
     (when (and keys data)
       (setf alist (acons (car keys) (car data) alist))
       (setf keys (cdr keys))
       (setf data (cdr data))
       (go start)))
  alist)



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70536 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,pairlis,[keys,data,'&optional',alist],[tagbody,start,[when,[and,keys,data],[setf,alist,[acons,[car,keys],[car,data],alist]],[setf,keys,[cdr,keys]],[setf,data,[cdr,data]],[go,start]]],alist]).
wl:lambda_def(defun,pairlis,cl_pairlis,[sys_keys,sys_data,c38_optional,sys_alist],[[tagbody,start,[when,[and,sys_keys,sys_data],[setf,sys_alist,[acons,[car,sys_keys],[car,sys_data],sys_alist]],[setf,sys_keys,[cdr,sys_keys]],[setf,sys_data,[cdr,sys_data]],[go,start]]],sys_alist]).
wl:arglist_info(pairlis,cl_pairlis,[sys_keys,sys_data,c38_optional,sys_alist],arginfo{all:[sys_keys,sys_data,sys_alist],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_keys,sys_data,sys_alist],opt:[sys_alist],req:[sys_keys,sys_data],rest:0,sublists:0,whole:0}).
wl:init_args(2,cl_pairlis).

/*

### Compiled:  `CL:PAIRLIS` 
*/
cl_pairlis(_261306050,_261306084,_261306546,_261512754):-_261427282=[bv(sys_keys,_261306050),bv(sys_data,_261306084),bv(sys_alist,_261306154)|_261280478],global_env(_261280478),opt_var(_261280478,sys_alist,_261306154,true,[],1,_261306546),catch((call_addr_block(_261427282,(push_label(start),get_var(_261427282,sys_keys,_261403224),(_261403224\==[]->get_var(_261427282,sys_data,_261405750),_261402194=_261405750;_261402194=[]),(_261402194\==[]->get_var(_261427282,sys_keys,_261413076),cl_car(_261413076,_261412170),get_var(_261427282,sys_data,_261414996),cl_car(_261414996,_261414090),get_var(_261427282,sys_alist,_261416838),cl_acons(_261412170,_261414090,_261416838,_261411852),set_var(_261427282,sys_alist,_261411852),get_var(_261427282,sys_keys,_261422022),cl_cdr(_261422022,_261421026),set_var(_261427282,sys_keys,_261421026),get_var(_261427282,sys_data,_261425024),cl_cdr(_261425024,_261424028),set_var(_261427282,sys_data,_261424028),goto(start,_261427282),_261338746=_261427056;_261338746=[])),[addr(addr_tagbody_44_start,start,'$unused',_261465184,(get_var(_261465184,sys_keys,_261465204),(_261465204\==[]->get_var(_261465184,sys_data,_261465256),_261465276=_261465256;_261465276=[]),(_261465276\==[]->get_var(_261465184,sys_keys,_261465328),cl_car(_261465328,_261891414),get_var(_261465184,sys_data,_261465368),cl_car(_261465368,_261980690),get_var(_261465184,sys_alist,_261465404),cl_acons(_261891414,_261980690,_261465404,_261465420),set_var(_261465184,sys_alist,_261465420),get_var(_261465184,sys_keys,_261465452),cl_cdr(_261465452,_261465474),set_var(_261465184,sys_keys,_261465474),get_var(_261465184,sys_data,_261465506),cl_cdr(_261465506,_261988694),set_var(_261465184,sys_data,_261988694),goto(start,_261465184),_261465558=_261465564;_261465558=[])))]),get_var(_261427282,sys_alist,_261466484),_261466484=_261512754),block_exit(pairlis,_261512754),true).
:-set_opv(cl_pairlis,classof,claz_function),set_opv(pairlis,compile_as,kw_function),set_opv(pairlis,function,cl_pairlis),_261276382=pairlis.
/*
:-side_effect(assert_lsp(pairlis,lambda_def(defun,pairlis,cl_pairlis,[sys_keys,sys_data,c38_optional,sys_alist],[[tagbody,start,[when,[and,sys_keys,sys_data],[setf,sys_alist,[acons,[car,sys_keys],[car,sys_data],sys_alist]],[setf,sys_keys,[cdr,sys_keys]],[setf,sys_data,[cdr,sys_data]],[go,start]]],sys_alist]))).
*/
/*
:-side_effect(assert_lsp(pairlis,arglist_info(pairlis,cl_pairlis,[sys_keys,sys_data,c38_optional,sys_alist],arginfo{all:[sys_keys,sys_data,sys_alist],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_keys,sys_data,sys_alist],opt:[sys_alist],req:[sys_keys,sys_data],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(pairlis,init_args(2,cl_pairlis))).
*/
/*
#+(or WAM-CL LISP500) 
(defun some-list-2 (predicate list1 list2)
  (tagbody
   start
     (when (and list1 list2)
       (when (funcall predicate (car list1) (car list2))
	 (return-from some-list-2 t))
       (pop list1)
       (pop list2)
       (go start))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:70810 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'some-list-2',[predicate,list1,list2],[tagbody,start,[when,[and,list1,list2],[when,[funcall,predicate,[car,list1],[car,list2]],['return-from','some-list-2',t]],[pop,list1],[pop,list2],[go,start]]]]).
wl:lambda_def(defun, sys_some_list_2, f_sys_some_list_2, [predicate, sys_list1, sys_list2], [[tagbody, start, [when, [and, sys_list1, sys_list2], [when, [funcall, predicate, [car, sys_list1], [car, sys_list2]], [return_from, sys_some_list_2, t]], [pop, sys_list1], [pop, sys_list2], [go, start]]]]).
wl:arglist_info(sys_some_list_2, f_sys_some_list_2, [predicate, sys_list1, sys_list2], arginfo{all:[predicate, sys_list1, sys_list2], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[predicate, sys_list1, sys_list2], opt:0, req:[predicate, sys_list1, sys_list2], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_some_list_2).

/*

### Compiled:  `SYS::SOME-LIST-2` 
*/
f_sys_some_list_2(Predicate_In, List1_In, List2_In, FnResult) :-
	BlockExitEnv41=[bv(predicate, Predicate_In), bv(sys_list1, List1_In), bv(sys_list2, List2_In)|Env],
	global_env(Env),
	catch(( call_addr_block(BlockExitEnv41,
				(push_label(start), get_var(BlockExitEnv41, sys_list1, IFTEST29), (IFTEST29\==[]->get_var(BlockExitEnv41, sys_list2, List2_Get32), IFTEST27=List2_Get32;IFTEST27=[]), (IFTEST27\==[]->get_var(BlockExitEnv41, predicate, Predicate_Get36), get_var(BlockExitEnv41, sys_list1, List1_Get37), cl_car(List1_Get37, Car_Ret), get_var(BlockExitEnv41, sys_list2, List2_Get38), cl_car(List2_Get38, Car_Ret50), cl_apply(Predicate_Get36, [Car_Ret, Car_Ret50], IFTEST34), (IFTEST34\==[]->throw(block_exit(sys_some_list_2, t)), _262685538=ThrowResult40;_262685538=[]), cl_pop(sys_list1, Pop_Ret), cl_pop(sys_list2, Pop_Ret52), goto(start, BlockExitEnv41), _TBResult=_GORES43;_TBResult=[])),
				
				[ addr(addr_tagbody_45_start,
				       start,
				       '$unused',
				       BlockExitEnv,
				       (get_var(BlockExitEnv, sys_list1, IFTEST9), (IFTEST9\==[]->get_var(BlockExitEnv, sys_list2, List2_Get), IFTEST=List2_Get;IFTEST=[]), (IFTEST\==[]->get_var(BlockExitEnv, predicate, Apply_Param), get_var(BlockExitEnv, sys_list1, List1_Get17), cl_car(List1_Get17, Car_Ret53), get_var(BlockExitEnv, sys_list2, List2_Get18), cl_car(List2_Get18, Car_Ret54), cl_apply(Apply_Param, [Car_Ret53, Car_Ret54], IFTEST14), (IFTEST14\==[]->throw(block_exit(sys_some_list_2, t)), _262742830=ThrowResult;_262742830=[]), cl_pop(sys_list1, Pop_Ret55), cl_pop(sys_list2, Pop_Ret56), goto(start, BlockExitEnv), _262742892=_GORES;_262742892=[])))
				]),
		[]=FnResult
	      ),
	      block_exit(sys_some_list_2, FnResult),
	      true).
:- set_opv(f_sys_some_list_2, classof, claz_function),
   set_opv(sys_some_list_2, compile_as, kw_function),
   set_opv(sys_some_list_2, function, f_sys_some_list_2),
   DefunResult=sys_some_list_2.
/*
:- side_effect(assert_lsp(sys_some_list_2,
			  lambda_def(defun,
				     sys_some_list_2,
				     f_sys_some_list_2,
				     [predicate, sys_list1, sys_list2],
				     
				     [ 
				       [ tagbody,
					 start,
					 
					 [ when,
					   [and, sys_list1, sys_list2],
					   
					   [ when,
					     
					     [ funcall,
					       predicate,
					       [car, sys_list1],
					       [car, sys_list2]
					     ],
					     [return_from, sys_some_list_2, t]
					   ],
					   [pop, sys_list1],
					   [pop, sys_list2],
					   [go, start]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_some_list_2,
			  arglist_info(sys_some_list_2,
				       f_sys_some_list_2,
				       [predicate, sys_list1, sys_list2],
				       arginfo{ all:
						    [ predicate,
						      sys_list1,
						      sys_list2
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ predicate,
							sys_list1,
							sys_list2
						      ],
						opt:0,
						req:
						    [ predicate,
						      sys_list1,
						      sys_list2
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_some_list_2,
			  init_args(exact_only, f_sys_some_list_2))).
*/
/*
(flet 
  ((satisfies (object elem &key key test test-not)
	 (let* ((zi (if key (funcall key elem) elem))
		(r (funcall (or test test-not #'eql) object zi)))
	   (if test-not (not r) r)))

       (satisfies-if (predicate elem &key key)
	 (funcall predicate (if key (funcall key elem) elem)))
       (satisfies-if-not (predicate elem &key key)
	 (not (funcall predicate (if key (funcall key elem) elem))))
       (seq-start (sequence &key (start 0) end from-end)
	 (if (listp sequence)
	     (if from-end
		 (let ((acc nil)
		       (sequence (nthcdr start sequence)))
		   (tagbody
		    start
		      (when (and sequence (or (not end) (< start end)))
			(push sequence acc)
			(setf sequence (cdr sequence))
			(setf start (+ 1 start))
			(go start)))
		   (list 3 acc start))
		 (list 2 (nthcdr start sequence) start))
	     (if from-end (cons 1 (- end 1)) (cons 0 start))))
       (seq-position (iter)
	 (case (car iter)
	   ((0 1) (cdr iter))
	   (t (caddr iter))))
       (seq-next (iter)
	 (case (car iter)
	   (0 (setf (cdr iter) (+ 1 (cdr iter))))
	   (1 (setf (cdr iter) (- (cdr iter) 1)))
	   (2 (setf (cadr iter) (cdadr iter))
	      (setf (caddr iter) (+ 1 (caddr iter))))
	   (t (setf (cadr iter) (cdadr iter))
	      (setf (caddr iter) (- (caddr iter) 1)))))
       (seq-ref (sequence iter)
	 (case (car iter)
	   ((0 1) (aref sequence (cdr iter)))
	   (2 (caadr iter))
	   (t (caaadr iter))))
       (seq-set (sequence iter value)
	 (case (car iter)
	   ((0 1) (setf (aref sequence (cdr iter)) value))
	   (2 (setf (caadr iter) value))
	   (t (setf (caaadr iter) value))))
       (seq-end-p (sequence iter &key start end from-end)
	 (case (car iter)
	   (0 (or (= (cdr iter) (length sequence))
		  (and end (= end (cdr iter)))))
	   (1 (< (cdr iter) start))
	   (2 (or (null (cadr iter)) (and end (= end (caddr iter)))))
	   (t (or (null (cadr iter)) (< (caddr iter) start)))))
       (seq-result (sequence iter result)
	 (case (car iter)
	   (0 (make-array (length result)
			  :element-type (array-element-type sequence)
			  :initial-contents (reverse result)))
	   (1 (make-array (length result)
			  :element-type (array-element-type sequence)
			  :initial-contents result))
	   (2 (reverse result))
	   (3 result))))



#+BUILTIN 
  (defun member (item list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies item (car list) rest)
	   (return-from member list))
	 (setf list (cdr list))
	 (go start))))


#+BUILTIN 
  (defun member-if (predicate list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies-if predicate (car list) rest)
	   (return-from member-if list))
	 (setf list (cdr list))
	 (go start))))

#+BUILTIN 
  (defun member-if-not (predicate list &rest rest)
    (tagbody
       start
       (when list
	 (when (apply #'satisfies-if-not predicate (car list) rest)
	   (return-from member-if list))
	 (setf list (cdr list))
	 (go start))))
  (defun subst (new old tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new old (car tree) rest))
	      (d (apply #'subst new old (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies old tree rest) new tree)))
  (defun subst-if (new predicate tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new predicate (car tree) rest))
	      (d (apply #'subst new predicate (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies-if predicate tree rest) new tree)))
  (defun subst-if-not (new predicate tree &rest rest)
    (if (consp tree)
	(let ((a (apply #'subst new predicate (car tree) rest))
	      (d (apply #'subst new predicate (cdr tree) rest)))
	  (if (and (eq a (car tree)) (eq d (cdr tree)))
	      tree
	      (cons a d)))
	(if (apply #'satisfies-if-not predicate tree rest) new tree)))
  (defun nsubst (new old tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new old (car tree) rest))
	  (setf (cdr tree) (apply #'subst new old (cdr tree) rest))
	  tree)
	(if (apply #'satisfies old tree rest) new tree)))
  (defun nsubst-if (new predicate tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new predicate (car tree) rest))
	  (setf (cdr tree) (apply #'subst new predicate (cdr tree) rest))
	  tree)
	(if (apply #'satisfies-if predicate tree rest) new tree)))
  (defun nsubst-if-not (new predicate tree &rest rest)
    (if (consp tree)
	(progn
	  (setf (car tree) (apply #'subst new predicate (car tree) rest))
	  (setf (cdr tree) (apply #'subst new predicate (cdr tree) rest))
	  tree)
	(if (apply #'satisfies-if-not predicate tree rest) new tree)))

#+BUILTIN 
  (defun assoc (item alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies item (car elem) rest)
	(return-from assoc elem))))
  (defun assoc-if (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if predicate (car elem) rest)
	(return-from assoc-if elem))))
  (defun assoc-if-not (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if-not predicate (car elem) rest)
	(return-from assoc-if-not elem))))
  (defun rassoc (item alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies item (cdr elem) rest)
	(return-from rassoc elem))))
  (defun rassoc-if (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if predicate (cdr elem) rest)
	(return-from rassoc-if elem))))
  (defun rassoc-if-not (predicate alist &rest rest)
    (dolist (elem alist)
      (when (apply #'satisfies-if-not predicate (cdr elem) rest)
	(return-from rassoc-if-not elem))))
  (defun adjoin (item list &rest rest)
    (dolist (elem list (cons item list))
      (when (apply #'satisfies item elem rest)
	(return-from adjoin list))))
  (defun set-exclusive-or (list-1 list-2 &rest rest &key key)
    (let ((result nil))
      (dolist (item list-1)
	(unless (apply #'member (if key (funcall key item) item) list-2 rest)
	  (push item result)))
      (dolist (item list-2)
	(block matches
	  (dolist (elem list-1)
	    (when (apply #'satisfies
			 (if key (funcall key elem) elem) item rest)
	      (return-from matches)))
	  (push item result)))
      result))
  (defun nset-exclusive-or (list-1 list-2 &rest rest &key key)
    (let ((result nil)
	  (list nil)
	  (item nil))
      (tagbody
       start-1
	 (unless list-1 (go start-2))
	 (setf item (car list-1))
	 (setf list list-2)
	 (setf prev nil)
       start-1-in
	 (unless list (go end-1-in))
	 (let ((elem (if key (funcall key (car list)) (car list))))
	   (when (apply #'satisfies item (if key (funcall key elem) elem) rest)
	     (if prev
		 (setf (cdr prev) (cdr list))
		 (setf list-2 (cdr list)))
	     (setf list-1 (cdr list-1))
	     (go start-1)))
	 (setf prev list)
	 (setf list (cdr list))
	 (go start-1-in)
       end-1-in
	 (setf item (cdr list-1))
	 (setf (cdr list-1) result)
	 (unless result (setf end list-1))
	 (setf result list-1)
	 (setf list-1 item)
	 (go start-1)
       start-2
	 (return-from nset-exclusive-or
	   (if end (progn (setf (cdr end) list-2) result) list-2)))))
  (defun fill (sequence item &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (seq-set sequence iter item)
	   (seq-next iter)
	   (go start))))
    sequence)
  (defun every (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (unless (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every nil))
	   (mapc #'seq-next iters)
	   (go start))))
    t)
  (defun some (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (let ((result (apply predicate (mapcar #'seq-ref sequences iters))))
	     (when result (return-from some result)))
	   (mapc #'seq-next iters)
	   (go start)))))
  (defun notevery (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (unless (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every t))
	   (mapc #'seq-next iters)
	   (go start)))))
  (defun notany (predicate &rest sequences)
    (let ((iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (when (apply predicate (mapcar #'seq-ref sequences iters))
	     (return-from every nil))
	   (mapc #'seq-next iters)
	   (go start))))
    t)
  (defun map-into (result-sequence function &rest sequences)
    (let ((result-iter (seq-start result-sequence))
	  (iters (mapcar #'seq-start sequences)))
      (tagbody
       start
	 (unless (some-list-2 #'seq-end-p sequences iters)
	   (seq-set result-sequence result-iter
		    (apply function (mapcar #'seq-ref sequences iters)))
	   (seq-next result-iter)
	   (mapc #'seq-next iters)
	   (go start))))
    result-sequence)
  (defun reduce (function sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (if (apply #'seq-end-p sequence iter rest)
	  (funcall function)
	  (let ((elem (seq-ref sequence iter)))
	    (seq-next iter)
	    (unless (apply #'seq-end-p sequence iter rest)
	      (tagbody
	       start
		 (setq elem (funcall function elem (seq-ref sequence iter)))
		 (seq-next iter)
		 (unless (apply #'seq-end-p sequence iter rest)
		   (go start))))
	    elem))))
  (defun count (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies item (seq-ref sequence iter) rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))
  (defun count-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if predicate (seq-ref sequence iter) rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))
  (defun count-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest))
	  (count 0))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if-not predicate (seq-ref sequence iter)
			rest)
	     (setf count (+ 1 count)))
	   (seq-next iter)
	   (go start)))
      count))

#+BUILTIN 
  (defun find (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies item elem rest)
	       (return-from find elem)))
	   (seq-next iter)
	   (go start)))))

#+BUILTIN 
  (defun find-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies-if predicate elem rest)
	       (return-from find-if elem)))
	   (seq-next iter)
	   (go start)))))

#+BUILTIN 
  (defun find-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (when (apply #'satisfies-if-not predicate elem rest)
	       (return-from find-if-not elem)))
	   (seq-next iter)
	   (go start)))))

#+BUILTIN 
  (defun position (item sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies item (seq-ref sequence iter) rest)
	     (return-from position (seq-position iter)))
	   (seq-next iter)
	   (go start)))))

#+BUILTIN 
  (defun position-if (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if predicate (seq-ref sequence iter) rest)
	     (return-from position-if (seq-position iter)))
	   (seq-next iter)
	   (go start)))))

#+BUILTIN
  (defun position-if-not (predicate sequence &rest rest)
    (let ((iter (apply #'seq-start sequence rest)))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (when (apply #'satisfies-if-not predicate (seq-ref sequence iter)
			rest)
	     (return-from position-if-not (seq-position iter)))
	   (seq-next iter)
	   (go start)))))
  (defun remove (item sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies item elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result)))
  (defun remove-if (predicate sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies-if predicate elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result)))
  (defun remove-if-not (predicate sequence &rest rest &key count)
    (let ((iter (apply #'seq-start sequence rest))
	  (result nil))
      (tagbody
       start
	 (unless (apply #'seq-end-p sequence iter rest)
	   (let ((elem (seq-ref sequence iter)))
	     (unless (and (apply #'satisfies-if-not predicate elem rest)
			  (or (not count) (not (minusp (decf count)))))
	       (push elem result)))
	   (seq-next iter)
	   (go start)))
      (seq-result sequence iter result)))
)                     


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:71086 **********************/
:-lisp_compile_to_prolog(pkg_sys,[flet,[[satisfies,[object,elem,'&key',key,test,'test-not'],['let*',[[zi,[if,key,[funcall,key,elem],elem]],[r,[funcall,[or,test,'test-not',function(eql)],object,zi]]],[if,'test-not',[not,r],r]]],['satisfies-if',[predicate,elem,'&key',key],[funcall,predicate,[if,key,[funcall,key,elem],elem]]],['satisfies-if-not',[predicate,elem,'&key',key],[not,[funcall,predicate,[if,key,[funcall,key,elem],elem]]]],['seq-start',[sequence,'&key',[start,0],end,'from-end'],[if,[listp,sequence],[if,'from-end',[let,[[acc,[]],[sequence,[nthcdr,start,sequence]]],[tagbody,start,[when,[and,sequence,[or,[not,end],[<,start,end]]],[push,sequence,acc],[setf,sequence,[cdr,sequence]],[setf,start,[+,1,start]],[go,start]]],[list,3,acc,start]],[list,2,[nthcdr,start,sequence],start]],[if,'from-end',[cons,1,[-,end,1]],[cons,0,start]]]],['seq-position',[iter],[case,[car,iter],[[0,1],[cdr,iter]],[t,[caddr,iter]]]],['seq-next',[iter],[case,[car,iter],[0,[setf,[cdr,iter],[+,1,[cdr,iter]]]],[1,[setf,[cdr,iter],[-,[cdr,iter],1]]],[2,[setf,[cadr,iter],[cdadr,iter]],[setf,[caddr,iter],[+,1,[caddr,iter]]]],[t,[setf,[cadr,iter],[cdadr,iter]],[setf,[caddr,iter],[-,[caddr,iter],1]]]]],['seq-ref',[sequence,iter],[case,[car,iter],[[0,1],[aref,sequence,[cdr,iter]]],[2,[caadr,iter]],[t,[caaadr,iter]]]],['seq-set',[sequence,iter,value],[case,[car,iter],[[0,1],[setf,[aref,sequence,[cdr,iter]],value]],[2,[setf,[caadr,iter],value]],[t,[setf,[caaadr,iter],value]]]],['seq-end-p',[sequence,iter,'&key',start,end,'from-end'],[case,[car,iter],[0,[or,[=,[cdr,iter],[length,sequence]],[and,end,[=,end,[cdr,iter]]]]],[1,[<,[cdr,iter],start]],[2,[or,[null,[cadr,iter]],[and,end,[=,end,[caddr,iter]]]]],[t,[or,[null,[cadr,iter]],[<,[caddr,iter],start]]]]],['seq-result',[sequence,iter,result],[case,[car,iter],[0,['make-array',[length,result],':element-type',['array-element-type',sequence],':initial-contents',[reverse,result]]],[1,['make-array',[length,result],':element-type',['array-element-type',sequence],':initial-contents',result]],[2,[reverse,result]],[3,result]]]],[defun,subst,[new,old,tree,'&rest',rest],[if,[consp,tree],[let,[[a,[apply,function(subst),new,old,[car,tree],rest]],[d,[apply,function(subst),new,old,[cdr,tree],rest]]],[if,[and,[eq,a,[car,tree]],[eq,d,[cdr,tree]]],tree,[cons,a,d]]],[if,[apply,function(satisfies),old,tree,rest],new,tree]]],[defun,'subst-if',[new,predicate,tree,'&rest',rest],[if,[consp,tree],[let,[[a,[apply,function(subst),new,predicate,[car,tree],rest]],[d,[apply,function(subst),new,predicate,[cdr,tree],rest]]],[if,[and,[eq,a,[car,tree]],[eq,d,[cdr,tree]]],tree,[cons,a,d]]],[if,[apply,function('satisfies-if'),predicate,tree,rest],new,tree]]],[defun,'subst-if-not',[new,predicate,tree,'&rest',rest],[if,[consp,tree],[let,[[a,[apply,function(subst),new,predicate,[car,tree],rest]],[d,[apply,function(subst),new,predicate,[cdr,tree],rest]]],[if,[and,[eq,a,[car,tree]],[eq,d,[cdr,tree]]],tree,[cons,a,d]]],[if,[apply,function('satisfies-if-not'),predicate,tree,rest],new,tree]]],[defun,nsubst,[new,old,tree,'&rest',rest],[if,[consp,tree],[progn,[setf,[car,tree],[apply,function(subst),new,old,[car,tree],rest]],[setf,[cdr,tree],[apply,function(subst),new,old,[cdr,tree],rest]],tree],[if,[apply,function(satisfies),old,tree,rest],new,tree]]],[defun,'nsubst-if',[new,predicate,tree,'&rest',rest],[if,[consp,tree],[progn,[setf,[car,tree],[apply,function(subst),new,predicate,[car,tree],rest]],[setf,[cdr,tree],[apply,function(subst),new,predicate,[cdr,tree],rest]],tree],[if,[apply,function('satisfies-if'),predicate,tree,rest],new,tree]]],[defun,'nsubst-if-not',[new,predicate,tree,'&rest',rest],[if,[consp,tree],[progn,[setf,[car,tree],[apply,function(subst),new,predicate,[car,tree],rest]],[setf,[cdr,tree],[apply,function(subst),new,predicate,[cdr,tree],rest]],tree],[if,[apply,function('satisfies-if-not'),predicate,tree,rest],new,tree]]],[defun,'assoc-if',[predicate,alist,'&rest',rest],[dolist,[elem,alist],[when,[apply,function('satisfies-if'),predicate,[car,elem],rest],['return-from','assoc-if',elem]]]],[defun,'assoc-if-not',[predicate,alist,'&rest',rest],[dolist,[elem,alist],[when,[apply,function('satisfies-if-not'),predicate,[car,elem],rest],['return-from','assoc-if-not',elem]]]],[defun,rassoc,[item,alist,'&rest',rest],[dolist,[elem,alist],[when,[apply,function(satisfies),item,[cdr,elem],rest],['return-from',rassoc,elem]]]],[defun,'rassoc-if',[predicate,alist,'&rest',rest],[dolist,[elem,alist],[when,[apply,function('satisfies-if'),predicate,[cdr,elem],rest],['return-from','rassoc-if',elem]]]],[defun,'rassoc-if-not',[predicate,alist,'&rest',rest],[dolist,[elem,alist],[when,[apply,function('satisfies-if-not'),predicate,[cdr,elem],rest],['return-from','rassoc-if-not',elem]]]],[defun,adjoin,[item,list,'&rest',rest],[dolist,[elem,list,[cons,item,list]],[when,[apply,function(satisfies),item,elem,rest],['return-from',adjoin,list]]]],[defun,'set-exclusive-or',['list-1','list-2','&rest',rest,'&key',key],[let,[[result,[]]],[dolist,[item,'list-1'],[unless,[apply,function(member),[if,key,[funcall,key,item],item],'list-2',rest],[push,item,result]]],[dolist,[item,'list-2'],[block,matches,[dolist,[elem,'list-1'],[when,[apply,function(satisfies),[if,key,[funcall,key,elem],elem],item,rest],['return-from',matches]]],[push,item,result]]],result]],[defun,'nset-exclusive-or',['list-1','list-2','&rest',rest,'&key',key],[let,[[result,[]],[list,[]],[item,[]]],[tagbody,'start-1',[unless,'list-1',[go,'start-2']],[setf,item,[car,'list-1']],[setf,list,'list-2'],[setf,prev,[]],'start-1-in',[unless,list,[go,'end-1-in']],[let,[[elem,[if,key,[funcall,key,[car,list]],[car,list]]]],[when,[apply,function(satisfies),item,[if,key,[funcall,key,elem],elem],rest],[if,prev,[setf,[cdr,prev],[cdr,list]],[setf,'list-2',[cdr,list]]],[setf,'list-1',[cdr,'list-1']],[go,'start-1']]],[setf,prev,list],[setf,list,[cdr,list]],[go,'start-1-in'],'end-1-in',[setf,item,[cdr,'list-1']],[setf,[cdr,'list-1'],result],[unless,result,[setf,end,'list-1']],[setf,result,'list-1'],[setf,'list-1',item],[go,'start-1'],'start-2',['return-from','nset-exclusive-or',[if,end,[progn,[setf,[cdr,end],'list-2'],result],'list-2']]]]],[defun,fill,[sequence,item,'&rest',rest],[let,[[iter,[apply,function('seq-start'),sequence,rest]]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],['seq-set',sequence,iter,item],['seq-next',iter],[go,start]]]],sequence],[defun,every,[predicate,'&rest',sequences],[let,[[iters,[mapcar,function('seq-start'),sequences]]],[tagbody,start,[unless,['some-list-2',function('seq-end-p'),sequences,iters],[unless,[apply,predicate,[mapcar,function('seq-ref'),sequences,iters]],['return-from',every,[]]],[mapc,function('seq-next'),iters],[go,start]]]],t],[defun,some,[predicate,'&rest',sequences],[let,[[iters,[mapcar,function('seq-start'),sequences]]],[tagbody,start,[unless,['some-list-2',function('seq-end-p'),sequences,iters],[let,[[result,[apply,predicate,[mapcar,function('seq-ref'),sequences,iters]]]],[when,result,['return-from',some,result]]],[mapc,function('seq-next'),iters],[go,start]]]]],[defun,notevery,[predicate,'&rest',sequences],[let,[[iters,[mapcar,function('seq-start'),sequences]]],[tagbody,start,[unless,['some-list-2',function('seq-end-p'),sequences,iters],[unless,[apply,predicate,[mapcar,function('seq-ref'),sequences,iters]],['return-from',every,t]],[mapc,function('seq-next'),iters],[go,start]]]]],[defun,notany,[predicate,'&rest',sequences],[let,[[iters,[mapcar,function('seq-start'),sequences]]],[tagbody,start,[unless,['some-list-2',function('seq-end-p'),sequences,iters],[when,[apply,predicate,[mapcar,function('seq-ref'),sequences,iters]],['return-from',every,[]]],[mapc,function('seq-next'),iters],[go,start]]]],t],[defun,'map-into',['result-sequence',function,'&rest',sequences],[let,[['result-iter',['seq-start','result-sequence']],[iters,[mapcar,function('seq-start'),sequences]]],[tagbody,start,[unless,['some-list-2',function('seq-end-p'),sequences,iters],['seq-set','result-sequence','result-iter',[apply,function,[mapcar,function('seq-ref'),sequences,iters]]],['seq-next','result-iter'],[mapc,function('seq-next'),iters],[go,start]]]],'result-sequence'],[defun,reduce,[function,sequence,'&rest',rest],[let,[[iter,[apply,function('seq-start'),sequence,rest]]],[if,[apply,function('seq-end-p'),sequence,iter,rest],[funcall,function],[let,[[elem,['seq-ref',sequence,iter]]],['seq-next',iter],[unless,[apply,function('seq-end-p'),sequence,iter,rest],[tagbody,start,[setq,elem,[funcall,function,elem,['seq-ref',sequence,iter]]],['seq-next',iter],[unless,[apply,function('seq-end-p'),sequence,iter,rest],[go,start]]]],elem]]]],[defun,count,[item,sequence,'&rest',rest],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[when,[apply,function(satisfies),item,['seq-ref',sequence,iter],rest],[setf,count,[+,1,count]]],['seq-next',iter],[go,start]]],count]],[defun,'count-if',[predicate,sequence,'&rest',rest],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[when,[apply,function('satisfies-if'),predicate,['seq-ref',sequence,iter],rest],[setf,count,[+,1,count]]],['seq-next',iter],[go,start]]],count]],[defun,'count-if-not',[predicate,sequence,'&rest',rest],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[when,[apply,function('satisfies-if-not'),predicate,['seq-ref',sequence,iter],rest],[setf,count,[+,1,count]]],['seq-next',iter],[go,start]]],count]],[defun,remove,[item,sequence,'&rest',rest,'&key',count],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[result,[]]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[let,[[elem,['seq-ref',sequence,iter]]],[unless,[and,[apply,function(satisfies),item,elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,elem,result]]],['seq-next',iter],[go,start]]],['seq-result',sequence,iter,result]]],[defun,'remove-if',[predicate,sequence,'&rest',rest,'&key',count],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[result,[]]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[let,[[elem,['seq-ref',sequence,iter]]],[unless,[and,[apply,function('satisfies-if'),predicate,elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,elem,result]]],['seq-next',iter],[go,start]]],['seq-result',sequence,iter,result]]],[defun,'remove-if-not',[predicate,sequence,'&rest',rest,'&key',count],[let,[[iter,[apply,function('seq-start'),sequence,rest]],[result,[]]],[tagbody,start,[unless,[apply,function('seq-end-p'),sequence,iter,rest],[let,[[elem,['seq-ref',sequence,iter]]],[unless,[and,[apply,function('satisfies-if-not'),predicate,elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,elem,result]]],['seq-next',iter],[go,start]]],['seq-result',sequence,iter,result]]]]).
/*
% case:-[[[0,1],[cdr,sys_iter]],[t,[caddr,sys_iter]]].
*/
/*
% conds:-[[[sys_memq,_265849796,[quote,[0,1]]],[progn,[cdr,sys_iter]]],[t,[progn,[caddr,sys_iter]]]].
*/
/*
% case:-[[0,[setf,[cdr,sys_iter],[+,1,[cdr,sys_iter]]]],[1,[setf,[cdr,sys_iter],[-,[cdr,sys_iter],1]]],[2,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[+,1,[caddr,sys_iter]]]],[t,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[-,[caddr,sys_iter],1]]]].
*/
/*
% conds:-[[[eq,_265985908,[quote,0]],[progn,[setf,[cdr,sys_iter],[+,1,[cdr,sys_iter]]]]],[[eq,_265985908,[quote,1]],[progn,[setf,[cdr,sys_iter],[-,[cdr,sys_iter],1]]]],[[eq,_265985908,[quote,2]],[progn,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[+,1,[caddr,sys_iter]]]]],[t,[progn,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[-,[caddr,sys_iter],1]]]]].
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266382576,_266368652],[sys_iter,_266382576,_266368652]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266414448,_266368652],[sys_iter,_266414448,_266368652]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266446446,_266368652],[sys_iter,_266446446,_266368652]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266478472,_266464548],[sys_iter,_266478472,_266464548]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266527158,_266526986],[sys_iter,_266527158,_266526986]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266559000,_266558828],[sys_iter,_266559000,_266558828]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266590968,_266590796],[sys_iter,_266590968,_266590796]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266622964,_266622792],[sys_iter,_266622964,_266622792]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266671858,_266671686],[sys_iter,_266671858,_266671686]),setf_inverse_op(cadr,sys_pf_set_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266704674,_266704502],[sys_iter,_266704674,_266704502]),setf_inverse_op(cadr,setf_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266736748,_266736576],[sys_iter,_266736748,_266736576]),setf_inverse_op(cadr,sys_pf_set_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266773818,_266773646],[sys_iter,_266773818,_266773646]),setf_inverse_op(caddr,sys_pf_set_caddr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266806652,_266806480],[sys_iter,_266806652,_266806480]),setf_inverse_op(caddr,setf_caddr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266838726,_266838554],[sys_iter,_266838726,_266838554]),setf_inverse_op(caddr,sys_pf_set_caddr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266891822,_266891650],[sys_iter,_266891822,_266891650]),setf_inverse_op(cadr,sys_pf_set_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266923790,_266923618],[sys_iter,_266923790,_266923618]),setf_inverse_op(cadr,setf_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266955864,_266955692],[sys_iter,_266955864,_266955692]),setf_inverse_op(cadr,sys_pf_set_cadr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_266992982,_266992810],[sys_iter,_266992982,_266992810]),setf_inverse_op(caddr,sys_pf_set_caddr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_267024950,_267024778],[sys_iter,_267024950,_267024778]),setf_inverse_op(caddr,setf_caddr))).
*/
/*
:-side_effect((compile_each($,_265976394,[],[],true),append([sys_iter],[_267057024,_267056852],[sys_iter,_267057024,_267056852]),setf_inverse_op(caddr,sys_pf_set_caddr))).
*/
/*
% case:-[[[0,1],[aref,sequence,[cdr,sys_iter]]],[2,[caadr,sys_iter]],[t,[caaadr,sys_iter]]].
*/
/*
% conds:-[[[sys_memq,_267194678,[quote,[0,1]]],[progn,[aref,sequence,[cdr,sys_iter]]]],[[eq,_267194678,[quote,2]],[progn,[caadr,sys_iter]]],[t,[progn,[caaadr,sys_iter]]]].
*/
/*
% case:-[[[0,1],[setf,[aref,sequence,[cdr,sys_iter]],sys_value]],[2,[setf,[caadr,sys_iter],sys_value]],[t,[setf,[caaadr,sys_iter],sys_value]]].
*/
/*
% conds:-[[[sys_memq,_267412594,[quote,[0,1]]],[progn,[setf,[aref,sequence,[cdr,sys_iter]],sys_value]]],[[eq,_267412594,[quote,2]],[progn,[setf,[caadr,sys_iter],sys_value]]],[t,[progn,[setf,[caaadr,sys_iter],sys_value]]]].
*/
/*
:-side_effect((compile_each($,_267403768,[[cdr,sys_iter]],[[cdr,sys_iter]],true),append([sequence,[cdr,sys_iter]],[_267621598,_267621426],[sequence,[cdr,sys_iter],_267621598,_267621426]),setf_inverse_op(aref,[]))).
*/
/*
:-side_effect((compile_each($,_267403768,[[cdr,sys_iter]],[[cdr,sys_iter]],true),append([sequence,[cdr,sys_iter]],[_267672118,_267671946],[sequence,[cdr,sys_iter],_267672118,_267671946]),setf_inverse_op(aref,setf_aref))).
*/
/*
:-side_effect((compile_each($,_267403768,[[cdr,sys_iter]],[[cdr,sys_iter]],true),append([sequence,[cdr,sys_iter]],[_267722790,_267722618],[sequence,[cdr,sys_iter],_267722790,_267722618]),setf_inverse_op(aref,[]))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267784114,_267783942],[sys_iter,_267784114,_267783942]),setf_inverse_op(caadr,sys_pf_set_caadr))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267816948,_267816776],[sys_iter,_267816948,_267816776]),setf_inverse_op(caadr,setf_caadr))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267849022,_267848850],[sys_iter,_267849022,_267848850]),setf_inverse_op(caadr,sys_pf_set_caadr))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267890394,_267890222],[sys_iter,_267890394,_267890222]),setf_inverse_op(caaadr,sys_pf_set_caaadr))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267923246,_267923074],[sys_iter,_267923246,_267923074]),setf_inverse_op(caaadr,setf_caaadr))).
*/
/*
:-side_effect((compile_each($,_267403768,[],[],true),append([sys_iter],[_267955320,_267955148],[sys_iter,_267955320,_267955148]),setf_inverse_op(caaadr,sys_pf_set_caaadr))).
*/
/*
% case:-[[0,[or,[=,[cdr,sys_iter],[length,sequence]],[and,end,[=,end,[cdr,sys_iter]]]]],[1,[<,[cdr,sys_iter],start]],[2,[or,[null,[cadr,sys_iter]],[and,end,[=,end,[caddr,sys_iter]]]]],[t,[or,[null,[cadr,sys_iter]],[<,[caddr,sys_iter],start]]]].
*/
/*
% conds:-[[[eq,_268055280,[quote,0]],[progn,[or,[=,[cdr,sys_iter],[length,sequence]],[and,end,[=,end,[cdr,sys_iter]]]]]],[[eq,_268055280,[quote,1]],[progn,[<,[cdr,sys_iter],start]]],[[eq,_268055280,[quote,2]],[progn,[or,[null,[cadr,sys_iter]],[and,end,[=,end,[caddr,sys_iter]]]]]],[t,[progn,[or,[null,[cadr,sys_iter]],[<,[caddr,sys_iter],start]]]]].
*/
/*
% case:-[[0,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,[reverse,sys_result]]],[1,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,sys_result]],[2,[reverse,sys_result]],[3,sys_result]].
*/
/*
% conds:-[[[eq,_268677806,[quote,0]],[progn,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,[reverse,sys_result]]]],[[eq,_268677806,[quote,1]],[progn,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,sys_result]]],[[eq,_268677806,[quote,2]],[progn,[reverse,sys_result]]],[[eq,_268677806,[quote,3]],[progn,sys_result]]].
*/
wl:lambda_def(defun,satisfies,cl_satisfies1,[sys_object,sys_elem,c38_key,key,test,sys_test_not],[[let_xx,[[sys_zi,[if,key,[funcall,key,sys_elem],sys_elem]],[sys_r,[funcall,[or,test,sys_test_not,function(eql)],sys_object,sys_zi]]],[if,sys_test_not,[not,sys_r],sys_r]]]).
wl:arglist_info(satisfies,cl_satisfies1,[sys_object,sys_elem,c38_key,key,test,sys_test_not],arginfo{all:[sys_object,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key,test,sys_test_not],names:[sys_object,sys_elem,key,test,sys_test_not],opt:0,req:[sys_object,sys_elem],rest:0,sublists:0,whole:0}).
wl:init_args(2,cl_satisfies1).

/*

### Compiled:  `CL:SATISFIES` 
*/
cl_satisfies1(_265073496,_265073530,_265072884,_265228132):-_278071474=[bv(sys_object,_265073496),bv(sys_elem,_265073530),bv(key,_265073652),bv(test,_265074738),bv(sys_test_not,_265075830)|_264935688],global_env(_264935688),get_kw(_264935688,_265072884,key,key,_265073652,[]=_265073652,_265078174),get_kw(_264935688,_265072884,test,test,_265074738,[]=_265074738,_265077628),get_kw(_264935688,_265072884,sys_test_not,sys_test_not,_265075830,[]=_265075830,_265076914),catch((get_var(_278071474,key,_265114252),(_265114252\==[]->get_var(_278071474,key,_265116582),get_var(_278071474,sys_elem,_265117026),cl_apply(_265116582,[_265117026],_265115488),_265113438=_265115488;get_var(_278071474,sys_elem,_265119942),_265113438=_265119942),(get_var(_278071474,test,_265129964),_265129964\==[],_265125312=_265129964->true;(get_var(_278071474,sys_test_not,_265128502),_265128502\==[],_265126644=_265128502->true;_265126644=cl_eql),_265125312=_265126644),get_var(_278071474,sys_object,_265132116),get_var(_278071474,sys_zi,_265133404),cl_apply(_265125312,[_265132116,_265133404],_265123272),_265111872=[bv(sys_zi,_265113438),bv(sys_r,_265123272)|_278071474],get_var(_265111872,sys_test_not,_265169208),(_265169208\==[]->get_var(_265111872,sys_r,_265171224),cl_not(_265171224,_265183348),_265109934=_265183348;get_var(_265111872,sys_r,_265182584),_265109934=_265182584),_265109934=_265228132),block_exit(satisfies,_265228132),true).
wl:lambda_def(defun,sys_satisfies_if,f_sys_satisfies_if1,[predicate,sys_elem,c38_key,key],[[funcall,predicate,[if,key,[funcall,key,sys_elem],sys_elem]]]).
wl:arglist_info(sys_satisfies_if,f_sys_satisfies_if1,[predicate,sys_elem,c38_key,key],arginfo{all:[predicate,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key],names:[predicate,sys_elem,key],opt:0,req:[predicate,sys_elem],rest:0,sublists:0,whole:0}).
wl:init_args(2,f_sys_satisfies_if1).

/*

### Compiled:  `SYS::SATISFIES-IF` 
*/
f_sys_satisfies_if1(_265261570,_265274024,_265261240,_265260906):-_278087942=[bv(predicate,_265261570),bv(sys_elem,_265274024),bv(key,_265274680)|_264935688],global_env(_264935688),get_kw(_264935688,_265261240,key,key,_265274680,[]=_265274680,_265263262),catch((get_var(_278087942,key,_265278432),get_var(_278087942,predicate,_265276630),(_265278432\==[]->get_var(_278087942,key,_265281294),get_var(_278087942,sys_elem,_265282542),cl_apply(_265281294,[_265282542],_265285510),_280126240=_265285510;get_var(_278087942,sys_elem,_265284710),_280126240=_265284710),cl_apply(_265276630,[_280126240],_265275546),_265275546=_265260906),block_exit(sys_satisfies_if,_265260906),true).
wl:lambda_def(defun,sys_satisfies_if_not,f_sys_satisfies_if_not1,[predicate,sys_elem,c38_key,key],[[not,[funcall,predicate,[if,key,[funcall,key,sys_elem],sys_elem]]]]).
wl:arglist_info(sys_satisfies_if_not,f_sys_satisfies_if_not1,[predicate,sys_elem,c38_key,key],arginfo{all:[predicate,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key],names:[predicate,sys_elem,key],opt:0,req:[predicate,sys_elem],rest:0,sublists:0,whole:0}).
wl:init_args(2,f_sys_satisfies_if_not1).

/*

### Compiled:  `SYS::SATISFIES-IF-NOT` 
*/
f_sys_satisfies_if_not1(_265322224,_265322946,_265319268,_265318934):-_278099468=[bv(predicate,_265322224),bv(sys_elem,_265322946),bv(key,_265323620)|_264935688],global_env(_264935688),get_kw(_264935688,_265319268,key,key,_265323620,[]=_265323620,_265321290),catch((get_var(_278099468,key,_265327818),get_var(_278099468,predicate,_265326958),(_265327818\==[]->get_var(_278099468,key,_265330698),get_var(_278099468,sys_elem,_265331964),cl_apply(_265330698,[_265331964],_265334968),_280145066=_265334968;get_var(_278099468,sys_elem,_265334150),_280145066=_265334150),cl_apply(_265326958,[_280145066],_265325416),cl_not(_265325416,_265324522),_265324522=_265318934),block_exit(sys_satisfies_if_not,_265318934),true).
wl:lambda_def(defun,sys_seq_start,f_sys_seq_start1,[sequence,c38_key,[start,0],end,sys_from_end],[[if,[listp,sequence],[if,sys_from_end,[let,[[sys_acc,[]],[sequence,[nthcdr,start,sequence]]],[tagbody,start,[when,[and,sequence,[or,[not,end],[<,start,end]]],[push,sequence,sys_acc],[setf,sequence,[cdr,sequence]],[setf,start,[+,1,start]],[go,start]]],[list,3,sys_acc,start]],[list,2,[nthcdr,start,sequence],start]],[if,sys_from_end,[cons,1,[-,end,1]],[cons,0,start]]]]).
wl:arglist_info(sys_seq_start,f_sys_seq_start1,[sequence,c38_key,[start,0],end,sys_from_end],arginfo{all:[sequence],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[start,end,sys_from_end],names:[sequence,start,end,sys_from_end],opt:0,req:[sequence],rest:0,sublists:0,whole:0}).
wl:init_args(1,f_sys_seq_start1).

/*

### Compiled:  `SYS::SEQ-START` 
*/
f_sys_seq_start1(_265373302,_265372954,_265372620):-_278120838=[bv(sequence,_265373302),bv(start,_265373412),bv(end,_265374508),bv(sys_from_end,_265375600)|_264935688],global_env(_264935688),get_kw(_264935688,_265372954,start,start,_265373412,0=_265373412,_265377902),get_kw(_264935688,_265372954,end,end,_265374508,[]=_265374508,_265377398),get_kw(_264935688,_265372954,sys_from_end,sys_from_end,_265375600,[]=_265375600,_265376684),catch((get_var(_278120838,sequence,_265419496),(is_listp(_265419496)->get_var(_278120838,sys_from_end,_265420958),(_265420958\==[]->get_var(_278120838,sequence,_265427906),get_var(_278120838,start,_265425682),cl_nthcdr(_265425682,_265427906,_265425544),_265425000=[bv(sys_acc,[]),bv(sequence,_265425544)|_278120838],call_addr_block(_265425000,(push_label(start),get_var(_265425000,sequence,_265511270),(_265511270\==[]->(get_var(_265425000,end,_265514230),cl_not(_265514230,_265519012),_265519012\==[],_265521416=_265519012->true;get_var(_265425000,end,_265517410),get_var(_265425000,start,_265516186),<(_265516186,_265517410,_265515290),_265521416=_265515290),_265509808=_265521416;_265509808=[]),(_265509808\==[]->cl_push(sequence,sys_acc,_265531242),get_var(_265425000,sequence,_265533752),cl_cdr(_265533752,_265532588),set_var(_265425000,sequence,_265532588),get_var(_265425000,start,_265536932),+(1,_265536932,_265535794),set_var(_265425000,start,_265535794),goto(start,_265425000),_265443802=_265539102;_265443802=[])),[addr(addr_tagbody_46_start,start,'$unused',_265575466,(get_var(_265575466,sequence,_265575486),(_265575486\==[]->(get_var(_265575466,end,_278627170),cl_not(_278627170,_265575568),_265575568\==[],_265575600=_265575568->true;get_var(_265575466,end,_265575656),get_var(_265575466,start,_265575628),<(_265575628,_265575656,_265575680),_265575600=_265575680),_265575696=_265575600;_265575696=[]),(_265575696\==[]->cl_push(sequence,sys_acc,_265575744),get_var(_265575466,sequence,_265575762),cl_cdr(_265575762,_265575784),set_var(_265575466,sequence,_265575784),get_var(_265575466,start,_265575816),+(1,_265575816,_265575840),set_var(_265575466,start,_265575840),goto(start,_265575466),_265575870=_265575876;_265575870=[])))]),get_var(_265425000,start,_265588200),get_var(_265425000,sys_acc,_265576278),_265424788=[3,_265576278,_265588200],_265667048=_265424788;get_var(_278120838,sequence,_265633814),get_var(_278120838,start,_265632362),cl_nthcdr(_265632362,_265633814,_265631396),get_var(_278120838,start,_265635986),_265638974=[2,_265631396,_265635986],_265667048=_265638974),_265412330=_265667048;get_var(_278120838,sys_from_end,_265656460),(_265656460\==[]->get_var(_278120838,end,_265659454),-(_265659454,1,_265658642),_265663900=[1|_265658642],_265667396=_265663900;get_var(_278120838,start,_265662444),_265664248=[0|_265662444],_265667396=_265664248),_265412330=_265667396),_265412330=_265372620),block_exit(sys_seq_start,_265372620),true).
wl:lambda_def(defun,sys_seq_position,f_sys_seq_position1,[sys_iter],[[case,[car,sys_iter],[[0,1],[cdr,sys_iter]],[t,[caddr,sys_iter]]]]).
wl:arglist_info(sys_seq_position,f_sys_seq_position1,[sys_iter],arginfo{all:[sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_iter],opt:0,req:[sys_iter],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_seq_position1).

/*

### Compiled:  `SYS::SEQ-POSITION` 
*/
f_sys_seq_position1(_265835100,_265834960):-_278144400=[bv(sys_iter,_265835100)|_264935688],global_env(_264935688),catch((get_var(_278144400,sys_iter,_265847896),cl_car(_265847896,_265849796),f_sys_memq(_265849796,[0,1],_265937326),(_265937326\==[]->get_var(_278144400,sys_iter,_265940226),cl_cdr(_265940226,_265949564),_265846688=_265949564;get_var(_278144400,sys_iter,_265945452),cl_caddr(_265945452,_265949912),_265846688=_265949912),_265846688=_265834960),block_exit(sys_seq_position,_265834960),true).
wl:lambda_def(defun,sys_seq_next,f_sys_seq_next1,[sys_iter],[[case,[car,sys_iter],[0,[setf,[cdr,sys_iter],[+,1,[cdr,sys_iter]]]],[1,[setf,[cdr,sys_iter],[-,[cdr,sys_iter],1]]],[2,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[+,1,[caddr,sys_iter]]]],[t,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[-,[caddr,sys_iter],1]]]]]).
wl:arglist_info(sys_seq_next,f_sys_seq_next1,[sys_iter],arginfo{all:[sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_iter],opt:0,req:[sys_iter],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_seq_next1).

/*

### Compiled:  `SYS::SEQ-NEXT` 
*/
f_sys_seq_next1(_265977938,_265977066):-_278161674=[bv(sys_iter,_265977938)|_264935688],global_env(_264935688),catch((get_var(_278161674,sys_iter,_265984744),cl_car(_265984744,_265985908),(is_eq(_265985908,0)->get_var(_278161674,sys_iter,_266496938),cl_cdr(_266496938,_280247190),+(1,_280247190,_266497516),cl_rplacd(_266496938,_266497516,_267107502),_265979726=_267107502;(is_eq(_265985908,1)->get_var(_278161674,sys_iter,_266641380),cl_cdr(_266641380,_280251990),-(_280251990,1,_266641970),cl_rplacd(_266641380,_266641970,_267100100),_267107850=_267100100;(is_eq(_265985908,2)->get_var(_278161674,sys_iter,_266755164),cl_cdadr(_266755164,_266755712),f_sys_pf_set_cadr(_266755164,_266755712,_266657698),get_var(_278161674,sys_iter,_266857142),cl_caddr(_266857142,_266857906),+(1,_266857906,_266857756),f_sys_pf_set_caddr(_266857142,_266857756,_267094506),_267100448=_267094506;get_var(_278161674,sys_iter,_266974280),cl_cdadr(_266974280,_280264140),f_sys_pf_set_cadr(_266974280,_280264140,_280265658),get_var(_278161674,sys_iter,_267075440),cl_caddr(_267075440,_280267698),-(_280267698,1,_267076078),f_sys_pf_set_caddr(_267075440,_267076078,_267094854),_267100448=_267094854),_267107850=_267100448),_265979726=_267107850),_265979726=_265977066),block_exit(sys_seq_next,_265977066),true).
wl:lambda_def(defun,sys_seq_ref,f_sys_seq_ref1,[sequence,sys_iter],[[case,[car,sys_iter],[[0,1],[aref,sequence,[cdr,sys_iter]]],[2,[caadr,sys_iter]],[t,[caaadr,sys_iter]]]]).
wl:arglist_info(sys_seq_ref,f_sys_seq_ref1,[sequence,sys_iter],arginfo{all:[sequence,sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter],opt:0,req:[sequence,sys_iter],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_seq_ref1).

/*

### Compiled:  `SYS::SEQ-REF` 
*/
f_sys_seq_ref1(_267189218,_267190006,_267188102):-_278179500=[bv(sequence,_267189218),bv(sys_iter,_267190006)|_264935688],global_env(_264935688),catch((get_var(_278179500,sys_iter,_267193430),cl_car(_267193430,_267194678),f_sys_memq(_267194678,[0,1],_267335842),(_267335842\==[]->get_var(_278179500,sequence,_267339180),get_var(_278179500,sys_iter,_267340578),cl_cdr(_267340578,_267339672),cl_aref(_267339180,_267339672,_267363490),_267191004=_267363490;(is_eq(_267194678,2)->get_var(_278179500,sys_iter,_267351550),cl_caadr(_267351550,_267361116),_267363838=_267361116;get_var(_278179500,sys_iter,_267356890),cl_caaadr(_267356890,_267361464),_267363838=_267361464),_267191004=_267363838),_267191004=_267188102),block_exit(sys_seq_ref,_267188102),true).
wl:lambda_def(defun,sys_seq_set,f_sys_seq_set1,[sequence,sys_iter,sys_value],[[case,[car,sys_iter],[[0,1],[setf,[aref,sequence,[cdr,sys_iter]],sys_value]],[2,[setf,[caadr,sys_iter],sys_value]],[t,[setf,[caaadr,sys_iter],sys_value]]]]).
wl:arglist_info(sys_seq_set,f_sys_seq_set1,[sequence,sys_iter,sys_value],arginfo{all:[sequence,sys_iter,sys_value],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter,sys_value],opt:0,req:[sequence,sys_iter,sys_value],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_seq_set1).

/*

### Compiled:  `SYS::SEQ-SET` 
*/
f_sys_seq_set1(_267405632,_267406450,_267404672,_267404440):-_278195054=[bv(sequence,_267405632),bv(sys_iter,_267406450),bv(sys_value,_267404672)|_264935688],global_env(_264935688),catch((get_var(_278195054,sys_iter,_267411316),cl_car(_267411316,_267412594),f_sys_memq(_267412594,[0,1],_267595494),(_267595494\==[]->get_var(_278195054,sequence,_267750614),get_var(_278195054,sys_iter,_267753574),get_var(_278195054,sys_value,_267751132),cl_cdr(_267753574,_280309292),cl_apply([],[_267750614,_280309292,_267751132],_267985002),_267408404=_267985002;(is_eq(_267412594,2)->get_var(_278195054,sys_iter,_267867438),get_var(_278195054,sys_value,_267868858),f_sys_pf_set_caadr(_267867438,_267868858,_267982008),_267985350=_267982008;get_var(_278195054,sys_iter,_267973736),get_var(_278195054,sys_value,_267975162),f_sys_pf_set_caaadr(_267973736,_267975162,_267982356),_267985350=_267982356),_267408404=_267985350),_267408404=_267404440),block_exit(sys_seq_set,_267404440),true).
wl:lambda_def(defun,sys_seq_end_p,f_sys_seq_end_p1,[sequence,sys_iter,c38_key,start,end,sys_from_end],[[case,[car,sys_iter],[0,[or,[=,[cdr,sys_iter],[length,sequence]],[and,end,[=,end,[cdr,sys_iter]]]]],[1,[<,[cdr,sys_iter],start]],[2,[or,[null,[cadr,sys_iter]],[and,end,[=,end,[caddr,sys_iter]]]]],[t,[or,[null,[cadr,sys_iter]],[<,[caddr,sys_iter],start]]]]]).
wl:arglist_info(sys_seq_end_p,f_sys_seq_end_p1,[sequence,sys_iter,c38_key,start,end,sys_from_end],arginfo{all:[sequence,sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[start,end,sys_from_end],names:[sequence,sys_iter,start,end,sys_from_end],opt:0,req:[sequence,sys_iter],rest:0,sublists:0,whole:0}).
wl:init_args(2,f_sys_seq_end_p1).

/*

### Compiled:  `SYS::SEQ-END-P` 
*/
f_sys_seq_end_p1(_268044068,_268044916,_268037550,_268037216):-_278216904=[bv(sequence,_268044068),bv(sys_iter,_268044916),bv(start,_268045716),bv(end,_268046390),bv(sys_from_end,_268047256)|_264935688],global_env(_264935688),get_kw(_264935688,_268037550,start,start,_268045716,[]=_268045716,_268043116),get_kw(_264935688,_268037550,end,end,_268046390,[]=_268046390,_268042508),get_kw(_264935688,_268037550,sys_from_end,sys_from_end,_268047256,[]=_268047256,_268041984),catch((get_var(_278216904,sys_iter,_268053972),cl_car(_268053972,_268055280),(is_eq(_268055280,0)->(get_var(_278216904,sys_iter,_268411912),cl_cdr(_268411912,_280337278),get_var(_278216904,sequence,_268414150),cl_length(_268414150,_268413076),=(_280337278,_268413076,_268430044),_268430044\==[],_268555034=_268430044->true;get_var(_278216904,end,_268417272),(_268417272\==[]->get_var(_278216904,end,_268419906),get_var(_278216904,sys_iter,_268421298),cl_cdr(_268421298,_280345508),=(_268419906,_280345508,_268423862),_268416544=_268423862;_268416544=[]),_268555034=_268416544),_268049278=_268555034;(is_eq(_268055280,1)->get_var(_278216904,sys_iter,_268460698),cl_cdr(_268460698,_280350754),get_var(_278216904,start,_268462702),<(_280350754,_268462702,_268546354),_268555382=_268546354;(is_eq(_268055280,2)->(get_var(_278216904,sys_iter,_268474788),cl_cadr(_268474788,_268473882),cl_null(_268473882,_268490376),_268490376\==[],_268539338=_268490376->true;get_var(_278216904,end,_268477562),(_268477562\==[]->get_var(_278216904,end,_268480208),get_var(_278216904,sys_iter,_268481612),cl_caddr(_268481612,_280362082),=(_268480208,_280362082,_268484194),_268476834=_268484194;_268476834=[]),_268539338=_268476834),_268546702=_268539338;(get_var(_278216904,sys_iter,_268516100),cl_cadr(_268516100,_278875512),cl_null(_278875512,_268522950),_268522950\==[],_268539686=_268522950->true;get_var(_278216904,sys_iter,_268519078),cl_caddr(_268519078,_280370142),get_var(_278216904,start,_268521106),<(_280370142,_268521106,_268518104),_268539686=_268518104),_268546702=_268539686),_268555382=_268546702),_268049278=_268555382),_268049278=_268037216),block_exit(sys_seq_end_p,_268037216),true).
wl:lambda_def(defun,sys_seq_result,f_sys_seq_result1,[sequence,sys_iter,sys_result],[[case,[car,sys_iter],[0,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,[reverse,sys_result]]],[1,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,sys_result]],[2,[reverse,sys_result]],[3,sys_result]]]).
wl:arglist_info(sys_seq_result,f_sys_seq_result1,[sequence,sys_iter,sys_result],arginfo{all:[sequence,sys_iter,sys_result],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter,sys_result],opt:0,req:[sequence,sys_iter,sys_result],rest:0,sublists:0,whole:0}).
wl:init_args(exact_only,f_sys_seq_result1).

/*

### Compiled:  `SYS::SEQ-RESULT` 
*/
f_sys_seq_result1(_268670148,_268671050,_268669164,_268668932):-_278243638=[bv(sequence,_268670148),bv(sys_iter,_268671050),bv(sys_result,_268669164)|_264935688],global_env(_264935688),catch((get_var(_278243638,sys_iter,_268676444),cl_car(_268676444,_268677806),(is_eq(_268677806,0)->get_var(_278243638,sys_result,_268924488),cl_length(_268924488,_280388322),get_var(_278243638,sequence,_268927498),cl_array_element_type(_268927498,_268926424),get_var(_278243638,sys_result,_268929654),cl_reverse(_268929654,_268928664),cl_make_array([_280388322,kw_element_type,_268926424,kw_initial_contents,_268928664],_268993572),_268673154=_268993572;(is_eq(_268677806,1)->get_var(_278243638,sys_result,_268950694),cl_length(_268950694,_280397040),get_var(_278243638,sequence,_268952866),cl_array_element_type(_268952866,_280399354),get_var(_278243638,sys_result,_268954908),cl_make_array([_280397040,kw_element_type,_280399354,kw_initial_contents,_268954908],_268987656),_268993920=_268987656;(is_eq(_268677806,2)->get_var(_278243638,sys_result,_268973060),cl_reverse(_268973060,_268984508),_268988004=_268984508;(is_eq(_268677806,3)->get_var(_278243638,sys_result,_268979666),_268984856=_268979666;_268982892=[],_268984856=_268982892),_268988004=_268984856),_268993920=_268988004),_268673154=_268993920),_268673154=_268668932),block_exit(sys_seq_result,_268668932),true).
:-cl_defun(subst,[sys_new,sys_old,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,sys_old,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,sys_old,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(satisfies),sys_old,sys_tree,rest],sys_new,sys_tree]],_269095838),cl_defun(subst_if,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(sys_satisfies_if),predicate,sys_tree,rest],sys_new,sys_tree]],_280412858),cl_defun(subst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(sys_satisfies_if_not),predicate,sys_tree,rest],sys_new,sys_tree]],_280414992),cl_defun(nsubst,[sys_new,sys_old,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,sys_old,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,sys_old,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(satisfies),sys_old,sys_tree,rest],sys_new,sys_tree]],_280417126),cl_defun(nsubst_if,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(sys_satisfies_if),predicate,sys_tree,rest],sys_new,sys_tree]],_280419260),cl_defun(nsubst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(sys_satisfies_if_not),predicate,sys_tree,rest],sys_new,sys_tree]],_280421394),cl_defun(assoc_if,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if),predicate,[car,sys_elem],rest],[return_from,assoc_if,sys_elem]]],_280423528),cl_defun(assoc_if_not,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if_not),predicate,[car,sys_elem],rest],[return_from,assoc_if_not,sys_elem]]],_280425166),cl_defun(rassoc,[item,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(satisfies),item,[cdr,sys_elem],rest],[return_from,rassoc,sys_elem]]],_280426804),cl_defun(rassoc_if,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if),predicate,[cdr,sys_elem],rest],[return_from,rassoc_if,sys_elem]]],_280428442),cl_defun(rassoc_if_not,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if_not),predicate,[cdr,sys_elem],rest],[return_from,rassoc_if_not,sys_elem]]],_280430080),cl_defun(adjoin,[item,list,c38_rest,rest],[dolist,[sys_elem,list,[cons,item,list]],[when,[apply,function(satisfies),item,sys_elem,rest],[return_from,adjoin,list]]],_280431718),cl_defun(set_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],[let,[[sys_result,[]]],[dolist,[item,sys_list_1],[unless,[apply,function(member),[if,key,[funcall,key,item],item],sys_list_2,rest],[push,item,sys_result]]],[dolist,[item,sys_list_2],[block,sys_matches,[dolist,[sys_elem,sys_list_1],[when,[apply,function(satisfies),[if,key,[funcall,key,sys_elem],sys_elem],item,rest],[return_from,sys_matches]]],[push,item,sys_result]]],sys_result],_280433356),cl_defun(nset_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],[let,[[sys_result,[]],[list,[]],[item,[]]],[tagbody,sys_start_1,[unless,sys_list_1,[go,sys_start_2]],[setf,item,[car,sys_list_1]],[setf,list,sys_list_2],[setf,sys_prev,[]],sys_start_1_in,[unless,list,[go,sys_end_1_in]],[let,[[sys_elem,[if,key,[funcall,key,[car,list]],[car,list]]]],[when,[apply,function(satisfies),item,[if,key,[funcall,key,sys_elem],sys_elem],rest],[if,sys_prev,[setf,[cdr,sys_prev],[cdr,list]],[setf,sys_list_2,[cdr,list]]],[setf,sys_list_1,[cdr,sys_list_1]],[go,sys_start_1]]],[setf,sys_prev,list],[setf,list,[cdr,list]],[go,sys_start_1_in],sys_end_1_in,[setf,item,[cdr,sys_list_1]],[setf,[cdr,sys_list_1],sys_result],[unless,sys_result,[setf,end,sys_list_1]],[setf,sys_result,sys_list_1],[setf,sys_list_1,item],[go,sys_start_1],sys_start_2,[return_from,nset_exclusive_or,[if,end,[progn,[setf,[cdr,end],sys_list_2],sys_result],sys_list_2]]]],_280435242),cl_defun(fill,[sequence,item,c38_rest,rest],[[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[sys_seq_set,sequence,sys_iter,item],[sys_seq_next,sys_iter],[go,start]]]],sequence],_280436880),cl_defun(every,[predicate,c38_rest,sys_sequences],[[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[unless,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,[]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],t],_280438766),cl_defun(some,[predicate,c38_rest,sys_sequences],[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[let,[[sys_result,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]]]],[when,sys_result,[return_from,some,sys_result]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],_280441148),cl_defun(notevery,[predicate,c38_rest,sys_sequences],[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[unless,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,t]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],_280443530),cl_defun(notany,[predicate,c38_rest,sys_sequences],[[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[when,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,[]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],t],_280445912),cl_defun(map_into,[sys_result_sequence,function,c38_rest,sys_sequences],[[let,[[sys_result_iter,[sys_seq_start,sys_result_sequence]],[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[sys_seq_set,sys_result_sequence,sys_result_iter,[apply,function,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]]],[sys_seq_next,sys_result_iter],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],sys_result_sequence],_280448294),cl_defun(reduce,[function,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]]],[if,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[funcall,function],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[sys_seq_next,sys_iter],[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[tagbody,start,[setq,sys_elem,[funcall,function,sys_elem,[sys_seq_ref,sequence,sys_iter]]],[sys_seq_next,sys_iter],[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[go,start]]]],sys_elem]]],_280450676),cl_defun(count,[item,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(satisfies),item,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count],_280453058),cl_defun(count_if,[predicate,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(sys_satisfies_if),predicate,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count],_280455192),cl_defun(count_if_not,[predicate,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(sys_satisfies_if_not),predicate,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count],_280457326),cl_defun(remove,[item,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(satisfies),item,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]],_280459460),cl_defun(remove_if,[predicate,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(sys_satisfies_if),predicate,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]],_280461594),cl_defun(remove_if_not,[predicate,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(sys_satisfies_if_not),predicate,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]],_264759222).
/*
:-side_effect(assert_lsp(satisfies,lambda_def(defun,satisfies,cl_satisfies1,[sys_object,sys_elem,c38_key,key,test,sys_test_not],[[let_xx,[[sys_zi,[if,key,[funcall,key,sys_elem],sys_elem]],[sys_r,[funcall,[or,test,sys_test_not,function(eql)],sys_object,sys_zi]]],[if,sys_test_not,[not,sys_r],sys_r]]]))).
*/
/*
:-side_effect(assert_lsp(satisfies,arglist_info(satisfies,cl_satisfies1,[sys_object,sys_elem,c38_key,key,test,sys_test_not],arginfo{all:[sys_object,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key,test,sys_test_not],names:[sys_object,sys_elem,key,test,sys_test_not],opt:0,req:[sys_object,sys_elem],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(satisfies,init_args(2,cl_satisfies1))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if,lambda_def(defun,sys_satisfies_if,f_sys_satisfies_if1,[predicate,sys_elem,c38_key,key],[[funcall,predicate,[if,key,[funcall,key,sys_elem],sys_elem]]]))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if,arglist_info(sys_satisfies_if,f_sys_satisfies_if1,[predicate,sys_elem,c38_key,key],arginfo{all:[predicate,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key],names:[predicate,sys_elem,key],opt:0,req:[predicate,sys_elem],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if,init_args(2,f_sys_satisfies_if1))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if_not,lambda_def(defun,sys_satisfies_if_not,f_sys_satisfies_if_not1,[predicate,sys_elem,c38_key,key],[[not,[funcall,predicate,[if,key,[funcall,key,sys_elem],sys_elem]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if_not,arglist_info(sys_satisfies_if_not,f_sys_satisfies_if_not1,[predicate,sys_elem,c38_key,key],arginfo{all:[predicate,sys_elem],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[key],names:[predicate,sys_elem,key],opt:0,req:[predicate,sys_elem],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_satisfies_if_not,init_args(2,f_sys_satisfies_if_not1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_start,lambda_def(defun,sys_seq_start,f_sys_seq_start1,[sequence,c38_key,[start,0],end,sys_from_end],[[if,[listp,sequence],[if,sys_from_end,[let,[[sys_acc,[]],[sequence,[nthcdr,start,sequence]]],[tagbody,start,[when,[and,sequence,[or,[not,end],[<,start,end]]],[push,sequence,sys_acc],[setf,sequence,[cdr,sequence]],[setf,start,[+,1,start]],[go,start]]],[list,3,sys_acc,start]],[list,2,[nthcdr,start,sequence],start]],[if,sys_from_end,[cons,1,[-,end,1]],[cons,0,start]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_start,arglist_info(sys_seq_start,f_sys_seq_start1,[sequence,c38_key,[start,0],end,sys_from_end],arginfo{all:[sequence],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[start,end,sys_from_end],names:[sequence,start,end,sys_from_end],opt:0,req:[sequence],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_start,init_args(1,f_sys_seq_start1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_position,lambda_def(defun,sys_seq_position,f_sys_seq_position1,[sys_iter],[[case,[car,sys_iter],[[0,1],[cdr,sys_iter]],[t,[caddr,sys_iter]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_position,arglist_info(sys_seq_position,f_sys_seq_position1,[sys_iter],arginfo{all:[sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_iter],opt:0,req:[sys_iter],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_position,init_args(exact_only,f_sys_seq_position1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_next,lambda_def(defun,sys_seq_next,f_sys_seq_next1,[sys_iter],[[case,[car,sys_iter],[0,[setf,[cdr,sys_iter],[+,1,[cdr,sys_iter]]]],[1,[setf,[cdr,sys_iter],[-,[cdr,sys_iter],1]]],[2,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[+,1,[caddr,sys_iter]]]],[t,[setf,[cadr,sys_iter],[cdadr,sys_iter]],[setf,[caddr,sys_iter],[-,[caddr,sys_iter],1]]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_next,arglist_info(sys_seq_next,f_sys_seq_next1,[sys_iter],arginfo{all:[sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sys_iter],opt:0,req:[sys_iter],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_next,init_args(exact_only,f_sys_seq_next1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_ref,lambda_def(defun,sys_seq_ref,f_sys_seq_ref1,[sequence,sys_iter],[[case,[car,sys_iter],[[0,1],[aref,sequence,[cdr,sys_iter]]],[2,[caadr,sys_iter]],[t,[caaadr,sys_iter]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_ref,arglist_info(sys_seq_ref,f_sys_seq_ref1,[sequence,sys_iter],arginfo{all:[sequence,sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter],opt:0,req:[sequence,sys_iter],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_ref,init_args(exact_only,f_sys_seq_ref1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_set,lambda_def(defun,sys_seq_set,f_sys_seq_set1,[sequence,sys_iter,sys_value],[[case,[car,sys_iter],[[0,1],[setf,[aref,sequence,[cdr,sys_iter]],sys_value]],[2,[setf,[caadr,sys_iter],sys_value]],[t,[setf,[caaadr,sys_iter],sys_value]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_set,arglist_info(sys_seq_set,f_sys_seq_set1,[sequence,sys_iter,sys_value],arginfo{all:[sequence,sys_iter,sys_value],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter,sys_value],opt:0,req:[sequence,sys_iter,sys_value],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_set,init_args(exact_only,f_sys_seq_set1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_end_p,lambda_def(defun,sys_seq_end_p,f_sys_seq_end_p1,[sequence,sys_iter,c38_key,start,end,sys_from_end],[[case,[car,sys_iter],[0,[or,[=,[cdr,sys_iter],[length,sequence]],[and,end,[=,end,[cdr,sys_iter]]]]],[1,[<,[cdr,sys_iter],start]],[2,[or,[null,[cadr,sys_iter]],[and,end,[=,end,[caddr,sys_iter]]]]],[t,[or,[null,[cadr,sys_iter]],[<,[caddr,sys_iter],start]]]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_end_p,arglist_info(sys_seq_end_p,f_sys_seq_end_p1,[sequence,sys_iter,c38_key,start,end,sys_from_end],arginfo{all:[sequence,sys_iter],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:[start,end,sys_from_end],names:[sequence,sys_iter,start,end,sys_from_end],opt:0,req:[sequence,sys_iter],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_end_p,init_args(2,f_sys_seq_end_p1))).
*/
/*
:-side_effect(assert_lsp(sys_seq_result,lambda_def(defun,sys_seq_result,f_sys_seq_result1,[sequence,sys_iter,sys_result],[[case,[car,sys_iter],[0,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,[reverse,sys_result]]],[1,[make_array,[length,sys_result],kw_element_type,[array_element_type,sequence],kw_initial_contents,sys_result]],[2,[reverse,sys_result]],[3,sys_result]]]))).
*/
/*
:-side_effect(assert_lsp(sys_seq_result,arglist_info(sys_seq_result,f_sys_seq_result1,[sequence,sys_iter,sys_result],arginfo{all:[sequence,sys_iter,sys_result],allow_other_keys:0,aux:0,body:0,complex:0,env:0,key:0,names:[sequence,sys_iter,sys_result],opt:0,req:[sequence,sys_iter,sys_result],rest:0,sublists:0,whole:0}))).
*/
/*
:-side_effect(assert_lsp(sys_seq_result,init_args(exact_only,f_sys_seq_result1))).
*/
/*
:-was_info(((assert_lsp(subst,wl:lambda_def(defun,subst,cl_subst,[sys_new,sys_old,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,sys_old,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,sys_old,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(satisfies),sys_old,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(subst,wl:arglist_info(subst,cl_subst,[sys_new,sys_old,sys_tree,c38_rest,rest],arginfo{all:[sys_new,sys_old,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,sys_old,sys_tree,rest],opt:0,req:[sys_new,sys_old,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(subst,wl:init_args(3,cl_subst)),assert_lsp(subst,(cl_subst(_287233678,_287233712,_287233758,_287233342,_287233008):-_287232470=[bv(sys_new,_287233678),bv(sys_old,_287233712),bv(sys_tree,_287233758),bv(rest,_287233342),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_287232470,if,_287274798),get_var(_287232470,sys_tree,_287288642),cl_consp(_287288642,_287288574),get_var(_287232470,sys_new,_287294254),get_var(_287232470,sys_old,_287295416),get_var(_287232470,sys_tree,_287297484),cl_car(_287297484,_287296578),get_var(_287232470,rest,_287298480),cl_subst(_287294254,_287295416,_287296578,_287298480,_287294032),get_var(_287232470,sys_new,_287302474),get_var(_287232470,sys_old,_287303668),get_var(_287232470,sys_tree,_287305024),cl_cdr(_287305024,_287700158),get_var(_287232470,rest,_287306812),cl_subst(_287302474,_287303668,_287700158,_287306812,_287301508),_287293560=[bv(sys_a,_287294032),bv(sys_d,_287301508)|_287232470],get_var(_287293560,sys_a,_287333656),get_var(_287293560,sys_tree,_287331954),cl_car(_287331954,_287331100),(is_eq(_287333656,_287331100)->get_var(_287293560,sys_d,_287334288),get_var(_287293560,sys_tree,_287336284),cl_cdr(_287336284,_287708986),cl_eq(_287334288,_287708986,_287338718),_287328178=_287338718;_287328178=[]),(_287328178\==[]->get_var(_287293560,sys_tree,_287346584),_287293348=_287346584;get_var(_287293560,sys_a,_287347798),get_var(_287293560,sys_d,_287348902),_287350882=[_287347798|_287348902],_287293348=_287350882),get_var(_287232470,sys_old,_287373370),get_var(_287232470,sys_tree,_287374612),get_var(_287232470,rest,_287375878),cl_satisfies(_287373370,_287374612,_287375878,_287372046),(_287372046\==[]->get_var(_287232470,sys_new,_287378620),_287272502=_287378620;get_var(_287232470,sys_tree,_287379850),_287272502=_287379850),_287272502=_287233008),block_exit(subst,_287233008),true)))),(set_opv(cl_subst,classof,claz_function),set_opv(subst,compile_as,kw_function),set_opv(subst,function,cl_subst)),_287490234=subst)).
*/
/*
:-was_info(((assert_lsp(subst_if,wl:lambda_def(defun,subst_if,cl_subst_if,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(sys_satisfies_if),predicate,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(subst_if,wl:arglist_info(subst_if,cl_subst_if,[sys_new,predicate,sys_tree,c38_rest,rest],arginfo{all:[sys_new,predicate,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,predicate,sys_tree,rest],opt:0,req:[sys_new,predicate,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(subst_if,wl:init_args(3,cl_subst_if)),assert_lsp(subst_if,(cl_subst_if(_288058894,_288059808,_288071910,_288046406,_288046072):-_288347138=[bv(sys_new,_288058894),bv(predicate,_288059808),bv(sys_tree,_288071910),bv(rest,_288046406),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_288347138,if,_288077408),get_var(_288347138,sys_tree,_288091344),cl_consp(_288091344,_288494278),get_var(_288347138,sys_new,_288096934),get_var(_288347138,predicate,_288098368),get_var(_288347138,sys_tree,_288099742),cl_car(_288099742,_288497608),get_var(_288347138,rest,_288101524),cl_subst(_288096934,_288098368,_288497608,_288101524,_288120528),get_var(_288347138,sys_new,_288104752),get_var(_288347138,predicate,_288106198),get_var(_288347138,sys_tree,_288107578),cl_cdr(_288107578,_288502474),get_var(_288347138,rest,_288109366),cl_subst(_288104752,_288106198,_288502474,_288109366,_288129548),_288095496=[bv(sys_a,_288120528),bv(sys_d,_288129548)|_288347138],get_var(_288095496,sys_a,_288133302),get_var(_288095496,sys_tree,_288134646),cl_car(_288134646,_288136770),(is_eq(_288133302,_288136770)->get_var(_288095496,sys_d,_288137638),get_var(_288095496,sys_tree,_288138994),cl_cdr(_288138994,_288511232),cl_eq(_288137638,_288511232,_288141428),_288130850=_288141428;_288130850=[]),(_288130850\==[]->get_var(_288095496,sys_tree,_288149294),_288095284=_288149294;get_var(_288095496,sys_a,_288150508),get_var(_288095496,sys_d,_288151612),_288153592=[_288150508|_288151612],_288095284=_288153592),get_var(_288347138,predicate,_288176332),get_var(_288347138,sys_tree,_288177598),get_var(_288347138,rest,_288178864),f_sys_satisfies_if(_288176332,_288177598,_288178864,_288174756),(_288174756\==[]->get_var(_288347138,sys_new,_288181740),_288074426=_288181740;get_var(_288347138,sys_tree,_288182970),_288074426=_288182970),_288074426=_288046072),block_exit(subst_if,_288046072),true)))),(set_opv(cl_subst_if,classof,claz_function),set_opv(subst_if,compile_as,kw_function),set_opv(subst_if,function,cl_subst_if)),_280412858=subst_if)).
*/
/*
:-was_info(((assert_lsp(subst_if_not,wl:lambda_def(defun,subst_if_not,cl_subst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[let,[[sys_a,[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[sys_d,[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]]],[if,[and,[eq,sys_a,[car,sys_tree]],[eq,sys_d,[cdr,sys_tree]]],sys_tree,[cons,sys_a,sys_d]]],[if,[apply,function(sys_satisfies_if_not),predicate,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(subst_if_not,wl:arglist_info(subst_if_not,cl_subst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],arginfo{all:[sys_new,predicate,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,predicate,sys_tree,rest],opt:0,req:[sys_new,predicate,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(subst_if_not,wl:init_args(3,cl_subst_if_not)),assert_lsp(subst_if_not,(cl_subst_if_not(_288867842,_288868756,_288880858,_288855354,_288855020):-_289156158=[bv(sys_new,_288867842),bv(predicate,_288868756),bv(sys_tree,_288880858),bv(rest,_288855354),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_289156158,if,_288886356),get_var(_289156158,sys_tree,_288900292),cl_consp(_288900292,_289303298),get_var(_289156158,sys_new,_288905882),get_var(_289156158,predicate,_288907316),get_var(_289156158,sys_tree,_288908690),cl_car(_288908690,_289306628),get_var(_289156158,rest,_288910472),cl_subst(_288905882,_288907316,_289306628,_288910472,_288929476),get_var(_289156158,sys_new,_288913700),get_var(_289156158,predicate,_288915146),get_var(_289156158,sys_tree,_288916526),cl_cdr(_288916526,_289311494),get_var(_289156158,rest,_288918314),cl_subst(_288913700,_288915146,_289311494,_288918314,_288938496),_288904444=[bv(sys_a,_288929476),bv(sys_d,_288938496)|_289156158],get_var(_288904444,sys_a,_288942250),get_var(_288904444,sys_tree,_288943594),cl_car(_288943594,_288945718),(is_eq(_288942250,_288945718)->get_var(_288904444,sys_d,_288946586),get_var(_288904444,sys_tree,_288947942),cl_cdr(_288947942,_289320252),cl_eq(_288946586,_289320252,_288950376),_288939798=_288950376;_288939798=[]),(_288939798\==[]->get_var(_288904444,sys_tree,_288958242),_288904232=_288958242;get_var(_288904444,sys_a,_288959456),get_var(_288904444,sys_d,_288960560),_288962540=[_288959456|_288960560],_288904232=_288962540),get_var(_289156158,predicate,_288985280),get_var(_289156158,sys_tree,_288986546),get_var(_289156158,rest,_288987812),f_sys_satisfies_if_not(_288985280,_288986546,_288987812,_288983704),(_288983704\==[]->get_var(_289156158,sys_new,_288990760),_288883374=_288990760;get_var(_289156158,sys_tree,_288991990),_288883374=_288991990),_288883374=_288855020),block_exit(subst_if_not,_288855020),true)))),(set_opv(cl_subst_if_not,classof,claz_function),set_opv(subst_if_not,compile_as,kw_function),set_opv(subst_if_not,function,cl_subst_if_not)),_280414992=subst_if_not)).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_289741898,_289741726],[sys_tree,_289741898,_289741726]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_289835446,_289835274],[sys_tree,_289835446,_289835274]),setf_inverse_op(car,sys_set_car))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_289929120,_289928948],[sys_tree,_289929120,_289928948]),setf_inverse_op(car,setf_car))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_290022822,_290022650],[sys_tree,_290022822,_290022650]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_290128200,_290128028],[sys_tree,_290128200,_290128028]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_290222960,_290222788],[sys_tree,_290222960,_290222788]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_290317846,_290317674],[sys_tree,_290317846,_290317674]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_289668694,[],[],true),append([sys_tree],[_290412760,_290412588],[sys_tree,_290412760,_290412588]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-was_info(((assert_lsp(nsubst,wl:lambda_def(defun,nsubst,cl_nsubst,[sys_new,sys_old,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,sys_old,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,sys_old,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(satisfies),sys_old,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(nsubst,wl:arglist_info(nsubst,cl_nsubst,[sys_new,sys_old,sys_tree,c38_rest,rest],arginfo{all:[sys_new,sys_old,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,sys_old,sys_tree,rest],opt:0,req:[sys_new,sys_old,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(nsubst,wl:init_args(3,cl_nsubst)),assert_lsp(nsubst,(cl_nsubst(_289682054,_289694094,_289706224,_289669566,_289669232):-_290653600=[bv(sys_new,_289682054),bv(sys_old,_289694094),bv(sys_tree,_289706224),bv(rest,_289669566),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_290653600,if,_289710958),get_var(_290653600,sys_tree,_289724652),cl_consp(_289724652,_290773250),get_var(_290653600,sys_tree,_290102944),get_var(_290653600,sys_new,_290104358),get_var(_290653600,sys_old,_290105540),get_var(_290653600,sys_tree,_290106884),cl_car(_290106884,_290777292),get_var(_290653600,rest,_290108672),cl_subst(_290104358,_290105540,_290777292,_290108672,_290103552),cl_rplaca(_290102944,_290103552,_289727816),get_var(_290653600,sys_tree,_290494094),get_var(_290653600,sys_new,_290495520),get_var(_290653600,sys_old,_290496714),get_var(_290653600,sys_tree,_290498070),cl_cdr(_290498070,_290784828),get_var(_290653600,rest,_290499870),cl_subst(_290495520,_290496714,_290784828,_290499870,_290786836),cl_rplacd(_290494094,_290786836,_290114118),get_var(_290653600,sys_tree,_290505606),get_var(_290653600,sys_old,_290523176),get_var(_290653600,sys_tree,_290524418),get_var(_290653600,rest,_290525684),cl_satisfies(_290523176,_290524418,_290525684,_290521852),(_290521852\==[]->get_var(_290653600,sys_new,_290528426),_289708516=_290528426;get_var(_290653600,sys_tree,_290529656),_289708516=_290529656),_289708516=_289669232),block_exit(nsubst,_289669232),true)))),(set_opv(cl_nsubst,classof,claz_function),set_opv(nsubst,compile_as,kw_function),set_opv(nsubst,function,cl_nsubst)),_280417126=nsubst)).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291150082,_291149910],[sys_tree,_291150082,_291149910]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291247734,_291247562],[sys_tree,_291247734,_291247562]),setf_inverse_op(car,sys_set_car))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291345512,_291345340],[sys_tree,_291345512,_291345340]),setf_inverse_op(car,setf_car))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291443318,_291443146],[sys_tree,_291443318,_291443146]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291553082,_291552910],[sys_tree,_291553082,_291552910]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291651946,_291651774],[sys_tree,_291651946,_291651774]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291750936,_291750764],[sys_tree,_291750936,_291750764]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_291088106,[],[],true),append([sys_tree],[_291849954,_291849782],[sys_tree,_291849954,_291849782]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-was_info(((assert_lsp(nsubst_if,wl:lambda_def(defun,nsubst_if,cl_nsubst_if,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(sys_satisfies_if),predicate,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(nsubst_if,wl:arglist_info(nsubst_if,cl_nsubst_if,[sys_new,predicate,sys_tree,c38_rest,rest],arginfo{all:[sys_new,predicate,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,predicate,sys_tree,rest],opt:0,req:[sys_new,predicate,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(nsubst_if,wl:init_args(3,cl_nsubst_if)),assert_lsp(nsubst_if,(cl_nsubst_if(_291101466,_291102380,_291114482,_291088978,_291088644):-_292095292=[bv(sys_new,_291101466),bv(predicate,_291102380),bv(sys_tree,_291114482),bv(rest,_291088978),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_292095292,if,_291119170),get_var(_292095292,sys_tree,_291132836),cl_consp(_291132836,_292214942),get_var(_292095292,sys_tree,_291527544),get_var(_292095292,sys_new,_291528958),get_var(_292095292,predicate,_291530392),get_var(_292095292,sys_tree,_291531766),cl_car(_291531766,_292218984),get_var(_292095292,rest,_291533554),cl_subst(_291528958,_291530392,_292218984,_291533554,_292220992),cl_rplaca(_291527544,_292220992,_292222468),get_var(_292095292,sys_tree,_291935392),get_var(_292095292,sys_new,_291936818),get_var(_292095292,predicate,_291938264),get_var(_292095292,sys_tree,_291939644),cl_cdr(_291939644,_292226560),get_var(_292095292,rest,_291941444),cl_subst(_291936818,_291938264,_292226560,_291941444,_292228568),cl_rplacd(_291935392,_292228568,_292230044),get_var(_292095292,sys_tree,_291947180),get_var(_292095292,predicate,_291965002),get_var(_292095292,sys_tree,_291966268),get_var(_292095292,rest,_291967534),f_sys_satisfies_if(_291965002,_291966268,_291967534,_291963426),(_291963426\==[]->get_var(_292095292,sys_new,_291970410),_291116728=_291970410;get_var(_292095292,sys_tree,_291971640),_291116728=_291971640),_291116728=_291088644),block_exit(nsubst_if,_291088644),true)))),(set_opv(cl_nsubst_if,classof,claz_function),set_opv(nsubst_if,compile_as,kw_function),set_opv(nsubst_if,function,cl_nsubst_if)),_280419260=nsubst_if)).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_292596276,_292596104],[sys_tree,_292596276,_292596104]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_292698104,_292697932],[sys_tree,_292698104,_292697932]),setf_inverse_op(car,sys_set_car))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_292800058,_292799886],[sys_tree,_292800058,_292799886]),setf_inverse_op(car,setf_car))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_292902040,_292901868],[sys_tree,_292902040,_292901868]),setf_inverse_op(car,rplaca))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_293015980,_293015808],[sys_tree,_293015980,_293015808]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_293119020,_293118848],[sys_tree,_293119020,_293118848]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_293222186,_293222014],[sys_tree,_293222186,_293222014]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_292534300,[],[],true),append([sys_tree],[_293325380,_293325208],[sys_tree,_293325380,_293325208]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-was_info(((assert_lsp(nsubst_if_not,wl:lambda_def(defun,nsubst_if_not,cl_nsubst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],[if,[consp,sys_tree],[progn,[setf,[car,sys_tree],[apply,function(subst),sys_new,predicate,[car,sys_tree],rest]],[setf,[cdr,sys_tree],[apply,function(subst),sys_new,predicate,[cdr,sys_tree],rest]],sys_tree],[if,[apply,function(sys_satisfies_if_not),predicate,sys_tree,rest],sys_new,sys_tree]])),assert_lsp(nsubst_if_not,wl:arglist_info(nsubst_if_not,cl_nsubst_if_not,[sys_new,predicate,sys_tree,c38_rest,rest],arginfo{all:[sys_new,predicate,sys_tree],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_new,predicate,sys_tree,rest],opt:0,req:[sys_new,predicate,sys_tree],rest:[rest],sublists:0,whole:0})),assert_lsp(nsubst_if_not,wl:init_args(3,cl_nsubst_if_not)),assert_lsp(nsubst_if_not,(cl_nsubst_if_not(_292547660,_292548574,_292560676,_292535172,_292534838):-_293574966=[bv(sys_new,_292547660),bv(predicate,_292548574),bv(sys_tree,_292560676),bv(rest,_292535172),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_293574966,if,_292565364),get_var(_293574966,sys_tree,_292579030),cl_consp(_292579030,_293694616),get_var(_293574966,sys_tree,_292990442),get_var(_293574966,sys_new,_292991856),get_var(_293574966,predicate,_292993290),get_var(_293574966,sys_tree,_292994664),cl_car(_292994664,_293698658),get_var(_293574966,rest,_292996452),cl_subst(_292991856,_292993290,_293698658,_292996452,_293700666),cl_rplaca(_292990442,_293700666,_293702142),get_var(_293574966,sys_tree,_293414994),get_var(_293574966,sys_new,_293416420),get_var(_293574966,predicate,_293417866),get_var(_293574966,sys_tree,_293419246),cl_cdr(_293419246,_293706234),get_var(_293574966,rest,_293421046),cl_subst(_293416420,_293417866,_293706234,_293421046,_293708242),cl_rplacd(_293414994,_293708242,_293709718),get_var(_293574966,sys_tree,_293426782),get_var(_293574966,predicate,_293444604),get_var(_293574966,sys_tree,_293445870),get_var(_293574966,rest,_293447136),f_sys_satisfies_if_not(_293444604,_293445870,_293447136,_293443028),(_293443028\==[]->get_var(_293574966,sys_new,_293450084),_292562922=_293450084;get_var(_293574966,sys_tree,_293451314),_292562922=_293451314),_292562922=_292534838),block_exit(nsubst_if_not,_292534838),true)))),(set_opv(cl_nsubst_if_not,classof,claz_function),set_opv(nsubst_if_not,compile_as,kw_function),set_opv(nsubst_if_not,function,cl_nsubst_if_not)),_280421394=nsubst_if_not)).
*/
/*
:-was_info(((assert_lsp(assoc_if,wl:lambda_def(defun,assoc_if,cl_assoc_if,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if),predicate,[car,sys_elem],rest],[return_from,assoc_if,sys_elem]]])),assert_lsp(assoc_if,wl:arglist_info(assoc_if,cl_assoc_if,[predicate,sys_alist,c38_rest,rest],arginfo{all:[predicate,sys_alist],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_alist,rest],opt:0,req:[predicate,sys_alist],rest:[rest],sublists:0,whole:0})),assert_lsp(assoc_if,wl:init_args(2,cl_assoc_if)),assert_lsp(assoc_if,(cl_assoc_if(_294020368,_294019386,_294019022,_294018688):-_294018150=[bv(predicate,_294020368),bv(sys_alist,_294019386),bv(rest,_294019022),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_294018150,dolist,_294034908),get_var(_294018150,sys_alist,_294036646),f_sys_elem(_294036646,_294036578),get_var(_294018150,predicate,_294041540),get_var(_294018150,sys_elem,_294042914),cl_car(_294042914,_294203156),get_var(_294018150,rest,_294044744),f_sys_satisfies_if(_294041540,_294203156,_294044744,_294039928),(_294039928\==[]->get_var(_294018150,sys_elem,_294048966),throw(block_exit(assoc_if,_294048966)),_294034124=_294051900;_294034124=[]),_294034124=_294018688),block_exit(assoc_if,_294018688),true)))),(set_opv(cl_assoc_if,classof,claz_function),set_opv(assoc_if,compile_as,kw_function),set_opv(assoc_if,function,cl_assoc_if)),_280423528=assoc_if)).
*/
/*
:-was_info(((assert_lsp(assoc_if_not,wl:lambda_def(defun,assoc_if_not,cl_assoc_if_not,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if_not),predicate,[car,sys_elem],rest],[return_from,assoc_if_not,sys_elem]]])),assert_lsp(assoc_if_not,wl:arglist_info(assoc_if_not,cl_assoc_if_not,[predicate,sys_alist,c38_rest,rest],arginfo{all:[predicate,sys_alist],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_alist,rest],opt:0,req:[predicate,sys_alist],rest:[rest],sublists:0,whole:0})),assert_lsp(assoc_if_not,wl:init_args(2,cl_assoc_if_not)),assert_lsp(assoc_if_not,(cl_assoc_if_not(_294441224,_294453320,_294439878,_294439544):-_294470950=[bv(predicate,_294441224),bv(sys_alist,_294453320),bv(rest,_294439878),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_294470950,dolist,_294456638),get_var(_294470950,sys_alist,_294458370),f_sys_elem(_294458370,_294621470),get_var(_294470950,predicate,_294462456),get_var(_294470950,sys_elem,_294463830),cl_car(_294463830,_294624088),get_var(_294470950,rest,_294465660),f_sys_satisfies_if_not(_294462456,_294624088,_294465660,_294460844),(_294460844\==[]->get_var(_294470950,sys_elem,_294468834),throw(block_exit(assoc_if_not,_294468834)),_294455000=_294469198;_294455000=[]),_294455000=_294439544),block_exit(assoc_if_not,_294439544),true)))),(set_opv(cl_assoc_if_not,classof,claz_function),set_opv(assoc_if_not,compile_as,kw_function),set_opv(assoc_if_not,function,cl_assoc_if_not)),_280425166=assoc_if_not)).
*/
/*
:-was_info(((assert_lsp(rassoc,wl:lambda_def(defun,rassoc,cl_rassoc,[item,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(satisfies),item,[cdr,sys_elem],rest],[return_from,rassoc,sys_elem]]])),assert_lsp(rassoc,wl:arglist_info(rassoc,cl_rassoc,[item,sys_alist,c38_rest,rest],arginfo{all:[item,sys_alist],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[item,sys_alist,rest],opt:0,req:[item,sys_alist],rest:[rest],sublists:0,whole:0})),assert_lsp(rassoc,wl:init_args(2,cl_rassoc)),assert_lsp(rassoc,(cl_rassoc(_294863642,_294887882,_294863312,_294862978):-_294905046=[bv(item,_294863642),bv(sys_alist,_294887882),bv(rest,_294863312),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_294905046,dolist,_294891200),get_var(_294905046,sys_alist,_294892932),f_sys_elem(_294892932,_295055858),get_var(_294905046,item,_294896022),get_var(_294905046,sys_elem,_294898132),cl_cdr(_294898132,_295058486),get_var(_294905046,rest,_294899962),cl_satisfies(_294896022,_295058486,_294899962,_294895406),(_294895406\==[]->get_var(_294905046,sys_elem,_294902930),throw(block_exit(rassoc,_294902930)),_294889562=_294903294;_294889562=[]),_294889562=_294862978),block_exit(rassoc,_294862978),true)))),(set_opv(cl_rassoc,classof,claz_function),set_opv(rassoc,compile_as,kw_function),set_opv(rassoc,function,cl_rassoc)),_280426804=rassoc)).
*/
/*
:-was_info(((assert_lsp(rassoc_if,wl:lambda_def(defun,rassoc_if,cl_rassoc_if,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if),predicate,[cdr,sys_elem],rest],[return_from,rassoc_if,sys_elem]]])),assert_lsp(rassoc_if,wl:arglist_info(rassoc_if,cl_rassoc_if,[predicate,sys_alist,c38_rest,rest],arginfo{all:[predicate,sys_alist],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_alist,rest],opt:0,req:[predicate,sys_alist],rest:[rest],sublists:0,whole:0})),assert_lsp(rassoc_if,wl:init_args(2,cl_rassoc_if)),assert_lsp(rassoc_if,(cl_rassoc_if(_295300772,_295312868,_295299426,_295299092):-_295330426=[bv(predicate,_295300772),bv(sys_alist,_295312868),bv(rest,_295299426),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_295330426,dolist,_295316186),get_var(_295330426,sys_alist,_295317918),f_sys_elem(_295317918,_295480946),get_var(_295330426,predicate,_295322004),get_var(_295330426,sys_elem,_295323378),cl_cdr(_295323378,_295483564),get_var(_295330426,rest,_295325208),f_sys_satisfies_if(_295322004,_295483564,_295325208,_295320392),(_295320392\==[]->get_var(_295330426,sys_elem,_295328310),throw(block_exit(rassoc_if,_295328310)),_295314548=_295328674;_295314548=[]),_295314548=_295299092),block_exit(rassoc_if,_295299092),true)))),(set_opv(cl_rassoc_if,classof,claz_function),set_opv(rassoc_if,compile_as,kw_function),set_opv(rassoc_if,function,cl_rassoc_if)),_280428442=rassoc_if)).
*/
/*
:-was_info(((assert_lsp(rassoc_if_not,wl:lambda_def(defun,rassoc_if_not,cl_rassoc_if_not,[predicate,sys_alist,c38_rest,rest],[dolist,[sys_elem,sys_alist],[when,[apply,function(sys_satisfies_if_not),predicate,[cdr,sys_elem],rest],[return_from,rassoc_if_not,sys_elem]]])),assert_lsp(rassoc_if_not,wl:arglist_info(rassoc_if_not,cl_rassoc_if_not,[predicate,sys_alist,c38_rest,rest],arginfo{all:[predicate,sys_alist],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_alist,rest],opt:0,req:[predicate,sys_alist],rest:[rest],sublists:0,whole:0})),assert_lsp(rassoc_if_not,wl:init_args(2,cl_rassoc_if_not)),assert_lsp(rassoc_if_not,(cl_rassoc_if_not(_295728070,_295740166,_295726724,_295726390):-_295757796=[bv(predicate,_295728070),bv(sys_alist,_295740166),bv(rest,_295726724),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_295757796,dolist,_295743484),get_var(_295757796,sys_alist,_295745216),f_sys_elem(_295745216,_295908316),get_var(_295757796,predicate,_295749302),get_var(_295757796,sys_elem,_295750676),cl_cdr(_295750676,_295910934),get_var(_295757796,rest,_295752506),f_sys_satisfies_if_not(_295749302,_295910934,_295752506,_295747690),(_295747690\==[]->get_var(_295757796,sys_elem,_295755680),throw(block_exit(rassoc_if_not,_295755680)),_295741846=_295756044;_295741846=[]),_295741846=_295726390),block_exit(rassoc_if_not,_295726390),true)))),(set_opv(cl_rassoc_if_not,classof,claz_function),set_opv(rassoc_if_not,compile_as,kw_function),set_opv(rassoc_if_not,function,cl_rassoc_if_not)),_280430080=rassoc_if_not)).
*/
/*
:-was_info(((assert_lsp(adjoin,wl:lambda_def(defun,adjoin,cl_adjoin,[item,list,c38_rest,rest],[dolist,[sys_elem,list,[cons,item,list]],[when,[apply,function(satisfies),item,sys_elem,rest],[return_from,adjoin,list]]])),assert_lsp(adjoin,wl:arglist_info(adjoin,cl_adjoin,[item,list,c38_rest,rest],arginfo{all:[item,list],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[item,list,rest],opt:0,req:[item,list],rest:[rest],sublists:0,whole:0})),assert_lsp(adjoin,wl:init_args(2,cl_adjoin)),assert_lsp(adjoin,(cl_adjoin(_296168552,_296156450,_296156086,_296155752):-_296189996=[bv(item,_296168552),bv(list,_296156450),bv(rest,_296156086),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_296189996,dolist,_296172720),get_var(_296189996,list,_296173732),get_var(_296189996,item,_296175856),get_var(_296189996,list,_296177068),_296174978=[_296175856|_296177068],f_sys_elem(_296173732,_296174978,_296353732),get_var(_296189996,item,_296182580),get_var(_296189996,sys_elem,_296183816),get_var(_296189996,rest,_296185100),cl_satisfies(_296182580,_296183816,_296185100,_296181214),(_296181214\==[]->get_var(_296189996,list,_296187892),throw(block_exit(adjoin,_296187892)),_296171010=_296188256;_296171010=[]),_296171010=_296155752),block_exit(adjoin,_296155752),true)))),(set_opv(cl_adjoin,classof,claz_function),set_opv(adjoin,compile_as,kw_function),set_opv(adjoin,function,cl_adjoin)),_280431718=adjoin)).
*/
/*
:-was_info(((assert_lsp(set_exclusive_or,wl:lambda_def(defun,set_exclusive_or,cl_set_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],[let,[[sys_result,[]]],[dolist,[item,sys_list_1],[unless,[apply,function(member),[if,key,[funcall,key,item],item],sys_list_2,rest],[push,item,sys_result]]],[dolist,[item,sys_list_2],[block,sys_matches,[dolist,[sys_elem,sys_list_1],[when,[apply,function(satisfies),[if,key,[funcall,key,sys_elem],sys_elem],item,rest],[return_from,sys_matches]]],[push,item,sys_result]]],sys_result])),assert_lsp(set_exclusive_or,wl:arglist_info(set_exclusive_or,cl_set_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],arginfo{all:[sys_list_1,sys_list_2],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:[key],names:[sys_list_1,sys_list_2,rest,key],opt:0,req:[sys_list_1,sys_list_2],rest:[rest],sublists:0,whole:0})),assert_lsp(set_exclusive_or,wl:init_args(2,cl_set_exclusive_or)),assert_lsp(set_exclusive_or,(cl_set_exclusive_or(_296610318,_296610352,_296609956,_296609622):-_297019868=[bv(sys_list_1,_296610318),bv(sys_list_2,_296610352),bv(rest,_296609956),bv(key,_296637740),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),get_kw([name='TOPLEVEL',environ=env_2],_296609956,key,key,_296637740,[]=_296637740,_296612038),catch((get_var(_297019868,let,_296642082),f_sys_result([],_297078464),cl_apply(_297078464,[],_297192820),get_var(_297019868,sys_list_1,_296713214),_296712566=bv(item,_296712870),_296660622=[_296712566|_297019868],forall(member(_296712870,_296713214),(nb_setarg(2,_296712566,_296712870),get_var(_296660622,key,_296663234),(_296663234\==[]->get_var(_296660622,key,_296666132),get_var(_296660622,item,_296667416),cl_apply(_296666132,[_296667416],_296681902),_296662824=_296681902;get_var(_296660622,item,_296681138),_296662824=_296681138),get_var(_296660622,sys_list_2,_296684470),get_var(_296660622,rest,_296686544),cl_member(_296662824,_296684470,_296686544,_296662118),(_296662118\==[]->_296658910=[];cl_push(item,sys_result,_296692742),_296658910=_296692742))),get_var(_297019868,sys_list_2,_296720894),_296810552=bv(item,_296810920),_296810748=[_296810552|_297019868],forall(member(_296810920,_296720894),(nb_setarg(2,_296810552,_296810920),catch((get_var(_296810748,sys_list_1,_296724982),_296767786=bv(sys_elem,_296768154),_296745410=[_296767786|_296810748],forall(member(_296768154,_296724982),(nb_setarg(2,_296767786,_296768154),get_var(_296745410,key,_296728340),(_296728340\==[]->get_var(_296745410,key,_296731250),get_var(_296745410,sys_elem,_296732546),cl_apply(_296731250,[_296732546],_296735574),_296727930=_296735574;get_var(_296745410,sys_elem,_296734744),_296727930=_296734744),get_var(_296745410,item,_296738928),get_var(_296745410,rest,_296740164),cl_satisfies(_296727930,_296738928,_296740164,_296727224),(_296727224\==[]->set_var(_296745410,block_ret_sys_matches,[]),always(block_exit_sys_matches,_296745410);_296724056=[]))),cl_push(item,sys_result,_297033008),_297033008=_296719968),block_exit(sys_matches,_296719968),true))),get_var(_297019868,sys_result,_296819670),_296819670=_296609622),block_exit(set_exclusive_or,_296609622),true)))),(set_opv(cl_set_exclusive_or,classof,claz_function),set_opv(set_exclusive_or,compile_as,kw_function),set_opv(set_exclusive_or,function,cl_set_exclusive_or)),_280433356=set_exclusive_or)).
*/
/*
:-side_effect((compile_each($,_297747104,[],[],true),append([sys_prev],[_297805672,_297805500],[sys_prev,_297805672,_297805500]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_297747104,[],[],true),append([sys_prev],[_297940864,_297940692],[sys_prev,_297940864,_297940692]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_297747104,[],[],true),append([sys_prev],[_298076182,_298076010],[sys_prev,_298076182,_298076010]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_297747104,[],[],true),append([sys_prev],[_298211528,_298211356],[sys_prev,_298211528,_298211356]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_298522624,[],[],true),append([sys_prev],[_298582014,_298581842],[sys_prev,_298582014,_298581842]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_298522624,[],[],true),append([sys_prev],[_298719314,_298719142],[sys_prev,_298719314,_298719142]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_298522624,[],[],true),append([sys_prev],[_298856740,_298856568],[sys_prev,_298856740,_298856568]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_298522624,[],[],true),append([sys_prev],[_298994194,_298994022],[sys_prev,_298994194,_298994022]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_299225994,[],[],true),append([sys_list_1],[_299244292,_299244120],[sys_list_1,_299244292,_299244120]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_299225994,[],[],true),append([sys_list_1],[_299378520,_299378348],[sys_list_1,_299378520,_299378348]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_299225994,[],[],true),append([sys_list_1],[_299512874,_299512702],[sys_list_1,_299512874,_299512702]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_299225994,[],[],true),append([sys_list_1],[_299647256,_299647084],[sys_list_1,_299647256,_299647084]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_299802586,[],[],true),append([end],[_299820920,_299820748],[end,_299820920,_299820748]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_299802586,[],[],true),append([end],[_299958428,_299958256],[end,_299958428,_299958256]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_299802586,[],[],true),append([end],[_300096062,_300095890],[end,_300096062,_300095890]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_299802586,[],[],true),append([end],[_300233724,_300233552],[end,_300233724,_300233552]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_300410796,[],[],true),append([sys_prev],[_300471116,_300470944],[sys_prev,_300471116,_300470944]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-side_effect((compile_each($,_300410796,[],[],true),append([sys_prev],[_300618876,_300618704],[sys_prev,_300618876,_300618704]),setf_inverse_op(cdr,sys_set_cdr))).
*/
/*
:-side_effect((compile_each($,_300410796,[],[],true),append([sys_prev],[_300766762,_300766590],[sys_prev,_300766762,_300766590]),setf_inverse_op(cdr,setf_cdr))).
*/
/*
:-side_effect((compile_each($,_300410796,[],[],true),append([sys_prev],[_300914676,_300914504],[sys_prev,_300914676,_300914504]),setf_inverse_op(cdr,rplacd))).
*/
/*
:-was_info(((assert_lsp(nset_exclusive_or,wl:lambda_def(defun,nset_exclusive_or,cl_nset_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],[let,[[sys_result,[]],[list,[]],[item,[]]],[tagbody,sys_start_1,[unless,sys_list_1,[go,sys_start_2]],[setf,item,[car,sys_list_1]],[setf,list,sys_list_2],[setf,sys_prev,[]],sys_start_1_in,[unless,list,[go,sys_end_1_in]],[let,[[sys_elem,[if,key,[funcall,key,[car,list]],[car,list]]]],[when,[apply,function(satisfies),item,[if,key,[funcall,key,sys_elem],sys_elem],rest],[if,sys_prev,[setf,[cdr,sys_prev],[cdr,list]],[setf,sys_list_2,[cdr,list]]],[setf,sys_list_1,[cdr,sys_list_1]],[go,sys_start_1]]],[setf,sys_prev,list],[setf,list,[cdr,list]],[go,sys_start_1_in],sys_end_1_in,[setf,item,[cdr,sys_list_1]],[setf,[cdr,sys_list_1],sys_result],[unless,sys_result,[setf,end,sys_list_1]],[setf,sys_result,sys_list_1],[setf,sys_list_1,item],[go,sys_start_1],sys_start_2,[return_from,nset_exclusive_or,[if,end,[progn,[setf,[cdr,end],sys_list_2],sys_result],sys_list_2]]]])),assert_lsp(nset_exclusive_or,wl:arglist_info(nset_exclusive_or,cl_nset_exclusive_or,[sys_list_1,sys_list_2,c38_rest,rest,c38_key,key],arginfo{all:[sys_list_1,sys_list_2],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:[key],names:[sys_list_1,sys_list_2,rest,key],opt:0,req:[sys_list_1,sys_list_2],rest:[rest],sublists:0,whole:0})),assert_lsp(nset_exclusive_or,wl:init_args(2,cl_nset_exclusive_or)),assert_lsp(nset_exclusive_or,(cl_nset_exclusive_or(_297645220,_297657386,_297630988,_297630654):-_300383164=[bv(sys_list_1,_297645220),bv(sys_list_2,_297657386),bv(rest,_297630988),bv(key,_297658812),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),get_kw([name='TOPLEVEL',environ=env_2],_297630988,key,key,_297658812,[]=_297658812,_297633070),catch((get_var(_300383164,let,_297669012),f_sys_result([],_301928538),cl_list([],_297684938),cl_item([],_297685522),cl_apply(_301928538,[_297684938,_297685522],_302244534),call_addr_block(_300383164,(push_label(sys_start_1),get_var(_300383164,sys_list_1,_300380562),(_300380562\==[]->_300380064=[];goto(sys_start_2,_300383164),_300380064=_300382938),get_var(_300383164,sys_list_1,_300389676),cl_car(_300389676,_300388596),set_var(_300383164,item,_300388596),get_var(_300383164,sys_list_2,_300394070),set_var(_300383164,list,_300394070),set_var(_300383164,sys_prev,[]),push_label(sys_start_1_in),get_var(_300383164,list,_300400982),(_300400982\==[]->_300400484=[];goto(sys_end_1_in,_300383164),_300400484=_300403340),get_var(_300383164,key,_300411582),(_300411582\==[]->get_var(_300383164,key,_300414564),get_var(_300383164,list,_300416016),cl_car(_300416016,_302261482),cl_apply(_300414564,[_302261482],_300420558),_300433606=_300420558;get_var(_300383164,list,_300419116),cl_car(_300419116,_300420906),_300433606=_300420906),_300410796=[bv(sys_elem,_300433606)|_300383164],get_var(_300410796,item,_300438046),get_var(_300410796,key,_300438918),(_300438918\==[]->get_var(_300410796,key,_300441876),get_var(_300410796,sys_elem,_300443220),cl_apply(_300441876,[_300443220],_300446296),_300438508=_300446296;get_var(_300410796,sys_elem,_300445442),_300438508=_300445442),get_var(_300410796,rest,_300449650),cl_satisfies(_300438046,_300438508,_300449650,_300436554),(_300436554\==[]->get_var(_300410796,sys_prev,_300455146),(_300455146\==[]->get_var(_300410796,sys_prev,_301049010),get_var(_300410796,list,_301050388),cl_cdr(_301050388,_302278704),cl_rplacd(_301049010,_302278704,_301056256),_300454878=_301056256;get_var(_300410796,list,_301054124),cl_cdr(_301054124,_301056604),set_var(_300410796,sys_list_2,_301056604),_300454878=_301056604),get_var(_300410796,sys_list_1,_301060638),cl_cdr(_301060638,_301059558),set_var(_300410796,sys_list_1,_301059558),goto(sys_start_1,_300410796),_300410584=_301062700;_300410584=[]),get_var(_300383164,list,_301113908),set_var(_300383164,sys_prev,_301113908),get_var(_300383164,list,_301116308),cl_cdr(_301116308,_301854058),set_var(_300383164,list,_301854058),goto(sys_start_1_in,_300383164)),[addr(addr_tagbody_47_sys_start_1,sys_start_1,'$used',_301241832,(get_var(_301241832,sys_list_1,_301241860),(_301241860\==[]->_301241898=[];goto(sys_start_2,_301241832),_301241898=_301241922),get_var(_301241832,sys_list_1,_301241950),cl_car(_301241950,_302295336),set_var(_301241832,item,_302295336),get_var(_301241832,sys_list_2,_301242004),set_var(_301241832,list,_301242004),set_var(_301241832,sys_prev,[]),push_label(sys_start_1_in),get_var(_301241832,list,_301242066),(_301242066\==[]->_301242104=[];goto(sys_end_1_in,_301241832),_301242104=_301242128),get_var(_301241832,key,_301242156),(_301242156\==[]->get_var(_301241832,key,_301242208),get_var(_301241832,list,_301242236),cl_car(_301242236,_302306374),cl_apply(_301242208,[_302306374],_301242282),_301242296=_301242282;get_var(_301241832,list,_301242316),cl_car(_301242316,_301242342),_301242296=_301242342),_301242374=[bv(sys_elem,_301242296)|_301241832],get_var(_301242374,item,_301242414),get_var(_301242374,key,_301242442),(_301242442\==[]->get_var(_301242374,key,_301242494),get_var(_301242374,sys_elem,_301242522),cl_apply(_301242494,[_301242522],_301242556),_301242570=_301242556;get_var(_301242374,sys_elem,_301242590),_301242570=_301242590),get_var(_301242374,rest,_301242624),cl_satisfies(_301242414,_301242570,_301242624,_301242654),(_301242654\==[]->get_var(_301242374,sys_prev,_301242706),(_301242706\==[]->get_var(_301242374,sys_prev,_301242758),get_var(_301242374,list,_301242794),cl_cdr(_301242794,_302324072),cl_rplacd(_301242758,_302324072,_301242834),_301242848=_301242834;get_var(_301242374,list,_301242868),cl_cdr(_301242868,_301242894),set_var(_301242374,sys_list_2,_301242894),_301242848=_301242894),get_var(_301242374,sys_list_1,_301242942),cl_cdr(_301242942,_302329574),set_var(_301242374,sys_list_1,_302329574),goto(sys_start_1,_301242374),_301243000=_301243014;_301243000=[]),get_var(_301241832,list,_301243048),set_var(_301241832,sys_prev,_301243048),get_var(_301241832,list,_301243090),cl_cdr(_301243090,_302335028),set_var(_301241832,list,_302335028),goto(sys_start_1_in,_301241832))),addr(addr_tagbody_47_sys_start_1_in,sys_start_1_in,'$used',_301243154,(get_var(_301243154,list,_301243182),(_301243182\==[]->_301243220=[];goto(sys_end_1_in,_301243154),_301243220=_301243244),get_var(_301243154,key,_301243272),(_301243272\==[]->get_var(_301243154,key,_301243324),get_var(_301243154,list,_301243352),cl_car(_301243352,_302344250),cl_apply(_301243324,[_302344250],_301243398),_301243418=_301243398;get_var(_301243154,list,_301243446),cl_car(_301243446,_301243472),_301243418=_301243472),_301243504=[bv(sys_elem,_301243418)|_301243154],get_var(_301243504,item,_301243544),get_var(_301243504,key,_301243572),(_301243572\==[]->get_var(_301243504,key,_301243624),get_var(_301243504,sys_elem,_301243652),cl_apply(_301243624,[_301243652],_301243686),_301243700=_301243686;get_var(_301243504,sys_elem,_301243720),_301243700=_301243720),get_var(_301243504,rest,_301243754),cl_satisfies(_301243544,_301243700,_301243754,_301243784),(_301243784\==[]->get_var(_301243504,sys_prev,_301243836),(_301243836\==[]->get_var(_301243504,sys_prev,_301243888),get_var(_301243504,list,_301243924),cl_cdr(_301243924,_302361472),cl_rplacd(_301243888,_302361472,_301243964),_301243978=_301243964;get_var(_301243504,list,_301243998),cl_cdr(_301243998,_301244024),set_var(_301243504,sys_list_2,_301244024),_301243978=_301244024),get_var(_301243504,sys_list_1,_301244072),cl_cdr(_301244072,_302366974),set_var(_301243504,sys_list_1,_302366974),goto(sys_start_1,_301243504),_301244130=_301244144;_301244130=[]),get_var(_301243154,list,_301244178),set_var(_301243154,sys_prev,_301244178),get_var(_301243154,list,_301244220),cl_cdr(_301244220,_302372428),set_var(_301243154,list,_302372428),goto(sys_start_1_in,_301243154))),addr(addr_tagbody_47_sys_end_1_in,sys_end_1_in,'$unused',_301244284,(get_var(_301244284,sys_list_1,_301244312),cl_cdr(_301244312,_302375870),set_var(_301244284,item,_302375870),get_var(_301244284,sys_list_1,_301244366),get_var(_301244284,sys_result,_301244402),cl_rplacd(_301244366,_301244402,_302379332),get_var(_301244284,sys_result,_301244444),(_301244444\==[]->_301244482=[];get_var(_301244284,sys_list_1,_301244502),set_var(_301244284,end,_301244502),_301244482=_301244502),get_var(_301244284,sys_list_1,_301244550),set_var(_301244284,sys_result,_301244550),get_var(_301244284,item,_301244592),set_var(_301244284,sys_list_1,_301244592),goto(sys_start_1,_301244284))),addr(addr_tagbody_47_sys_start_2,sys_start_2,'$unused',_301244644,(get_var(_301244644,end,_301244672),(_301244672\==[]->get_var(_301244644,end,_301244724),get_var(_301244644,sys_list_2,_301244760),cl_rplacd(_301244724,_301244760,_302391640),get_var(_301244644,sys_result,_301244802),_301244822=_301244802;get_var(_301244644,sys_list_2,_301244850),_301244822=_301244850),throw(block_exit(nset_exclusive_or,_301244822))))]),[]=_297630654),block_exit(nset_exclusive_or,_297630654),true)))),(set_opv(cl_nset_exclusive_or,classof,claz_function),set_opv(nset_exclusive_or,compile_as,kw_function),set_opv(nset_exclusive_or,function,cl_nset_exclusive_or)),_280435242=nset_exclusive_or)).
*/
/*
:-was_info(((assert_lsp(fill,wl:lambda_def(defun,fill,cl_fill,[sequence,item,c38_rest,rest],[[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[sys_seq_set,sequence,sys_iter,item],[sys_seq_next,sys_iter],[go,start]]]],sequence])),assert_lsp(fill,wl:arglist_info(fill,cl_fill,[sequence,item,c38_rest,rest],arginfo{all:[sequence,item],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sequence,item,rest],opt:0,req:[sequence,item],rest:[rest],sublists:0,whole:0})),assert_lsp(fill,wl:init_args(2,cl_fill)),assert_lsp(fill,(cl_fill(_303264366,_303276420,_303262984,_303262650):-_303512864=[bv(sequence,_303264366),bv(item,_303276420),bv(rest,_303262984),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_303512864,sequence,_303283000),get_var(_303512864,rest,_303284332),f_sys_seq_start(_303283000,_303284332,_303281896),_303281592=[bv(sys_iter,_303281896)|_303512864],call_addr_block(_303281592,(push_label(start),get_var(_303281592,sequence,_303337700),get_var(_303281592,sys_iter,_303339050),get_var(_303281592,rest,_303340490),f_sys_seq_end_p(_303337700,_303339050,_303340490,_303336166),(_303336166\==[]->_303296058=[];get_var(_303281592,sequence,_303344242),get_var(_303281592,sys_iter,_303345598),get_var(_303281592,item,_303347044),f_sys_seq_set(_303344242,_303345598,_303347044,_303343220),get_var(_303281592,sys_iter,_303350240),f_sys_seq_next(_303350240,_303349386),goto(start,_303281592),_303296058=_303352266)),[addr(addr_tagbody_48_start,start,'$unused',_303375948,(get_var(_303375948,sequence,_303375976),get_var(_303375948,sys_iter,_303376004),get_var(_303375948,rest,_303376032),f_sys_seq_end_p(_303375976,_303376004,_303376032,_303376062),(_303376062\==[]->_303376100=[];get_var(_303375948,sequence,_303376128),get_var(_303375948,sys_iter,_303376156),get_var(_303375948,item,_303376184),f_sys_seq_set(_303376128,_303376156,_303376184,_303647918),get_var(_303375948,sys_iter,_303376228),f_sys_seq_next(_303376228,_303650200),goto(start,_303375948),_303376100=_303376272)))]),get_var(_303512864,sequence,_303401414),_303401414=_303262650),block_exit(fill,_303262650),true)))),(set_opv(cl_fill,classof,claz_function),set_opv(fill,compile_as,kw_function),set_opv(fill,function,cl_fill)),_280436880=fill)).
*/
/*
:-was_info(((assert_lsp(every,wl:lambda_def(defun,every,cl_every,[predicate,c38_rest,sys_sequences],[[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[unless,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,[]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],t])),assert_lsp(every,wl:arglist_info(every,cl_every,[predicate,c38_rest,sys_sequences],arginfo{all:[predicate],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_sequences],opt:0,req:[predicate],rest:[sys_sequences],sublists:0,whole:0})),assert_lsp(every,wl:init_args(2,cl_every)),assert_lsp(every,(cl_every(_303994042,_303992748,_303992414):-_304343900=[bv(predicate,_303994042),bv(sys_sequences,_303992748),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((find_operator_or_die(_304343900,sys_seq_start,_304011636),get_var(_304343900,sys_sequences,_304011980),cl_mapcar(_304011636,_304011980,_304011498),_304011194=[bv(sys_iters,_304011498)|_304343900],call_addr_block(_304011194,(push_label(start),find_operator_or_die(_304011194,sys_seq_end_p,_304110686),get_var(_304011194,sys_sequences,_304112026),get_var(_304011194,sys_iters,_304113316),f_sys_some_list_2(_304110686,_304112026,_304113316,_304110118),(_304110118\==[]->_304035694=[];find_operator_or_die(_304011194,sys_seq_ref,_304117686),get_var(_304011194,sys_sequences,_304119026),get_var(_304011194,sys_iters,_304120322),cl_mapcar(_304117686,[_304119026,_304120322],_304117530),cl_predicate(_304117530,_304116914),(_304116914\==[]->_304116272=[];throw(block_exit(every,[])),_304116272=_304125378),find_operator_or_die(_304011194,sys_seq_next,_304132598),get_var(_304011194,sys_iters,_304133770),cl_mapc(_304132598,_304133770,_304132530),goto(start,_304011194),_304035694=_304135518)),[addr(addr_tagbody_49_start,start,'$unused',_304173412,(find_operator_or_die(_304173412,sys_seq_end_p,_304173436),get_var(_304173412,sys_sequences,_304173454),get_var(_304173412,sys_iters,_304173478),f_sys_some_list_2(_304173436,_304173454,_304173478,_304173498),(_304173498\==[]->_304173536=[];find_operator_or_die(_304173412,sys_seq_ref,_304173560),get_var(_304173412,sys_sequences,_304173578),get_var(_304173412,sys_iters,_304173606),cl_mapcar(_304173560,[_304173578,_304173606],_304410028),cl_predicate(_304410028,_304173658),(_304173658\==[]->_304173696=[];throw(block_exit(every,[])),_304173696=_304173714),find_operator_or_die(_304173412,sys_seq_next,_304173738),get_var(_304173412,sys_iters,_304173756),cl_mapc(_304173738,_304173756,_304509984),goto(start,_304173412),_304173536=_304173802)))]),t=_303992414),block_exit(every,_303992414),true)))),(set_opv(cl_every,classof,claz_function),set_opv(every,compile_as,kw_function),set_opv(every,function,cl_every)),_280438766=every)).
*/
/*
:-was_info(((assert_lsp(some,wl:lambda_def(defun,some,cl_some,[predicate,c38_rest,sys_sequences],[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[let,[[sys_result,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]]]],[when,sys_result,[return_from,some,sys_result]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]])),assert_lsp(some,wl:arglist_info(some,cl_some,[predicate,c38_rest,sys_sequences],arginfo{all:[predicate],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_sequences],opt:0,req:[predicate],rest:[sys_sequences],sublists:0,whole:0})),assert_lsp(some,wl:init_args(2,cl_some)),assert_lsp(some,(cl_some(_304887336,_304886042,_304885708):-_305069528=[bv(predicate,_304887336),bv(sys_sequences,_304886042),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_305069528,let,_304903436),find_operator_or_die(_305069528,sys_seq_start,_305294504),get_var(_305069528,sys_sequences,_304917966),cl_mapcar(_305294504,_304917966,_304916488),f_sys_iters(_304916488,_305338316),cl_apply(_305338316,[],_305447578),call_addr_block(_305069528,(push_label(start),find_operator_or_die(_305069528,sys_seq_end_p,_305296452),get_var(_305069528,sys_sequences,_305026142),get_var(_305069528,sys_iters,_305027432),f_sys_some_list_2(_305296452,_305026142,_305027432,_305024234),(_305024234\==[]->_304922896=[];find_operator_or_die(_305069528,sys_seq_ref,_305298176),get_var(_305069528,sys_sequences,_305034010),get_var(_305069528,sys_iters,_305035306),cl_mapcar(_305298176,[_305034010,_305035306],_305348388),cl_predicate(_305348388,_305048262),_305032006=[bv(sys_result,_305048262)|_305069528],get_var(_305032006,sys_result,_305049350),(_305049350\==[]->get_var(_305032006,sys_result,_305052016),throw(block_exit(some,_305052016)),_305031794=_305052380;_305031794=[]),find_operator_or_die(_305069528,sys_seq_next,_305301594),get_var(_305069528,sys_iters,_305067554),cl_mapc(_305301594,_305067554,_305464338),goto(start,_305069528),_304922896=_305069302)),[addr(addr_tagbody_50_start,start,'$unused',_305114740,(find_operator_or_die(_305114740,sys_seq_end_p,_305360880),get_var(_305114740,sys_sequences,_305114782),get_var(_305114740,sys_iters,_305114810),f_sys_some_list_2(_305360880,_305114782,_305114810,_305114840),(_305114840\==[]->_305114878=[];find_operator_or_die(_305114740,sys_seq_ref,_305365670),get_var(_305114740,sys_sequences,_305114920),get_var(_305114740,sys_iters,_305114948),cl_mapcar(_305365670,[_305114920,_305114948],_305367898),cl_predicate(_305367898,_305114996),_305115012=[bv(sys_result,_305114996)|_305114740],get_var(_305115012,sys_result,_305115052),(_305115052\==[]->get_var(_305115012,sys_result,_305115104),throw(block_exit(some,_305115104)),_305115140=_305115154;_305115140=[]),find_operator_or_die(_305114740,sys_seq_next,_305375790),get_var(_305114740,sys_iters,_305115202),cl_mapc(_305375790,_305115202,_305482292),goto(start,_305114740),_305114878=_305115248)))]),[]=_304885708),block_exit(some,_304885708),true)))),(set_opv(cl_some,classof,claz_function),set_opv(some,compile_as,kw_function),set_opv(some,function,cl_some)),_280441148=some)).
*/
/*
:-was_info(((assert_lsp(notevery,wl:lambda_def(defun,notevery,cl_notevery,[predicate,c38_rest,sys_sequences],[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[unless,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,t]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]])),assert_lsp(notevery,wl:arglist_info(notevery,cl_notevery,[predicate,c38_rest,sys_sequences],arginfo{all:[predicate],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_sequences],opt:0,req:[predicate],rest:[sys_sequences],sublists:0,whole:0})),assert_lsp(notevery,wl:init_args(2,cl_notevery)),assert_lsp(notevery,(cl_notevery(_305893000,_305891706,_305891372):-_306018340=[bv(predicate,_305893000),bv(sys_sequences,_305891706),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_306018340,let,_305908776),find_operator_or_die(_306018340,sys_seq_start,_306225324),get_var(_306018340,sys_sequences,_305923198),cl_mapcar(_306225324,_305923198,_306265410),f_sys_iters(_306265410,_306266750),cl_apply(_306266750,[],_306365682),call_addr_block(_306018340,(push_label(start),find_operator_or_die(_306018340,sys_seq_end_p,_306227272),get_var(_306018340,sys_sequences,_306004444),get_var(_306018340,sys_iters,_306005734),f_sys_some_list_2(_306227272,_306004444,_306005734,_306002536),(_306002536\==[]->_305928020=[];find_operator_or_die(_306018340,sys_seq_ref,_306228996),get_var(_306018340,sys_sequences,_306011444),get_var(_306018340,sys_iters,_306012740),cl_mapcar(_306228996,[_306011444,_306012740],_306276822),cl_predicate(_306276822,_306009332),(_306009332\==[]->_306008690=[];throw(block_exit(every,t)),_306008690=_306017796),find_operator_or_die(_306018340,sys_seq_next,_306231748),get_var(_306018340,sys_iters,_306026198),cl_mapc(_306231748,_306026198,_306379962),goto(start,_306018340),_305928020=_306027946)),[addr(addr_tagbody_51_start,start,'$unused',_306065840,(find_operator_or_die(_306065840,sys_seq_end_p,_306286642),get_var(_306065840,sys_sequences,_306065882),get_var(_306065840,sys_iters,_306065910),f_sys_some_list_2(_306286642,_306065882,_306065910,_306065940),(_306065940\==[]->_306065978=[];find_operator_or_die(_306065840,sys_seq_ref,_306291432),get_var(_306065840,sys_sequences,_306066020),get_var(_306065840,sys_iters,_306066048),cl_mapcar(_306291432,[_306066020,_306066048],_306293660),cl_predicate(_306293660,_306066100),(_306066100\==[]->_306066138=[];throw(block_exit(every,t)),_306066138=_306066156),find_operator_or_die(_306065840,sys_seq_next,_306298880),get_var(_306065840,sys_iters,_306066198),cl_mapc(_306298880,_306066198,_306394656),goto(start,_306065840),_306065978=_306066244)))]),[]=_305891372),block_exit(notevery,_305891372),true)))),(set_opv(cl_notevery,classof,claz_function),set_opv(notevery,compile_as,kw_function),set_opv(notevery,function,cl_notevery)),_280443530=notevery)).
*/
/*
:-was_info(((assert_lsp(notany,wl:lambda_def(defun,notany,cl_notany,[predicate,c38_rest,sys_sequences],[[let,[[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[when,[apply,predicate,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]],[return_from,every,[]]],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],t])),assert_lsp(notany,wl:arglist_info(notany,cl_notany,[predicate,c38_rest,sys_sequences],arginfo{all:[predicate],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sys_sequences],opt:0,req:[predicate],rest:[sys_sequences],sublists:0,whole:0})),assert_lsp(notany,wl:init_args(2,cl_notany)),assert_lsp(notany,(cl_notany(_306787546,_306786252,_306785918):-_307137540=[bv(predicate,_306787546),bv(sys_sequences,_306786252),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((find_operator_or_die(_307137540,sys_seq_start,_307137220),get_var(_307137540,sys_sequences,_306806480),cl_mapcar(_307137220,_306806480,_306816696),_306804698=[bv(sys_iters,_306816696)|_307137540],call_addr_block(_306804698,(push_label(start),find_operator_or_die(_306804698,sys_seq_end_p,_307138990),get_var(_306804698,sys_sequences,_306905632),get_var(_306804698,sys_iters,_306906922),f_sys_some_list_2(_307138990,_306905632,_306906922,_306903724),(_306903724\==[]->_306829266=[];find_operator_or_die(_306804698,sys_seq_ref,_307140714),get_var(_306804698,sys_sequences,_306912632),get_var(_306804698,sys_iters,_306913928),cl_mapcar(_307140714,[_306912632,_306913928],_307186890),cl_predicate(_307186890,_306910520),(_306910520\==[]->throw(block_exit(every,[])),_306909878=_306918924;_306909878=[]),find_operator_or_die(_306804698,sys_seq_next,_307143466),get_var(_306804698,sys_iters,_306927376),cl_mapc(_307143466,_306927376,_307288224),goto(start,_306804698),_306829266=_306929124)),[addr(addr_tagbody_52_start,start,'$unused',_306967018,(find_operator_or_die(_306967018,sys_seq_end_p,_307196710),get_var(_306967018,sys_sequences,_306967060),get_var(_306967018,sys_iters,_306967088),f_sys_some_list_2(_307196710,_306967060,_306967088,_306967118),(_306967118\==[]->_306967156=[];find_operator_or_die(_306967018,sys_seq_ref,_307201500),get_var(_306967018,sys_sequences,_306967198),get_var(_306967018,sys_iters,_306967226),cl_mapcar(_307201500,[_306967198,_306967226],_307203728),cl_predicate(_307203728,_306967278),(_306967278\==[]->throw(block_exit(every,[])),_306967322=_306967328;_306967322=[]),find_operator_or_die(_306967018,sys_seq_next,_307208948),get_var(_306967018,sys_iters,_306967376),cl_mapc(_307208948,_306967376,_307302918),goto(start,_306967018),_306967156=_306967422)))]),t=_306785918),block_exit(notany,_306785918),true)))),(set_opv(cl_notany,classof,claz_function),set_opv(notany,compile_as,kw_function),set_opv(notany,function,cl_notany)),_280445912=notany)).
*/
/*
:-was_info(((assert_lsp(map_into,wl:lambda_def(defun,map_into,cl_map_into,[sys_result_sequence,function,c38_rest,sys_sequences],[[let,[[sys_result_iter,[sys_seq_start,sys_result_sequence]],[sys_iters,[mapcar,function(sys_seq_start),sys_sequences]]],[tagbody,start,[unless,[sys_some_list_2,function(sys_seq_end_p),sys_sequences,sys_iters],[sys_seq_set,sys_result_sequence,sys_result_iter,[apply,function,[mapcar,function(sys_seq_ref),sys_sequences,sys_iters]]],[sys_seq_next,sys_result_iter],[mapc,function(sys_seq_next),sys_iters],[go,start]]]],sys_result_sequence])),assert_lsp(map_into,wl:arglist_info(map_into,cl_map_into,[sys_result_sequence,function,c38_rest,sys_sequences],arginfo{all:[sys_result_sequence,function],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[sys_result_sequence,function,sys_sequences],opt:0,req:[sys_result_sequence,function],rest:[sys_sequences],sublists:0,whole:0})),assert_lsp(map_into,wl:init_args(2,cl_map_into)),assert_lsp(map_into,(cl_map_into(_307698110,_307698144,_307697780,_307697446):-_308088118=[bv(sys_result_sequence,_307698110),bv(function,_307698144),bv(sys_sequences,_307697780),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_308088118,sys_result_sequence,_307729756),f_sys_seq_start(_307729756,_307729636),find_operator_or_die(_308088118,sys_seq_start,_308088900),get_var(_308088118,sys_sequences,_307733844),cl_mapcar(_308088900,_307733844,_307764822),_307729164=[bv(sys_result_iter,_307729636),bv(sys_iters,_307764822)|_308088118],call_addr_block(_307729164,(push_label(start),find_operator_or_die(_307729164,sys_seq_end_p,_308090580),get_var(_307729164,sys_sequences,_307858180),get_var(_307729164,sys_iters,_307859464),f_sys_some_list_2(_308090580,_307858180,_307859464,_307856272),(_307856272\==[]->_307777468=[];get_var(_307729164,sys_result_sequence,_307863730),get_var(_307729164,sys_result_iter,_307865266),cl_function([mapcar,function(sys_seq_ref),sys_sequences,sys_iters],_307865716),f_sys_seq_set(_307863730,_307865266,_307865716,_308241632),get_var(_307729164,sys_result_iter,_307871122),f_sys_seq_next(_307871122,_308243914),find_operator_or_die(_307729164,sys_seq_next,_308094408),get_var(_307729164,sys_iters,_307874080),cl_mapc(_308094408,_307874080,_308246580),goto(start,_307729164),_307777468=_307875816)),[addr(addr_tagbody_53_start,start,'$unused',_307911782,(find_operator_or_die(_307911782,sys_seq_end_p,_308151488),get_var(_307911782,sys_sequences,_307911824),get_var(_307911782,sys_iters,_307911852),f_sys_some_list_2(_308151488,_307911824,_307911852,_307911882),(_307911882\==[]->_307911920=[];get_var(_307911782,sys_result_sequence,_307911948),get_var(_307911782,sys_result_iter,_308254360),cl_function([mapcar,function(sys_seq_ref),sys_sequences,sys_iters],_308255814),f_sys_seq_set(_307911948,_308254360,_308255814,_308257502),get_var(_307911782,sys_result_iter,_307912018),f_sys_seq_next(_307912018,_308259784),find_operator_or_die(_307911782,sys_seq_next,_308160856),get_var(_307911782,sys_iters,_307912072),cl_mapc(_308160856,_307912072,_308262450),goto(start,_307911782),_307911920=_307912118)))]),get_var(_308088118,sys_result_sequence,_307946270),_307946270=_307697446),block_exit(map_into,_307697446),true)))),(set_opv(cl_map_into,classof,claz_function),set_opv(map_into,compile_as,kw_function),set_opv(map_into,function,cl_map_into)),_280448294=map_into)).
*/
/*
:-was_info(((assert_lsp(reduce,wl:lambda_def(defun,reduce,cl_reduce,[function,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]]],[if,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[funcall,function],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[sys_seq_next,sys_iter],[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[tagbody,start,[setq,sys_elem,[funcall,function,sys_elem,[sys_seq_ref,sequence,sys_iter]]],[sys_seq_next,sys_iter],[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[go,start]]]],sys_elem]]])),assert_lsp(reduce,wl:arglist_info(reduce,cl_reduce,[function,sequence,c38_rest,rest],arginfo{all:[function,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[function,sequence,rest],opt:0,req:[function,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(reduce,wl:init_args(2,cl_reduce)),assert_lsp(reduce,(cl_reduce(_308674708,_308675658,_308673428,_308673094):-_309095606=[bv(function,_308674708),bv(sequence,_308675658),bv(rest,_308673428),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_309095606,let,_308681650),get_var(_309095606,sequence,_308696266),get_var(_309095606,rest,_308697598),f_sys_seq_start(_308696266,_308697598,_308695162),f_sys_iter(_308695162,_309150934),cl_apply(_309150934,[],_309262248),get_var(_309095606,sequence,_308705866),get_var(_309095606,sys_iter,_308707204),get_var(_309095606,rest,_308708662),f_sys_seq_end_p(_308705866,_308707204,_308708662,_308704332),(_308704332\==[]->cl_function(_308890732),_308678302=_308890732;get_var(_309095606,sequence,_308714720),get_var(_309095606,sys_iter,_308716064),f_sys_seq_ref(_308714720,_308716064,_308726970),_308713324=[bv(sys_elem,_308726970)|_309095606],get_var(_308713324,sys_iter,_308728918),f_sys_seq_next(_308728918,_309272646),get_var(_308713324,sequence,_308734516),get_var(_308713324,sys_iter,_308735866),get_var(_308713324,rest,_308737306),f_sys_seq_end_p(_308734516,_308735866,_308737306,_308732982),(_308732982\==[]->_308731944=[];call_addr_block(_308713324,(push_label(start),cl_function(sys_elem,[sys_seq_ref,sequence,sys_iter],_308773582),set_var(_308713324,sys_elem,_308773582),get_var(_308713324,sys_iter,_308777616),f_sys_seq_next(_308777616,_309281762),get_var(_308713324,sequence,_308781870),get_var(_308713324,sys_iter,_308783232),get_var(_308713324,rest,_308784696),f_sys_seq_end_p(_308781870,_308783232,_308784696,_308780336),(_308780336\==[]->_308740874=[];goto(start,_308713324),_308740874=_308787308)),[addr(addr_tagbody_54_start,start,'$unused',_308807266,(cl_function(sys_elem,[sys_seq_ref,sequence,sys_iter],_309288822),set_var(_308807266,sys_elem,_309288822),get_var(_308807266,sys_iter,_308807322),f_sys_seq_next(_308807322,_309291766),get_var(_308807266,sequence,_308807362),get_var(_308807266,sys_iter,_308807390),get_var(_308807266,rest,_308807418),f_sys_seq_end_p(_308807362,_308807390,_308807418,_308807448),(_308807448\==[]->_308807486=[];goto(start,_308807266),_308807486=_308807518)))]),_308731944=[]),get_var(_308713324,sys_elem,_308713112),_308678302=_308713112),_308678302=_308673094),block_exit(reduce,_308673094),true)))),(set_opv(cl_reduce,classof,claz_function),set_opv(reduce,compile_as,kw_function),set_opv(reduce,function,cl_reduce)),_280450676=reduce)).
*/
/*
:-was_info(((assert_lsp(count,wl:lambda_def(defun,count,cl_count,[item,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(satisfies),item,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count])),assert_lsp(count,wl:arglist_info(count,cl_count,[item,sequence,c38_rest,rest],arginfo{all:[item,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[item,sequence,rest],opt:0,req:[item,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(count,wl:init_args(2,cl_count)),assert_lsp(count,(cl_count(_309765742,_309766692,_309753276,_309752942):-_309899686=[bv(item,_309765742),bv(sequence,_309766692),bv(rest,_309753276),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_309899686,let,_309771550),get_var(_309899686,sequence,_309785870),get_var(_309899686,rest,_309787202),f_sys_seq_start(_309785870,_309787202,_310160120),f_sys_iter(_310160120,_310162040),cl_count(0,_309790288),cl_apply(_310162040,[_309790288],_310265968),call_addr_block(_309899686,(push_label(start),get_var(_309899686,sequence,_309867568),get_var(_309899686,sys_iter,_309868918),get_var(_309899686,rest,_309870358),f_sys_seq_end_p(_309867568,_309868918,_309870358,_309866034),(_309866034\==[]->_309793326=[];get_var(_309899686,item,_309875930),get_var(_309899686,sequence,_309877472),get_var(_309899686,sys_iter,_309878828),f_sys_seq_ref(_309877472,_309878828,_309876380),get_var(_309899686,rest,_309881624),cl_satisfies(_309875930,_309876380,_309881624,_309874510),(_309874510\==[]->get_var(_309899686,count,_309885754),+(1,_309885754,_309890244),set_var(_309899686,count,_309890244),_309873796=_309890244;_309873796=[]),get_var(_309899686,sys_iter,_309897434),f_sys_seq_next(_309897434,_310282582),goto(start,_309899686),_309793326=_309899460)),[addr(addr_tagbody_55_start,start,'$unused',_309938778,(get_var(_309938778,sequence,_309938806),get_var(_309938778,sys_iter,_309938834),get_var(_309938778,rest,_309938862),f_sys_seq_end_p(_309938806,_309938834,_309938862,_309938892),(_309938892\==[]->_309938930=[];get_var(_309938778,item,_309938958),get_var(_309938778,sequence,_309938986),get_var(_309938778,sys_iter,_309939014),f_sys_seq_ref(_309938986,_309939014,_310291802),get_var(_309938778,rest,_309939056),cl_satisfies(_309938958,_310291802,_309939056,_309939086),(_309939086\==[]->get_var(_309938778,count,_310295816),+(1,_310295816,_309939152),set_var(_309938778,count,_309939152),_309939180=_309939152;_309939180=[]),get_var(_309938778,sys_iter,_309939206),f_sys_seq_next(_309939206,_310300228),goto(start,_309938778),_309938930=_309939250)))]),get_var(_309899686,count,_309940164),_309940164=_309752942),block_exit(count,_309752942),true)))),(set_opv(cl_count,classof,claz_function),set_opv(count,compile_as,kw_function),set_opv(count,function,cl_count)),_280453058=count)).
*/
/*
:-was_info(((assert_lsp(count_if,wl:lambda_def(defun,count_if,cl_count_if,[predicate,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(sys_satisfies_if),predicate,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count])),assert_lsp(count_if,wl:arglist_info(count_if,cl_count_if,[predicate,sequence,c38_rest,rest],arginfo{all:[predicate,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sequence,rest],opt:0,req:[predicate,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(count_if,wl:init_args(2,cl_count_if)),assert_lsp(count_if,(cl_count_if(_310740202,_310741152,_310738856,_310738522):-_310874880=[bv(predicate,_310740202),bv(sequence,_310741152),bv(rest,_310738856),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_310874880,let,_310746010),get_var(_310874880,sequence,_310760302),get_var(_310874880,rest,_310761634),f_sys_seq_start(_310760302,_310761634,_311135328),f_sys_iter(_311135328,_311137248),cl_count(0,_311239912),cl_apply(_311137248,[_311239912],_311241196),call_addr_block(_310874880,(push_label(start),get_var(_310874880,sequence,_310842394),get_var(_310874880,sys_iter,_310843744),get_var(_310874880,rest,_310845184),f_sys_seq_end_p(_310842394,_310843744,_310845184,_310840860),(_310840860\==[]->_310767758=[];get_var(_310874880,predicate,_310850966),get_var(_310874880,sequence,_310852532),get_var(_310874880,sys_iter,_310853888),f_sys_seq_ref(_310852532,_310853888,_311250100),get_var(_310874880,rest,_310856684),f_sys_satisfies_if(_310850966,_311250100,_310856684,_310849336),(_310849336\==[]->get_var(_310874880,count,_310860948),+(1,_310860948,_310865438),set_var(_310874880,count,_310865438),_310848622=_310865438;_310848622=[]),get_var(_310874880,sys_iter,_310872628),f_sys_seq_next(_310872628,_311257820),goto(start,_310874880),_310767758=_310874654)),[addr(addr_tagbody_56_start,start,'$unused',_310913972,(get_var(_310913972,sequence,_310914000),get_var(_310913972,sys_iter,_310914028),get_var(_310913972,rest,_310914056),f_sys_seq_end_p(_310914000,_310914028,_310914056,_310914086),(_310914086\==[]->_310914124=[];get_var(_310913972,predicate,_310914152),get_var(_310913972,sequence,_310914180),get_var(_310913972,sys_iter,_310914208),f_sys_seq_ref(_310914180,_310914208,_311267040),get_var(_310913972,rest,_310914250),f_sys_satisfies_if(_310914152,_311267040,_310914250,_310914280),(_310914280\==[]->get_var(_310913972,count,_310914332),+(1,_310914332,_310914360),set_var(_310913972,count,_310914360),_310914388=_310914360;_310914388=[]),get_var(_310913972,sys_iter,_310914414),f_sys_seq_next(_310914414,_311274760),goto(start,_310913972),_310914124=_310914458)))]),get_var(_310874880,count,_310915372),_310915372=_310738522),block_exit(count_if,_310738522),true)))),(set_opv(cl_count_if,classof,claz_function),set_opv(count_if,compile_as,kw_function),set_opv(count_if,function,cl_count_if)),_280455192=count_if)).
*/
/*
:-was_info(((assert_lsp(count_if_not,wl:lambda_def(defun,count_if_not,cl_count_if_not,[predicate,sequence,c38_rest,rest],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[count,0]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[when,[apply,function(sys_satisfies_if_not),predicate,[sys_seq_ref,sequence,sys_iter],rest],[setf,count,[+,1,count]]],[sys_seq_next,sys_iter],[go,start]]],count])),assert_lsp(count_if_not,wl:arglist_info(count_if_not,cl_count_if_not,[predicate,sequence,c38_rest,rest],arginfo{all:[predicate,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:0,names:[predicate,sequence,rest],opt:0,req:[predicate,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(count_if_not,wl:init_args(2,cl_count_if_not)),assert_lsp(count_if_not,(cl_count_if_not(_311720482,_311721432,_311719136,_311718802):-_311855304=[bv(predicate,_311720482),bv(sequence,_311721432),bv(rest,_311719136),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),catch((get_var(_311855304,let,_311726290),get_var(_311855304,sequence,_311740582),get_var(_311855304,rest,_311741914),f_sys_seq_start(_311740582,_311741914,_312115752),f_sys_iter(_312115752,_312117672),cl_count(0,_312220336),cl_apply(_312117672,[_312220336],_312221620),call_addr_block(_311855304,(push_label(start),get_var(_311855304,sequence,_311822746),get_var(_311855304,sys_iter,_311824096),get_var(_311855304,rest,_311825536),f_sys_seq_end_p(_311822746,_311824096,_311825536,_311821212),(_311821212\==[]->_311748038=[];get_var(_311855304,predicate,_311831318),get_var(_311855304,sequence,_311832884),get_var(_311855304,sys_iter,_311834240),f_sys_seq_ref(_311832884,_311834240,_312230524),get_var(_311855304,rest,_311837036),f_sys_satisfies_if_not(_311831318,_312230524,_311837036,_311829688),(_311829688\==[]->get_var(_311855304,count,_311841372),+(1,_311841372,_311845862),set_var(_311855304,count,_311845862),_311828974=_311845862;_311828974=[]),get_var(_311855304,sys_iter,_311853052),f_sys_seq_next(_311853052,_312238244),goto(start,_311855304),_311748038=_311855078)),[addr(addr_tagbody_57_start,start,'$unused',_311894396,(get_var(_311894396,sequence,_311894424),get_var(_311894396,sys_iter,_311894452),get_var(_311894396,rest,_311894480),f_sys_seq_end_p(_311894424,_311894452,_311894480,_311894510),(_311894510\==[]->_311894548=[];get_var(_311894396,predicate,_311894576),get_var(_311894396,sequence,_311894604),get_var(_311894396,sys_iter,_311894632),f_sys_seq_ref(_311894604,_311894632,_312247464),get_var(_311894396,rest,_311894674),f_sys_satisfies_if_not(_311894576,_312247464,_311894674,_311894704),(_311894704\==[]->get_var(_311894396,count,_311894756),+(1,_311894756,_311894784),set_var(_311894396,count,_311894784),_311894812=_311894784;_311894812=[]),get_var(_311894396,sys_iter,_311894838),f_sys_seq_next(_311894838,_312255184),goto(start,_311894396),_311894548=_311894882)))]),get_var(_311855304,count,_311895796),_311895796=_311718802),block_exit(count_if_not,_311718802),true)))),(set_opv(cl_count_if_not,classof,claz_function),set_opv(count_if_not,compile_as,kw_function),set_opv(count_if_not,function,cl_count_if_not)),_280457326=count_if_not)).
*/
/*
:-was_info(((assert_lsp(remove,wl:lambda_def(defun,remove,cl_remove,[item,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(satisfies),item,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]])),assert_lsp(remove,wl:arglist_info(remove,cl_remove,[item,sequence,c38_rest,rest,c38_key,count],arginfo{all:[item,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:[count],names:[item,sequence,rest,count],opt:0,req:[item,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(remove,wl:init_args(2,cl_remove)),assert_lsp(remove,(cl_remove(_312719204,_312720154,_312704992,_312704658):-_312989932=[bv(item,_312719204),bv(sequence,_312720154),bv(rest,_312704992),bv(count,_312705538),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),get_kw([name='TOPLEVEL',environ=env_2],_312704992,count,count,_312705538,[]=_312705538,_312706610),catch((get_var(_312989932,let,_312726922),get_var(_312989932,sequence,_312741626),get_var(_312989932,rest,_312742958),f_sys_seq_start(_312741626,_312742958,_313379880),f_sys_iter(_313379880,_313381800),f_sys_result([],_312746044),cl_apply(_313381800,[_312746044],_313530930),call_addr_block(_312989932,(push_label(start),get_var(_312989932,sequence,_312903150),get_var(_312989932,sys_iter,_312904500),get_var(_312989932,rest,_312905940),f_sys_seq_end_p(_312903150,_312904500,_312905940,_312901616),(_312901616\==[]->_312749798=[];get_var(_312989932,sequence,_312912986),get_var(_312989932,sys_iter,_312914342),f_sys_seq_ref(_312912986,_312914342,_312925496),_312911590=[bv(sys_elem,_312925496)|_312989932],get_var(_312911590,item,_312930876),get_var(_312911590,sys_elem,_312932112),get_var(_312911590,rest,_312933402),cl_satisfies(_312930876,_312932112,_312933402,_312929510),(_312929510\==[]->(get_var(_312911590,count,_312936596),cl_not(_312936596,_312942592),_312942592\==[],_312945304=_312942592->true;set_place(_312911590,decf,[value,count],[],_312938570),cl_minusp(_312938570,_313400760),cl_not(_313400760,_313549302),_312945304=_313549302),_312927616=_312945304;_312927616=[]),(_312927616\==[]->_312911378=[];cl_push(sys_elem,sys_result,_312960050),_312911378=_312960050),get_var(_312989932,sys_iter,_312987680),f_sys_seq_next(_312987680,_313555226),goto(start,_312989932),_312749798=_312989706)),[addr(addr_tagbody_58_start,start,'$unused',_313054788,(get_var(_313054788,sequence,_313054816),get_var(_313054788,sys_iter,_313054844),get_var(_313054788,rest,_313054872),f_sys_seq_end_p(_313054816,_313054844,_313054872,_313054902),(_313054902\==[]->_313054940=[];get_var(_313054788,sequence,_313054968),get_var(_313054788,sys_iter,_313054996),f_sys_seq_ref(_313054968,_313054996,_313055024),_313055050=[bv(sys_elem,_313055024)|_313054788],get_var(_313055050,item,_313055090),get_var(_313055050,sys_elem,_313055118),get_var(_313055050,rest,_313055146),cl_satisfies(_313055090,_313055118,_313055146,_313055176),(_313055176\==[]->(get_var(_313055050,count,_313055246),cl_not(_313055246,_313055272),_313055272\==[],_313055304=_313055272->true;set_place(_313055050,decf,[value,count],[],_313055332),cl_minusp(_313055332,_313425710),cl_not(_313425710,_313573914),_313055304=_313573914),_313055372=_313055304;_313055372=[]),(_313055372\==[]->_313055422=[];cl_push(sys_elem,sys_result,_313055450),_313055422=_313055450),get_var(_313054788,sys_iter,_313055484),f_sys_seq_next(_313055484,_313579838),goto(start,_313054788),_313054940=_313055528)))]),get_var(_312989932,sequence,_313056796),get_var(_312989932,sys_iter,_313058158),get_var(_312989932,sys_result,_313059700),f_sys_seq_result(_313056796,_313058158,_313059700,_312723574),_312723574=_312704658),block_exit(remove,_312704658),true)))),(set_opv(cl_remove,classof,claz_function),set_opv(remove,compile_as,kw_function),set_opv(remove,function,cl_remove)),_280459460=remove)).
*/
/*
:-was_info(((assert_lsp(remove_if,wl:lambda_def(defun,remove_if,cl_remove_if,[predicate,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(sys_satisfies_if),predicate,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]])),assert_lsp(remove_if,wl:arglist_info(remove_if,cl_remove_if,[predicate,sequence,c38_rest,rest,c38_key,count],arginfo{all:[predicate,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:[count],names:[predicate,sequence,rest,count],opt:0,req:[predicate,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(remove_if,wl:init_args(2,cl_remove_if)),assert_lsp(remove_if,(cl_remove_if(_314142532,_314143482,_314139420,_314139086):-_314414046=[bv(predicate,_314142532),bv(sequence,_314143482),bv(rest,_314139420),bv(count,_314144938),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),get_kw([name='TOPLEVEL',environ=env_2],_314139420,count,count,_314144938,[]=_314144938,_314141586),catch((get_var(_314414046,let,_314150270),get_var(_314414046,sequence,_314164960),get_var(_314414046,rest,_314166292),f_sys_seq_start(_314164960,_314166292,_314803988),f_sys_iter(_314803988,_314805908),f_sys_result([],_314953016),cl_apply(_314805908,[_314953016],_314954300),call_addr_block(_314414046,(push_label(start),get_var(_314414046,sequence,_314326906),get_var(_314414046,sys_iter,_314328256),get_var(_314414046,rest,_314329696),f_sys_seq_end_p(_314326906,_314328256,_314329696,_314325372),(_314325372\==[]->_314173132=[];get_var(_314414046,sequence,_314336742),get_var(_314414046,sys_iter,_314338098),f_sys_seq_ref(_314336742,_314338098,_314349242),_314335346=[bv(sys_elem,_314349242)|_314414046],get_var(_314335346,predicate,_314354832),get_var(_314335346,sys_elem,_314356092),get_var(_314335346,rest,_314357382),f_sys_satisfies_if(_314354832,_314356092,_314357382,_314353256),(_314353256\==[]->(get_var(_314335346,count,_314360710),cl_not(_314360710,_314366706),_314366706\==[],_314369418=_314366706->true;set_place(_314335346,decf,[value,count],[],_314362684),cl_minusp(_314362684,_314824868),cl_not(_314824868,_314972662),_314369418=_314972662),_314351362=_314369418;_314351362=[]),(_314351362\==[]->_314335134=[];cl_push(sys_elem,sys_result,_314384164),_314335134=_314384164),get_var(_314414046,sys_iter,_314411794),f_sys_seq_next(_314411794,_314978586),goto(start,_314414046),_314173132=_314413820)),[addr(addr_tagbody_59_start,start,'$unused',_314478902,(get_var(_314478902,sequence,_314478930),get_var(_314478902,sys_iter,_314478958),get_var(_314478902,rest,_314478986),f_sys_seq_end_p(_314478930,_314478958,_314478986,_314479016),(_314479016\==[]->_314479054=[];get_var(_314478902,sequence,_314479082),get_var(_314478902,sys_iter,_314479110),f_sys_seq_ref(_314479082,_314479110,_314479138),_314479164=[bv(sys_elem,_314479138)|_314478902],get_var(_314479164,predicate,_314479204),get_var(_314479164,sys_elem,_314479232),get_var(_314479164,rest,_314479260),f_sys_satisfies_if(_314479204,_314479232,_314479260,_314479290),(_314479290\==[]->(get_var(_314479164,count,_314479360),cl_not(_314479360,_314479386),_314479386\==[],_314479418=_314479386->true;set_place(_314479164,decf,[value,count],[],_314479450),cl_minusp(_314479450,_314849090),cl_not(_314849090,_314997264),_314479418=_314997264),_314479500=_314479418;_314479500=[]),(_314479500\==[]->_314479550=[];cl_push(sys_elem,sys_result,_314479578),_314479550=_314479578),get_var(_314478902,sys_iter,_314479612),f_sys_seq_next(_314479612,_315003188),goto(start,_314478902),_314479054=_314479656)))]),get_var(_314414046,sequence,_314480924),get_var(_314414046,sys_iter,_314482286),get_var(_314414046,sys_result,_314483828),f_sys_seq_result(_314480924,_314482286,_314483828,_315007948),_315007948=_314139086),block_exit(remove_if,_314139086),true)))),(set_opv(cl_remove_if,classof,claz_function),set_opv(remove_if,compile_as,kw_function),set_opv(remove_if,function,cl_remove_if)),_280461594=remove_if)).
*/
/*
:-was_info(((assert_lsp(remove_if_not,wl:lambda_def(defun,remove_if_not,cl_remove_if_not,[predicate,sequence,c38_rest,rest,c38_key,count],[let,[[sys_iter,[apply,function(sys_seq_start),sequence,rest]],[sys_result,[]]],[tagbody,start,[unless,[apply,function(sys_seq_end_p),sequence,sys_iter,rest],[let,[[sys_elem,[sys_seq_ref,sequence,sys_iter]]],[unless,[and,[apply,function(sys_satisfies_if_not),predicate,sys_elem,rest],[or,[not,count],[not,[minusp,[decf,count]]]]],[push,sys_elem,sys_result]]],[sys_seq_next,sys_iter],[go,start]]],[sys_seq_result,sequence,sys_iter,sys_result]])),assert_lsp(remove_if_not,wl:arglist_info(remove_if_not,cl_remove_if_not,[predicate,sequence,c38_rest,rest,c38_key,count],arginfo{all:[predicate,sequence],allow_other_keys:0,aux:0,body:0,complex:[rest],env:0,key:[count],names:[predicate,sequence,rest,count],opt:0,req:[predicate,sequence],rest:[rest],sublists:0,whole:0})),assert_lsp(remove_if_not,wl:init_args(2,cl_remove_if_not)),assert_lsp(remove_if_not,(cl_remove_if_not(_315574890,_315575840,_315571778,_315571444):-_315846548=[bv(predicate,_315574890),bv(sequence,_315575840),bv(rest,_315571778),bv(count,_315577296),name='TOPLEVEL',environ=env_2],global_env([name='TOPLEVEL',environ=env_2]),get_kw([name='TOPLEVEL',environ=env_2],_315571778,count,count,_315577296,[]=_315577296,_315573944),catch((get_var(_315846548,let,_315582628),get_var(_315846548,sequence,_315597318),get_var(_315846548,rest,_315598650),f_sys_seq_start(_315597318,_315598650,_316236512),f_sys_iter(_316236512,_316238432),f_sys_result([],_316385540),cl_apply(_316238432,[_316385540],_316386824),call_addr_block(_315846548,(push_label(start),get_var(_315846548,sequence,_315759336),get_var(_315846548,sys_iter,_315760686),get_var(_315846548,rest,_315762126),f_sys_seq_end_p(_315759336,_315760686,_315762126,_315757802),(_315757802\==[]->_315605490=[];get_var(_315846548,sequence,_315769172),get_var(_315846548,sys_iter,_315770528),f_sys_seq_ref(_315769172,_315770528,_315781672),_315767776=[bv(sys_elem,_315781672)|_315846548],get_var(_315767776,predicate,_315787262),get_var(_315767776,sys_elem,_315788522),get_var(_315767776,rest,_315789812),f_sys_satisfies_if_not(_315787262,_315788522,_315789812,_315785686),(_315785686\==[]->(get_var(_315767776,count,_315793212),cl_not(_315793212,_315799208),_315799208\==[],_315801920=_315799208->true;set_place(_315767776,decf,[value,count],[],_315795186),cl_minusp(_315795186,_316257392),cl_not(_316257392,_316405186),_315801920=_316405186),_315783792=_315801920;_315783792=[]),(_315783792\==[]->_315767564=[];cl_push(sys_elem,sys_result,_315816666),_315767564=_315816666),get_var(_315846548,sys_iter,_315844296),f_sys_seq_next(_315844296,_316411110),goto(start,_315846548),_315605490=_315846322)),[addr(addr_tagbody_60_start,start,'$unused',_315911404,(get_var(_315911404,sequence,_315911432),get_var(_315911404,sys_iter,_315911460),get_var(_315911404,rest,_315911488),f_sys_seq_end_p(_315911432,_315911460,_315911488,_315911518),(_315911518\==[]->_315911556=[];get_var(_315911404,sequence,_315911584),get_var(_315911404,sys_iter,_315911612),f_sys_seq_ref(_315911584,_315911612,_315911640),_315911666=[bv(sys_elem,_315911640)|_315911404],get_var(_315911666,predicate,_315911706),get_var(_315911666,sys_elem,_315911734),get_var(_315911666,rest,_315911762),f_sys_satisfies_if_not(_315911706,_315911734,_315911762,_315911792),(_315911792\==[]->(get_var(_315911666,count,_315911862),cl_not(_315911862,_315911888),_315911888\==[],_315911920=_315911888->true;set_place(_315911666,decf,[value,count],[],_315911952),cl_minusp(_315911952,_316281614),cl_not(_316281614,_316429788),_315911920=_316429788),_315912002=_315911920;_315912002=[]),(_315912002\==[]->_315912052=[];cl_push(sys_elem,sys_result,_315912080),_315912052=_315912080),get_var(_315911404,sys_iter,_315912114),f_sys_seq_next(_315912114,_316435712),goto(start,_315911404),_315911556=_315912158)))]),get_var(_315846548,sequence,_315913426),get_var(_315846548,sys_iter,_315914788),get_var(_315846548,sys_result,_315916330),f_sys_seq_result(_315913426,_315914788,_315916330,_316440472),_316440472=_315571444),block_exit(remove_if_not,_315571444),true)))),(set_opv(cl_remove_if_not,classof,claz_function),set_opv(remove_if_not,compile_as,kw_function),set_opv(remove_if_not,function,cl_remove_if_not)),_316105828=remove_if_not)).
*/
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun null (object) (if object nil t))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:85791 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,null,[object],[if,object,[],t]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun not (object) (if object nil t))




*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:85869 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,not,[object],[if,object,[],t]]]]))
/*
#+(or WAM-CL LISP500) 
(defun mod (x y) (multiple-value-call #'(lambda (q r) r) (floor x y)))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:85952 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,mod,[x,y],['multiple-value-call',function([lambda,[q,r],r]),[floor,x,y]]]).
wl:lambda_def(defun, mod, cl_mod, [sys_x, sys_y], [[multiple_value_call, function([lambda, [sys_q, sys_r], sys_r]), [floor, sys_x, sys_y]]]).
wl:arglist_info(mod, cl_mod, [sys_x, sys_y], arginfo{all:[sys_x, sys_y], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_x, sys_y], opt:0, req:[sys_x, sys_y], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_mod).

/*

### Compiled:  `CL:MOD` 
*/
cl_mod(X_In, Y_In, FnResult) :-
	Env9=[bv(sys_x, X_In), bv(sys_y, Y_In)|Env],
	global_env(Env),
	catch(( get_var(Env9, sys_x, X_Get),
		get_var(Env9, sys_y, Y_Get),
		cl_floor(X_Get, Y_Get, Floor_Ret),
		nb_current('$mv_return', Nb_current_Ret),
		cl_apply(function([lambda, [sys_q, sys_r], sys_r]),
			 [Nb_current_Ret],
			 Apply_Ret),
		Apply_Ret=FnResult
	      ),
	      block_exit(mod, FnResult),
	      true).
:- set_opv(cl_mod, classof, claz_function),
   set_opv(mod, compile_as, kw_function),
   set_opv(mod, function, cl_mod),
   DefunResult=(mod).
/*
:- side_effect(assert_lsp((mod),
			  lambda_def(defun,
				     (mod),
				     cl_mod,
				     [sys_x, sys_y],
				     
				     [ 
				       [ multiple_value_call,
					 function([lambda, [sys_q, sys_r], sys_r]),
					 [floor, sys_x, sys_y]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp((mod),
			  arglist_info((mod),
				       cl_mod,
				       [sys_x, sys_y],
				       arginfo{ all:[sys_x, sys_y],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_x, sys_y],
						opt:0,
						req:[sys_x, sys_y],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(mod, init_args(exact_only, cl_mod))).
*/
/*
#+(or WAM-CL LISP500) 
#+BUILTIN
(defun functionp (object) (eq (type-of object) 'function))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:86050 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[defun,functionp,[object],[eq,['type-of',object],[quote,function]]]]))
/*
#+(or WAM-CL LISP500) 
(defun coerce (object result-type)
  (if (typep object result-type)
      object
      (case result-type
	((t) object)
	(character (character object))
	(function (if (and (consp object) (eq (car object) 'lambda))
		      (eval (list 'function object))
		      (if (fboundp object)
			  (fdefinition object))
			  (error 'type-error :datum object
				 :expected-type result-type)))
	(t (error 'type-error :datum object :expected-type result-type)))))




*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:86151 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,coerce,[object,'result-type'],[if,[typep,object,'result-type'],object,[case,'result-type',[[t],object],[character,[character,object]],[function,[if,[and,[consp,object],[eq,[car,object],[quote,lambda]]],[eval,[list,[quote,function],object]],[if,[fboundp,object],[fdefinition,object]],[error,[quote,'type-error'],':datum',object,':expected-type','result-type']]],[t,[error,[quote,'type-error'],':datum',object,':expected-type','result-type']]]]]).
/*
% case:-[[[t],sys_object],[character,[character,sys_object]],[function,[if,[and,[consp,sys_object],[eq,[car,sys_object],[quote,lambda]]],[eval,[list,[quote,function],sys_object]],[if,[fboundp,sys_object],[fdefinition,sys_object]],[error,[quote,type_error],kw_datum,sys_object,kw_expected_type,sys_result_type]]],[t,[error,[quote,type_error],kw_datum,sys_object,kw_expected_type,sys_result_type]]].
*/
/*
% conds:-[[[eq,_317754488,[quote,t]],[progn,sys_object]],[[eq,_317754488,[quote,character]],[progn,[character,sys_object]]],[[eq,_317754488,[quote,function]],[progn,[if,[and,[consp,sys_object],[eq,[car,sys_object],[quote,lambda]]],[eval,[list,[quote,function],sys_object]],[if,[fboundp,sys_object],[fdefinition,sys_object]],[error,[quote,type_error],kw_datum,sys_object,kw_expected_type,sys_result_type]]]],[t,[progn,[error,[quote,type_error],kw_datum,sys_object,kw_expected_type,sys_result_type]]]].
*/
wl:lambda_def(defun, coerce, cl_coerce, [sys_object, sys_result_type], [[if, [typep, sys_object, sys_result_type], sys_object, [case, sys_result_type, [[t], sys_object], [character, [character, sys_object]], [function, [if, [and, [consp, sys_object], [eq, [car, sys_object], [quote, lambda]]], [eval, [list, [quote, function], sys_object]], [if, [fboundp, sys_object], [fdefinition, sys_object]], [error, [quote, type_error], kw_datum, sys_object, kw_expected_type, sys_result_type]]], [t, [error, [quote, type_error], kw_datum, sys_object, kw_expected_type, sys_result_type]]]]]).
wl:arglist_info(coerce, cl_coerce, [sys_object, sys_result_type], arginfo{all:[sys_object, sys_result_type], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_object, sys_result_type], opt:0, req:[sys_object, sys_result_type], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, cl_coerce).

/*

### Compiled:  `CL:COERCE` 
*/
cl_coerce(Object_In, Result_type_In, FnResult) :-
	Env33=[bv(sys_object, Object_In), bv(sys_result_type, Result_type_In)|Env],
	global_env(Env),
	catch(( get_var(Env33, sys_object, Object_Get),
		get_var(Env33, sys_result_type, Result_type_Get),
		cl_typep(Object_Get, Result_type_Get, IFTEST),
		(   IFTEST\==[]
		->  get_var(Env33, sys_object, Object_Get9),
		    _317742380=Object_Get9
		;   get_var(Env33, sys_result_type, Key),
		    (   is_eq(Key, t)
		    ->  get_var(Env33, sys_object, Object_Get15),
			ElseResult30=Object_Get15
		    ;   (   is_eq(Key, character)
			->  get_var(Env33, sys_object, Object_Get18),
			    cl_character(Object_Get18, TrueResult25),
			    ElseResult28=TrueResult25
			;   (   is_eq(Key, function)
			    ->  cl_if(
				      [ and,
					[consp, sys_object],
					[eq, [car, sys_object], [quote, lambda]]
				      ],
				      
				      [ eval,
					[list, [quote, function], sys_object]
				      ],
				      
				      [ if,
					[fboundp, sys_object],
					[fdefinition, sys_object]
				      ],
				      
				      [ error,
					[quote, type_error],
					kw_datum,
					sys_object,
					kw_expected_type,
					sys_result_type
				      ],
				      TrueResult),
				ElseResult26=TrueResult
			    ;   get_var(Env33, sys_object, Object_Get21),
				get_var(Env33,
					sys_result_type,
					Result_type_Get22),
				cl_error(
					 [ type_error,
					   kw_datum,
					   Object_Get21,
					   kw_expected_type,
					   Result_type_Get22
					 ],
					 ElseResult),
				ElseResult26=ElseResult
			    ),
			    ElseResult28=ElseResult26
			),
			ElseResult30=ElseResult28
		    ),
		    _317742380=ElseResult30
		),
		_317742380=FnResult
	      ),
	      block_exit(coerce, FnResult),
	      true).
:- set_opv(cl_coerce, classof, claz_function),
   set_opv(coerce, compile_as, kw_function),
   set_opv(coerce, function, cl_coerce),
   DefunResult=coerce.
/*
:- side_effect(assert_lsp(coerce,
			  lambda_def(defun,
				     coerce,
				     cl_coerce,
				     [sys_object, sys_result_type],
				     
				     [ 
				       [ if,
					 [typep, sys_object, sys_result_type],
					 sys_object,
					 
					 [ case,
					   sys_result_type,
					   [[t], sys_object],
					   [character, [character, sys_object]],
					   
					   [ function,
					     
					     [ if,
					       
					       [ and,
						 [consp, sys_object],
						 
						 [ eq,
						   [car, sys_object],
						   [quote, lambda]
						 ]
					       ],
					       
					       [ eval,
						 
						 [ list,
						   [quote, function],
						   sys_object
						 ]
					       ],
					       
					       [ if,
						 [fboundp, sys_object],
						 [fdefinition, sys_object]
					       ],
					       
					       [ error,
						 [quote, type_error],
						 kw_datum,
						 sys_object,
						 kw_expected_type,
						 sys_result_type
					       ]
					     ]
					   ],
					   
					   [ t,
					     
					     [ error,
					       [quote, type_error],
					       kw_datum,
					       sys_object,
					       kw_expected_type,
					       sys_result_type
					     ]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(coerce,
			  arglist_info(coerce,
				       cl_coerce,
				       [sys_object, sys_result_type],
				       arginfo{ all:
						    [ sys_object,
						      sys_result_type
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_object,
							sys_result_type
						      ],
						opt:0,
						req:
						    [ sys_object,
						      sys_result_type
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(coerce, init_args(exact_only, cl_coerce))).
*/
/*
#+(or WAM-CL LISP500) 
(defmacro deftype (name lambda-list &rest forms)
  `(ensure-type ',name #'(lambda ,lambda-list (block ,name ,@forms))))


*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:86646 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,deftype,[name,'lambda-list','&rest',forms],['#BQ',['ensure-type',[quote,['#COMMA',name]],function([lambda,['#COMMA','lambda-list'],[block,['#COMMA',name],['#BQ-COMMA-ELIPSE',forms]]])]]]).
wl:lambda_def(defmacro, deftype, cl_deftype, [sys_name, sys_lambda_list, c38_rest, forms], [progn, ['#BQ', [sys_ensure_type, [quote, ['#COMMA', sys_name]], function([lambda, ['#COMMA', sys_lambda_list], [block, ['#COMMA', sys_name], ['#BQ-COMMA-ELIPSE', forms]]])]]]).
wl:arglist_info(deftype, cl_deftype, [sys_name, sys_lambda_list, c38_rest, forms], arginfo{all:[sys_name, sys_lambda_list], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_name, sys_lambda_list, forms], opt:0, req:[sys_name, sys_lambda_list], rest:[forms], sublists:0, whole:0}).
wl: init_args(2, cl_deftype).

/*

### Compiled:  `CL:DEFTYPE` 
*/
cl_deftype(Name_In, Lambda_list_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_name, Name_In), bv(sys_lambda_list, Lambda_list_In), bv(forms, RestNKeys)|CDR],
	global_env(CDR),
	catch(( get_var(Env, sys_name, Name_Get),
		[sys_ensure_type, [quote, Name_Get], function([lambda, ['#COMMA', sys_lambda_list], [block, ['#COMMA', sys_name], ['#BQ-COMMA-ELIPSE', forms]]])]=MFResult
	      ),
	      block_exit(deftype, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_deftype, classof, claz_macro),
   set_opv(deftype, compile_as, kw_operator),
   set_opv(deftype, function, cl_deftype),
   DefMacroResult=deftype.
/*
:- side_effect(assert_lsp(deftype,
			  lambda_def(defmacro,
				     deftype,
				     cl_deftype,
				     [sys_name, sys_lambda_list, c38_rest, forms],
				     
				     [ progn,
				       
				       [ '#BQ',
					 
					 [ sys_ensure_type,
					   [quote, ['#COMMA', sys_name]],
					   function(
						    [ lambda,
						      
						      [ '#COMMA',
							sys_lambda_list
						      ],
						      
						      [ block,
							['#COMMA', sys_name],
							
							[ '#BQ-COMMA-ELIPSE',
							  forms
							]
						      ]
						    ]).
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(deftype,
			  arglist_info(deftype,
				       cl_deftype,
				       
				       [ sys_name,
					 sys_lambda_list,
					 c38_rest,
					 forms
				       ],
				       arginfo{ all:[sys_name, sys_lambda_list],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_name,
							sys_lambda_list,
							forms
						      ],
						opt:0,
						req:[sys_name, sys_lambda_list],
						rest:[forms],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(deftype, init_args(2, cl_deftype))).
*/
/*
#+(or WAM-CL LISP500) 
(defun *= (cons number)
  (or (not cons) (eq (car cons) '*) (= (car cons) number)))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:86796 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,*=,[cons,number],[or,[not,cons],[eq,[car,cons],[quote,*]],[=,[car,cons],number]]]).
wl:lambda_def(defun, *=, f_sys_xx_c61, [cons, number], [[or, [not, cons], [eq, [car, cons], [quote, *]], [=, [car, cons], number]]]).
wl:arglist_info(*=, f_sys_xx_c61, [cons, number], arginfo{all:[cons, number], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[cons, number], opt:0, req:[cons, number], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_xx_c61).

/*

### Compiled:  `*=` 
*/
f_sys_xx_c61(Cons_In, Number_In, FnResult) :-
	Env12=[bv(cons, Cons_In), bv(number, Number_In)|Env],
	global_env(Env),
	catch(( (   get_var(Env12, cons, Cons_Get),
		    cl_not(Cons_Get, FORM1_Res9),
		    FORM1_Res9\==[],
		    _319867454=FORM1_Res9
		->  true
		;   (   get_var(Env12, cons, Cons_Get6),
			cl_car(Cons_Get6, Eq_Param),
			cl_eq(Eq_Param, *, FORM1_Res),
			FORM1_Res\==[],
			_319870806=FORM1_Res
		    ->  true
		    ;   get_var(Env12, cons, Cons_Get7),
			cl_car(Cons_Get7, Car_Ret),
			=(Car_Ret, number, Number),
			_319870806=Number
		    ),
		    _319867454=_319870806
		),
		_319867454=FnResult
	      ),
	      block_exit(*=, FnResult),
	      true).
:- set_opv(f_sys_xx_c61, classof, claz_function),
   set_opv(*=, compile_as, kw_function),
   set_opv(*=, function, f_sys_xx_c61),
   DefunResult= *= .
/*
:- side_effect(assert_lsp(*=,
			  lambda_def(defun,
				     *=,
				     f_sys_xx_c61,
				     [cons, number],
				     
				     [ 
				       [ or,
					 [not, cons],
					 [eq, [car, cons], [quote, *]],
					 [=, [car, cons], number]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(*=,
			  arglist_info(*=,
				       f_sys_xx_c61,
				       [cons, number],
				       arginfo{ all:[cons, number],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[cons, number],
						opt:0,
						req:[cons, number],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(*=, init_args(exact_only, f_sys_xx_c61))).
*/
/*
#+(or WAM-CL LISP500) 
(defun ensure-type (name expander)
  (let ((cons (assoc name *type-expanders*)))
    (if cons
	(setf (cdr cons) expander)
	(push (cons name expander) *type-expanders*))
    name))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:86912 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'ensure-type',[name,expander],[let,[[cons,[assoc,name,'*type-expanders*']]],[if,cons,[setf,[cdr,cons],expander],[push,[cons,name,expander],'*type-expanders*']],name]]).
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([cons], [CAR15, CAR], [cons, CAR15, CAR]), setf_inverse_op(cdr, rplacd))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([cons], [CAR15, CAR], [cons, CAR15, CAR]), setf_inverse_op(cdr, sys_set_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([cons], [CAR15, CAR], [cons, CAR15, CAR]), setf_inverse_op(cdr, setf_cdr))).
*/
/*
:- side_effect((compile_each($, LEnv, [], [], true), append([cons], [CAR15, CAR], [cons, CAR15, CAR]), setf_inverse_op(cdr, rplacd))).
*/
wl:lambda_def(defun, sys_ensure_type, f_sys_ensure_type, [sys_name, sys_expander], [[let, [[cons, [assoc, sys_name, sys_xx_type_expanders_xx]]], [if, cons, [setf, [cdr, cons], sys_expander], [push, [cons, sys_name, sys_expander], sys_xx_type_expanders_xx]], sys_name]]).
wl:arglist_info(sys_ensure_type, f_sys_ensure_type, [sys_name, sys_expander], arginfo{all:[sys_name, sys_expander], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_name, sys_expander], opt:0, req:[sys_name, sys_expander], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_ensure_type).

/*

### Compiled:  `SYS::ENSURE-TYPE` 
*/
f_sys_ensure_type(Name_In, Expander_In, FnResult) :-
	Env23=[bv(sys_name, Name_In), bv(sys_expander, Expander_In)|Env],
	global_env(Env),
	catch(( get_var(Env23, sys_name, Name_Get),
		get_var(Env23,
			sys_xx_type_expanders_xx,
			Xx_type_expanders_xx_Get),
		cl_assoc(Name_Get, Xx_type_expanders_xx_Get, [], Cons_Init),
		LEnv=[bv(cons, Cons_Init)|Env23],
		get_var(LEnv, cons, IFTEST),
		(   IFTEST\==[]
		->  get_var(LEnv, cons, Cons_Get16),
		    get_var(LEnv, sys_expander, Expander_Get),
		    cl_rplacd(Cons_Get16, Expander_Get, TrueResult),
		    _320514066=TrueResult
		;   cl_push([cons, sys_name, sys_expander],
			    sys_xx_type_expanders_xx,
			    ElseResult),
		    _320514066=ElseResult
		),
		get_var(LEnv, sys_name, Name_Get20),
		Name_Get20=FnResult
	      ),
	      block_exit(sys_ensure_type, FnResult),
	      true).
:- set_opv(f_sys_ensure_type, classof, claz_function),
   set_opv(sys_ensure_type, compile_as, kw_function),
   set_opv(sys_ensure_type, function, f_sys_ensure_type),
   DefunResult=sys_ensure_type.
/*
:- side_effect(assert_lsp(sys_ensure_type,
			  lambda_def(defun,
				     sys_ensure_type,
				     f_sys_ensure_type,
				     [sys_name, sys_expander],
				     
				     [ 
				       [ let,
					 
					 [ 
					   [ cons,
					     
					     [ assoc,
					       sys_name,
					       sys_xx_type_expanders_xx
					     ]
					   ]
					 ],
					 
					 [ if,
					   cons,
					   [setf, [cdr, cons], sys_expander],
					   
					   [ push,
					     [cons, sys_name, sys_expander],
					     sys_xx_type_expanders_xx
					   ]
					 ],
					 sys_name
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_ensure_type,
			  arglist_info(sys_ensure_type,
				       f_sys_ensure_type,
				       [sys_name, sys_expander],
				       arginfo{ all:[sys_name, sys_expander],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:[sys_name, sys_expander],
						opt:0,
						req:[sys_name, sys_expander],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_ensure_type,
			  init_args(exact_only, f_sys_ensure_type))).
*/
/*
#+WAM-CL
#+(or WAM-CL LISP500) 
(defun ensure-package (name nicknames shadow shadowing-import-from use
		       import-from intern export)
  (let ((package (find-package name)))
    (unless package
      (setq package (make-package name :nicknames nicknames)))
    (shadow shadow package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(shadowing-import (mapcar #'(lambda (symbol-name)
					      (find-symbol symbol-name
							   imported-package))
					  symbol-names)
				  package)))
	  shadowing-import-from)
    (use-package use package)
    (mapc #'(lambda (list)
	      (let ((imported-package (find-package (car list)))
		    (symbol-names (cdr list)))
		(import (mapcar #'(lambda (symbol-name)
				    (find-symbol symbol-name imported-package))
				symbol-names)
			package)))
	  import-from)
    (mapc #'(lambda (symbol-name) (intern symbol-name package)) intern)
    (export export package)
    package))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:87128 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defun,'ensure-package',[name,nicknames,shadow,'shadowing-import-from',use,'import-from',intern,export],[let,[[package,['find-package',name]]],[unless,package,[setq,package,['make-package',name,':nicknames',nicknames]]],[shadow,shadow,package],[mapc,function([lambda,[list],[let,[['imported-package',['find-package',[car,list]]],['symbol-names',[cdr,list]]],['shadowing-import',[mapcar,function([lambda,['symbol-name'],['find-symbol','symbol-name','imported-package']]),'symbol-names'],package]]]),'shadowing-import-from'],['use-package',use,package],[mapc,function([lambda,[list],[let,[['imported-package',['find-package',[car,list]]],['symbol-names',[cdr,list]]],[import,[mapcar,function([lambda,['symbol-name'],['find-symbol','symbol-name','imported-package']]),'symbol-names'],package]]]),'import-from'],[mapc,function([lambda,['symbol-name'],[intern,'symbol-name',package]]),intern],[export,export,package],package]]).
wl:lambda_def(defun, sys_ensure_package, f_sys_ensure_package, [sys_name, sys_nicknames, shadow, sys_shadowing_import_from, sys_use, sys_import_from, intern, export], [[let, [[package, [find_package, sys_name]]], [unless, package, [setq, package, [make_package, sys_name, kw_nicknames, sys_nicknames]]], [shadow, shadow, package], [mapc, function([lambda, [list], [let, [[sys_imported_package, [find_package, [car, list]]], [sys_symbol_names, [cdr, list]]], [shadowing_import, [mapcar, function([lambda, [symbol_name], [find_symbol, symbol_name, sys_imported_package]]), sys_symbol_names], package]]]), sys_shadowing_import_from], [use_package, sys_use, package], [mapc, function([lambda, [list], [let, [[sys_imported_package, [find_package, [car, list]]], [sys_symbol_names, [cdr, list]]], [import, [mapcar, function([lambda, [symbol_name], [find_symbol, symbol_name, sys_imported_package]]), sys_symbol_names], package]]]), sys_import_from], [mapc, function([lambda, [symbol_name], [intern, symbol_name, package]]), intern], [export, export, package], package]]).
wl:arglist_info(sys_ensure_package, f_sys_ensure_package, [sys_name, sys_nicknames, shadow, sys_shadowing_import_from, sys_use, sys_import_from, intern, export], arginfo{all:[sys_name, sys_nicknames, shadow, sys_shadowing_import_from, sys_use, sys_import_from, intern, export], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_name, sys_nicknames, shadow, sys_shadowing_import_from, sys_use, sys_import_from, intern, export], opt:0, req:[sys_name, sys_nicknames, shadow, sys_shadowing_import_from, sys_use, sys_import_from, intern, export], rest:0, sublists:0, whole:0}).
wl: init_args(exact_only, f_sys_ensure_package).

/*

### Compiled:  `SYS::ENSURE-PACKAGE` 
*/
f_sys_ensure_package(Name_In, Nicknames_In, Shadow_In, Shadowing_import_from_In, Use_In, Import_from_In, Intern_In, Export_In, FnResult) :-
	Env73=[bv(sys_name, Name_In), bv(sys_nicknames, Nicknames_In), bv(shadow, Shadow_In), bv(sys_shadowing_import_from, Shadowing_import_from_In), bv(sys_use, Use_In), bv(sys_import_from, Import_from_In), bv(intern, Intern_In), bv(export, Export_In)|Env],
	global_env(Env),
	catch(( get_var(Env73, sys_name, Name_Get),
		cl_find_package(Name_Get, Package_Init),
		LEnv=[bv(package, Package_Init)|Env73],
		get_var(LEnv, package, IFTEST),
		(   IFTEST\==[]
		->  _321544930=[]
		;   get_var(LEnv, sys_name, Name_Get20),
		    get_var(LEnv, sys_nicknames, Nicknames_Get),
		    cl_make_package(Name_Get20,
				    [kw_nicknames, Nicknames_Get],
				    ElseResult),
		    set_var(LEnv, package, ElseResult),
		    _321544930=ElseResult
		),
		get_var(LEnv, package, Package_Get24),
		get_var(LEnv, shadow, Shadow_Get),
		cl_shadow(Shadow_Get, Package_Get24, Shadow_Ret),
		get_var(LEnv,
			sys_shadowing_import_from,
			Shadowing_import_from_Get),
		cl_mapc(closure(LEnv40,
				LetResult26,
				[list],
				(get_var(LEnv40, list, List_Get), cl_car(List_Get, Find_package_Param), cl_find_package(Find_package_Param, Imported_package_Init), get_var(LEnv40, list, List_Get29), cl_cdr(List_Get29, Symbol_names_Init), LEnv27=[bv(sys_imported_package, Imported_package_Init), bv(sys_symbol_names, Symbol_names_Init)|LEnv40], get_var(LEnv27, sys_symbol_names, Symbol_names_Get), cl_mapcar(closure(LEnv35, LResult, [symbol_name],  (get_var(LEnv35, symbol_name, Symbol_name_Get), get_var(LEnv35, sys_imported_package, Imported_package_Get), cl_find_symbol(Symbol_name_Get, Imported_package_Get, LResult))), Symbol_names_Get, Shadowing_import_Param), get_var(LEnv27, package, Package_Get38), cl_shadowing_import(Shadowing_import_Param, Package_Get38, LetResult26))),
			Shadowing_import_from_Get,
			Mapc_Ret),
		get_var(LEnv, package, Package_Get44),
		get_var(LEnv, sys_use, Use_Get),
		cl_use_package(Use_Get, Package_Get44, Use_package_Ret),
		get_var(LEnv, sys_import_from, Import_from_Get),
		cl_mapc(closure(LEnv60,
				LetResult46,
				[list],
				(get_var(LEnv60, list, List_Get48), cl_car(List_Get48, Find_package_Param76), cl_find_package(Find_package_Param76, Imported_package_Init50), get_var(LEnv60, list, List_Get49), cl_cdr(List_Get49, Symbol_names_Init51), LEnv47=[bv(sys_imported_package, Imported_package_Init50), bv(sys_symbol_names, Symbol_names_Init51)|LEnv60], get_var(LEnv47, sys_symbol_names, Symbol_names_Get57), cl_mapcar(closure(LEnv55, LResult54, [symbol_name],  (get_var(LEnv55, symbol_name, Symbol_name_Get52), get_var(LEnv55, sys_imported_package, Imported_package_Get53), cl_find_symbol(Symbol_name_Get52, Imported_package_Get53, LResult54))), Symbol_names_Get57, Import_Param), get_var(LEnv47, package, Package_Get58), cl_import(Import_Param, Package_Get58, LetResult46))),
			Import_from_Get,
			Mapc_Ret81),
		get_var(LEnv, intern, Intern_Get),
		cl_mapc(closure(LEnv66,
				LResult65,
				[symbol_name],
				(get_var(LEnv66, package, Package_Get64), get_var(LEnv66, symbol_name, Symbol_name_Get63), cl_intern(Symbol_name_Get63, Package_Get64, LResult65))),
			Intern_Get,
			Mapc_Ret82),
		get_var(LEnv, package, Package_Get69),
		cl_export(export, Package_Get69, Export_Ret),
		get_var(LEnv, package, Package_Get70),
		Package_Get70=FnResult
	      ),
	      block_exit(sys_ensure_package, FnResult),
	      true).
:- set_opv(f_sys_ensure_package, classof, claz_function),
   set_opv(sys_ensure_package, compile_as, kw_function),
   set_opv(sys_ensure_package, function, f_sys_ensure_package),
   DefunResult=sys_ensure_package.
/*
:- side_effect(assert_lsp(sys_ensure_package,
			  lambda_def(defun,
				     sys_ensure_package,
				     f_sys_ensure_package,
				     
				     [ sys_name,
				       sys_nicknames,
				       shadow,
				       sys_shadowing_import_from,
				       sys_use,
				       sys_import_from,
				       intern,
				       export
				     ],
				     
				     [ 
				       [ let,
					 [[package, [find_package, sys_name]]],
					 
					 [ unless,
					   package,
					   
					   [ setq,
					     package,
					     
					     [ make_package,
					       sys_name,
					       kw_nicknames,
					       sys_nicknames
					     ]
					   ]
					 ],
					 [shadow, shadow, package],
					 
					 [ mapc,
					   function(
						    [ lambda,
						      [list],
						      
						      [ let,
							
							[ 
							  [ sys_imported_package,
							    
							    [ find_package,
							      [car, list]
							    ]
							  ],
							  
							  [ sys_symbol_names,
							    [cdr, list]
							  ]
							],
							
							[ shadowing_import,
							  
							  [ mapcar,
							    function(
								     [ lambda,
								       [symbol_name],
								       
								       [ find_symbol,
									 symbol_name,
									 sys_imported_package
								       ]
								     ]),
							    sys_symbol_names
							  ],
							  package
							]
						      ]
						    ]),
					   sys_shadowing_import_from
					 ],
					 [use_package, sys_use, package],
					 
					 [ mapc,
					   function(
						    [ lambda,
						      [list],
						      
						      [ let,
							
							[ 
							  [ sys_imported_package,
							    
							    [ find_package,
							      [car, list]
							    ]
							  ],
							  
							  [ sys_symbol_names,
							    [cdr, list]
							  ]
							],
							
							[ import,
							  
							  [ mapcar,
							    function(
								     [ lambda,
								       [symbol_name],
								       
								       [ find_symbol,
									 symbol_name,
									 sys_imported_package
								       ]
								     ]),
							    sys_symbol_names
							  ],
							  package
							]
						      ]
						    ]),
					   sys_import_from
					 ],
					 
					 [ mapc,
					   function(
						    [ lambda,
						      [symbol_name],
						      
						      [ intern,
							symbol_name,
							package
						      ]
						    ]),
					   intern
					 ],
					 [export, export, package],
					 package
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(sys_ensure_package,
			  arglist_info(sys_ensure_package,
				       f_sys_ensure_package,
				       
				       [ sys_name,
					 sys_nicknames,
					 shadow,
					 sys_shadowing_import_from,
					 sys_use,
					 sys_import_from,
					 intern,
					 export
				       ],
				       arginfo{ all:
						    [ sys_name,
						      sys_nicknames,
						      shadow,
						      sys_shadowing_import_from,
						      sys_use,
						      sys_import_from,
						      intern,
						      export
						    ],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:0,
						env:0,
						key:0,
						names:
						      [ sys_name,
							sys_nicknames,
							shadow,
							sys_shadowing_import_from,
							sys_use,
							sys_import_from,
							intern,
							export
						      ],
						opt:0,
						req:
						    [ sys_name,
						      sys_nicknames,
						      shadow,
						      sys_shadowing_import_from,
						      sys_use,
						      sys_import_from,
						      intern,
						      export
						    ],
						rest:0,
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(sys_ensure_package,
			  init_args(exact_only, f_sys_ensure_package))).
*/
/*
#+WAM-CL
#+(or WAM-CL LISP500) 
(defmacro defpackage (defined-package-name &rest options)
  (flet ((option (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (mapcar #'designator-string (cdr option))))
		   options))
	 (options (option-name)
	   (mapcan #'(lambda (option)
		       (when (eq (car option) option-name)
			 (list (mapcar #'designator-string (cdr option)))))
		   options)))
    `(ensure-package ,(designator-string defined-package-name)
      ,(option :nicknames)
      ,(option :shadow) ,(options :shadowing-import-from) ,(option :use)
      ,(options :import-from) ,(option :intern) ,(option :export))))



*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:88151 **********************/
:-lisp_compile_to_prolog(pkg_sys,[defmacro,defpackage,['defined-package-name','&rest',options],[flet,[[option,['option-name'],[mapcan,function([lambda,[option],[when,[eq,[car,option],'option-name'],[mapcar,function('designator-string'),[cdr,option]]]]),options]],[options,['option-name'],[mapcan,function([lambda,[option],[when,[eq,[car,option],'option-name'],[list,[mapcar,function('designator-string'),[cdr,option]]]]]),options]]],['#BQ',['ensure-package',['#COMMA',['designator-string','defined-package-name']],['#COMMA',[option,':nicknames']],['#COMMA',[option,':shadow']],['#COMMA',[options,':shadowing-import-from']],['#COMMA',[option,':use']],['#COMMA',[options,':import-from']],['#COMMA',[option,':intern']],['#COMMA',[option,':export']]]]]]).
wl:lambda_def(defmacro, defpackage, cl_defpackage, [sys_defined_package_name, c38_rest, sys_options], [progn, [flet, [[sys_option, [sys_option_name], [mapcan, function([lambda, [sys_option], [when, [eq, [car, sys_option], sys_option_name], [mapcar, function(sys_designator_string), [cdr, sys_option]]]]), sys_options]], [sys_options, [sys_option_name], [mapcan, function([lambda, [sys_option], [when, [eq, [car, sys_option], sys_option_name], [list, [mapcar, function(sys_designator_string), [cdr, sys_option]]]]]), sys_options]]], ['#BQ', [sys_ensure_package, ['#COMMA', [sys_designator_string, sys_defined_package_name]], ['#COMMA', [sys_option, kw_nicknames]], ['#COMMA', [sys_option, kw_shadow]], ['#COMMA', [sys_options, kw_shadowing_import_from]], ['#COMMA', [sys_option, kw_use]], ['#COMMA', [sys_options, kw_import_from]], ['#COMMA', [sys_option, kw_intern]], ['#COMMA', [sys_option, kw_export]]]]]]).
wl:arglist_info(defpackage, cl_defpackage, [sys_defined_package_name, c38_rest, sys_options], arginfo{all:[sys_defined_package_name], allow_other_keys:0, aux:0, body:0, complex:[rest], env:0, key:0, names:[sys_defined_package_name, sys_options], opt:0, req:[sys_defined_package_name], rest:[sys_options], sublists:0, whole:0}).
wl: init_args(1, cl_defpackage).

/*

### Compiled:  `CL:DEFPACKAGE` 
*/
cl_defpackage(Defined_package_name_In, RestNKeys, FnResult) :-
	nop(defmacro),
	Env=[bv(sys_defined_package_name, Defined_package_name_In), bv(sys_options, RestNKeys)|CDR],
	global_env(CDR),
	catch(( assert_lsp(sys_option,
			   wl:lambda_def(defun, sys_option, f_sys_option1, [sys_option_name], [[mapcan, function([lambda, [sys_option], [when, [eq, [car, sys_option], sys_option_name], [mapcar, function(sys_designator_string), [cdr, sys_option]]]]), sys_options]])),
		assert_lsp(sys_option,
			   wl:arglist_info(sys_option, f_sys_option1, [sys_option_name], arginfo{all:[sys_option_name], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_option_name], opt:0, req:[sys_option_name], rest:0, sublists:0, whole:0})), !,
		assert_lsp(sys_option, wl:init_args(exact_only, f_sys_option1)),
		assert_lsp(sys_option,
			   (f_sys_option1(Option_name_In, FnResult7):-Env39=[bv(sys_option_name, Option_name_In)|Env], global_env(Env), catch((get_var(Env39, sys_options, Options_Get), cl_mapcan(closure(LEnv, LResult, [sys_option],  (get_var(LEnv, sys_option, Option_Get), cl_car(Option_Get, PredArg1Result), get_var(LEnv, sys_option_name, Option_name_Get), (is_eq(PredArg1Result, Option_name_Get)->get_var(LEnv, sys_option, Option_Get15), cl_cdr(Option_Get15, KeysNRest), cl_mapcar(f_sys_designator_string, KeysNRest, TrueResult), LResult=TrueResult;LResult=[]))), Options_Get, Mapcan_Ret), Mapcan_Ret=FnResult7), block_exit(sys_option, FnResult7), true))),
		assert_lsp(sys_options,
			   wl:lambda_def(defun, sys_options, f_sys_options1, [sys_option_name], [[mapcan, function([lambda, [sys_option], [when, [eq, [car, sys_option], sys_option_name], [list, [mapcar, function(sys_designator_string), [cdr, sys_option]]]]]), sys_options]])),
		assert_lsp(sys_options,
			   wl:arglist_info(sys_options, f_sys_options1, [sys_option_name], arginfo{all:[sys_option_name], allow_other_keys:0, aux:0, body:0, complex:0, env:0, key:0, names:[sys_option_name], opt:0, req:[sys_option_name], rest:0, sublists:0, whole:0})), !,
		assert_lsp(sys_options,
			   wl:init_args(exact_only, f_sys_options1)),
		assert_lsp(sys_options,
			   (f_sys_options1(Option_name_In23, FnResult22):-Env40=[bv(sys_option_name, Option_name_In23)|Env], global_env(Env), catch((get_var(Env40, sys_options, Options_Get35), cl_mapcan(closure(LEnv33, LResult32, [sys_option],  (get_var(LEnv33, sys_option, Option_Get25), cl_car(Option_Get25, PredArg1Result28), get_var(LEnv33, sys_option_name, Option_name_Get26), (is_eq(PredArg1Result28, Option_name_Get26)->get_var(LEnv33, sys_option, Option_Get30), cl_cdr(Option_Get30, KeysNRest42), cl_mapcar(f_sys_designator_string, KeysNRest42, Mapcar_Ret), TrueResult31=Mapcar_Ret, LResult32=TrueResult31;LResult32=[]))), Options_Get35, Mapcan_Ret45), Mapcan_Ret45=FnResult22), block_exit(sys_options, FnResult22), true))),
		get_var(
			[ 
			  [ fbound(sys_option)=bound_type(kw_function, f_sys_option1),
			    fbound(sys_options)=bound_type(kw_function, f_sys_options1)
			  ]
			| Env
			],
			sys_defined_package_name,
			Defined_package_name_Get),
		f_sys_designator_string(Defined_package_name_Get,
					Designator_string_Ret),
		f_sys_option1(kw_nicknames, Option1_Ret),
		f_sys_option1(kw_shadow, Option1_Ret49),
		f_sys_options1(kw_shadowing_import_from, Options1_Ret),
		f_sys_option1(kw_use, Option1_Ret51),
		f_sys_options1(kw_import_from, Options1_Ret52),
		f_sys_option1(kw_intern, Option1_Ret53),
		f_sys_option1(kw_export, Option1_Ret54),
		[sys_ensure_package, Designator_string_Ret, Option1_Ret, Option1_Ret49, Options1_Ret, Option1_Ret51, Options1_Ret52, Option1_Ret53, Option1_Ret54]=MFResult
	      ),
	      block_exit(defpackage, MFResult),
	      true),
	cl_eval(MFResult, FnResult).
:- set_opv(cl_defpackage, classof, claz_macro),
   set_opv(defpackage, compile_as, kw_operator),
   set_opv(defpackage, function, cl_defpackage),
   DefMacroResult=defpackage.
/*
:- side_effect(assert_lsp(defpackage,
			  lambda_def(defmacro,
				     defpackage,
				     cl_defpackage,
				     
				     [ sys_defined_package_name,
				       c38_rest,
				       sys_options
				     ],
				     
				     [ progn,
				       
				       [ flet,
					 
					 [ 
					   [ sys_option,
					     [sys_option_name],
					     
					     [ mapcan,
					       function(
							[ lambda,
							  [sys_option],
							  
							  [ when,
							    
							    [ eq,
							      [car, sys_option],
							      sys_option_name
							    ],
							    
							    [ mapcar,
							      function(sys_designator_string),
							      [cdr, sys_option]
							    ]
							  ]
							]),
					       sys_options
					     ]
					   ],
					   
					   [ sys_options,
					     [sys_option_name],
					     
					     [ mapcan,
					       function(
							[ lambda,
							  [sys_option],
							  
							  [ when,
							    
							    [ eq,
							      [car, sys_option],
							      sys_option_name
							    ],
							    
							    [ list,
							      
							      [ mapcar,
								function(sys_designator_string),
								[cdr, sys_option]
							      ]
							    ]
							  ]
							]),
					       sys_options
					     ]
					   ]
					 ],
					 
					 [ '#BQ',
					   
					   [ sys_ensure_package,
					     
					     [ '#COMMA',
					       
					       [ sys_designator_string,
						 sys_defined_package_name
					       ]
					     ],
					     
					     [ '#COMMA',
					       [sys_option, kw_nicknames]
					     ],
					     ['#COMMA', [sys_option, kw_shadow]],
					     
					     [ '#COMMA',
					       
					       [ sys_options,
						 kw_shadowing_import_from
					       ]
					     ],
					     ['#COMMA', [sys_option, kw_use]],
					     
					     [ '#COMMA',
					       [sys_options, kw_import_from]
					     ],
					     ['#COMMA', [sys_option, kw_intern]],
					     ['#COMMA', [sys_option, kw_export]]
					   ]
					 ]
				       ]
				     ]))).
*/
/*
:- side_effect(assert_lsp(defpackage,
			  arglist_info(defpackage,
				       cl_defpackage,
				       
				       [ sys_defined_package_name,
					 c38_rest,
					 sys_options
				       ],
				       arginfo{ all:[sys_defined_package_name],
						allow_other_keys:0,
						aux:0,
						body:0,
						complex:[rest],
						env:0,
						key:0,
						names:
						      [ sys_defined_package_name,
							sys_options
						      ],
						opt:0,
						req:[sys_defined_package_name],
						rest:[sys_options],
						sublists:0,
						whole:0
					      }))).
*/
/*
:- side_effect(assert_lsp(defpackage, init_args(1, cl_defpackage))).
*/
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defun backquote-expand (list level)
  (if (consp list) 
      (if (eq 'backquote (car list)) 
	  (list 'list ''backquote 
		(backquote-expand (car (cdr list)) (+ level 1))) 
	  (if (eq 'unquote (car list)) 
	      (if (= level 0) 
		  (car (cdr list)) 
		  (list 'list ''unquote 
			(backquote-expand (car (cdr list)) (- level 1)))) 
	      (if (eq 'unquote-splicing (car list)) 
		  (if (= level 0) 
		      (values (car (cdr list)) t) 
		      (list 'list ''unquote-splicing 
			    (backquote-expand (car (cdr list)) (- level 1)))) 
		  (labels ((collect (list) 
			     (if (consp list) 
				 (cons (multiple-value-call 
					   #'(lambda (value 
						      &optional splicingp) 
					       (if splicingp 
						   value 
						   (list 'list value))) 
				       (backquote-expand (car list) level)) 
				     (collect (cdr list))) 
				 (list (list 'quote list))))) 
		    (cons 'append (collect list)))))) 
      (list 'quote list))) 

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:88838 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defun,'backquote-expand',[list,level],[if,[consp,list],[if,[eq,[quote,backquote],[car,list]],[list,[quote,list],[quote,[quote,backquote]],['backquote-expand',[car,[cdr,list]],[+,level,1]]],[if,[eq,[quote,unquote],[car,list]],[if,[=,level,0],[car,[cdr,list]],[list,[quote,list],[quote,[quote,unquote]],['backquote-expand',[car,[cdr,list]],[-,level,1]]]],[if,[eq,[quote,'unquote-splicing'],[car,list]],[if,[=,level,0],[values,[car,[cdr,list]],t],[list,[quote,list],[quote,[quote,'unquote-splicing']],['backquote-expand',[car,[cdr,list]],[-,level,1]]]],[labels,[[collect,[list],[if,[consp,list],[cons,['multiple-value-call',function([lambda,[value,'&optional',splicingp],[if,splicingp,value,[list,[quote,list],value]]]),['backquote-expand',[car,list],level]],[collect,[cdr,list]]],[list,[list,[quote,quote],list]]]]],[cons,[quote,append],[collect,list]]]]]],[list,[quote,quote],list]]]]]))
/*
#+BUILTIN
#+(or WAM-CL LISP500) 
(defmacro backquote (form)
  (backquote-expand form 0))

*/

/*********** /home/dmiles/logicmoo_workspace/packs_usr/wam_common_lisp/prolog/wam_cl/wam-cl-init-1.lisp:89848 **********************/
:-lisp_compile_to_prolog(pkg_sys,'$COMMENT'([flag_removed,[+,':BUILTIN'],[#+,[':or',':WAM-CL',':LISP500'],[defmacro,backquote,[form],['backquote-expand',form,0]]]]))

%; Total compilation time: 66.035 seconds

